begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hist.c  -  Histogram related operations.     Copyright 1999, 2000, 2001, 2002, 2004, 2005    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"corefile.h"
end_include

begin_include
include|#
directive|include
file|"gmon_io.h"
end_include

begin_include
include|#
directive|include
file|"gmon_out.h"
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_include
include|#
directive|include
file|"sym_ids.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_define
define|#
directive|define
name|UNITS_TO_CODE
value|(offset_to_code / sizeof(UNIT))
end_define

begin_function_decl
specifier|static
name|void
name|scale_and_align_entries
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_header
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_line
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_time
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declarations of automatically generated functions to output blurbs.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|flat_blurb
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|bfd_vma
name|s_lowpc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lowest address in .text.  */
end_comment

begin_decl_stmt
name|bfd_vma
name|s_highpc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest address in .text.  */
end_comment

begin_decl_stmt
name|bfd_vma
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same, but expressed in UNITs.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|hist_num_bins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of histogram samples.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|hist_sample
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Histogram samples (shorts in the file!).  */
end_comment

begin_decl_stmt
name|double
name|hist_scale
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|hist_dimension
index|[
literal|16
index|]
init|=
literal|"seconds"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|hist_dimension_abbrev
init|=
literal|'s'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|accum_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accumulated time so far for print_line(). */
end_comment

begin_decl_stmt
specifier|static
name|double
name|total_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total time for all routines.  */
end_comment

begin_comment
comment|/* Table of SI prefixes for powers of 10 (used to automatically    scale some of the values in the flat profile).  */
end_comment

begin_struct
specifier|const
struct|struct
block|{
name|char
name|prefix
decl_stmt|;
name|double
name|scale
decl_stmt|;
block|}
name|SItab
index|[]
init|=
block|{
block|{
literal|'T'
block|,
literal|1e-12
block|}
block|,
comment|/* tera */
block|{
literal|'G'
block|,
literal|1e-09
block|}
block|,
comment|/* giga */
block|{
literal|'M'
block|,
literal|1e-06
block|}
block|,
comment|/* mega */
block|{
literal|'K'
block|,
literal|1e-03
block|}
block|,
comment|/* kilo */
block|{
literal|' '
block|,
literal|1e-00
block|}
block|,
block|{
literal|'m'
block|,
literal|1e+03
block|}
block|,
comment|/* milli */
block|{
literal|'u'
block|,
literal|1e+06
block|}
block|,
comment|/* micro */
block|{
literal|'n'
block|,
literal|1e+09
block|}
block|,
comment|/* nano */
block|{
literal|'p'
block|,
literal|1e+12
block|}
block|,
comment|/* pico */
block|{
literal|'f'
block|,
literal|1e+15
block|}
block|,
comment|/* femto */
block|{
literal|'a'
block|,
literal|1e+18
block|}
comment|/* ato */
block|}
struct|;
end_struct

begin_comment
comment|/* Read the histogram from file IFP.  FILENAME is the name of IFP and    is provided for formatting error messages only.  */
end_comment

begin_function
name|void
name|hist_read_rec
parameter_list|(
name|FILE
modifier|*
name|ifp
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|bfd_vma
name|n_lowpc
decl_stmt|,
name|n_highpc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|ncnt
decl_stmt|,
name|profrate
decl_stmt|;
name|UNIT
name|count
decl_stmt|;
if|if
condition|(
name|gmon_io_read_vma
argument_list|(
name|ifp
argument_list|,
operator|&
name|n_lowpc
argument_list|)
operator|||
name|gmon_io_read_vma
argument_list|(
name|ifp
argument_list|,
operator|&
name|n_highpc
argument_list|)
operator|||
name|gmon_io_read_32
argument_list|(
name|ifp
argument_list|,
operator|&
name|ncnt
argument_list|)
operator|||
name|gmon_io_read_32
argument_list|(
name|ifp
argument_list|,
operator|&
name|profrate
argument_list|)
operator|||
name|gmon_io_read
argument_list|(
name|ifp
argument_list|,
name|hist_dimension
argument_list|,
literal|15
argument_list|)
operator|||
name|gmon_io_read
argument_list|(
name|ifp
argument_list|,
operator|&
name|hist_dimension_abbrev
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s: unexpected end of file\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s_highpc
condition|)
block|{
comment|/* This is the first histogram record.  */
name|s_lowpc
operator|=
name|n_lowpc
expr_stmt|;
name|s_highpc
operator|=
name|n_highpc
expr_stmt|;
name|lowpc
operator|=
operator|(
name|bfd_vma
operator|)
name|n_lowpc
operator|/
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
expr_stmt|;
name|highpc
operator|=
operator|(
name|bfd_vma
operator|)
name|n_highpc
operator|/
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
expr_stmt|;
name|hist_num_bins
operator|=
name|ncnt
expr_stmt|;
name|hz
operator|=
name|profrate
expr_stmt|;
block|}
name|DBG
argument_list|(
argument|SAMPLEDEBUG
argument_list|,
argument|printf (
literal|"[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %u\n"
argument|, 	       (unsigned long) n_lowpc, (unsigned long) n_highpc, ncnt);        printf (
literal|"[hist_read_rec] s_lowpc 0x%lx s_highpc 0x%lx nsamples %u\n"
argument|, 	       (unsigned long) s_lowpc, (unsigned long) s_highpc, 	       hist_num_bins);        printf (
literal|"[hist_read_rec]   lowpc 0x%lx   highpc 0x%lx\n"
argument|, 	       (unsigned long) lowpc, (unsigned long) highpc)
argument_list|)
empty_stmt|;
if|if
condition|(
name|n_lowpc
operator|!=
name|s_lowpc
operator|||
name|n_highpc
operator|!=
name|s_highpc
operator|||
name|ncnt
operator|!=
name|hist_num_bins
operator|||
name|hz
operator|!=
operator|(
name|int
operator|)
name|profrate
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: `%s' is incompatible with first gmon file\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hist_sample
condition|)
block|{
name|hist_sample
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|hist_num_bins
operator|*
sizeof|sizeof
argument_list|(
name|hist_sample
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hist_sample
argument_list|,
literal|0
argument_list|,
name|hist_num_bins
operator|*
sizeof|sizeof
argument_list|(
name|hist_sample
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hist_num_bins
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|count
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s: unexpected EOF after reading %u of %u samples\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|filename
argument_list|,
name|i
argument_list|,
name|hist_num_bins
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hist_sample
index|[
name|i
index|]
operator|+=
name|bfd_get_16
argument_list|(
name|core_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|count
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|SAMPLEDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[hist_read_rec] 0x%lx: %u\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|n_lowpc
operator|+
name|i
operator|*
operator|(
name|n_highpc
operator|-
name|n_lowpc
operator|)
operator|/
name|ncnt
argument_list|)
argument_list|,
name|hist_sample
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write execution histogram to file OFP.  FILENAME is the name    of OFP and is provided for formatting error-messages only.  */
end_comment

begin_function
name|void
name|hist_write_hist
parameter_list|(
name|FILE
modifier|*
name|ofp
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|UNIT
name|count
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Write header.  */
if|if
condition|(
name|gmon_io_write_8
argument_list|(
name|ofp
argument_list|,
name|GMON_TAG_TIME_HIST
argument_list|)
operator|||
name|gmon_io_write_vma
argument_list|(
name|ofp
argument_list|,
name|s_lowpc
argument_list|)
operator|||
name|gmon_io_write_vma
argument_list|(
name|ofp
argument_list|,
name|s_highpc
argument_list|)
operator|||
name|gmon_io_write_32
argument_list|(
name|ofp
argument_list|,
name|hist_num_bins
argument_list|)
operator|||
name|gmon_io_write_32
argument_list|(
name|ofp
argument_list|,
name|hz
argument_list|)
operator|||
name|gmon_io_write
argument_list|(
name|ofp
argument_list|,
name|hist_dimension
argument_list|,
literal|15
argument_list|)
operator|||
name|gmon_io_write
argument_list|(
name|ofp
argument_list|,
operator|&
name|hist_dimension_abbrev
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hist_num_bins
condition|;
operator|++
name|i
control|)
block|{
name|bfd_put_16
argument_list|(
name|core_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|hist_sample
index|[
name|i
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|count
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|count
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ofp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Calculate scaled entry point addresses (to save time in    hist_assign_samples), and, on architectures that have procedure    entry masks at the start of a function, possibly push the scaled    entry points over the procedure entry mask, if it turns out that    the entry point is in one bin and the code for a routine is in the    next bin.  */
end_comment

begin_function
specifier|static
name|void
name|scale_and_align_entries
parameter_list|()
block|{
name|Sym
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|bin_of_entry
decl_stmt|;
name|bfd_vma
name|bin_of_code
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
name|sym
operator|++
control|)
block|{
name|sym
operator|->
name|hist
operator|.
name|scaled_addr
operator|=
name|sym
operator|->
name|addr
operator|/
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
expr_stmt|;
name|bin_of_entry
operator|=
operator|(
name|sym
operator|->
name|hist
operator|.
name|scaled_addr
operator|-
name|lowpc
operator|)
operator|/
name|hist_scale
expr_stmt|;
name|bin_of_code
operator|=
operator|(
operator|(
name|sym
operator|->
name|hist
operator|.
name|scaled_addr
operator|+
name|UNITS_TO_CODE
operator|-
name|lowpc
operator|)
operator|/
name|hist_scale
operator|)
expr_stmt|;
if|if
condition|(
name|bin_of_entry
operator|<
name|bin_of_code
condition|)
block|{
name|DBG
argument_list|(
name|SAMPLEDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[scale_and_align_entries] pushing 0x%lx to 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
operator|->
name|hist
operator|.
name|scaled_addr
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sym
operator|->
name|hist
operator|.
name|scaled_addr
operator|+
name|UNITS_TO_CODE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|hist
operator|.
name|scaled_addr
operator|+=
name|UNITS_TO_CODE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Assign samples to the symbol to which they belong.     Histogram bin I covers some address range [BIN_LOWPC,BIN_HIGH_PC)    which may overlap one more symbol address ranges.  If a symbol    overlaps with the bin's address range by O percent, then O percent    of the bin's count is credited to that symbol.     There are three cases as to where BIN_LOW_PC and BIN_HIGH_PC can be    with respect to the symbol's address range [SYM_LOW_PC,    SYM_HIGH_PC) as shown in the following diagram.  OVERLAP computes    the distance (in UNITs) between the arrows, the fraction of the    sample that is to be credited to the symbol which starts at    SYM_LOW_PC.  	  sym_low_pc                                      sym_high_pc 	       |                                               | 	       v                                               v  	       +-----------------------------------------------+ 	       |                                               | 	  |  ->|    |<-         ->|         |<-         ->|    |<-  | 	  |         |             |         |             |         | 	  +---------+             +---------+             +---------+  	  ^         ^             ^         ^             ^         ^ 	  |         |             |         |             |         |      bin_low_pc bin_high_pc  bin_low_pc bin_high_pc  bin_low_pc bin_high_pc     For the VAX we assert that samples will never fall in the first two    bytes of any routine, since that is the entry mask, thus we call    scale_and_align_entries() to adjust the entry points if the entry    mask falls in one bin but the code for the routine doesn't start    until the next bin.  In conjunction with the alignment of routine    addresses, this should allow us to have only one sample for every    four bytes of text space and never have any overlap (the two end    cases, above).  */
end_comment

begin_function
name|void
name|hist_assign_samples
parameter_list|()
block|{
name|bfd_vma
name|bin_low_pc
decl_stmt|,
name|bin_high_pc
decl_stmt|;
name|bfd_vma
name|sym_low_pc
decl_stmt|,
name|sym_high_pc
decl_stmt|;
name|bfd_vma
name|overlap
decl_stmt|,
name|addr
decl_stmt|;
name|unsigned
name|int
name|bin_count
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|double
name|time
decl_stmt|,
name|credit
decl_stmt|;
comment|/* Read samples and assign to symbols.  */
name|hist_scale
operator|=
name|highpc
operator|-
name|lowpc
expr_stmt|;
name|hist_scale
operator|/=
name|hist_num_bins
expr_stmt|;
name|scale_and_align_entries
argument_list|()
expr_stmt|;
comment|/* Iterate over all sample bins.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|hist_num_bins
condition|;
operator|++
name|i
control|)
block|{
name|bin_count
operator|=
name|hist_sample
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bin_count
condition|)
continue|continue;
name|bin_low_pc
operator|=
name|lowpc
operator|+
call|(
name|bfd_vma
call|)
argument_list|(
name|hist_scale
operator|*
name|i
argument_list|)
expr_stmt|;
name|bin_high_pc
operator|=
name|lowpc
operator|+
call|(
name|bfd_vma
call|)
argument_list|(
name|hist_scale
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|time
operator|=
name|bin_count
expr_stmt|;
name|DBG
argument_list|(
name|SAMPLEDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[assign_samples] bin_low_pc=0x%lx, bin_high_pc=0x%lx, bin_count=%u\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
operator|*
name|bin_low_pc
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
operator|*
name|bin_high_pc
argument_list|)
argument_list|,
name|bin_count
argument_list|)
argument_list|)
expr_stmt|;
name|total_time
operator|+=
name|time
expr_stmt|;
comment|/* Credit all symbols that are covered by bin I.  */
for|for
control|(
name|j
operator|=
name|j
operator|-
literal|1
init|;
name|j
operator|<
name|symtab
operator|.
name|len
condition|;
operator|++
name|j
control|)
block|{
name|sym_low_pc
operator|=
name|symtab
operator|.
name|base
index|[
name|j
index|]
operator|.
name|hist
operator|.
name|scaled_addr
expr_stmt|;
name|sym_high_pc
operator|=
name|symtab
operator|.
name|base
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|hist
operator|.
name|scaled_addr
expr_stmt|;
comment|/* If high end of bin is below entry address, 	     go for next bin.  */
if|if
condition|(
name|bin_high_pc
operator|<
name|sym_low_pc
condition|)
break|break;
comment|/* If low end of bin is above high end of symbol, 	     go for next symbol.  */
if|if
condition|(
name|bin_low_pc
operator|>=
name|sym_high_pc
condition|)
continue|continue;
name|overlap
operator|=
name|MIN
argument_list|(
name|bin_high_pc
argument_list|,
name|sym_high_pc
argument_list|)
operator|-
name|MAX
argument_list|(
name|bin_low_pc
argument_list|,
name|sym_low_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlap
operator|>
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|SAMPLEDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symtab
operator|.
name|base
index|[
name|j
index|]
operator|.
name|addr
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
operator|*
name|sym_high_pc
argument_list|)
argument_list|,
name|symtab
operator|.
name|base
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|overlap
operator|*
name|time
operator|/
name|hist_scale
argument_list|,
operator|(
name|long
operator|)
name|overlap
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|symtab
operator|.
name|base
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|credit
operator|=
name|overlap
operator|*
name|time
operator|/
name|hist_scale
expr_stmt|;
comment|/* Credit symbol if it appears in INCL_FLAT or that 		 table is empty and it does not appear it in 		 EXCL_FLAT.  */
if|if
condition|(
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_FLAT
index|]
argument_list|,
name|addr
argument_list|)
operator|||
operator|(
name|syms
index|[
name|INCL_FLAT
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_FLAT
index|]
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
block|{
name|symtab
operator|.
name|base
index|[
name|j
index|]
operator|.
name|hist
operator|.
name|time
operator|+=
name|credit
expr_stmt|;
block|}
else|else
block|{
name|total_time
operator|-=
name|credit
expr_stmt|;
block|}
block|}
block|}
block|}
name|DBG
argument_list|(
name|SAMPLEDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[assign_samples] total_time %f\n"
argument_list|,
name|total_time
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print header for flag histogram profile.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|int
name|prefix
parameter_list|)
block|{
name|char
name|unit
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|unit
argument_list|,
name|_
argument_list|(
literal|"%c%c/call"
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|hist_dimension_abbrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsd_style_output
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ngranularity: each sample hit covers %ld byte(s)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|hist_scale
operator|*
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_time
operator|>
literal|0.0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" for %.2f%% of %.2f %s\n\n"
argument_list|)
argument_list|,
literal|100.0
operator|/
name|total_time
argument_list|,
name|total_time
operator|/
name|hz
argument_list|,
name|hist_dimension
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nEach sample counts as %g %s.\n"
argument_list|)
argument_list|,
literal|1.0
operator|/
name|hz
argument_list|,
name|hist_dimension
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|total_time
operator|<=
literal|0.0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" no time accumulated\n\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This doesn't hurt since all the numerators will be zero.  */
name|total_time
operator|=
literal|1.0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n"
argument_list|,
literal|"%  "
argument_list|,
name|_
argument_list|(
literal|"cumulative"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"self  "
argument_list|)
argument_list|,
literal|""
argument_list|,
name|_
argument_list|(
literal|"self  "
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"total "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5.5s %9.9s  %8.8s %8.8s %8.8s %8.8s  %-8.8s\n"
argument_list|,
name|_
argument_list|(
literal|"time"
argument_list|)
argument_list|,
name|hist_dimension
argument_list|,
name|hist_dimension
argument_list|,
name|_
argument_list|(
literal|"calls"
argument_list|)
argument_list|,
name|unit
argument_list|,
name|unit
argument_list|,
name|_
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
name|Sym
modifier|*
name|sym
parameter_list|,
name|double
name|scale
parameter_list|)
block|{
if|if
condition|(
name|ignore_zeros
operator|&&
name|sym
operator|->
name|ncalls
operator|==
literal|0
operator|&&
name|sym
operator|->
name|hist
operator|.
name|time
operator|==
literal|0
condition|)
return|return;
name|accum_time
operator|+=
name|sym
operator|->
name|hist
operator|.
name|time
expr_stmt|;
if|if
condition|(
name|bsd_style_output
condition|)
name|printf
argument_list|(
literal|"%5.1f %10.2f %8.2f"
argument_list|,
name|total_time
operator|>
literal|0.0
condition|?
literal|100
operator|*
name|sym
operator|->
name|hist
operator|.
name|time
operator|/
name|total_time
else|:
literal|0.0
argument_list|,
name|accum_time
operator|/
name|hz
argument_list|,
name|sym
operator|->
name|hist
operator|.
name|time
operator|/
name|hz
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%6.2f %9.2f %8.2f"
argument_list|,
name|total_time
operator|>
literal|0.0
condition|?
literal|100
operator|*
name|sym
operator|->
name|hist
operator|.
name|time
operator|/
name|total_time
else|:
literal|0.0
argument_list|,
name|accum_time
operator|/
name|hz
argument_list|,
name|sym
operator|->
name|hist
operator|.
name|time
operator|/
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|ncalls
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %8lu %8.2f %8.2f  "
argument_list|,
name|sym
operator|->
name|ncalls
argument_list|,
name|scale
operator|*
name|sym
operator|->
name|hist
operator|.
name|time
operator|/
name|hz
operator|/
name|sym
operator|->
name|ncalls
argument_list|,
name|scale
operator|*
operator|(
name|sym
operator|->
name|hist
operator|.
name|time
operator|+
name|sym
operator|->
name|cg
operator|.
name|child_time
operator|)
operator|/
name|hz
operator|/
name|sym
operator|->
name|ncalls
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %8.8s %8.8s %8.8s  "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsd_style_output
condition|)
name|print_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|print_name_only
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare LP and RP.  The primary comparison key is execution time,    the secondary is number of invocation, and the tertiary is the    lexicographic order of the function names.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_time
parameter_list|(
specifier|const
name|PTR
name|lp
parameter_list|,
specifier|const
name|PTR
name|rp
parameter_list|)
block|{
specifier|const
name|Sym
modifier|*
name|left
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|lp
decl_stmt|;
specifier|const
name|Sym
modifier|*
name|right
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|rp
decl_stmt|;
name|double
name|time_diff
decl_stmt|;
name|time_diff
operator|=
name|right
operator|->
name|hist
operator|.
name|time
operator|-
name|left
operator|->
name|hist
operator|.
name|time
expr_stmt|;
if|if
condition|(
name|time_diff
operator|>
literal|0.0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|time_diff
operator|<
literal|0.0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|right
operator|->
name|ncalls
operator|>
name|left
operator|->
name|ncalls
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|right
operator|->
name|ncalls
operator|<
name|left
operator|->
name|ncalls
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|strcmp
argument_list|(
name|left
operator|->
name|name
argument_list|,
name|right
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print the flat histogram profile.  */
end_comment

begin_function
name|void
name|hist_print
parameter_list|()
block|{
name|Sym
modifier|*
modifier|*
name|time_sorted_syms
decl_stmt|,
modifier|*
name|top_dog
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|unsigned
name|log_scale
decl_stmt|;
name|double
name|top_time
decl_stmt|,
name|time
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
if|if
condition|(
name|first_output
condition|)
name|first_output
operator|=
name|FALSE
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\f\n"
argument_list|)
expr_stmt|;
name|accum_time
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|bsd_style_output
condition|)
block|{
if|if
condition|(
name|print_descriptions
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\n\nflat profile:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|flat_blurb
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flat profile:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the symbol table by time (call-count and name as secondary      and tertiary keys).  */
name|time_sorted_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
operator|++
name|index
control|)
name|time_sorted_syms
index|[
name|index
index|]
operator|=
operator|&
name|symtab
operator|.
name|base
index|[
name|index
index|]
expr_stmt|;
name|qsort
argument_list|(
name|time_sorted_syms
argument_list|,
name|symtab
operator|.
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|,
name|cmp_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsd_style_output
condition|)
block|{
name|log_scale
operator|=
literal|5
expr_stmt|;
comment|/* Milli-seconds is BSD-default.  */
block|}
else|else
block|{
comment|/* Search for symbol with highest per-call 	 execution time and scale accordingly.  */
name|log_scale
operator|=
literal|0
expr_stmt|;
name|top_dog
operator|=
literal|0
expr_stmt|;
name|top_time
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
operator|++
name|index
control|)
block|{
name|sym
operator|=
name|time_sorted_syms
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|ncalls
operator|!=
literal|0
condition|)
block|{
name|time
operator|=
operator|(
name|sym
operator|->
name|hist
operator|.
name|time
operator|+
name|sym
operator|->
name|cg
operator|.
name|child_time
operator|)
operator|/
name|sym
operator|->
name|ncalls
expr_stmt|;
if|if
condition|(
name|time
operator|>
name|top_time
condition|)
block|{
name|top_dog
operator|=
name|sym
expr_stmt|;
name|top_time
operator|=
name|time
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|top_dog
operator|&&
name|top_dog
operator|->
name|ncalls
operator|!=
literal|0
operator|&&
name|top_time
operator|>
literal|0.0
condition|)
block|{
name|top_time
operator|/=
name|hz
expr_stmt|;
for|for
control|(
name|log_scale
operator|=
literal|0
init|;
name|log_scale
operator|<
name|ARRAY_SIZE
argument_list|(
name|SItab
argument_list|)
condition|;
name|log_scale
operator|++
control|)
block|{
name|double
name|scaled_value
init|=
name|SItab
index|[
name|log_scale
index|]
operator|.
name|scale
operator|*
name|top_time
decl_stmt|;
if|if
condition|(
name|scaled_value
operator|>=
literal|1.0
operator|&&
name|scaled_value
operator|<
literal|1000.0
condition|)
break|break;
block|}
block|}
block|}
comment|/* For now, the dimension is always seconds.  In the future, we      may also want to support other (pseudo-)dimensions (such as      I-cache misses etc.).  */
name|print_header
argument_list|(
name|SItab
index|[
name|log_scale
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
operator|++
name|index
control|)
block|{
name|addr
operator|=
name|time_sorted_syms
index|[
name|index
index|]
operator|->
name|addr
expr_stmt|;
comment|/* Print symbol if its in INCL_FLAT table or that table 	is empty and the symbol is not in EXCL_FLAT.  */
if|if
condition|(
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_FLAT
index|]
argument_list|,
name|addr
argument_list|)
operator|||
operator|(
name|syms
index|[
name|INCL_FLAT
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_FLAT
index|]
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
name|print_line
argument_list|(
name|time_sorted_syms
index|[
name|index
index|]
argument_list|,
name|SItab
index|[
name|log_scale
index|]
operator|.
name|scale
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|time_sorted_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_descriptions
operator|&&
operator|!
name|bsd_style_output
condition|)
name|flat_blurb
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

