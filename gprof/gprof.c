begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993, 1998, 2001, 2002  *      The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"bfdver.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"basic_blocks.h"
end_include

begin_include
include|#
directive|include
file|"call_graph.h"
end_include

begin_include
include|#
directive|include
file|"cg_arcs.h"
end_include

begin_include
include|#
directive|include
file|"cg_print.h"
end_include

begin_include
include|#
directive|include
file|"corefile.h"
end_include

begin_include
include|#
directive|include
file|"gmon_io.h"
end_include

begin_include
include|#
directive|include
file|"hertz.h"
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_include
include|#
directive|include
file|"sym_ids.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|whoami
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|function_mapping_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|a_out_name
init|=
name|A_OUTNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|hz
init|=
name|HZ_WRONG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default options values:  */
end_comment

begin_decl_stmt
name|int
name|debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output_style
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output_width
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|bsd_style_output
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|demangle
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|ignore_direct_calls
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|ignore_static_funcs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|ignore_zeros
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|line_granularity
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|print_descriptions
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|print_path
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|ignore_non_functions
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|File_Format
name|file_format
init|=
name|FF_AUTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|first_output
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1983 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gmon_name
init|=
name|GMONNAME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* profile filename */
end_comment

begin_comment
comment|/*  * Functions that get excluded by default:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_excluded_list
index|[]
init|=
block|{
literal|"_gprof_mcount"
block|,
literal|"mcount"
block|,
literal|"_mcount"
block|,
literal|"__mcount"
block|,
literal|"__mcount_internal"
block|,
literal|"__mcleanup"
block|,
literal|"<locore>"
block|,
literal|"<hicore>"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Codes used for the long options with no short synonyms.  150 isn't    special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_DEMANGLE
value|(150)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_DEMANGLE
value|(OPTION_DEMANGLE + 1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"line"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"no-static"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"ignore-non-functions"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'D'
block|}
block|,
comment|/* output styles: */
block|{
literal|"annotated-source"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"no-annotated-source"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'J'
block|}
block|,
block|{
literal|"flat-profile"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"no-flat-profile"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'P'
block|}
block|,
block|{
literal|"graph"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'q'
block|}
block|,
block|{
literal|"no-graph"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'Q'
block|}
block|,
block|{
literal|"exec-counts"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"no-exec-counts"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'Z'
block|}
block|,
block|{
literal|"function-ordering"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"file-ordering"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"file-info"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"sum"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
comment|/* various options to affect output: */
block|{
literal|"all-lines"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"demangle"
block|,
name|optional_argument
block|,
literal|0
block|,
name|OPTION_DEMANGLE
block|}
block|,
block|{
literal|"no-demangle"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_NO_DEMANGLE
block|}
block|,
block|{
literal|"directory-path"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"display-unused-functions"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'z'
block|}
block|,
block|{
literal|"min-count"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'m'
block|}
block|,
block|{
literal|"print-path"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"separate-files"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'y'
block|}
block|,
block|{
literal|"static-call-graph"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"table-length"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"time"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"no-time"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"width"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'w'
block|}
block|,
comment|/*      * These are for backwards-compatibility only.  Their functionality      * is provided by the output style options already:      */
block|{
literal|""
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|""
block|,
name|required_argument
block|,
literal|0
block|,
literal|'E'
block|}
block|,
block|{
literal|""
block|,
name|required_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|""
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|""
block|,
name|required_argument
block|,
literal|0
block|,
literal|'k'
block|}
block|,
comment|/* miscellaneous: */
block|{
literal|"brief"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"debug"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"file-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"traditional"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ Usage: %s [-[abcDhilLsTvwxyz]] [-[ACeEfFJnNOpPqQZ][name]] [-I dirs]\n\ 	[-d[num]] [-k from/to] [-m min-count] [-t table-length]\n\ 	[--[no-]annotated-source[=name]] [--[no-]exec-counts[=name]]\n\ 	[--[no-]flat-profile[=name]] [--[no-]graph[=name]]\n\ 	[--[no-]time=name] [--all-lines] [--brief] [--debug[=level]]\n\ 	[--function-ordering] [--file-ordering]\n\ 	[--directory-path=dirs] [--display-unused-functions]\n\ 	[--file-format=name] [--file-info] [--help] [--line] [--min-count=n]\n\ 	[--no-static] [--print-path] [--separate-files]\n\ 	[--static-call-graph] [--sum] [--table-length=len] [--traditional]\n\ 	[--version] [--width=n] [--ignore-non-functions]\n\ 	[--demangle[=STYLE]] [--no-demangle] [@FILE]\n\ 	[image-file] [profile-file...]\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
if|if
condition|(
name|REPORT_BUGS_TO
index|[
literal|0
index|]
operator|&&
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|sp
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|Sym
modifier|*
modifier|*
name|cg
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|user_specified
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_NLS
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|whoami
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|whoami
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aA::bBcC::d::De:E:f:F:hiI:J::k:lLm:n:N:O:p::P::q::Q::rR:st:Tvw:xyzZ::"
argument_list|,
name|long_options
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|ignore_static_funcs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_ANNO
argument_list|)
expr_stmt|;
block|}
name|output_style
operator||=
name|STYLE_ANNOTATED_SOURCE
expr_stmt|;
name|user_specified
operator||=
name|STYLE_ANNOTATED_SOURCE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|print_descriptions
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|output_style
operator||=
name|STYLE_CALL_GRAPH
expr_stmt|;
name|user_specified
operator||=
name|STYLE_CALL_GRAPH
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ignore_direct_calls
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_EXEC
argument_list|)
expr_stmt|;
block|}
name|output_style
operator||=
name|STYLE_EXEC_COUNTS
expr_stmt|;
name|user_specified
operator||=
name|STYLE_EXEC_COUNTS
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
name|debug_level
operator||=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|debug_level
operator||=
name|ANYDEBUG
expr_stmt|;
block|}
else|else
block|{
name|debug_level
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|DBG
argument_list|(
name|ANYDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[main] debug-level=0x%x\n"
argument_list|,
name|debug_level
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: debugging not supported; -d ignored\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
case|case
literal|'D'
case|:
name|ignore_non_functions
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_TIME
argument_list|)
expr_stmt|;
case|case
literal|'e'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_GRAPH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_TIME
argument_list|)
expr_stmt|;
case|case
literal|'f'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_GRAPH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_FLAT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_FLAT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
name|output_style
operator||=
name|STYLE_GMON_INFO
expr_stmt|;
name|user_specified
operator||=
name|STYLE_GMON_INFO
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|search_list_append
argument_list|(
operator|&
name|src_search_list
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_ANNO
argument_list|)
expr_stmt|;
name|output_style
operator||=
name|STYLE_ANNOTATED_SOURCE
expr_stmt|;
block|}
else|else
block|{
name|output_style
operator|&=
operator|~
name|STYLE_ANNOTATED_SOURCE
expr_stmt|;
block|}
name|user_specified
operator||=
name|STYLE_ANNOTATED_SOURCE
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_ARCS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|line_granularity
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|print_path
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|bb_min_calls
operator|=
operator|(
name|unsigned
name|long
operator|)
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_TIME
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_TIME
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|file_format
operator|=
name|FF_AUTO
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|file_format
operator|=
name|FF_MAGIC
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|file_format
operator|=
name|FF_BSD
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|file_format
operator|=
name|FF_BSD44
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|file_format
operator|=
name|FF_PROF
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unknown file format %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_FLAT
argument_list|)
expr_stmt|;
block|}
name|output_style
operator||=
name|STYLE_FLAT_PROFILE
expr_stmt|;
name|user_specified
operator||=
name|STYLE_FLAT_PROFILE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_FLAT
argument_list|)
expr_stmt|;
name|output_style
operator||=
name|STYLE_FLAT_PROFILE
expr_stmt|;
block|}
else|else
block|{
name|output_style
operator|&=
operator|~
name|STYLE_FLAT_PROFILE
expr_stmt|;
block|}
name|user_specified
operator||=
name|STYLE_FLAT_PROFILE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_ARCS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|INCL_GRAPH
argument_list|)
expr_stmt|;
block|}
block|}
name|output_style
operator||=
name|STYLE_CALL_GRAPH
expr_stmt|;
name|user_specified
operator||=
name|STYLE_CALL_GRAPH
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|output_style
operator||=
name|STYLE_FUNCTION_ORDER
expr_stmt|;
name|user_specified
operator||=
name|STYLE_FUNCTION_ORDER
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|output_style
operator||=
name|STYLE_FILE_ORDER
expr_stmt|;
name|user_specified
operator||=
name|STYLE_FILE_ORDER
expr_stmt|;
name|function_mapping_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_ARCS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_GRAPH
argument_list|)
expr_stmt|;
block|}
name|output_style
operator||=
name|STYLE_CALL_GRAPH
expr_stmt|;
block|}
else|else
block|{
name|output_style
operator|&=
operator|~
name|STYLE_CALL_GRAPH
expr_stmt|;
block|}
name|user_specified
operator||=
name|STYLE_CALL_GRAPH
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|output_style
operator||=
name|STYLE_SUMMARY_FILE
expr_stmt|;
name|user_specified
operator||=
name|STYLE_SUMMARY_FILE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|bb_table_length
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_table_length
operator|<
literal|0
condition|)
block|{
name|bb_table_length
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|bsd_style_output
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* This output is intended to follow the GNU standards document.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"GNU gprof %s\n"
argument_list|)
argument_list|,
name|BFD_VERSION_STRING
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Based on BSD gprof, copyright 1983 Regents of the University of California.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ This program is free software.  This program has absolutely no warranty.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
name|output_width
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_width
operator|<
literal|1
condition|)
block|{
name|output_width
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
name|bb_annotate_all_lines
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|create_annotation_files
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|ignore_zeros
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
name|sym_id_add
argument_list|(
name|optarg
argument_list|,
name|EXCL_EXEC
argument_list|)
expr_stmt|;
name|output_style
operator||=
name|STYLE_EXEC_COUNTS
expr_stmt|;
block|}
else|else
block|{
name|output_style
operator|&=
operator|~
name|STYLE_EXEC_COUNTS
expr_stmt|;
block|}
name|user_specified
operator||=
name|STYLE_ANNOTATED_SOURCE
expr_stmt|;
break|break;
case|case
name|OPTION_DEMANGLE
case|:
name|demangle
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
block|{
name|enum
name|demangling_styles
name|style
decl_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unknown demangling style `%s'\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_NO_DEMANGLE
case|:
name|demangle
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't allow both ordering options, they modify the arc data in-place.  */
if|if
condition|(
operator|(
name|user_specified
operator|&
name|STYLE_FUNCTION_ORDER
operator|)
operator|&&
operator|(
name|user_specified
operator|&
name|STYLE_FILE_ORDER
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\ %s: Only one of --function-ordering and --file-ordering may be specified.\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* --sum implies --line, otherwise we'd lose basic block counts in        gmon.sum */
if|if
condition|(
name|output_style
operator|&
name|STYLE_SUMMARY_FILE
condition|)
name|line_granularity
operator|=
literal|1
expr_stmt|;
comment|/* append value of GPROF_PATH to source search list if set: */
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"GPROF_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|search_list_append
argument_list|(
operator|&
name|src_search_list
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|a_out_name
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|gmon_name
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
comment|/* Turn off default functions.  */
for|for
control|(
name|sp
operator|=
operator|&
name|default_excluded_list
index|[
literal|0
index|]
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
name|sym_id_add
argument_list|(
operator|*
name|sp
argument_list|,
name|EXCL_TIME
argument_list|)
expr_stmt|;
name|sym_id_add
argument_list|(
operator|*
name|sp
argument_list|,
name|EXCL_GRAPH
argument_list|)
expr_stmt|;
name|sym_id_add
argument_list|(
operator|*
name|sp
argument_list|,
name|EXCL_FLAT
argument_list|)
expr_stmt|;
block|}
comment|/* Read symbol table from core file.  */
name|core_init
argument_list|(
name|a_out_name
argument_list|)
expr_stmt|;
comment|/* If we should ignore direct function calls, we need to load to      core's text-space.  */
if|if
condition|(
name|ignore_direct_calls
condition|)
name|core_get_text_space
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
comment|/* Create symbols from core image.  */
if|if
condition|(
name|line_granularity
condition|)
name|core_create_line_syms
argument_list|()
expr_stmt|;
else|else
name|core_create_function_syms
argument_list|()
expr_stmt|;
comment|/* Translate sym specs into syms.  */
name|sym_id_parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|file_format
operator|==
name|FF_PROF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: sorry, file format `prof' is not yet supported\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get information about gmon.out file(s).  */
do|do
block|{
name|gmon_out_read
argument_list|(
name|gmon_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|gmon_name
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
do|while
condition|(
name|optind
operator|++
operator|<
name|argc
condition|)
do|;
block|}
comment|/* If user did not specify output style, try to guess something      reasonable.  */
if|if
condition|(
name|output_style
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gmon_input
operator|&
operator|(
name|INPUT_HISTOGRAM
operator||
name|INPUT_CALL_GRAPH
operator|)
condition|)
block|{
if|if
condition|(
name|gmon_input
operator|&
name|INPUT_HISTOGRAM
condition|)
name|output_style
operator||=
name|STYLE_FLAT_PROFILE
expr_stmt|;
if|if
condition|(
name|gmon_input
operator|&
name|INPUT_CALL_GRAPH
condition|)
name|output_style
operator||=
name|STYLE_CALL_GRAPH
expr_stmt|;
block|}
else|else
name|output_style
operator|=
name|STYLE_EXEC_COUNTS
expr_stmt|;
name|output_style
operator|&=
operator|~
name|user_specified
expr_stmt|;
block|}
comment|/* Dump a gmon.sum file if requested (before any other      processing!)  */
if|if
condition|(
name|output_style
operator|&
name|STYLE_SUMMARY_FILE
condition|)
block|{
name|gmon_out_write
argument_list|(
name|GMONSUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gmon_input
operator|&
name|INPUT_HISTOGRAM
condition|)
block|{
name|hist_assign_samples
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|gmon_input
operator|&
name|INPUT_CALL_GRAPH
condition|)
block|{
name|cg
operator|=
name|cg_assemble
argument_list|()
expr_stmt|;
block|}
comment|/* Do some simple sanity checks.  */
if|if
condition|(
operator|(
name|output_style
operator|&
name|STYLE_FLAT_PROFILE
operator|)
operator|&&
operator|!
operator|(
name|gmon_input
operator|&
name|INPUT_HISTOGRAM
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: gmon.out file is missing histogram\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|output_style
operator|&
name|STYLE_CALL_GRAPH
operator|)
operator|&&
operator|!
operator|(
name|gmon_input
operator|&
name|INPUT_CALL_GRAPH
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: gmon.out file is missing call-graph data\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output whatever user whishes to see.  */
if|if
condition|(
name|cg
operator|&&
operator|(
name|output_style
operator|&
name|STYLE_CALL_GRAPH
operator|)
operator|&&
name|bsd_style_output
condition|)
block|{
comment|/* Print the dynamic profile.  */
name|cg_print
argument_list|(
name|cg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_style
operator|&
name|STYLE_FLAT_PROFILE
condition|)
block|{
comment|/* Print the flat profile.  */
name|hist_print
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cg
operator|&&
operator|(
name|output_style
operator|&
name|STYLE_CALL_GRAPH
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|bsd_style_output
condition|)
block|{
comment|/* Print the dynamic profile.  */
name|cg_print
argument_list|(
name|cg
argument_list|)
expr_stmt|;
block|}
name|cg_print_index
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_style
operator|&
name|STYLE_EXEC_COUNTS
condition|)
name|print_exec_counts
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_style
operator|&
name|STYLE_ANNOTATED_SOURCE
condition|)
name|print_annotated_source
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_style
operator|&
name|STYLE_FUNCTION_ORDER
condition|)
name|cg_print_function_ordering
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_style
operator|&
name|STYLE_FILE_ORDER
condition|)
name|cg_print_file_ordering
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|done
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

