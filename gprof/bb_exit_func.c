begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  bb_exit_func.c - dumps all the basic-block statistics linked into     the bb_head chain to .d files.     Copyright 2000, 2001, 2004 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.     This code was contributed by:       David Mosberger-Tang<David.Mosberger@acm.org>  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gmon_out.h"
end_include

begin_comment
comment|/* structure emitted by -a */
end_comment

begin_struct
struct|struct
name|bb
block|{
name|long
name|zero_word
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|long
modifier|*
name|counts
decl_stmt|;
name|long
name|ncounts
decl_stmt|;
name|struct
name|bb
modifier|*
name|next
decl_stmt|;
specifier|const
name|unsigned
name|long
modifier|*
name|addresses
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|bb
modifier|*
name|__bb_head
init|=
operator|(
expr|struct
name|bb
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|__bb_exit_func
parameter_list|()
block|{
specifier|const
name|int
name|version
init|=
name|GMON_VERSION
decl_stmt|;
name|struct
name|gmon_hdr
name|ghdr
decl_stmt|;
name|struct
name|bb
modifier|*
name|ptr
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* GEN_GMON_CNT_FILE should be defined on systems with mcleanup()      functions that do not write basic-block to gmon.out.  In such      cases profiling with "-pg -a" would result in a gmon.out file      without basic-block info (because the file written here would be      overwritten.  Thus, a separate file is generated instead.  The      two files can easily be combined by specifying them on gprof's      command line (and possibly generating a gmon.sum file with "gprof      -s"). */
ifndef|#
directive|ifndef
name|GEN_GMON_CNT_FILE
define|#
directive|define
name|OUT_NAME
value|"gmon.out"
else|#
directive|else
define|#
directive|define
name|OUT_NAME
value|"gmon.cnt"
endif|#
directive|endif
name|fp
operator|=
name|fopen
argument_list|(
name|OUT_NAME
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|perror
argument_list|(
name|OUT_NAME
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
operator|&
name|ghdr
operator|.
name|cookie
index|[
literal|0
index|]
argument_list|,
name|GMON_MAGIC
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ghdr
operator|.
name|version
argument_list|,
operator|&
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|ghdr
argument_list|,
sizeof|sizeof
argument_list|(
name|ghdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|__bb_head
init|;
name|ptr
operator|!=
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|u_int
name|ncounts
init|=
name|ptr
operator|->
name|ncounts
decl_stmt|;
name|u_char
name|tag
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|tag
operator|=
name|GMON_TAG_BB_COUNT
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|ncounts
argument_list|,
sizeof|sizeof
argument_list|(
name|ncounts
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncounts
condition|;
operator|++
name|i
control|)
block|{
name|fwrite
argument_list|(
operator|&
name|ptr
operator|->
name|addresses
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
operator|->
name|addresses
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|ptr
operator|->
name|counts
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
operator|->
name|counts
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

