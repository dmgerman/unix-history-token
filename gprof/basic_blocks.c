begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* basic_blocks.c  -  Basic-block level related code: reading/writing    of basic-block info to/from gmon.out; computing and formatting of    basic-block related statistics.     Copyright 1999, 2000, 2001, 2002, 2004, 2005    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"basic_blocks.h"
end_include

begin_include
include|#
directive|include
file|"corefile.h"
end_include

begin_include
include|#
directive|include
file|"gmon_io.h"
end_include

begin_include
include|#
directive|include
file|"gmon_out.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"sym_ids.h"
end_include

begin_function_decl
specifier|static
name|int
name|cmp_bb
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_ncalls
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fskip_string
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|annotate_with_count
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Default option values:  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|bb_annotate_all_lines
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|bb_min_calls
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bb_table_length
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables used to compute annotated source listing stats:  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|num_executable_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|num_lines_executed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper for sorting.  Compares two symbols and returns result    such that sorting will be increasing according to filename, line    number, and address (in that order).  */
end_comment

begin_function
specifier|static
name|int
name|cmp_bb
parameter_list|(
specifier|const
name|PTR
name|lp
parameter_list|,
specifier|const
name|PTR
name|rp
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
specifier|const
name|Sym
modifier|*
name|left
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|lp
decl_stmt|;
specifier|const
name|Sym
modifier|*
name|right
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|rp
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|file
operator|&&
name|right
operator|->
name|file
condition|)
block|{
name|r
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|file
operator|->
name|name
argument_list|,
name|right
operator|->
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
if|if
condition|(
name|left
operator|->
name|line_num
operator|!=
name|right
operator|->
name|line_num
condition|)
return|return
name|left
operator|->
name|line_num
operator|-
name|right
operator|->
name|line_num
return|;
block|}
if|if
condition|(
name|left
operator|->
name|addr
operator|<
name|right
operator|->
name|addr
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|left
operator|->
name|addr
operator|>
name|right
operator|->
name|addr
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper for sorting.  Order basic blocks in decreasing number of    calls, ties are broken in increasing order of line numbers.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_ncalls
parameter_list|(
specifier|const
name|PTR
name|lp
parameter_list|,
specifier|const
name|PTR
name|rp
parameter_list|)
block|{
specifier|const
name|Sym
modifier|*
name|left
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|lp
decl_stmt|;
specifier|const
name|Sym
modifier|*
name|right
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|rp
decl_stmt|;
if|if
condition|(
operator|!
name|left
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|right
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|left
operator|->
name|ncalls
operator|<
name|right
operator|->
name|ncalls
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|left
operator|->
name|ncalls
operator|>
name|right
operator|->
name|ncalls
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|left
operator|->
name|line_num
operator|-
name|right
operator|->
name|line_num
return|;
block|}
end_function

begin_comment
comment|/* Skip over variable length string.  */
end_comment

begin_function
specifier|static
name|void
name|fskip_string
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Read a basic-block record from file IFP.  FILENAME is the name    of file IFP and is provided for formatting error-messages only.  */
end_comment

begin_function
name|void
name|bb_read_rec
parameter_list|(
name|FILE
modifier|*
name|ifp
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|unsigned
name|int
name|nblocks
decl_stmt|,
name|b
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|,
name|ncalls
decl_stmt|;
name|Sym
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|gmon_io_read_32
argument_list|(
name|ifp
argument_list|,
operator|&
name|nblocks
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s: unexpected end of file\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nblocks
operator|=
name|bfd_get_32
argument_list|(
name|core_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|nblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmon_file_version
operator|==
literal|0
condition|)
name|fskip_string
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|nblocks
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
name|gmon_file_version
operator|==
literal|0
condition|)
block|{
name|int
name|line_num
decl_stmt|;
comment|/* Version 0 had lots of extra stuff that we don't 	     care about anymore.  */
if|if
condition|(
operator|(
name|fread
argument_list|(
operator|&
name|ncalls
argument_list|,
sizeof|sizeof
argument_list|(
name|ncalls
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|fread
argument_list|(
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|fskip_string
argument_list|(
name|ifp
argument_list|)
operator|,
name|FALSE
operator|)
operator|||
operator|(
name|fskip_string
argument_list|(
name|ifp
argument_list|)
operator|,
name|FALSE
operator|)
operator|||
operator|(
name|fread
argument_list|(
operator|&
name|line_num
argument_list|,
sizeof|sizeof
argument_list|(
name|line_num
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
operator|!=
literal|1
operator|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gmon_io_read_vma
argument_list|(
name|ifp
argument_list|,
operator|&
name|addr
argument_list|)
operator|||
name|gmon_io_read_vma
argument_list|(
name|ifp
argument_list|,
operator|&
name|ncalls
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Basic-block execution counts are meaningful only if we're 	 profiling at the line-by-line level:  */
if|if
condition|(
name|line_granularity
condition|)
block|{
name|sym
operator|=
name|sym_lookup
argument_list|(
operator|&
name|symtab
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DBG
argument_list|(
name|BBDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[bb_read_rec] 0x%lx->0x%lx (%s:%d) cnt=%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
operator|->
name|addr
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|sym
operator|->
name|line_num
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ncalls
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sym
operator|->
name|bb_addr
index|[
name|i
index|]
operator|||
name|sym
operator|->
name|bb_addr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|sym
operator|->
name|bb_addr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
name|sym
operator|->
name|bb_calls
index|[
name|i
index|]
operator|+=
name|ncalls
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
specifier|static
name|bfd_boolean
name|user_warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|user_warned
condition|)
block|{
name|user_warned
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: warning: ignoring basic-block exec counts (use -l or --line)\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Write all basic-blocks with non-zero counts to file OFP.  FILENAME    is the name of OFP and is provided for producing error-messages    only.  */
end_comment

begin_function
name|void
name|bb_write_blocks
parameter_list|(
name|FILE
modifier|*
name|ofp
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|unsigned
name|int
name|nblocks
init|=
literal|0
decl_stmt|;
name|Sym
modifier|*
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Count how many non-zero blocks with have:  */
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBBS
operator|&&
name|sym
operator|->
name|bb_addr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|nblocks
operator|+=
name|i
expr_stmt|;
block|}
comment|/* Write header:  */
if|if
condition|(
name|gmon_io_write_8
argument_list|(
name|ofp
argument_list|,
name|GMON_TAG_BB_COUNT
argument_list|)
operator|||
name|gmon_io_write_32
argument_list|(
name|ofp
argument_list|,
name|nblocks
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Write counts:  */
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBBS
operator|&&
name|sym
operator|->
name|bb_addr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gmon_io_write_vma
argument_list|(
name|ofp
argument_list|,
name|sym
operator|->
name|bb_addr
index|[
name|i
index|]
argument_list|)
operator|||
name|gmon_io_write_vma
argument_list|(
name|ofp
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sym
operator|->
name|bb_calls
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output basic-block statistics in a format that is easily parseable.    Current the format is:<filename>:<line-number>: (<function-name>:<bb-addr):<ncalls>  */
end_comment

begin_function
name|void
name|print_exec_counts
parameter_list|()
block|{
name|Sym
modifier|*
modifier|*
name|sorted_bbs
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|first_output
condition|)
name|first_output
operator|=
name|FALSE
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\f\n"
argument_list|)
expr_stmt|;
comment|/* Sort basic-blocks according to function name and line number:  */
name|sorted_bbs
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|sorted_bbs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
comment|/* Accept symbol if it's in the INCL_EXEC table 	 or there is no INCL_EXEC table 	 and it does not appear in the EXCL_EXEC table.  */
if|if
condition|(
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_EXEC
index|]
argument_list|,
name|sym
operator|->
name|addr
argument_list|)
operator|||
operator|(
name|syms
index|[
name|INCL_EXEC
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_EXEC
index|]
argument_list|,
name|sym
operator|->
name|addr
argument_list|)
operator|)
condition|)
block|{
name|sorted_bbs
index|[
name|len
operator|++
index|]
operator|=
name|sym
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|sorted_bbs
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|sorted_bbs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cmp_bb
argument_list|)
expr_stmt|;
comment|/* Output basic-blocks:  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|sym
operator|=
name|sorted_bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|ncalls
operator|>
literal|0
operator|||
operator|!
name|ignore_zeros
condition|)
block|{
comment|/* FIXME: This only works if bfd_vma is unsigned long.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s:%d: (%s:0x%lx) %lu executions\n"
argument_list|)
argument_list|,
name|sym
operator|->
name|file
condition|?
name|sym
operator|->
name|file
operator|->
name|name
else|:
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
argument_list|,
name|sym
operator|->
name|line_num
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
operator|->
name|addr
argument_list|,
name|sym
operator|->
name|ncalls
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NBBS
operator|&&
name|sym
operator|->
name|bb_addr
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|bb_calls
index|[
name|j
index|]
operator|>
literal|0
operator|||
operator|!
name|ignore_zeros
condition|)
block|{
comment|/* FIXME: This only works if bfd_vma is unsigned long.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s:%d: (%s:0x%lx) %lu executions\n"
argument_list|)
argument_list|,
name|sym
operator|->
name|file
condition|?
name|sym
operator|->
name|file
operator|->
name|name
else|:
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
argument_list|,
name|sym
operator|->
name|line_num
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
operator|->
name|bb_addr
index|[
name|j
index|]
argument_list|,
name|sym
operator|->
name|bb_calls
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|sorted_bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for bb_annotated_source: format annotation containing    number of line executions.  Depends on being called on each    line of a file in sequential order.     Global variable bb_annotate_all_lines enables execution count    compression (counts are supressed if identical to the last one)    and prints counts on all executed lines.  Otherwise, print    all basic-block execution counts exactly once on the line    that starts the basic-block.  */
end_comment

begin_function
specifier|static
name|void
name|annotate_with_count
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|int
name|line_num
parameter_list|,
name|PTR
name|arg
parameter_list|)
block|{
name|Source_File
modifier|*
name|sf
init|=
name|arg
decl_stmt|;
name|Sym
modifier|*
name|b
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|unsigned
name|long
name|last_count
decl_stmt|;
name|unsigned
name|long
name|last_print
init|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
decl_stmt|;
name|b
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|line_num
operator|<=
name|sf
operator|->
name|num_lines
condition|)
name|b
operator|=
name|sf
operator|->
name|line
index|[
name|line_num
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|char
name|tmpbuf
index|[
name|NBBS
operator|*
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|ncalls
decl_stmt|;
name|int
name|ncalls_set
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
operator|++
name|num_executable_lines
expr_stmt|;
name|p
operator|=
name|tmpbuf
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ncalls
operator|=
literal|0
expr_stmt|;
name|ncalls_set
operator|=
literal|0
expr_stmt|;
comment|/* If this is a function entry point, label the line no matter what. 	 Otherwise, we're in the middle of a function, so check to see 	 if the first basic-block address is larger than the starting 	 address of the line.  If so, then this line begins with a 	 a portion of the previous basic-block, so print that prior 	 execution count (if bb_annotate_all_lines is set).  */
if|if
condition|(
name|b
operator|->
name|is_func
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%lu"
argument_list|,
name|b
operator|->
name|ncalls
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|last_count
operator|=
name|b
operator|->
name|ncalls
expr_stmt|;
name|last_print
operator|=
name|last_count
expr_stmt|;
name|ncalls
operator|=
name|b
operator|->
name|ncalls
expr_stmt|;
name|ncalls_set
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bb_annotate_all_lines
operator|&&
name|b
operator|->
name|bb_addr
index|[
literal|0
index|]
operator|&&
name|b
operator|->
name|bb_addr
index|[
literal|0
index|]
operator|>
name|b
operator|->
name|addr
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%lu"
argument_list|,
name|last_count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|last_print
operator|=
name|last_count
expr_stmt|;
name|ncalls
operator|=
name|last_count
expr_stmt|;
name|ncalls_set
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Loop through all of this line's basic-blocks.  For each one, 	 update last_count, then compress sequential identical counts 	 (if bb_annotate_all_lines) and print the execution count.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBBS
operator|&&
name|b
operator|->
name|bb_addr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|last_count
operator|=
name|b
operator|->
name|bb_calls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ncalls_set
condition|)
block|{
name|ncalls
operator|=
literal|0
expr_stmt|;
name|ncalls_set
operator|=
literal|1
expr_stmt|;
block|}
name|ncalls
operator|+=
name|last_count
expr_stmt|;
if|if
condition|(
name|bb_annotate_all_lines
operator|&&
name|last_count
operator|==
name|last_print
condition|)
continue|continue;
if|if
condition|(
name|p
operator|>
name|tmpbuf
condition|)
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%lu"
argument_list|,
name|last_count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|last_print
operator|=
name|last_count
expr_stmt|;
block|}
comment|/* We're done.  If nothing has been printed on this line, 	 print the last execution count (bb_annotate_all_lines), 	 which could be from either a previous line (if there were 	 no BBs on this line), or from this line (if all our BB 	 counts were compressed out because they were identical).  */
if|if
condition|(
name|bb_annotate_all_lines
operator|&&
name|p
operator|==
name|tmpbuf
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%lu"
argument_list|,
name|last_count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ncalls
operator|=
name|last_count
expr_stmt|;
name|ncalls_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ncalls_set
condition|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|width
condition|;
name|c
operator|++
control|)
name|buf
index|[
name|c
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
operator|++
name|num_lines_executed
expr_stmt|;
if|if
condition|(
name|ncalls
operator|<
name|bb_min_calls
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"#####"
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmpbuf
operator|+
literal|5
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
literal|" -> "
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|width
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|tmpbuf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|buf
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|strcpy
argument_list|(
name|buf
operator|+
name|width
operator|-
name|len
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|width
operator|-
name|len
condition|;
operator|++
name|c
control|)
name|buf
index|[
name|c
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Annotate the files named in SOURCE_FILES with basic-block statistics    (execution counts).  After each source files, a few statistics    regarding that source file are printed.  */
end_comment

begin_function
name|void
name|print_annotated_source
parameter_list|()
block|{
name|Sym
modifier|*
name|sym
decl_stmt|,
modifier|*
name|line_stats
decl_stmt|,
modifier|*
name|new_line
decl_stmt|;
name|Source_File
modifier|*
name|sf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|table_len
decl_stmt|;
name|FILE
modifier|*
name|ofp
decl_stmt|;
comment|/* Find maximum line number for each source file that user is      interested in:  */
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
comment|/* Accept symbol if it's file is known, its line number is 	 bigger than anything we have seen for that file so far and 	 if it's in the INCL_ANNO table or there is no INCL_ANNO 	 table and it does not appear in the EXCL_ANNO table.  */
if|if
condition|(
name|sym
operator|->
name|file
operator|&&
name|sym
operator|->
name|line_num
operator|>
name|sym
operator|->
name|file
operator|->
name|num_lines
operator|&&
operator|(
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_ANNO
index|]
argument_list|,
name|sym
operator|->
name|addr
argument_list|)
operator|||
operator|(
name|syms
index|[
name|INCL_ANNO
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_ANNO
index|]
argument_list|,
name|sym
operator|->
name|addr
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sym
operator|->
name|file
operator|->
name|num_lines
operator|=
name|sym
operator|->
name|line_num
expr_stmt|;
block|}
block|}
comment|/* Allocate line descriptors:  */
for|for
control|(
name|sf
operator|=
name|first_src_file
init|;
name|sf
condition|;
name|sf
operator|=
name|sf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sf
operator|->
name|num_lines
operator|>
literal|0
condition|)
block|{
name|sf
operator|->
name|line
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
name|sf
operator|->
name|num_lines
operator|*
sizeof|sizeof
argument_list|(
name|sf
operator|->
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sf
operator|->
name|line
argument_list|,
literal|0
argument_list|,
name|sf
operator|->
name|num_lines
operator|*
sizeof|sizeof
argument_list|(
name|sf
operator|->
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Count executions per line:  */
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|file
operator|&&
name|sym
operator|->
name|file
operator|->
name|num_lines
operator|&&
operator|(
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_ANNO
index|]
argument_list|,
name|sym
operator|->
name|addr
argument_list|)
operator|||
operator|(
name|syms
index|[
name|INCL_ANNO
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_ANNO
index|]
argument_list|,
name|sym
operator|->
name|addr
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sym
operator|->
name|file
operator|->
name|ncalls
operator|+=
name|sym
operator|->
name|ncalls
expr_stmt|;
name|line_stats
operator|=
name|sym
operator|->
name|file
operator|->
name|line
index|[
name|sym
operator|->
name|line_num
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|line_stats
condition|)
block|{
comment|/* Common case has at most one basic-block per source line:  */
name|sym
operator|->
name|file
operator|->
name|line
index|[
name|sym
operator|->
name|line_num
operator|-
literal|1
index|]
operator|=
name|sym
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|line_stats
operator|->
name|addr
condition|)
block|{
comment|/* sym is the 3rd .. nth basic block for this line:  */
name|line_stats
operator|->
name|ncalls
operator|+=
name|sym
operator|->
name|ncalls
expr_stmt|;
block|}
else|else
block|{
comment|/* sym is the second basic block for this line.  */
name|new_line
operator|=
operator|(
name|Sym
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_line
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_line
operator|=
operator|*
name|line_stats
expr_stmt|;
name|new_line
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|new_line
operator|->
name|ncalls
operator|+=
name|sym
operator|->
name|ncalls
expr_stmt|;
name|sym
operator|->
name|file
operator|->
name|line
index|[
name|sym
operator|->
name|line_num
operator|-
literal|1
index|]
operator|=
name|new_line
expr_stmt|;
block|}
block|}
block|}
comment|/* Plod over source files, annotating them:  */
for|for
control|(
name|sf
operator|=
name|first_src_file
init|;
name|sf
condition|;
name|sf
operator|=
name|sf
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|sf
operator|->
name|num_lines
operator|||
operator|(
name|ignore_zeros
operator|&&
name|sf
operator|->
name|ncalls
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|num_executable_lines
operator|=
name|num_lines_executed
operator|=
literal|0
expr_stmt|;
name|ofp
operator|=
name|annotate_source
argument_list|(
name|sf
argument_list|,
literal|16
argument_list|,
name|annotate_with_count
argument_list|,
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ofp
condition|)
continue|continue;
if|if
condition|(
name|bb_table_length
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
name|_
argument_list|(
literal|"\n\nTop %d Lines:\n\n     Line      Count\n\n"
argument_list|)
argument_list|,
name|bb_table_length
argument_list|)
expr_stmt|;
comment|/* Abuse line arrays---it's not needed anymore:  */
name|qsort
argument_list|(
name|sf
operator|->
name|line
argument_list|,
name|sf
operator|->
name|num_lines
argument_list|,
sizeof|sizeof
argument_list|(
name|sf
operator|->
name|line
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cmp_ncalls
argument_list|)
expr_stmt|;
name|table_len
operator|=
name|bb_table_length
expr_stmt|;
if|if
condition|(
name|table_len
operator|>
name|sf
operator|->
name|num_lines
condition|)
name|table_len
operator|=
name|sf
operator|->
name|num_lines
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_len
condition|;
operator|++
name|i
control|)
block|{
name|sym
operator|=
name|sf
operator|->
name|line
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|||
name|sym
operator|->
name|ncalls
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%9d %10lu\n"
argument_list|,
name|sym
operator|->
name|line_num
argument_list|,
name|sym
operator|->
name|ncalls
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sf
operator|->
name|line
argument_list|)
expr_stmt|;
name|sf
operator|->
name|line
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
name|_
argument_list|(
literal|"\nExecution Summary:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
name|_
argument_list|(
literal|"%9ld   Executable lines in this file\n"
argument_list|)
argument_list|,
name|num_executable_lines
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
name|_
argument_list|(
literal|"%9ld   Lines executed\n"
argument_list|)
argument_list|,
name|num_lines_executed
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
name|_
argument_list|(
literal|"%9.2f   Percent of the file executed\n"
argument_list|)
argument_list|,
name|num_executable_lines
condition|?
literal|100.0
operator|*
name|num_lines_executed
operator|/
operator|(
name|double
operator|)
name|num_executable_lines
else|:
literal|100.0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
name|_
argument_list|(
literal|"\n%9lu   Total number of line executions\n"
argument_list|)
argument_list|,
name|sf
operator|->
name|ncalls
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
name|_
argument_list|(
literal|"%9.2f   Average executions per line\n"
argument_list|)
argument_list|,
name|num_executable_lines
condition|?
operator|(
name|double
operator|)
name|sf
operator|->
name|ncalls
operator|/
operator|(
name|double
operator|)
name|num_executable_lines
else|:
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofp
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

