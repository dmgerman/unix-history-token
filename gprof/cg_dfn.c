begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *      The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"cg_arcs.h"
end_include

begin_include
include|#
directive|include
file|"cg_dfn.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_define
define|#
directive|define
name|DFN_INCR_DEPTH
value|(128)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|Sym
modifier|*
name|sym
decl_stmt|;
name|int
name|cycle_top
decl_stmt|;
block|}
name|DFN_Stack
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_numbered
name|PARAMS
argument_list|(
operator|(
name|Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_busy
name|PARAMS
argument_list|(
operator|(
name|Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_cycle
name|PARAMS
argument_list|(
operator|(
name|Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pre_visit
name|PARAMS
argument_list|(
operator|(
name|Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|post_visit
name|PARAMS
argument_list|(
operator|(
name|Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DFN_Stack
modifier|*
name|dfn_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dfn_maxdepth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dfn_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dfn_counter
init|=
name|DFN_NAN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Is CHILD already numbered?  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_numbered
parameter_list|(
name|child
parameter_list|)
name|Sym
modifier|*
name|child
decl_stmt|;
block|{
return|return
name|child
operator|->
name|cg
operator|.
name|top_order
operator|!=
name|DFN_NAN
operator|&&
name|child
operator|->
name|cg
operator|.
name|top_order
operator|!=
name|DFN_BUSY
return|;
block|}
end_function

begin_comment
comment|/*  * Is CHILD already busy?  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_busy
parameter_list|(
name|child
parameter_list|)
name|Sym
modifier|*
name|child
decl_stmt|;
block|{
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|top_order
operator|==
name|DFN_NAN
condition|)
block|{
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * CHILD is part of a cycle.  Find the top caller into this cycle  * that is not part of the cycle and make all functions in cycle  * members of that cycle (top caller == caller with smallest  * depth-first number).  */
end_comment

begin_function
specifier|static
name|void
name|find_cycle
parameter_list|(
name|child
parameter_list|)
name|Sym
modifier|*
name|child
decl_stmt|;
block|{
name|Sym
modifier|*
name|head
init|=
literal|0
decl_stmt|;
name|Sym
modifier|*
name|tail
decl_stmt|;
name|int
name|cycle_top
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|cycle_top
operator|=
name|dfn_depth
init|;
name|cycle_top
operator|>
literal|0
condition|;
operator|--
name|cycle_top
control|)
block|{
name|head
operator|=
name|dfn_stack
index|[
name|cycle_top
index|]
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|head
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|!=
name|child
operator|&&
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|==
name|head
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cycle_top
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[find_cycle] couldn't find head of cycle\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug_level
operator|&
name|DFNDEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"[find_cycle] dfn_depth %d cycle_top %d "
argument_list|,
name|dfn_depth
argument_list|,
name|cycle_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
condition|)
block|{
name|print_name
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cycle_top
operator|==
name|dfn_depth
condition|)
block|{
comment|/*        * This is previous function, e.g. this calls itself.  Sort of        * boring.        *        * Since we are taking out self-cycles elsewhere no need for        * the special case, here.        */
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[find_cycle] "
argument|); 	   print_name (child); 	   printf (
literal|"\n"
argument|)
argument_list|)
empty_stmt|;
block|}
else|else
block|{
comment|/*        * Glom intervening functions that aren't already glommed into        * this cycle.  Things have been glommed when their cyclehead        * field points to the head of the cycle they are glommed        * into.        */
for|for
control|(
name|tail
operator|=
name|head
init|;
name|tail
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
condition|;
name|tail
operator|=
name|tail
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
comment|/* void: chase down to tail of things already glommed */
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[find_cycle] tail "
argument|); 	       print_name (tail); 	       printf (
literal|"\n"
argument|)
argument_list|)
empty_stmt|;
block|}
comment|/*        * If what we think is the top of the cycle has a cyclehead        * field, then it's not really the head of the cycle, which is        * really what we want.        */
if|if
condition|(
name|head
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|!=
name|head
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
expr_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[find_cycle] new cyclehead "
argument|); 	       print_name (head); 	       printf (
literal|"\n"
argument|)
argument_list|)
empty_stmt|;
block|}
for|for
control|(
name|index
operator|=
name|cycle_top
operator|+
literal|1
init|;
name|index
operator|<=
name|dfn_depth
condition|;
operator|++
name|index
control|)
block|{
name|child
operator|=
name|dfn_stack
index|[
name|index
index|]
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|==
name|child
condition|)
block|{
comment|/* 	       * Not yet glommed anywhere, glom it and fix any 	       * children it has glommed. 	       */
name|tail
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[find_cycle] glomming "
argument|); 		   print_name (child); 		   printf (
literal|" onto "
argument|); 		   print_name (head); 		   printf (
literal|"\n"
argument|)
argument_list|)
empty_stmt|;
for|for
control|(
name|tail
operator|=
name|child
init|;
name|tail
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
condition|;
name|tail
operator|=
name|tail
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
name|tail
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[find_cycle] and its tail "
argument|); 		       print_name (tail->cg.cyc.next); 		       printf (
literal|" onto "
argument|); 		       print_name (head); 		       printf (
literal|"\n"
argument|)
argument_list|)
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|!=
name|head
comment|/* firewall */
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[find_cycle] glommed, but not to head\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Prepare for visiting the children of PARENT.  Push a parent onto  * the stack and mark it busy.  */
end_comment

begin_function
specifier|static
name|void
name|pre_visit
parameter_list|(
name|parent
parameter_list|)
name|Sym
modifier|*
name|parent
decl_stmt|;
block|{
operator|++
name|dfn_depth
expr_stmt|;
if|if
condition|(
name|dfn_depth
operator|>=
name|dfn_maxdepth
condition|)
block|{
name|dfn_maxdepth
operator|+=
name|DFN_INCR_DEPTH
expr_stmt|;
name|dfn_stack
operator|=
name|xrealloc
argument_list|(
name|dfn_stack
argument_list|,
name|dfn_maxdepth
operator|*
sizeof|sizeof
expr|*
name|dfn_stack
argument_list|)
expr_stmt|;
block|}
name|dfn_stack
index|[
name|dfn_depth
index|]
operator|.
name|sym
operator|=
name|parent
expr_stmt|;
name|dfn_stack
index|[
name|dfn_depth
index|]
operator|.
name|cycle_top
operator|=
name|dfn_depth
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|top_order
operator|=
name|DFN_BUSY
expr_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[pre_visit]\t\t%d:"
argument|, dfn_depth);        print_name (parent);        printf (
literal|"\n"
argument|)
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Done with visiting node PARENT.  Pop PARENT off dfn_stack  * and number functions if PARENT is head of a cycle.  */
end_comment

begin_function
specifier|static
name|void
name|post_visit
parameter_list|(
name|parent
parameter_list|)
name|Sym
modifier|*
name|parent
decl_stmt|;
block|{
name|Sym
modifier|*
name|member
decl_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[post_visit]\t%d: "
argument|, dfn_depth);        print_name (parent);        printf (
literal|"\n"
argument|)
argument_list|)
empty_stmt|;
comment|/*    * Number functions and things in their cycles unless the function    * is itself part of a cycle:    */
if|if
condition|(
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|==
name|parent
condition|)
block|{
operator|++
name|dfn_counter
expr_stmt|;
for|for
control|(
name|member
operator|=
name|parent
init|;
name|member
condition|;
name|member
operator|=
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
name|member
operator|->
name|cg
operator|.
name|top_order
operator|=
name|dfn_counter
expr_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[post_visit]\t\tmember "
argument|); 	       print_name (member); 	       printf (
literal|"-> cg.top_order = %d\n"
argument|, dfn_counter)
argument_list|)
empty_stmt|;
block|}
block|}
else|else
block|{
name|DBG
argument_list|(
name|DFNDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[post_visit]\t\tis part of a cycle\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|--
name|dfn_depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given this PARENT, depth first number its children.  */
end_comment

begin_function
name|void
name|cg_dfn
parameter_list|(
name|parent
parameter_list|)
name|Sym
modifier|*
name|parent
decl_stmt|;
block|{
name|Arc
modifier|*
name|arc
decl_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[dfn] dfn( "
argument|);        print_name (parent);        printf (
literal|")\n"
argument|)
argument_list|)
empty_stmt|;
comment|/*    * If we're already numbered, no need to look any further:    */
if|if
condition|(
name|is_numbered
argument_list|(
name|parent
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/*    * If we're already busy, must be a cycle:    */
if|if
condition|(
name|is_busy
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|find_cycle
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return;
block|}
name|pre_visit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/*    * Recursively visit children:    */
for|for
control|(
name|arc
operator|=
name|parent
operator|->
name|cg
operator|.
name|children
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_child
control|)
block|{
name|cg_dfn
argument_list|(
name|arc
operator|->
name|child
argument_list|)
expr_stmt|;
block|}
name|post_visit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

