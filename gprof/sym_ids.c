begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sym_ids.c     Copyright 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"cg_arcs.h"
end_include

begin_include
include|#
directive|include
file|"sym_ids.h"
end_include

begin_include
include|#
directive|include
file|"corefile.h"
end_include

begin_struct
specifier|static
struct|struct
name|sym_id
block|{
name|struct
name|sym_id
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* Parsing modifies this.  */
name|Table_Id
name|which_table
decl_stmt|;
name|bfd_boolean
name|has_right
decl_stmt|;
struct|struct
name|match
block|{
name|int
name|prev_index
decl_stmt|;
comment|/* Index of prev match.  */
name|Sym
modifier|*
name|prev_match
decl_stmt|;
comment|/* Previous match.  */
name|Sym
modifier|*
name|first_match
decl_stmt|;
comment|/* Chain of all matches.  */
name|Sym
name|sym
decl_stmt|;
block|}
name|left
struct|,
name|right
struct|;
block|}
modifier|*
name|id_list
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|parse_spec
parameter_list|(
name|char
modifier|*
parameter_list|,
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_id
parameter_list|(
name|struct
name|sym_id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|match
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_match
parameter_list|(
name|struct
name|match
modifier|*
parameter_list|,
name|Sym
modifier|*
parameter_list|,
name|Sym_Table
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|Sym_Table
name|syms
index|[
name|NUM_TABLES
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|table_name
index|[]
init|=
block|{
literal|"INCL_GRAPH"
block|,
literal|"EXCL_GRAPH"
block|,
literal|"INCL_ARCS"
block|,
literal|"EXCL_ARCS"
block|,
literal|"INCL_FLAT"
block|,
literal|"EXCL_FLAT"
block|,
literal|"INCL_TIME"
block|,
literal|"EXCL_TIME"
block|,
literal|"INCL_ANNO"
block|,
literal|"EXCL_ANNO"
block|,
literal|"INCL_EXEC"
block|,
literal|"EXCL_EXEC"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* This is the table in which we keep all the syms that match    the right half of an arc id.  It is NOT sorted according    to the addresses, because it is accessed only through    the left half's CHILDREN pointers (so it's crucial not    to reorder this table once pointers into it exist).  */
end_comment

begin_decl_stmt
specifier|static
name|Sym_Table
name|right_ids
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Source_File
name|non_existent_file
init|=
block|{
literal|0
block|,
literal|"<non-existent-file>"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sym_id_add
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|Table_Id
name|which_table
parameter_list|)
block|{
name|struct
name|sym_id
modifier|*
name|id
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|spec
argument_list|)
decl_stmt|;
name|id
operator|=
operator|(
expr|struct
name|sym_id
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|spec
operator|=
operator|(
name|char
operator|*
operator|)
name|id
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|id
operator|->
name|spec
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|id
operator|->
name|which_table
operator|=
name|which_table
expr_stmt|;
name|id
operator|->
name|next
operator|=
name|id_list
expr_stmt|;
name|id_list
operator|=
name|id
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A spec has the syntax FILENAME:(FUNCNAME|LINENUM).  As a convenience    to the user, a spec without a colon is interpreted as:  	(i)   a FILENAME if it contains a dot 	(ii)  a FUNCNAME if it starts with a non-digit character 	(iii) a LINENUM if it starts with a digit     A FUNCNAME containing a dot can be specified by :FUNCNAME, a    FILENAME not containing a dot can be specified by FILENAME.  */
end_comment

begin_function
specifier|static
name|void
name|parse_spec
parameter_list|(
name|char
modifier|*
name|spec
parameter_list|,
name|Sym
modifier|*
name|sym
parameter_list|)
block|{
name|char
modifier|*
name|colon
decl_stmt|;
name|sym_init
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|colon
operator|=
name|strrchr
argument_list|(
name|spec
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|colon
operator|>
name|spec
condition|)
block|{
name|sym
operator|->
name|file
operator|=
name|source_file_lookup_name
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|->
name|file
condition|)
name|sym
operator|->
name|file
operator|=
operator|&
name|non_existent_file
expr_stmt|;
block|}
name|spec
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|spec
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|spec
index|[
literal|0
index|]
argument_list|)
condition|)
name|sym
operator|->
name|line_num
operator|=
name|atoi
argument_list|(
name|spec
argument_list|)
expr_stmt|;
else|else
name|sym
operator|->
name|name
operator|=
name|spec
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|spec
argument_list|)
condition|)
block|{
comment|/* No colon: spec is a filename if it contains a dot.  */
if|if
condition|(
name|strchr
argument_list|(
name|spec
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|sym
operator|->
name|file
operator|=
name|source_file_lookup_name
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|->
name|file
condition|)
name|sym
operator|->
name|file
operator|=
operator|&
name|non_existent_file
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|spec
argument_list|)
condition|)
block|{
name|sym
operator|->
name|line_num
operator|=
name|atoi
argument_list|(
name|spec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|spec
argument_list|)
condition|)
block|{
name|sym
operator|->
name|name
operator|=
name|spec
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A symbol id has the syntax SPEC[/SPEC], where SPEC is is defined    by parse_spec().  */
end_comment

begin_function
specifier|static
name|void
name|parse_id
parameter_list|(
name|struct
name|sym_id
modifier|*
name|id
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|DBG
argument_list|(
name|IDDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[parse_id] %s -> "
argument_list|,
name|id
operator|->
name|spec
argument_list|)
argument_list|)
expr_stmt|;
name|slash
operator|=
name|strchr
argument_list|(
name|id
operator|->
name|spec
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
block|{
name|parse_spec
argument_list|(
name|slash
operator|+
literal|1
argument_list|,
operator|&
name|id
operator|->
name|right
operator|.
name|sym
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|id
operator|->
name|has_right
operator|=
name|TRUE
expr_stmt|;
block|}
name|parse_spec
argument_list|(
name|id
operator|->
name|spec
argument_list|,
operator|&
name|id
operator|->
name|left
operator|.
name|sym
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug_level
operator|&
name|IDDEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|id
operator|->
name|left
operator|.
name|sym
operator|.
name|file
condition|?
name|id
operator|->
name|left
operator|.
name|sym
operator|.
name|file
operator|->
name|name
else|:
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|left
operator|.
name|sym
operator|.
name|name
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|id
operator|->
name|left
operator|.
name|sym
operator|.
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|id
operator|->
name|left
operator|.
name|sym
operator|.
name|line_num
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|id
operator|->
name|left
operator|.
name|sym
operator|.
name|line_num
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|has_right
condition|)
block|{
name|printf
argument_list|(
literal|"/%s:"
argument_list|,
name|id
operator|->
name|right
operator|.
name|sym
operator|.
name|file
condition|?
name|id
operator|->
name|right
operator|.
name|sym
operator|.
name|file
operator|->
name|name
else|:
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|right
operator|.
name|sym
operator|.
name|name
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|id
operator|->
name|right
operator|.
name|sym
operator|.
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|id
operator|->
name|right
operator|.
name|sym
operator|.
name|line_num
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|id
operator|->
name|right
operator|.
name|sym
operator|.
name|line_num
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return TRUE iff PATTERN matches SYM.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|match
parameter_list|(
name|Sym
modifier|*
name|pattern
parameter_list|,
name|Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|pattern
operator|->
name|file
operator|&&
name|pattern
operator|->
name|file
operator|!=
name|sym
operator|->
name|file
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|pattern
operator|->
name|line_num
operator|&&
name|pattern
operator|->
name|line_num
operator|!=
name|sym
operator|->
name|line_num
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|pattern
operator|->
name|name
condition|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
init|=
name|sym
operator|->
name|name
decl_stmt|;
if|if
condition|(
operator|*
name|sym_name
operator|&&
name|bfd_get_symbol_leading_char
argument_list|(
name|core_bfd
argument_list|)
operator|==
operator|*
name|sym_name
condition|)
name|sym_name
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pattern
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|extend_match
parameter_list|(
name|struct
name|match
modifier|*
name|m
parameter_list|,
name|Sym
modifier|*
name|sym
parameter_list|,
name|Sym_Table
modifier|*
name|tab
parameter_list|,
name|bfd_boolean
name|second_pass
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|prev_match
operator|!=
name|sym
operator|-
literal|1
condition|)
block|{
comment|/* Discontinuity: add new match to table.  */
if|if
condition|(
name|second_pass
condition|)
block|{
name|tab
operator|->
name|base
index|[
name|tab
operator|->
name|len
index|]
operator|=
operator|*
name|sym
expr_stmt|;
name|m
operator|->
name|prev_index
operator|=
name|tab
operator|->
name|len
expr_stmt|;
comment|/* Link match into match's chain.  */
name|tab
operator|->
name|base
index|[
name|tab
operator|->
name|len
index|]
operator|.
name|next
operator|=
name|m
operator|->
name|first_match
expr_stmt|;
name|m
operator|->
name|first_match
operator|=
operator|&
name|tab
operator|->
name|base
index|[
name|tab
operator|->
name|len
index|]
expr_stmt|;
block|}
operator|++
name|tab
operator|->
name|len
expr_stmt|;
block|}
comment|/* Extend match to include this symbol.  */
if|if
condition|(
name|second_pass
condition|)
name|tab
operator|->
name|base
index|[
name|m
operator|->
name|prev_index
index|]
operator|.
name|end_addr
operator|=
name|sym
operator|->
name|end_addr
expr_stmt|;
name|m
operator|->
name|prev_match
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through sym_id list produced by option processing and fill    in the various symbol tables indicating what symbols should    be displayed or suppressed for the various kinds of outputs.     This can potentially produce huge tables and in particulars    tons of arcs, but this happens only if the user makes silly    requests---you get what you ask for!  */
end_comment

begin_function
name|void
name|sym_id_parse
parameter_list|()
block|{
name|Sym
modifier|*
name|sym
decl_stmt|,
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|struct
name|sym_id
modifier|*
name|id
decl_stmt|;
name|Sym_Table
modifier|*
name|tab
decl_stmt|;
comment|/* Convert symbol ids into Syms, so we can deal with them more easily.  */
for|for
control|(
name|id
operator|=
name|id_list
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
name|parse_id
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* First determine size of each table.  */
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
for|for
control|(
name|id
operator|=
name|id_list
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
if|if
condition|(
name|match
argument_list|(
operator|&
name|id
operator|->
name|left
operator|.
name|sym
argument_list|,
name|sym
argument_list|)
condition|)
name|extend_match
argument_list|(
operator|&
name|id
operator|->
name|left
argument_list|,
name|sym
argument_list|,
operator|&
name|syms
index|[
name|id
operator|->
name|which_table
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|has_right
operator|&&
name|match
argument_list|(
operator|&
name|id
operator|->
name|right
operator|.
name|sym
argument_list|,
name|sym
argument_list|)
condition|)
name|extend_match
argument_list|(
operator|&
name|id
operator|->
name|right
argument_list|,
name|sym
argument_list|,
operator|&
name|right_ids
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create tables of appropriate size and reset lengths.  */
for|for
control|(
name|tab
operator|=
name|syms
init|;
name|tab
operator|<
operator|&
name|syms
index|[
name|NUM_TABLES
index|]
condition|;
operator|++
name|tab
control|)
block|{
if|if
condition|(
name|tab
operator|->
name|len
condition|)
block|{
name|tab
operator|->
name|base
operator|=
operator|(
name|Sym
operator|*
operator|)
name|xmalloc
argument_list|(
name|tab
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
argument_list|)
argument_list|)
expr_stmt|;
name|tab
operator|->
name|limit
operator|=
name|tab
operator|->
name|base
operator|+
name|tab
operator|->
name|len
expr_stmt|;
name|tab
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|right_ids
operator|.
name|len
condition|)
block|{
name|right_ids
operator|.
name|base
operator|=
operator|(
name|Sym
operator|*
operator|)
name|xmalloc
argument_list|(
name|right_ids
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
argument_list|)
argument_list|)
expr_stmt|;
name|right_ids
operator|.
name|limit
operator|=
name|right_ids
operator|.
name|base
operator|+
name|right_ids
operator|.
name|len
expr_stmt|;
name|right_ids
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make a second pass through symtab, creating syms as necessary.  */
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
for|for
control|(
name|id
operator|=
name|id_list
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
if|if
condition|(
name|match
argument_list|(
operator|&
name|id
operator|->
name|left
operator|.
name|sym
argument_list|,
name|sym
argument_list|)
condition|)
name|extend_match
argument_list|(
operator|&
name|id
operator|->
name|left
argument_list|,
name|sym
argument_list|,
operator|&
name|syms
index|[
name|id
operator|->
name|which_table
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|has_right
operator|&&
name|match
argument_list|(
operator|&
name|id
operator|->
name|right
operator|.
name|sym
argument_list|,
name|sym
argument_list|)
condition|)
name|extend_match
argument_list|(
operator|&
name|id
operator|->
name|right
argument_list|,
name|sym
argument_list|,
operator|&
name|right_ids
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Go through ids creating arcs as needed.  */
for|for
control|(
name|id
operator|=
name|id_list
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
if|if
condition|(
name|id
operator|->
name|has_right
condition|)
block|{
for|for
control|(
name|left
operator|=
name|id
operator|->
name|left
operator|.
name|first_match
init|;
name|left
condition|;
name|left
operator|=
name|left
operator|->
name|next
control|)
block|{
for|for
control|(
name|right
operator|=
name|id
operator|->
name|right
operator|.
name|first_match
init|;
name|right
condition|;
name|right
operator|=
name|right
operator|->
name|next
control|)
block|{
name|DBG
argument_list|(
name|IDDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[sym_id_parse]: arc %s:%s(%lx-%lx) -> %s:%s(%lx-%lx) to %s\n"
argument_list|,
name|left
operator|->
name|file
condition|?
name|left
operator|->
name|file
operator|->
name|name
else|:
literal|"*"
argument_list|,
name|left
operator|->
name|name
condition|?
name|left
operator|->
name|name
else|:
literal|"*"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|left
operator|->
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|left
operator|->
name|end_addr
argument_list|,
name|right
operator|->
name|file
condition|?
name|right
operator|->
name|file
operator|->
name|name
else|:
literal|"*"
argument_list|,
name|right
operator|->
name|name
condition|?
name|right
operator|->
name|name
else|:
literal|"*"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|right
operator|->
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|right
operator|->
name|end_addr
argument_list|,
name|table_name
index|[
name|id
operator|->
name|which_table
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|arc_add
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Finally, we can sort the tables and we're done.  */
for|for
control|(
name|tab
operator|=
operator|&
name|syms
index|[
literal|0
index|]
init|;
name|tab
operator|<
operator|&
name|syms
index|[
name|NUM_TABLES
index|]
condition|;
operator|++
name|tab
control|)
block|{
name|DBG
argument_list|(
name|IDDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[sym_id_parse] syms[%s]:\n"
argument_list|,
name|table_name
index|[
name|tab
operator|-
operator|&
name|syms
index|[
literal|0
index|]
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|symtab_finalize
argument_list|(
name|tab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Symbol tables storing the FROM symbols of arcs do not necessarily    have distinct address ranges.  For example, somebody might request    -k /_mcount to suppress any arcs into _mcount, while at the same    time requesting -k a/b.  Fortunately, those symbol tables don't get    very big (the user has to type them!), so a linear search is probably    tolerable.  */
end_comment

begin_function
name|bfd_boolean
name|sym_id_arc_is_present
parameter_list|(
name|Sym_Table
modifier|*
name|sym_tab
parameter_list|,
name|Sym
modifier|*
name|from
parameter_list|,
name|Sym
modifier|*
name|to
parameter_list|)
block|{
name|Sym
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|sym_tab
operator|->
name|base
init|;
name|sym
operator|<
name|sym_tab
operator|->
name|limit
condition|;
operator|++
name|sym
control|)
block|{
if|if
condition|(
name|from
operator|->
name|addr
operator|>=
name|sym
operator|->
name|addr
operator|&&
name|from
operator|->
name|addr
operator|<=
name|sym
operator|->
name|end_addr
operator|&&
name|arc_lookup
argument_list|(
name|sym
argument_list|,
name|to
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

end_unit

