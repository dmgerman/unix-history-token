begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* corefile.c     Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_include
include|#
directive|include
file|"corefile.h"
end_include

begin_decl_stmt
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|core_num_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|core_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|core_text_sect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|core_text_space
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_insn_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset_to_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For mapping symbols to specific .o files during file ordering.  */
end_comment

begin_decl_stmt
name|struct
name|function_map
modifier|*
name|symbol_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|symbol_map_count
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|read_function_mappings
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|core_sym_class
parameter_list|(
name|asymbol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|get_src_info
parameter_list|(
name|bfd_vma
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|i386_find_call
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|alpha_find_call
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|vax_find_call
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tahoe_find_call
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|sparc_find_call
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mips_find_call
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|parse_error
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unable to parse mapping file %s.\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_function_mappings
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|dummy
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: could not open %s.\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* First parse the mapping file so we know how big we need to      make our tables.  We also do some sanity checks at this      time.  */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|int
name|matches
decl_stmt|;
name|matches
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%[^\n:]"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
name|parse_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Just skip messages about files with no symbols.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|dummy
argument_list|,
literal|"No symbols in "
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|matches
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
name|EOF
condition|)
name|parse_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Don't care what else is on this line at this point.  */
name|matches
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%[^\n]\n"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
name|parse_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Now we know how big we need to make our table.  */
name|symbol_map
operator|=
operator|(
operator|(
expr|struct
name|function_map
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Rewind the input file so we can read it again.  */
name|rewind
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Read each entry and put it into the table.  */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|int
name|matches
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|matches
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%[^\n:]"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
name|parse_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Just skip messages about files with no symbols.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|dummy
argument_list|,
literal|"No symbols in "
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|matches
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
name|EOF
condition|)
name|parse_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* dummy has the filename, go ahead and copy it.  */
name|symbol_map
index|[
name|count
index|]
operator|.
name|file_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dummy
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_map
index|[
name|count
index|]
operator|.
name|file_name
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
comment|/* Now we need the function name.  */
name|matches
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%[^\n]\n"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
name|parse_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strrchr
argument_list|(
name|dummy
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|symbol_map
index|[
name|count
index|]
operator|.
name|function_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_map
index|[
name|count
index|]
operator|.
name|function_name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Record the size of the map table for future reference.  */
name|symbol_map_count
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|core_init
parameter_list|(
specifier|const
name|char
modifier|*
name|aout_name
parameter_list|)
block|{
name|int
name|core_sym_bytes
decl_stmt|;
name|asymbol
modifier|*
name|synthsyms
decl_stmt|;
name|long
name|synth_count
decl_stmt|;
name|core_bfd
operator|=
name|bfd_openr
argument_list|(
name|aout_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|core_bfd
condition|)
block|{
name|perror
argument_list|(
name|aout_name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|core_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s: not in executable format\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|aout_name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get core's text section.  */
name|core_text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|core_text_sect
condition|)
block|{
name|core_text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|"$CODE$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|core_text_sect
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't find .text section in %s\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|aout_name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read core's symbol table.  */
comment|/* This will probably give us more than we need, but that's ok.  */
name|core_sym_bytes
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_sym_bytes
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|whoami
argument_list|,
name|aout_name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|core_syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|core_sym_bytes
argument_list|)
expr_stmt|;
name|core_num_syms
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|core_bfd
argument_list|,
name|core_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_num_syms
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|whoami
argument_list|,
name|aout_name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|synth_count
operator|=
name|bfd_get_synthetic_symtab
argument_list|(
name|core_bfd
argument_list|,
name|core_num_syms
argument_list|,
name|core_syms
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|synthsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|synth_count
operator|>
literal|0
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|symp
decl_stmt|;
name|long
name|new_size
decl_stmt|;
name|long
name|i
decl_stmt|;
name|new_size
operator|=
operator|(
name|core_num_syms
operator|+
name|synth_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|core_syms
argument_list|)
expr_stmt|;
name|core_syms
operator|=
name|xrealloc
argument_list|(
name|core_syms
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|symp
operator|=
name|core_syms
operator|+
name|core_num_syms
expr_stmt|;
name|core_num_syms
operator|+=
name|synth_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|synth_count
condition|;
name|i
operator|++
control|)
operator|*
name|symp
operator|++
operator|=
name|synthsyms
operator|+
name|i
expr_stmt|;
operator|*
name|symp
operator|=
literal|0
expr_stmt|;
block|}
name|min_insn_size
operator|=
literal|1
expr_stmt|;
name|offset_to_code
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|core_bfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_vax
case|:
case|case
name|bfd_arch_tahoe
case|:
name|offset_to_code
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|bfd_arch_alpha
case|:
name|min_insn_size
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|function_mapping_file
condition|)
name|read_function_mappings
argument_list|(
name|function_mapping_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in the text space of an a.out file.  */
end_comment

begin_function
name|void
name|core_get_text_space
parameter_list|(
name|bfd
modifier|*
name|cbfd
parameter_list|)
block|{
name|core_text_space
operator|=
name|malloc
argument_list|(
name|bfd_get_section_size
argument_list|(
name|core_text_sect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|core_text_space
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: ran out room for %lu bytes of text space\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bfd_get_section_size
argument_list|(
name|core_text_sect
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|cbfd
argument_list|,
name|core_text_sect
argument_list|,
name|core_text_space
argument_list|,
literal|0
argument_list|,
name|bfd_get_section_size
argument_list|(
name|core_text_sect
argument_list|)
argument_list|)
condition|)
block|{
name|bfd_perror
argument_list|(
literal|"bfd_get_section_contents"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|core_text_space
argument_list|)
expr_stmt|;
name|core_text_space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|core_text_space
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't do -c\n"
argument_list|)
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|find_call
parameter_list|(
name|Sym
modifier|*
name|parent
parameter_list|,
name|bfd_vma
name|p_lowpc
parameter_list|,
name|bfd_vma
name|p_highpc
parameter_list|)
block|{
if|if
condition|(
name|core_text_space
operator|==
literal|0
condition|)
return|return;
name|hist_clip_symbol_address
argument_list|(
operator|&
name|p_lowpc
argument_list|,
operator|&
name|p_highpc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|core_bfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_i386
case|:
name|i386_find_call
argument_list|(
name|parent
argument_list|,
name|p_lowpc
argument_list|,
name|p_highpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_alpha
case|:
name|alpha_find_call
argument_list|(
name|parent
argument_list|,
name|p_lowpc
argument_list|,
name|p_highpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_vax
case|:
name|vax_find_call
argument_list|(
name|parent
argument_list|,
name|p_lowpc
argument_list|,
name|p_highpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_sparc
case|:
name|sparc_find_call
argument_list|(
name|parent
argument_list|,
name|p_lowpc
argument_list|,
name|p_highpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_tahoe
case|:
name|tahoe_find_call
argument_list|(
name|parent
argument_list|,
name|p_lowpc
argument_list|,
name|p_highpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_mips
case|:
name|mips_find_call
argument_list|(
name|parent
argument_list|,
name|p_lowpc
argument_list|,
name|p_highpc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: -c not supported on architecture %s\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|bfd_printable_name
argument_list|(
name|core_bfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't give the error more than once.  */
name|ignore_direct_calls
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return class of symbol SYM.  The returned class can be any of: 	0   -> symbol is not interesting to us 	'T' -> symbol is a global name 	't' -> symbol is a local (static) name.  */
end_comment

begin_function
specifier|static
name|int
name|core_sym_class
parameter_list|(
name|asymbol
modifier|*
name|sym
parameter_list|)
block|{
name|symbol_info
name|syminfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|sym_prefix
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|section
operator|==
name|NULL
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Must be a text symbol, and static text symbols      don't qualify if ignore_static_funcs set.   */
if|if
condition|(
name|ignore_static_funcs
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
condition|)
block|{
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[core_sym_class] %s: not a function\n"
argument_list|,
name|sym
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bfd_get_symbol_info
argument_list|(
name|core_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|syminfo
argument_list|)
expr_stmt|;
name|i
operator|=
name|syminfo
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'T'
condition|)
return|return
name|i
return|;
comment|/* It's a global symbol.  */
if|if
condition|(
name|i
operator|==
literal|'W'
condition|)
comment|/* Treat weak symbols as text symbols.  FIXME: a weak symbol may        also be a data symbol.  */
return|return
literal|'T'
return|;
if|if
condition|(
name|i
operator|!=
literal|'t'
condition|)
block|{
comment|/* Not a static text symbol.  */
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[core_sym_class] %s is of class %c\n"
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Do some more filtering on static function-names.  */
if|if
condition|(
name|ignore_static_funcs
condition|)
return|return
literal|0
return|;
comment|/* Can't zero-length name or funny characters in name, where      `funny' includes: `.' (.o file names) and `$' (Pascal labels).  */
if|if
condition|(
operator|!
name|sym
operator|->
name|name
operator|||
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|name
operator|=
name|sym
operator|->
name|name
init|;
operator|*
name|name
condition|;
operator|++
name|name
control|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
operator|||
operator|*
name|name
operator|==
literal|'$'
condition|)
return|return
literal|0
return|;
block|}
comment|/* On systems where the C compiler adds an underscore to all      names, static names without underscores seem usually to be      labels in hand written assembler in the library.  We don't want      these names.  This is certainly necessary on a Sparc running      SunOS 4.1 (try profiling a program that does a lot of      division). I don't know whether it has harmful side effects on      other systems.  Perhaps it should be made configurable.  */
name|sym_prefix
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sym_prefix
operator|&&
name|sym_prefix
operator|!=
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|)
comment|/* GCC may add special symbols to help gdb figure out the file 	language.  We want to ignore these, since sometimes they mask 	the real function.  (dj@ctron)  */
operator|||
operator|!
name|strncmp
argument_list|(
name|sym
operator|->
name|name
argument_list|,
literal|"__gnu_compiled"
argument_list|,
literal|14
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|sym
operator|->
name|name
argument_list|,
literal|"___gnu_compiled"
argument_list|,
literal|15
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* If the object file supports marking of function symbols, then      we can zap anything that doesn't have BSF_FUNCTION set.  */
if|if
condition|(
name|ignore_non_functions
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|'t'
return|;
comment|/* It's a static text symbol.  */
block|}
end_function

begin_comment
comment|/* Get whatever source info we can get regarding address ADDR.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_src_info
parameter_list|(
name|bfd_vma
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|line_num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
literal|0
decl_stmt|,
modifier|*
name|func_name
init|=
literal|0
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_find_nearest_line
argument_list|(
name|core_bfd
argument_list|,
name|core_text_sect
argument_list|,
name|core_syms
argument_list|,
name|addr
operator|-
name|core_text_sect
operator|->
name|vma
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|func_name
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|l
argument_list|)
operator|&&
name|fname
operator|&&
name|func_name
operator|&&
name|l
condition|)
block|{
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[get_src_info] 0x%lx -> %s:%d (%s)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
name|fname
argument_list|,
name|l
argument_list|,
name|func_name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|fname
expr_stmt|;
operator|*
name|name
operator|=
name|func_name
expr_stmt|;
operator|*
name|line_num
operator|=
name|l
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[get_src_info] no info for 0x%lx (%s:%d,%s)\n"
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|,
name|fname
condition|?
name|fname
else|:
literal|"<unknown>"
argument_list|,
name|l
argument_list|,
name|func_name
condition|?
name|func_name
else|:
literal|"<unknown>"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read in symbol table from core.    One symbol per function is entered.  */
end_comment

begin_function
name|void
name|core_create_function_syms
parameter_list|()
block|{
name|bfd_vma
name|min_vma
init|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
decl_stmt|;
name|bfd_vma
name|max_vma
init|=
literal|0
decl_stmt|;
name|int
name|class
decl_stmt|;
name|long
name|i
decl_stmt|,
name|found
decl_stmt|,
name|skip
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* Pass 1 - determine upper bound on number of function names.  */
name|symtab
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|core_num_syms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|core_sym_class
argument_list|(
name|core_syms
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
comment|/* This should be replaced with a binary search or hashed 	 search.  Gross.  	 Don't create a symtab entry for a function that has 	 a mapping to a file, unless it's the first function 	 in the file.  */
name|skip
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|symbol_map_count
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|core_syms
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|symbol_map
index|[
name|j
index|]
operator|.
name|function_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|symbol_map
index|[
name|j
index|]
operator|.
name|file_name
argument_list|,
name|symbol_map
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|file_name
argument_list|)
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
operator|++
name|symtab
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: file `%s' has no symbols\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|a_out_name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The "+ 2" is for the sentinels.  */
name|symtab
operator|.
name|base
operator|=
operator|(
name|Sym
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|symtab
operator|.
name|len
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass 2 - create symbols.  */
name|symtab
operator|.
name|limit
operator|=
name|symtab
operator|.
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|core_num_syms
condition|;
operator|++
name|i
control|)
block|{
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|class
operator|=
name|core_sym_class
argument_list|(
name|core_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|class
condition|)
block|{
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[core_create_function_syms] rejecting: 0x%lx %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|core_syms
index|[
name|i
index|]
operator|->
name|value
argument_list|,
name|core_syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* This should be replaced with a binary search or hashed 	 search.  Gross.   */
name|skip
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|symbol_map_count
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|core_syms
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|symbol_map
index|[
name|j
index|]
operator|.
name|function_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|symbol_map
index|[
name|j
index|]
operator|.
name|file_name
argument_list|,
name|symbol_map
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|file_name
argument_list|)
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
else|else
name|found
operator|=
name|j
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skip
condition|)
continue|continue;
name|sym_init
argument_list|(
name|symtab
operator|.
name|limit
argument_list|)
expr_stmt|;
comment|/* Symbol offsets are always section-relative.  */
name|sym_sec
operator|=
name|core_syms
index|[
name|i
index|]
operator|->
name|section
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|addr
operator|=
name|core_syms
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|sym_sec
condition|)
name|symtab
operator|.
name|limit
operator|->
name|addr
operator|+=
name|bfd_get_section_vma
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_map_count
operator|&&
operator|!
name|strcmp
argument_list|(
name|core_syms
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|symbol_map
index|[
name|found
index|]
operator|.
name|function_name
argument_list|)
condition|)
block|{
name|symtab
operator|.
name|limit
operator|->
name|name
operator|=
name|symbol_map
index|[
name|found
index|]
operator|.
name|file_name
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|symtab
operator|.
name|limit
operator|->
name|name
operator|=
name|core_syms
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|mapped
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Lookup filename and line number, if we can.  */
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|func_name
decl_stmt|;
if|if
condition|(
name|get_src_info
argument_list|(
name|symtab
operator|.
name|limit
operator|->
name|addr
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|func_name
argument_list|,
operator|&
name|symtab
operator|.
name|limit
operator|->
name|line_num
argument_list|)
condition|)
block|{
name|symtab
operator|.
name|limit
operator|->
name|file
operator|=
name|source_file_lookup_path
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* FIXME: Checking __osf__ here does not work with a cross 	       gprof.  */
ifdef|#
directive|ifdef
name|__osf__
comment|/* Suppress symbols that are not function names.  This is 	       useful to suppress code-labels and aliases.  	       This is known to be useful under DEC's OSF/1.  Under SunOS 4.x, 	       labels do not appear in the symbol table info, so this isn't 	       necessary.  */
if|if
condition|(
name|strcmp
argument_list|(
name|symtab
operator|.
name|limit
operator|->
name|name
argument_list|,
name|func_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The symbol's address maps to a different name, so 		   it can't be a function-entry point.  This happens 		   for labels, for example.  */
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[core_create_function_syms: rej %s (maps to %s)\n"
argument_list|,
name|symtab
operator|.
name|limit
operator|->
name|name
argument_list|,
name|func_name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
block|}
block|}
name|symtab
operator|.
name|limit
operator|->
name|is_func
operator|=
name|TRUE
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|is_bb_head
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|class
operator|==
literal|'t'
condition|)
name|symtab
operator|.
name|limit
operator|->
name|is_static
operator|=
name|TRUE
expr_stmt|;
comment|/* Keep track of the minimum and maximum vma addresses used by all 	 symbols.  When computing the max_vma, use the ending address of the 	 section containing the symbol, if available.  */
name|min_vma
operator|=
name|MIN
argument_list|(
name|symtab
operator|.
name|limit
operator|->
name|addr
argument_list|,
name|min_vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_sec
condition|)
name|max_vma
operator|=
name|MAX
argument_list|(
name|bfd_get_section_vma
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|,
name|sym_sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|,
name|sym_sec
argument_list|)
operator|-
literal|1
argument_list|,
name|max_vma
argument_list|)
expr_stmt|;
else|else
name|max_vma
operator|=
name|MAX
argument_list|(
name|symtab
operator|.
name|limit
operator|->
name|addr
argument_list|,
name|max_vma
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[core_create_function_syms] %ld %s 0x%lx\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|symtab
operator|.
name|limit
operator|-
name|symtab
operator|.
name|base
argument_list|)
argument_list|,
name|symtab
operator|.
name|limit
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symtab
operator|.
name|limit
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|symtab
operator|.
name|limit
expr_stmt|;
block|}
comment|/* Create sentinels.  */
name|sym_init
argument_list|(
name|symtab
operator|.
name|limit
argument_list|)
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|name
operator|=
literal|"<locore>"
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|end_addr
operator|=
name|min_vma
operator|-
literal|1
expr_stmt|;
operator|++
name|symtab
operator|.
name|limit
expr_stmt|;
name|sym_init
argument_list|(
name|symtab
operator|.
name|limit
argument_list|)
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|name
operator|=
literal|"<hicore>"
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|addr
operator|=
name|max_vma
operator|+
literal|1
expr_stmt|;
name|symtab
operator|.
name|limit
operator|->
name|end_addr
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
operator|++
name|symtab
operator|.
name|limit
expr_stmt|;
name|symtab
operator|.
name|len
operator|=
name|symtab
operator|.
name|limit
operator|-
name|symtab
operator|.
name|base
expr_stmt|;
name|symtab_finalize
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in symbol table from core.    One symbol per line of source code is entered.  */
end_comment

begin_function
name|void
name|core_create_line_syms
parameter_list|()
block|{
name|char
modifier|*
name|prev_name
decl_stmt|,
modifier|*
name|prev_filename
decl_stmt|;
name|unsigned
name|int
name|prev_name_len
decl_stmt|,
name|prev_filename_len
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|,
name|min_vma
init|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
decl_stmt|,
name|max_vma
init|=
literal|0
decl_stmt|;
name|Sym
modifier|*
name|prev
decl_stmt|,
name|dummy
decl_stmt|,
modifier|*
name|sentinel
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|prev_line_num
decl_stmt|;
name|Sym_Table
name|ltab
decl_stmt|;
name|bfd_vma
name|vma_high
decl_stmt|;
comment|/* Create symbols for functions as usual.  This is necessary in      cases where parts of a program were not compiled with -g.  For      those parts we still want to get info at the function level.  */
name|core_create_function_syms
argument_list|()
expr_stmt|;
comment|/* Pass 1: count the number of symbols.  */
comment|/* To find all line information, walk through all possible      text-space addresses (one by one!) and get the debugging      info for each address.  When the debugging info changes,      it is time to create a new symbol.       Of course, this is rather slow and it would be better if      BFD would provide an iterator for enumerating all line infos.  */
name|prev_name_len
operator|=
name|PATH_MAX
expr_stmt|;
name|prev_filename_len
operator|=
name|PATH_MAX
expr_stmt|;
name|prev_name
operator|=
name|xmalloc
argument_list|(
name|prev_name_len
argument_list|)
expr_stmt|;
name|prev_filename
operator|=
name|xmalloc
argument_list|(
name|prev_filename_len
argument_list|)
expr_stmt|;
name|ltab
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|prev_line_num
operator|=
literal|0
expr_stmt|;
name|vma_high
operator|=
name|core_text_sect
operator|->
name|vma
operator|+
name|bfd_get_section_size
argument_list|(
name|core_text_sect
argument_list|)
expr_stmt|;
for|for
control|(
name|vma
operator|=
name|core_text_sect
operator|->
name|vma
init|;
name|vma
operator|<
name|vma_high
condition|;
name|vma
operator|+=
name|min_insn_size
control|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|get_src_info
argument_list|(
name|vma
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|dummy
operator|.
name|name
argument_list|,
operator|&
name|dummy
operator|.
name|line_num
argument_list|)
operator|||
operator|(
name|prev_line_num
operator|==
name|dummy
operator|.
name|line_num
operator|&&
name|prev_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|dummy
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|prev_filename
argument_list|,
name|filename
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
operator|++
name|ltab
operator|.
name|len
expr_stmt|;
name|prev_line_num
operator|=
name|dummy
operator|.
name|line_num
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dummy
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|prev_name_len
condition|)
block|{
name|prev_name_len
operator|=
name|len
operator|+
literal|1024
expr_stmt|;
name|free
argument_list|(
name|prev_name
argument_list|)
expr_stmt|;
name|prev_name
operator|=
name|xmalloc
argument_list|(
name|prev_name_len
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|prev_name
argument_list|,
name|dummy
operator|.
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|prev_filename_len
condition|)
block|{
name|prev_filename_len
operator|=
name|len
operator|+
literal|1024
expr_stmt|;
name|free
argument_list|(
name|prev_filename
argument_list|)
expr_stmt|;
name|prev_filename
operator|=
name|xmalloc
argument_list|(
name|prev_filename_len
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|prev_filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|min_vma
operator|=
name|MIN
argument_list|(
name|vma
argument_list|,
name|min_vma
argument_list|)
expr_stmt|;
name|max_vma
operator|=
name|MAX
argument_list|(
name|vma
argument_list|,
name|max_vma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|prev_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_filename
argument_list|)
expr_stmt|;
comment|/* Make room for function symbols, too.  */
name|ltab
operator|.
name|len
operator|+=
name|symtab
operator|.
name|len
expr_stmt|;
name|ltab
operator|.
name|base
operator|=
operator|(
name|Sym
operator|*
operator|)
name|xmalloc
argument_list|(
name|ltab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
argument_list|)
argument_list|)
expr_stmt|;
name|ltab
operator|.
name|limit
operator|=
name|ltab
operator|.
name|base
expr_stmt|;
comment|/* Pass 2 - create symbols.  */
comment|/* We now set is_static as we go along, rather than by running      through the symbol table at the end.       The old way called symtab_finalize before the is_static pass,      causing a problem since symtab_finalize uses is_static as part of      its address conflict resolution algorithm.  Since global symbols      were prefered over static symbols, and all line symbols were      global at that point, static function names that conflicted with      their own line numbers (static, but labeled as global) were      rejected in favor of the line num.       This was not the desired functionality.  We always want to keep      our function symbols and discard any conflicting line symbols.      Perhaps symtab_finalize should be modified to make this      distinction as well, but the current fix works and the code is a      lot cleaner now.  */
name|prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vma
operator|=
name|core_text_sect
operator|->
name|vma
init|;
name|vma
operator|<
name|vma_high
condition|;
name|vma
operator|+=
name|min_insn_size
control|)
block|{
name|sym_init
argument_list|(
name|ltab
operator|.
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_src_info
argument_list|(
name|vma
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|ltab
operator|.
name|limit
operator|->
name|name
argument_list|,
operator|&
name|ltab
operator|.
name|limit
operator|->
name|line_num
argument_list|)
operator|||
operator|(
name|prev
operator|&&
name|prev
operator|->
name|line_num
operator|==
name|ltab
operator|.
name|limit
operator|->
name|line_num
operator|&&
name|strcmp
argument_list|(
name|prev
operator|->
name|name
argument_list|,
name|ltab
operator|.
name|limit
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|prev
operator|->
name|file
operator|->
name|name
argument_list|,
name|filename
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* Make name pointer a malloc'ed string.  */
name|ltab
operator|.
name|limit
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|ltab
operator|.
name|limit
operator|->
name|name
argument_list|)
expr_stmt|;
name|ltab
operator|.
name|limit
operator|->
name|file
operator|=
name|source_file_lookup_path
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|ltab
operator|.
name|limit
operator|->
name|addr
operator|=
name|vma
expr_stmt|;
comment|/* Set is_static based on the enclosing function, using either: 	 1) the previous symbol, if it's from the same function, or 	 2) a symtab lookup.  */
if|if
condition|(
name|prev
operator|&&
name|ltab
operator|.
name|limit
operator|->
name|file
operator|==
name|prev
operator|->
name|file
operator|&&
name|strcmp
argument_list|(
name|ltab
operator|.
name|limit
operator|->
name|name
argument_list|,
name|prev
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ltab
operator|.
name|limit
operator|->
name|is_static
operator|=
name|prev
operator|->
name|is_static
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|sym_lookup
argument_list|(
operator|&
name|symtab
argument_list|,
name|ltab
operator|.
name|limit
operator|->
name|addr
argument_list|)
expr_stmt|;
name|ltab
operator|.
name|limit
operator|->
name|is_static
operator|=
name|sym
operator|->
name|is_static
expr_stmt|;
block|}
name|prev
operator|=
name|ltab
operator|.
name|limit
expr_stmt|;
name|DBG
argument_list|(
name|AOUTDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[core_create_line_syms] %lu %s 0x%lx\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|ltab
operator|.
name|limit
operator|-
name|ltab
operator|.
name|base
argument_list|)
argument_list|,
name|ltab
operator|.
name|limit
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ltab
operator|.
name|limit
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ltab
operator|.
name|limit
expr_stmt|;
block|}
comment|/* Update sentinels.  */
name|sentinel
operator|=
name|sym_lookup
argument_list|(
operator|&
name|symtab
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentinel
operator|&&
name|strcmp
argument_list|(
name|sentinel
operator|->
name|name
argument_list|,
literal|"<locore>"
argument_list|)
operator|==
literal|0
operator|&&
name|min_vma
operator|<=
name|sentinel
operator|->
name|end_addr
condition|)
name|sentinel
operator|->
name|end_addr
operator|=
name|min_vma
operator|-
literal|1
expr_stmt|;
name|sentinel
operator|=
name|sym_lookup
argument_list|(
operator|&
name|symtab
argument_list|,
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentinel
operator|&&
name|strcmp
argument_list|(
name|sentinel
operator|->
name|name
argument_list|,
literal|"<hicore>"
argument_list|)
operator|==
literal|0
operator|&&
name|max_vma
operator|>=
name|sentinel
operator|->
name|addr
condition|)
name|sentinel
operator|->
name|addr
operator|=
name|max_vma
operator|+
literal|1
expr_stmt|;
comment|/* Copy in function symbols.  */
name|memcpy
argument_list|(
name|ltab
operator|.
name|limit
argument_list|,
name|symtab
operator|.
name|base
argument_list|,
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
argument_list|)
argument_list|)
expr_stmt|;
name|ltab
operator|.
name|limit
operator|+=
name|symtab
operator|.
name|len
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|ltab
operator|.
name|limit
operator|-
name|ltab
operator|.
name|base
argument_list|)
operator|!=
name|ltab
operator|.
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: somebody miscounted: ltab.len=%d instead of %ld\n"
argument_list|)
argument_list|,
name|whoami
argument_list|,
name|ltab
operator|.
name|len
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ltab
operator|.
name|limit
operator|-
name|ltab
operator|.
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Finalize ltab and make it symbol table.  */
name|symtab_finalize
argument_list|(
operator|&
name|ltab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symtab
operator|.
name|base
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|ltab
expr_stmt|;
block|}
end_function

end_unit

