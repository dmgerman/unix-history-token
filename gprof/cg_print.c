begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cg_print.c -  Print routines for displaying call graphs.     Copyright 2000, 2001, 2002, 2004 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"cg_arcs.h"
end_include

begin_include
include|#
directive|include
file|"cg_print.h"
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_include
include|#
directive|include
file|"corefile.h"
end_include

begin_comment
comment|/* Return value of comparison functions used to sort tables.  */
end_comment

begin_define
define|#
directive|define
name|LESSTHAN
value|-1
end_define

begin_define
define|#
directive|define
name|EQUALTO
value|0
end_define

begin_define
define|#
directive|define
name|GREATERTHAN
value|1
end_define

begin_function_decl
specifier|static
name|void
name|print_header
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_cycle
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_member
parameter_list|(
name|Sym
modifier|*
parameter_list|,
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sort_members
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_members
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_arc
parameter_list|(
name|Arc
modifier|*
parameter_list|,
name|Arc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sort_parents
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_parents
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sort_children
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_children
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_line
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_name
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_arc_count
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_fun_nuses
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|order_and_dump_functions_by_arcs
parameter_list|(
name|Arc
modifier|*
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|Arc
modifier|*
modifier|*
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declarations of automatically generated functions to output blurbs.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bsd_callg_blurb
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fsf_callg_blurb
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|double
name|print_time
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_header
parameter_list|()
block|{
if|if
condition|(
name|first_output
condition|)
name|first_output
operator|=
name|FALSE
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\f\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsd_style_output
condition|)
block|{
if|if
condition|(
name|print_descriptions
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\t\t     Call graph (explanation follows)\n\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\t\t\tCall graph\n\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ngranularity: each sample hit covers %ld byte(s)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|hist_scale
operator|*
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_time
operator|>
literal|0.0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" for %.2f%% of %.2f seconds\n\n"
argument_list|)
argument_list|,
literal|100.0
operator|/
name|print_time
argument_list|,
name|print_time
operator|/
name|hz
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" no time propagated\n\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This doesn't hurt, since all the numerators will be 0.0.  */
name|print_time
operator|=
literal|1.0
expr_stmt|;
block|}
if|if
condition|(
name|bsd_style_output
condition|)
block|{
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7.7s/%-7.7s     %-8.8s\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|_
argument_list|(
literal|"called"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"total"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"parents"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-6.6s %5.5s %7.7s %11.11s %7.7s+%-7.7s %-8.8s\t%5.5s\n"
argument_list|,
name|_
argument_list|(
literal|"index"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"%time"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"self"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"descendants"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"called"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"self"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"index"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7.7s/%-7.7s     %-8.8s\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|_
argument_list|(
literal|"called"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"total"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"children"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"index %% time    self  children    called     name\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a cycle header.  */
end_comment

begin_function
specifier|static
name|void
name|print_cycle
parameter_list|(
name|Sym
modifier|*
name|cyc
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%d]"
argument_list|,
name|cyc
operator|->
name|cg
operator|.
name|index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|bsd_style_output
condition|?
literal|"%-6.6s %5.1f %7.2f %11.2f %7lu"
else|:
literal|"%-6.6s %5.1f %7.2f %7.2f %7lu"
argument_list|,
name|buf
argument_list|,
literal|100
operator|*
operator|(
name|cyc
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|+
name|cyc
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|)
operator|/
name|print_time
argument_list|,
name|cyc
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|/
name|hz
argument_list|,
name|cyc
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|/
name|hz
argument_list|,
name|cyc
operator|->
name|ncalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyc
operator|->
name|cg
operator|.
name|self_calls
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"+%-7lu"
argument_list|,
name|cyc
operator|->
name|cg
operator|.
name|self_calls
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %7.7s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"<cycle %d as a whole> [%d]\n"
argument_list|)
argument_list|,
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
argument_list|,
name|cyc
operator|->
name|cg
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare LEFT and RIGHT membmer.  Major comparison key is    CG.PROP.SELF+CG.PROP.CHILD, secondary key is NCALLS+CG.SELF_CALLS.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_member
parameter_list|(
name|Sym
modifier|*
name|left
parameter_list|,
name|Sym
modifier|*
name|right
parameter_list|)
block|{
name|double
name|left_time
init|=
name|left
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|+
name|left
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
decl_stmt|;
name|double
name|right_time
init|=
name|right
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|+
name|right
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
decl_stmt|;
name|unsigned
name|long
name|left_calls
init|=
name|left
operator|->
name|ncalls
operator|+
name|left
operator|->
name|cg
operator|.
name|self_calls
decl_stmt|;
name|unsigned
name|long
name|right_calls
init|=
name|right
operator|->
name|ncalls
operator|+
name|right
operator|->
name|cg
operator|.
name|self_calls
decl_stmt|;
if|if
condition|(
name|left_time
operator|>
name|right_time
condition|)
return|return
name|GREATERTHAN
return|;
if|if
condition|(
name|left_time
operator|<
name|right_time
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|left_calls
operator|>
name|right_calls
condition|)
return|return
name|GREATERTHAN
return|;
if|if
condition|(
name|left_calls
operator|<
name|right_calls
condition|)
return|return
name|LESSTHAN
return|;
return|return
name|EQUALTO
return|;
block|}
end_function

begin_comment
comment|/* Sort members of a cycle.  */
end_comment

begin_function
specifier|static
name|void
name|sort_members
parameter_list|(
name|Sym
modifier|*
name|cyc
parameter_list|)
block|{
name|Sym
modifier|*
name|todo
decl_stmt|,
modifier|*
name|doing
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* Detach cycle members from cyclehead,      and insertion sort them back on.  */
name|todo
operator|=
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
expr_stmt|;
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|doing
operator|=
name|todo
init|;
name|doing
operator|&&
name|doing
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
condition|;
name|doing
operator|=
name|todo
control|)
block|{
name|todo
operator|=
name|doing
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|cyc
init|;
name|prev
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
condition|;
name|prev
operator|=
name|prev
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
if|if
condition|(
name|cmp_member
argument_list|(
name|doing
argument_list|,
name|prev
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
argument_list|)
operator|==
name|GREATERTHAN
condition|)
break|break;
block|}
name|doing
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|=
name|prev
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
expr_stmt|;
name|prev
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|=
name|doing
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the members of a cycle.  */
end_comment

begin_function
specifier|static
name|void
name|print_members
parameter_list|(
name|Sym
modifier|*
name|cyc
parameter_list|)
block|{
name|Sym
modifier|*
name|member
decl_stmt|;
name|sort_members
argument_list|(
name|cyc
argument_list|)
expr_stmt|;
for|for
control|(
name|member
operator|=
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
init|;
name|member
condition|;
name|member
operator|=
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
name|printf
argument_list|(
name|bsd_style_output
condition|?
literal|"%6.6s %5.5s %7.2f %11.2f %7lu"
else|:
literal|"%6.6s %5.5s %7.2f %7.2f %7lu"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|member
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|/
name|hz
argument_list|,
name|member
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|/
name|hz
argument_list|,
name|member
operator|->
name|ncalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|->
name|cg
operator|.
name|self_calls
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"+%-7lu"
argument_list|,
name|member
operator|->
name|cg
operator|.
name|self_calls
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %7.7s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two arcs to/from the same child/parent. 	- if one arc is a self arc, it's least. 	- if one arc is within a cycle, it's less than. 	- if both arcs are within a cycle, compare arc counts. 	- if neither arc is within a cycle, compare with 		time + child_time as major key 		arc count as minor key.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_arc
parameter_list|(
name|Arc
modifier|*
name|left
parameter_list|,
name|Arc
modifier|*
name|right
parameter_list|)
block|{
name|Sym
modifier|*
name|left_parent
init|=
name|left
operator|->
name|parent
decl_stmt|;
name|Sym
modifier|*
name|left_child
init|=
name|left
operator|->
name|child
decl_stmt|;
name|Sym
modifier|*
name|right_parent
init|=
name|right
operator|->
name|parent
decl_stmt|;
name|Sym
modifier|*
name|right_child
init|=
name|right
operator|->
name|child
decl_stmt|;
name|double
name|left_time
decl_stmt|,
name|right_time
decl_stmt|;
name|DBG
argument_list|(
argument|TIMEDEBUG
argument_list|,
argument|printf (
literal|"[cmp_arc] "
argument|);        print_name (left_parent);        printf (
literal|" calls "
argument|);        print_name (left_child);        printf (
literal|" %f + %f %lu/%lu\n"
argument|, left->time, left->child_time, 	       left->count, left_child->ncalls);        printf (
literal|"[cmp_arc] "
argument|);        print_name (right_parent);        printf (
literal|" calls "
argument|);        print_name (right_child);        printf (
literal|" %f + %f %lu/%lu\n"
argument|, right->time, right->child_time, 	       right->count, right_child->ncalls);        printf (
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|left_parent
operator|==
name|left_child
condition|)
return|return
name|LESSTHAN
return|;
comment|/* Left is a self call.  */
if|if
condition|(
name|right_parent
operator|==
name|right_child
condition|)
return|return
name|GREATERTHAN
return|;
comment|/* Right is a self call.  */
if|if
condition|(
name|left_parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|left_child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|left_parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|==
name|left_child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
condition|)
block|{
comment|/* Left is a call within a cycle.  */
if|if
condition|(
name|right_parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|right_child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|right_parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|==
name|right_child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
condition|)
block|{
comment|/* Right is a call within the cycle, too.  */
if|if
condition|(
name|left
operator|->
name|count
operator|<
name|right
operator|->
name|count
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|left
operator|->
name|count
operator|>
name|right
operator|->
name|count
condition|)
return|return
name|GREATERTHAN
return|;
return|return
name|EQUALTO
return|;
block|}
else|else
block|{
comment|/* Right isn't a call within the cycle.  */
return|return
name|LESSTHAN
return|;
block|}
block|}
else|else
block|{
comment|/* Left isn't a call within a cycle.  */
if|if
condition|(
name|right_parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|right_child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|right_parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|==
name|right_child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
condition|)
block|{
comment|/* Right is a call within a cycle.  */
return|return
name|GREATERTHAN
return|;
block|}
else|else
block|{
comment|/* Neither is a call within a cycle.  */
name|left_time
operator|=
name|left
operator|->
name|time
operator|+
name|left
operator|->
name|child_time
expr_stmt|;
name|right_time
operator|=
name|right
operator|->
name|time
operator|+
name|right
operator|->
name|child_time
expr_stmt|;
if|if
condition|(
name|left_time
operator|<
name|right_time
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|left_time
operator|>
name|right_time
condition|)
return|return
name|GREATERTHAN
return|;
if|if
condition|(
name|left
operator|->
name|count
operator|<
name|right
operator|->
name|count
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|left
operator|->
name|count
operator|>
name|right
operator|->
name|count
condition|)
return|return
name|GREATERTHAN
return|;
return|return
name|EQUALTO
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sort_parents
parameter_list|(
name|Sym
modifier|*
name|child
parameter_list|)
block|{
name|Arc
modifier|*
name|arc
decl_stmt|,
modifier|*
name|detached
decl_stmt|,
name|sorted
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* Unlink parents from child, then insertion sort back on to      sorted's parents. 	  *arc        the arc you have detached and are inserting. 	  *detached   the rest of the arcs to be sorted. 	  sorted      arc list onto which you insertion sort. 	  *prev       arc before the arc you are comparing.  */
name|sorted
operator|.
name|next_parent
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|child
operator|->
name|cg
operator|.
name|parents
init|;
name|arc
condition|;
name|arc
operator|=
name|detached
control|)
block|{
name|detached
operator|=
name|arc
operator|->
name|next_parent
expr_stmt|;
comment|/* Consider *arc as disconnected; insert it into sorted.  */
for|for
control|(
name|prev
operator|=
operator|&
name|sorted
init|;
name|prev
operator|->
name|next_parent
condition|;
name|prev
operator|=
name|prev
operator|->
name|next_parent
control|)
block|{
if|if
condition|(
name|cmp_arc
argument_list|(
name|arc
argument_list|,
name|prev
operator|->
name|next_parent
argument_list|)
operator|!=
name|GREATERTHAN
condition|)
break|break;
block|}
name|arc
operator|->
name|next_parent
operator|=
name|prev
operator|->
name|next_parent
expr_stmt|;
name|prev
operator|->
name|next_parent
operator|=
name|arc
expr_stmt|;
block|}
comment|/* Reattach sorted arcs to child.  */
name|child
operator|->
name|cg
operator|.
name|parents
operator|=
name|sorted
operator|.
name|next_parent
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_parents
parameter_list|(
name|Sym
modifier|*
name|child
parameter_list|)
block|{
name|Sym
modifier|*
name|parent
decl_stmt|;
name|Arc
modifier|*
name|arc
decl_stmt|;
name|Sym
modifier|*
name|cycle_head
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|!=
literal|0
condition|)
name|cycle_head
operator|=
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
expr_stmt|;
else|else
name|cycle_head
operator|=
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|->
name|cg
operator|.
name|parents
condition|)
block|{
name|printf
argument_list|(
name|bsd_style_output
condition|?
name|_
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7.7s %7.7s<spontaneous>\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"%6.6s %5.5s %7.7s %7.7s %7.7s %7.7s<spontaneous>\n"
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|sort_parents
argument_list|(
name|child
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|child
operator|->
name|cg
operator|.
name|parents
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_parent
control|)
block|{
name|parent
operator|=
name|arc
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|parent
operator|||
operator|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|==
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|)
condition|)
block|{
comment|/* Selfcall or call among siblings.  */
name|printf
argument_list|(
name|bsd_style_output
condition|?
literal|"%6.6s %5.5s %7.7s %11.11s %7lu %7.7s     "
else|:
literal|"%6.6s %5.5s %7.7s %7.7s %7lu %7.7s     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arc
operator|->
name|count
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Regular parent of child.  */
name|printf
argument_list|(
name|bsd_style_output
condition|?
literal|"%6.6s %5.5s %7.2f %11.2f %7lu/%-7lu     "
else|:
literal|"%6.6s %5.5s %7.2f %7.2f %7lu/%-7lu     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arc
operator|->
name|time
operator|/
name|hz
argument_list|,
name|arc
operator|->
name|child_time
operator|/
name|hz
argument_list|,
name|arc
operator|->
name|count
argument_list|,
name|cycle_head
operator|->
name|ncalls
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sort_children
parameter_list|(
name|Sym
modifier|*
name|parent
parameter_list|)
block|{
name|Arc
modifier|*
name|arc
decl_stmt|,
modifier|*
name|detached
decl_stmt|,
name|sorted
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* Unlink children from parent, then insertion sort back on to      sorted's children. 	  *arc        the arc you have detached and are inserting. 	  *detached   the rest of the arcs to be sorted. 	  sorted      arc list onto which you insertion sort. 	  *prev       arc before the arc you are comparing.  */
name|sorted
operator|.
name|next_child
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|parent
operator|->
name|cg
operator|.
name|children
init|;
name|arc
condition|;
name|arc
operator|=
name|detached
control|)
block|{
name|detached
operator|=
name|arc
operator|->
name|next_child
expr_stmt|;
comment|/* Consider *arc as disconnected; insert it into sorted.  */
for|for
control|(
name|prev
operator|=
operator|&
name|sorted
init|;
name|prev
operator|->
name|next_child
condition|;
name|prev
operator|=
name|prev
operator|->
name|next_child
control|)
block|{
if|if
condition|(
name|cmp_arc
argument_list|(
name|arc
argument_list|,
name|prev
operator|->
name|next_child
argument_list|)
operator|!=
name|LESSTHAN
condition|)
break|break;
block|}
name|arc
operator|->
name|next_child
operator|=
name|prev
operator|->
name|next_child
expr_stmt|;
name|prev
operator|->
name|next_child
operator|=
name|arc
expr_stmt|;
block|}
comment|/* Reattach sorted children to parent.  */
name|parent
operator|->
name|cg
operator|.
name|children
operator|=
name|sorted
operator|.
name|next_child
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_children
parameter_list|(
name|Sym
modifier|*
name|parent
parameter_list|)
block|{
name|Sym
modifier|*
name|child
decl_stmt|;
name|Arc
modifier|*
name|arc
decl_stmt|;
name|sort_children
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|arc
operator|=
name|parent
operator|->
name|cg
operator|.
name|children
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|parent
operator|->
name|cg
operator|.
name|children
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_child
control|)
block|{
name|child
operator|=
name|arc
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|parent
operator|||
operator|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
operator|&&
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|==
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|)
condition|)
block|{
comment|/* Self call or call to sibling.  */
name|printf
argument_list|(
name|bsd_style_output
condition|?
literal|"%6.6s %5.5s %7.7s %11.11s %7lu %7.7s     "
else|:
literal|"%6.6s %5.5s %7.7s %7.7s %7lu %7.7s     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arc
operator|->
name|count
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Regular child of parent.  */
name|printf
argument_list|(
name|bsd_style_output
condition|?
literal|"%6.6s %5.5s %7.2f %11.2f %7lu/%-7lu     "
else|:
literal|"%6.6s %5.5s %7.2f %7.2f %7lu/%-7lu     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arc
operator|->
name|time
operator|/
name|hz
argument_list|,
name|arc
operator|->
name|child_time
operator|/
name|hz
argument_list|,
name|arc
operator|->
name|count
argument_list|,
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|->
name|ncalls
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
name|Sym
modifier|*
name|np
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%d]"
argument_list|,
name|np
operator|->
name|cg
operator|.
name|index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|bsd_style_output
condition|?
literal|"%-6.6s %5.1f %7.2f %11.2f"
else|:
literal|"%-6.6s %5.1f %7.2f %7.2f"
argument_list|,
name|buf
argument_list|,
literal|100
operator|*
operator|(
name|np
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|+
name|np
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|)
operator|/
name|print_time
argument_list|,
name|np
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|/
name|hz
argument_list|,
name|np
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|/
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|ncalls
operator|+
name|np
operator|->
name|cg
operator|.
name|self_calls
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %7lu"
argument_list|,
name|np
operator|->
name|ncalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|cg
operator|.
name|self_calls
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"+%-7lu "
argument_list|,
name|np
operator|->
name|cg
operator|.
name|self_calls
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %7.7s "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" %7.7s %7.7s "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|print_name
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print dynamic call graph.  */
end_comment

begin_function
name|void
name|cg_print
parameter_list|(
name|Sym
modifier|*
modifier|*
name|timesortsym
parameter_list|)
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|Sym
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|print_descriptions
operator|&&
name|bsd_style_output
condition|)
name|bsd_callg_blurb
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|print_header
argument_list|()
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
operator|+
name|num_cycles
condition|;
operator|++
name|index
control|)
block|{
name|parent
operator|=
name|timesortsym
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ignore_zeros
operator|&&
name|parent
operator|->
name|ncalls
operator|==
literal|0
operator|&&
name|parent
operator|->
name|cg
operator|.
name|self_calls
operator|==
literal|0
operator|&&
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|==
literal|0
operator|&&
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|==
literal|0
operator|)
operator|||
operator|!
name|parent
operator|->
name|cg
operator|.
name|print_flag
operator|||
operator|(
name|line_granularity
operator|&&
operator|!
name|parent
operator|->
name|is_func
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|parent
operator|->
name|name
operator|&&
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
condition|)
block|{
comment|/* Cycle header.  */
name|print_cycle
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|print_members
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_parents
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|print_line
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|print_children
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsd_style_output
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----------------------------------------------\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsd_style_output
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|timesortsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_descriptions
operator|&&
operator|!
name|bsd_style_output
condition|)
name|fsf_callg_blurb
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_name
parameter_list|(
specifier|const
name|PTR
name|left
parameter_list|,
specifier|const
name|PTR
name|right
parameter_list|)
block|{
specifier|const
name|Sym
modifier|*
modifier|*
name|npp1
init|=
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|left
decl_stmt|;
specifier|const
name|Sym
modifier|*
modifier|*
name|npp2
init|=
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|right
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|npp1
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|npp2
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|cg_print_index
parameter_list|()
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|unsigned
name|int
name|nnames
decl_stmt|,
name|todo
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|col
decl_stmt|,
name|starting_col
decl_stmt|;
name|Sym
modifier|*
modifier|*
name|name_sorted_syms
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|column_width
init|=
operator|(
name|output_width
operator|-
literal|1
operator|)
operator|/
literal|3
decl_stmt|;
comment|/* Don't write in last col!  */
comment|/* Now, sort regular function name      alphabetically to create an index.  */
name|name_sorted_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|symtab
operator|.
name|len
operator|+
name|num_cycles
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|nnames
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|ignore_zeros
operator|&&
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|ncalls
operator|==
literal|0
operator|&&
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|hist
operator|.
name|time
operator|==
literal|0
condition|)
continue|continue;
name|name_sorted_syms
index|[
name|nnames
operator|++
index|]
operator|=
operator|&
name|symtab
operator|.
name|base
index|[
name|index
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|name_sorted_syms
argument_list|,
name|nnames
argument_list|,
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|,
name|cmp_name
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|1
operator|,
name|todo
operator|=
name|nnames
init|;
name|index
operator|<=
name|num_cycles
condition|;
name|index
operator|++
control|)
name|name_sorted_syms
index|[
name|todo
operator|++
index|]
operator|=
operator|&
name|cycle_header
index|[
name|index
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"\f\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Index by function name\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|todo
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
name|col
operator|=
literal|0
expr_stmt|;
name|starting_col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|todo
condition|;
name|j
operator|+=
name|index
control|)
block|{
name|sym
operator|=
name|name_sorted_syms
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|cg
operator|.
name|print_flag
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%d]"
argument_list|,
name|sym
operator|->
name|cg
operator|.
name|index
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|sym
operator|->
name|cg
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|nnames
condition|)
block|{
if|if
condition|(
name|bsd_style_output
condition|)
block|{
name|printf
argument_list|(
literal|"%6.6s %-19.19s"
argument_list|,
name|buf
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|col
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|col
operator|<
name|starting_col
operator|+
literal|5
condition|;
operator|++
name|col
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|col
operator|+=
name|print_name_only
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line_granularity
operator|&&
name|sym
operator|->
name|is_static
operator|&&
name|sym
operator|->
name|file
condition|)
block|{
name|filename
operator|=
name|sym
operator|->
name|file
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|print_path
condition|)
block|{
name|filename
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
condition|)
operator|++
name|filename
expr_stmt|;
else|else
name|filename
operator|=
name|sym
operator|->
name|file
operator|->
name|name
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|col
operator|+=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|3
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|bsd_style_output
condition|)
block|{
name|printf
argument_list|(
literal|"%6.6s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"<cycle %d>"
argument_list|)
argument_list|,
name|sym
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-19.19s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|col
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|col
operator|<
name|starting_col
operator|+
literal|5
condition|;
operator|++
name|col
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"<cycle %d>"
argument_list|)
argument_list|,
name|sym
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|col
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|starting_col
operator|+=
name|column_width
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name_sorted_syms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare two arcs based on their usage counts.    We want to sort in descending order.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_arc_count
parameter_list|(
specifier|const
name|PTR
name|left
parameter_list|,
specifier|const
name|PTR
name|right
parameter_list|)
block|{
specifier|const
name|Arc
modifier|*
modifier|*
name|npp1
init|=
operator|(
specifier|const
name|Arc
operator|*
operator|*
operator|)
name|left
decl_stmt|;
specifier|const
name|Arc
modifier|*
modifier|*
name|npp2
init|=
operator|(
specifier|const
name|Arc
operator|*
operator|*
operator|)
name|right
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|npp1
operator|)
operator|->
name|count
operator|>
operator|(
operator|*
name|npp2
operator|)
operator|->
name|count
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|npp1
operator|)
operator|->
name|count
operator|<
operator|(
operator|*
name|npp2
operator|)
operator|->
name|count
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare two funtions based on their usage counts.    We want to sort in descending order.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_fun_nuses
parameter_list|(
specifier|const
name|PTR
name|left
parameter_list|,
specifier|const
name|PTR
name|right
parameter_list|)
block|{
specifier|const
name|Sym
modifier|*
modifier|*
name|npp1
init|=
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|left
decl_stmt|;
specifier|const
name|Sym
modifier|*
modifier|*
name|npp2
init|=
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|right
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|npp1
operator|)
operator|->
name|nuses
operator|>
operator|(
operator|*
name|npp2
operator|)
operator|->
name|nuses
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|npp1
operator|)
operator|->
name|nuses
operator|<
operator|(
operator|*
name|npp2
operator|)
operator|->
name|nuses
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print a suggested function ordering based on the profiling data.     We perform 4 major steps when ordering functions:  	* Group unused functions together and place them at the 	end of the function order.  	* Search the highest use arcs (those which account for 90% of 	the total arc count) for functions which have several parents.  	Group those with the most call sites together (currently the 	top 1.25% which have at least five different call sites).  	These are emitted at the start of the function order.  	* Use a greedy placement algorithm to place functions which 	occur in the top 99% of the arcs in the profile.  Some provisions 	are made to handle high usage arcs where the parent and/or 	child has already been placed.  	* Run the same greedy placement algorithm on the remaining 	arcs to place the leftover functions.      The various "magic numbers" should (one day) be tuneable by command    line options.  They were arrived at by benchmarking a few applications    with various values to see which values produced better overall function    orderings.     Of course, profiling errors, machine limitations (PA long calls), and    poor cutoff values for the placement algorithm may limit the usefullness    of the resulting function order.  Improvements would be greatly appreciated.     Suggestions:  	* Place the functions with many callers near the middle of the 	list to reduce long calls.  	* Propagate arc usage changes as functions are placed.  Ie if 	func1 and func2 are placed together, arcs to/from those arcs 	to the same parent/child should be combined, then resort the 	arcs to choose the next one.  	* Implement some global positioning algorithm to place the 	chains made by the greedy local positioning algorithm.  Probably 	by examining arcs which haven't been placed yet to tie two 	chains together.  	* Take a function's size and time into account in the algorithm; 	size in particular is important on the PA (long calls).  Placing 	many small functions onto their own page may be wise.  	* Use better profiling information; many published algorithms 	are based on call sequences through time, rather than just 	arc counts.  	* Prodecure cloning could improve performance when a small number 	of arcs account for most of the calls to a particular function.  	* Use relocation information to avoid moving unused functions 	completely out of the code stream; this would avoid severe lossage 	when the profile data bears little resemblance to actual runs.  	* Propagation of arc usages should also improve .o link line 	ordering which shares the same arc placement algorithm with 	the function ordering code (in fact it is a degenerate case 	of function ordering).  */
end_comment

begin_function
name|void
name|cg_print_function_ordering
parameter_list|()
block|{
name|unsigned
name|long
name|index
decl_stmt|,
name|used
decl_stmt|,
name|unused
decl_stmt|,
name|scratch_index
decl_stmt|;
name|unsigned
name|long
name|unplaced_arc_count
decl_stmt|,
name|high_arc_count
decl_stmt|,
name|scratch_arc_count
decl_stmt|;
ifdef|#
directive|ifdef
name|__GNUC__
name|unsigned
name|long
name|long
name|total_arcs
decl_stmt|,
name|tmp_arcs_count
decl_stmt|;
else|#
directive|else
name|unsigned
name|long
name|total_arcs
decl_stmt|,
name|tmp_arcs_count
decl_stmt|;
endif|#
directive|endif
name|Sym
modifier|*
modifier|*
name|unused_syms
decl_stmt|,
modifier|*
modifier|*
name|used_syms
decl_stmt|,
modifier|*
modifier|*
name|scratch_syms
decl_stmt|;
name|Arc
modifier|*
modifier|*
name|unplaced_arcs
decl_stmt|,
modifier|*
modifier|*
name|high_arcs
decl_stmt|,
modifier|*
modifier|*
name|scratch_arcs
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|unused
operator|=
literal|0
expr_stmt|;
name|scratch_index
operator|=
literal|0
expr_stmt|;
name|unplaced_arc_count
operator|=
literal|0
expr_stmt|;
name|high_arc_count
operator|=
literal|0
expr_stmt|;
name|scratch_arc_count
operator|=
literal|0
expr_stmt|;
comment|/* First group all the unused functions together.  */
name|unused_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|used_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|scratch_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|high_arcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|scratch_arcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|unplaced_arcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk through all the functions; mark those which are never      called as placed (we'll emit them as a group later).  */
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|used
operator|=
literal|0
operator|,
name|unused
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|ncalls
operator|==
literal|0
condition|)
block|{
comment|/* Filter out gprof generated names.  */
if|if
condition|(
name|strcmp
argument_list|(
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|name
argument_list|,
literal|"<locore>"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|name
argument_list|,
literal|"<hicore>"
argument_list|)
condition|)
block|{
name|unused_syms
index|[
name|unused
operator|++
index|]
operator|=
operator|&
name|symtab
operator|.
name|base
index|[
name|index
index|]
expr_stmt|;
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|has_been_placed
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|used_syms
index|[
name|used
operator|++
index|]
operator|=
operator|&
name|symtab
operator|.
name|base
index|[
name|index
index|]
expr_stmt|;
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|has_been_placed
operator|=
literal|0
expr_stmt|;
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|nuses
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Sort the arcs from most used to least used.  */
name|qsort
argument_list|(
name|arcs
argument_list|,
name|numarcs
argument_list|,
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|,
name|cmp_arc_count
argument_list|)
expr_stmt|;
comment|/* Compute the total arc count.  Also mark arcs as unplaced.       Note we don't compensate for overflow if that happens!      Overflow is much less likely when this file is compiled      with GCC as it can double-wide integers via long long.  */
name|total_arcs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|numarcs
condition|;
name|index
operator|++
control|)
block|{
name|total_arcs
operator|+=
name|arcs
index|[
name|index
index|]
operator|->
name|count
expr_stmt|;
name|arcs
index|[
name|index
index|]
operator|->
name|has_been_placed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We want to pull out those functions which are referenced      by many highly used arcs and emit them as a group.  This      could probably use some tuning.  */
name|tmp_arcs_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|numarcs
condition|;
name|index
operator|++
control|)
block|{
name|tmp_arcs_count
operator|+=
name|arcs
index|[
name|index
index|]
operator|->
name|count
expr_stmt|;
comment|/* Count how many times each parent and child are used up 	 to our threshhold of arcs (90%).  */
if|if
condition|(
operator|(
name|double
operator|)
name|tmp_arcs_count
operator|/
operator|(
name|double
operator|)
name|total_arcs
operator|>
literal|0.90
condition|)
break|break;
name|arcs
index|[
name|index
index|]
operator|->
name|child
operator|->
name|nuses
operator|++
expr_stmt|;
block|}
comment|/* Now sort a temporary symbol table based on the number of      times each function was used in the highest used arcs.  */
name|memcpy
argument_list|(
name|scratch_syms
argument_list|,
name|used_syms
argument_list|,
name|used
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|scratch_syms
argument_list|,
name|used
argument_list|,
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|,
name|cmp_fun_nuses
argument_list|)
expr_stmt|;
comment|/* Now pick out those symbols we're going to emit as      a group.  We take up to 1.25% of the used symbols.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|used
operator|/
literal|80
condition|;
name|index
operator|++
control|)
block|{
name|Sym
modifier|*
name|sym
init|=
name|scratch_syms
index|[
name|index
index|]
decl_stmt|;
name|Arc
modifier|*
name|arc
decl_stmt|;
comment|/* If we hit symbols that aren't used from many call sites, 	 then we can quit.  We choose five as the low limit for 	 no particular reason.  */
if|if
condition|(
name|sym
operator|->
name|nuses
operator|==
literal|5
condition|)
break|break;
comment|/* We're going to need the arcs between these functions. 	 Unfortunately, we don't know all these functions 	 until we're done.  So we keep track of all the arcs 	 to the functions we care about, then prune out those 	 which are uninteresting.  	 An interesting variation would be to quit when we found 	 multi-call site functions which account for some percentage 	 of the arcs.  */
name|arc
operator|=
name|sym
operator|->
name|cg
operator|.
name|children
expr_stmt|;
while|while
condition|(
name|arc
condition|)
block|{
if|if
condition|(
name|arc
operator|->
name|parent
operator|!=
name|arc
operator|->
name|child
condition|)
name|scratch_arcs
index|[
name|scratch_arc_count
operator|++
index|]
operator|=
name|arc
expr_stmt|;
name|arc
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
name|arc
operator|=
name|arc
operator|->
name|next_child
expr_stmt|;
block|}
name|arc
operator|=
name|sym
operator|->
name|cg
operator|.
name|parents
expr_stmt|;
while|while
condition|(
name|arc
condition|)
block|{
if|if
condition|(
name|arc
operator|->
name|parent
operator|!=
name|arc
operator|->
name|child
condition|)
name|scratch_arcs
index|[
name|scratch_arc_count
operator|++
index|]
operator|=
name|arc
expr_stmt|;
name|arc
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
name|arc
operator|=
name|arc
operator|->
name|next_parent
expr_stmt|;
block|}
comment|/* Keep track of how many symbols we're going to place.  */
name|scratch_index
operator|=
name|index
expr_stmt|;
comment|/* A lie, but it makes identifying 	 these functions easier later.  */
name|sym
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now walk through the temporary arcs and copy      those we care about into the high arcs array.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|scratch_arc_count
condition|;
name|index
operator|++
control|)
block|{
name|Arc
modifier|*
name|arc
init|=
name|scratch_arcs
index|[
name|index
index|]
decl_stmt|;
comment|/* If this arc refers to highly used functions, then 	 then we want to keep it.  */
if|if
condition|(
name|arc
operator|->
name|child
operator|->
name|has_been_placed
operator|&&
name|arc
operator|->
name|parent
operator|->
name|has_been_placed
condition|)
block|{
name|high_arcs
index|[
name|high_arc_count
operator|++
index|]
operator|=
name|scratch_arcs
index|[
name|index
index|]
expr_stmt|;
comment|/* We need to turn of has_been_placed since we're going to 	     use the main arc placement algorithm on these arcs.  */
name|arc
operator|->
name|child
operator|->
name|has_been_placed
operator|=
literal|0
expr_stmt|;
name|arc
operator|->
name|parent
operator|->
name|has_been_placed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Dump the multi-site high usage functions which are not      going to be ordered by the main ordering algorithm.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|scratch_index
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|scratch_syms
index|[
name|index
index|]
operator|->
name|has_been_placed
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|scratch_syms
index|[
name|index
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Now we can order the multi-site high use      functions based on the arcs between them.  */
name|qsort
argument_list|(
name|high_arcs
argument_list|,
name|high_arc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|,
name|cmp_arc_count
argument_list|)
expr_stmt|;
name|order_and_dump_functions_by_arcs
argument_list|(
name|high_arcs
argument_list|,
name|high_arc_count
argument_list|,
literal|1
argument_list|,
name|unplaced_arcs
argument_list|,
operator|&
name|unplaced_arc_count
argument_list|)
expr_stmt|;
comment|/* Order and dump the high use functions left,      these typically have only a few call sites.  */
name|order_and_dump_functions_by_arcs
argument_list|(
name|arcs
argument_list|,
name|numarcs
argument_list|,
literal|0
argument_list|,
name|unplaced_arcs
argument_list|,
operator|&
name|unplaced_arc_count
argument_list|)
expr_stmt|;
comment|/* Now place the rarely used functions.  */
name|order_and_dump_functions_by_arcs
argument_list|(
name|unplaced_arcs
argument_list|,
name|unplaced_arc_count
argument_list|,
literal|1
argument_list|,
name|scratch_arcs
argument_list|,
operator|&
name|scratch_arc_count
argument_list|)
expr_stmt|;
comment|/* Output any functions not emitted by the order_and_dump calls.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|used
condition|;
name|index
operator|++
control|)
if|if
condition|(
name|used_syms
index|[
name|index
index|]
operator|->
name|has_been_placed
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|used_syms
index|[
name|index
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Output the unused functions.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|unused
condition|;
name|index
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|unused_syms
index|[
name|index
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|unused_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|used_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|scratch_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|high_arcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|scratch_arcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|unplaced_arcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unused_syms
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|used_syms
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratch_syms
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|high_arcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratch_arcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unplaced_arcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place functions based on the arcs in THE_ARCS with ARC_COUNT entries;    place unused arcs into UNPLACED_ARCS/UNPLACED_ARC_COUNT.     If ALL is nonzero, then place all functions referenced by THE_ARCS,    else only place those referenced in the top 99% of the arcs in THE_ARCS.  */
end_comment

begin_define
define|#
directive|define
name|MOST
value|0.99
end_define

begin_function
specifier|static
name|void
name|order_and_dump_functions_by_arcs
parameter_list|(
name|the_arcs
parameter_list|,
name|arc_count
parameter_list|,
name|all
parameter_list|,
name|unplaced_arcs
parameter_list|,
name|unplaced_arc_count
parameter_list|)
name|Arc
modifier|*
modifier|*
name|the_arcs
decl_stmt|;
name|unsigned
name|long
name|arc_count
decl_stmt|;
name|int
name|all
decl_stmt|;
name|Arc
modifier|*
modifier|*
name|unplaced_arcs
decl_stmt|;
name|unsigned
name|long
modifier|*
name|unplaced_arc_count
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__GNUC__
name|unsigned
name|long
name|long
name|tmp_arcs
decl_stmt|,
name|total_arcs
decl_stmt|;
else|#
directive|else
name|unsigned
name|long
name|tmp_arcs
decl_stmt|,
name|total_arcs
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|index
decl_stmt|;
comment|/* If needed, compute the total arc count.       Note we don't compensate for overflow if that happens!  */
if|if
condition|(
operator|!
name|all
condition|)
block|{
name|total_arcs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|arc_count
condition|;
name|index
operator|++
control|)
name|total_arcs
operator|+=
name|the_arcs
index|[
name|index
index|]
operator|->
name|count
expr_stmt|;
block|}
else|else
name|total_arcs
operator|=
literal|0
expr_stmt|;
name|tmp_arcs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|arc_count
condition|;
name|index
operator|++
control|)
block|{
name|Sym
modifier|*
name|sym1
decl_stmt|,
modifier|*
name|sym2
decl_stmt|;
name|Sym
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|tmp_arcs
operator|+=
name|the_arcs
index|[
name|index
index|]
operator|->
name|count
expr_stmt|;
comment|/* Ignore this arc if it's already been placed.  */
if|if
condition|(
name|the_arcs
index|[
name|index
index|]
operator|->
name|has_been_placed
condition|)
continue|continue;
name|child
operator|=
name|the_arcs
index|[
name|index
index|]
operator|->
name|child
expr_stmt|;
name|parent
operator|=
name|the_arcs
index|[
name|index
index|]
operator|->
name|parent
expr_stmt|;
comment|/* If we're not using all arcs, and this is a rarely used 	 arc, then put it on the unplaced_arc list.  Similarly 	 if both the parent and child of this arc have been placed.  */
if|if
condition|(
operator|(
operator|!
name|all
operator|&&
operator|(
name|double
operator|)
name|tmp_arcs
operator|/
operator|(
name|double
operator|)
name|total_arcs
operator|>
name|MOST
operator|)
operator|||
name|child
operator|->
name|has_been_placed
operator|||
name|parent
operator|->
name|has_been_placed
condition|)
block|{
name|unplaced_arcs
index|[
operator|(
operator|*
name|unplaced_arc_count
operator|)
operator|++
index|]
operator|=
name|the_arcs
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* If all slots in the parent and child are full, then there isn't 	 anything we can do right now.  We'll place this arc on the 	 unplaced arc list in the hope that a global positioning 	 algorithm can use it to place function chains.  */
if|if
condition|(
name|parent
operator|->
name|next
operator|&&
name|parent
operator|->
name|prev
operator|&&
name|child
operator|->
name|next
operator|&&
name|child
operator|->
name|prev
condition|)
block|{
name|unplaced_arcs
index|[
operator|(
operator|*
name|unplaced_arc_count
operator|)
operator|++
index|]
operator|=
name|the_arcs
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* If the parent is unattached, then find the closest 	 place to attach it onto child's chain.   Similarly 	 for the opposite case.  */
if|if
condition|(
operator|!
name|parent
operator|->
name|next
operator|&&
operator|!
name|parent
operator|->
name|prev
condition|)
block|{
name|int
name|next_count
init|=
literal|0
decl_stmt|;
name|int
name|prev_count
init|=
literal|0
decl_stmt|;
name|Sym
modifier|*
name|prev
init|=
name|child
decl_stmt|;
name|Sym
modifier|*
name|next
init|=
name|child
decl_stmt|;
comment|/* Walk to the beginning and end of the child's chain.  */
while|while
condition|(
name|next
operator|->
name|next
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next_count
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|prev
operator|->
name|prev
condition|)
block|{
name|prev
operator|=
name|prev
operator|->
name|prev
expr_stmt|;
name|prev_count
operator|++
expr_stmt|;
block|}
comment|/* Choose the closest.  */
name|child
operator|=
name|next_count
operator|<
name|prev_count
condition|?
name|next
else|:
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|child
operator|->
name|next
operator|&&
operator|!
name|child
operator|->
name|prev
condition|)
block|{
name|int
name|next_count
init|=
literal|0
decl_stmt|;
name|int
name|prev_count
init|=
literal|0
decl_stmt|;
name|Sym
modifier|*
name|prev
init|=
name|parent
decl_stmt|;
name|Sym
modifier|*
name|next
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|next
operator|->
name|next
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next_count
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|prev
operator|->
name|prev
condition|)
block|{
name|prev
operator|=
name|prev
operator|->
name|prev
expr_stmt|;
name|prev_count
operator|++
expr_stmt|;
block|}
name|parent
operator|=
name|prev_count
operator|<
name|next_count
condition|?
name|prev
else|:
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* Couldn't find anywhere to attach the functions, 	     put the arc on the unplaced arc list.  */
name|unplaced_arcs
index|[
operator|(
operator|*
name|unplaced_arc_count
operator|)
operator|++
index|]
operator|=
name|the_arcs
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure we don't tie two ends together.  */
name|sym1
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|sym1
operator|->
name|next
condition|)
while|while
condition|(
name|sym1
operator|->
name|next
condition|)
name|sym1
operator|=
name|sym1
operator|->
name|next
expr_stmt|;
else|else
while|while
condition|(
name|sym1
operator|->
name|prev
condition|)
name|sym1
operator|=
name|sym1
operator|->
name|prev
expr_stmt|;
name|sym2
operator|=
name|child
expr_stmt|;
if|if
condition|(
name|sym2
operator|->
name|next
condition|)
while|while
condition|(
name|sym2
operator|->
name|next
condition|)
name|sym2
operator|=
name|sym2
operator|->
name|next
expr_stmt|;
else|else
while|while
condition|(
name|sym2
operator|->
name|prev
condition|)
name|sym2
operator|=
name|sym2
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|sym1
operator|==
name|child
operator|&&
name|sym2
operator|==
name|parent
condition|)
block|{
comment|/* This would tie two ends together.  */
name|unplaced_arcs
index|[
operator|(
operator|*
name|unplaced_arc_count
operator|)
operator|++
index|]
operator|=
name|the_arcs
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parent
operator|->
name|next
condition|)
block|{
comment|/* Must attach to the parent's prev field.  */
if|if
condition|(
operator|!
name|child
operator|->
name|next
condition|)
block|{
comment|/* parent-prev and child-next */
name|parent
operator|->
name|prev
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|next
operator|=
name|parent
expr_stmt|;
name|the_arcs
index|[
name|index
index|]
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|parent
operator|->
name|prev
condition|)
block|{
comment|/* Must attach to the parent's next field.  */
if|if
condition|(
operator|!
name|child
operator|->
name|prev
condition|)
block|{
comment|/* parent-next and child-prev */
name|parent
operator|->
name|next
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|prev
operator|=
name|parent
expr_stmt|;
name|the_arcs
index|[
name|index
index|]
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Can attach to either field in the parent, depends 	     on where we've got space in the child.  */
if|if
condition|(
name|child
operator|->
name|prev
condition|)
block|{
comment|/* parent-prev and child-next.  */
name|parent
operator|->
name|prev
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|next
operator|=
name|parent
expr_stmt|;
name|the_arcs
index|[
name|index
index|]
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* parent-next and child-prev.  */
name|parent
operator|->
name|next
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|prev
operator|=
name|parent
expr_stmt|;
name|the_arcs
index|[
name|index
index|]
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Dump the chains of functions we've made.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|arc_count
condition|;
name|index
operator|++
control|)
block|{
name|Sym
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|the_arcs
index|[
name|index
index|]
operator|->
name|parent
operator|->
name|has_been_placed
operator|||
name|the_arcs
index|[
name|index
index|]
operator|->
name|child
operator|->
name|has_been_placed
condition|)
continue|continue;
name|sym
operator|=
name|the_arcs
index|[
name|index
index|]
operator|->
name|parent
expr_stmt|;
comment|/* If this symbol isn't attached to any other 	 symbols, then we've got a rarely used arc.  	 Skip it for now, we'll deal with them later.  */
if|if
condition|(
name|sym
operator|->
name|next
operator|==
name|NULL
operator|&&
name|sym
operator|->
name|prev
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Get to the start of this chain.  */
while|while
condition|(
name|sym
operator|->
name|prev
condition|)
name|sym
operator|=
name|sym
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|sym
condition|)
block|{
comment|/* Mark it as placed.  */
name|sym
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|sym
operator|=
name|sym
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* If we want to place all the arcs, then output      those which weren't placed by the main algorithm.  */
if|if
condition|(
name|all
condition|)
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|arc_count
condition|;
name|index
operator|++
control|)
block|{
name|Sym
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|the_arcs
index|[
name|index
index|]
operator|->
name|parent
operator|->
name|has_been_placed
operator|||
name|the_arcs
index|[
name|index
index|]
operator|->
name|child
operator|->
name|has_been_placed
condition|)
continue|continue;
name|sym
operator|=
name|the_arcs
index|[
name|index
index|]
operator|->
name|parent
expr_stmt|;
name|sym
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a suggested .o ordering for files on a link line based    on profiling information.  This uses the function placement    code for the bulk of its work.  */
end_comment

begin_function
name|void
name|cg_print_file_ordering
parameter_list|()
block|{
name|unsigned
name|long
name|scratch_arc_count
decl_stmt|,
name|index
decl_stmt|;
name|Arc
modifier|*
modifier|*
name|scratch_arcs
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
name|scratch_arc_count
operator|=
literal|0
expr_stmt|;
name|scratch_arcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|numarcs
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|arcs
index|[
name|index
index|]
operator|->
name|parent
operator|->
name|mapped
operator|||
operator|!
name|arcs
index|[
name|index
index|]
operator|->
name|child
operator|->
name|mapped
condition|)
name|arcs
index|[
name|index
index|]
operator|->
name|has_been_placed
operator|=
literal|1
expr_stmt|;
block|}
name|order_and_dump_functions_by_arcs
argument_list|(
name|arcs
argument_list|,
name|numarcs
argument_list|,
literal|0
argument_list|,
name|scratch_arcs
argument_list|,
operator|&
name|scratch_arc_count
argument_list|)
expr_stmt|;
comment|/* Output .o's not handled by the main placement algorithm.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|mapped
operator|&&
operator|!
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|has_been_placed
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|symtab
operator|.
name|base
index|[
name|index
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Now output any .o's that didn't have any text symbols.  */
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symbol_map_count
condition|;
name|index
operator|++
control|)
block|{
name|unsigned
name|int
name|index2
decl_stmt|;
comment|/* Don't bother searching if this symbol 	 is the same as the previous one.  */
if|if
condition|(
name|last
operator|&&
operator|!
name|strcmp
argument_list|(
name|last
argument_list|,
name|symbol_map
index|[
name|index
index|]
operator|.
name|file_name
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|index2
operator|=
literal|0
init|;
name|index2
operator|<
name|symtab
operator|.
name|len
condition|;
name|index2
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|symtab
operator|.
name|base
index|[
name|index2
index|]
operator|.
name|mapped
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symtab
operator|.
name|base
index|[
name|index2
index|]
operator|.
name|name
argument_list|,
name|symbol_map
index|[
name|index
index|]
operator|.
name|file_name
argument_list|)
condition|)
break|break;
block|}
comment|/* If we didn't find it in the symbol table, then it must 	 be a .o with no text symbols.  Output it last.  */
if|if
condition|(
name|index2
operator|==
name|symtab
operator|.
name|len
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|symbol_map
index|[
name|index
index|]
operator|.
name|file_name
argument_list|)
expr_stmt|;
name|last
operator|=
name|symbol_map
index|[
name|index
index|]
operator|.
name|file_name
expr_stmt|;
block|}
block|}
end_function

end_unit

