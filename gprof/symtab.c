begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* symtab.c     Copyright 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"cg_arcs.h"
end_include

begin_include
include|#
directive|include
file|"corefile.h"
end_include

begin_function_decl
specifier|static
name|int
name|cmp_addr
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|Sym_Table
name|symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a symbol (so it's empty).  */
end_comment

begin_function
name|void
name|sym_init
parameter_list|(
name|Sym
modifier|*
name|sym
parameter_list|)
block|{
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It is not safe to assume that a binary zero corresponds      to a floating-point 0.0, so initialize floats explicitly.  */
name|sym
operator|->
name|hist
operator|.
name|time
operator|=
literal|0.0
expr_stmt|;
name|sym
operator|->
name|cg
operator|.
name|child_time
operator|=
literal|0.0
expr_stmt|;
name|sym
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|=
literal|0.0
expr_stmt|;
name|sym
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|=
literal|0.0
expr_stmt|;
name|sym
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|=
literal|0.0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare the function entry-point of two symbols and return<0, =0,    or>0 depending on whether the left value is smaller than, equal    to, or greater than the right value.  If two symbols are equal    but one has is_func set and the other doesn't, we make the    non-function symbol one "bigger" so that the function symbol will    survive duplicate removal.  Finally, if both symbols have the    same is_func value, we discriminate against is_static such that    the global symbol survives.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_addr
parameter_list|(
specifier|const
name|PTR
name|lp
parameter_list|,
specifier|const
name|PTR
name|rp
parameter_list|)
block|{
specifier|const
name|Sym
modifier|*
name|left
init|=
operator|(
specifier|const
name|Sym
operator|*
operator|)
name|lp
decl_stmt|;
specifier|const
name|Sym
modifier|*
name|right
init|=
operator|(
specifier|const
name|Sym
operator|*
operator|)
name|rp
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|addr
operator|>
name|right
operator|->
name|addr
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|left
operator|->
name|addr
operator|<
name|right
operator|->
name|addr
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|left
operator|->
name|is_func
operator|!=
name|right
operator|->
name|is_func
condition|)
return|return
name|right
operator|->
name|is_func
operator|-
name|left
operator|->
name|is_func
return|;
return|return
name|left
operator|->
name|is_static
operator|-
name|right
operator|->
name|is_static
return|;
block|}
end_function

begin_function
name|void
name|symtab_finalize
parameter_list|(
name|Sym_Table
modifier|*
name|tab
parameter_list|)
block|{
name|Sym
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|bfd_vma
name|prev_addr
decl_stmt|;
if|if
condition|(
operator|!
name|tab
operator|->
name|len
condition|)
return|return;
comment|/* Sort symbol table in order of increasing function addresses.  */
name|qsort
argument_list|(
name|tab
operator|->
name|base
argument_list|,
name|tab
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|Sym
argument_list|)
argument_list|,
name|cmp_addr
argument_list|)
expr_stmt|;
comment|/* Remove duplicate entries to speed-up later processing and      set end_addr if its not set yet.  */
name|prev_addr
operator|=
name|tab
operator|->
name|base
index|[
literal|0
index|]
operator|.
name|addr
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|src
operator|=
name|dst
operator|=
name|tab
operator|->
name|base
init|;
name|src
operator|<
name|tab
operator|->
name|limit
condition|;
operator|++
name|src
control|)
block|{
if|if
condition|(
name|src
operator|->
name|addr
operator|==
name|prev_addr
condition|)
block|{
comment|/* If same address, favor global symbol over static one, 	     then function over line number.  If both symbols are 	     either static or global and either function or line, check 	     whether one has name beginning with underscore while 	     the other doesn't.  In such cases, keep sym without 	     underscore.  This takes cares of compiler generated 	     symbols (such as __gnu_compiled, __c89_used, etc.).  */
if|if
condition|(
operator|(
operator|!
name|src
operator|->
name|is_static
operator|&&
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|is_static
operator|)
operator|||
operator|(
operator|(
name|src
operator|->
name|is_static
operator|==
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|is_static
operator|)
operator|&&
operator|(
operator|(
name|src
operator|->
name|is_func
operator|&&
operator|!
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|is_func
operator|)
operator|||
operator|(
operator|(
name|src
operator|->
name|is_func
operator|==
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|is_func
operator|)
operator|&&
operator|(
operator|(
name|src
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|&&
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|)
operator|||
operator|(
name|src
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|src
operator|->
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
operator|&&
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|DBG
argument_list|(
argument|AOUTDEBUG | IDDEBUG
argument_list|,
argument|printf (
literal|"[symtab_finalize] favor %s@%c%c over %s@%c%c"
argument|, 			   src->name, src->is_static ?
literal|'t'
argument|:
literal|'T'
argument|, 			   src->is_func ?
literal|'F'
argument|:
literal|'f'
argument|, 			   dst[-
literal|1
argument|].name, dst[-
literal|1
argument|].is_static ?
literal|'t'
argument|:
literal|'T'
argument|, 			   dst[-
literal|1
argument|].is_func ?
literal|'F'
argument|:
literal|'f'
argument|); 		   printf (
literal|" (addr=%lx)\n"
argument|, (unsigned long) src->addr)
argument_list|)
empty_stmt|;
name|dst
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|src
expr_stmt|;
block|}
else|else
block|{
name|DBG
argument_list|(
argument|AOUTDEBUG | IDDEBUG
argument_list|,
argument|printf (
literal|"[symtab_finalize] favor %s@%c%c over %s@%c%c"
argument|, 			   dst[-
literal|1
argument|].name, dst[-
literal|1
argument|].is_static ?
literal|'t'
argument|:
literal|'T'
argument|, 			   dst[-
literal|1
argument|].is_func ?
literal|'F'
argument|:
literal|'f'
argument|, 			   src->name, src->is_static ?
literal|'t'
argument|:
literal|'T'
argument|, 			   src->is_func ?
literal|'F'
argument|:
literal|'f'
argument|); 		   printf (
literal|" (addr=%lx)\n"
argument|, (unsigned long) src->addr)
argument_list|)
empty_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dst
operator|>
name|tab
operator|->
name|base
operator|&&
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|end_addr
operator|==
literal|0
condition|)
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|end_addr
operator|=
name|src
operator|->
name|addr
operator|-
literal|1
expr_stmt|;
comment|/* Retain sym only if it has a non-empty address range.  */
if|if
condition|(
operator|!
name|src
operator|->
name|end_addr
operator|||
name|src
operator|->
name|addr
operator|<=
name|src
operator|->
name|end_addr
condition|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|prev_addr
operator|=
name|src
operator|->
name|addr
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tab
operator|->
name|len
operator|>
literal|0
operator|&&
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|end_addr
operator|==
literal|0
condition|)
name|dst
index|[
operator|-
literal|1
index|]
operator|.
name|end_addr
operator|=
name|core_text_sect
operator|->
name|vma
operator|+
name|bfd_get_section_size
argument_list|(
name|core_text_sect
argument_list|)
operator|-
literal|1
expr_stmt|;
name|DBG
argument_list|(
name|AOUTDEBUG
operator||
name|IDDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[symtab_finalize]: removed %d duplicate entries\n"
argument_list|,
name|tab
operator|->
name|len
operator|-
call|(
name|int
call|)
argument_list|(
name|dst
operator|-
name|tab
operator|->
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tab
operator|->
name|limit
operator|=
name|dst
expr_stmt|;
name|tab
operator|->
name|len
operator|=
name|tab
operator|->
name|limit
operator|-
name|tab
operator|->
name|base
expr_stmt|;
name|DBG
argument_list|(
argument|AOUTDEBUG | IDDEBUG
argument_list|,
argument|unsigned int j;         for (j =
literal|0
argument|; j< tab->len; ++j) 	 { 	   printf (
literal|"[symtab_finalize] 0x%lx-0x%lx\t%s\n"
argument|, 		 (long) tab->base[j].addr, (long) tab->base[j].end_addr, 		 tab->base[j].name); 	 }
argument_list|)
empty_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|Sym
modifier|*
name|dbg_sym_lookup
parameter_list|(
name|Sym_Table
modifier|*
name|sym_tab
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|long
name|low
decl_stmt|,
name|mid
decl_stmt|,
name|high
decl_stmt|;
name|Sym
modifier|*
name|sym
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[dbg_sym_lookup] address 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address
argument_list|)
expr_stmt|;
name|sym
operator|=
name|sym_tab
operator|->
name|base
expr_stmt|;
for|for
control|(
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|sym_tab
operator|->
name|len
operator|-
literal|1
init|;
name|low
operator|!=
name|high
condition|;
control|)
block|{
name|mid
operator|=
operator|(
name|high
operator|+
name|low
operator|)
operator|>>
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[dbg_sym_lookup] low=0x%lx, mid=0x%lx, high=0x%lx\n"
argument_list|,
name|low
argument_list|,
name|mid
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[dbg_sym_lookup] sym[m]=0x%lx sym[m + 1]=0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
index|[
name|mid
index|]
operator|.
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
index|[
name|mid
index|]
operator|.
name|addr
operator|<=
name|address
operator|&&
name|sym
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|addr
operator|>
name|address
condition|)
return|return
operator|&
name|sym
index|[
name|mid
index|]
return|;
if|if
condition|(
name|sym
index|[
name|mid
index|]
operator|.
name|addr
operator|>
name|address
condition|)
name|high
operator|=
name|mid
expr_stmt|;
else|else
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[dbg_sym_lookup] binary search fails???\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Look up an address in the symbol-table that is sorted by address.    If address does not hit any symbol, 0 is returned.  */
end_comment

begin_function
name|Sym
modifier|*
name|sym_lookup
parameter_list|(
name|Sym_Table
modifier|*
name|sym_tab
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|long
name|low
decl_stmt|,
name|high
decl_stmt|;
name|long
name|mid
init|=
operator|-
literal|1
decl_stmt|;
name|Sym
modifier|*
name|sym
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|probes
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|sym_tab
operator|->
name|len
condition|)
return|return
literal|0
return|;
name|sym
operator|=
name|sym_tab
operator|->
name|base
expr_stmt|;
for|for
control|(
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|sym_tab
operator|->
name|len
operator|-
literal|1
init|;
name|low
operator|!=
name|high
condition|;
control|)
block|{
name|DBG
argument_list|(
name|LOOKUPDEBUG
argument_list|,
operator|++
name|probes
argument_list|)
expr_stmt|;
name|mid
operator|=
operator|(
name|high
operator|+
name|low
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|sym
index|[
name|mid
index|]
operator|.
name|addr
operator|<=
name|address
operator|&&
name|sym
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|addr
operator|>
name|address
condition|)
block|{
if|if
condition|(
name|address
operator|>
name|sym
index|[
name|mid
index|]
operator|.
name|end_addr
condition|)
block|{
comment|/* Address falls into gap between 		 sym[mid] and sym[mid + 1].  */
return|return
literal|0
return|;
block|}
else|else
block|{
name|DBG
argument_list|(
name|LOOKUPDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[sym_lookup] %d probes (symtab->len=%u)\n"
argument_list|,
name|probes
argument_list|,
name|sym_tab
operator|->
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|sym
index|[
name|mid
index|]
return|;
block|}
block|}
if|if
condition|(
name|sym
index|[
name|mid
index|]
operator|.
name|addr
operator|>
name|address
condition|)
name|high
operator|=
name|mid
expr_stmt|;
else|else
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sym
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|addr
operator|<=
name|address
condition|)
block|{
if|if
condition|(
name|address
operator|>
name|sym
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|end_addr
condition|)
block|{
comment|/* Address is beyond end of sym[mid + 1].  */
return|return
literal|0
return|;
block|}
else|else
block|{
name|DBG
argument_list|(
name|LOOKUPDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[sym_lookup] %d (%u) probes, fall off\n"
argument_list|,
name|probes
argument_list|,
name|sym_tab
operator|->
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|sym
index|[
name|mid
operator|+
literal|1
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

