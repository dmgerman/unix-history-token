begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993, 2001  *      The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"search_list.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"call_graph.h"
end_include

begin_include
include|#
directive|include
file|"cg_arcs.h"
end_include

begin_include
include|#
directive|include
file|"cg_dfn.h"
end_include

begin_include
include|#
directive|include
file|"cg_print.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_include
include|#
directive|include
file|"sym_ids.h"
end_include

begin_function_decl
specifier|static
name|int
name|cmp_topo
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_time
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cycle_time
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cycle_link
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inherit_flags
parameter_list|(
name|Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_flags
parameter_list|(
name|Sym
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_total
parameter_list|(
specifier|const
name|PTR
parameter_list|,
specifier|const
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|Sym
modifier|*
name|cycle_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_cycles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Arc
modifier|*
modifier|*
name|arcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|numarcs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return TRUE iff PARENT has an arc to covers the address  * range covered by CHILD.  */
end_comment

begin_function
name|Arc
modifier|*
name|arc_lookup
parameter_list|(
name|Sym
modifier|*
name|parent
parameter_list|,
name|Sym
modifier|*
name|child
parameter_list|)
block|{
name|Arc
modifier|*
name|arc
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|||
operator|!
name|child
condition|)
block|{
name|printf
argument_list|(
literal|"[arc_lookup] parent == 0 || child == 0\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DBG
argument_list|(
name|LOOKUPDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[arc_lookup] parent %s child %s\n"
argument_list|,
name|parent
operator|->
name|name
argument_list|,
name|child
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|parent
operator|->
name|cg
operator|.
name|children
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_child
control|)
block|{
name|DBG
argument_list|(
name|LOOKUPDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[arc_lookup]\t parent %s child %s\n"
argument_list|,
name|arc
operator|->
name|parent
operator|->
name|name
argument_list|,
name|arc
operator|->
name|child
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|addr
operator|>=
name|arc
operator|->
name|child
operator|->
name|addr
operator|&&
name|child
operator|->
name|end_addr
operator|<=
name|arc
operator|->
name|child
operator|->
name|end_addr
condition|)
block|{
return|return
name|arc
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add (or just increment) an arc:  */
end_comment

begin_function
name|void
name|arc_add
parameter_list|(
name|Sym
modifier|*
name|parent
parameter_list|,
name|Sym
modifier|*
name|child
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|maxarcs
init|=
literal|0
decl_stmt|;
name|Arc
modifier|*
name|arc
decl_stmt|,
modifier|*
modifier|*
name|newarcs
decl_stmt|;
name|DBG
argument_list|(
name|TALLYDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[arc_add] %lu arcs from %s to %s\n"
argument_list|,
name|count
argument_list|,
name|parent
operator|->
name|name
argument_list|,
name|child
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|arc
operator|=
name|arc_lookup
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
condition|)
block|{
comment|/*        * A hit: just increment the count.        */
name|DBG
argument_list|(
name|TALLYDEBUG
argument_list|,
name|printf
argument_list|(
literal|"[tally] hit %lu += %lu\n"
argument_list|,
name|arc
operator|->
name|count
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|arc
operator|->
name|count
operator|+=
name|count
expr_stmt|;
return|return;
block|}
name|arc
operator|=
operator|(
name|Arc
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|arc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|arc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arc
argument_list|)
argument_list|)
expr_stmt|;
name|arc
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|arc
operator|->
name|child
operator|=
name|child
expr_stmt|;
name|arc
operator|->
name|count
operator|=
name|count
expr_stmt|;
comment|/* If this isn't an arc for a recursive call to parent, then add it      to the array of arcs.  */
if|if
condition|(
name|parent
operator|!=
name|child
condition|)
block|{
comment|/* If we've exhausted space in our current array, get a new one 	 and copy the contents.   We might want to throttle the doubling 	 factor one day.  */
if|if
condition|(
name|numarcs
operator|==
name|maxarcs
condition|)
block|{
comment|/* Determine how much space we want to allocate.  */
if|if
condition|(
name|maxarcs
operator|==
literal|0
condition|)
name|maxarcs
operator|=
literal|1
expr_stmt|;
name|maxarcs
operator|*=
literal|2
expr_stmt|;
comment|/* Allocate the new array.  */
name|newarcs
operator|=
operator|(
name|Arc
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
operator|*
name|maxarcs
argument_list|)
expr_stmt|;
comment|/* Copy the old array's contents into the new array.  */
name|memcpy
argument_list|(
name|newarcs
argument_list|,
name|arcs
argument_list|,
name|numarcs
operator|*
sizeof|sizeof
argument_list|(
name|Arc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free up the old array.  */
name|free
argument_list|(
name|arcs
argument_list|)
expr_stmt|;
comment|/* And make the new array be the current array.  */
name|arcs
operator|=
name|newarcs
expr_stmt|;
block|}
comment|/* Place this arc in the arc array.  */
name|arcs
index|[
name|numarcs
operator|++
index|]
operator|=
name|arc
expr_stmt|;
block|}
comment|/* prepend this child to the children of this parent: */
name|arc
operator|->
name|next_child
operator|=
name|parent
operator|->
name|cg
operator|.
name|children
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|children
operator|=
name|arc
expr_stmt|;
comment|/* prepend this parent to the parents of this child: */
name|arc
operator|->
name|next_parent
operator|=
name|child
operator|->
name|cg
operator|.
name|parents
expr_stmt|;
name|child
operator|->
name|cg
operator|.
name|parents
operator|=
name|arc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_topo
parameter_list|(
specifier|const
name|PTR
name|lp
parameter_list|,
specifier|const
name|PTR
name|rp
parameter_list|)
block|{
specifier|const
name|Sym
modifier|*
name|left
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|lp
decl_stmt|;
specifier|const
name|Sym
modifier|*
name|right
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|rp
decl_stmt|;
return|return
name|left
operator|->
name|cg
operator|.
name|top_order
operator|-
name|right
operator|->
name|cg
operator|.
name|top_order
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|propagate_time
parameter_list|(
name|Sym
modifier|*
name|parent
parameter_list|)
block|{
name|Arc
modifier|*
name|arc
decl_stmt|;
name|Sym
modifier|*
name|child
decl_stmt|;
name|double
name|share
decl_stmt|,
name|prop_share
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|==
literal|0.0
condition|)
block|{
return|return;
block|}
comment|/* gather time from children of this parent: */
for|for
control|(
name|arc
operator|=
name|parent
operator|->
name|cg
operator|.
name|children
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_child
control|)
block|{
name|child
operator|=
name|arc
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|count
operator|==
literal|0
operator|||
name|child
operator|==
name|parent
operator|||
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|!=
name|child
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|==
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|parent
operator|->
name|cg
operator|.
name|top_order
operator|<=
name|child
operator|->
name|cg
operator|.
name|top_order
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[propagate] toporder botches\n"
argument_list|)
expr_stmt|;
block|}
name|child
operator|=
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parent
operator|->
name|cg
operator|.
name|top_order
operator|<=
name|child
operator|->
name|cg
operator|.
name|top_order
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[propagate] toporder botches\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|ncalls
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* distribute time for this arc: */
name|arc
operator|->
name|time
operator|=
name|child
operator|->
name|hist
operator|.
name|time
operator|*
operator|(
operator|(
operator|(
name|double
operator|)
name|arc
operator|->
name|count
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|child
operator|->
name|ncalls
operator|)
operator|)
expr_stmt|;
name|arc
operator|->
name|child_time
operator|=
name|child
operator|->
name|cg
operator|.
name|child_time
operator|*
operator|(
operator|(
operator|(
name|double
operator|)
name|arc
operator|->
name|count
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|child
operator|->
name|ncalls
operator|)
operator|)
expr_stmt|;
name|share
operator|=
name|arc
operator|->
name|time
operator|+
name|arc
operator|->
name|child_time
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|child_time
operator|+=
name|share
expr_stmt|;
comment|/* (1 - cg.prop.fract) gets lost along the way: */
name|prop_share
operator|=
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|*
name|share
expr_stmt|;
comment|/* fix things for printing: */
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|+=
name|prop_share
expr_stmt|;
name|arc
operator|->
name|time
operator|*=
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
expr_stmt|;
name|arc
operator|->
name|child_time
operator|*=
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
expr_stmt|;
comment|/* add this share to the parent's cycle header, if any: */
if|if
condition|(
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|!=
name|parent
condition|)
block|{
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|->
name|cg
operator|.
name|child_time
operator|+=
name|share
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|+=
name|prop_share
expr_stmt|;
block|}
name|DBG
argument_list|(
argument|PROPDEBUG
argument_list|,
argument|printf (
literal|"[prop_time] child \t"
argument|); 	   print_name (child); 	   printf (
literal|" with %f %f %lu/%lu\n"
argument|, child->hist.time, 		   child->cg.child_time, arc->count, child->ncalls); 	   printf (
literal|"[prop_time] parent\t"
argument|); 	   print_name (parent); 	   printf (
literal|"\n[prop_time] share %f\n"
argument|, share)
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the time of a cycle as the sum of the times of all  * its members.  */
end_comment

begin_function
specifier|static
name|void
name|cycle_time
parameter_list|()
block|{
name|Sym
modifier|*
name|member
decl_stmt|,
modifier|*
name|cyc
decl_stmt|;
for|for
control|(
name|cyc
operator|=
operator|&
name|cycle_header
index|[
literal|1
index|]
init|;
name|cyc
operator|<=
operator|&
name|cycle_header
index|[
name|num_cycles
index|]
condition|;
operator|++
name|cyc
control|)
block|{
for|for
control|(
name|member
operator|=
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
init|;
name|member
condition|;
name|member
operator|=
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
if|if
condition|(
name|member
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|==
literal|0.0
condition|)
block|{
comment|/* 	       * All members have the same propfraction except those 	       * that were excluded with -E. 	       */
continue|continue;
block|}
name|cyc
operator|->
name|hist
operator|.
name|time
operator|+=
name|member
operator|->
name|hist
operator|.
name|time
expr_stmt|;
block|}
name|cyc
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|=
name|cyc
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|*
name|cyc
operator|->
name|hist
operator|.
name|time
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cycle_link
parameter_list|()
block|{
name|Sym
modifier|*
name|sym
decl_stmt|,
modifier|*
name|cyc
decl_stmt|,
modifier|*
name|member
decl_stmt|;
name|Arc
modifier|*
name|arc
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* count the number of cycles, and initialize the cycle lists: */
name|num_cycles
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
comment|/* this is how you find unattached cycles: */
if|if
condition|(
name|sym
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|==
name|sym
operator|&&
name|sym
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
condition|)
block|{
operator|++
name|num_cycles
expr_stmt|;
block|}
block|}
comment|/*    * cycle_header is indexed by cycle number: i.e. it is origin 1,    * not origin 0.    */
name|cycle_header
operator|=
operator|(
name|Sym
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|num_cycles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Now link cycles to true cycle-heads, number them, accumulate    * the data for the cycle.    */
name|num
operator|=
literal|0
expr_stmt|;
name|cyc
operator|=
name|cycle_header
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|symtab
operator|.
name|base
init|;
name|sym
operator|<
name|symtab
operator|.
name|limit
condition|;
operator|++
name|sym
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sym
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|==
name|sym
operator|&&
name|sym
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
operator|++
name|num
expr_stmt|;
operator|++
name|cyc
expr_stmt|;
name|sym_init
argument_list|(
name|cyc
argument_list|)
expr_stmt|;
name|cyc
operator|->
name|cg
operator|.
name|print_flag
operator|=
name|TRUE
expr_stmt|;
comment|/* should this be printed? */
name|cyc
operator|->
name|cg
operator|.
name|top_order
operator|=
name|DFN_NAN
expr_stmt|;
comment|/* graph call chain top-sort order */
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|=
name|num
expr_stmt|;
comment|/* internal number of cycle on */
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|=
name|cyc
expr_stmt|;
comment|/* pointer to head of cycle */
name|cyc
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|=
name|sym
expr_stmt|;
comment|/* pointer to next member of cycle */
name|DBG
argument_list|(
argument|CYCLEDEBUG
argument_list|,
argument|printf (
literal|"[cycle_link] "
argument|); 	   print_name (sym); 	   printf (
literal|" is the head of cycle %d\n"
argument|, num)
argument_list|)
empty_stmt|;
comment|/* link members to cycle header: */
for|for
control|(
name|member
operator|=
name|sym
init|;
name|member
condition|;
name|member
operator|=
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|=
name|num
expr_stmt|;
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|=
name|cyc
expr_stmt|;
block|}
comment|/*        * Count calls from outside the cycle and those among cycle        * members:        */
for|for
control|(
name|member
operator|=
name|sym
init|;
name|member
condition|;
name|member
operator|=
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
for|for
control|(
name|arc
operator|=
name|member
operator|->
name|cg
operator|.
name|parents
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_parent
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|parent
operator|==
name|member
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|arc
operator|->
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|==
name|num
condition|)
block|{
name|cyc
operator|->
name|cg
operator|.
name|self_calls
operator|+=
name|arc
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
name|cyc
operator|->
name|ncalls
operator|+=
name|arc
operator|->
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check if any parent of this child (or outside parents of this  * cycle) have their print flags on and set the print flag of the  * child (cycle) appropriately.  Similarly, deal with propagation  * fractions from parents.  */
end_comment

begin_function
specifier|static
name|void
name|inherit_flags
parameter_list|(
name|Sym
modifier|*
name|child
parameter_list|)
block|{
name|Sym
modifier|*
name|head
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|member
decl_stmt|;
name|Arc
modifier|*
name|arc
decl_stmt|;
name|head
operator|=
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|head
condition|)
block|{
comment|/* just a regular child, check its parents: */
name|child
operator|->
name|cg
operator|.
name|print_flag
operator|=
name|FALSE
expr_stmt|;
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|child
operator|->
name|cg
operator|.
name|parents
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_parent
control|)
block|{
name|parent
operator|=
name|arc
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|parent
condition|)
block|{
continue|continue;
block|}
name|child
operator|->
name|cg
operator|.
name|print_flag
operator||=
name|parent
operator|->
name|cg
operator|.
name|print_flag
expr_stmt|;
comment|/* 	   * If the child was never actually called (e.g., this arc 	   * is static (and all others are, too)) no time propagates 	   * along this arc. 	   */
if|if
condition|(
name|child
operator|->
name|ncalls
operator|!=
literal|0
condition|)
block|{
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|+=
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|*
operator|(
operator|(
operator|(
name|double
operator|)
name|arc
operator|->
name|count
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|child
operator|->
name|ncalls
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/*        * Its a member of a cycle, look at all parents from outside        * the cycle.        */
name|head
operator|->
name|cg
operator|.
name|print_flag
operator|=
name|FALSE
expr_stmt|;
name|head
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|member
operator|=
name|head
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
init|;
name|member
condition|;
name|member
operator|=
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
for|for
control|(
name|arc
operator|=
name|member
operator|->
name|cg
operator|.
name|parents
init|;
name|arc
condition|;
name|arc
operator|=
name|arc
operator|->
name|next_parent
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|==
name|head
condition|)
block|{
continue|continue;
block|}
name|parent
operator|=
name|arc
operator|->
name|parent
expr_stmt|;
name|head
operator|->
name|cg
operator|.
name|print_flag
operator||=
name|parent
operator|->
name|cg
operator|.
name|print_flag
expr_stmt|;
comment|/* 	       * If the cycle was never actually called (e.g. this 	       * arc is static (and all others are, too)) no time 	       * propagates along this arc. 	       */
if|if
condition|(
name|head
operator|->
name|ncalls
operator|!=
literal|0
condition|)
block|{
name|head
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|+=
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|*
operator|(
operator|(
operator|(
name|double
operator|)
name|arc
operator|->
name|count
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|head
operator|->
name|ncalls
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|member
operator|=
name|head
init|;
name|member
condition|;
name|member
operator|=
name|member
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
control|)
block|{
name|member
operator|->
name|cg
operator|.
name|print_flag
operator|=
name|head
operator|->
name|cg
operator|.
name|print_flag
expr_stmt|;
name|member
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|=
name|head
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * In one top-to-bottom pass over the topologically sorted symbols  * propagate:  *      cg.print_flag as the union of parents' print_flags  *      propfraction as the sum of fractional parents' propfractions  * and while we're here, sum time for functions.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_flags
parameter_list|(
name|Sym
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|Sym
modifier|*
name|old_head
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|old_head
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
name|symtab
operator|.
name|len
operator|-
literal|1
init|;
name|index
operator|>=
literal|0
condition|;
operator|--
name|index
control|)
block|{
name|child
operator|=
name|symbols
index|[
name|index
index|]
expr_stmt|;
comment|/*        * If we haven't done this function or cycle, inherit things        * from parent.  This way, we are linear in the number of arcs        * since we do all members of a cycle (and the cycle itself)        * as we hit the first member of the cycle.        */
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|!=
name|old_head
condition|)
block|{
name|old_head
operator|=
name|child
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
expr_stmt|;
name|inherit_flags
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|DBG
argument_list|(
argument|PROPDEBUG
argument_list|,
argument|printf (
literal|"[prop_flags] "
argument|); 	   print_name (child); 	   printf (
literal|"inherits print-flag %d and prop-fract %f\n"
argument|, 		   child->cg.print_flag, child->cg.prop.fract)
argument_list|)
empty_stmt|;
if|if
condition|(
operator|!
name|child
operator|->
name|cg
operator|.
name|print_flag
condition|)
block|{
comment|/* 	   * Printflag is off. It gets turned on by being in the 	   * INCL_GRAPH table, or there being an empty INCL_GRAPH 	   * table and not being in the EXCL_GRAPH table. 	   */
if|if
condition|(
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_GRAPH
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
operator|||
operator|(
name|syms
index|[
name|INCL_GRAPH
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_GRAPH
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
operator|)
condition|)
block|{
name|child
operator|->
name|cg
operator|.
name|print_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	   * This function has printing parents: maybe someone wants 	   * to shut it up by putting it in the EXCL_GRAPH table. 	   * (But favor INCL_GRAPH over EXCL_GRAPH.) 	   */
if|if
condition|(
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_GRAPH
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
operator|&&
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_GRAPH
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
condition|)
block|{
name|child
operator|->
name|cg
operator|.
name|print_flag
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|==
literal|0.0
condition|)
block|{
comment|/* 	   * No parents to pass time to.  Collect time from children 	   * if its in the INCL_TIME table, or there is an empty 	   * INCL_TIME table and its not in the EXCL_TIME table. 	   */
if|if
condition|(
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_TIME
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
operator|||
operator|(
name|syms
index|[
name|INCL_TIME
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_TIME
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
operator|)
condition|)
block|{
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|=
literal|1.0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	   * It has parents to pass time to, but maybe someone wants 	   * to shut it up by puttting it in the EXCL_TIME table. 	   * (But favor being in INCL_TIME tabe over being in 	   * EXCL_TIME table.) 	   */
if|if
condition|(
operator|!
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|INCL_TIME
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
operator|&&
name|sym_lookup
argument_list|(
operator|&
name|syms
index|[
name|EXCL_TIME
index|]
argument_list|,
name|child
operator|->
name|addr
argument_list|)
condition|)
block|{
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|=
name|child
operator|->
name|hist
operator|.
name|time
operator|*
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
expr_stmt|;
name|print_time
operator|+=
name|child
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
expr_stmt|;
name|DBG
argument_list|(
argument|PROPDEBUG
argument_list|,
argument|printf (
literal|"[prop_flags] "
argument|); 	   print_name (child); 	   printf (
literal|" ends up with printflag %d and prop-fract %f\n"
argument|, 		   child->cg.print_flag, child->cg.prop.fract); 	   printf (
literal|"[prop_flags] time %f propself %f print_time %f\n"
argument|, 		   child->hist.time, child->cg.prop.self, print_time)
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare by decreasing propagated time.  If times are equal, but one  * is a cycle header, say that's first (e.g. less, i.e. -1).  If one's  * name doesn't have an underscore and the other does, say that one is  * first.  All else being equal, compare by names.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_total
parameter_list|(
specifier|const
name|PTR
name|lp
parameter_list|,
specifier|const
name|PTR
name|rp
parameter_list|)
block|{
specifier|const
name|Sym
modifier|*
name|left
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|lp
decl_stmt|;
specifier|const
name|Sym
modifier|*
name|right
init|=
operator|*
operator|(
specifier|const
name|Sym
operator|*
operator|*
operator|)
name|rp
decl_stmt|;
name|double
name|diff
decl_stmt|;
name|diff
operator|=
operator|(
name|left
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|+
name|left
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|)
operator|-
operator|(
name|right
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|+
name|right
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|diff
operator|>
literal|0.0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|left
operator|->
name|name
operator|&&
name|left
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|right
operator|->
name|name
operator|&&
name|right
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|!=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|left
operator|->
name|name
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|right
operator|->
name|name
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|left
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|&&
name|right
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|left
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|right
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|left
operator|->
name|ncalls
operator|>
name|right
operator|->
name|ncalls
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|left
operator|->
name|ncalls
operator|<
name|right
operator|->
name|ncalls
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
name|strcmp
argument_list|(
name|left
operator|->
name|name
argument_list|,
name|right
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Topologically sort the graph (collapsing cycles), and propagates  * time bottom up and flags top down.  */
end_comment

begin_function
name|Sym
modifier|*
modifier|*
name|cg_assemble
parameter_list|()
block|{
name|Sym
modifier|*
name|parent
decl_stmt|,
modifier|*
modifier|*
name|time_sorted_syms
decl_stmt|,
modifier|*
modifier|*
name|top_sorted_syms
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|Arc
modifier|*
name|arc
decl_stmt|;
comment|/*    * initialize various things:    *      zero out child times.    *      count self-recursive calls.    *      indicate that nothing is on cycles.    */
for|for
control|(
name|parent
operator|=
name|symtab
operator|.
name|base
init|;
name|parent
operator|<
name|symtab
operator|.
name|limit
condition|;
name|parent
operator|++
control|)
block|{
name|parent
operator|->
name|cg
operator|.
name|child_time
operator|=
literal|0.0
expr_stmt|;
name|arc
operator|=
name|arc_lookup
argument_list|(
name|parent
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|&&
name|parent
operator|==
name|arc
operator|->
name|child
condition|)
block|{
name|parent
operator|->
name|ncalls
operator|-=
name|arc
operator|->
name|count
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|self_calls
operator|=
name|arc
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|->
name|cg
operator|.
name|self_calls
operator|=
literal|0
expr_stmt|;
block|}
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|fract
operator|=
literal|0.0
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|self
operator|=
literal|0.0
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|prop
operator|.
name|child
operator|=
literal|0.0
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|print_flag
operator|=
name|FALSE
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|top_order
operator|=
name|DFN_NAN
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|num
operator|=
literal|0
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|head
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|cg
operator|.
name|cyc
operator|.
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignore_direct_calls
condition|)
block|{
name|find_call
argument_list|(
name|parent
argument_list|,
name|parent
operator|->
name|addr
argument_list|,
operator|(
name|parent
operator|+
literal|1
operator|)
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Topologically order things.  If any node is unnumbered, number    * it and any of its descendents.    */
for|for
control|(
name|parent
operator|=
name|symtab
operator|.
name|base
init|;
name|parent
operator|<
name|symtab
operator|.
name|limit
condition|;
name|parent
operator|++
control|)
block|{
if|if
condition|(
name|parent
operator|->
name|cg
operator|.
name|top_order
operator|==
name|DFN_NAN
condition|)
block|{
name|cg_dfn
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* link together nodes on the same cycle: */
name|cycle_link
argument_list|()
expr_stmt|;
comment|/* sort the symbol table in reverse topological order: */
name|top_sorted_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symtab
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
operator|++
name|index
control|)
block|{
name|top_sorted_syms
index|[
name|index
index|]
operator|=
operator|&
name|symtab
operator|.
name|base
index|[
name|index
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|top_sorted_syms
argument_list|,
name|symtab
operator|.
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|,
name|cmp_topo
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
argument|DFNDEBUG
argument_list|,
argument|printf (
literal|"[cg_assemble] topological sort listing\n"
argument|);        for (index =
literal|0
argument|; index< symtab.len; ++index)        {        printf (
literal|"[cg_assemble] "
argument|);        printf (
literal|"%d:"
argument|, top_sorted_syms[index]->cg.top_order);        print_name (top_sorted_syms[index]);        printf (
literal|"\n"
argument|);        }
argument_list|)
empty_stmt|;
comment|/*    * Starting from the topological top, propagate print flags to    * children.  also, calculate propagation fractions.  this happens    * before time propagation since time propagation uses the    * fractions.    */
name|propagate_flags
argument_list|(
name|top_sorted_syms
argument_list|)
expr_stmt|;
comment|/*    * Starting from the topological bottom, propogate children times    * up to parents.    */
name|cycle_time
argument_list|()
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
operator|++
name|index
control|)
block|{
name|propagate_time
argument_list|(
name|top_sorted_syms
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|top_sorted_syms
argument_list|)
expr_stmt|;
comment|/*    * Now, sort by CG.PROP.SELF + CG.PROP.CHILD.  Sorting both the regular    * function names and cycle headers.    */
name|time_sorted_syms
operator|=
operator|(
name|Sym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|symtab
operator|.
name|len
operator|+
name|num_cycles
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
condition|;
name|index
operator|++
control|)
block|{
name|time_sorted_syms
index|[
name|index
index|]
operator|=
operator|&
name|symtab
operator|.
name|base
index|[
name|index
index|]
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|1
init|;
name|index
operator|<=
name|num_cycles
condition|;
name|index
operator|++
control|)
block|{
name|time_sorted_syms
index|[
name|symtab
operator|.
name|len
operator|+
name|index
operator|-
literal|1
index|]
operator|=
operator|&
name|cycle_header
index|[
name|index
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|time_sorted_syms
argument_list|,
name|symtab
operator|.
name|len
operator|+
name|num_cycles
argument_list|,
sizeof|sizeof
argument_list|(
name|Sym
operator|*
argument_list|)
argument_list|,
name|cmp_total
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|symtab
operator|.
name|len
operator|+
name|num_cycles
condition|;
name|index
operator|++
control|)
block|{
name|time_sorted_syms
index|[
name|index
index|]
operator|->
name|cg
operator|.
name|index
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|time_sorted_syms
return|;
block|}
end_function

end_unit

