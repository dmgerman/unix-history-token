begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* from: FreeBSD: head/lib/msun/src/s_tanhl.c XXX */
end_comment

begin_comment
comment|/* @(#)s_tanh.c 5.1 93/09/24 */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * See s_tanh.c for complete comments.  *  * Converted to long double by Bruce D. Evans.  */
end_comment

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<ieeefp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_include
include|#
directive|include
file|"fpmath.h"
end_include

begin_include
include|#
directive|include
file|"k_expl.h"
end_include

begin_if
if|#
directive|if
name|LDBL_MAX_EXP
operator|!=
literal|0x4000
end_if

begin_comment
comment|/* We also require the usual expsign encoding. */
end_comment

begin_error
error|#
directive|error
literal|"Unsupported long double format"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BIAS
value|(LDBL_MAX_EXP - 1)
end_define

begin_decl_stmt
specifier|static
specifier|const
specifier|volatile
name|double
name|tiny
init|=
literal|1.0e-300
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|double
name|one
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LDBL_MANT_DIG
operator|==
literal|64
end_if

begin_comment
comment|/*  * Domain [-0.25, 0.25], range ~[-1.6304e-22, 1.6304e-22]:  * |tanh(x)/x - t(x)|< 2**-72.3  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|union
name|IEEEl2bits
name|T3u
init|=
name|LD80C
argument_list|(
literal|0xaaaaaaaaaaaaaa9f
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|3.33333333333333333017e-1L
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|T3
value|T3u.e
end_define

begin_decl_stmt
specifier|static
specifier|const
name|double
name|T5
init|=
literal|1.3333333333333314e-1
decl_stmt|,
comment|/*  0x1111111111110a.0p-55 */
name|T7
init|=
operator|-
literal|5.3968253968210485e-2
decl_stmt|,
comment|/* -0x1ba1ba1ba1a1a1.0p-57 */
name|T9
init|=
literal|2.1869488531393817e-2
decl_stmt|,
comment|/*  0x1664f488172022.0p-58 */
name|T11
init|=
operator|-
literal|8.8632352345964591e-3
decl_stmt|,
comment|/* -0x1226e34bc138d5.0p-59 */
name|T13
init|=
literal|3.5921169709993771e-3
decl_stmt|,
comment|/*  0x1d6d371d3e400f.0p-61 */
name|T15
init|=
operator|-
literal|1.4555786415756001e-3
decl_stmt|,
comment|/* -0x17d923aa63814d.0p-62 */
name|T17
init|=
literal|5.8645267876296793e-4
decl_stmt|,
comment|/*  0x13378589b85aa7.0p-63 */
name|T19
init|=
operator|-
literal|2.1121033571392224e-4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -0x1baf0af80c4090.0p-65 */
end_comment

begin_elif
elif|#
directive|elif
name|LDBL_MANT_DIG
operator|==
literal|113
end_elif

begin_comment
comment|/*  * Domain [-0.25, 0.25], range ~[-2.4211e-37, 2.4211e-37]:  * |tanh(x)/x - t(x)|< 2**121.6  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|long
name|double
name|T3
init|=
operator|-
literal|3.33333333333333333333333333333332980e-1L
decl_stmt|,
comment|/* -0x1555555555555555555555555554e.0p-114L */
name|T5
init|=
literal|1.33333333333333333333333333332707260e-1L
decl_stmt|,
comment|/*  0x1111111111111111111111110ab7b.0p-115L */
name|T7
init|=
operator|-
literal|5.39682539682539682539682535723482314e-2L
decl_stmt|,
comment|/* -0x1ba1ba1ba1ba1ba1ba1ba17b5fc98.0p-117L */
name|T9
init|=
literal|2.18694885361552028218693591149061717e-2L
decl_stmt|,
comment|/*  0x1664f4882c10f9f32d6b1a12a25e5.0p-118L */
name|T11
init|=
operator|-
literal|8.86323552990219656883762347736381851e-3L
decl_stmt|,
comment|/* -0x1226e355e6c23c8f5a5a0f386cb4d.0p-119L */
name|T13
init|=
literal|3.59212803657248101358314398220822722e-3L
decl_stmt|,
comment|/*  0x1d6d3d0e157ddfb403ad3637442c6.0p-121L */
name|T15
init|=
operator|-
literal|1.45583438705131796512568010348874662e-3L
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -0x17da36452b75e150c44cc34253b34.0p-122L */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|T17
init|=
literal|5.9002744094556621e-4
decl_stmt|,
comment|/*  0x1355824803668e.0p-63 */
name|T19
init|=
operator|-
literal|2.3912911424260516e-4
decl_stmt|,
comment|/* -0x1f57d7734c8dde.0p-65 */
name|T21
init|=
literal|9.6915379535512898e-5
decl_stmt|,
comment|/*  0x1967e18ad6a6ca.0p-66 */
name|T23
init|=
operator|-
literal|3.9278322983156353e-5
decl_stmt|,
comment|/* -0x1497d8e6b75729.0p-67 */
name|T25
init|=
literal|1.5918887220143869e-5
decl_stmt|,
comment|/*  0x10b1319998cafa.0p-68 */
name|T27
init|=
operator|-
literal|6.4514295231630956e-6
decl_stmt|,
comment|/* -0x1b0f2b71b218eb.0p-70 */
name|T29
init|=
literal|2.6120754043964365e-6
decl_stmt|,
comment|/*  0x15e963a3cf3a39.0p-71 */
name|T31
init|=
operator|-
literal|1.0407567231003314e-6
decl_stmt|,
comment|/* -0x1176041e656869.0p-72 */
name|T33
init|=
literal|3.4744117554063574e-7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0x1750fe732cab9c.0p-74 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDBL_MANT_DIG == 64 */
end_comment

begin_function
specifier|static
specifier|inline
name|long
name|double
name|divl
parameter_list|(
name|long
name|double
name|a
parameter_list|,
name|long
name|double
name|b
parameter_list|,
name|long
name|double
name|c
parameter_list|,
name|long
name|double
name|d
parameter_list|,
name|long
name|double
name|e
parameter_list|,
name|long
name|double
name|f
parameter_list|)
block|{
name|long
name|double
name|inv
decl_stmt|,
name|r
decl_stmt|;
name|float
name|fr
decl_stmt|,
name|fw
decl_stmt|;
name|_2sumF
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|b
operator|=
name|b
operator|+
name|c
expr_stmt|;
name|_2sumF
argument_list|(
name|d
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|+
name|f
expr_stmt|;
name|inv
operator|=
literal|1
operator|/
operator|(
name|d
operator|+
name|e
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|*
name|inv
expr_stmt|;
name|fr
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|fr
expr_stmt|;
name|fw
operator|=
name|d
operator|+
name|e
expr_stmt|;
name|e
operator|=
name|d
operator|-
name|fw
operator|+
name|e
expr_stmt|;
name|d
operator|=
name|fw
expr_stmt|;
name|r
operator|=
name|r
operator|+
operator|(
name|a
operator|-
name|d
operator|*
name|r
operator|+
name|b
operator|-
name|e
operator|*
name|r
operator|)
operator|*
name|inv
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|long
name|double
name|tanhl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
name|long
name|double
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|s
decl_stmt|,
name|x2
decl_stmt|,
name|x4
decl_stmt|,
name|z
decl_stmt|;
name|double
name|dx2
decl_stmt|;
name|int16_t
name|jx
decl_stmt|,
name|ix
decl_stmt|;
name|GET_LDBL_EXPSIGN
argument_list|(
name|jx
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ix
operator|=
name|jx
operator|&
literal|0x7fff
expr_stmt|;
comment|/* x is INF or NaN */
if|if
condition|(
name|ix
operator|>=
literal|0x7fff
condition|)
block|{
if|if
condition|(
name|jx
operator|>=
literal|0
condition|)
return|return
name|one
operator|/
name|x
operator|+
name|one
return|;
comment|/* tanh(+-inf)=+-1 */
else|else
return|return
name|one
operator|/
name|x
operator|-
name|one
return|;
comment|/* tanh(NaN) = NaN */
block|}
name|ENTERI
argument_list|()
expr_stmt|;
comment|/* |x|< 40 */
if|if
condition|(
name|ix
operator|<
literal|0x4004
operator|||
name|fabsl
argument_list|(
name|x
argument_list|)
operator|<
literal|40
condition|)
block|{
comment|/* |x|<40 */
if|if
condition|(
name|__predict_false
argument_list|(
name|ix
operator|<
name|BIAS
operator|-
operator|(
name|LDBL_MANT_DIG
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
condition|)
block|{
comment|/* |x|<TINY */
comment|/* tanh(+-0) = +0; tanh(tiny) = tiny(-+) with inexact: */
return|return
operator|(
name|x
operator|==
literal|0
condition|?
name|x
else|:
operator|(
literal|0x1p200
operator|*
name|x
operator|-
name|x
operator|)
operator|*
literal|0x1p
operator|-
literal|200
operator|)
return|;
block|}
if|if
condition|(
name|ix
operator|<
literal|0x3ffd
condition|)
block|{
comment|/* |x|<0.25 */
name|x2
operator|=
name|x
operator|*
name|x
expr_stmt|;
if|#
directive|if
name|LDBL_MANT_DIG
operator|==
literal|64
name|x4
operator|=
name|x2
operator|*
name|x2
expr_stmt|;
name|RETURNI
argument_list|(
operator|(
operator|(
name|T19
operator|*
name|x2
operator|+
name|T17
operator|)
operator|*
name|x4
operator|+
operator|(
name|T15
operator|*
name|x2
operator|+
name|T13
operator|)
operator|)
operator|*
operator|(
name|x2
operator|*
name|x
operator|*
name|x2
operator|*
name|x4
operator|*
name|x4
operator|)
operator|+
operator|(
operator|(
name|T11
operator|*
name|x2
operator|+
name|T9
operator|)
operator|*
name|x4
operator|+
operator|(
name|T7
operator|*
name|x2
operator|+
name|T5
operator|)
operator|)
operator|*
operator|(
name|x2
operator|*
name|x
operator|*
name|x2
operator|)
operator|+
name|T3
operator|*
operator|(
name|x2
operator|*
name|x
operator|)
operator|+
name|x
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|LDBL_MANT_DIG
operator|==
literal|113
name|dx2
operator|=
name|x2
expr_stmt|;
if|#
directive|if
literal|0
block|RETURNI(((((((((((((((T33*dx2 + T31)*dx2 + T29)*dx2 + T27)*dx2 + 		    T25)*x2 + T23)*x2 + T21)*x2 + T19)*x2 + T17)*x2 + 		    T15)*x2 + T13)*x2 + T11)*x2 + T9)*x2 + T7)*x2 + T5)* 		    (x2*x*x2) + 		    T3*(x2*x) + x);
else|#
directive|else
name|long
name|double
name|q
init|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|T33
operator|*
name|dx2
operator|+
name|T31
operator|)
operator|*
name|dx2
operator|+
name|T29
operator|)
operator|*
name|dx2
operator|+
name|T27
operator|)
operator|*
name|dx2
operator|+
name|T25
operator|)
operator|*
name|x2
operator|+
name|T23
operator|)
operator|*
name|x2
operator|+
name|T21
operator|)
operator|*
name|x2
operator|+
name|T19
operator|)
operator|*
name|x2
operator|+
name|T17
operator|)
operator|*
name|x2
operator|+
name|T15
operator|)
operator|*
name|x2
operator|+
name|T13
operator|)
operator|*
name|x2
operator|+
name|T11
operator|)
operator|*
name|x2
operator|+
name|T9
operator|)
operator|*
name|x2
operator|+
name|T7
operator|)
operator|*
name|x2
operator|+
name|T5
operator|)
operator|*
operator|(
name|x2
operator|*
name|x
operator|*
name|x2
operator|)
decl_stmt|;
name|RETURNI
argument_list|(
name|q
operator|+
name|T3
operator|*
operator|(
name|x2
operator|*
name|x
operator|)
operator|+
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|k_hexpl
argument_list|(
literal|2
operator|*
name|fabsl
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0x4001
operator|&&
name|fabsl
argument_list|(
name|x
argument_list|)
operator|<
literal|1.5
condition|)
comment|/* |x|<1.5 */
name|z
operator|=
name|divl
argument_list|(
name|hi
argument_list|,
name|lo
argument_list|,
operator|-
literal|0.5
argument_list|,
name|hi
argument_list|,
name|lo
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
else|else
name|z
operator|=
name|one
operator|-
name|one
operator|/
operator|(
name|lo
operator|+
literal|0.5
operator|+
name|hi
operator|)
expr_stmt|;
comment|/* |x|>= 40, return +-1 */
block|}
else|else
block|{
name|z
operator|=
name|one
operator|-
name|tiny
expr_stmt|;
comment|/* raise inexact flag */
block|}
name|s
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|jx
operator|<
literal|0
condition|)
name|s
operator|=
operator|-
literal|1
expr_stmt|;
name|RETURNI
argument_list|(
name|s
operator|*
name|z
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

