begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2002 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *  * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/statvfs.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_function_decl
specifier|static
name|int
name|sfs2svfs
parameter_list|(
specifier|const
name|struct
name|statfs
modifier|*
name|from
parameter_list|,
name|struct
name|statvfs
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|fstatvfs
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|statvfs
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|statfs
name|sfs
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|long
name|pcval
decl_stmt|;
name|rv
operator|=
name|_fstatfs
argument_list|(
name|fd
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|rv
operator|=
name|sfs2svfs
argument_list|(
operator|&
name|sfs
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* 	 * Whether pathconf's -1 return means error or unlimited does not 	 * make any difference in this best-effort implementation. 	 */
name|pcval
operator|=
name|_fpathconf
argument_list|(
name|fd
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcval
operator|==
operator|-
literal|1
condition|)
name|result
operator|->
name|f_namemax
operator|=
operator|~
literal|0UL
expr_stmt|;
else|else
name|result
operator|->
name|f_namemax
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pcval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|statvfs
parameter_list|(
specifier|const
name|char
modifier|*
name|__restrict
name|path
parameter_list|,
name|struct
name|statvfs
modifier|*
name|__restrict
name|result
parameter_list|)
block|{
name|struct
name|statfs
name|sfs
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|long
name|pcval
decl_stmt|;
name|rv
operator|=
name|statfs
argument_list|(
name|path
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|sfs2svfs
argument_list|(
operator|&
name|sfs
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* 	 * Whether pathconf's -1 return means error or unlimited does not 	 * make any difference in this best-effort implementation. 	 */
name|pcval
operator|=
name|pathconf
argument_list|(
name|path
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcval
operator|==
operator|-
literal|1
condition|)
name|result
operator|->
name|f_namemax
operator|=
operator|~
literal|0UL
expr_stmt|;
else|else
name|result
operator|->
name|f_namemax
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pcval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfs2svfs
parameter_list|(
specifier|const
name|struct
name|statfs
modifier|*
name|from
parameter_list|,
name|struct
name|statvfs
modifier|*
name|to
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|statvfs
name|zvfs
decl_stmt|;
operator|*
name|to
operator|=
name|zvfs
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
condition|)
name|to
operator|->
name|f_flag
operator||=
name|ST_RDONLY
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|f_flags
operator|&
name|MNT_NOSUID
condition|)
name|to
operator|->
name|f_flag
operator||=
name|ST_NOSUID
expr_stmt|;
comment|/* XXX should we clamp negative values? */
define|#
directive|define
name|COPY
parameter_list|(
name|field
parameter_list|)
define|\
value|do { \ 		to->field = from->field; \ 		if (from->field != to->field) { \ 			errno = EOVERFLOW; \ 			return (-1); \ 		} \ 	} while(0)
name|COPY
argument_list|(
name|f_bavail
argument_list|)
expr_stmt|;
name|COPY
argument_list|(
name|f_bfree
argument_list|)
expr_stmt|;
name|COPY
argument_list|(
name|f_blocks
argument_list|)
expr_stmt|;
name|COPY
argument_list|(
name|f_ffree
argument_list|)
expr_stmt|;
name|COPY
argument_list|(
name|f_files
argument_list|)
expr_stmt|;
name|to
operator|->
name|f_bsize
operator|=
name|from
operator|->
name|f_iosize
expr_stmt|;
name|to
operator|->
name|f_frsize
operator|=
name|from
operator|->
name|f_bsize
expr_stmt|;
name|to
operator|->
name|f_favail
operator|=
name|to
operator|->
name|f_ffree
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|statvfs
name|buf
decl_stmt|;
if|if
condition|(
name|statvfs
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"statvfs"
argument_list|)
expr_stmt|;
define|#
directive|define
name|SHOW
parameter_list|(
name|field
parameter_list|)
define|\
value|printf(#field ": %ju\n", (uintmax_t)buf.field)
name|SHOW
argument_list|(
name|f_bavail
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_bfree
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_blocks
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_favail
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_ffree
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_files
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_bsize
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_frsize
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|f_namemax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f_flag: %lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|buf
operator|.
name|f_flag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAIN */
end_comment

end_unit

