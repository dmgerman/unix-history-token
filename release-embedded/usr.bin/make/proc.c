begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2005 Max Okumoto.  *	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/**  * Replace the current process.  */
end_comment

begin_function
name|void
name|Proc_Exec
parameter_list|(
specifier|const
name|ProcStuff
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|in
operator|!=
name|STDIN_FILENO
condition|)
block|{
comment|/* 		 * Redirect the child's stdin to the input fd 		 * and reset it to the beginning (again). 		 */
if|if
condition|(
name|dup2
argument_list|(
name|ps
operator|->
name|in
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|out
operator|!=
name|STDOUT_FILENO
condition|)
block|{
comment|/* 		 * Redirect the child's stdout to the output fd. 		 */
if|if
condition|(
name|dup2
argument_list|(
name|ps
operator|->
name|out
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ps
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|err
operator|!=
name|STDERR_FILENO
condition|)
block|{
comment|/* 		 * Redirect the child's stderr to the err fd. 		 */
if|if
condition|(
name|dup2
argument_list|(
name|ps
operator|->
name|err
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ps
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|merge_errors
condition|)
block|{
comment|/* 		 * Send stderr to parent process too. 		 */
if|if
condition|(
name|dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|unsetenv
condition|)
block|{
comment|/* for the benfit of ksh */
name|unsetenv
argument_list|(
literal|"ENV"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The file descriptors for stdin, stdout, or stderr might 	 * have been marked close-on-exec.  Clear the flag on all 	 * of them. 	 */
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_GETFD
argument_list|)
operator|&
operator|(
operator|~
name|FD_CLOEXEC
operator|)
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_GETFD
argument_list|)
operator|&
operator|(
operator|~
name|FD_CLOEXEC
operator|)
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|STDERR_FILENO
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|STDERR_FILENO
argument_list|,
name|F_GETFD
argument_list|)
operator|&
operator|(
operator|~
name|FD_CLOEXEC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|pgroup
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_PGRP
comment|/* 		 * Become a process group leader, so we can kill it and all 		 * its descendants in one fell swoop, by killing its process 		 * family, but not commit suicide. 		 */
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
name|setsid
argument_list|()
expr_stmt|;
else|#
directive|else
name|setpgid
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* USE_PGRP */
block|}
if|if
condition|(
name|ps
operator|->
name|searchpath
condition|)
block|{
name|execvp
argument_list|(
name|ps
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|ps
operator|->
name|argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|ps
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|ps
operator|->
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execv
argument_list|(
name|commandShell
operator|->
name|path
argument_list|,
name|ps
operator|->
name|argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|"Could not execute shell\n"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"Could not execute shell"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Since we are the child process, exit without flushing buffers. 	 */
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

