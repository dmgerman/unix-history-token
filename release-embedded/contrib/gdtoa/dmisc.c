begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MULTIPLE_THREADS
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|dtoa_result
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|rv_alloc
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
else|#
directive|else
function|rv_alloc
parameter_list|(
name|int
name|i
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
name|ULong
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
sizeof|sizeof
argument_list|(
name|Bigint
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|ULong
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|j
operator|<=
name|i
condition|;
name|j
operator|<<=
literal|1
control|)
name|k
operator|++
expr_stmt|;
name|r
operator|=
operator|(
name|int
operator|*
operator|)
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|k
expr_stmt|;
return|return
ifndef|#
directive|ifndef
name|MULTIPLE_THREADS
name|dtoa_result
operator|=
endif|#
directive|endif
operator|(
name|char
operator|*
operator|)
operator|(
name|r
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|nrv_alloc
parameter_list|(
name|s
parameter_list|,
name|rve
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
modifier|*
name|rve
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|nrv_alloc
argument_list|(
argument|char *s
argument_list|,
argument|char **rve
argument_list|,
argument|int n
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
modifier|*
name|rv
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|rv
operator|=
name|rv_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|t
expr_stmt|;
return|return
name|rv
return|;
block|}
end_block

begin_comment
comment|/* freedtoa(s) must be used to free values s returned by dtoa  * when MULTIPLE_THREADS is #defined.  It should be used in all cases,  * but for consistency with earlier versions of dtoa, it is optional  * when MULTIPLE_THREADS is not defined.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|freedtoa
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|freedtoa
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
name|Bigint
modifier|*
name|b
init|=
operator|(
name|Bigint
operator|*
operator|)
operator|(
operator|(
name|int
operator|*
operator|)
name|s
operator|-
literal|1
operator|)
decl_stmt|;
name|b
operator|->
name|maxwds
operator|=
literal|1
operator|<<
operator|(
name|b
operator|->
name|k
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|b
operator|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MULTIPLE_THREADS
if|if
condition|(
name|s
operator|==
name|dtoa_result
condition|)
name|dtoa_result
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|int
name|quorem
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|,
modifier|*
name|S
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|Bigint
operator|*
name|S
operator|)
endif|#
directive|endif
block|{
name|int
name|n
block|;
name|ULong
operator|*
name|bx
block|,
operator|*
name|bxe
block|,
name|q
block|,
operator|*
name|sx
block|,
operator|*
name|sxe
block|;
ifdef|#
directive|ifdef
name|ULLong
name|ULLong
name|borrow
block|,
name|carry
block|,
name|y
block|,
name|ys
block|;
else|#
directive|else
name|ULong
name|borrow
block|,
name|carry
block|,
name|y
block|,
name|ys
block|;
ifdef|#
directive|ifdef
name|Pack_32
name|ULong
name|si
block|,
name|z
block|,
name|zs
block|;
endif|#
directive|endif
endif|#
directive|endif
name|n
operator|=
name|S
operator|->
name|wds
block|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*debug*/
if|if
condition|(
name|b
operator|->
name|wds
operator|>
name|n
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversize b in quorem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|b
operator|->
name|wds
operator|<
name|n
condition|)
return|return
literal|0
return|;
end_if

begin_expr_stmt
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sxe
operator|=
name|sx
operator|+
operator|--
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|q
operator|=
operator|*
name|bxe
operator|/
operator|(
operator|*
name|sxe
operator|+
literal|1
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ensure q<= true quotient */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*debug*/
end_comment

begin_if
if|if
condition|(
name|q
operator|>
literal|9
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversized quotient in quorem"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|q
condition|)
block|{
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|ULLong
name|ys
operator|=
operator|*
name|sx
operator|++
operator|*
operator|(
name|ULLong
operator|)
name|q
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|32
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffffffffUL
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|32
operator|&
literal|1UL
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffffffffUL
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Pack_32
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|*
name|q
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|*
name|q
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
operator|(
name|y
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
operator|(
name|z
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|#
directive|else
name|ys
operator|=
operator|*
name|sx
operator|++
operator|*
name|q
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
operator|(
name|y
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|ULLong
name|ys
operator|=
operator|*
name|sx
operator|++
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|32
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffffffffUL
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|32
operator|&
literal|1UL
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffffffffUL
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Pack_32
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
operator|(
name|y
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
operator|(
name|z
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|#
directive|else
name|ys
operator|=
operator|*
name|sx
operator|++
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
operator|(
name|y
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|q
return|;
end_return

unit|}
end_unit

