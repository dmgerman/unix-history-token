begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERF_BUCKET_TYPES_H
end_ifndef

begin_define
define|#
directive|define
name|SERF_BUCKET_TYPES_H
end_define

begin_include
include|#
directive|include
file|<apr_mmap.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_comment
comment|/* this header and serf.h refer to each other, so take a little extra care */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERF_H
end_ifndef

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @file serf_bucket_types.h  * @brief serf-supported bucket types  */
end_comment

begin_comment
comment|/* ### this whole file needs docco ... */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_request
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_REQUEST
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), request)
name|serf_bucket_t
modifier|*
name|serf_bucket_request_create
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|URI
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* Send a Content-Length header with @a len. The @a body bucket should    contain precisely that much data.  */
name|void
name|serf_bucket_request_set_CL
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_int64_t
name|len
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_request_get_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|request
parameter_list|)
function_decl|;
name|void
name|serf_bucket_request_become
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|)
function_decl|;
comment|/**  * Sets the root url of the remote host. If this request contains a relative  * url, it will be prefixed with the root url to form an absolute url.  * @a bucket is the request bucket. @a root_url is the absolute url of the  * root of the remote host, without the closing '/'.  */
name|void
name|serf_bucket_request_set_root
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|root_url
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_response
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_RESPONSE
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), response)
name|serf_bucket_t
modifier|*
name|serf_bucket_response_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
define|#
directive|define
name|SERF_HTTP_VERSION
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|((major) * 1000 + (minor))
define|#
directive|define
name|SERF_HTTP_11
value|SERF_HTTP_VERSION(1, 1)
define|#
directive|define
name|SERF_HTTP_10
value|SERF_HTTP_VERSION(1, 0)
define|#
directive|define
name|SERF_HTTP_VERSION_MAJOR
parameter_list|(
name|shv
parameter_list|)
value|((int)shv / 1000)
define|#
directive|define
name|SERF_HTTP_VERSION_MINOR
parameter_list|(
name|shv
parameter_list|)
value|((int)shv % 1000)
typedef|typedef
struct|struct
block|{
name|int
name|version
decl_stmt|;
name|int
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
block|}
name|serf_status_line
typedef|;
comment|/**  * Return the Status-Line information, if available. This function  * works like other bucket read functions: it may return APR_EAGAIN or  * APR_EOF to signal the state of the bucket for reading. A return  * value of APR_SUCCESS will always indicate that status line  * information was returned; for other return values the caller must  * check the version field in @a sline. A value of 0 means that the  * data is not (yet) present.  */
name|apr_status_t
name|serf_bucket_response_status
parameter_list|(
name|serf_bucket_t
modifier|*
name|bkt
parameter_list|,
name|serf_status_line
modifier|*
name|sline
parameter_list|)
function_decl|;
comment|/**  * Wait for the HTTP headers to be processed for a @a response.  *  * If the headers are available, APR_SUCCESS is returned.  * If the headers aren't available, APR_EAGAIN is returned.  */
name|apr_status_t
name|serf_bucket_response_wait_for_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|response
parameter_list|)
function_decl|;
comment|/**  * Get the headers bucket for @a response.  */
name|serf_bucket_t
modifier|*
name|serf_bucket_response_get_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|response
parameter_list|)
function_decl|;
comment|/**  * Advise the response @a bucket that this was from a HEAD request and  * that it should not expect to see a response body.  */
name|void
name|serf_bucket_response_set_head
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_response_body
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_RESPONSE_BODY
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), response_body)
name|serf_bucket_t
modifier|*
name|serf_bucket_response_body_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|apr_uint64_t
name|limit
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_bwtp_frame
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_BWTP_FRAME
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), bwtp_frame)
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_bwtp_incoming_frame
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_BWTP_INCOMING_FRAME
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), bwtp_incoming_frame)
name|int
name|serf_bucket_bwtp_frame_get_channel
parameter_list|(
name|serf_bucket_t
modifier|*
name|hdr
parameter_list|)
function_decl|;
name|int
name|serf_bucket_bwtp_frame_get_type
parameter_list|(
name|serf_bucket_t
modifier|*
name|hdr
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|serf_bucket_bwtp_frame_get_phrase
parameter_list|(
name|serf_bucket_t
modifier|*
name|hdr
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_bwtp_frame_get_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|hdr
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_bwtp_channel_open
parameter_list|(
name|int
name|channel
parameter_list|,
specifier|const
name|char
modifier|*
name|URI
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_bwtp_channel_close
parameter_list|(
name|int
name|channel
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_bwtp_header_create
parameter_list|(
name|int
name|channel
parameter_list|,
specifier|const
name|char
modifier|*
name|phrase
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_bwtp_message_create
parameter_list|(
name|int
name|channel
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_bwtp_incoming_frame_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|bkt
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|apr_status_t
name|serf_bucket_bwtp_incoming_frame_wait_for_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|bkt
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_aggregate
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_AGGREGATE
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), aggregate)
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_bucket_aggregate_eof_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|)
function_decl|;
comment|/** serf_bucket_aggregate_cleanup will instantly destroy all buckets in     the aggregate bucket that have been read completely. Whereas normally,      these buckets are destroyed on every read operation. */
name|void
name|serf_bucket_aggregate_cleanup
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_aggregate_create
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* Creates a stream bucket.    A stream bucket is like an aggregate bucket, but:    - it doesn't destroy its child buckets on cleanup    - one can always keep adding child buckets, the handler FN should return      APR_EOF when no more buckets will be added.    Note: keep this factory function internal for now. If it turns out this   bucket type is useful outside serf, we should make it an actual separate   type.   */
name|serf_bucket_t
modifier|*
name|serf__bucket_stream_create
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|serf_bucket_aggregate_eof_t
name|fn
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
function_decl|;
comment|/** Transform @a bucket in-place into an aggregate bucket. */
name|void
name|serf_bucket_aggregate_become
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
name|void
name|serf_bucket_aggregate_prepend
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|serf_bucket_t
modifier|*
name|prepend_bucket
parameter_list|)
function_decl|;
name|void
name|serf_bucket_aggregate_append
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|serf_bucket_t
modifier|*
name|append_bucket
parameter_list|)
function_decl|;
name|void
name|serf_bucket_aggregate_hold_open
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|serf_bucket_aggregate_eof_t
name|fn
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
function_decl|;
name|void
name|serf_bucket_aggregate_prepend_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
name|vecs_count
parameter_list|)
function_decl|;
name|void
name|serf_bucket_aggregate_append_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
name|vecs_count
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_file
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_FILE
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), file)
name|serf_bucket_t
modifier|*
name|serf_bucket_file_create
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_socket
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_SOCKET
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), socket)
name|serf_bucket_t
modifier|*
name|serf_bucket_socket_create
parameter_list|(
name|apr_socket_t
modifier|*
name|skt
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/**  * Call @a progress_func every time bytes are read from the socket, pass  * the number of bytes read.  *  * When using serf's bytes read& written progress indicator, pass   * @a serf_context_progress_delta for progress_func and the serf_context for  * progress_baton.  */
name|void
name|serf_bucket_socket_set_read_progress_cb
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|serf_progress_t
name|progress_func
parameter_list|,
name|void
modifier|*
name|progress_baton
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_simple
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_SIMPLE
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), simple)
typedef|typedef
name|void
function_decl|(
modifier|*
name|serf_simple_freefunc_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_simple_create
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|serf_simple_freefunc_t
name|freefunc
parameter_list|,
name|void
modifier|*
name|freefunc_baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/**  * Equivalent to serf_bucket_simple_create, except that the bucket takes  * ownership of a private copy of the data.  */
name|serf_bucket_t
modifier|*
name|serf_bucket_simple_copy_create
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/**  * Equivalent to serf_bucket_simple_create, except that the bucket assumes  * responsibility for freeing the data on this allocator without making  * a copy.  It is assumed that data was created by a call from allocator.  */
name|serf_bucket_t
modifier|*
name|serf_bucket_simple_own_create
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
define|#
directive|define
name|SERF_BUCKET_SIMPLE_STRING
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
define|\
value|serf_bucket_simple_create(s, strlen(s), NULL, NULL, a);
define|#
directive|define
name|SERF_BUCKET_SIMPLE_STRING_LEN
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|,
name|a
parameter_list|)
define|\
value|serf_bucket_simple_create(s, l, NULL, NULL, a);
comment|/* ==================================================================== */
comment|/* Note: apr_mmap_t is always defined, but if APR doesn't have mmaps, then    the caller can never create an apr_mmap_t to pass to this function. */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_mmap
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_MMAP
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), mmap)
name|serf_bucket_t
modifier|*
name|serf_bucket_mmap_create
parameter_list|(
name|apr_mmap_t
modifier|*
name|mmap
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_headers
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_HEADERS
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), headers)
name|serf_bucket_t
modifier|*
name|serf_bucket_headers_create
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/**  * Set, default: value copied.  *  * Set the specified @a header within the bucket, copying the @a value  * into space from this bucket's allocator. The header is NOT copied,  * so it should remain in scope at least as long as the bucket.  */
name|void
name|serf_bucket_headers_set
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
comment|/**  * Set, copies: header and value copied.  *  * Copy the specified @a header and @a value into the bucket, using space  * from this bucket's allocator.  */
name|void
name|serf_bucket_headers_setc
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
comment|/**  * Set, no copies.  *  * Set the specified @a header and @a value into the bucket, without  * copying either attribute. Both attributes should remain in scope at  * least as long as the bucket.  *  * @note In the case where a header already exists this will result  *       in a reallocation and copy, @see serf_bucket_headers_setn.  */
name|void
name|serf_bucket_headers_setn
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
comment|/**  * Set, extended: fine grained copy control of header and value.  *  * Set the specified @a header, with length @a header_size with the  * @a value, and length @a value_size, into the bucket. The header will  * be copied if @a header_copy is set, and the value is copied if  * @a value_copy is set. If the values are not copied, then they should  * remain in scope at least as long as the bucket.  *  * If @a headers_bucket already contains a header with the same name  * as @a header, then append @a value to the existing value,  * separating with a comma (as per RFC 2616, section 4.2).  In this  * case, the new value must be allocated and the header re-used, so  * behave as if @a value_copy were true and @a header_copy false.  */
name|void
name|serf_bucket_headers_setx
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|apr_size_t
name|header_size
parameter_list|,
name|int
name|header_copy
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|apr_size_t
name|value_size
parameter_list|,
name|int
name|value_copy
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|serf_bucket_headers_get
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|)
function_decl|;
comment|/**  * @param baton opaque baton as passed to @see serf_bucket_headers_do  * @param key The header key from this iteration through the table  * @param value The header value from this iteration through the table  */
typedef|typedef
name|int
function_decl|(
name|serf_bucket_headers_do_callback_fn_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
comment|/**  * Iterates over all headers of the message and invokes the callback   * function with header key and value. Stop iterating when no more  * headers are available or when the callback function returned a   * non-0 value.  *  * @param headers_bucket headers to iterate over  * @param func callback routine to invoke for every header in the bucket  * @param baton baton to pass on each invocation to func  */
name|void
name|serf_bucket_headers_do
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
name|serf_bucket_headers_do_callback_fn_t
name|func
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_chunk
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_CHUNK
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), chunk)
name|serf_bucket_t
modifier|*
name|serf_bucket_chunk_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_dechunk
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_DECHUNK
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), dechunk)
name|serf_bucket_t
modifier|*
name|serf_bucket_dechunk_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_deflate
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_DEFLATE
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), deflate)
define|#
directive|define
name|SERF_DEFLATE_GZIP
value|0
define|#
directive|define
name|SERF_DEFLATE_DEFLATE
value|1
name|serf_bucket_t
modifier|*
name|serf_bucket_deflate_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|int
name|format
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_limit
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_LIMIT
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), limit)
name|serf_bucket_t
modifier|*
name|serf_bucket_limit_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|apr_uint64_t
name|limit
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
define|#
directive|define
name|SERF_SSL_CERT_NOTYETVALID
value|1
define|#
directive|define
name|SERF_SSL_CERT_EXPIRED
value|2
define|#
directive|define
name|SERF_SSL_CERT_UNKNOWNCA
value|4
define|#
directive|define
name|SERF_SSL_CERT_SELF_SIGNED
value|8
define|#
directive|define
name|SERF_SSL_CERT_UNKNOWN_FAILURE
value|16
define|#
directive|define
name|SERF_SSL_CERT_REVOKED
value|32
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_ssl_encrypt
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_SSL_ENCRYPT
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), ssl_encrypt)
typedef|typedef
name|struct
name|serf_ssl_context_t
name|serf_ssl_context_t
typedef|;
typedef|typedef
name|struct
name|serf_ssl_certificate_t
name|serf_ssl_certificate_t
typedef|;
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_ssl_need_client_cert_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cert_path
parameter_list|)
function_decl|;
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_ssl_need_cert_password_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|cert_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|password
parameter_list|)
function_decl|;
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_ssl_need_server_cert_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|failures
parameter_list|,
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|)
function_decl|;
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_ssl_server_cert_chain_cb_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|failures
parameter_list|,
name|int
name|error_depth
parameter_list|,
specifier|const
name|serf_ssl_certificate_t
modifier|*
specifier|const
modifier|*
name|certs
parameter_list|,
name|apr_size_t
name|certs_len
parameter_list|)
function_decl|;
name|void
name|serf_ssl_client_cert_provider_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_client_cert_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|cache_pool
parameter_list|)
function_decl|;
name|void
name|serf_ssl_client_cert_password_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_cert_password_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|cache_pool
parameter_list|)
function_decl|;
comment|/**  * Set a callback to override the default SSL server certificate validation   * algorithm.  */
name|void
name|serf_ssl_server_cert_callback_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_server_cert_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
comment|/**  * Set callbacks to override the default SSL server certificate validation   * algorithm for the current certificate or the entire certificate chain.   */
name|void
name|serf_ssl_server_cert_chain_callback_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_server_cert_t
name|cert_callback
parameter_list|,
name|serf_ssl_server_cert_chain_cb_t
name|cert_chain_callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
comment|/**  * Use the default root CA certificates as included with the OpenSSL library.  */
name|apr_status_t
name|serf_ssl_use_default_certificates
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Allow SNI indicators to be sent to the server.  */
name|apr_status_t
name|serf_ssl_set_hostname
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
function_decl|;
comment|/**  * Return the depth of the certificate.  */
name|int
name|serf_ssl_cert_depth
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|)
function_decl|;
comment|/**  * Extract the fields of the issuer in a table with keys (E, CN, OU, O, L,   * ST and C). The returned table will be allocated in @a pool.  */
name|apr_hash_t
modifier|*
name|serf_ssl_cert_issuer
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Extract the fields of the subject in a table with keys (E, CN, OU, O, L,   * ST and C). The returned table will be allocated in @a pool.  */
name|apr_hash_t
modifier|*
name|serf_ssl_cert_subject
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Extract the fields of the certificate in a table with keys (sha1, notBefore,  * notAfter, subjectAltName). The returned table will be allocated in @a pool.  */
name|apr_hash_t
modifier|*
name|serf_ssl_cert_certificate
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Export a certificate to base64-encoded, zero-terminated string.  * The returned string is allocated in @a pool. Returns NULL on failure.  */
specifier|const
name|char
modifier|*
name|serf_ssl_cert_export
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Load a CA certificate file from a path @a file_path. If the file was loaded  * and parsed correctly, a certificate @a cert will be created and returned.  * This certificate object will be alloced in @a pool.  */
name|apr_status_t
name|serf_ssl_load_cert_file
parameter_list|(
name|serf_ssl_certificate_t
modifier|*
modifier|*
name|cert
parameter_list|,
specifier|const
name|char
modifier|*
name|file_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Adds the certificate @a cert to the list of trusted certificates in   * @a ssl_ctx that will be used for verification.   * See also @a serf_ssl_load_cert_file.  */
name|apr_status_t
name|serf_ssl_trust_cert
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|,
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|)
function_decl|;
comment|/**  * Enable or disable SSL compression on a SSL session.  * @a enabled = 1 to enable compression, 0 to disable compression.  * Default = disabled.  */
name|apr_status_t
name|serf_ssl_use_compression
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|,
name|int
name|enabled
parameter_list|)
function_decl|;
name|serf_bucket_t
modifier|*
name|serf_bucket_ssl_encrypt_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_ssl_context_t
modifier|*
name|ssl_context
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|serf_ssl_context_t
modifier|*
name|serf_bucket_ssl_encrypt_context_get
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_ssl_decrypt
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_SSL_DECRYPT
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), ssl_decrypt)
name|serf_bucket_t
modifier|*
name|serf_bucket_ssl_decrypt_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_ssl_context_t
modifier|*
name|ssl_context
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|serf_ssl_context_t
modifier|*
name|serf_bucket_ssl_decrypt_context_get
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_barrier
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_BARRIER
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), barrier)
name|serf_bucket_t
modifier|*
name|serf_bucket_barrier_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
specifier|extern
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_iovec
decl_stmt|;
define|#
directive|define
name|SERF_BUCKET_IS_IOVEC
parameter_list|(
name|b
parameter_list|)
value|SERF_BUCKET_CHECK((b), iovec)
name|serf_bucket_t
modifier|*
name|serf_bucket_iovec_create
parameter_list|(
name|struct
name|iovec
name|vecs
index|[]
parameter_list|,
name|int
name|len
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* ==================================================================== */
comment|/* ### do we need a PIPE bucket type? they are simple apr_file_t objects */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SERF_BUCKET_TYPES_H */
end_comment

end_unit

