begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
enum|enum
block|{
name|STATE_FETCH
block|,
name|STATE_CHUNK
block|,
name|STATE_EOF
block|}
name|state
enum|;
name|apr_status_t
name|last_status
decl_stmt|;
name|serf_bucket_t
modifier|*
name|chunk
decl_stmt|;
name|serf_bucket_t
modifier|*
name|stream
decl_stmt|;
name|char
name|chunk_hdr
index|[
literal|20
index|]
decl_stmt|;
block|}
name|chunk_context_t
typedef|;
end_typedef

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_chunk_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|chunk_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|STATE_FETCH
expr_stmt|;
name|ctx
operator|->
name|chunk
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
return|return
name|serf_bucket_create
argument_list|(
operator|&
name|serf_bucket_type_chunk
argument_list|,
name|allocator
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CRLF
value|"\r\n"
end_define

begin_function
specifier|static
name|apr_status_t
name|create_chunk
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|chunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_bucket_t
modifier|*
name|simple_bkt
decl_stmt|;
name|apr_size_t
name|chunk_len
decl_stmt|;
name|apr_size_t
name|stream_len
decl_stmt|;
name|struct
name|iovec
name|vecs
index|[
literal|66
index|]
decl_stmt|;
comment|/* 64 + chunk trailer + EOF trailer = 66 */
name|int
name|vecs_read
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|!=
name|STATE_FETCH
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
name|ctx
operator|->
name|last_status
operator|=
name|serf_bucket_read_iovec
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|SERF_READ_ALL_AVAIL
argument_list|,
literal|64
argument_list|,
name|vecs
argument_list|,
operator|&
name|vecs_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|ctx
operator|->
name|last_status
argument_list|)
condition|)
block|{
comment|/* Uh-oh. */
return|return
name|ctx
operator|->
name|last_status
return|;
block|}
comment|/* Count the length of the data we read. */
name|stream_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecs_read
condition|;
name|i
operator|++
control|)
block|{
name|stream_len
operator|+=
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
comment|/* assert: stream_len in hex< sizeof(ctx->chunk_hdr) */
comment|/* Inserting a 0 byte chunk indicates a terminator, which already happens      * during the EOF handler below.  Adding another one here will cause the      * EOF chunk to be interpreted by the server as a new request.  So,      * we'll only do this if we have something to write.      */
if|if
condition|(
name|stream_len
condition|)
block|{
comment|/* Build the chunk header. */
name|chunk_len
operator|=
name|apr_snprintf
argument_list|(
argument|ctx->chunk_hdr
argument_list|,
argument|sizeof(ctx->chunk_hdr)
argument_list|,
literal|"%"
argument|APR_UINT64_T_HEX_FMT CRLF
argument_list|,
argument|(apr_uint64_t)stream_len
argument_list|)
expr_stmt|;
comment|/* Create a copy of the chunk header so we can have multiple chunks          * in the pipeline at the same time.          */
name|simple_bkt
operator|=
name|serf_bucket_simple_copy_create
argument_list|(
name|ctx
operator|->
name|chunk_hdr
argument_list|,
name|chunk_len
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|ctx
operator|->
name|chunk
argument_list|,
name|simple_bkt
argument_list|)
expr_stmt|;
comment|/* Insert the chunk footer. */
name|vecs
index|[
name|vecs_read
index|]
operator|.
name|iov_base
operator|=
name|CRLF
expr_stmt|;
name|vecs
index|[
name|vecs_read
operator|++
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|CRLF
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We've reached the end of the line for the stream. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|ctx
operator|->
name|last_status
argument_list|)
condition|)
block|{
comment|/* Insert the chunk footer. */
name|vecs
index|[
name|vecs_read
index|]
operator|.
name|iov_base
operator|=
literal|"0"
name|CRLF
name|CRLF
expr_stmt|;
name|vecs
index|[
name|vecs_read
operator|++
index|]
operator|.
name|iov_len
operator|=
expr|sizeof
operator|(
literal|"0"
name|CRLF
name|CRLF
operator|)
operator|-
literal|1
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|STATE_EOF
expr_stmt|;
block|}
else|else
block|{
comment|/* Okay, we can return data.  */
name|ctx
operator|->
name|state
operator|=
name|STATE_CHUNK
expr_stmt|;
block|}
name|serf_bucket_aggregate_append_iovec
argument_list|(
name|ctx
operator|->
name|chunk
argument_list|,
name|vecs
argument_list|,
name|vecs_read
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_chunk_read
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|chunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* Before proceeding, we need to fetch some data from the stream. */
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|STATE_FETCH
condition|)
block|{
name|status
operator|=
name|create_chunk
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|chunk
argument_list|,
name|requested
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Mask EOF from aggregate bucket. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|&&
name|ctx
operator|->
name|state
operator|==
name|STATE_CHUNK
condition|)
block|{
name|status
operator|=
name|ctx
operator|->
name|last_status
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|STATE_FETCH
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_chunk_readline
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|chunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|serf_bucket_readline
argument_list|(
name|ctx
operator|->
name|chunk
argument_list|,
name|acceptable
argument_list|,
name|found
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Mask EOF from aggregate bucket. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|&&
name|ctx
operator|->
name|state
operator|==
name|STATE_CHUNK
condition|)
block|{
name|status
operator|=
name|APR_EAGAIN
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|STATE_FETCH
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_chunk_read_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
block|{
name|chunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* Before proceeding, we need to fetch some data from the stream. */
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|STATE_FETCH
condition|)
block|{
name|status
operator|=
name|create_chunk
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
name|status
operator|=
name|serf_bucket_read_iovec
argument_list|(
name|ctx
operator|->
name|chunk
argument_list|,
name|requested
argument_list|,
name|vecs_size
argument_list|,
name|vecs
argument_list|,
name|vecs_used
argument_list|)
expr_stmt|;
comment|/* Mask EOF from aggregate bucket. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|&&
name|ctx
operator|->
name|state
operator|==
name|STATE_CHUNK
condition|)
block|{
name|status
operator|=
name|ctx
operator|->
name|last_status
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|STATE_FETCH
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_chunk_peek
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|chunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|serf_bucket_peek
argument_list|(
name|ctx
operator|->
name|chunk
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Mask EOF from aggregate bucket. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|&&
name|ctx
operator|->
name|state
operator|==
name|STATE_CHUNK
condition|)
block|{
name|status
operator|=
name|APR_EAGAIN
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serf_chunk_destroy
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|chunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_bucket_destroy
argument_list|(
name|ctx
operator|->
name|stream
argument_list|)
expr_stmt|;
name|serf_bucket_destroy
argument_list|(
name|ctx
operator|->
name|chunk
argument_list|)
expr_stmt|;
name|serf_default_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_chunk
init|=
block|{
literal|"CHUNK"
block|,
name|serf_chunk_read
block|,
name|serf_chunk_readline
block|,
name|serf_chunk_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_default_read_bucket
block|,
name|serf_chunk_peek
block|,
name|serf_chunk_destroy
block|, }
decl_stmt|;
end_decl_stmt

end_unit

