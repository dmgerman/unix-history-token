begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_create
parameter_list|(
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|bkt
init|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bkt
argument_list|)
argument_list|)
decl_stmt|;
name|bkt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|bkt
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|bkt
operator|->
name|allocator
operator|=
name|allocator
expr_stmt|;
return|return
name|bkt
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_default_read_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* Read some data from the bucket.      *      * Because we're an internal 'helper' to the bucket, we can't call the      * normal serf_bucket_read() call because the debug allocator tracker will      * end up marking the bucket as read *twice* - once for us and once for      * our caller - which is reading the same bucket.  This leads to premature      * abort()s if we ever see EAGAIN.  Instead, we'll go directly to the      * vtable and bypass the debug tracker.      */
name|apr_status_t
name|status
init|=
name|bucket
operator|->
name|type
operator|->
name|read
argument_list|(
name|bucket
argument_list|,
name|requested
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
comment|/* assert that vecs_size>= 1 ? */
comment|/* Return that data as a single iovec. */
if|if
condition|(
name|len
condition|)
block|{
name|vecs
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
comment|/* loses the 'const' */
name|vecs
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
operator|*
name|vecs_used
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|vecs_used
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_default_read_for_sendfile
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* Read a bunch of stuff into the headers.      *      * See serf_default_read_iovec as to why we call into the vtable      * directly.      */
name|apr_status_t
name|status
init|=
name|bucket
operator|->
name|type
operator|->
name|read_iovec
argument_list|(
name|bucket
argument_list|,
name|requested
argument_list|,
name|hdtr
operator|->
name|numheaders
argument_list|,
name|hdtr
operator|->
name|headers
argument_list|,
operator|&
name|hdtr
operator|->
name|numheaders
argument_list|)
decl_stmt|;
comment|/* There isn't a file, and there are no trailers. */
operator|*
name|file
operator|=
name|NULL
expr_stmt|;
name|hdtr
operator|->
name|numtrailers
operator|=
literal|0
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_default_read_bucket
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|serf_default_destroy
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
name|serf_debug__bucket_destroy
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|serf_bucket_mem_free
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_default_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|serf_bucket_mem_free
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
name|bucket
operator|->
name|data
argument_list|)
expr_stmt|;
name|serf_default_destroy
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==================================================================== */
end_comment

begin_function
name|char
modifier|*
name|serf_bstrmemdup
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|newstr
init|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|newstr
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|serf_bmemdup
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|mem
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|newmem
init|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newmem
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|newmem
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|serf_bstrdup
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|apr_size_t
name|size
init|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|newstr
init|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|serf_bstrcatv
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|struct
name|iovec
modifier|*
name|vec
parameter_list|,
name|int
name|vecs
parameter_list|,
name|apr_size_t
modifier|*
name|bytes_written
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_size_t
name|new_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|newstr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecs
condition|;
name|i
operator|++
control|)
block|{
name|new_len
operator|+=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
comment|/* It's up to the caller to free this memory later. */
name|newstr
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|c
operator|=
name|newstr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecs
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|c
argument_list|,
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|c
operator|+=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
if|if
condition|(
name|bytes_written
condition|)
block|{
operator|*
name|bytes_written
operator|=
name|c
operator|-
name|newstr
expr_stmt|;
block|}
return|return
name|newstr
return|;
block|}
end_function

begin_comment
comment|/* ==================================================================== */
end_comment

begin_function
specifier|static
name|void
name|find_crlf
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|found
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
operator|*
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|start
operator|+
operator|*
name|len
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
specifier|const
name|char
modifier|*
name|cr
init|=
name|memchr
argument_list|(
name|start
argument_list|,
literal|'\r'
argument_list|,
operator|*
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
operator|++
name|cr
expr_stmt|;
if|if
condition|(
name|cr
operator|<
name|end
operator|&&
name|cr
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|len
operator|-=
name|cr
operator|+
literal|1
operator|-
name|start
expr_stmt|;
operator|*
name|data
operator|=
name|cr
operator|+
literal|1
expr_stmt|;
operator|*
name|found
operator|=
name|SERF_NEWLINE_CRLF
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cr
operator|==
name|end
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|data
operator|=
name|end
expr_stmt|;
operator|*
name|found
operator|=
name|SERF_NEWLINE_CRLF_SPLIT
expr_stmt|;
return|return;
block|}
comment|/* It was a bare CR without an LF. Just move past it. */
operator|*
name|len
operator|-=
name|cr
operator|-
name|start
expr_stmt|;
name|start
operator|=
name|cr
expr_stmt|;
block|}
operator|*
name|data
operator|=
name|start
operator|+
operator|*
name|len
expr_stmt|;
operator|*
name|len
operator|-=
operator|*
name|data
operator|-
name|start
expr_stmt|;
operator|*
name|found
operator|=
name|SERF_NEWLINE_NONE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_util_readline
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|cr
decl_stmt|;
specifier|const
name|char
modifier|*
name|lf
decl_stmt|;
name|int
name|want_cr
decl_stmt|;
name|int
name|want_crlf
decl_stmt|;
name|int
name|want_lf
decl_stmt|;
comment|/* If _only_ CRLF is acceptable, then the scanning needs a loop to      * skip false hits on CR characters. Use a separate function.      */
if|if
condition|(
name|acceptable
operator|==
name|SERF_NEWLINE_CRLF
condition|)
block|{
name|find_crlf
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|found
argument_list|)
expr_stmt|;
return|return;
block|}
name|start
operator|=
operator|*
name|data
expr_stmt|;
name|cr
operator|=
name|lf
operator|=
name|NULL
expr_stmt|;
name|want_cr
operator|=
name|acceptable
operator|&
name|SERF_NEWLINE_CR
expr_stmt|;
name|want_crlf
operator|=
name|acceptable
operator|&
name|SERF_NEWLINE_CRLF
expr_stmt|;
name|want_lf
operator|=
name|acceptable
operator|&
name|SERF_NEWLINE_LF
expr_stmt|;
if|if
condition|(
name|want_cr
operator|||
name|want_crlf
condition|)
block|{
name|cr
operator|=
name|memchr
argument_list|(
name|start
argument_list|,
literal|'\r'
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_lf
condition|)
block|{
name|lf
operator|=
name|memchr
argument_list|(
name|start
argument_list|,
literal|'\n'
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cr
operator|+
literal|1
operator|==
name|lf
condition|)
operator|*
name|found
operator|=
name|want_crlf
condition|?
name|SERF_NEWLINE_CRLF
else|:
name|SERF_NEWLINE_CR
expr_stmt|;
elseif|else
if|if
condition|(
name|want_cr
operator|&&
name|cr
operator|<
name|lf
condition|)
operator|*
name|found
operator|=
name|SERF_NEWLINE_CR
expr_stmt|;
else|else
operator|*
name|found
operator|=
name|SERF_NEWLINE_LF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cr
operator|==
name|start
operator|+
operator|*
name|len
operator|-
literal|1
condition|)
block|{
comment|/* the CR occurred in the last byte of the buffer. this could be              * a CRLF split across the data boundary.              * ### FIX THIS LOGIC? does caller need to detect?              */
operator|*
name|found
operator|=
name|want_crlf
condition|?
name|SERF_NEWLINE_CRLF_SPLIT
else|:
name|SERF_NEWLINE_CR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|want_cr
condition|)
operator|*
name|found
operator|=
name|SERF_NEWLINE_CR
expr_stmt|;
else|else
comment|/* want_crlf */
operator|*
name|found
operator|=
name|SERF_NEWLINE_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lf
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|SERF_NEWLINE_LF
expr_stmt|;
else|else
operator|*
name|found
operator|=
name|SERF_NEWLINE_NONE
expr_stmt|;
switch|switch
condition|(
operator|*
name|found
condition|)
block|{
case|case
name|SERF_NEWLINE_LF
case|:
operator|*
name|data
operator|=
name|lf
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|SERF_NEWLINE_CR
case|:
case|case
name|SERF_NEWLINE_CRLF
case|:
case|case
name|SERF_NEWLINE_CRLF_SPLIT
case|:
operator|*
name|data
operator|=
name|cr
operator|+
literal|1
operator|+
operator|(
operator|*
name|found
operator|==
name|SERF_NEWLINE_CRLF
operator|)
expr_stmt|;
break|break;
case|case
name|SERF_NEWLINE_NONE
case|:
operator|*
name|data
operator|+=
operator|*
name|len
expr_stmt|;
break|break;
default|default:
comment|/* Not reachable */
return|return;
block|}
operator|*
name|len
operator|-=
operator|*
name|data
operator|-
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==================================================================== */
end_comment

begin_function
name|void
name|serf_databuf_init
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|)
block|{
comment|/* nothing is sitting in the buffer */
name|databuf
operator|->
name|remaining
operator|=
literal|0
expr_stmt|;
comment|/* avoid thinking we have hit EOF */
name|databuf
operator|->
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure the buffer is prepared for reading. Will return APR_SUCCESS,  * APR_EOF, or some failure code. *len is only set for EOF. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|common_databuf_prep
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_size_t
name|readlen
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* if there is data in the buffer, then we're happy. */
if|if
condition|(
name|databuf
operator|->
name|remaining
operator|>
literal|0
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* if we already hit EOF, then keep returning that. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|databuf
operator|->
name|status
argument_list|)
condition|)
block|{
comment|/* *data = NULL;   ?? */
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|APR_EOF
return|;
block|}
comment|/* refill the buffer */
name|status
operator|=
call|(
modifier|*
name|databuf
operator|->
name|read
call|)
argument_list|(
name|databuf
operator|->
name|read_baton
argument_list|,
sizeof|sizeof
argument_list|(
name|databuf
operator|->
name|buf
argument_list|)
argument_list|,
name|databuf
operator|->
name|buf
argument_list|,
operator|&
name|readlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
name|databuf
operator|->
name|current
operator|=
name|databuf
operator|->
name|buf
expr_stmt|;
name|databuf
operator|->
name|remaining
operator|=
name|readlen
expr_stmt|;
name|databuf
operator|->
name|status
operator|=
name|status
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_databuf_read
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|common_databuf_prep
argument_list|(
name|databuf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
comment|/* peg the requested amount to what we have remaining */
if|if
condition|(
name|requested
operator|==
name|SERF_READ_ALL_AVAIL
operator|||
name|requested
operator|>
name|databuf
operator|->
name|remaining
condition|)
name|requested
operator|=
name|databuf
operator|->
name|remaining
expr_stmt|;
comment|/* return the values */
operator|*
name|data
operator|=
name|databuf
operator|->
name|current
expr_stmt|;
operator|*
name|len
operator|=
name|requested
expr_stmt|;
comment|/* adjust our internal state to note we've consumed some data */
name|databuf
operator|->
name|current
operator|+=
name|requested
expr_stmt|;
name|databuf
operator|->
name|remaining
operator|-=
name|requested
expr_stmt|;
comment|/* If we read everything, then we need to return whatever the data      * read returned to us. This is going to be APR_EOF or APR_EGAIN.      * If we have NOT read everything, then return APR_SUCCESS to indicate      * that we're ready to return some more if asked.      */
return|return
name|databuf
operator|->
name|remaining
condition|?
name|APR_SUCCESS
else|:
name|databuf
operator|->
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_databuf_readline
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|common_databuf_prep
argument_list|(
name|databuf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
comment|/* the returned line will start at the current position. */
operator|*
name|data
operator|=
name|databuf
operator|->
name|current
expr_stmt|;
comment|/* read a line from the buffer, and adjust the various pointers. */
name|serf_util_readline
argument_list|(
operator|&
name|databuf
operator|->
name|current
argument_list|,
operator|&
name|databuf
operator|->
name|remaining
argument_list|,
name|acceptable
argument_list|,
name|found
argument_list|)
expr_stmt|;
comment|/* the length matches the amount consumed by the readline */
operator|*
name|len
operator|=
name|databuf
operator|->
name|current
operator|-
operator|*
name|data
expr_stmt|;
comment|/* see serf_databuf_read's return condition */
return|return
name|databuf
operator|->
name|remaining
condition|?
name|APR_SUCCESS
else|:
name|databuf
operator|->
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_databuf_peek
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|common_databuf_prep
argument_list|(
name|databuf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
comment|/* return everything we have */
operator|*
name|data
operator|=
name|databuf
operator|->
name|current
expr_stmt|;
operator|*
name|len
operator|=
name|databuf
operator|->
name|remaining
expr_stmt|;
comment|/* If the last read returned EOF, then the peek should return the same.      * The other possibility in databuf->status is APR_EAGAIN, which we      * should never return. Thus, just return APR_SUCCESS for non-EOF cases.      */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|databuf
operator|->
name|status
argument_list|)
condition|)
return|return
name|APR_EOF
return|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* ==================================================================== */
end_comment

begin_function
name|void
name|serf_linebuf_init
parameter_list|(
name|serf_linebuf_t
modifier|*
name|linebuf
parameter_list|)
block|{
name|linebuf
operator|->
name|state
operator|=
name|SERF_LINEBUF_EMPTY
expr_stmt|;
name|linebuf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_linebuf_fetch
parameter_list|(
name|serf_linebuf_t
modifier|*
name|linebuf
parameter_list|,
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|)
block|{
comment|/* If we had a complete line, then assume the caller has used it, so      * we can now reset the state.      */
if|if
condition|(
name|linebuf
operator|->
name|state
operator|==
name|SERF_LINEBUF_READY
condition|)
block|{
name|linebuf
operator|->
name|state
operator|=
name|SERF_LINEBUF_EMPTY
expr_stmt|;
comment|/* Reset the line_used, too, so we don't have to test the state          * before using this value.          */
name|linebuf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
name|linebuf
operator|->
name|state
operator|==
name|SERF_LINEBUF_CRLF_SPLIT
condition|)
block|{
comment|/* On the previous read, we received just a CR. The LF might              * be present, but the bucket couldn't see it. We need to              * examine a single character to determine how to handle the              * split CRLF.              */
name|status
operator|=
name|serf_bucket_peek
argument_list|(
name|bucket
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|status
return|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
block|{
comment|/* We saw the second part of CRLF. We don't need to                      * save that character, so do an actual read to suck                      * up that character.                      */
comment|/* ### check status */
operator|(
name|void
operator|)
name|serf_bucket_read
argument_list|(
name|bucket
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* else:                  *   We saw the first character of the next line. Thus,                  *   the current line is terminated by the CR. Just                  *   ignore whatever we peeked at. The next reader will                  *   see it and handle it as appropriate.                  */
comment|/* Whatever was read, the line is now ready for use. */
name|linebuf
operator|->
name|state
operator|=
name|SERF_LINEBUF_READY
expr_stmt|;
block|}
else|else
block|{
comment|/* no data available, try again later. */
return|return
name|APR_EAGAIN
return|;
block|}
block|}
else|else
block|{
name|int
name|found
decl_stmt|;
name|status
operator|=
name|serf_bucket_readline
argument_list|(
name|bucket
argument_list|,
name|acceptable
argument_list|,
operator|&
name|found
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* Some bucket types (socket) might need an extra read to find                out EOF state, so they'll return no data in that read. This                means we're done reading, return what we got. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
name|linebuf
operator|->
name|used
operator|+
name|len
operator|>
sizeof|sizeof
argument_list|(
name|linebuf
operator|->
name|line
argument_list|)
condition|)
block|{
comment|/* ### need a "line too long" error */
return|return
name|APR_EGENERAL
return|;
block|}
comment|/* Note: our logic doesn't change for SERF_LINEBUF_PARTIAL. That              * only affects how we fill the buffer. It is a communication to              * our caller on whether the line is ready or not.              */
comment|/* If we didn't see a newline, then we should mark the line              * buffer as partially complete.              */
if|if
condition|(
name|found
operator|==
name|SERF_NEWLINE_NONE
condition|)
block|{
name|linebuf
operator|->
name|state
operator|=
name|SERF_LINEBUF_PARTIAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found
operator|==
name|SERF_NEWLINE_CRLF_SPLIT
condition|)
block|{
name|linebuf
operator|->
name|state
operator|=
name|SERF_LINEBUF_CRLF_SPLIT
expr_stmt|;
comment|/* Toss the partial CR. We won't ever need it. */
operator|--
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* We got a newline (of some form). We don't need it                  * in the line buffer, so back up the length. Then                  * mark the line as ready.                  */
name|len
operator|-=
literal|1
operator|+
operator|(
name|found
operator|==
name|SERF_NEWLINE_CRLF
operator|)
expr_stmt|;
name|linebuf
operator|->
name|state
operator|=
name|SERF_LINEBUF_READY
expr_stmt|;
block|}
comment|/* ### it would be nice to avoid this copy if at all possible,                ### and just return the a data/len pair to the caller. we're                ### keeping it simple for now. */
name|memcpy
argument_list|(
operator|&
name|linebuf
operator|->
name|line
index|[
name|linebuf
operator|->
name|used
index|]
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|linebuf
operator|->
name|used
operator|+=
name|len
expr_stmt|;
block|}
comment|/* If we saw anything besides "success. please read again", then          * we should return that status. If the line was completed, then          * we should also return.          */
if|if
condition|(
name|status
operator|||
name|linebuf
operator|->
name|state
operator|==
name|SERF_LINEBUF_READY
condition|)
return|return
name|status
return|;
comment|/* We got APR_SUCCESS and the line buffer is not complete. Let's          * loop to read some more data.          */
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* Logging functions.    Use with one of the [COMP]_VERBOSE defines so that the compiler knows to    optimize this code out when no logging is needed. */
end_comment

begin_function
specifier|static
name|void
name|log_time
parameter_list|()
block|{
name|apr_time_exp_t
name|tm
decl_stmt|;
name|apr_time_exp_lt
argument_list|(
operator|&
name|tm
argument_list|,
name|apr_time_now
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d-%02d-%02dT%02d:%02d:%02d.%06d%+03d] "
argument_list|,
literal|1900
operator|+
name|tm
operator|.
name|tm_year
argument_list|,
literal|1
operator|+
name|tm
operator|.
name|tm_mon
argument_list|,
name|tm
operator|.
name|tm_mday
argument_list|,
name|tm
operator|.
name|tm_hour
argument_list|,
name|tm
operator|.
name|tm_min
argument_list|,
name|tm
operator|.
name|tm_sec
argument_list|,
name|tm
operator|.
name|tm_usec
argument_list|,
name|tm
operator|.
name|tm_gmtoff
operator|/
literal|3600
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf__log
parameter_list|(
name|int
name|verbose_flag
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|log_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf__log_nopref
parameter_list|(
name|int
name|verbose_flag
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf__log_skt
parameter_list|(
name|int
name|verbose_flag
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_socket_t
modifier|*
name|skt
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|apr_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|log_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|skt
condition|)
block|{
comment|/* Log local and remote ip address:port */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[l:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_socket_addr_get
argument_list|(
operator|&
name|sa
argument_list|,
name|APR_LOCAL
argument_list|,
name|skt
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|apr_sockaddr_ip_getbuf
argument_list|(
name|buf
argument_list|,
literal|32
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d"
argument_list|,
name|buf
argument_list|,
name|sa
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" r:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_socket_addr_get
argument_list|(
operator|&
name|sa
argument_list|,
name|APR_REMOTE
argument_list|,
name|skt
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|apr_sockaddr_ip_getbuf
argument_list|(
name|buf
argument_list|,
literal|32
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d"
argument_list|,
name|buf
argument_list|,
name|sa
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

