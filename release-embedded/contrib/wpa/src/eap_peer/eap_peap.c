begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * EAP peer method: EAP-PEAP (draft-josefsson-pppext-eap-tls-eap-10.txt)  * Copyright (c) 2004-2008, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"crypto/sha1.h"
end_include

begin_include
include|#
directive|include
file|"crypto/tls.h"
end_include

begin_include
include|#
directive|include
file|"eap_common/eap_tlv_common.h"
end_include

begin_include
include|#
directive|include
file|"eap_common/eap_peap_common.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_include
include|#
directive|include
file|"eap_tls_common.h"
end_include

begin_include
include|#
directive|include
file|"eap_config.h"
end_include

begin_include
include|#
directive|include
file|"tncc.h"
end_include

begin_comment
comment|/* Maximum supported PEAP version  * 0 = Microsoft's PEAP version 0; draft-kamath-pppext-peapv0-00.txt  * 1 = draft-josefsson-ppext-eap-tls-eap-05.txt  * 2 = draft-josefsson-ppext-eap-tls-eap-10.txt  */
end_comment

begin_define
define|#
directive|define
name|EAP_PEAP_VERSION
value|1
end_define

begin_function_decl
specifier|static
name|void
name|eap_peap_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|eap_peap_data
block|{
name|struct
name|eap_ssl_data
name|ssl
decl_stmt|;
name|int
name|peap_version
decl_stmt|,
name|force_peap_version
decl_stmt|,
name|force_new_label
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|phase2_method
decl_stmt|;
name|void
modifier|*
name|phase2_priv
decl_stmt|;
name|int
name|phase2_success
decl_stmt|;
name|int
name|phase2_eap_success
decl_stmt|;
name|int
name|phase2_eap_started
decl_stmt|;
name|struct
name|eap_method_type
name|phase2_type
decl_stmt|;
name|struct
name|eap_method_type
modifier|*
name|phase2_types
decl_stmt|;
name|size_t
name|num_phase2_types
decl_stmt|;
name|int
name|peap_outer_success
decl_stmt|;
comment|/* 0 = PEAP terminated on Phase 2 inner 				 * EAP-Success 				 * 1 = reply with tunneled EAP-Success to inner 				 * EAP-Success and expect AS to send outer 				 * (unencrypted) EAP-Success after this 				 * 2 = reply with PEAP/TLS ACK to inner 				 * EAP-Success and expect AS to send outer 				 * (unencrypted) EAP-Success after this */
name|int
name|resuming
decl_stmt|;
comment|/* starting a resumed session */
name|int
name|reauth
decl_stmt|;
comment|/* reauthentication */
name|u8
modifier|*
name|key_data
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|pending_phase2_req
decl_stmt|;
enum|enum
block|{
name|NO_BINDING
block|,
name|OPTIONAL_BINDING
block|,
name|REQUIRE_BINDING
block|}
name|crypto_binding
enum|;
name|int
name|crypto_binding_used
decl_stmt|;
name|u8
name|binding_nonce
index|[
literal|32
index|]
decl_stmt|;
name|u8
name|ipmk
index|[
literal|40
index|]
decl_stmt|;
name|u8
name|cmk
index|[
literal|20
index|]
decl_stmt|;
name|int
name|soh
decl_stmt|;
comment|/* Whether IF-TNCCS-SOH (Statement of Health; Microsoft NAP) 		  * is enabled. */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|eap_peap_parse_phase1
parameter_list|(
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|phase1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"peapver="
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
condition|)
block|{
name|data
operator|->
name|force_peap_version
operator|=
name|atoi
argument_list|(
name|pos
operator|+
literal|8
argument_list|)
expr_stmt|;
name|data
operator|->
name|peap_version
operator|=
name|data
operator|->
name|force_peap_version
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Forced PEAP version %d"
argument_list|,
name|data
operator|->
name|force_peap_version
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"peaplabel=1"
argument_list|)
condition|)
block|{
name|data
operator|->
name|force_new_label
operator|=
literal|1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Force new label for key "
literal|"derivation"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"peap_outer_success=0"
argument_list|)
condition|)
block|{
name|data
operator|->
name|peap_outer_success
operator|=
literal|0
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: terminate authentication on "
literal|"tunneled EAP-Success"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"peap_outer_success=1"
argument_list|)
condition|)
block|{
name|data
operator|->
name|peap_outer_success
operator|=
literal|1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: send tunneled EAP-Success "
literal|"after receiving tunneled EAP-Success"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"peap_outer_success=2"
argument_list|)
condition|)
block|{
name|data
operator|->
name|peap_outer_success
operator|=
literal|2
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: send PEAP/TLS ACK after "
literal|"receiving tunneled EAP-Success"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"crypto_binding=0"
argument_list|)
condition|)
block|{
name|data
operator|->
name|crypto_binding
operator|=
name|NO_BINDING
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Do not use cryptobinding"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"crypto_binding=1"
argument_list|)
condition|)
block|{
name|data
operator|->
name|crypto_binding
operator|=
name|OPTIONAL_BINDING
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Optional cryptobinding"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"crypto_binding=2"
argument_list|)
condition|)
block|{
name|data
operator|->
name|crypto_binding
operator|=
name|REQUIRE_BINDING
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Require cryptobinding"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EAP_TNC
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"tnc=soh2"
argument_list|)
condition|)
block|{
name|data
operator|->
name|soh
operator|=
literal|2
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: SoH version 2 enabled"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"tnc=soh1"
argument_list|)
condition|)
block|{
name|data
operator|->
name|soh
operator|=
literal|1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: SoH version 1 enabled"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|phase1
argument_list|,
literal|"tnc=soh"
argument_list|)
condition|)
block|{
name|data
operator|->
name|soh
operator|=
literal|2
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: SoH version 2 enabled"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EAP_TNC */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|eap_peap_init
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
decl_stmt|;
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|data
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sm
operator|->
name|peap_done
operator|=
name|FALSE
expr_stmt|;
name|data
operator|->
name|peap_version
operator|=
name|EAP_PEAP_VERSION
expr_stmt|;
name|data
operator|->
name|force_peap_version
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|->
name|peap_outer_success
operator|=
literal|2
expr_stmt|;
name|data
operator|->
name|crypto_binding
operator|=
name|OPTIONAL_BINDING
expr_stmt|;
if|if
condition|(
name|config
operator|&&
name|config
operator|->
name|phase1
operator|&&
name|eap_peap_parse_phase1
argument_list|(
name|data
argument_list|,
name|config
operator|->
name|phase1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|eap_peap_deinit
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|eap_peer_select_phase2_methods
argument_list|(
name|config
argument_list|,
literal|"auth="
argument_list|,
operator|&
name|data
operator|->
name|phase2_types
argument_list|,
operator|&
name|data
operator|->
name|num_phase2_types
argument_list|)
operator|<
literal|0
condition|)
block|{
name|eap_peap_deinit
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|data
operator|->
name|phase2_type
operator|.
name|vendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|eap_peer_tls_ssl_init
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|config
argument_list|,
name|EAP_TYPE_PEAP
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Failed to initialize SSL."
argument_list|)
expr_stmt|;
name|eap_peap_deinit
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peap_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|&&
name|data
operator|->
name|phase2_method
condition|)
name|data
operator|->
name|phase2_method
operator|->
name|deinit
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|phase2_types
argument_list|)
expr_stmt|;
name|eap_peer_tls_ssl_deinit
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|key_data
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_tlv_build_nak - Build EAP-TLV NAK message  * @id: EAP identifier for the header  * @nak_type: TLV type (EAP_TLV_*)  * Returns: Buffer to the allocated EAP-TLV NAK message or %NULL on failure  *  * This function builds an EAP-TLV NAK message. The caller is responsible for  * freeing the returned buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_tlv_build_nak
parameter_list|(
name|int
name|id
parameter_list|,
name|u16
name|nak_type
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_TLV
argument_list|,
literal|10
argument_list|,
name|EAP_CODE_RESPONSE
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Mandatory */
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
name|EAP_TLV_NAK_TLV
argument_list|)
expr_stmt|;
name|wpabuf_put_be16
argument_list|(
name|msg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Length */
name|wpabuf_put_be32
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Vendor-Id */
name|wpabuf_put_be16
argument_list|(
name|msg
argument_list|,
name|nak_type
argument_list|)
expr_stmt|;
comment|/* NAK-Type */
return|return
name|msg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_get_isk
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|u8
modifier|*
name|isk
parameter_list|,
name|size_t
name|isk_len
parameter_list|)
block|{
name|u8
modifier|*
name|key
decl_stmt|;
name|size_t
name|key_len
decl_stmt|;
name|os_memset
argument_list|(
name|isk
argument_list|,
literal|0
argument_list|,
name|isk_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|phase2_method
operator|==
name|NULL
operator|||
name|data
operator|->
name|phase2_priv
operator|==
name|NULL
operator|||
name|data
operator|->
name|phase2_method
operator|->
name|isKeyAvailable
operator|==
name|NULL
operator|||
name|data
operator|->
name|phase2_method
operator|->
name|getKey
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|data
operator|->
name|phase2_method
operator|->
name|isKeyAvailable
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|)
operator|||
operator|(
name|key
operator|=
name|data
operator|->
name|phase2_method
operator|->
name|getKey
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|,
operator|&
name|key_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Could not get key material "
literal|"from Phase 2"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|key_len
operator|>
name|isk_len
condition|)
name|key_len
operator|=
name|isk_len
expr_stmt|;
name|os_memcpy
argument_list|(
name|isk
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_derive_cmk
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|)
block|{
name|u8
modifier|*
name|tk
decl_stmt|;
name|u8
name|isk
index|[
literal|32
index|]
decl_stmt|,
name|imck
index|[
literal|60
index|]
decl_stmt|;
comment|/* 	 * Tunnel key (TK) is the first 60 octets of the key generated by 	 * phase 1 of PEAP (based on TLS). 	 */
name|tk
operator|=
name|data
operator|->
name|key_data
expr_stmt|;
if|if
condition|(
name|tk
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: TK"
argument_list|,
name|tk
argument_list|,
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|reauth
operator|&&
name|tls_connection_resumed
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|)
condition|)
block|{
comment|/* Fast-connect: IPMK|CMK = TK */
name|os_memcpy
argument_list|(
name|data
operator|->
name|ipmk
argument_list|,
name|tk
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: IPMK from TK"
argument_list|,
name|data
operator|->
name|ipmk
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|data
operator|->
name|cmk
argument_list|,
name|tk
operator|+
literal|40
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: CMK from TK"
argument_list|,
name|data
operator|->
name|cmk
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eap_peap_get_isk
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|isk
argument_list|,
sizeof|sizeof
argument_list|(
name|isk
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: ISK"
argument_list|,
name|isk
argument_list|,
sizeof|sizeof
argument_list|(
name|isk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * IPMK Seed = "Inner Methods Compound Keys" | ISK 	 * TempKey = First 40 octets of TK 	 * IPMK|CMK = PRF+(TempKey, IPMK Seed, 60) 	 * (note: draft-josefsson-pppext-eap-tls-eap-10.txt includes a space 	 * in the end of the label just before ISK; is that just a typo?) 	 */
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: TempKey"
argument_list|,
name|tk
argument_list|,
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|peap_prfplus
argument_list|(
name|data
operator|->
name|peap_version
argument_list|,
name|tk
argument_list|,
literal|40
argument_list|,
literal|"Inner Methods Compound Keys"
argument_list|,
name|isk
argument_list|,
sizeof|sizeof
argument_list|(
name|isk
argument_list|)
argument_list|,
name|imck
argument_list|,
sizeof|sizeof
argument_list|(
name|imck
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: IMCK (IPMKj)"
argument_list|,
name|imck
argument_list|,
sizeof|sizeof
argument_list|(
name|imck
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|data
operator|->
name|ipmk
argument_list|,
name|imck
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: IPMK (S-IPMKj)"
argument_list|,
name|data
operator|->
name|ipmk
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|data
operator|->
name|cmk
argument_list|,
name|imck
operator|+
literal|40
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: CMK (CMKj)"
argument_list|,
name|data
operator|->
name|cmk
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_tlv_add_cryptobinding
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|)
block|{
name|u8
modifier|*
name|mac
decl_stmt|;
name|u8
name|eap_type
init|=
name|EAP_TYPE_PEAP
decl_stmt|;
specifier|const
name|u8
modifier|*
name|addr
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|len
index|[
literal|2
index|]
decl_stmt|;
name|u16
name|tlv_type
decl_stmt|;
comment|/* Compound_MAC: HMAC-SHA1-160(cryptobinding TLV | EAP type) */
name|addr
index|[
literal|0
index|]
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
index|[
literal|0
index|]
operator|=
literal|60
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|&
name|eap_type
expr_stmt|;
name|len
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|tlv_type
operator|=
name|EAP_TLV_CRYPTO_BINDING_TLV
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|peap_version
operator|>=
literal|2
condition|)
name|tlv_type
operator||=
name|EAP_TLV_TYPE_MANDATORY
expr_stmt|;
name|wpabuf_put_be16
argument_list|(
name|buf
argument_list|,
name|tlv_type
argument_list|)
expr_stmt|;
name|wpabuf_put_be16
argument_list|(
name|buf
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reserved */
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
expr_stmt|;
comment|/* Version */
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
expr_stmt|;
comment|/* RecvVersion */
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* SubType: 0 = Request, 1 = Response */
name|wpabuf_put_data
argument_list|(
name|buf
argument_list|,
name|data
operator|->
name|binding_nonce
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Nonce */
name|mac
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* Compound_MAC */
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP-PEAP: Compound_MAC CMK"
argument_list|,
name|data
operator|->
name|cmk
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP-PEAP: Compound_MAC data 1"
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|len
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP-PEAP: Compound_MAC data 2"
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|len
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hmac_sha1_vector
argument_list|(
name|data
operator|->
name|cmk
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP-PEAP: Compound_MAC"
argument_list|,
name|mac
argument_list|,
name|SHA1_MAC_LEN
argument_list|)
expr_stmt|;
name|data
operator|->
name|crypto_binding_used
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * eap_tlv_build_result - Build EAP-TLV Result message  * @id: EAP identifier for the header  * @status: Status (EAP_TLV_RESULT_SUCCESS or EAP_TLV_RESULT_FAILURE)  * Returns: Buffer to the allocated EAP-TLV Result message or %NULL on failure  *  * This function builds an EAP-TLV Result message. The caller is responsible  * for freeing the returned buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_tlv_build_result
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|int
name|crypto_tlv_used
parameter_list|,
name|int
name|id
parameter_list|,
name|u16
name|status
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|crypto_binding
operator|==
name|NO_BINDING
condition|)
name|crypto_tlv_used
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|crypto_tlv_used
condition|)
name|len
operator|+=
literal|60
expr_stmt|;
comment|/* Cryptobinding TLV */
name|msg
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_TLV
argument_list|,
name|len
argument_list|,
name|EAP_CODE_RESPONSE
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Mandatory */
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
name|EAP_TLV_RESULT_TLV
argument_list|)
expr_stmt|;
name|wpabuf_put_be16
argument_list|(
name|msg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Length */
name|wpabuf_put_be16
argument_list|(
name|msg
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Status */
if|if
condition|(
name|crypto_tlv_used
operator|&&
name|eap_tlv_add_cryptobinding
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|msg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_tlv_validate_cryptobinding
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
specifier|const
name|u8
modifier|*
name|crypto_tlv
parameter_list|,
name|size_t
name|crypto_tlv_len
parameter_list|)
block|{
name|u8
name|buf
index|[
literal|61
index|]
decl_stmt|,
name|mac
index|[
name|SHA1_MAC_LEN
index|]
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
if|if
condition|(
name|eap_peap_derive_cmk
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Could not derive CMK"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|crypto_tlv_len
operator|!=
literal|4
operator|+
literal|56
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Invalid cryptobinding TLV "
literal|"length %d"
argument_list|,
operator|(
name|int
operator|)
name|crypto_tlv_len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|=
name|crypto_tlv
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
comment|/* TLV header */
if|if
condition|(
name|pos
index|[
literal|1
index|]
operator|!=
name|data
operator|->
name|peap_version
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Cryptobinding TLV Version "
literal|"mismatch (was %d; expected %d)"
argument_list|,
name|pos
index|[
literal|1
index|]
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pos
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Unexpected Cryptobinding TLV "
literal|"SubType %d"
argument_list|,
name|pos
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|+=
literal|4
expr_stmt|;
name|os_memcpy
argument_list|(
name|data
operator|->
name|binding_nonce
argument_list|,
name|pos
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|32
expr_stmt|;
comment|/* Nonce */
comment|/* Compound_MAC: HMAC-SHA1-160(cryptobinding TLV | EAP type) */
name|os_memcpy
argument_list|(
name|buf
argument_list|,
name|crypto_tlv
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
name|buf
operator|+
literal|4
operator|+
literal|4
operator|+
literal|32
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* Compound_MAC */
name|buf
index|[
literal|60
index|]
operator|=
name|EAP_TYPE_PEAP
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Compound_MAC data"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|hmac_sha1
argument_list|(
name|data
operator|->
name|cmk
argument_list|,
literal|20
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_memcmp
argument_list|(
name|mac
argument_list|,
name|pos
argument_list|,
name|SHA1_MAC_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Invalid Compound_MAC in "
literal|"cryptobinding TLV"
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Received MAC"
argument_list|,
name|pos
argument_list|,
name|SHA1_MAC_LEN
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Expected MAC"
argument_list|,
name|mac
argument_list|,
name|SHA1_MAC_LEN
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Valid cryptobinding TLV received"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * eap_tlv_process - Process a received EAP-TLV message and generate a response  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @ret: Return values from EAP request validation and processing  * @req: EAP-TLV request to be processed. The caller must have validated that  * the buffer is large enough to contain full request (hdr->length bytes) and  * that the EAP type is EAP_TYPE_TLV.  * @resp: Buffer to return a pointer to the allocated response message. This  * field should be initialized to %NULL before the call. The value will be  * updated if a response message is generated. The caller is responsible for  * freeing the allocated message.  * @force_failure: Force negotiation to fail  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|eap_tlv_process
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|struct
name|eap_method_ret
modifier|*
name|ret
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|resp
parameter_list|,
name|int
name|force_failure
parameter_list|)
block|{
name|size_t
name|left
decl_stmt|,
name|tlv_len
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
specifier|const
name|u8
modifier|*
name|result_tlv
init|=
name|NULL
decl_stmt|,
modifier|*
name|crypto_tlv
init|=
name|NULL
decl_stmt|;
name|size_t
name|result_tlv_len
init|=
literal|0
decl_stmt|,
name|crypto_tlv_len
init|=
literal|0
decl_stmt|;
name|int
name|tlv_type
decl_stmt|,
name|mandatory
decl_stmt|;
comment|/* Parse TLVs */
name|pos
operator|=
name|eap_hdr_validate
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_TLV
argument_list|,
name|req
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-TLV: Received TLVs"
argument_list|,
name|pos
argument_list|,
name|left
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
operator|>=
literal|4
condition|)
block|{
name|mandatory
operator|=
operator|!
operator|!
operator|(
name|pos
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
expr_stmt|;
name|tlv_type
operator|=
name|WPA_GET_BE16
argument_list|(
name|pos
argument_list|)
operator|&
literal|0x3fff
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
name|tlv_len
operator|=
name|WPA_GET_BE16
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
name|left
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|tlv_len
operator|>
name|left
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-TLV: TLV underrun "
literal|"(tlv_len=%lu left=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tlv_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|left
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|tlv_type
condition|)
block|{
case|case
name|EAP_TLV_RESULT_TLV
case|:
name|result_tlv
operator|=
name|pos
expr_stmt|;
name|result_tlv_len
operator|=
name|tlv_len
expr_stmt|;
break|break;
case|case
name|EAP_TLV_CRYPTO_BINDING_TLV
case|:
name|crypto_tlv
operator|=
name|pos
expr_stmt|;
name|crypto_tlv_len
operator|=
name|tlv_len
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-TLV: Unsupported TLV Type "
literal|"%d%s"
argument_list|,
name|tlv_type
argument_list|,
name|mandatory
condition|?
literal|" (mandatory)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|mandatory
condition|)
block|{
comment|/* NAK TLV and ignore all TLVs in this packet. 				 */
operator|*
name|resp
operator|=
name|eap_tlv_build_nak
argument_list|(
name|eap_get_id
argument_list|(
name|req
argument_list|)
argument_list|,
name|tlv_type
argument_list|)
expr_stmt|;
return|return
operator|*
name|resp
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
comment|/* Ignore this TLV, but process other TLVs */
break|break;
block|}
name|pos
operator|+=
name|tlv_len
expr_stmt|;
name|left
operator|-=
name|tlv_len
expr_stmt|;
block|}
if|if
condition|(
name|left
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-TLV: Last TLV too short in "
literal|"Request (left=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|left
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Process supported TLVs */
if|if
condition|(
name|crypto_tlv
operator|&&
name|data
operator|->
name|crypto_binding
operator|!=
name|NO_BINDING
condition|)
block|{
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Cryptobinding TLV"
argument_list|,
name|crypto_tlv
argument_list|,
name|crypto_tlv_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_tlv_validate_cryptobinding
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|crypto_tlv
operator|-
literal|4
argument_list|,
name|crypto_tlv_len
operator|+
literal|4
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|result_tlv
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|force_failure
operator|=
literal|1
expr_stmt|;
name|crypto_tlv
operator|=
name|NULL
expr_stmt|;
comment|/* do not include Cryptobinding TLV 					    * in response, if the received 					    * cryptobinding was invalid. */
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|crypto_tlv
operator|&&
name|data
operator|->
name|crypto_binding
operator|==
name|REQUIRE_BINDING
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: No cryptobinding TLV"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|result_tlv
condition|)
block|{
name|int
name|status
decl_stmt|,
name|resp_status
decl_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-TLV: Result TLV"
argument_list|,
name|result_tlv
argument_list|,
name|result_tlv_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_tlv_len
operator|<
literal|2
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-TLV: Too short Result TLV "
literal|"(len=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|result_tlv_len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|status
operator|=
name|WPA_GET_BE16
argument_list|(
name|result_tlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EAP_TLV_RESULT_SUCCESS
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-TLV: TLV Result - Success "
literal|"- EAP-TLV/Phase2 Completed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_failure
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-TLV: Earlier failure"
literal|" - force failed Phase 2"
argument_list|)
expr_stmt|;
name|resp_status
operator|=
name|EAP_TLV_RESULT_FAILURE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
block|}
else|else
block|{
name|resp_status
operator|=
name|EAP_TLV_RESULT_SUCCESS
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_UNCOND_SUCC
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|EAP_TLV_RESULT_FAILURE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-TLV: TLV Result - Failure"
argument_list|)
expr_stmt|;
name|resp_status
operator|=
name|EAP_TLV_RESULT_FAILURE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-TLV: Unknown TLV Result "
literal|"Status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|resp_status
operator|=
name|EAP_TLV_RESULT_FAILURE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
block|}
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
operator|*
name|resp
operator|=
name|eap_tlv_build_result
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|crypto_tlv
operator|!=
name|NULL
argument_list|,
name|eap_get_id
argument_list|(
name|req
argument_list|)
argument_list|,
name|resp_status
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_peapv2_tlv_eap_payload
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|e
decl_stmt|;
name|struct
name|eap_tlv_hdr
modifier|*
name|tlv
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Encapsulate EAP packet in EAP-Payload TLV */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAPv2: Add EAP-Payload TLV"
argument_list|)
expr_stmt|;
name|e
operator|=
name|wpabuf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
operator|+
name|wpabuf_len
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAPv2: Failed to allocate memory "
literal|"for TLV encapsulation"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tlv
operator|=
name|wpabuf_put
argument_list|(
name|e
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
argument_list|)
expr_stmt|;
name|tlv
operator|->
name|tlv_type
operator|=
name|host_to_be16
argument_list|(
name|EAP_TLV_TYPE_MANDATORY
operator||
name|EAP_TLV_EAP_PAYLOAD_TLV
argument_list|)
expr_stmt|;
name|tlv
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
name|wpabuf_len
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_buf
argument_list|(
name|e
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_phase2_request
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|struct
name|eap_method_ret
modifier|*
name|ret
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|hdr
init|=
name|wpabuf_mhead
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|struct
name|eap_method_ret
name|iret
decl_stmt|;
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: too short "
literal|"Phase 2 request (len=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 Request: type=%d"
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|pos
condition|)
block|{
case|case
name|EAP_TYPE_IDENTITY
case|:
operator|*
name|resp
operator|=
name|eap_sm_buildIdentity
argument_list|(
name|sm
argument_list|,
name|hdr
operator|->
name|identifier
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_TYPE_TLV
case|:
name|os_memset
argument_list|(
operator|&
name|iret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_tlv_process
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|iret
argument_list|,
name|req
argument_list|,
name|resp
argument_list|,
name|data
operator|->
name|phase2_eap_started
operator|&&
operator|!
name|data
operator|->
name|phase2_eap_success
argument_list|)
condition|)
block|{
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iret
operator|.
name|methodState
operator|==
name|METHOD_DONE
operator|||
name|iret
operator|.
name|methodState
operator|==
name|METHOD_MAY_CONT
condition|)
block|{
name|ret
operator|->
name|methodState
operator|=
name|iret
operator|.
name|methodState
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|iret
operator|.
name|decision
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|EAP_TYPE_EXPANDED
case|:
ifdef|#
directive|ifdef
name|EAP_TNC
if|if
condition|(
name|data
operator|->
name|soh
condition|)
block|{
specifier|const
name|u8
modifier|*
name|epos
decl_stmt|;
name|size_t
name|eleft
decl_stmt|;
name|epos
operator|=
name|eap_hdr_validate
argument_list|(
name|EAP_VENDOR_MICROSOFT
argument_list|,
literal|0x21
argument_list|,
name|req
argument_list|,
operator|&
name|eleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|epos
condition|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: SoH EAP Extensions"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|tncc_process_soh_request
argument_list|(
name|data
operator|->
name|soh
argument_list|,
name|epos
argument_list|,
name|eleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
operator|*
name|resp
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_MICROSOFT
argument_list|,
literal|0x21
argument_list|,
name|wpabuf_len
argument_list|(
name|buf
argument_list|)
argument_list|,
name|EAP_CODE_RESPONSE
argument_list|,
name|hdr
operator|->
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|resp
operator|==
name|NULL
condition|)
block|{
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpabuf_put_buf
argument_list|(
operator|*
name|resp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* EAP_TNC */
comment|/* fall through */
default|default:
if|if
condition|(
name|data
operator|->
name|phase2_type
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|==
name|EAP_TYPE_NONE
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|num_phase2_types
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|method
operator|!=
operator|*
name|pos
condition|)
continue|continue;
name|data
operator|->
name|phase2_type
operator|.
name|vendor
operator|=
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|vendor
expr_stmt|;
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|=
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|method
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Selected "
literal|"Phase 2 EAP vendor %d method %d"
argument_list|,
name|data
operator|->
name|phase2_type
operator|.
name|vendor
argument_list|,
name|data
operator|->
name|phase2_type
operator|.
name|method
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|pos
operator|!=
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|||
operator|*
name|pos
operator|==
name|EAP_TYPE_NONE
condition|)
block|{
if|if
condition|(
name|eap_peer_tls_phase2_nak
argument_list|(
name|data
operator|->
name|phase2_types
argument_list|,
name|data
operator|->
name|num_phase2_types
argument_list|,
name|hdr
argument_list|,
name|resp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|==
name|NULL
condition|)
block|{
name|data
operator|->
name|phase2_method
operator|=
name|eap_peer_get_eap_method
argument_list|(
name|data
operator|->
name|phase2_type
operator|.
name|vendor
argument_list|,
name|data
operator|->
name|phase2_type
operator|.
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|phase2_method
condition|)
block|{
name|sm
operator|->
name|init_phase2
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|phase2_priv
operator|=
name|data
operator|->
name|phase2_method
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|init_phase2
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|==
name|NULL
operator|||
name|data
operator|->
name|phase2_method
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: failed to initialize "
literal|"Phase 2 EAP method %d"
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|data
operator|->
name|phase2_eap_started
operator|=
literal|1
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|iret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iret
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|resp
operator|=
name|data
operator|->
name|phase2_method
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|,
operator|&
name|iret
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iret
operator|.
name|methodState
operator|==
name|METHOD_DONE
operator|||
name|iret
operator|.
name|methodState
operator|==
name|METHOD_MAY_CONT
operator|)
operator|&&
operator|(
name|iret
operator|.
name|decision
operator|==
name|DECISION_UNCOND_SUCC
operator|||
name|iret
operator|.
name|decision
operator|==
name|DECISION_COND_SUCC
operator|)
condition|)
block|{
name|data
operator|->
name|phase2_eap_success
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|resp
operator|==
name|NULL
operator|&&
operator|(
name|config
operator|->
name|pending_req_identity
operator|||
name|config
operator|->
name|pending_req_password
operator|||
name|config
operator|->
name|pending_req_otp
operator|||
name|config
operator|->
name|pending_req_new_password
operator|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|wpabuf_alloc_copy
argument_list|(
name|hdr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_decrypt
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|struct
name|eap_method_ret
modifier|*
name|ret
parameter_list|,
specifier|const
name|struct
name|eap_hdr
modifier|*
name|req
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|in_data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|out_data
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|in_decrypted
init|=
name|NULL
decl_stmt|;
name|int
name|res
decl_stmt|,
name|skip_change
init|=
literal|0
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|rhdr
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: received %lu bytes encrypted data for"
literal|" Phase 2"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|in_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|pending_phase2_req
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Pending Phase 2 request - "
literal|"skip decryption and use old data"
argument_list|)
expr_stmt|;
comment|/* Clear TLS reassembly state. */
name|eap_peer_tls_reset_input
argument_list|(
operator|&
name|data
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|in_decrypted
operator|=
name|data
operator|->
name|pending_phase2_req
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|NULL
expr_stmt|;
name|skip_change
operator|=
literal|1
expr_stmt|;
goto|goto
name|continue_req
goto|;
block|}
if|if
condition|(
name|wpabuf_len
argument_list|(
name|in_data
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|workaround
operator|&&
name|data
operator|->
name|phase2_success
condition|)
block|{
comment|/* 		 * Cisco ACS seems to be using TLS ACK to terminate 		 * EAP-PEAPv0/GTC. Try to reply with TLS ACK. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Received TLS ACK, but "
literal|"expected data - acknowledge with TLS ACK since "
literal|"Phase 2 has been completed"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|wpabuf_len
argument_list|(
name|in_data
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Received TLS ACK - requesting more fragments */
return|return
name|eap_peer_tls_encrypt
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|data
operator|->
name|peap_version
argument_list|,
name|req
operator|->
name|identifier
argument_list|,
name|NULL
argument_list|,
name|out_data
argument_list|)
return|;
block|}
name|res
operator|=
name|eap_peer_tls_decrypt
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|in_data
argument_list|,
operator|&
name|in_decrypted
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
name|continue_req
label|:
name|wpa_hexdump_buf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Decrypted Phase 2 EAP"
argument_list|,
name|in_decrypted
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|wpabuf_mhead
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
operator|==
literal|5
operator|&&
name|hdr
operator|->
name|code
operator|==
name|EAP_CODE_REQUEST
operator|&&
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|==
literal|5
operator|&&
name|eap_get_type
argument_list|(
name|in_decrypted
argument_list|)
operator|==
name|EAP_TYPE_IDENTITY
condition|)
block|{
comment|/* At least FreeRADIUS seems to send full EAP header with 		 * EAP Request Identity */
name|skip_change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
operator|>=
literal|5
operator|&&
name|hdr
operator|->
name|code
operator|==
name|EAP_CODE_REQUEST
operator|&&
name|eap_get_type
argument_list|(
name|in_decrypted
argument_list|)
operator|==
name|EAP_TYPE_TLV
condition|)
block|{
name|skip_change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|peap_version
operator|==
literal|0
operator|&&
operator|!
name|skip_change
condition|)
block|{
name|struct
name|eap_hdr
modifier|*
name|nhdr
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|nmsg
init|=
name|wpabuf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nmsg
operator|==
name|NULL
condition|)
block|{
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nhdr
operator|=
name|wpabuf_put
argument_list|(
name|nmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nhdr
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_buf
argument_list|(
name|nmsg
argument_list|,
name|in_decrypted
argument_list|)
expr_stmt|;
name|nhdr
operator|->
name|code
operator|=
name|req
operator|->
name|code
expr_stmt|;
name|nhdr
operator|->
name|identifier
operator|=
name|req
operator|->
name|identifier
expr_stmt|;
name|nhdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|in_decrypted
operator|=
name|nmsg
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|peap_version
operator|>=
literal|2
condition|)
block|{
name|struct
name|eap_tlv_hdr
modifier|*
name|tlv
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|nmsg
decl_stmt|;
if|if
condition|(
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAPv2: Too short Phase 2 "
literal|"EAP TLV"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tlv
operator|=
name|wpabuf_mhead
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|be_to_host16
argument_list|(
name|tlv
operator|->
name|tlv_type
argument_list|)
operator|&
literal|0x3fff
operator|)
operator|!=
name|EAP_TLV_EAP_PAYLOAD_TLV
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAPv2: Not an EAP TLV"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
operator|+
name|be_to_host16
argument_list|(
name|tlv
operator|->
name|length
argument_list|)
operator|>
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAPv2: Invalid EAP TLV "
literal|"length"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
operator|(
name|tlv
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|>
name|be_to_host16
argument_list|(
name|tlv
operator|->
name|length
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAPv2: No room for full "
literal|"EAP packet in EAP TLV"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nmsg
operator|=
name|wpabuf_alloc
argument_list|(
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmsg
operator|==
name|NULL
condition|)
block|{
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wpabuf_put_data
argument_list|(
name|nmsg
argument_list|,
name|hdr
argument_list|,
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|in_decrypted
operator|=
name|nmsg
expr_stmt|;
block|}
name|hdr
operator|=
name|wpabuf_mhead
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Too short Phase 2 "
literal|"EAP frame (len=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Length mismatch in "
literal|"Phase 2 EAP frame (len=%lu hdr->length=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|<
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Odd.. Phase 2 EAP header has "
literal|"shorter length than full decrypted data "
literal|"(%lu< %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|in_decrypted
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: received Phase 2: code=%d "
literal|"identifier=%d length=%lu"
argument_list|,
name|hdr
operator|->
name|code
argument_list|,
name|hdr
operator|->
name|identifier
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|code
condition|)
block|{
case|case
name|EAP_CODE_REQUEST
case|:
if|if
condition|(
name|eap_peap_phase2_request
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|ret
argument_list|,
name|in_decrypted
argument_list|,
operator|&
name|resp
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Phase2 Request "
literal|"processing failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|EAP_CODE_SUCCESS
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 Success"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|peap_version
operator|==
literal|1
condition|)
block|{
comment|/* EAP-Success within TLS tunnel is used to indicate 			 * shutdown of the TLS channel. The authentication has 			 * been completed. */
if|if
condition|(
name|data
operator|->
name|phase2_eap_started
operator|&&
operator|!
name|data
operator|->
name|phase2_eap_success
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 "
literal|"Success used to indicate success, "
literal|"but Phase 2 EAP was not yet "
literal|"completed successfully"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Version 1 - "
literal|"EAP-Success within TLS tunnel - "
literal|"authentication completed"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_UNCOND_SUCC
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|peap_outer_success
operator|==
literal|2
condition|)
block|{
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Use TLS ACK "
literal|"to finish authentication"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|peap_outer_success
operator|==
literal|1
condition|)
block|{
comment|/* Reply with EAP-Success within the TLS 				 * channel to complete the authentication. */
name|resp
operator|=
name|wpabuf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|rhdr
operator|=
name|wpabuf_put
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rhdr
argument_list|)
argument_list|)
expr_stmt|;
name|rhdr
operator|->
name|code
operator|=
name|EAP_CODE_SUCCESS
expr_stmt|;
name|rhdr
operator|->
name|identifier
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
name|rhdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No EAP-Success expected for Phase 1 (outer, 				 * unencrypted auth), so force EAP state 				 * machine to SUCCESS state. */
name|sm
operator|->
name|peap_done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* FIX: ? */
block|}
break|break;
case|case
name|EAP_CODE_FAILURE
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 Failure"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_MAY_CONT
expr_stmt|;
name|ret
operator|->
name|allowNotifications
operator|=
name|FALSE
expr_stmt|;
comment|/* Reply with EAP-Failure within the TLS channel to complete 		 * failure reporting. */
name|resp
operator|=
name|wpabuf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|rhdr
operator|=
name|wpabuf_put
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rhdr
argument_list|)
argument_list|)
expr_stmt|;
name|rhdr
operator|->
name|code
operator|=
name|EAP_CODE_FAILURE
expr_stmt|;
name|rhdr
operator|->
name|identifier
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
name|rhdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Unexpected code=%d in "
literal|"Phase 2 EAP header"
argument_list|,
name|hdr
operator|->
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpabuf_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|int
name|skip_change2
init|=
literal|0
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|rmsg
decl_stmt|,
name|buf
decl_stmt|;
name|wpa_hexdump_buf_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Encrypting Phase 2 data"
argument_list|,
name|resp
argument_list|)
expr_stmt|;
comment|/* PEAP version changes */
if|if
condition|(
name|data
operator|->
name|peap_version
operator|>=
literal|2
condition|)
block|{
name|resp
operator|=
name|eap_peapv2_tlv_eap_payload
argument_list|(
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|wpabuf_len
argument_list|(
name|resp
argument_list|)
operator|>=
literal|5
operator|&&
name|wpabuf_head_u8
argument_list|(
name|resp
argument_list|)
index|[
literal|0
index|]
operator|==
name|EAP_CODE_RESPONSE
operator|&&
name|eap_get_type
argument_list|(
name|resp
argument_list|)
operator|==
name|EAP_TYPE_TLV
condition|)
name|skip_change2
operator|=
literal|1
expr_stmt|;
name|rmsg
operator|=
name|resp
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|peap_version
operator|==
literal|0
operator|&&
operator|!
name|skip_change2
condition|)
block|{
name|wpabuf_set
argument_list|(
operator|&
name|buf
argument_list|,
name|wpabuf_head_u8
argument_list|(
name|resp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|resp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|rmsg
operator|=
operator|&
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|eap_peer_tls_encrypt
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|data
operator|->
name|peap_version
argument_list|,
name|req
operator|->
name|identifier
argument_list|,
name|rmsg
argument_list|,
name|out_data
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Failed to encrypt "
literal|"a Phase 2 frame"
argument_list|)
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_peap_process
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|struct
name|eap_method_ret
modifier|*
name|ret
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|reqData
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|req
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|int
name|res
decl_stmt|;
name|u8
name|flags
decl_stmt|,
name|id
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|pos
operator|=
name|eap_peer_tls_process_init
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|ret
argument_list|,
name|reqData
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|req
operator|=
name|wpabuf_head
argument_list|(
name|reqData
argument_list|)
expr_stmt|;
name|id
operator|=
name|req
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EAP_TLS_FLAGS_START
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Start (server ver=%d, own "
literal|"ver=%d)"
argument_list|,
name|flags
operator|&
name|EAP_TLS_VERSION_MASK
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|EAP_TLS_VERSION_MASK
operator|)
operator|<
name|data
operator|->
name|peap_version
condition|)
name|data
operator|->
name|peap_version
operator|=
name|flags
operator|&
name|EAP_TLS_VERSION_MASK
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|force_peap_version
operator|>=
literal|0
operator|&&
name|data
operator|->
name|force_peap_version
operator|!=
name|data
operator|->
name|peap_version
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP-PEAP: Failed to select "
literal|"forced PEAP version %d"
argument_list|,
name|data
operator|->
name|force_peap_version
argument_list|)
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|ret
operator|->
name|allowNotifications
operator|=
name|FALSE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Using PEAP version %d"
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
comment|/* make sure that this frame is empty, even though it 			   * should always be, anyway */
block|}
name|resp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tls_connection_established
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|)
operator|&&
operator|!
name|data
operator|->
name|resuming
condition|)
block|{
name|struct
name|wpabuf
name|msg
decl_stmt|;
name|wpabuf_set
argument_list|(
operator|&
name|msg
argument_list|,
name|pos
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|res
operator|=
name|eap_peap_decrypt
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|ret
argument_list|,
name|req
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|eap_peer_tls_process_helper
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|data
operator|->
name|peap_version
argument_list|,
name|id
argument_list|,
name|pos
argument_list|,
name|left
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_connection_established
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|)
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: TLS done, proceed to Phase 2"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|key_data
argument_list|)
expr_stmt|;
comment|/* draft-josefsson-ppext-eap-tls-eap-05.txt 			 * specifies that PEAPv1 would use "client PEAP 			 * encryption" as the label. However, most existing 			 * PEAPv1 implementations seem to be using the old 			 * label, "client EAP encryption", instead. Use the old 			 * label by default, but allow it to be configured with 			 * phase1 parameter peaplabel=1. */
if|if
condition|(
name|data
operator|->
name|peap_version
operator|>
literal|1
operator|||
name|data
operator|->
name|force_new_label
condition|)
name|label
operator|=
literal|"client PEAP encryption"
expr_stmt|;
else|else
name|label
operator|=
literal|"client EAP encryption"
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: using label '%s' in "
literal|"key derivation"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|data
operator|->
name|key_data
operator|=
name|eap_peer_tls_derive_key
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|label
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|key_data
condition|)
block|{
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Derived key"
argument_list|,
name|data
operator|->
name|key_data
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Failed to "
literal|"derive key"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|data
operator|->
name|resuming
condition|)
block|{
comment|/* 				 * At least few RADIUS servers (Aegis v1.1.6; 				 * but not v1.1.4; and Cisco ACS) seem to be 				 * terminating PEAPv1 (Aegis) or PEAPv0 (Cisco 				 * ACS) session resumption with outer 				 * EAP-Success. This does not seem to follow 				 * draft-josefsson-pppext-eap-tls-eap-05.txt 				 * section 4.2, so only allow this if EAP 				 * workarounds are enabled. 				 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Workaround - "
literal|"allow outer EAP-Success to "
literal|"terminate PEAP resumption"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
block|}
name|data
operator|->
name|resuming
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|2
condition|)
block|{
name|struct
name|wpabuf
name|msg
decl_stmt|;
comment|/* 			 * Application data included in the handshake message. 			 */
name|wpabuf_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|resp
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|wpabuf_set
argument_list|(
operator|&
name|msg
argument_list|,
name|pos
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|res
operator|=
name|eap_peap_decrypt
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|ret
argument_list|,
name|req
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
block|{
name|ret
operator|->
name|allowNotifications
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|1
condition|)
block|{
name|wpabuf_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|eap_peer_tls_build_ack
argument_list|(
name|id
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
return|;
block|}
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|eap_peap_has_reauth_data
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
return|return
name|tls_connection_established
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|)
operator|&&
name|data
operator|->
name|phase2_success
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peap_deinit_for_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|wpabuf_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|crypto_binding_used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|eap_peap_init_for_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|key_data
argument_list|)
expr_stmt|;
name|data
operator|->
name|key_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|eap_peer_tls_reauth_init
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|)
condition|)
block|{
name|os_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|&&
name|data
operator|->
name|phase2_method
operator|&&
name|data
operator|->
name|phase2_method
operator|->
name|init_for_reauth
condition|)
name|data
operator|->
name|phase2_method
operator|->
name|init_for_reauth
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|)
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|phase2_eap_success
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|phase2_eap_started
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|resuming
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|reauth
operator|=
literal|1
expr_stmt|;
name|sm
operator|->
name|peap_done
operator|=
name|FALSE
expr_stmt|;
return|return
name|priv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_get_status
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|len
operator|=
name|eap_peer_tls_status
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|phase2_method
condition|)
block|{
name|ret
operator|=
name|os_snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"EAP-PEAPv%d Phase2 method=%s\n"
argument_list|,
name|data
operator|->
name|peap_version
argument_list|,
name|data
operator|->
name|phase2_method
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|ret
operator|>=
name|buflen
operator|-
name|len
condition|)
return|return
name|len
return|;
name|len
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|eap_peap_isKeyAvailable
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
return|return
name|data
operator|->
name|key_data
operator|!=
name|NULL
operator|&&
name|data
operator|->
name|phase2_success
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_peap_getKey
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|u8
modifier|*
name|key
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|key_data
operator|==
name|NULL
operator|||
operator|!
name|data
operator|->
name|phase2_success
condition|)
return|return
name|NULL
return|;
name|key
operator|=
name|os_malloc
argument_list|(
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|EAP_TLS_KEY_LEN
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|crypto_binding_used
condition|)
block|{
name|u8
name|csk
index|[
literal|128
index|]
decl_stmt|;
comment|/* 		 * Note: It looks like Microsoft implementation requires null 		 * termination for this label while the one used for deriving 		 * IPMK|CMK did not use null termination. 		 */
if|if
condition|(
name|peap_prfplus
argument_list|(
name|data
operator|->
name|peap_version
argument_list|,
name|data
operator|->
name|ipmk
argument_list|,
literal|40
argument_list|,
literal|"Session Key Generating Function"
argument_list|,
operator|(
name|u8
operator|*
operator|)
literal|"\00"
argument_list|,
literal|1
argument_list|,
name|csk
argument_list|,
sizeof|sizeof
argument_list|(
name|csk
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: CSK"
argument_list|,
name|csk
argument_list|,
sizeof|sizeof
argument_list|(
name|csk
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|key
argument_list|,
name|csk
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Derived key"
argument_list|,
name|key
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
block|}
else|else
name|os_memcpy
argument_list|(
name|key
argument_list|,
name|data
operator|->
name|key_data
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_function
name|int
name|eap_peer_peap_register
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|eap_method
modifier|*
name|eap
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|eap
operator|=
name|eap_peer_method_alloc
argument_list|(
name|EAP_PEER_METHOD_INTERFACE_VERSION
argument_list|,
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
literal|"PEAP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|eap
operator|->
name|init
operator|=
name|eap_peap_init
expr_stmt|;
name|eap
operator|->
name|deinit
operator|=
name|eap_peap_deinit
expr_stmt|;
name|eap
operator|->
name|process
operator|=
name|eap_peap_process
expr_stmt|;
name|eap
operator|->
name|isKeyAvailable
operator|=
name|eap_peap_isKeyAvailable
expr_stmt|;
name|eap
operator|->
name|getKey
operator|=
name|eap_peap_getKey
expr_stmt|;
name|eap
operator|->
name|get_status
operator|=
name|eap_peap_get_status
expr_stmt|;
name|eap
operator|->
name|has_reauth_data
operator|=
name|eap_peap_has_reauth_data
expr_stmt|;
name|eap
operator|->
name|deinit_for_reauth
operator|=
name|eap_peap_deinit_for_reauth
expr_stmt|;
name|eap
operator|->
name|init_for_reauth
operator|=
name|eap_peap_init_for_reauth
expr_stmt|;
name|ret
operator|=
name|eap_peer_method_register
argument_list|(
name|eap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|eap_peer_method_free
argument_list|(
name|eap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

