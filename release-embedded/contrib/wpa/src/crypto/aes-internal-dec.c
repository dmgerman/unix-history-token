begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * AES (Rijndael) cipher - decrypt  *  * Modifications to public domain implementation:  * - cleanup  * - use C pre-processor to make it easier to change S table access  * - added option (AES_SMALL_TABLES) for reducing code size by about 8 kB at  *   cost of reduced throughput (quite small difference on Pentium 4,  *   10-25% when using -O1 or -O2 optimization)  *  * Copyright (c) 2003-2012, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_include
include|#
directive|include
file|"aes_i.h"
end_include

begin_comment
comment|/**  * Expand the cipher key into the decryption key schedule.  *  * @return	the number of rounds for the given cipher key size.  */
end_comment

begin_function
specifier|static
name|int
name|rijndaelKeySetupDec
parameter_list|(
name|u32
name|rk
index|[]
parameter_list|,
specifier|const
name|u8
name|cipherKey
index|[]
parameter_list|,
name|int
name|keyBits
parameter_list|)
block|{
name|int
name|Nr
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u32
name|temp
decl_stmt|;
comment|/* expand the cipher key: */
name|Nr
operator|=
name|rijndaelKeySetupEnc
argument_list|(
name|rk
argument_list|,
name|cipherKey
argument_list|,
name|keyBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nr
operator|<
literal|0
condition|)
return|return
name|Nr
return|;
comment|/* invert the order of the round keys: */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|4
operator|*
name|Nr
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|+=
literal|4
operator|,
name|j
operator|-=
literal|4
control|)
block|{
name|temp
operator|=
name|rk
index|[
name|i
index|]
expr_stmt|;
name|rk
index|[
name|i
index|]
operator|=
name|rk
index|[
name|j
index|]
expr_stmt|;
name|rk
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|rk
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|rk
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|rk
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|rk
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|rk
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|rk
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|rk
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|rk
index|[
name|j
operator|+
literal|2
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|rk
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|rk
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|rk
index|[
name|j
operator|+
literal|3
index|]
expr_stmt|;
name|rk
index|[
name|j
operator|+
literal|3
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* apply the inverse MixColumn transform to all round keys but the 	 * first and the last: */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|Nr
condition|;
name|i
operator|++
control|)
block|{
name|rk
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|rk
index|[
name|j
index|]
operator|=
name|TD0_
argument_list|(
name|TE4
argument_list|(
operator|(
name|rk
index|[
name|j
index|]
operator|>>
literal|24
operator|)
argument_list|)
argument_list|)
operator|^
name|TD1_
argument_list|(
name|TE4
argument_list|(
operator|(
name|rk
index|[
name|j
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
operator|^
name|TD2_
argument_list|(
name|TE4
argument_list|(
operator|(
name|rk
index|[
name|j
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
operator|^
name|TD3_
argument_list|(
name|TE4
argument_list|(
operator|(
name|rk
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Nr
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|aes_decrypt_init
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u32
modifier|*
name|rk
decl_stmt|;
name|int
name|res
decl_stmt|;
name|rk
operator|=
name|os_malloc
argument_list|(
name|AES_PRIV_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rk
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|res
operator|=
name|rijndaelKeySetupDec
argument_list|(
name|rk
argument_list|,
name|key
argument_list|,
name|len
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|rk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rk
index|[
name|AES_PRIV_NR_POS
index|]
operator|=
name|res
expr_stmt|;
return|return
name|rk
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rijndaelDecrypt
parameter_list|(
specifier|const
name|u32
name|rk
index|[
comment|/*44*/
index|]
parameter_list|,
name|int
name|Nr
parameter_list|,
specifier|const
name|u8
name|ct
index|[
literal|16
index|]
parameter_list|,
name|u8
name|pt
index|[
literal|16
index|]
parameter_list|)
block|{
name|u32
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
ifndef|#
directive|ifndef
name|FULL_UNROLL
name|int
name|r
decl_stmt|;
endif|#
directive|endif
comment|/* ?FULL_UNROLL */
comment|/* 	 * map byte array block to cipher state 	 * and add initial round key: 	 */
name|s0
operator|=
name|GETU32
argument_list|(
name|ct
argument_list|)
operator|^
name|rk
index|[
literal|0
index|]
expr_stmt|;
name|s1
operator|=
name|GETU32
argument_list|(
name|ct
operator|+
literal|4
argument_list|)
operator|^
name|rk
index|[
literal|1
index|]
expr_stmt|;
name|s2
operator|=
name|GETU32
argument_list|(
name|ct
operator|+
literal|8
argument_list|)
operator|^
name|rk
index|[
literal|2
index|]
expr_stmt|;
name|s3
operator|=
name|GETU32
argument_list|(
name|ct
operator|+
literal|12
argument_list|)
operator|^
name|rk
index|[
literal|3
index|]
expr_stmt|;
define|#
directive|define
name|ROUND
parameter_list|(
name|i
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
define|\
value|d##0 = TD0(s##0) ^ TD1(s##3) ^ TD2(s##2) ^ TD3(s##1) ^ rk[4 * i]; \ d##1 = TD0(s##1) ^ TD1(s##0) ^ TD2(s##3) ^ TD3(s##2) ^ rk[4 * i + 1]; \ d##2 = TD0(s##2) ^ TD1(s##1) ^ TD2(s##0) ^ TD3(s##3) ^ rk[4 * i + 2]; \ d##3 = TD0(s##3) ^ TD1(s##2) ^ TD2(s##1) ^ TD3(s##0) ^ rk[4 * i + 3]
ifdef|#
directive|ifdef
name|FULL_UNROLL
name|ROUND
argument_list|(
literal|1
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|3
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|4
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|5
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|6
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|7
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|8
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|9
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nr
operator|>
literal|10
condition|)
block|{
name|ROUND
argument_list|(
literal|10
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|11
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nr
operator|>
literal|12
condition|)
block|{
name|ROUND
argument_list|(
literal|12
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|13
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|rk
operator|+=
name|Nr
operator|<<
literal|2
expr_stmt|;
else|#
directive|else
comment|/* !FULL_UNROLL */
comment|/* Nr - 1 full rounds: */
name|r
operator|=
name|Nr
operator|>>
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ROUND
argument_list|(
literal|1
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rk
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|--
name|r
operator|==
literal|0
condition|)
break|break;
name|ROUND
argument_list|(
literal|0
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ?FULL_UNROLL */
undef|#
directive|undef
name|ROUND
comment|/* 	 * apply last round and 	 * map cipher state to byte array block: 	 */
name|s0
operator|=
name|TD41
argument_list|(
name|t0
argument_list|)
operator|^
name|TD42
argument_list|(
name|t3
argument_list|)
operator|^
name|TD43
argument_list|(
name|t2
argument_list|)
operator|^
name|TD44
argument_list|(
name|t1
argument_list|)
operator|^
name|rk
index|[
literal|0
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|pt
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|s1
operator|=
name|TD41
argument_list|(
name|t1
argument_list|)
operator|^
name|TD42
argument_list|(
name|t0
argument_list|)
operator|^
name|TD43
argument_list|(
name|t3
argument_list|)
operator|^
name|TD44
argument_list|(
name|t2
argument_list|)
operator|^
name|rk
index|[
literal|1
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|pt
operator|+
literal|4
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|TD41
argument_list|(
name|t2
argument_list|)
operator|^
name|TD42
argument_list|(
name|t1
argument_list|)
operator|^
name|TD43
argument_list|(
name|t0
argument_list|)
operator|^
name|TD44
argument_list|(
name|t3
argument_list|)
operator|^
name|rk
index|[
literal|2
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|pt
operator|+
literal|8
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|s3
operator|=
name|TD41
argument_list|(
name|t3
argument_list|)
operator|^
name|TD42
argument_list|(
name|t2
argument_list|)
operator|^
name|TD43
argument_list|(
name|t1
argument_list|)
operator|^
name|TD44
argument_list|(
name|t0
argument_list|)
operator|^
name|rk
index|[
literal|3
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|pt
operator|+
literal|12
argument_list|,
name|s3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aes_decrypt
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|crypt
parameter_list|,
name|u8
modifier|*
name|plain
parameter_list|)
block|{
name|u32
modifier|*
name|rk
init|=
name|ctx
decl_stmt|;
name|rijndaelDecrypt
argument_list|(
name|ctx
argument_list|,
name|rk
index|[
name|AES_PRIV_NR_POS
index|]
argument_list|,
name|crypt
argument_list|,
name|plain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aes_decrypt_deinit
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|os_memset
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
name|AES_PRIV_SIZE
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

