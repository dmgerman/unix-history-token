begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for GNU DIFF.     Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1998, 2001, 2002,    2004 Free Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|<dirname.h>
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<quotesys.h>
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_decl_stmt
name|char
specifier|const
name|pr_program
index|[]
init|=
name|PR_PROGRAM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue up one-line messages to be printed at the end,    when -l is specified.  Each message is recorded with a `struct msg'.  */
end_comment

begin_struct
struct|struct
name|msg
block|{
name|struct
name|msg
modifier|*
name|next
decl_stmt|;
name|char
name|args
index|[
literal|1
index|]
decl_stmt|;
comment|/* Format + 4 args, each '\0' terminated, concatenated.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Head of the chain of queues messages.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
name|msg_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tail of the chain of queues messages.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
modifier|*
name|msg_chain_end
init|=
operator|&
name|msg_chain
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Use when a system call returns non-zero status.    NAME should normally be the file name.  */
end_comment

begin_function
name|void
name|perror_with_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use when a system call returns non-zero status and that is fatal.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|print_message_queue
argument_list|()
expr_stmt|;
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|e
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message containing MSGID, then exit.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|msgid
parameter_list|)
block|{
name|print_message_queue
argument_list|()
expr_stmt|;
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like printf, except if -l in effect then save the message and print later.    This is used for things like "Only in ...".  */
end_comment

begin_function
name|void
name|message
parameter_list|(
name|char
specifier|const
modifier|*
name|format_msgid
parameter_list|,
name|char
specifier|const
modifier|*
name|arg1
parameter_list|,
name|char
specifier|const
modifier|*
name|arg2
parameter_list|)
block|{
name|message5
argument_list|(
name|format_msgid
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|message5
parameter_list|(
name|char
specifier|const
modifier|*
name|format_msgid
parameter_list|,
name|char
specifier|const
modifier|*
name|arg1
parameter_list|,
name|char
specifier|const
modifier|*
name|arg2
parameter_list|,
name|char
specifier|const
modifier|*
name|arg3
parameter_list|,
name|char
specifier|const
modifier|*
name|arg4
parameter_list|)
block|{
if|if
condition|(
name|paginate
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|size
index|[
literal|5
index|]
decl_stmt|;
name|size_t
name|total_size
init|=
name|offsetof
argument_list|(
expr|struct
name|msg
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|struct
name|msg
modifier|*
name|new
decl_stmt|;
name|arg
index|[
literal|0
index|]
operator|=
name|format_msgid
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg3
condition|?
name|arg3
else|:
literal|""
expr_stmt|;
name|arg
index|[
literal|4
index|]
operator|=
name|arg4
condition|?
name|arg4
else|:
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|total_size
operator|+=
name|size
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|arg
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|new
operator|->
name|args
init|;
name|i
operator|<
literal|5
condition|;
name|p
operator|+=
name|size
index|[
name|i
operator|++
index|]
control|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|arg
index|[
name|i
index|]
argument_list|,
name|size
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|msg_chain_end
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|msg_chain_end
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sdiff_merge_assist
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
name|format_msgid
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output all the messages that were saved up by calls to `message'.  */
end_comment

begin_function
name|void
name|print_message_queue
parameter_list|(
name|void
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|arg
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|msg
modifier|*
name|m
init|=
name|msg_chain
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|struct
name|msg
modifier|*
name|next
init|=
name|m
operator|->
name|next
decl_stmt|;
name|arg
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|args
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|arg
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|arg
index|[
name|i
index|]
operator|+
name|strlen
argument_list|(
name|arg
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call before outputting the results of comparing files NAME0 and NAME1    to set up OUTFILE, the stdio stream for the output to go to.     Usually, OUTFILE is just stdout.  But when -l was specified    we fork off a `pr' and make OUTFILE a pipe to it.    `pr' then outputs to our stdout.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|current_name0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|current_name1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|currently_recursive
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setup_output
parameter_list|(
name|char
specifier|const
modifier|*
name|name0
parameter_list|,
name|char
specifier|const
modifier|*
name|name1
parameter_list|,
name|bool
name|recursive
parameter_list|)
block|{
name|current_name0
operator|=
name|name0
expr_stmt|;
name|current_name1
operator|=
name|name1
expr_stmt|;
name|currently_recursive
operator|=
name|recursive
expr_stmt|;
name|outfile
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
end_if

begin_decl_stmt
specifier|static
name|pid_t
name|pr_pid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|begin_output
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|outfile
operator|!=
literal|0
condition|)
return|return;
comment|/* Construct the header of this piece of diff.  */
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_name0
argument_list|)
operator|+
name|strlen
argument_list|(
name|current_name1
argument_list|)
operator|+
name|strlen
argument_list|(
name|switch_string
argument_list|)
operator|+
literal|7
argument_list|)
expr_stmt|;
comment|/* POSIX 1003.1-2001 specifies this format.  But there are some bugs in      the standard: it says that we must print only the last component      of the pathnames, and it requires two spaces after "diff" if      there are no options.  These requirements are silly and do not      match historical practice.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"diff%s %s %s"
argument_list|,
name|switch_string
argument_list|,
name|current_name0
argument_list|,
name|current_name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|paginate
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|_
argument_list|(
literal|"write failed"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make OUTFILE a pipe to a subsidiary `pr'.  */
block|{
if|#
directive|if
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipes
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|pr_pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pr_pid
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr_pid
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipes
index|[
literal|0
index|]
operator|!=
name|STDIN_FILENO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|execl
argument_list|(
name|pr_program
argument_list|,
name|pr_program
argument_list|,
literal|"-h"
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|errno
operator|==
name|ENOENT
condition|?
literal|127
else|:
literal|126
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fdopen
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
name|pfatal_with_name
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|char
modifier|*
name|command
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
name|pr_program
operator|-
literal|1
operator|+
literal|7
operator|+
name|quote_system_arg
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s -f -h "
argument_list|,
name|pr_program
argument_list|)
expr_stmt|;
name|p
operator|=
name|command
operator|+
sizeof|sizeof
name|pr_program
operator|-
literal|1
operator|+
literal|7
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|outfile
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
name|pfatal_with_name
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* If -l was not specified, output the diff straight to `stdout'.  */
name|outfile
operator|=
name|stdout
expr_stmt|;
comment|/* If handling multiple files (because scanning a directory), 	 print which files the following output is about.  */
if|if
condition|(
name|currently_recursive
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* A special header is needed at the beginning of context output.  */
switch|switch
condition|(
name|output_style
condition|)
block|{
case|case
name|OUTPUT_CONTEXT
case|:
name|print_context_header
argument_list|(
name|files
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_UNIFIED
case|:
name|print_context_header
argument_list|(
name|files
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Call after the end of output of diffs for one file.    Close OUTFILE and get rid of the `pr' subfork.  */
end_comment

begin_function
name|void
name|finish_output
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|outfile
operator|!=
literal|0
operator|&&
name|outfile
operator|!=
name|stdout
condition|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|wstatus
decl_stmt|;
name|int
name|werrno
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|outfile
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"write failed"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
operator|)
name|wstatus
operator|=
name|pclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|wstatus
operator|==
operator|-
literal|1
condition|)
name|werrno
operator|=
name|errno
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fclose
argument_list|(
name|outfile
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|_
argument_list|(
literal|"write failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pr_pid
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
operator|(
operator|!
name|werrno
operator|&&
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
condition|?
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
else|:
name|INT_MAX
operator|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|werrno
argument_list|,
name|_
argument_list|(
name|status
operator|==
literal|126
condition|?
literal|"subsidiary program `%s' could not be invoked"
else|:
name|status
operator|==
literal|127
condition|?
literal|"subsidiary program `%s' not found"
else|:
name|status
operator|==
name|INT_MAX
condition|?
literal|"subsidiary program `%s' failed"
else|:
literal|"subsidiary program `%s' failed (exit status %d)"
argument_list|)
argument_list|,
name|pr_program
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|outfile
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two lines (typically one from each input file)    according to the command line options.    For efficiency, this is invoked only when the lines do not match exactly    but an option like -i might cause us to ignore the difference.    Return nonzero if the lines differ.  */
end_comment

begin_function
name|bool
name|lines_differ
parameter_list|(
name|char
specifier|const
modifier|*
name|s1
parameter_list|,
name|char
specifier|const
modifier|*
name|s2
parameter_list|)
block|{
specifier|register
name|char
specifier|const
modifier|*
name|t1
init|=
name|s1
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|t2
init|=
name|s2
decl_stmt|;
name|size_t
name|column
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|unsigned
name|char
name|c1
init|=
operator|*
name|t1
operator|++
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c2
init|=
operator|*
name|t2
operator|++
decl_stmt|;
comment|/* Test for exact char equality first, since it's a common case.  */
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
block|{
switch|switch
condition|(
name|ignore_white_space
condition|)
block|{
case|case
name|IGNORE_ALL_SPACE
case|:
comment|/* For -w, just skip past any white space.  */
while|while
condition|(
name|isspace
argument_list|(
name|c1
argument_list|)
operator|&&
name|c1
operator|!=
literal|'\n'
condition|)
name|c1
operator|=
operator|*
name|t1
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|c2
argument_list|)
operator|&&
name|c2
operator|!=
literal|'\n'
condition|)
name|c2
operator|=
operator|*
name|t2
operator|++
expr_stmt|;
break|break;
case|case
name|IGNORE_SPACE_CHANGE
case|:
comment|/* For -b, advance past any sequence of white space in 		 line 1 and consider it just one space, or nothing at 		 all if it is at the end of the line.  */
if|if
condition|(
name|isspace
argument_list|(
name|c1
argument_list|)
condition|)
block|{
while|while
condition|(
name|c1
operator|!=
literal|'\n'
condition|)
block|{
name|c1
operator|=
operator|*
name|t1
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c1
argument_list|)
condition|)
block|{
operator|--
name|t1
expr_stmt|;
name|c1
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Likewise for line 2.  */
if|if
condition|(
name|isspace
argument_list|(
name|c2
argument_list|)
condition|)
block|{
while|while
condition|(
name|c2
operator|!=
literal|'\n'
condition|)
block|{
name|c2
operator|=
operator|*
name|t2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c2
argument_list|)
condition|)
block|{
operator|--
name|t2
expr_stmt|;
name|c2
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
block|{
comment|/* If we went too far when doing the simple test 		     for equality, go back to the first non-white-space 		     character in both sides and try again.  */
if|if
condition|(
name|c2
operator|==
literal|' '
operator|&&
name|c1
operator|!=
literal|'\n'
operator|&&
name|s1
operator|+
literal|1
operator|<
name|t1
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|t1
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
operator|--
name|t1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c1
operator|==
literal|' '
operator|&&
name|c2
operator|!=
literal|'\n'
operator|&&
name|s2
operator|+
literal|1
operator|<
name|t2
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|t2
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
operator|--
name|t2
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
name|IGNORE_TAB_EXPANSION
case|:
if|if
condition|(
operator|(
name|c1
operator|==
literal|' '
operator|&&
name|c2
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c1
operator|==
literal|'\t'
operator|&&
name|c2
operator|==
literal|' '
operator|)
condition|)
block|{
name|size_t
name|column2
init|=
name|column
decl_stmt|;
for|for
control|(
init|;
condition|;
name|c1
operator|=
operator|*
name|t1
operator|++
control|)
block|{
if|if
condition|(
name|c1
operator|==
literal|' '
condition|)
name|column
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'\t'
condition|)
name|column
operator|+=
name|tabsize
operator|-
name|column
operator|%
name|tabsize
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
init|;
condition|;
name|c2
operator|=
operator|*
name|t2
operator|++
control|)
block|{
if|if
condition|(
name|c2
operator|==
literal|' '
condition|)
name|column2
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'\t'
condition|)
name|column2
operator|+=
name|tabsize
operator|-
name|column2
operator|%
name|tabsize
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|column
operator|!=
name|column2
condition|)
return|return
name|true
return|;
block|}
break|break;
case|case
name|IGNORE_NO_WHITE_SPACE
case|:
break|break;
block|}
comment|/* Lowercase all letters if -i is specified.  */
if|if
condition|(
name|ignore_case
condition|)
block|{
name|c1
operator|=
name|tolower
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
if|if
condition|(
name|c1
operator|==
literal|'\n'
condition|)
return|return
name|false
return|;
name|column
operator|+=
name|c1
operator|==
literal|'\t'
condition|?
name|tabsize
operator|-
name|column
operator|%
name|tabsize
else|:
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the consecutive changes at the start of the script START.    Return the last link before the first gap.  */
end_comment

begin_function
name|struct
name|change
modifier|*
name|find_change
parameter_list|(
name|struct
name|change
modifier|*
name|start
parameter_list|)
block|{
return|return
name|start
return|;
block|}
end_function

begin_function
name|struct
name|change
modifier|*
name|find_reverse_change
parameter_list|(
name|struct
name|change
modifier|*
name|start
parameter_list|)
block|{
return|return
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide SCRIPT into pieces by calling HUNKFUN and    print each piece with PRINTFUN.    Both functions take one arg, an edit script.     HUNKFUN is called with the tail of the script    and returns the last link that belongs together with the start    of the tail.     PRINTFUN takes a subscript which belongs together (with a null    link at the end) and prints it.  */
end_comment

begin_decl_stmt
name|void
name|print_script
argument_list|(
expr|struct
name|change
operator|*
name|script
argument_list|,
expr|struct
name|change
operator|*
call|(
modifier|*
name|hunkfun
call|)
argument_list|(
expr|struct
name|change
operator|*
argument_list|)
argument_list|,
name|void
argument_list|(
operator|*
name|printfun
argument_list|)
argument_list|(
expr|struct
name|change
operator|*
argument_list|)
argument_list|)
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|script
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|change
modifier|*
name|this
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* Find a set of changes that belong together.  */
name|this
operator|=
name|next
expr_stmt|;
name|end
operator|=
call|(
modifier|*
name|hunkfun
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Disconnect them from the rest of the changes, 	 making them a hunk, and remember the rest for next iteration.  */
name|next
operator|=
name|end
operator|->
name|link
expr_stmt|;
name|end
operator|->
name|link
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug_script
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Print this hunk.  */
call|(
modifier|*
name|printfun
call|)
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|/* Reconnect the script so it will all be freed properly.  */
name|end
operator|->
name|link
operator|=
name|next
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print the text of a single line LINE,    flagging it with the characters in LINE_FLAG (which say whether    the line is inserted, deleted, changed, etc.).  */
end_comment

begin_function
name|void
name|print_1_line
parameter_list|(
name|char
specifier|const
modifier|*
name|line_flag
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|line
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|base
init|=
name|line
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|limit
init|=
name|line
index|[
literal|1
index|]
decl_stmt|;
comment|/* Help the compiler.  */
name|FILE
modifier|*
name|out
init|=
name|outfile
decl_stmt|;
comment|/* Help the compiler some more.  */
name|char
specifier|const
modifier|*
name|flag_format
init|=
literal|0
decl_stmt|;
comment|/* If -T was specified, use a Tab between the line-flag and the text.      Otherwise use a Space (as Unix diff does).      Print neither space nor tab if line-flags are empty.  */
if|if
condition|(
name|line_flag
operator|&&
operator|*
name|line_flag
condition|)
block|{
name|flag_format
operator|=
name|initial_tab
condition|?
literal|"%s\t"
else|:
literal|"%s "
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
name|flag_format
argument_list|,
name|line_flag
argument_list|)
expr_stmt|;
block|}
name|output_1_line
argument_list|(
name|base
argument_list|,
name|limit
argument_list|,
name|flag_format
argument_list|,
name|line_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|line_flag
operator|||
name|line_flag
index|[
literal|0
index|]
operator|)
operator|&&
name|limit
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\\ %s\n"
argument_list|,
name|_
argument_list|(
literal|"No newline at end of file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line from BASE up to LIMIT.    With -t, expand white space characters to spaces, and if FLAG_FORMAT    is nonzero, output it with argument LINE_FLAG after every    internal carriage return, so that tab stops continue to line up.  */
end_comment

begin_function
name|void
name|output_1_line
parameter_list|(
name|char
specifier|const
modifier|*
name|base
parameter_list|,
name|char
specifier|const
modifier|*
name|limit
parameter_list|,
name|char
specifier|const
modifier|*
name|flag_format
parameter_list|,
name|char
specifier|const
modifier|*
name|line_flag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expand_tabs
condition|)
name|fwrite
argument_list|(
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|limit
operator|-
name|base
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|FILE
modifier|*
name|out
init|=
name|outfile
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|t
init|=
name|base
decl_stmt|;
specifier|register
name|size_t
name|column
init|=
literal|0
decl_stmt|;
name|size_t
name|tab_size
init|=
name|tabsize
decl_stmt|;
while|while
condition|(
name|t
operator|<
name|limit
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|t
operator|++
operator|)
condition|)
block|{
case|case
literal|'\t'
case|:
block|{
name|size_t
name|spaces
init|=
name|tab_size
operator|-
name|column
operator|%
name|tab_size
decl_stmt|;
name|column
operator|+=
name|spaces
expr_stmt|;
do|do
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|spaces
condition|)
do|;
block|}
break|break;
case|case
literal|'\r'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_format
operator|&&
name|t
operator|<
name|limit
operator|&&
operator|*
name|t
operator|!=
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
name|flag_format
argument_list|,
name|line_flag
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|column
operator|==
literal|0
condition|)
continue|continue;
name|column
operator|--
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
default|default:
name|column
operator|+=
name|isprint
argument_list|(
name|c
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|char
specifier|const
name|change_letter
index|[]
init|=
block|{
literal|0
block|,
literal|'d'
block|,
literal|'a'
block|,
literal|'c'
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Translate an internal line number (an index into diff's table of lines)    into an actual line number in the input file.    The internal line number is I.  FILE points to the data on the file.     Internal line numbers count from 0 starting after the prefix.    Actual line numbers count from 1 within the entire file.  */
end_comment

begin_function
name|lin
name|translate_line_number
parameter_list|(
name|struct
name|file_data
specifier|const
modifier|*
name|file
parameter_list|,
name|lin
name|i
parameter_list|)
block|{
return|return
name|i
operator|+
name|file
operator|->
name|prefix_lines
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Translate a line number range.  This is always done for printing,    so for convenience translate to long int rather than lin, so that the    caller can use printf with "%ld" without casting.  */
end_comment

begin_function
name|void
name|translate_range
parameter_list|(
name|struct
name|file_data
specifier|const
modifier|*
name|file
parameter_list|,
name|lin
name|a
parameter_list|,
name|lin
name|b
parameter_list|,
name|long
name|int
modifier|*
name|aptr
parameter_list|,
name|long
name|int
modifier|*
name|bptr
parameter_list|)
block|{
operator|*
name|aptr
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|a
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|bptr
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|b
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a pair of line numbers with SEPCHAR, translated for file FILE.    If the two numbers are identical, print just one number.     Args A and B are internal line numbers.    We print the translated (real) line numbers.  */
end_comment

begin_function
name|void
name|print_number_range
parameter_list|(
name|char
name|sepchar
parameter_list|,
name|struct
name|file_data
modifier|*
name|file
parameter_list|,
name|lin
name|a
parameter_list|,
name|lin
name|b
parameter_list|)
block|{
name|long
name|int
name|trans_a
decl_stmt|,
name|trans_b
decl_stmt|;
name|translate_range
argument_list|(
name|file
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|trans_a
argument_list|,
operator|&
name|trans_b
argument_list|)
expr_stmt|;
comment|/* Note: we can have B< A in the case of a range of no lines.      In this case, we should print the line number before the range,      which is B.  */
if|if
condition|(
name|trans_b
operator|>
name|trans_a
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld%c%ld"
argument_list|,
name|trans_a
argument_list|,
name|sepchar
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld"
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a hunk of edit script and report the range of lines in each file    that it applies to.  HUNK is the start of the hunk, which is a chain    of `struct change'.  The first and last line numbers of file 0 are stored in    *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.    Note that these are internal line numbers that count from 0.     If no lines from file 0 are deleted, then FIRST0 is LAST0+1.     Return UNCHANGED if only ignorable lines are inserted or deleted,    OLD if lines of file 0 are deleted,    NEW if lines of file 1 are inserted,    and CHANGED if both kinds of changes are found. */
end_comment

begin_function
name|enum
name|changes
name|analyze_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|hunk
parameter_list|,
name|lin
modifier|*
name|first0
parameter_list|,
name|lin
modifier|*
name|last0
parameter_list|,
name|lin
modifier|*
name|first1
parameter_list|,
name|lin
modifier|*
name|last1
parameter_list|)
block|{
name|struct
name|change
modifier|*
name|next
decl_stmt|;
name|lin
name|l0
decl_stmt|,
name|l1
decl_stmt|;
name|lin
name|show_from
decl_stmt|,
name|show_to
decl_stmt|;
name|lin
name|i
decl_stmt|;
name|bool
name|trivial
init|=
name|ignore_blank_lines
operator|||
name|ignore_regexp
operator|.
name|fastmap
decl_stmt|;
name|size_t
name|trivial_length
init|=
name|ignore_blank_lines
operator|-
literal|1
decl_stmt|;
comment|/* If 0, ignore zero-length lines;        if SIZE_MAX, do not ignore lines just because of their length.  */
name|bool
name|skip_leading_white_space
init|=
operator|(
name|ignore_blank_lines
operator|&&
name|IGNORE_SPACE_CHANGE
operator|<=
name|ignore_white_space
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|linbuf0
init|=
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
decl_stmt|;
comment|/* Help the compiler.  */
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|linbuf1
init|=
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
decl_stmt|;
name|show_from
operator|=
name|show_to
operator|=
literal|0
expr_stmt|;
operator|*
name|first0
operator|=
name|hunk
operator|->
name|line0
expr_stmt|;
operator|*
name|first1
operator|=
name|hunk
operator|->
name|line1
expr_stmt|;
name|next
operator|=
name|hunk
expr_stmt|;
do|do
block|{
name|l0
operator|=
name|next
operator|->
name|line0
operator|+
name|next
operator|->
name|deleted
operator|-
literal|1
expr_stmt|;
name|l1
operator|=
name|next
operator|->
name|line1
operator|+
name|next
operator|->
name|inserted
operator|-
literal|1
expr_stmt|;
name|show_from
operator|+=
name|next
operator|->
name|deleted
expr_stmt|;
name|show_to
operator|+=
name|next
operator|->
name|inserted
expr_stmt|;
for|for
control|(
name|i
operator|=
name|next
operator|->
name|line0
init|;
name|i
operator|<=
name|l0
operator|&&
name|trivial
condition|;
name|i
operator|++
control|)
block|{
name|char
specifier|const
modifier|*
name|line
init|=
name|linbuf0
index|[
name|i
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|newline
init|=
name|linbuf0
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|1
decl_stmt|;
name|size_t
name|len
init|=
name|newline
operator|-
name|line
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
name|line
decl_stmt|;
if|if
condition|(
name|skip_leading_white_space
condition|)
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|newline
operator|-
name|p
operator|!=
name|trivial_length
operator|&&
operator|(
operator|!
name|ignore_regexp
operator|.
name|fastmap
operator|||
name|re_search
argument_list|(
operator|&
name|ignore_regexp
argument_list|,
name|line
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|trivial
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|next
operator|->
name|line1
init|;
name|i
operator|<=
name|l1
operator|&&
name|trivial
condition|;
name|i
operator|++
control|)
block|{
name|char
specifier|const
modifier|*
name|line
init|=
name|linbuf1
index|[
name|i
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|newline
init|=
name|linbuf1
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|1
decl_stmt|;
name|size_t
name|len
init|=
name|newline
operator|-
name|line
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
name|line
decl_stmt|;
if|if
condition|(
name|skip_leading_white_space
condition|)
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|newline
operator|-
name|p
operator|!=
name|trivial_length
operator|&&
operator|(
operator|!
name|ignore_regexp
operator|.
name|fastmap
operator|||
name|re_search
argument_list|(
operator|&
name|ignore_regexp
argument_list|,
name|line
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|trivial
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|next
operator|=
name|next
operator|->
name|link
operator|)
operator|!=
literal|0
condition|)
do|;
operator|*
name|last0
operator|=
name|l0
expr_stmt|;
operator|*
name|last1
operator|=
name|l1
expr_stmt|;
comment|/* If all inserted or deleted lines are ignorable,      tell the caller to ignore this hunk.  */
if|if
condition|(
name|trivial
condition|)
return|return
name|UNCHANGED
return|;
return|return
operator|(
name|show_from
condition|?
name|OLD
else|:
name|UNCHANGED
operator|)
operator||
operator|(
name|show_to
condition|?
name|NEW
else|:
name|UNCHANGED
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Concatenate three strings, returning a newly malloc'd string.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|char
specifier|const
modifier|*
name|s1
parameter_list|,
name|char
specifier|const
modifier|*
name|s2
parameter_list|,
name|char
specifier|const
modifier|*
name|s3
parameter_list|)
block|{
name|char
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Yield a new block of SIZE bytes, initialized to zero.  */
end_comment

begin_function
name|void
modifier|*
name|zalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Yield the newly malloc'd pathname    of the file in DIR whose filename is FILE.  */
end_comment

begin_function
name|char
modifier|*
name|dir_file_pathname
parameter_list|(
name|char
specifier|const
modifier|*
name|dir
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|base
init|=
name|base_name
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|bool
name|omit_slash
init|=
operator|!
operator|*
name|base
operator|||
name|base
index|[
name|strlen
argument_list|(
name|base
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
decl_stmt|;
return|return
name|concat
argument_list|(
name|dir
argument_list|,
literal|"/"
operator|+
name|omit_slash
argument_list|,
name|file
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|debug_script
parameter_list|(
name|struct
name|change
modifier|*
name|sp
parameter_list|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|link
control|)
block|{
name|long
name|int
name|line0
init|=
name|sp
operator|->
name|line0
decl_stmt|;
name|long
name|int
name|line1
init|=
name|sp
operator|->
name|line1
decl_stmt|;
name|long
name|int
name|deleted
init|=
name|sp
operator|->
name|deleted
decl_stmt|;
name|long
name|int
name|inserted
init|=
name|sp
operator|->
name|inserted
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3ld %3ld delete %ld insert %ld\n"
argument_list|,
name|line0
argument_list|,
name|line1
argument_list|,
name|deleted
argument_list|,
name|inserted
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

