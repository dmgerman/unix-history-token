begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Mudflap: narrow-pointer bounds-checking by tree rewriting.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Frank Ch. Eigler<fche@redhat.com>    and Graydon Hoare<graydon@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SOCKLEN_T
end_ifndef

begin_define
define|#
directive|define
name|socklen_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These attempt to coax various unix flavours to declare all our    needed tidbits in the system headers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some BSDs break<sys/socket.h> if this is defined. */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_define
define|#
directive|define
name|_XOPEN_SOURCE
end_define

begin_define
define|#
directive|define
name|_BSD_TYPES
end_define

begin_define
define|#
directive|define
name|__EXTENSIONS__
end_define

begin_define
define|#
directive|define
name|_ALL_SOURCE
end_define

begin_define
define|#
directive|define
name|_LARGE_FILE_API
end_define

begin_define
define|#
directive|define
name|_LARGEFILE64_SOURCE
end_define

begin_define
define|#
directive|define
name|_XOPEN_SOURCE_EXTENDED
value|1
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLFCN_H
end_ifdef

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DIRENT_H
end_ifdef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IPC_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SEM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SHM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PWD_H
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GRP_H
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MNTENT_H
end_ifdef

begin_include
include|#
directive|include
file|<mntent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mf-runtime.h"
end_include

begin_include
include|#
directive|include
file|"mf-impl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MUDFLAP
end_ifdef

begin_error
error|#
directive|error
literal|"Do not compile this file with -fmudflap!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A bunch of independent stdlib/unistd hook functions, all    intercepted by mf-runtime.h macros.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRNLEN
end_ifndef

begin_function
specifier|static
specifier|inline
name|size_t
function|(
name|strnlen
function|)
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
name|n
operator|&&
operator|*
name|s
condition|;
operator|++
name|s
operator|,
operator|--
name|n
control|)
empty_stmt|;
return|return
operator|(
name|s
operator|-
name|str
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* str*,mem*,b* */
end_comment

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|memcpy
argument_list|,
argument|void *dest
argument_list|,
argument|const void *src
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|src
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memcpy source"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dest
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"memcpy dest"
argument_list|)
expr_stmt|;
return|return
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|memmove
argument_list|,
argument|void *dest
argument_list|,
argument|const void *src
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|src
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memmove src"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dest
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"memmove dest"
argument_list|)
expr_stmt|;
return|return
name|memmove
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|memset
argument_list|,
argument|void *s
argument_list|,
argument|int c
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"memset dest"
argument_list|)
expr_stmt|;
return|return
name|memset
argument_list|(
name|s
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|memcmp
argument_list|,
argument|const void *s1
argument_list|,
argument|const void *s2
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s1
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memcmp 1st arg"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s2
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memcmp 2nd arg"
argument_list|)
expr_stmt|;
return|return
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|memchr
argument_list|,
argument|const void *s
argument_list|,
argument|int c
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memchr region"
argument_list|)
expr_stmt|;
return|return
name|memchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MEMRCHR
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|memrchr
argument_list|,
argument|const void *s
argument_list|,
argument|int c
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memrchr region"
argument_list|)
expr_stmt|;
return|return
name|memrchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strcpy
argument_list|,
argument|char *dest
argument_list|,
argument|const char *src
argument_list|)
end_macro

begin_block
block|{
comment|/* nb: just because strlen(src) == n doesn't mean (src + n) or (src + n +      1) are valid pointers. the allocated object might have size< n.      check anyways. */
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|src
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strcpy src"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dest
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"strcpy dest"
argument_list|)
expr_stmt|;
return|return
name|strcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRNCPY
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strncpy
argument_list|,
argument|char *dest
argument_list|,
argument|const char *src
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|len
init|=
name|strnlen
argument_list|(
name|src
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|src
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strncpy src"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dest
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"strncpy dest"
argument_list|)
expr_stmt|;
comment|/* nb: strNcpy */
return|return
name|strncpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strcat
argument_list|,
argument|char *dest
argument_list|,
argument|const char *src
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|dest_sz
decl_stmt|;
name|size_t
name|src_sz
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|dest_sz
operator|=
name|strlen
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|src_sz
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|src
argument_list|,
name|CLAMPADD
argument_list|(
name|src_sz
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strcat src"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dest
argument_list|,
name|CLAMPADD
argument_list|(
name|dest_sz
argument_list|,
name|CLAMPADD
argument_list|(
name|src_sz
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"strcat dest"
argument_list|)
expr_stmt|;
return|return
name|strcat
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strncat
argument_list|,
argument|char *dest
argument_list|,
argument|const char *src
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
comment|/* nb: validating the extents (s,n) might be a mistake for two reasons.    (1) the string s might be shorter than n chars, and n is just a   poor choice by the programmer. this is not a "true" error in the   sense that the call to strncat would still be ok.    (2) we could try to compensate for case (1) by calling strlen(s) and   using that as a bound for the extent to verify, but strlen might fall off   the end of a non-terminated string, leading to a false positive.    so we will call strnlen(s,n) and use that as a bound.    if strnlen returns a length beyond the end of the registered extent   associated with s, there is an error: the programmer's estimate for n is   too large _AND_ the string s is unterminated, in which case they'd be   about to touch memory they don't own while calling strncat.    this same logic applies to further uses of strnlen later down in this   file. */
name|size_t
name|src_sz
decl_stmt|;
name|size_t
name|dest_sz
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|src_sz
operator|=
name|strnlen
argument_list|(
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dest_sz
operator|=
name|strnlen
argument_list|(
name|dest
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|src
argument_list|,
name|src_sz
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strncat src"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dest
argument_list|,
operator|(
name|CLAMPADD
argument_list|(
name|dest_sz
argument_list|,
name|CLAMPADD
argument_list|(
name|src_sz
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"strncat dest"
argument_list|)
expr_stmt|;
return|return
name|strncat
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|strcmp
argument_list|,
argument|const char *s1
argument_list|,
argument|const char *s2
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|s1_sz
decl_stmt|;
name|size_t
name|s2_sz
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|s1_sz
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|s2_sz
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s1
argument_list|,
name|CLAMPADD
argument_list|(
name|s1_sz
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strcmp 1st arg"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s2
argument_list|,
name|CLAMPADD
argument_list|(
name|s2_sz
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"strcmp 2nd arg"
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|strcasecmp
argument_list|,
argument|const char *s1
argument_list|,
argument|const char *s2
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|s1_sz
decl_stmt|;
name|size_t
name|s2_sz
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|s1_sz
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|s2_sz
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s1
argument_list|,
name|CLAMPADD
argument_list|(
name|s1_sz
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strcasecmp 1st arg"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s2
argument_list|,
name|CLAMPADD
argument_list|(
name|s2_sz
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strcasecmp 2nd arg"
argument_list|)
expr_stmt|;
return|return
name|strcasecmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|strncmp
argument_list|,
argument|const char *s1
argument_list|,
argument|const char *s2
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|s1_sz
decl_stmt|;
name|size_t
name|s2_sz
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|s1_sz
operator|=
name|strnlen
argument_list|(
name|s1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s2_sz
operator|=
name|strnlen
argument_list|(
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s1
argument_list|,
name|s1_sz
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strncmp 1st arg"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s2
argument_list|,
name|s2_sz
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strncmp 2nd arg"
argument_list|)
expr_stmt|;
return|return
name|strncmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|strncasecmp
argument_list|,
argument|const char *s1
argument_list|,
argument|const char *s2
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|s1_sz
decl_stmt|;
name|size_t
name|s2_sz
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|s1_sz
operator|=
name|strnlen
argument_list|(
name|s1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s2_sz
operator|=
name|strnlen
argument_list|(
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s1
argument_list|,
name|s1_sz
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strncasecmp 1st arg"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s2
argument_list|,
name|s2_sz
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strncasecmp 2nd arg"
argument_list|)
expr_stmt|;
return|return
name|strncasecmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strdup
argument_list|,
argument|const char *s
argument_list|)
end_macro

begin_block
block|{
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t sz
argument_list|)
empty_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strdup region"
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
name|CLAMPADD
argument_list|(
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|CLAMPADD
argument_list|(
name|__mf_opts
operator|.
name|crumple_zone
argument_list|,
name|__mf_opts
operator|.
name|crumple_zone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|result
argument_list|)
condition|)
return|return
name|result
return|;
name|result
operator|+=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|result
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|__mf_register
argument_list|(
name|result
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|,
literal|"strdup region"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strndup
argument_list|,
argument|const char *s
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t sz
argument_list|)
empty_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|size_t
name|sz
init|=
name|strnlen
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|sz
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strndup region"
argument_list|)
expr_stmt|;
comment|/* nb: strNdup */
comment|/* note: strndup still adds a \0, even with the N limit! */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
name|CLAMPADD
argument_list|(
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|CLAMPADD
argument_list|(
name|__mf_opts
operator|.
name|crumple_zone
argument_list|,
name|__mf_opts
operator|.
name|crumple_zone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|result
argument_list|)
condition|)
return|return
name|result
return|;
name|result
operator|+=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|result
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|__mf_register
argument_list|(
name|result
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|,
literal|"strndup region"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strchr
argument_list|,
argument|const char *s
argument_list|,
argument|int c
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strchr region"
argument_list|)
expr_stmt|;
return|return
name|strchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strrchr
argument_list|,
argument|const char *s
argument_list|,
argument|int c
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strrchr region"
argument_list|)
expr_stmt|;
return|return
name|strrchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strstr
argument_list|,
argument|const char *haystack
argument_list|,
argument|const char *needle
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|haystack_sz
decl_stmt|;
name|size_t
name|needle_sz
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|haystack_sz
operator|=
name|strlen
argument_list|(
name|haystack
argument_list|)
expr_stmt|;
name|needle_sz
operator|=
name|strlen
argument_list|(
name|needle
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|haystack
argument_list|,
name|CLAMPADD
argument_list|(
name|haystack_sz
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strstr haystack"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|needle
argument_list|,
name|CLAMPADD
argument_list|(
name|needle_sz
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strstr needle"
argument_list|)
expr_stmt|;
return|return
name|strstr
argument_list|(
name|haystack
argument_list|,
name|needle
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MEMMEM
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|memmem
argument_list|,
argument|const void *haystack
argument_list|,
argument|size_t haystacklen
argument_list|,
argument|const void *needle
argument_list|,
argument|size_t needlelen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|haystack
argument_list|,
name|haystacklen
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memmem haystack"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|needle
argument_list|,
name|needlelen
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"memmem needle"
argument_list|)
expr_stmt|;
return|return
name|memmem
argument_list|(
name|haystack
argument_list|,
name|haystacklen
argument_list|,
name|needle
argument_list|,
name|needlelen
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|size_t
argument_list|,
argument|strlen
argument_list|,
argument|const char *s
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|result
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strlen region"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|size_t
argument_list|,
argument|strnlen
argument_list|,
argument|const char *s
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|result
init|=
name|strnlen
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|result
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"strnlen region"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void
argument_list|,
argument|bzero
argument_list|,
argument|void *s
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"bzero region"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|bcopy
end_undef

begin_macro
name|WRAPPER2
argument_list|(
argument|void
argument_list|,
argument|bcopy
argument_list|,
argument|const void *src
argument_list|,
argument|void *dest
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|src
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"bcopy src"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dest
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"bcopy dest"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|bcmp
end_undef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|bcmp
argument_list|,
argument|const void *s1
argument_list|,
argument|const void *s2
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s1
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"bcmp 1st arg"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s2
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"bcmp 2nd arg"
argument_list|)
expr_stmt|;
return|return
name|bcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|index
argument_list|,
argument|const char *s
argument_list|,
argument|int c
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"index region"
argument_list|)
expr_stmt|;
return|return
name|index
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|rindex
argument_list|,
argument|const char *s
argument_list|,
argument|int c
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"rindex region"
argument_list|)
expr_stmt|;
return|return
name|rindex
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* XXX:  stpcpy, memccpy */
end_comment

begin_comment
comment|/* XXX: *printf,*scanf */
end_comment

begin_comment
comment|/* XXX: setjmp, longjmp */
end_comment

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|asctime
argument_list|,
argument|struct tm *tm
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
modifier|*
name|reg_result
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tm
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"asctime tm"
argument_list|)
expr_stmt|;
name|result
operator|=
name|asctime
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_result
operator|==
name|NULL
condition|)
block|{
name|__mf_register
argument_list|(
name|result
argument_list|,
name|strlen
argument_list|(
name|result
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"asctime string"
argument_list|)
expr_stmt|;
name|reg_result
operator|=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|ctime
argument_list|,
argument|const time_t *timep
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
modifier|*
name|reg_result
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|timep
argument_list|,
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"ctime time"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ctime
argument_list|(
name|timep
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_result
operator|==
name|NULL
condition|)
block|{
comment|/* XXX: what if asctime and ctime return the same static ptr? */
name|__mf_register
argument_list|(
name|result
argument_list|,
name|strlen
argument_list|(
name|result
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"ctime string"
argument_list|)
expr_stmt|;
name|reg_result
operator|=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|struct tm*
argument_list|,
argument|localtime
argument_list|,
argument|const time_t *timep
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|struct
name|tm
modifier|*
name|reg_result
init|=
name|NULL
decl_stmt|;
name|struct
name|tm
modifier|*
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|timep
argument_list|,
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"localtime time"
argument_list|)
expr_stmt|;
name|result
operator|=
name|localtime
argument_list|(
name|timep
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_result
operator|==
name|NULL
condition|)
block|{
name|__mf_register
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tm
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"localtime tm"
argument_list|)
expr_stmt|;
name|reg_result
operator|=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|struct tm*
argument_list|,
argument|gmtime
argument_list|,
argument|const time_t *timep
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|struct
name|tm
modifier|*
name|reg_result
init|=
name|NULL
decl_stmt|;
name|struct
name|tm
modifier|*
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|timep
argument_list|,
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"gmtime time"
argument_list|)
expr_stmt|;
name|result
operator|=
name|gmtime
argument_list|(
name|timep
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_result
operator|==
name|NULL
condition|)
block|{
name|__mf_register
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tm
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"gmtime tm"
argument_list|)
expr_stmt|;
name|reg_result
operator|=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* EL start */
end_comment

begin_comment
comment|/* The following indicate if the result of the corresponding function  * should be explicitly un/registered by the wrapper */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|MF_REGISTER_fopen
value|__MF_TYPE_STATIC
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|MF_REGISTER_fopen
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MF_RESULT_SIZE_fopen
value|(sizeof (FILE))
end_define

begin_undef
undef|#
directive|undef
name|MF_REGISTER_opendir
end_undef

begin_define
define|#
directive|define
name|MF_RESULT_SIZE_opendir
value|0
end_define

begin_comment
comment|/* (sizeof (DIR)) */
end_comment

begin_undef
undef|#
directive|undef
name|MF_REGISTER_readdir
end_undef

begin_define
define|#
directive|define
name|MF_REGISTER_gethostbyname
value|__MF_TYPE_STATIC
end_define

begin_undef
undef|#
directive|undef
name|MF_REGISTER_gethostbyname_items
end_undef

begin_undef
undef|#
directive|undef
name|MF_REGISTER_dlopen
end_undef

begin_undef
undef|#
directive|undef
name|MF_REGISTER_dlerror
end_undef

begin_undef
undef|#
directive|undef
name|MF_REGISTER_dlsym
end_undef

begin_define
define|#
directive|define
name|MF_REGISTER_shmat
value|__MF_TYPE_GUESS
end_define

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_macro
name|WRAPPER2
argument_list|(
argument|time_t
argument_list|,
argument|time
argument_list|,
argument|time_t *timep
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|timep
condition|)
name|MF_VALIDATE_EXTENT
argument_list|(
name|timep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|timep
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"time timep"
argument_list|)
expr_stmt|;
return|return
name|time
argument_list|(
name|timep
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|strerror
argument_list|,
argument|int errnum
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_strerror
init|=
name|NULL
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|p
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_strerror
operator|!=
name|NULL
condition|)
name|__mf_unregister
argument_list|(
name|last_strerror
argument_list|,
literal|0
argument_list|,
name|__MF_TYPE_STATIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
name|__mf_register
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"strerror result"
argument_list|)
expr_stmt|;
name|last_strerror
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_comment
comment|/* An auxiliary data structure for tracking the hand-made stdio    buffers we generate during the fopen/fopen64 hooks.  In a civilized    language, this would be a simple dynamically sized FILE*->char*    lookup table, but this is C and we get to do it by hand.  */
end_comment

begin_struct
struct|struct
name|mf_filebuffer
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|struct
name|mf_filebuffer
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mf_filebuffer
modifier|*
name|mf_filebuffers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mkbuffer
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
comment|/* Reset any buffer automatically provided by libc, since this may      have been done via mechanisms that libmudflap couldn't      intercept.  */
name|int
name|rc
decl_stmt|;
name|size_t
name|bufsize
init|=
name|BUFSIZ
decl_stmt|;
name|int
name|bufmode
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|malloc
argument_list|(
name|bufsize
argument_list|)
decl_stmt|;
name|struct
name|mf_filebuffer
modifier|*
name|b
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mf_filebuffer
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
operator|(
name|buffer
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
comment|/* Link it into list.  */
name|b
operator|->
name|file
operator|=
name|f
expr_stmt|;
name|b
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|mf_filebuffers
expr_stmt|;
name|mf_filebuffers
operator|=
name|b
expr_stmt|;
comment|/* Determine how the file is supposed to be buffered at the moment.  */
name|bufmode
operator|=
name|fileno
argument_list|(
name|f
argument_list|)
operator|==
literal|2
condition|?
name|_IONBF
else|:
operator|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|)
condition|?
name|_IOLBF
else|:
name|_IOFBF
operator|)
expr_stmt|;
name|rc
operator|=
name|setvbuf
argument_list|(
name|f
argument_list|,
name|buffer
argument_list|,
name|bufmode
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmkbuffer
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|mf_filebuffer
modifier|*
name|b
init|=
name|mf_filebuffers
decl_stmt|;
name|struct
name|mf_filebuffer
modifier|*
modifier|*
name|pb
init|=
operator|&
name|mf_filebuffers
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|file
operator|==
name|f
condition|)
block|{
operator|*
name|pb
operator|=
name|b
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
name|pb
operator|=
operator|&
name|b
operator|->
name|next
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|WRAPPER2
argument_list|(
argument|FILE *
argument_list|,
argument|fopen
argument_list|,
argument|const char *path
argument_list|,
argument|const char *mode
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|FILE
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fopen path"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|mode
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fopen mode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|,
literal|"fopen result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fopen result"
argument_list|)
expr_stmt|;
name|mkbuffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|setvbuf
argument_list|,
argument|FILE *stream
argument_list|,
argument|char *buf
argument_list|,
argument|int mode
argument_list|,
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"setvbuf stream"
argument_list|)
expr_stmt|;
name|unmkbuffer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"setvbuf buffer"
argument_list|)
expr_stmt|;
comment|/* Override the user only if it's an auto-allocated buffer request.  Otherwise      assume that the supplied buffer is already known to libmudflap.  */
if|if
condition|(
operator|(
name|buf
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|mode
operator|==
name|_IOFBF
operator|)
operator|||
operator|(
name|mode
operator|==
name|_IOLBF
operator|)
operator|)
condition|)
name|mkbuffer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|setvbuf
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SETBUF
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|setbuf
argument_list|,
argument|FILE* stream
argument_list|,
argument|char *buf
argument_list|)
end_macro

begin_block
block|{
return|return
name|__mfwrap_setvbuf
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|,
name|buf
condition|?
name|_IOFBF
else|:
name|_IONBF
argument_list|,
name|BUFSIZ
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SETBUFFER
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|setbuffer
argument_list|,
argument|FILE* stream
argument_list|,
argument|char *buf
argument_list|,
argument|size_t sz
argument_list|)
end_macro

begin_block
block|{
return|return
name|__mfwrap_setvbuf
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|,
name|buf
condition|?
name|_IOFBF
else|:
name|_IONBF
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SETLINEBUF
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|setlinebuf
argument_list|,
argument|FILE* stream
argument_list|)
end_macro

begin_block
block|{
return|return
name|__mfwrap_setvbuf
argument_list|(
name|stream
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|FILE *
argument_list|,
argument|fdopen
argument_list|,
argument|int fd
argument_list|,
argument|const char *mode
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|FILE
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|mode
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fdopen mode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|,
literal|"fdopen result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fdopen result"
argument_list|)
expr_stmt|;
name|mkbuffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|FILE *
argument_list|,
argument|freopen
argument_list|,
argument|const char *path
argument_list|,
argument|const char *mode
argument_list|,
argument|FILE *s
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|FILE
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"freopen path"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
operator|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"freopen stream"
argument_list|)
expr_stmt|;
name|unmkbuffer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|mode
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"freopen mode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|freopen
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|,
literal|"freopen result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"freopen result"
argument_list|)
expr_stmt|;
name|mkbuffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FOPEN64
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|FILE *
argument_list|,
argument|fopen64
argument_list|,
argument|const char *path
argument_list|,
argument|const char *mode
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|FILE
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fopen64 path"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|mode
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fopen64 mode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|fopen64
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|,
literal|"fopen64 result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fopen64 result"
argument_list|)
expr_stmt|;
name|mkbuffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FREOPEN64
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|FILE *
argument_list|,
argument|freopen64
argument_list|,
argument|const char *path
argument_list|,
argument|const char *mode
argument_list|,
argument|FILE *s
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|FILE
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"freopen64 path"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
operator|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"freopen64 stream"
argument_list|)
expr_stmt|;
name|unmkbuffer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|mode
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"freopen64 mode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|freopen
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|,
literal|"freopen64 result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"freopen64 result"
argument_list|)
expr_stmt|;
name|mkbuffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fclose
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|int
name|resp
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fclose stream"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_unregister
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unmkbuffer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|resp
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|size_t
argument_list|,
argument|fread
argument_list|,
argument|void *ptr
argument_list|,
argument|size_t size
argument_list|,
argument|size_t nmemb
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fread stream"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|ptr
argument_list|,
name|size
operator|*
name|nmemb
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fread buffer"
argument_list|)
expr_stmt|;
return|return
name|fread
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|nmemb
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|size_t
argument_list|,
argument|fwrite
argument_list|,
argument|const void *ptr
argument_list|,
argument|size_t size
argument_list|,
argument|size_t nmemb
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fwrite stream"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|ptr
argument_list|,
name|size
operator|*
name|nmemb
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fwrite buffer"
argument_list|)
expr_stmt|;
return|return
name|fwrite
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|nmemb
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fgetc
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fgetc stream"
argument_list|)
expr_stmt|;
return|return
name|fgetc
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|fgets
argument_list|,
argument|char *s
argument_list|,
argument|int size
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fgets stream"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|size
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fgets buffer"
argument_list|)
expr_stmt|;
return|return
name|fgets
argument_list|(
name|s
argument_list|,
name|size
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|getc
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"getc stream"
argument_list|)
expr_stmt|;
return|return
name|getc
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|gets
argument_list|,
argument|char *s
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gets buffer"
argument_list|)
expr_stmt|;
comment|/* Avoid link-time warning... */
name|s
operator|=
name|fgets
argument_list|(
name|s
argument_list|,
name|INT_MAX
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|s
condition|)
block|{
comment|/* better late than never */
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gets buffer"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|ungetc
argument_list|,
argument|int c
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"ungetc stream"
argument_list|)
expr_stmt|;
return|return
name|ungetc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fputc
argument_list|,
argument|int c
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fputc stream"
argument_list|)
expr_stmt|;
return|return
name|fputc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fputs
argument_list|,
argument|const char *s
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fputs buffer"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fputs stream"
argument_list|)
expr_stmt|;
return|return
name|fputs
argument_list|(
name|s
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|putc
argument_list|,
argument|int c
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"putc stream"
argument_list|)
expr_stmt|;
return|return
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|puts
argument_list|,
argument|const char *s
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"puts buffer"
argument_list|)
expr_stmt|;
return|return
name|puts
argument_list|(
name|s
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void
argument_list|,
argument|clearerr
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"clearerr stream"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|feof
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"feof stream"
argument_list|)
expr_stmt|;
return|return
name|feof
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|ferror
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"ferror stream"
argument_list|)
expr_stmt|;
return|return
name|ferror
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fileno
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fileno stream"
argument_list|)
expr_stmt|;
return|return
name|fileno
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|printf
argument_list|,
argument|const char *format
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"printf format"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|result
operator|=
name|vprintf
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fprintf
argument_list|,
argument|FILE *stream
argument_list|,
argument|const char *format
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fprintf stream"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fprintf format"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|result
operator|=
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|sprintf
argument_list|,
argument|char *str
argument_list|,
argument|const char *format
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"sprintf str"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"sprintf format"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|result
operator|=
name|vsprintf
argument_list|(
name|str
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|str
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"sprintf str"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|snprintf
argument_list|,
argument|char *str
argument_list|,
argument|size_t size
argument_list|,
argument|const char *format
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|str
argument_list|,
name|size
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"snprintf str"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"snprintf format"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|result
operator|=
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|vprintf
argument_list|,
argument|const char *format
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"vprintf format"
argument_list|)
expr_stmt|;
return|return
name|vprintf
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|vfprintf
argument_list|,
argument|FILE *stream
argument_list|,
argument|const char *format
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"vfprintf stream"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"vfprintf format"
argument_list|)
expr_stmt|;
return|return
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|vsprintf
argument_list|,
argument|char *str
argument_list|,
argument|const char *format
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|int
name|result
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"vsprintf str"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"vsprintf format"
argument_list|)
expr_stmt|;
name|result
operator|=
name|vsprintf
argument_list|(
name|str
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|str
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"vsprintf str"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|vsnprintf
argument_list|,
argument|char *str
argument_list|,
argument|size_t size
argument_list|,
argument|const char *format
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|str
argument_list|,
name|size
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"vsnprintf str"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|format
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"vsnprintf format"
argument_list|)
expr_stmt|;
return|return
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|access
argument_list|,
argument|const char *path
argument_list|,
argument|int mode
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"access path"
argument_list|)
expr_stmt|;
return|return
name|access
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|remove
argument_list|,
argument|const char *path
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"remove path"
argument_list|)
expr_stmt|;
return|return
name|remove
argument_list|(
name|path
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fflush
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|NULL
condition|)
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fflush stream"
argument_list|)
expr_stmt|;
return|return
name|fflush
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fseek
argument_list|,
argument|FILE *stream
argument_list|,
argument|long offset
argument_list|,
argument|int whence
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fseek stream"
argument_list|)
expr_stmt|;
return|return
name|fseek
argument_list|(
name|stream
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FSEEKO64
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fseeko64
argument_list|,
argument|FILE *stream
argument_list|,
argument|off64_t offset
argument_list|,
argument|int whence
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fseeko64 stream"
argument_list|)
expr_stmt|;
return|return
name|fseeko64
argument_list|(
name|stream
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|long
argument_list|,
argument|ftell
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"ftell stream"
argument_list|)
expr_stmt|;
return|return
name|ftell
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FTELLO64
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|off64_t
argument_list|,
argument|ftello64
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"ftello64 stream"
argument_list|)
expr_stmt|;
return|return
name|ftello64
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|void
argument_list|,
argument|rewind
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"rewind stream"
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fgetpos
argument_list|,
argument|FILE *stream
argument_list|,
argument|fpos_t *pos
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fgetpos stream"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pos
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fgetpos pos"
argument_list|)
expr_stmt|;
return|return
name|fgetpos
argument_list|(
name|stream
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fsetpos
argument_list|,
argument|FILE *stream
argument_list|,
argument|fpos_t *pos
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"fsetpos stream"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pos
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fsetpos pos"
argument_list|)
expr_stmt|;
return|return
name|fsetpos
argument_list|(
name|stream
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|stat
argument_list|,
argument|const char *path
argument_list|,
argument|struct stat *buf
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"stat path"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"stat buf"
argument_list|)
expr_stmt|;
return|return
name|stat
argument_list|(
name|path
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STAT64
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|stat64
argument_list|,
argument|const char *path
argument_list|,
argument|struct stat64 *buf
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"stat64 path"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"stat64 buf"
argument_list|)
expr_stmt|;
return|return
name|stat64
argument_list|(
name|path
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|fstat
argument_list|,
argument|int filedes
argument_list|,
argument|struct stat *buf
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"fstat buf"
argument_list|)
expr_stmt|;
return|return
name|fstat
argument_list|(
name|filedes
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|lstat
argument_list|,
argument|const char *path
argument_list|,
argument|struct stat *buf
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"lstat path"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"lstat buf"
argument_list|)
expr_stmt|;
return|return
name|lstat
argument_list|(
name|path
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|mkfifo
argument_list|,
argument|const char *path
argument_list|,
argument|mode_t mode
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"mkfifo path"
argument_list|)
expr_stmt|;
return|return
name|mkfifo
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DIRENT_H
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|DIR *
argument_list|,
argument|opendir
argument_list|,
argument|const char *path
argument_list|)
end_macro

begin_block
block|{
name|DIR
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"opendir path"
argument_list|)
expr_stmt|;
name|p
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_opendir
name|__mf_register
argument_list|(
name|p
argument_list|,
name|MF_RESULT_SIZE_opendir
argument_list|,
name|MF_REGISTER_opendir
argument_list|,
literal|"opendir result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
name|MF_RESULT_SIZE_opendir
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"opendir result"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|closedir
argument_list|,
argument|DIR *dir
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dir
argument_list|,
literal|0
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"closedir dir"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_opendir
name|__mf_unregister
argument_list|(
name|dir
argument_list|,
name|MF_RESULT_SIZE_opendir
argument_list|,
name|MF_REGISTER_opendir
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|closedir
argument_list|(
name|dir
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|struct dirent *
argument_list|,
argument|readdir
argument_list|,
argument|DIR *dir
argument_list|)
end_macro

begin_block
block|{
name|struct
name|dirent
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|dir
argument_list|,
literal|0
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"readdir dir"
argument_list|)
expr_stmt|;
name|p
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_readdir
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_readdir
argument_list|,
literal|"readdir result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"readdir result"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|recv
argument_list|,
argument|int s
argument_list|,
argument|void *buf
argument_list|,
argument|size_t len
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"recv buf"
argument_list|)
expr_stmt|;
return|return
name|recv
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|recvfrom
argument_list|,
argument|int s
argument_list|,
argument|void *buf
argument_list|,
argument|size_t len
argument_list|,
argument|int flags
argument_list|,
argument|struct sockaddr *from
argument_list|,
argument|socklen_t *fromlen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"recvfrom buf"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|from
argument_list|,
operator|(
name|size_t
operator|)
operator|*
name|fromlen
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"recvfrom from"
argument_list|)
expr_stmt|;
return|return
name|recvfrom
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|flags
argument_list|,
name|from
argument_list|,
name|fromlen
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|recvmsg
argument_list|,
argument|int s
argument_list|,
argument|struct msghdr *msg
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"recvmsg msg"
argument_list|)
expr_stmt|;
return|return
name|recvmsg
argument_list|(
name|s
argument_list|,
name|msg
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|send
argument_list|,
argument|int s
argument_list|,
argument|const void *msg
argument_list|,
argument|size_t len
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|msg
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"send msg"
argument_list|)
expr_stmt|;
return|return
name|send
argument_list|(
name|s
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|sendto
argument_list|,
argument|int s
argument_list|,
argument|const void *msg
argument_list|,
argument|size_t len
argument_list|,
argument|int flags
argument_list|,
argument|const struct sockaddr *to
argument_list|,
argument|socklen_t tolen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|msg
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"sendto msg"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|to
argument_list|,
operator|(
name|size_t
operator|)
name|tolen
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"sendto to"
argument_list|)
expr_stmt|;
return|return
name|sendto
argument_list|(
name|s
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|flags
argument_list|,
name|to
argument_list|,
name|tolen
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|sendmsg
argument_list|,
argument|int s
argument_list|,
argument|const void *msg
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"sendmsg msg"
argument_list|)
expr_stmt|;
return|return
name|sendmsg
argument_list|(
name|s
argument_list|,
name|msg
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|setsockopt
argument_list|,
argument|int s
argument_list|,
argument|int level
argument_list|,
argument|int optname
argument_list|,
argument|const void *optval
argument_list|,
argument|socklen_t optlen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|optval
argument_list|,
operator|(
name|size_t
operator|)
name|optlen
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"setsockopt optval"
argument_list|)
expr_stmt|;
return|return
name|setsockopt
argument_list|(
name|s
argument_list|,
name|level
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|,
name|optlen
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|getsockopt
argument_list|,
argument|int s
argument_list|,
argument|int level
argument_list|,
argument|int optname
argument_list|,
argument|void *optval
argument_list|,
argument|socklen_t *optlen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|optval
argument_list|,
operator|(
name|size_t
operator|)
operator|*
name|optlen
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"getsockopt optval"
argument_list|)
expr_stmt|;
return|return
name|getsockopt
argument_list|(
name|s
argument_list|,
name|level
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|,
name|optlen
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|accept
argument_list|,
argument|int s
argument_list|,
argument|struct  sockaddr *addr
argument_list|,
argument|socklen_t *addrlen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
name|MF_VALIDATE_EXTENT
argument_list|(
name|addr
argument_list|,
operator|(
name|size_t
operator|)
operator|*
name|addrlen
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"accept addr"
argument_list|)
expr_stmt|;
return|return
name|accept
argument_list|(
name|s
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|bind
argument_list|,
argument|int sockfd
argument_list|,
argument|struct  sockaddr *addr
argument_list|,
argument|socklen_t addrlen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|addrlen
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"bind addr"
argument_list|)
expr_stmt|;
return|return
name|bind
argument_list|(
name|sockfd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|connect
argument_list|,
argument|int sockfd
argument_list|,
argument|const struct sockaddr  *addr
argument_list|,
argument|socklen_t addrlen
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|addrlen
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"connect addr"
argument_list|)
expr_stmt|;
return|return
name|connect
argument_list|(
name|sockfd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_SOCKET_H */
end_comment

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|gethostname
argument_list|,
argument|char *name
argument_list|,
argument|size_t len
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gethostname name"
argument_list|)
expr_stmt|;
return|return
name|gethostname
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SETHOSTNAME
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|sethostname
argument_list|,
argument|const char *name
argument_list|,
argument|size_t len
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"sethostname name"
argument_list|)
expr_stmt|;
return|return
name|sethostname
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct hostent *
argument_list|,
argument|gethostbyname
argument_list|,
argument|const char *name
argument_list|)
end_macro

begin_block
block|{
name|struct
name|hostent
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|ss
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|int
name|nreg
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|name
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"gethostbyname name"
argument_list|)
expr_stmt|;
name|p
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_gethostbyname
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_gethostbyname
argument_list|,
literal|"gethostbyname result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gethostbyname result"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|s
operator|=
name|p
operator|->
name|h_name
operator|)
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_gethostbyname_items
name|__mf_register
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|MF_REGISTER_gethostbyname_items
argument_list|,
literal|"gethostbyname result->h_name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gethostbyname result->h_name"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|!=
operator|(
name|ss
operator|=
name|p
operator|->
name|h_aliases
operator|)
condition|)
block|{
for|for
control|(
name|nreg
operator|=
literal|1
init|;
condition|;
operator|++
name|nreg
control|)
block|{
name|s
operator|=
operator|*
name|ss
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
break|break;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_gethostbyname_items
name|__mf_register
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|MF_REGISTER_gethostbyname_items
argument_list|,
literal|"gethostbyname result->h_aliases[]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gethostbyname result->h_aliases[]"
argument_list|)
expr_stmt|;
block|}
name|nreg
operator|*=
sizeof|sizeof
argument_list|(
operator|*
name|p
operator|->
name|h_aliases
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_gethostbyname_items
name|__mf_register
argument_list|(
name|p
operator|->
name|h_aliases
argument_list|,
name|nreg
argument_list|,
name|MF_REGISTER_gethostbyname_items
argument_list|,
literal|"gethostbyname result->h_aliases"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
operator|->
name|h_aliases
argument_list|,
name|nreg
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gethostbyname result->h_aliases"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|!=
operator|(
name|ss
operator|=
name|p
operator|->
name|h_addr_list
operator|)
condition|)
block|{
for|for
control|(
name|nreg
operator|=
literal|1
init|;
condition|;
operator|++
name|nreg
control|)
block|{
name|s
operator|=
operator|*
name|ss
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
break|break;
ifdef|#
directive|ifdef
name|MF_REGISTER_gethostbyname_items
name|__mf_register
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|h_length
argument_list|,
name|MF_REGISTER_gethostbyname_items
argument_list|,
literal|"gethostbyname result->h_addr_list[]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|h_length
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gethostbyname result->h_addr_list[]"
argument_list|)
expr_stmt|;
block|}
name|nreg
operator|*=
sizeof|sizeof
argument_list|(
operator|*
name|p
operator|->
name|h_addr_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_gethostbyname_items
name|__mf_register
argument_list|(
name|p
operator|->
name|h_addr_list
argument_list|,
name|nreg
argument_list|,
name|MF_REGISTER_gethostbyname_items
argument_list|,
literal|"gethostbyname result->h_addr_list"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
operator|->
name|h_addr_list
argument_list|,
name|nreg
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"gethostbyname result->h_addr_list"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETDB_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|pid_t
argument_list|,
argument|wait
argument_list|,
argument|int *status
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|status
condition|)
name|MF_VALIDATE_EXTENT
argument_list|(
name|status
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"wait status"
argument_list|)
expr_stmt|;
return|return
name|wait
argument_list|(
name|status
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|pid_t
argument_list|,
argument|waitpid
argument_list|,
argument|pid_t pid
argument_list|,
argument|int *status
argument_list|,
argument|int options
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|status
condition|)
name|MF_VALIDATE_EXTENT
argument_list|(
name|status
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"waitpid status"
argument_list|)
expr_stmt|;
return|return
name|waitpid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
name|options
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_WAIT_H */
end_comment

begin_macro
name|WRAPPER2
argument_list|(
argument|FILE *
argument_list|,
argument|popen
argument_list|,
argument|const char *command
argument_list|,
argument|const char *mode
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|FILE
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|command
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"popen path"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|mode
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"popen mode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|popen
argument_list|(
name|command
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_register
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|,
literal|"popen result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"popen result"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|pclose
argument_list|,
argument|FILE *stream
argument_list|)
end_macro

begin_block
block|{
name|int
name|resp
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"pclose stream"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|pclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_fopen
name|__mf_unregister
argument_list|(
name|stream
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|,
name|MF_REGISTER_fopen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|resp
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|execve
argument_list|,
argument|const char *path
argument_list|,
argument|char *const argv []
argument_list|,
argument|char *const envp[]
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execve path"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
init|;
condition|;
control|)
block|{
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execve *argv"
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
break|break;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execve **argv"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|envp
init|;
condition|;
control|)
block|{
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execve *envp"
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
break|break;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execve **envp"
argument_list|)
expr_stmt|;
block|}
return|return
name|execve
argument_list|(
name|path
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|execv
argument_list|,
argument|const char *path
argument_list|,
argument|char *const argv []
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execv path"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
init|;
condition|;
control|)
block|{
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execv *argv"
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
break|break;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execv **argv"
argument_list|)
expr_stmt|;
block|}
return|return
name|execv
argument_list|(
name|path
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|execvp
argument_list|,
argument|const char *path
argument_list|,
argument|char *const argv []
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execvp path"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
init|;
condition|;
control|)
block|{
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execvp *argv"
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
break|break;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|s
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"execvp **argv"
argument_list|)
expr_stmt|;
block|}
return|return
name|execvp
argument_list|(
name|path
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|system
argument_list|,
argument|const char *string
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|string
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"system string"
argument_list|)
expr_stmt|;
return|return
name|system
argument_list|(
name|string
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|dlopen
argument_list|,
argument|const char *path
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|path
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"dlopen path"
argument_list|)
expr_stmt|;
name|p
operator|=
name|dlopen
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_dlopen
name|__mf_register
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|MF_REGISTER_dlopen
argument_list|,
literal|"dlopen result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"dlopen result"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|dlclose
argument_list|,
argument|void *handle
argument_list|)
end_macro

begin_block
block|{
name|int
name|resp
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"dlclose handle"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|dlclose
argument_list|(
name|handle
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_dlopen
name|__mf_unregister
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
name|MF_REGISTER_dlopen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|resp
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|dlerror
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|p
operator|=
name|dlerror
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
name|size_t
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_dlerror
name|__mf_register
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|MF_REGISTER_dlerror
argument_list|,
literal|"dlerror result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"dlerror result"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|dlsym
argument_list|,
argument|void *handle
argument_list|,
argument|char *symbol
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|n
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"dlsym handle"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|symbol
argument_list|,
name|CLAMPADD
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"dlsym symbol"
argument_list|)
expr_stmt|;
name|p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|MF_REGISTER_dlsym
name|__mf_register
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|MF_REGISTER_dlsym
argument_list|,
literal|"dlsym result"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MF_VALIDATE_EXTENT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"dlsym result"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_IPC_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_SEM_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_SHM_H
argument_list|)
end_if

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|semop
argument_list|,
argument|int semid
argument_list|,
argument|struct sembuf *sops
argument_list|,
argument|unsigned nsops
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|sops
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sops
argument_list|)
operator|*
name|nsops
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"semop sops"
argument_list|)
expr_stmt|;
return|return
name|semop
argument_list|(
name|semid
argument_list|,
name|sops
argument_list|,
name|nsops
argument_list|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_UNION_SEMUN
end_ifndef

begin_union
union|union
name|semun
block|{
name|int
name|val
decl_stmt|;
comment|/* value for SETVAL */
name|struct
name|semid_ds
modifier|*
name|buf
decl_stmt|;
comment|/* buffer for IPC_STAT, IPC_SET */
name|unsigned
name|short
name|int
modifier|*
name|array
decl_stmt|;
comment|/* array for GETALL, SETALL */
name|struct
name|seminfo
modifier|*
name|__buf
decl_stmt|;
comment|/* buffer for IPC_INFO */
block|}
union|;
end_union

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|semctl
argument_list|,
argument|int semid
argument_list|,
argument|int semnum
argument_list|,
argument|int cmd
argument_list|,
argument|union semun arg
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
name|MF_VALIDATE_EXTENT
argument_list|(
name|arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arg
operator|.
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"semctl buf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPC_SET
case|:
name|MF_VALIDATE_EXTENT
argument_list|(
name|arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arg
operator|.
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"semctl buf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GETALL
case|:
name|MF_VALIDATE_EXTENT
argument_list|(
name|arg
operator|.
name|array
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arg
operator|.
name|array
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"semctl array"
argument_list|)
expr_stmt|;
case|case
name|SETALL
case|:
name|MF_VALIDATE_EXTENT
argument_list|(
name|arg
operator|.
name|array
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arg
operator|.
name|array
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"semctl array"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IPC_INFO
comment|/* FreeBSD 5.1 And Cygwin headers include IPC_INFO but not the __buf field.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
case|case
name|IPC_INFO
case|:
name|MF_VALIDATE_EXTENT
argument_list|(
name|arg
operator|.
name|__buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arg
operator|.
name|__buf
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"semctl __buf"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
name|semctl
argument_list|(
name|semid
argument_list|,
name|semnum
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|shmctl
argument_list|,
argument|int shmid
argument_list|,
argument|int cmd
argument_list|,
argument|struct shmid_ds *buf
argument_list|)
end_macro

begin_block
block|{
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"shmctl buf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPC_SET
case|:
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"shmctl buf"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|cmd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|void *
argument_list|,
argument|shmat
argument_list|,
argument|int shmid
argument_list|,
argument|const void *shmaddr
argument_list|,
argument|int shmflg
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|p
operator|=
name|shmat
argument_list|(
name|shmid
argument_list|,
name|shmaddr
argument_list|,
name|shmflg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_shmat
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
name|struct
name|shmid_ds
name|buf
decl_stmt|;
name|__mf_register
argument_list|(
name|p
argument_list|,
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_STAT
argument_list|,
operator|&
name|buf
argument_list|)
condition|?
literal|0
else|:
name|buf
operator|.
name|shm_segsz
argument_list|,
name|MF_REGISTER_shmat
argument_list|,
literal|"shmat result"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|p
return|;
block|}
end_block

begin_macro
name|WRAPPER2
argument_list|(
argument|int
argument_list|,
argument|shmdt
argument_list|,
argument|const void *shmaddr
argument_list|)
end_macro

begin_block
block|{
name|int
name|resp
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|resp
operator|=
name|shmdt
argument_list|(
name|shmaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MF_REGISTER_shmat
name|__mf_unregister
argument_list|(
operator|(
name|void
operator|*
operator|)
name|shmaddr
argument_list|,
literal|0
argument_list|,
name|MF_REGISTER_shmat
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|resp
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IPC/SEM/SHM_H */
end_comment

begin_comment
comment|/* ctype stuff.  This is host-specific by necessity, as the arrays    that is used by most is*()/to*() macros are implementation-defined.  */
end_comment

begin_comment
comment|/* GLIBC 2.3 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE___CTYPE_B_LOC
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|unsigned short **
argument_list|,
argument|__ctype_b_loc
argument_list|,
argument|void
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|unsigned
name|short
modifier|*
name|last_buf
init|=
operator|(
name|void
operator|*
operator|)
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|short
modifier|*
modifier|*
name|last_ptr
init|=
operator|(
name|void
operator|*
operator|)
literal|0
decl_stmt|;
name|unsigned
name|short
modifier|*
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|short
operator|*
operator|*
operator|)
name|__ctype_b_loc
argument_list|()
decl_stmt|;
name|unsigned
name|short
modifier|*
name|buf
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|last_ptr
condition|)
block|{
comment|/* XXX: unregister last_ptr? */
name|last_ptr
operator|=
name|ptr
expr_stmt|;
name|__mf_register
argument_list|(
name|last_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_ptr
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"ctype_b_loc **"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
name|last_buf
condition|)
block|{
name|last_buf
operator|=
name|buf
expr_stmt|;
name|__mf_register
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|last_buf
operator|-
literal|128
operator|)
argument_list|,
literal|384
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"ctype_b_loc []"
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE___CTYPE_TOUPPER_LOC
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int **
argument_list|,
argument|__ctype_toupper_loc
argument_list|,
argument|void
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|int
modifier|*
name|last_buf
init|=
operator|(
name|void
operator|*
operator|)
literal|0
decl_stmt|;
specifier|static
name|int
modifier|*
modifier|*
name|last_ptr
init|=
operator|(
name|void
operator|*
operator|)
literal|0
decl_stmt|;
name|int
modifier|*
modifier|*
name|ptr
init|=
operator|(
name|int
operator|*
operator|*
operator|)
name|__ctype_toupper_loc
argument_list|()
decl_stmt|;
name|int
modifier|*
name|buf
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|last_ptr
condition|)
block|{
comment|/* XXX: unregister last_ptr? */
name|last_ptr
operator|=
name|ptr
expr_stmt|;
name|__mf_register
argument_list|(
name|last_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_ptr
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"ctype_toupper_loc **"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
name|last_buf
condition|)
block|{
name|last_buf
operator|=
name|buf
expr_stmt|;
name|__mf_register
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|last_buf
operator|-
literal|128
operator|)
argument_list|,
literal|384
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"ctype_toupper_loc []"
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE___CTYPE_TOLOWER_LOC
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|int **
argument_list|,
argument|__ctype_tolower_loc
argument_list|,
argument|void
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|int
modifier|*
name|last_buf
init|=
operator|(
name|void
operator|*
operator|)
literal|0
decl_stmt|;
specifier|static
name|int
modifier|*
modifier|*
name|last_ptr
init|=
operator|(
name|void
operator|*
operator|)
literal|0
decl_stmt|;
name|int
modifier|*
modifier|*
name|ptr
init|=
operator|(
name|int
operator|*
operator|*
operator|)
name|__ctype_tolower_loc
argument_list|()
decl_stmt|;
name|int
modifier|*
name|buf
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|last_ptr
condition|)
block|{
comment|/* XXX: unregister last_ptr? */
name|last_ptr
operator|=
name|ptr
expr_stmt|;
name|__mf_register
argument_list|(
name|last_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_ptr
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"ctype_tolower_loc **"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
name|last_buf
condition|)
block|{
name|last_buf
operator|=
name|buf
expr_stmt|;
name|__mf_register
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|last_buf
operator|-
literal|128
operator|)
argument_list|,
literal|384
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"ctype_tolower_loc []"
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* passwd/group related functions.  These register every (static) pointer value returned,    and rely on libmudflap's quiet toleration of duplicate static registrations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETLOGIN
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|getlogin
argument_list|,
argument|void
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|buf
init|=
name|getlogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getlogin() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CUSERID
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|cuserid
argument_list|,
argument|char * buf
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|MF_VALIDATE_EXTENT
argument_list|(
name|buf
argument_list|,
name|L_cuserid
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"cuserid destination"
argument_list|)
expr_stmt|;
return|return
name|cuserid
argument_list|(
name|buf
argument_list|)
return|;
block|}
name|buf
operator|=
name|cuserid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getcuserid() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETPWNAM
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct passwd *
argument_list|,
argument|getpwnam
argument_list|,
argument|const char *name
argument_list|)
end_macro

begin_block
block|{
name|struct
name|passwd
modifier|*
name|buf
decl_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"getpwnam name"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getpw*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETPWUID
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct passwd *
argument_list|,
argument|getpwuid
argument_list|,
argument|uid_t uid
argument_list|)
end_macro

begin_block
block|{
name|struct
name|passwd
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getpw*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETGRNAM
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct group *
argument_list|,
argument|getgrnam
argument_list|,
argument|const char *name
argument_list|)
end_macro

begin_block
block|{
name|struct
name|group
modifier|*
name|buf
decl_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"getgrnam name"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|getgrnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getgr*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETGRGID
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct group *
argument_list|,
argument|getgrgid
argument_list|,
argument|uid_t uid
argument_list|)
end_macro

begin_block
block|{
name|struct
name|group
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|getgrgid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getgr*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETSERVENT
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct servent *
argument_list|,
argument|getservent
argument_list|,
argument|void
argument_list|)
end_macro

begin_block
block|{
name|struct
name|servent
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|getservent
argument_list|()
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getserv*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETSERVBYNAME
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct servent *
argument_list|,
argument|getservbyname
argument_list|,
argument|const char *name
argument_list|,
argument|const char *proto
argument_list|)
end_macro

begin_block
block|{
name|struct
name|servent
modifier|*
name|buf
decl_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"getservbyname name"
argument_list|)
expr_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|proto
argument_list|,
name|strlen
argument_list|(
name|proto
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"getservbyname proto"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|getservbyname
argument_list|(
name|name
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getserv*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETSERVBYPORT
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct servent *
argument_list|,
argument|getservbyport
argument_list|,
argument|int port
argument_list|,
argument|const char *proto
argument_list|)
end_macro

begin_block
block|{
name|struct
name|servent
modifier|*
name|buf
decl_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|proto
argument_list|,
name|strlen
argument_list|(
name|proto
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"getservbyport proto"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|getservbyport
argument_list|(
name|port
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getserv*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAI_STRERROR
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|const char *
argument_list|,
argument|gai_strerror
argument_list|,
argument|int errcode
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|gai_strerror
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"gai_strerror() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETMNTENT
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct mntent *
argument_list|,
argument|getmntent
argument_list|,
argument|FILE *filep
argument_list|)
end_macro

begin_block
block|{
name|struct
name|mntent
modifier|*
name|m
decl_stmt|;
specifier|static
name|struct
name|mntent
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|filep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|filep
argument_list|)
argument_list|,
name|__MF_CHECK_WRITE
argument_list|,
literal|"getmntent stream"
argument_list|)
expr_stmt|;
define|#
directive|define
name|UR
parameter_list|(
name|field
parameter_list|)
value|__mf_unregister(last->field, strlen (last->field)+1, __MF_TYPE_STATIC)
if|if
condition|(
name|last
condition|)
block|{
name|UR
argument_list|(
name|mnt_fsname
argument_list|)
expr_stmt|;
name|UR
argument_list|(
name|mnt_dir
argument_list|)
expr_stmt|;
name|UR
argument_list|(
name|mnt_type
argument_list|)
expr_stmt|;
name|UR
argument_list|(
name|mnt_opts
argument_list|)
expr_stmt|;
name|__mf_unregister
argument_list|(
name|last
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|last
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|UR
name|m
operator|=
name|getmntent
argument_list|(
name|filep
argument_list|)
expr_stmt|;
name|last
operator|=
name|m
expr_stmt|;
define|#
directive|define
name|R
parameter_list|(
name|field
parameter_list|)
value|__mf_register(last->field, strlen (last->field)+1, __MF_TYPE_STATIC, "mntent " #field)
if|if
condition|(
name|m
condition|)
block|{
name|R
argument_list|(
name|mnt_fsname
argument_list|)
expr_stmt|;
name|R
argument_list|(
name|mnt_dir
argument_list|)
expr_stmt|;
name|R
argument_list|(
name|mnt_type
argument_list|)
expr_stmt|;
name|R
argument_list|(
name|mnt_opts
argument_list|)
expr_stmt|;
name|__mf_register
argument_list|(
name|last
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|last
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getmntent result"
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|R
return|return
name|m
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_INET_NTOA
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|char *
argument_list|,
argument|inet_ntoa
argument_list|,
argument|struct in_addr in
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
modifier|*
name|last_buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|last_buf
condition|)
name|__mf_unregister
argument_list|(
name|last_buf
argument_list|,
name|strlen
argument_list|(
name|last_buf
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|)
expr_stmt|;
name|buf
operator|=
name|inet_ntoa
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|last_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|__mf_register
argument_list|(
name|last_buf
argument_list|,
name|strlen
argument_list|(
name|last_buf
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"inet_ntoa result"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETPROTOENT
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct protoent *
argument_list|,
argument|getprotoent
argument_list|,
argument|void
argument_list|)
end_macro

begin_block
block|{
name|struct
name|protoent
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|getprotoent
argument_list|()
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getproto*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETPROTOBYNAME
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct protoent *
argument_list|,
argument|getprotobyname
argument_list|,
argument|const char *name
argument_list|)
end_macro

begin_block
block|{
name|struct
name|protoent
modifier|*
name|buf
decl_stmt|;
name|MF_VALIDATE_EXTENT
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|__MF_CHECK_READ
argument_list|,
literal|"getprotobyname name"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|getprotobyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getproto*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETPROTOBYNUMBER
end_ifdef

begin_macro
name|WRAPPER2
argument_list|(
argument|struct protoent *
argument_list|,
argument|getprotobynumber
argument_list|,
argument|int port
argument_list|)
end_macro

begin_block
block|{
name|struct
name|protoent
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|getprotobynumber
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|__mf_register
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"getproto*() return"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

