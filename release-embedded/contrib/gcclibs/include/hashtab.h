begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* An expandable hash tables datatype.      Copyright (C) 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This package implements basic hash table functionality.  It is possible    to search for an entry, create an entry and destroy an entry.     Elements in the table are generic pointers.     The size of the table is not fixed; if the occupancy of the table    grows too high the hash table will be expanded.     The abstract data implementation is based on generalized Algorithm D    from Knuth's book "The art of computer programming".  Hash table is    expanded by creation of new hash table and transferring elements from    the old table to the new table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__HASHTAB_H__
end_ifndef

begin_define
define|#
directive|define
name|__HASHTAB_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
include|#
directive|include
file|"ansidecl.h"
ifndef|#
directive|ifndef
name|GTY
define|#
directive|define
name|GTY
parameter_list|(
name|X
parameter_list|)
endif|#
directive|endif
comment|/* The type for a hash code.  */
typedef|typedef
name|unsigned
name|int
name|hashval_t
typedef|;
comment|/* Callback function pointer types.  */
comment|/* Calculate hash of a table entry.  */
typedef|typedef
name|hashval_t
function_decl|(
modifier|*
name|htab_hash
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* Compare a table entry with a possible entry.  The entry already in    the table always comes first, so the second element can be of a    different type (but in this case htab_find and htab_find_slot    cannot be used; instead the variants that accept a hash value    must be used).  */
typedef|typedef
name|int
function_decl|(
modifier|*
name|htab_eq
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* Cleanup function called whenever a live element is removed from    the hash table.  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|htab_del
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* Function called by htab_traverse for each live element.  The first    arg is the slot of the element (which can be passed to htab_clear_slot    if desired), the second arg is the auxiliary pointer handed to    htab_traverse.  Return 1 to continue scan, 0 to stop.  */
typedef|typedef
name|int
function_decl|(
modifier|*
name|htab_trav
function_decl|)
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* Memory-allocation function, with the same functionality as calloc().    Iff it returns NULL, the hash table implementation will pass an error    code back to the user, so if your code doesn't handle errors,    best if you use xcalloc instead.  */
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|htab_alloc
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* We also need a free() routine.  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|htab_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* Memory allocation and deallocation; variants which take an extra    argument.  */
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|htab_alloc_with_arg
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|htab_free_with_arg
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* This macro defines reserved value for empty table entry.  */
define|#
directive|define
name|HTAB_EMPTY_ENTRY
value|((PTR) 0)
comment|/* This macro defines reserved value for table entry which contained    a deleted element. */
define|#
directive|define
name|HTAB_DELETED_ENTRY
value|((PTR) 1)
comment|/* Hash tables are of the following type.  The structure    (implementation) of this type is not needed for using the hash    tables.  All work with hash table should be executed only through    functions mentioned below.  The size of this structure is subject to    change.  */
name|struct
name|htab
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Pointer to hash function.  */
name|htab_hash
name|hash_f
decl_stmt|;
comment|/* Pointer to comparison function.  */
name|htab_eq
name|eq_f
decl_stmt|;
comment|/* Pointer to cleanup function.  */
name|htab_del
name|del_f
decl_stmt|;
comment|/* Table itself.  */
name|void
modifier|*
modifier|*
name|GTY
argument_list|(
operator|(
name|use_param
operator|,
name|length
argument_list|(
literal|"%h.size"
argument_list|)
operator|)
argument_list|)
name|entries
decl_stmt|;
comment|/* Current size (in entries) of the hash table.  */
name|size_t
name|size
decl_stmt|;
comment|/* Current number of elements including also deleted elements.  */
name|size_t
name|n_elements
decl_stmt|;
comment|/* Current number of deleted elements in the table.  */
name|size_t
name|n_deleted
decl_stmt|;
comment|/* The following member is used for debugging. Its value is number      of all calls of `htab_find_slot' for the hash table. */
name|unsigned
name|int
name|searches
decl_stmt|;
comment|/* The following member is used for debugging.  Its value is number      of collisions fixed for time of work with the hash table. */
name|unsigned
name|int
name|collisions
decl_stmt|;
comment|/* Pointers to allocate/free functions.  */
name|htab_alloc
name|alloc_f
decl_stmt|;
name|htab_free
name|free_f
decl_stmt|;
comment|/* Alternate allocate/free functions, which take an extra argument.  */
name|void
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|alloc_arg
decl_stmt|;
name|htab_alloc_with_arg
name|alloc_with_arg_f
decl_stmt|;
name|htab_free_with_arg
name|free_with_arg_f
decl_stmt|;
comment|/* Current size (in entries) of the hash table, as an index into the      table of primes.  */
name|unsigned
name|int
name|size_prime_index
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|struct
name|htab
modifier|*
name|htab_t
typedef|;
comment|/* An enum saying whether we insert into the hash table or not.  */
enum|enum
name|insert_option
block|{
name|NO_INSERT
block|,
name|INSERT
block|}
enum|;
comment|/* The prototypes of the package functions. */
specifier|extern
name|htab_t
name|htab_create_alloc
parameter_list|(
name|size_t
parameter_list|,
name|htab_hash
parameter_list|,
name|htab_eq
parameter_list|,
name|htab_del
parameter_list|,
name|htab_alloc
parameter_list|,
name|htab_free
parameter_list|)
function_decl|;
specifier|extern
name|htab_t
name|htab_create_alloc_ex
parameter_list|(
name|size_t
parameter_list|,
name|htab_hash
parameter_list|,
name|htab_eq
parameter_list|,
name|htab_del
parameter_list|,
name|void
modifier|*
parameter_list|,
name|htab_alloc_with_arg
parameter_list|,
name|htab_free_with_arg
parameter_list|)
function_decl|;
comment|/* Backward-compatibility functions.  */
specifier|extern
name|htab_t
name|htab_create
parameter_list|(
name|size_t
parameter_list|,
name|htab_hash
parameter_list|,
name|htab_eq
parameter_list|,
name|htab_del
parameter_list|)
function_decl|;
specifier|extern
name|htab_t
name|htab_try_create
parameter_list|(
name|size_t
parameter_list|,
name|htab_hash
parameter_list|,
name|htab_eq
parameter_list|,
name|htab_del
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_set_functions_ex
parameter_list|(
name|htab_t
parameter_list|,
name|htab_hash
parameter_list|,
name|htab_eq
parameter_list|,
name|htab_del
parameter_list|,
name|void
modifier|*
parameter_list|,
name|htab_alloc_with_arg
parameter_list|,
name|htab_free_with_arg
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_delete
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_empty
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|htab_find
parameter_list|(
name|htab_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
modifier|*
name|htab_find_slot
parameter_list|(
name|htab_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|enum
name|insert_option
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|htab_find_with_hash
parameter_list|(
name|htab_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|hashval_t
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
modifier|*
name|htab_find_slot_with_hash
parameter_list|(
name|htab_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|hashval_t
parameter_list|,
name|enum
name|insert_option
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_clear_slot
parameter_list|(
name|htab_t
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_remove_elt
parameter_list|(
name|htab_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_remove_elt_with_hash
parameter_list|(
name|htab_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|hashval_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_traverse
parameter_list|(
name|htab_t
parameter_list|,
name|htab_trav
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|htab_traverse_noresize
parameter_list|(
name|htab_t
parameter_list|,
name|htab_trav
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|size_t
name|htab_size
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
specifier|extern
name|size_t
name|htab_elements
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
specifier|extern
name|double
name|htab_collisions
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
comment|/* A hash function for pointers.  */
specifier|extern
name|htab_hash
name|htab_hash_pointer
decl_stmt|;
comment|/* An equality function for pointers.  */
specifier|extern
name|htab_eq
name|htab_eq_pointer
decl_stmt|;
comment|/* A hash function for null-terminated strings.  */
specifier|extern
name|hashval_t
name|htab_hash_string
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* An iterative hash function for arbitrary data.  */
specifier|extern
name|hashval_t
name|iterative_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|hashval_t
parameter_list|)
function_decl|;
comment|/* Shorthand for hashing something with an intrinsic size.  */
define|#
directive|define
name|iterative_hash_object
parameter_list|(
name|OB
parameter_list|,
name|INIT
parameter_list|)
value|iterative_hash (&OB, sizeof (OB), INIT)
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __HASHTAB_H */
end_comment

end_unit

