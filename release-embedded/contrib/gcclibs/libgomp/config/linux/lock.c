begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This is a Linux specific implementation of the public OpenMP locking    primitives.  This implementation uses atomic instructions and the futex    syscall.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|"futex.h"
end_include

begin_comment
comment|/* The internal gomp_mutex_t and the external non-recursive omp_lock_t    have the same form.  Re-use it.  */
end_comment

begin_function
name|void
name|omp_init_lock
parameter_list|(
name|omp_lock_t
modifier|*
name|lock
parameter_list|)
block|{
name|gomp_mutex_init
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|omp_destroy_lock
parameter_list|(
name|omp_lock_t
modifier|*
name|lock
parameter_list|)
block|{
name|gomp_mutex_destroy
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|omp_set_lock
parameter_list|(
name|omp_lock_t
modifier|*
name|lock
parameter_list|)
block|{
name|gomp_mutex_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|omp_unset_lock
parameter_list|(
name|omp_lock_t
modifier|*
name|lock
parameter_list|)
block|{
name|gomp_mutex_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|omp_test_lock
parameter_list|(
name|omp_lock_t
modifier|*
name|lock
parameter_list|)
block|{
return|return
name|__sync_bool_compare_and_swap
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The external recursive omp_nest_lock_t form requires additional work.  */
end_comment

begin_comment
comment|/* We need an integer to uniquely identify this thread.  Most generally    this is the thread's TID, which ideally we'd get this straight from    the TLS block where glibc keeps it.  Unfortunately, we can't get at    that directly.     If we don't support (or have disabled) TLS, one function call is as    good (or bad) as any other.  Use the syscall all the time.     On an ILP32 system (defined here as not LP64), we can make do with    any thread-local pointer.  Ideally we'd use the TLS base address,    since that requires the least amount of arithmetic, but that's not    always available directly.  Make do with the gomp_thread pointer    since it's handy.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_TLS
argument_list|)
end_if

begin_function
specifier|static
specifier|inline
name|int
name|gomp_tid
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|syscall
argument_list|(
name|SYS_gettid
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|__LP64__
argument_list|)
end_elif

begin_function
specifier|static
specifier|inline
name|int
name|gomp_tid
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|gomp_thread
argument_list|()
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|__thread
name|int
name|tid_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|gomp_tid
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|tid
init|=
name|tid_cache
decl_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|tid
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|tid_cache
operator|=
name|tid
operator|=
name|syscall
argument_list|(
name|SYS_gettid
argument_list|)
expr_stmt|;
return|return
name|tid
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|omp_init_nest_lock
parameter_list|(
name|omp_nest_lock_t
modifier|*
name|lock
parameter_list|)
block|{
name|memset
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|omp_destroy_nest_lock
parameter_list|(
name|omp_nest_lock_t
modifier|*
name|lock
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|omp_set_nest_lock
parameter_list|(
name|omp_nest_lock_t
modifier|*
name|lock
parameter_list|)
block|{
name|int
name|otid
decl_stmt|,
name|tid
init|=
name|gomp_tid
argument_list|()
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|otid
operator|=
name|__sync_val_compare_and_swap
argument_list|(
operator|&
name|lock
operator|->
name|owner
argument_list|,
literal|0
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|otid
operator|==
literal|0
condition|)
block|{
name|lock
operator|->
name|count
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|otid
operator|==
name|tid
condition|)
block|{
name|lock
operator|->
name|count
operator|++
expr_stmt|;
return|return;
block|}
name|futex_wait
argument_list|(
operator|&
name|lock
operator|->
name|owner
argument_list|,
name|otid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|omp_unset_nest_lock
parameter_list|(
name|omp_nest_lock_t
modifier|*
name|lock
parameter_list|)
block|{
comment|/* ??? Validate that we own the lock here.  */
if|if
condition|(
operator|--
name|lock
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|__sync_lock_release
argument_list|(
operator|&
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
name|futex_wake
argument_list|(
operator|&
name|lock
operator|->
name|owner
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|omp_test_nest_lock
parameter_list|(
name|omp_nest_lock_t
modifier|*
name|lock
parameter_list|)
block|{
name|int
name|otid
decl_stmt|,
name|tid
init|=
name|gomp_tid
argument_list|()
decl_stmt|;
name|otid
operator|=
name|__sync_val_compare_and_swap
argument_list|(
operator|&
name|lock
operator|->
name|owner
argument_list|,
literal|0
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|otid
operator|==
literal|0
condition|)
block|{
name|lock
operator|->
name|count
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|otid
operator|==
name|tid
condition|)
return|return
operator|++
name|lock
operator|->
name|count
return|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|ialias
argument_list|(
argument|omp_init_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_init_nest_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_destroy_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_destroy_nest_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_set_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_set_nest_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_unset_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_unset_nest_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_test_lock
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_test_nest_lock
argument_list|)
end_macro

end_unit

