begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file defines the OpenMP internal control variables, and arranges    for them to be initialized from environment variables at startup.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|"libgomp_f.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
name|unsigned
name|long
name|gomp_nthreads_var
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|gomp_dyn_var
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|gomp_nest_var
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|gomp_schedule_type
name|gomp_run_sched_var
init|=
name|GFS_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|gomp_run_sched_chunk
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the OMP_SCHEDULE environment variable.  */
end_comment

begin_function
specifier|static
name|void
name|parse_schedule
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"OMP_SCHEDULE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"static"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gomp_run_sched_var
operator|=
name|GFS_STATIC
expr_stmt|;
name|env
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"dynamic"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gomp_run_sched_var
operator|=
name|GFS_DYNAMIC
expr_stmt|;
name|env
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"guided"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gomp_run_sched_var
operator|=
name|GFS_GUIDED
expr_stmt|;
name|env
operator|+=
literal|6
expr_stmt|;
block|}
else|else
goto|goto
name|unknown
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
operator|*
name|env
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|unknown
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|strtoul
argument_list|(
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
goto|goto
name|invalid
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
argument_list|)
condition|)
operator|++
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
name|gomp_run_sched_chunk
operator|=
name|value
expr_stmt|;
return|return;
name|unknown
label|:
name|gomp_error
argument_list|(
literal|"Unknown value for environment variable OMP_SCHEDULE"
argument_list|)
expr_stmt|;
return|return;
name|invalid
label|:
name|gomp_error
argument_list|(
literal|"Invalid value for chunk size in "
literal|"environment variable OMP_SCHEDULE"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse an unsigned long environment varible.  Return true if one was    present and it was successfully parsed.  */
end_comment

begin_function
specifier|static
name|bool
name|parse_unsigned_long
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|long
modifier|*
name|pvalue
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return
name|false
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|strtoul
argument_list|(
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|(
name|long
operator|)
name|value
operator|<=
literal|0
condition|)
goto|goto
name|invalid
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
argument_list|)
condition|)
operator|++
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
operator|*
name|pvalue
operator|=
name|value
expr_stmt|;
return|return
name|true
return|;
name|invalid
label|:
name|gomp_error
argument_list|(
literal|"Invalid value for environment variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Parse a boolean value for environment variable NAME and store the     result in VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|parse_boolean
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"true"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|value
operator|=
name|true
expr_stmt|;
name|env
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"false"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|value
operator|=
name|false
expr_stmt|;
name|env
operator|+=
literal|5
expr_stmt|;
block|}
else|else
name|env
operator|=
literal|"X"
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|!=
literal|'\0'
condition|)
name|gomp_error
argument_list|(
literal|"Invalid value for environment variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|constructor
operator|)
argument_list|)
name|initialize_env
argument_list|(
name|void
argument_list|)
block|{
name|unsigned
name|long
name|stacksize
decl_stmt|;
comment|/* Do a compile time check that mkomp_h.pl did good job.  */
name|omp_check_defines
argument_list|()
expr_stmt|;
name|parse_schedule
argument_list|()
expr_stmt|;
name|parse_boolean
argument_list|(
literal|"OMP_DYNAMIC"
argument_list|,
operator|&
name|gomp_dyn_var
argument_list|)
expr_stmt|;
name|parse_boolean
argument_list|(
literal|"OMP_NESTED"
argument_list|,
operator|&
name|gomp_nest_var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_unsigned_long
argument_list|(
literal|"OMP_NUM_THREADS"
argument_list|,
operator|&
name|gomp_nthreads_var
argument_list|)
condition|)
name|gomp_init_num_threads
argument_list|()
expr_stmt|;
comment|/* Not strictly environment related, but ordering constructors is tricky.  */
name|pthread_attr_init
argument_list|(
operator|&
name|gomp_thread_attr
argument_list|)
expr_stmt|;
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|gomp_thread_attr
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_unsigned_long
argument_list|(
literal|"GOMP_STACKSIZE"
argument_list|,
operator|&
name|stacksize
argument_list|)
condition|)
block|{
name|int
name|err
decl_stmt|;
name|stacksize
operator|*=
literal|1024
expr_stmt|;
name|err
operator|=
name|pthread_attr_setstacksize
argument_list|(
operator|&
name|gomp_thread_attr
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTHREAD_STACK_MIN
if|if
condition|(
name|err
operator|==
name|EINVAL
condition|)
block|{
if|if
condition|(
name|stacksize
operator|<
name|PTHREAD_STACK_MIN
condition|)
name|gomp_error
argument_list|(
literal|"Stack size less than minimum of %luk"
argument_list|,
name|PTHREAD_STACK_MIN
operator|/
literal|1024ul
operator|+
operator|(
name|PTHREAD_STACK_MIN
operator|%
literal|1024
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
else|else
name|gomp_error
argument_list|(
literal|"Stack size larger than system limit"
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|gomp_error
argument_list|(
literal|"Stack size change failed: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The public OpenMP API routines that access these variables.  */
end_comment

begin_function
name|void
name|omp_set_num_threads
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|gomp_nthreads_var
operator|=
operator|(
name|n
operator|>
literal|0
condition|?
name|n
else|:
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|omp_set_dynamic
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|gomp_dyn_var
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|int
name|omp_get_dynamic
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gomp_dyn_var
return|;
block|}
end_function

begin_function
name|void
name|omp_set_nested
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|gomp_nest_var
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|int
name|omp_get_nested
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gomp_nest_var
return|;
block|}
end_function

begin_macro
name|ialias
argument_list|(
argument|omp_set_dynamic
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_set_nested
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_set_num_threads
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_get_dynamic
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_get_nested
argument_list|)
end_macro

end_unit

