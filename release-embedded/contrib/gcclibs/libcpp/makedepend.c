begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dependency generator utility.    Copyright (C) 2004 Free Software Foundation, Inc.    Contributed by Zack Weinberg, May 2004  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"line-map.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|vpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|had_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Option lists, to give to cpplib before each input file.  */
end_comment

begin_struct
struct|struct
name|cmd_line_macro
block|{
name|struct
name|cmd_line_macro
modifier|*
name|next
decl_stmt|;
name|bool
name|is_undef
decl_stmt|;
specifier|const
name|char
modifier|*
name|macro
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cmd_line_macro
modifier|*
name|cmd_line_macros
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_dir
modifier|*
name|cmd_line_searchpath
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_clm
parameter_list|(
specifier|const
name|char
modifier|*
name|macro
parameter_list|,
name|bool
name|is_undef
parameter_list|)
block|{
name|struct
name|cmd_line_macro
modifier|*
name|clm
init|=
name|XNEW
argument_list|(
expr|struct
name|cmd_line_macro
argument_list|)
decl_stmt|;
name|clm
operator|->
name|next
operator|=
name|cmd_line_macros
expr_stmt|;
name|clm
operator|->
name|is_undef
operator|=
name|is_undef
expr_stmt|;
name|clm
operator|->
name|macro
operator|=
name|macro
expr_stmt|;
name|cmd_line_macros
operator|=
name|clm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_dir
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|sysp
parameter_list|)
block|{
name|cpp_dir
modifier|*
name|dir
init|=
name|XNEW
argument_list|(
name|cpp_dir
argument_list|)
decl_stmt|;
name|dir
operator|->
name|next
operator|=
name|cmd_line_searchpath
expr_stmt|;
name|dir
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|dir
operator|->
name|sysp
operator|=
name|sysp
expr_stmt|;
name|dir
operator|->
name|construct
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|user_supplied_p
operator|=
literal|1
expr_stmt|;
name|cmd_line_searchpath
operator|=
name|dir
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command line processing.  */
end_comment

begin_function
specifier|static
name|void
name|ATTRIBUTE_NORETURN
name|usage
parameter_list|(
name|int
name|errcode
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-vh] [-V vpath] [-Dname[=def]...] [-Uname] [-Idir...] [-o file] sources...\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_options
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"--help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hD:U:I:J:o:V:"
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'h'
case|:
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'D'
case|:
name|add_clm
argument_list|(
name|optarg
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|add_clm
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|add_dir
argument_list|(
name|optarg
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|add_dir
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|output_file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: too many output files\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|output_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|vpath
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: too many vpaths\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|vpath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* getopt has issued the error message.  */
case|case
operator|-
literal|1
case|:
comment|/* end of options */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no input files\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|optind
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up cpplib from command line options.  */
end_comment

begin_function
specifier|static
name|cpp_reader
modifier|*
name|reader_init
parameter_list|(
name|struct
name|line_maps
modifier|*
name|line_table
parameter_list|)
block|{
name|cpp_reader
modifier|*
name|reader
decl_stmt|;
name|cpp_options
modifier|*
name|options
decl_stmt|;
name|linemap_init
argument_list|(
name|line_table
argument_list|)
expr_stmt|;
name|reader
operator|=
name|cpp_create_reader
argument_list|(
name|CLK_GNUC89
argument_list|,
literal|0
argument_list|,
name|line_table
argument_list|)
expr_stmt|;
comment|/* Ignore warnings and errors (we don't have access to system      headers).  Request dependency output.  */
name|options
operator|=
name|cpp_get_options
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|options
operator|->
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
name|options
operator|->
name|inhibit_errors
operator|=
literal|1
expr_stmt|;
name|options
operator|->
name|deps
operator|.
name|style
operator|=
name|DEPS_USER
expr_stmt|;
comment|/* Further initialization.  */
name|cpp_post_options
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|cpp_init_iconv
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|cpp_set_include_chains
argument_list|(
name|reader
argument_list|,
name|cmd_line_searchpath
argument_list|,
name|cmd_line_searchpath
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpath
condition|)
block|{
name|struct
name|deps
modifier|*
name|deps
init|=
name|cpp_get_deps
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|deps_add_vpath
argument_list|(
name|deps
argument_list|,
name|vpath
argument_list|)
expr_stmt|;
block|}
return|return
name|reader
return|;
block|}
end_function

begin_comment
comment|/* Process one input source file.  */
end_comment

begin_function
specifier|static
name|void
name|process_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|line_maps
name|line_table
decl_stmt|;
name|cpp_reader
modifier|*
name|reader
init|=
name|reader_init
argument_list|(
operator|&
name|line_table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cpp_read_main_file
argument_list|(
name|reader
argument_list|,
name|file
argument_list|)
condition|)
name|had_errors
operator|=
name|true
expr_stmt|;
else|else
block|{
name|struct
name|cmd_line_macro
modifier|*
name|clm
decl_stmt|;
name|cpp_init_builtins
argument_list|(
name|reader
argument_list|,
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|clm
operator|=
name|cmd_line_macros
init|;
name|clm
condition|;
name|clm
operator|=
name|clm
operator|->
name|next
control|)
operator|(
name|clm
operator|->
name|is_undef
condition|?
name|cpp_undef
else|:
name|cpp_define
operator|)
operator|(
name|reader
operator|,
name|clm
operator|->
name|macro
operator|)
expr_stmt|;
name|cpp_scan_nooutput
argument_list|(
name|reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_finish
argument_list|(
name|reader
argument_list|,
name|stdout
argument_list|)
condition|)
name|had_errors
operator|=
name|true
expr_stmt|;
block|}
name|cpp_destroy
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|linemap_free
argument_list|(
operator|&
name|line_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Master control.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|first_input
decl_stmt|,
name|i
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|first_input
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
condition|)
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|output_file
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|process_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|had_errors
return|;
block|}
end_function

end_unit

