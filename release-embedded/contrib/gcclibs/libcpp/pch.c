begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  (Precompiled header reading/writing.)    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_function_decl
specifier|static
name|int
name|write_macdef
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_idents
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|hashmem
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|cpp_string_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpp_string_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_defs
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_hashnodes
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collect_ht_nodes
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_defs
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_macros
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This structure represents a macro definition on disk.  */
end_comment

begin_struct
struct|struct
name|macrodef_struct
block|{
name|unsigned
name|int
name|definition_length
decl_stmt|;
name|unsigned
name|short
name|name_length
decl_stmt|;
name|unsigned
name|short
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is how we write out a macro definition.    Suitable for being called by cpp_forall_identifiers.  */
end_comment

begin_function
specifier|static
name|int
name|write_macdef
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|hn
parameter_list|,
name|void
modifier|*
name|file_p
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
operator|(
name|FILE
operator|*
operator|)
name|file_p
decl_stmt|;
switch|switch
condition|(
name|hn
operator|->
name|type
condition|)
block|{
case|case
name|NT_VOID
case|:
if|if
condition|(
operator|!
operator|(
name|hn
operator|->
name|flags
operator|&
name|NODE_POISONED
operator|)
condition|)
return|return
literal|1
return|;
case|case
name|NT_MACRO
case|:
if|if
condition|(
operator|(
name|hn
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
return|return
literal|1
return|;
block|{
name|struct
name|macrodef_struct
name|s
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|defn
decl_stmt|;
name|s
operator|.
name|name_length
operator|=
name|NODE_LEN
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|s
operator|.
name|flags
operator|=
name|hn
operator|->
name|flags
operator|&
name|NODE_POISONED
expr_stmt|;
if|if
condition|(
name|hn
operator|->
name|type
operator|==
name|NT_MACRO
condition|)
block|{
name|defn
operator|=
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|s
operator|.
name|definition_length
operator|=
name|ustrlen
argument_list|(
name|defn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defn
operator|=
name|NODE_NAME
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|s
operator|.
name|definition_length
operator|=
name|s
operator|.
name|name_length
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|defn
argument_list|,
literal|1
argument_list|,
name|s
operator|.
name|definition_length
argument_list|,
name|f
argument_list|)
operator|!=
name|s
operator|.
name|definition_length
condition|)
block|{
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"while writing precompiled header"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
case|case
name|NT_ASSERTION
case|:
comment|/* Not currently implemented.  */
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This structure records the names of the defined macros.    It's also used as a callback structure for size_initial_idents    and save_idents.  */
end_comment

begin_struct
struct|struct
name|cpp_savedstate
block|{
comment|/* A hash table of the defined identifiers.  */
name|htab_t
name|definedhash
decl_stmt|;
comment|/* The size of the definitions of those identifiers (the size of      'definedstrs').  */
name|size_t
name|hashsize
decl_stmt|;
comment|/* Number of definitions */
name|size_t
name|n_defs
decl_stmt|;
comment|/* Array of definitions.  In cpp_write_pch_deps it is used for sorting.  */
name|cpp_hashnode
modifier|*
modifier|*
name|defs
decl_stmt|;
comment|/* Space for the next definition.  Definitions are null-terminated      strings.  */
name|unsigned
name|char
modifier|*
name|definedstrs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Save this identifier into the state: put it in the hash table,    put the definition in 'definedstrs'.  */
end_comment

begin_function
specifier|static
name|int
name|save_idents
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cpp_hashnode
modifier|*
name|hn
parameter_list|,
name|void
modifier|*
name|ss_p
parameter_list|)
block|{
name|struct
name|cpp_savedstate
modifier|*
specifier|const
name|ss
init|=
operator|(
expr|struct
name|cpp_savedstate
operator|*
operator|)
name|ss_p
decl_stmt|;
if|if
condition|(
name|hn
operator|->
name|type
operator|!=
name|NT_VOID
condition|)
block|{
name|struct
name|cpp_string
name|news
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|news
operator|.
name|len
operator|=
name|NODE_LEN
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|news
operator|.
name|text
operator|=
name|NODE_NAME
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|ss
operator|->
name|definedhash
argument_list|,
operator|&
name|news
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|struct
name|cpp_string
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|text
decl_stmt|;
name|sp
operator|=
name|XNEW
argument_list|(
expr|struct
name|cpp_string
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|len
operator|=
name|NODE_LEN
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|sp
operator|->
name|text
operator|=
name|text
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|NODE_LEN (hn)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|text
argument_list|,
name|NODE_NAME
argument_list|(
name|hn
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|hn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hash some memory in a generic way.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hashmem
parameter_list|(
specifier|const
name|void
modifier|*
name|p_p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p_p
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|hashval_t
name|h
decl_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
name|h
operator|=
name|h
operator|*
literal|67
operator|-
operator|(
operator|*
name|p
operator|++
operator|-
literal|113
operator|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Hash a cpp string for the hashtable machinery.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|cpp_string_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|a_p
parameter_list|)
block|{
specifier|const
name|struct
name|cpp_string
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|cpp_string
operator|*
operator|)
name|a_p
decl_stmt|;
return|return
name|hashmem
argument_list|(
name|a
operator|->
name|text
argument_list|,
name|a
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two cpp strings for the hashtable machinery.  */
end_comment

begin_function
specifier|static
name|int
name|cpp_string_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|a_p
parameter_list|,
specifier|const
name|void
modifier|*
name|b_p
parameter_list|)
block|{
specifier|const
name|struct
name|cpp_string
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|cpp_string
operator|*
operator|)
name|a_p
decl_stmt|;
specifier|const
name|struct
name|cpp_string
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|cpp_string
operator|*
operator|)
name|b_p
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|len
operator|==
name|b
operator|->
name|len
operator|&&
name|memcmp
argument_list|(
name|a
operator|->
name|text
argument_list|,
name|b
operator|->
name|text
argument_list|,
name|a
operator|->
name|len
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Save the current definitions of the cpp_reader for dependency    checking purposes.  When writing a precompiled header, this should    be called at the same point in the compilation as cpp_valid_state    would be called when reading the precompiled header back in.  */
end_comment

begin_function
name|int
name|cpp_save_state
parameter_list|(
name|cpp_reader
modifier|*
name|r
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
comment|/* Save the list of non-void identifiers for the dependency checking.  */
name|r
operator|->
name|savedstate
operator|=
name|XNEW
argument_list|(
expr|struct
name|cpp_savedstate
argument_list|)
expr_stmt|;
name|r
operator|->
name|savedstate
operator|->
name|definedhash
operator|=
name|htab_create
argument_list|(
literal|100
argument_list|,
name|cpp_string_hash
argument_list|,
name|cpp_string_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp_forall_identifiers
argument_list|(
name|r
argument_list|,
name|save_idents
argument_list|,
name|r
operator|->
name|savedstate
argument_list|)
expr_stmt|;
comment|/* Write out the list of defined identifiers.  */
name|cpp_forall_identifiers
argument_list|(
name|r
argument_list|,
name|write_macdef
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Calculate the 'hashsize' field of the saved state.  */
end_comment

begin_function
specifier|static
name|int
name|count_defs
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cpp_hashnode
modifier|*
name|hn
parameter_list|,
name|void
modifier|*
name|ss_p
parameter_list|)
block|{
name|struct
name|cpp_savedstate
modifier|*
specifier|const
name|ss
init|=
operator|(
expr|struct
name|cpp_savedstate
operator|*
operator|)
name|ss_p
decl_stmt|;
switch|switch
condition|(
name|hn
operator|->
name|type
condition|)
block|{
case|case
name|NT_MACRO
case|:
if|if
condition|(
name|hn
operator|->
name|flags
operator|&
name|NODE_BUILTIN
condition|)
return|return
literal|1
return|;
comment|/* else fall through.  */
case|case
name|NT_VOID
case|:
block|{
name|struct
name|cpp_string
name|news
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|news
operator|.
name|len
operator|=
name|NODE_LEN
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|news
operator|.
name|text
operator|=
name|NODE_NAME
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|htab_find
argument_list|(
name|ss
operator|->
name|definedhash
argument_list|,
operator|&
name|news
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
block|{
name|ss
operator|->
name|hashsize
operator|+=
name|NODE_LEN
argument_list|(
name|hn
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ss
operator|->
name|n_defs
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
case|case
name|NT_ASSERTION
case|:
comment|/* Not currently implemented.  */
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Collect the identifiers into the state's string table.  */
end_comment

begin_function
specifier|static
name|int
name|write_defs
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cpp_hashnode
modifier|*
name|hn
parameter_list|,
name|void
modifier|*
name|ss_p
parameter_list|)
block|{
name|struct
name|cpp_savedstate
modifier|*
specifier|const
name|ss
init|=
operator|(
expr|struct
name|cpp_savedstate
operator|*
operator|)
name|ss_p
decl_stmt|;
switch|switch
condition|(
name|hn
operator|->
name|type
condition|)
block|{
case|case
name|NT_MACRO
case|:
if|if
condition|(
name|hn
operator|->
name|flags
operator|&
name|NODE_BUILTIN
condition|)
return|return
literal|1
return|;
comment|/* else fall through.  */
case|case
name|NT_VOID
case|:
block|{
name|struct
name|cpp_string
name|news
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|news
operator|.
name|len
operator|=
name|NODE_LEN
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|news
operator|.
name|text
operator|=
name|NODE_NAME
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|htab_find
argument_list|(
name|ss
operator|->
name|definedhash
argument_list|,
operator|&
name|news
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
block|{
name|ss
operator|->
name|defs
index|[
name|ss
operator|->
name|n_defs
index|]
operator|=
name|hn
expr_stmt|;
name|ss
operator|->
name|n_defs
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
case|case
name|NT_ASSERTION
case|:
comment|/* Not currently implemented.  */
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Comparison function for qsort.  The arguments point to pointers of    type ht_hashnode *.  */
end_comment

begin_function
specifier|static
name|int
name|comp_hashnodes
parameter_list|(
specifier|const
name|void
modifier|*
name|px
parameter_list|,
specifier|const
name|void
modifier|*
name|py
parameter_list|)
block|{
name|cpp_hashnode
modifier|*
name|x
init|=
operator|*
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|px
decl_stmt|;
name|cpp_hashnode
modifier|*
name|y
init|=
operator|*
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|py
decl_stmt|;
return|return
name|ustrcmp
argument_list|(
name|NODE_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|NODE_NAME
argument_list|(
name|y
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the remainder of the dependency information.  This should be    called after the PCH is ready to be saved.  */
end_comment

begin_function
name|int
name|cpp_write_pch_deps
parameter_list|(
name|cpp_reader
modifier|*
name|r
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|macrodef_struct
name|z
decl_stmt|;
name|struct
name|cpp_savedstate
modifier|*
specifier|const
name|ss
init|=
name|r
operator|->
name|savedstate
decl_stmt|;
name|unsigned
name|char
modifier|*
name|definedstrs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* Collect the list of identifiers which have been seen and      weren't defined to anything previously.  */
name|ss
operator|->
name|hashsize
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|n_defs
operator|=
literal|0
expr_stmt|;
name|cpp_forall_identifiers
argument_list|(
name|r
argument_list|,
name|count_defs
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|ss
operator|->
name|defs
operator|=
name|XNEWVEC
argument_list|(
name|cpp_hashnode
operator|*
argument_list|,
name|ss
operator|->
name|n_defs
argument_list|)
expr_stmt|;
name|ss
operator|->
name|n_defs
operator|=
literal|0
expr_stmt|;
name|cpp_forall_identifiers
argument_list|(
name|r
argument_list|,
name|write_defs
argument_list|,
name|ss
argument_list|)
expr_stmt|;
comment|/* Sort the list, copy it into a buffer, and write it out.  */
name|qsort
argument_list|(
name|ss
operator|->
name|defs
argument_list|,
name|ss
operator|->
name|n_defs
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
argument_list|,
operator|&
name|comp_hashnodes
argument_list|)
expr_stmt|;
name|definedstrs
operator|=
name|ss
operator|->
name|definedstrs
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|ss->hashsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
operator|->
name|n_defs
condition|;
operator|++
name|i
control|)
block|{
name|size_t
name|len
init|=
name|NODE_LEN
argument_list|(
name|ss
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|definedstrs
argument_list|,
name|NODE_NAME
argument_list|(
name|ss
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|definedstrs
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|z
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|.
name|definition_length
operator|=
name|ss
operator|->
name|hashsize
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|ss
operator|->
name|definedstrs
argument_list|,
name|ss
operator|->
name|hashsize
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|cpp_errno
argument_list|(
name|r
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"while writing precompiled header"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|free
argument_list|(
name|ss
operator|->
name|definedstrs
argument_list|)
expr_stmt|;
comment|/* Free the saved state.  */
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|r
operator|->
name|savedstate
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out the definitions of the preprocessor, in a form suitable for    cpp_read_state.  */
end_comment

begin_function
name|int
name|cpp_write_pch_state
parameter_list|(
name|cpp_reader
modifier|*
name|r
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|deps
condition|)
name|r
operator|->
name|deps
operator|=
name|deps_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|deps_save
argument_list|(
name|r
operator|->
name|deps
argument_list|,
name|f
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cpp_errno
argument_list|(
name|r
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"while writing precompiled header"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|_cpp_save_file_entries
argument_list|(
name|r
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|cpp_errno
argument_list|(
name|r
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"while writing precompiled header"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Data structure to transform hash table nodes into a sorted list */
end_comment

begin_struct
struct|struct
name|ht_node_list
block|{
comment|/* Array of nodes */
name|cpp_hashnode
modifier|*
modifier|*
name|defs
decl_stmt|;
comment|/* Number of nodes in the array */
name|size_t
name|n_defs
decl_stmt|;
comment|/* Size of the allocated array */
name|size_t
name|asize
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback for collecting identifiers from hash table */
end_comment

begin_function
specifier|static
name|int
name|collect_ht_nodes
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cpp_hashnode
modifier|*
name|hn
parameter_list|,
name|void
modifier|*
name|nl_p
parameter_list|)
block|{
name|struct
name|ht_node_list
modifier|*
specifier|const
name|nl
init|=
operator|(
expr|struct
name|ht_node_list
operator|*
operator|)
name|nl_p
decl_stmt|;
if|if
condition|(
name|hn
operator|->
name|type
operator|!=
name|NT_VOID
operator|||
name|hn
operator|->
name|flags
operator|&
name|NODE_POISONED
condition|)
block|{
if|if
condition|(
name|nl
operator|->
name|n_defs
operator|==
name|nl
operator|->
name|asize
condition|)
block|{
name|nl
operator|->
name|asize
operator|*=
literal|2
expr_stmt|;
name|nl
operator|->
name|defs
operator|=
name|XRESIZEVEC
argument_list|(
name|cpp_hashnode
operator|*
argument_list|,
name|nl
operator|->
name|defs
argument_list|,
name|nl
operator|->
name|asize
argument_list|)
expr_stmt|;
block|}
name|nl
operator|->
name|defs
index|[
name|nl
operator|->
name|n_defs
index|]
operator|=
name|hn
expr_stmt|;
operator|++
name|nl
operator|->
name|n_defs
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FD is a precompiled header which is consistent    with the preprocessor's current definitions.  It will be consistent    when:     - anything that was defined just before the PCH was generated      is defined the same way now; and    - anything that was not defined then, but is defined now, was not      used by the PCH.     NAME is used to print warnings if `warn_invalid_pch' is set in the    reader's flags. */
end_comment

begin_function
name|int
name|cpp_valid_state
parameter_list|(
name|cpp_reader
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|macrodef_struct
name|m
decl_stmt|;
name|size_t
name|namebufsz
init|=
literal|256
decl_stmt|;
name|unsigned
name|char
modifier|*
name|namebuf
init|=
name|XNEWVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|namebufsz
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|undeftab
init|=
name|NULL
decl_stmt|;
name|struct
name|ht_node_list
name|nl
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|unsigned
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Read in the list of identifiers that must be defined      Check that they are defined in the same way.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_hashnode
modifier|*
name|h
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|newdefn
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|m
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|m
operator|.
name|name_length
operator|==
literal|0
condition|)
break|break;
comment|/* If this file is already preprocessed, there won't be any 	 macros defined, and that's OK.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|r
argument_list|,
name|preprocessed
argument_list|)
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|m
operator|.
name|definition_length
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
continue|continue;
block|}
if|if
condition|(
name|m
operator|.
name|definition_length
operator|>
name|namebufsz
condition|)
block|{
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|namebufsz
operator|=
name|m
operator|.
name|definition_length
operator|+
literal|256
expr_stmt|;
name|namebuf
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|namebufsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|namebuf
argument_list|,
name|m
operator|.
name|definition_length
argument_list|)
operator|!=
name|m
operator|.
name|definition_length
condition|)
goto|goto
name|error
goto|;
name|h
operator|=
name|cpp_lookup
argument_list|(
name|r
argument_list|,
name|namebuf
argument_list|,
name|m
operator|.
name|name_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|flags
operator|&
name|NODE_POISONED
operator|||
name|h
operator|->
name|type
operator|!=
name|NT_MACRO
operator|||
name|h
operator|->
name|flags
operator|&
name|NODE_POISONED
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|r
argument_list|,
name|warn_invalid_pch
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|r
argument_list|,
name|CPP_DL_WARNING_SYSHDR
argument_list|,
literal|"%s: not used because `%.*s' not defined"
argument_list|,
name|name
argument_list|,
name|m
operator|.
name|name_length
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|newdefn
operator|=
name|cpp_macro_definition
argument_list|(
name|r
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|definition_length
operator|!=
name|ustrlen
argument_list|(
name|newdefn
argument_list|)
operator|||
name|memcmp
argument_list|(
name|namebuf
argument_list|,
name|newdefn
argument_list|,
name|m
operator|.
name|definition_length
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|r
argument_list|,
name|warn_invalid_pch
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|r
argument_list|,
name|CPP_DL_WARNING_SYSHDR
argument_list|,
literal|"%s: not used because `%.*s' defined as `%s' not `%.*s'"
argument_list|,
name|name
argument_list|,
name|m
operator|.
name|name_length
argument_list|,
name|namebuf
argument_list|,
name|newdefn
operator|+
name|m
operator|.
name|name_length
argument_list|,
name|m
operator|.
name|definition_length
operator|-
name|m
operator|.
name|name_length
argument_list|,
name|namebuf
operator|+
name|m
operator|.
name|name_length
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|namebuf
operator|=
name|NULL
expr_stmt|;
comment|/* Read in the list of identifiers that must not be defined.      Check that they really aren't.  */
name|undeftab
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|m.definition_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|undeftab
argument_list|,
name|m
operator|.
name|definition_length
argument_list|)
operator|!=
name|m
operator|.
name|definition_length
condition|)
goto|goto
name|error
goto|;
comment|/* Collect identifiers from the current hash table.  */
name|nl
operator|.
name|n_defs
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|asize
operator|=
literal|10
expr_stmt|;
name|nl
operator|.
name|defs
operator|=
name|XNEWVEC
argument_list|(
name|cpp_hashnode
operator|*
argument_list|,
name|nl
operator|.
name|asize
argument_list|)
expr_stmt|;
name|cpp_forall_identifiers
argument_list|(
name|r
argument_list|,
operator|&
name|collect_ht_nodes
argument_list|,
operator|&
name|nl
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|nl
operator|.
name|defs
argument_list|,
name|nl
operator|.
name|n_defs
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
argument_list|,
operator|&
name|comp_hashnodes
argument_list|)
expr_stmt|;
comment|/* Loop through nl.defs and undeftab, both of which are sorted lists.      There should be no matches.  */
name|first
operator|=
name|undeftab
expr_stmt|;
name|last
operator|=
name|undeftab
operator|+
name|m
operator|.
name|definition_length
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|first
operator|<
name|last
operator|&&
name|i
operator|<
name|nl
operator|.
name|n_defs
condition|)
block|{
name|int
name|cmp
init|=
name|ustrcmp
argument_list|(
name|first
argument_list|,
name|NODE_NAME
argument_list|(
name|nl
operator|.
name|defs
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|first
operator|+=
name|ustrlen
argument_list|(
name|first
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
operator|++
name|i
expr_stmt|;
else|else
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|r
argument_list|,
name|warn_invalid_pch
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|r
argument_list|,
name|CPP_DL_WARNING_SYSHDR
argument_list|,
literal|"%s: not used because `%s' is defined"
argument_list|,
name|name
argument_list|,
name|first
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|free
argument_list|(
name|nl
operator|.
name|defs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|undeftab
argument_list|)
expr_stmt|;
comment|/* We win!  */
return|return
literal|0
return|;
name|error
label|:
name|cpp_errno
argument_list|(
name|r
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"while reading precompiled header"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|fail
label|:
if|if
condition|(
name|namebuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|undeftab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|undeftab
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|.
name|defs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nl
operator|.
name|defs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Save all the existing macros.  */
end_comment

begin_struct
struct|struct
name|save_macro_data
block|{
name|uchar
modifier|*
modifier|*
name|defns
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|size_t
name|array_size
decl_stmt|;
name|char
modifier|*
modifier|*
name|saved_pragmas
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Save the definition of a single macro, so that it will persist    across a PCH restore.  Because macro data is in GCed memory, which    will be blown away by PCH, it must be temporarily copied to    malloced memory.  (The macros will refer to identifier nodes which    are also GCed and so on, so the copying is done by turning them    into self-contained strings.)  The assumption is that most macro    definitions will come from the PCH file, not from the compilation    before the PCH file is loaded, so it doesn't matter that this is    a little expensive.     It would reduce the cost even further if macros defined in the PCH    file were not saved in this way, but this is not done (yet), except    for builtins, and for #assert by default.  */
end_comment

begin_function
specifier|static
name|int
name|save_macros
parameter_list|(
name|cpp_reader
modifier|*
name|r
parameter_list|,
name|cpp_hashnode
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data_p
parameter_list|)
block|{
name|struct
name|save_macro_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|save_macro_data
operator|*
operator|)
name|data_p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|NT_VOID
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|count
operator|==
name|data
operator|->
name|array_size
condition|)
block|{
name|data
operator|->
name|array_size
operator|*=
literal|2
expr_stmt|;
name|data
operator|->
name|defns
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
operator|*
argument_list|,
name|data
operator|->
name|defns
argument_list|,
operator|(
name|data
operator|->
name|array_size
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|h
operator|->
name|type
condition|)
block|{
case|case
name|NT_ASSERTION
case|:
comment|/* Not currently implemented.  */
return|return
literal|1
return|;
case|case
name|NT_MACRO
case|:
block|{
specifier|const
name|uchar
modifier|*
name|defn
init|=
name|cpp_macro_definition
argument_list|(
name|r
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|size_t
name|defnlen
init|=
name|ustrlen
argument_list|(
name|defn
argument_list|)
decl_stmt|;
name|data
operator|->
name|defns
index|[
name|data
operator|->
name|count
index|]
operator|=
operator|(
name|uchar
operator|*
operator|)
name|xmemdup
argument_list|(
name|defn
argument_list|,
name|defnlen
argument_list|,
name|defnlen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|data
operator|->
name|defns
index|[
name|data
operator|->
name|count
index|]
index|[
name|defnlen
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|data
operator|->
name|count
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Prepare to restore the state, by saving the currently-defined    macros in 'data'.  */
end_comment

begin_function
name|void
name|cpp_prepare_state
parameter_list|(
name|cpp_reader
modifier|*
name|r
parameter_list|,
name|struct
name|save_macro_data
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|save_macro_data
modifier|*
name|d
init|=
name|XNEW
argument_list|(
expr|struct
name|save_macro_data
argument_list|)
decl_stmt|;
name|d
operator|->
name|array_size
operator|=
literal|512
expr_stmt|;
name|d
operator|->
name|defns
operator|=
name|XNEWVEC
argument_list|(
name|uchar
operator|*
argument_list|,
name|d
operator|->
name|array_size
argument_list|)
expr_stmt|;
name|d
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|cpp_forall_identifiers
argument_list|(
name|r
argument_list|,
name|save_macros
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|saved_pragmas
operator|=
name|_cpp_save_pragma_names
argument_list|(
name|r
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a precompiled header that was previously determined to be valid,    apply all its definitions (and undefinitions) to the current state.    DEPNAME is passed to deps_restore.  */
end_comment

begin_function
name|int
name|cpp_read_state
parameter_list|(
name|cpp_reader
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|save_macro_data
modifier|*
name|data
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|lexer_state
name|old_state
decl_stmt|;
comment|/* Restore spec_nodes, which will be full of references to the old      hashtable entries and so will now be invalid.  */
block|{
name|struct
name|spec_nodes
modifier|*
name|s
init|=
operator|&
name|r
operator|->
name|spec_nodes
decl_stmt|;
name|s
operator|->
name|n_defined
operator|=
name|cpp_lookup
argument_list|(
name|r
argument_list|,
name|DSC
argument_list|(
literal|"defined"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n_true
operator|=
name|cpp_lookup
argument_list|(
name|r
argument_list|,
name|DSC
argument_list|(
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n_false
operator|=
name|cpp_lookup
argument_list|(
name|r
argument_list|,
name|DSC
argument_list|(
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n__VA_ARGS__
operator|=
name|cpp_lookup
argument_list|(
name|r
argument_list|,
name|DSC
argument_list|(
literal|"__VA_ARGS__"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|old_state
operator|=
name|r
operator|->
name|state
expr_stmt|;
name|r
operator|->
name|state
operator|.
name|in_directive
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|state
operator|.
name|angled_headers
operator|=
literal|0
expr_stmt|;
comment|/* Run through the carefully-saved macros, insert them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cpp_hashnode
modifier|*
name|h
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|uchar
modifier|*
name|defn
decl_stmt|;
name|namelen
operator|=
name|ustrcspn
argument_list|(
name|data
operator|->
name|defns
index|[
name|i
index|]
argument_list|,
literal|"( \n"
argument_list|)
expr_stmt|;
name|h
operator|=
name|cpp_lookup
argument_list|(
name|r
argument_list|,
name|data
operator|->
name|defns
index|[
name|i
index|]
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|defn
operator|=
name|data
operator|->
name|defns
index|[
name|i
index|]
operator|+
name|namelen
expr_stmt|;
comment|/* The PCH file is valid, so we know that if there is a definition 	 from the PCH file it must be the same as the one we had 	 originally, and so do not need to restore it.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|NT_VOID
condition|)
block|{
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|r
argument_list|,
name|defn
argument_list|,
name|ustrchr
argument_list|(
name|defn
argument_list|,
literal|'\n'
argument_list|)
operator|-
name|defn
argument_list|,
name|true
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|_cpp_clean_line
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_cpp_create_definition
argument_list|(
name|r
argument_list|,
name|h
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|data
operator|->
name|defns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|state
operator|=
name|old_state
expr_stmt|;
name|_cpp_restore_pragma_names
argument_list|(
name|r
argument_list|,
name|data
operator|->
name|saved_pragmas
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_restore
argument_list|(
name|r
operator|->
name|deps
argument_list|,
name|f
argument_list|,
name|CPP_OPTION
argument_list|(
name|r
argument_list|,
name|restore_pch_deps
argument_list|)
condition|?
name|name
else|:
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|_cpp_read_file_entries
argument_list|(
name|r
argument_list|,
name|f
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
literal|0
return|;
name|error
label|:
name|cpp_errno
argument_list|(
name|r
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"while reading precompiled header"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

