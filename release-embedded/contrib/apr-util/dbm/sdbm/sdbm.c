begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*  * sdbm - ndbm work-alike hashed database library  * based on Per-Aake Larson's Dynamic Hashing algorithms. BIT 18 (1978).  * author: oz@nexus.yorku.ca  * ex-public domain, ported to APR for Apache 2  * core routines  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_file_io.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_errno.h"
end_include

begin_include
include|#
directive|include
file|"apr_sdbm.h"
end_include

begin_include
include|#
directive|include
file|"sdbm_tune.h"
end_include

begin_include
include|#
directive|include
file|"sdbm_pair.h"
end_include

begin_include
include|#
directive|include
file|"sdbm_private.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* for memset() */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for malloc() and free() */
end_comment

begin_comment
comment|/*  * forward  */
end_comment

begin_function_decl
specifier|static
name|int
name|getdbit
parameter_list|(
name|apr_sdbm_t
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_status_t
name|setdbit
parameter_list|(
name|apr_sdbm_t
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_status_t
name|getpage
parameter_list|(
name|apr_sdbm_t
modifier|*
name|db
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_status_t
name|getnext
parameter_list|(
name|apr_sdbm_datum_t
modifier|*
name|key
parameter_list|,
name|apr_sdbm_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_status_t
name|makroom
parameter_list|(
name|apr_sdbm_t
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * useful macros  */
end_comment

begin_define
define|#
directive|define
name|bad
parameter_list|(
name|x
parameter_list|)
value|((x).dptr == NULL || (x).dsize<= 0)
end_define

begin_define
define|#
directive|define
name|exhash
parameter_list|(
name|item
parameter_list|)
value|sdbm_hash((item).dptr, (item).dsize)
end_define

begin_define
define|#
directive|define
name|OFF_PAG
parameter_list|(
name|off
parameter_list|)
value|(apr_off_t) (off) * PBLKSIZ
end_define

begin_define
define|#
directive|define
name|OFF_DIR
parameter_list|(
name|off
parameter_list|)
value|(apr_off_t) (off) * DBLKSIZ
end_define

begin_decl_stmt
specifier|static
specifier|const
name|long
name|masks
index|[]
init|=
block|{
literal|000000000000
block|,
literal|000000000001
block|,
literal|000000000003
block|,
literal|000000000007
block|,
literal|000000000017
block|,
literal|000000000037
block|,
literal|000000000077
block|,
literal|000000000177
block|,
literal|000000000377
block|,
literal|000000000777
block|,
literal|000000001777
block|,
literal|000000003777
block|,
literal|000000007777
block|,
literal|000000017777
block|,
literal|000000037777
block|,
literal|000000077777
block|,
literal|000000177777
block|,
literal|000000377777
block|,
literal|000000777777
block|,
literal|000001777777
block|,
literal|000003777777
block|,
literal|000007777777
block|,
literal|000017777777
block|,
literal|000037777777
block|,
literal|000077777777
block|,
literal|000177777777
block|,
literal|000377777777
block|,
literal|000777777777
block|,
literal|001777777777
block|,
literal|003777777777
block|,
literal|007777777777
block|,
literal|017777777777
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|apr_sdbm_datum_t
name|sdbm_nullitem
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|apr_status_t
name|database_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_sdbm_t
modifier|*
name|db
init|=
name|data
decl_stmt|;
comment|/*      * Can't rely on apr_sdbm_unlock, since it will merely      * decrement the refcnt if several locks are held.      */
if|if
condition|(
name|db
operator|->
name|flags
operator|&
operator|(
name|SDBM_SHARED_LOCK
operator||
name|SDBM_EXCLUSIVE_LOCK
operator|)
condition|)
operator|(
name|void
operator|)
name|apr_file_unlock
argument_list|(
name|db
operator|->
name|dirf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apr_file_close
argument_list|(
name|db
operator|->
name|dirf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apr_file_close
argument_list|(
name|db
operator|->
name|pagf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|prep
parameter_list|(
name|apr_sdbm_t
modifier|*
modifier|*
name|pdb
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
specifier|const
name|char
modifier|*
name|pagname
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|,
name|apr_fileperms_t
name|perms
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|apr_sdbm_t
modifier|*
name|db
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
operator|*
name|pdb
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|db
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|pool
operator|=
name|p
expr_stmt|;
comment|/*      * adjust user flags so that WRONLY becomes RDWR,       * as required by this package. Also set our internal      * flag for RDONLY if needed.      */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|APR_FOPEN_WRITE
operator|)
condition|)
block|{
name|db
operator|->
name|flags
operator||=
name|SDBM_RDONLY
expr_stmt|;
block|}
comment|/*      * adjust the file open flags so that we handle locking      * on our own (don't rely on any locking behavior within      * an apr_file_t, in case it's ever introduced, and set      * our own flag.      */
if|if
condition|(
name|flags
operator|&
name|APR_FOPEN_SHARELOCK
condition|)
block|{
name|db
operator|->
name|flags
operator||=
name|SDBM_SHARED
expr_stmt|;
name|flags
operator|&=
operator|~
name|APR_FOPEN_SHARELOCK
expr_stmt|;
block|}
name|flags
operator||=
name|APR_FOPEN_BINARY
operator||
name|APR_FOPEN_READ
expr_stmt|;
comment|/*      * open the files in sequence, and stat the dirfile.      * If we fail anywhere, undo everything, return NULL.      */
if|if
condition|(
operator|(
name|status
operator|=
name|apr_file_open
argument_list|(
operator|&
name|db
operator|->
name|dirf
argument_list|,
name|dirname
argument_list|,
name|flags
argument_list|,
name|perms
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_file_open
argument_list|(
operator|&
name|db
operator|->
name|pagf
argument_list|,
name|pagname
argument_list|,
name|flags
argument_list|,
name|perms
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_sdbm_lock
argument_list|(
name|db
argument_list|,
operator|(
name|db
operator|->
name|flags
operator|&
name|SDBM_RDONLY
operator|)
condition|?
name|APR_FLOCK_SHARED
else|:
name|APR_FLOCK_EXCLUSIVE
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
goto|goto
name|error
goto|;
comment|/* apr_pcalloc zeroed the buffers      * apr_sdbm_lock stated the dirf->size and invalidated the cache      */
comment|/*      * if we are opened in SHARED mode, unlock ourself       */
if|if
condition|(
name|db
operator|->
name|flags
operator|&
name|SDBM_SHARED
condition|)
if|if
condition|(
operator|(
name|status
operator|=
name|apr_sdbm_unlock
argument_list|(
name|db
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
goto|goto
name|error
goto|;
comment|/* make sure that we close the database at some point */
name|apr_pool_cleanup_register
argument_list|(
name|p
argument_list|,
name|db
argument_list|,
name|database_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Done! */
operator|*
name|pdb
operator|=
name|db
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
name|error
label|:
if|if
condition|(
name|db
operator|->
name|dirf
operator|&&
name|db
operator|->
name|pagf
condition|)
operator|(
name|void
operator|)
name|apr_sdbm_unlock
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|dirf
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|apr_file_close
argument_list|(
name|db
operator|->
name|dirf
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|pagf
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|apr_file_close
argument_list|(
name|db
operator|->
name|pagf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sdbm_open
argument_list|(
argument|apr_sdbm_t **db
argument_list|,
argument|const char *file
argument_list|,
argument|apr_int32_t flags
argument_list|,
argument|apr_fileperms_t perms
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|dirname
init|=
name|apr_pstrcat
argument_list|(
name|p
argument_list|,
name|file
argument_list|,
name|APR_SDBM_DIRFEXT
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pagname
init|=
name|apr_pstrcat
argument_list|(
name|p
argument_list|,
name|file
argument_list|,
name|APR_SDBM_PAGFEXT
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
return|return
name|prep
argument_list|(
name|db
argument_list|,
name|dirname
argument_list|,
name|pagname
argument_list|,
name|flags
argument_list|,
name|perms
argument_list|,
name|p
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sdbm_close
argument_list|(
argument|apr_sdbm_t *db
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_pool_cleanup_run
argument_list|(
name|db
operator|->
name|pool
argument_list|,
name|db
argument_list|,
name|database_cleanup
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sdbm_fetch
argument_list|(
argument|apr_sdbm_t *db
argument_list|,
argument|apr_sdbm_datum_t *val
argument_list|,
argument|apr_sdbm_datum_t key
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|bad
argument_list|(
name|key
argument_list|)
condition|)
return|return
name|APR_EINVAL
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_sdbm_lock
argument_list|(
name|db
argument_list|,
name|APR_FLOCK_SHARED
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|getpage
argument_list|(
name|db
argument_list|,
name|exhash
argument_list|(
name|key
argument_list|)
argument_list|)
operator|)
operator|==
name|APR_SUCCESS
condition|)
block|{
operator|*
name|val
operator|=
name|getpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* ### do we want a not-found result? */
block|}
operator|(
name|void
operator|)
name|apr_sdbm_unlock
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_function
specifier|static
name|apr_status_t
name|write_page
parameter_list|(
name|apr_sdbm_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|pagno
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_off_t
name|off
init|=
name|OFF_PAG
argument_list|(
name|pagno
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_file_seek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|off
argument_list|)
operator|)
operator|==
name|APR_SUCCESS
condition|)
name|status
operator|=
name|apr_file_write_full
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|buf
argument_list|,
name|PBLKSIZ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sdbm_delete
argument_list|(
argument|apr_sdbm_t *db
argument_list|,
argument|const apr_sdbm_datum_t key
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|bad
argument_list|(
name|key
argument_list|)
condition|)
return|return
name|APR_EINVAL
return|;
if|if
condition|(
name|apr_sdbm_rdonly
argument_list|(
name|db
argument_list|)
condition|)
return|return
name|APR_EINVAL
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_sdbm_lock
argument_list|(
name|db
argument_list|,
name|APR_FLOCK_EXCLUSIVE
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|getpage
argument_list|(
name|db
argument_list|,
name|exhash
argument_list|(
name|key
argument_list|)
argument_list|)
operator|)
operator|==
name|APR_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|delpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
condition|)
comment|/* ### should we define some APRUTIL codes? */
name|status
operator|=
name|APR_EGENERAL
expr_stmt|;
else|else
name|status
operator|=
name|write_page
argument_list|(
name|db
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|db
operator|->
name|pagbno
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|apr_sdbm_unlock
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sdbm_store
argument_list|(
argument|apr_sdbm_t *db
argument_list|,
argument|apr_sdbm_datum_t key
argument_list|,
argument|apr_sdbm_datum_t val
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|int
name|need
decl_stmt|;
specifier|register
name|long
name|hash
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|bad
argument_list|(
name|key
argument_list|)
condition|)
return|return
name|APR_EINVAL
return|;
if|if
condition|(
name|apr_sdbm_rdonly
argument_list|(
name|db
argument_list|)
condition|)
return|return
name|APR_EINVAL
return|;
name|need
operator|=
name|key
operator|.
name|dsize
operator|+
name|val
operator|.
name|dsize
expr_stmt|;
comment|/*      * is the pair too big (or too small) for this database ??      */
if|if
condition|(
name|need
operator|<
literal|0
operator|||
name|need
operator|>
name|PAIRMAX
condition|)
return|return
name|APR_EINVAL
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_sdbm_lock
argument_list|(
name|db
argument_list|,
name|APR_FLOCK_EXCLUSIVE
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|getpage
argument_list|(
name|db
argument_list|,
operator|(
name|hash
operator|=
name|exhash
argument_list|(
name|key
argument_list|)
operator|)
argument_list|)
operator|)
operator|==
name|APR_SUCCESS
condition|)
block|{
comment|/*          * if we need to replace, delete the key/data pair          * first. If it is not there, ignore.          */
if|if
condition|(
name|flags
operator|==
name|APR_SDBM_REPLACE
condition|)
operator|(
name|void
operator|)
name|delpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|APR_SDBM_INSERTDUP
operator|)
operator|&&
name|duppair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|status
operator|=
name|APR_EEXIST
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/*          * if we do not have enough room, we have to split.          */
if|if
condition|(
operator|!
name|fitpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|need
argument_list|)
condition|)
if|if
condition|(
operator|(
name|status
operator|=
name|makroom
argument_list|(
name|db
argument_list|,
name|hash
argument_list|,
name|need
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
goto|goto
name|error
goto|;
comment|/*          * we have enough room or split is successful. insert the key,          * and update the page file.          */
operator|(
name|void
operator|)
name|putpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|status
operator|=
name|write_page
argument_list|(
name|db
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|db
operator|->
name|pagbno
argument_list|)
expr_stmt|;
block|}
name|error
label|:
operator|(
name|void
operator|)
name|apr_sdbm_unlock
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*  * makroom - make room by splitting the overfull page  * this routine will attempt to make room for SPLTMAX times before  * giving up.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|makroom
parameter_list|(
name|apr_sdbm_t
modifier|*
name|db
parameter_list|,
name|long
name|hash
parameter_list|,
name|int
name|need
parameter_list|)
block|{
name|long
name|newp
decl_stmt|;
name|char
name|twin
index|[
name|PBLKSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|pag
init|=
name|db
operator|->
name|pagbuf
decl_stmt|;
name|char
modifier|*
name|new
init|=
name|twin
decl_stmt|;
specifier|register
name|int
name|smax
init|=
name|SPLTMAX
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
do|do
block|{
comment|/*          * split the current page          */
operator|(
name|void
operator|)
name|splpage
argument_list|(
name|pag
argument_list|,
name|new
argument_list|,
name|db
operator|->
name|hmask
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*          * address of the new page          */
name|newp
operator|=
operator|(
name|hash
operator|&
name|db
operator|->
name|hmask
operator|)
operator||
operator|(
name|db
operator|->
name|hmask
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*          * write delay, read avoidence/cache shuffle:          * select the page for incoming pair: if key is to go to the new page,          * write out the previous one, and copy the new one over, thus making          * it the current page. If not, simply write the new page, and we are          * still looking at the page of interest. current page is not updated          * here, as sdbm_store will do so, after it inserts the incoming pair.          */
if|if
condition|(
name|hash
operator|&
operator|(
name|db
operator|->
name|hmask
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|write_page
argument_list|(
name|db
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|db
operator|->
name|pagbno
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
name|db
operator|->
name|pagbno
operator|=
name|newp
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|pag
argument_list|,
name|new
argument_list|,
name|PBLKSIZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|write_page
argument_list|(
name|db
argument_list|,
name|new
argument_list|,
name|newp
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|setdbit
argument_list|(
name|db
argument_list|,
name|db
operator|->
name|curbit
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
comment|/*          * see if we have enough room now          */
if|if
condition|(
name|fitpair
argument_list|(
name|pag
argument_list|,
name|need
argument_list|)
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/*          * try again... update curbit and hmask as getpage would have          * done. because of our update of the current page, we do not          * need to read in anything. BUT we have to write the current          * [deferred] page out, as the window of failure is too great.          */
name|db
operator|->
name|curbit
operator|=
literal|2
operator|*
name|db
operator|->
name|curbit
operator|+
operator|(
operator|(
name|hash
operator|&
operator|(
name|db
operator|->
name|hmask
operator|+
literal|1
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|db
operator|->
name|hmask
operator||=
name|db
operator|->
name|hmask
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|write_page
argument_list|(
name|db
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|db
operator|->
name|pagbno
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
block|}
do|while
condition|(
operator|--
name|smax
condition|)
do|;
comment|/*      * if we are here, this is real bad news. After SPLTMAX splits,      * we still cannot fit the key. say goodnight.      */
if|#
directive|if
literal|0
block|(void) write(2, "sdbm: cannot insert after SPLTMAX attempts.\n", 44);
endif|#
directive|endif
comment|/* ### ENOSPC not really appropriate but better than nothing */
return|return
name|APR_ENOSPC
return|;
block|}
end_function

begin_comment
comment|/* Reads 'len' bytes from file 'f' at offset 'off' into buf.  * 'off' is given relative to the start of the file.  * If EOF is returned while reading, this is taken as success.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|read_from
parameter_list|(
name|apr_file_t
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|apr_off_t
name|off
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_file_seek
argument_list|(
name|f
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|off
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
operator|||
operator|(
operator|(
name|status
operator|=
name|apr_file_read_full
argument_list|(
name|f
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
operator|)
condition|)
block|{
comment|/* if EOF is reached, pretend we read all zero's */
if|if
condition|(
name|status
operator|==
name|APR_EOF
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * the following two routines will break if  * deletions aren't taken into account. (ndbm bug)  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sdbm_firstkey
argument_list|(
argument|apr_sdbm_t *db
argument_list|,
argument|apr_sdbm_datum_t *key
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_sdbm_lock
argument_list|(
name|db
argument_list|,
name|APR_FLOCK_SHARED
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
comment|/*      * start at page 0      */
if|if
condition|(
operator|(
name|status
operator|=
name|read_from
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|OFF_PAG
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PBLKSIZ
argument_list|)
operator|)
operator|==
name|APR_SUCCESS
condition|)
block|{
name|db
operator|->
name|pagbno
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|blkptr
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|keyptr
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|getnext
argument_list|(
name|key
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|apr_sdbm_unlock
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sdbm_nextkey
argument_list|(
argument|apr_sdbm_t *db
argument_list|,
argument|apr_sdbm_datum_t *key
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_sdbm_lock
argument_list|(
name|db
argument_list|,
name|APR_FLOCK_SHARED
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|getnext
argument_list|(
name|key
argument_list|,
name|db
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apr_sdbm_unlock
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*  * all important binary tree traversal  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|getpage
parameter_list|(
name|apr_sdbm_t
modifier|*
name|db
parameter_list|,
name|long
name|hash
parameter_list|)
block|{
specifier|register
name|int
name|hbit
decl_stmt|;
specifier|register
name|long
name|dbit
decl_stmt|;
specifier|register
name|long
name|pagb
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|dbit
operator|=
literal|0
expr_stmt|;
name|hbit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dbit
operator|<
name|db
operator|->
name|maxbno
operator|&&
name|getdbit
argument_list|(
name|db
argument_list|,
name|dbit
argument_list|)
condition|)
name|dbit
operator|=
literal|2
operator|*
name|dbit
operator|+
operator|(
operator|(
name|hash
operator|&
operator|(
literal|1
operator|<<
name|hbit
operator|++
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"dbit: %d..."
operator|,
name|dbit
operator|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|curbit
operator|=
name|dbit
expr_stmt|;
name|db
operator|->
name|hmask
operator|=
name|masks
index|[
name|hbit
index|]
expr_stmt|;
name|pagb
operator|=
name|hash
operator|&
name|db
operator|->
name|hmask
expr_stmt|;
comment|/*      * see if the block we need is already in memory.      * note: this lookaside cache has about 10% hit rate.      */
if|if
condition|(
name|pagb
operator|!=
name|db
operator|->
name|pagbno
condition|)
block|{
comment|/*          * note: here, we assume a "hole" is read as 0s.          * if not, must zero pagbuf first.          * ### joe: this assumption was surely never correct? but          * ### we make it so in read_from anyway.          */
if|if
condition|(
operator|(
name|status
operator|=
name|read_from
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|OFF_PAG
argument_list|(
name|pagb
argument_list|)
argument_list|,
name|PBLKSIZ
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|chkpage
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|)
condition|)
return|return
name|APR_ENOSPC
return|;
comment|/* ### better error? */
name|db
operator|->
name|pagbno
operator|=
name|pagb
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"pag read: %d\n"
operator|,
name|pagb
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getdbit
parameter_list|(
name|apr_sdbm_t
modifier|*
name|db
parameter_list|,
name|long
name|dbit
parameter_list|)
block|{
specifier|register
name|long
name|c
decl_stmt|;
specifier|register
name|long
name|dirb
decl_stmt|;
name|c
operator|=
name|dbit
operator|/
name|BYTESIZ
expr_stmt|;
name|dirb
operator|=
name|c
operator|/
name|DBLKSIZ
expr_stmt|;
if|if
condition|(
name|dirb
operator|!=
name|db
operator|->
name|dirbno
condition|)
block|{
if|if
condition|(
name|read_from
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|db
operator|->
name|dirbuf
argument_list|,
name|OFF_DIR
argument_list|(
name|dirb
argument_list|)
argument_list|,
name|DBLKSIZ
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
literal|0
return|;
name|db
operator|->
name|dirbno
operator|=
name|dirb
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"dir read: %d\n"
operator|,
name|dirb
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|db
operator|->
name|dirbuf
index|[
name|c
operator|%
name|DBLKSIZ
index|]
operator|&
operator|(
literal|1
operator|<<
name|dbit
operator|%
name|BYTESIZ
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|setdbit
parameter_list|(
name|apr_sdbm_t
modifier|*
name|db
parameter_list|,
name|long
name|dbit
parameter_list|)
block|{
specifier|register
name|long
name|c
decl_stmt|;
specifier|register
name|long
name|dirb
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_off_t
name|off
decl_stmt|;
name|c
operator|=
name|dbit
operator|/
name|BYTESIZ
expr_stmt|;
name|dirb
operator|=
name|c
operator|/
name|DBLKSIZ
expr_stmt|;
if|if
condition|(
name|dirb
operator|!=
name|db
operator|->
name|dirbno
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|read_from
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|db
operator|->
name|dirbuf
argument_list|,
name|OFF_DIR
argument_list|(
name|dirb
argument_list|)
argument_list|,
name|DBLKSIZ
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
name|db
operator|->
name|dirbno
operator|=
name|dirb
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"dir read: %d\n"
operator|,
name|dirb
operator|)
argument_list|)
expr_stmt|;
block|}
name|db
operator|->
name|dirbuf
index|[
name|c
operator|%
name|DBLKSIZ
index|]
operator||=
operator|(
literal|1
operator|<<
name|dbit
operator|%
name|BYTESIZ
operator|)
expr_stmt|;
if|if
condition|(
name|dbit
operator|>=
name|db
operator|->
name|maxbno
condition|)
name|db
operator|->
name|maxbno
operator|+=
name|DBLKSIZ
operator|*
name|BYTESIZ
expr_stmt|;
name|off
operator|=
name|OFF_DIR
argument_list|(
name|dirb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_file_seek
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|off
argument_list|)
operator|)
operator|==
name|APR_SUCCESS
condition|)
name|status
operator|=
name|apr_file_write_full
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|db
operator|->
name|dirbuf
argument_list|,
name|DBLKSIZ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* * getnext - get the next key in the page, and if done with * the page, try the next page in sequence */
end_comment

begin_function
specifier|static
name|apr_status_t
name|getnext
parameter_list|(
name|apr_sdbm_datum_t
modifier|*
name|key
parameter_list|,
name|apr_sdbm_t
modifier|*
name|db
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|db
operator|->
name|keyptr
operator|++
expr_stmt|;
operator|*
name|key
operator|=
name|getnkey
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|db
operator|->
name|keyptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|dptr
operator|!=
name|NULL
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/*          * we either run out, or there is nothing on this page..          * try the next one... If we lost our position on the          * file, we will have to seek.          */
name|db
operator|->
name|keyptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|pagbno
operator|!=
name|db
operator|->
name|blkptr
operator|++
condition|)
block|{
name|apr_off_t
name|off
init|=
name|OFF_PAG
argument_list|(
name|db
operator|->
name|blkptr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|apr_file_seek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|off
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
block|}
name|db
operator|->
name|pagbno
operator|=
name|db
operator|->
name|blkptr
expr_stmt|;
comment|/* ### EOF acceptable here too? */
if|if
condition|(
operator|(
name|status
operator|=
name|apr_file_read_full
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|chkpage
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
comment|/* ### need better error */
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_sdbm_rdonly
argument_list|(
argument|apr_sdbm_t *db
argument_list|)
end_macro

begin_block
block|{
comment|/* ### Should we return true if the first lock is a share lock,      *     to reflect that apr_sdbm_store and apr_sdbm_delete will fail?      */
return|return
operator|(
name|db
operator|->
name|flags
operator|&
name|SDBM_RDONLY
operator|)
operator|!=
literal|0
return|;
block|}
end_block

end_unit

