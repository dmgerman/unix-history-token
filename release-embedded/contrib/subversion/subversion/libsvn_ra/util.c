begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util.c:  Repository access utility routines.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_network_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|path_or_url
operator|==
name|NULL
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_ra_get_session_url
argument_list|(
name|ra_session
argument_list|,
operator|&
name|path_or_url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* The SVN_ERR_UNSUPPORTED_FEATURE error in the caller is more              important, so dummy up the session's URL and chuck this error. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|_
argument_list|(
literal|"<repository>"
argument_list|)
return|;
block|}
block|}
return|return
name|path_or_url
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__assert_mergeinfo_capable_server
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|mergeinfo_capable
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|mergeinfo_capable
argument_list|,
name|SVN_RA_CAPABILITY_MERGEINFO
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mergeinfo_capable
condition|)
block|{
name|path_or_url
operator|=
name|get_path
argument_list|(
name|path_or_url
argument_list|,
name|ra_session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Retrieval of mergeinfo unsupported by '%s'"
argument_list|)
argument_list|,
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|?
name|path_or_url
else|:
name|svn_dirent_local_style
argument_list|(
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__assert_capable_server
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|capability
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_MERGEINFO
argument_list|)
condition|)
return|return
name|svn_ra__assert_mergeinfo_capable_server
argument_list|(
name|ra_session
argument_list|,
name|path_or_url
argument_list|,
name|pool
argument_list|)
return|;
else|else
block|{
name|svn_boolean_t
name|has
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|has
argument_list|,
name|capability
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has
condition|)
block|{
name|path_or_url
operator|=
name|get_path
argument_list|(
name|path_or_url
argument_list|,
name|ra_session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The '%s' feature is not supported by '%s'"
argument_list|)
argument_list|,
name|capability
argument_list|,
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|?
name|path_or_url
else|:
name|svn_dirent_local_style
argument_list|(
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Does ERR mean "the current value of the revprop isn't equal to    the *OLD_VALUE_P you gave me"?  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_atomicity_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
return|return
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_ERR_FS_PROP_BASEVALUE_MISMATCH
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__release_operational_lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_revprop_name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|mylocktoken
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|reposlocktoken
decl_stmt|;
name|svn_boolean_t
name|be_atomic
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_prop
argument_list|(
name|session
argument_list|,
literal|0
argument_list|,
name|lock_revprop_name
argument_list|,
operator|&
name|reposlocktoken
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reposlocktoken
operator|&&
name|svn_string_compare
argument_list|(
name|reposlocktoken
argument_list|,
name|mylocktoken
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_ra_change_rev_prop2
argument_list|(
name|session
argument_list|,
literal|0
argument_list|,
name|lock_revprop_name
argument_list|,
name|be_atomic
condition|?
operator|&
name|mylocktoken
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_atomicity_error
argument_list|(
name|err
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Lock was stolen by '%s'; unable to "
literal|"remove it"
argument_list|)
argument_list|,
name|reposlocktoken
operator|->
name|data
argument_list|)
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__get_operational_lock
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|lock_string_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|stolen_lock_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_revprop_name
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|int
name|num_retries
parameter_list|,
name|svn_ra__lock_retry_func_t
name|retry_func
parameter_list|,
name|void
modifier|*
name|retry_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|hostname_str
index|[
name|APRMAXHOSTLEN
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_string_t
modifier|*
name|mylocktoken
decl_stmt|,
modifier|*
name|reposlocktoken
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|svn_boolean_t
name|be_atomic
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|lock_string_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stolen_lock_p
condition|)
operator|*
name|stolen_lock_p
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We build a lock token from the local hostname and a UUID.  */
name|apr_err
operator|=
name|apr_gethostname
argument_list|(
name|hostname_str
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname_str
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Unable to determine local hostname"
argument_list|)
argument_list|)
return|;
name|mylocktoken
operator|=
name|svn_string_createf
argument_list|(
name|pool
argument_list|,
literal|"%s:%s"
argument_list|,
name|hostname_str
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ye Olde Retry Loope */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_retries
condition|;
operator|++
name|i
control|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|unset
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Check for cancellation.  If we're cancelled, don't leave a          stray lock behind!  */
if|if
condition|(
name|cancel_func
condition|)
block|{
name|err
operator|=
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CANCELLED
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|svn_ra__release_operational_lock
argument_list|(
name|session
argument_list|,
name|lock_revprop_name
argument_list|,
name|mylocktoken
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Ask the repository for the value of the LOCK_REVPROP_NAME. */
name|SVN_ERR
argument_list|(
name|svn_ra_rev_prop
argument_list|(
name|session
argument_list|,
literal|0
argument_list|,
name|lock_revprop_name
argument_list|,
operator|&
name|reposlocktoken
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did we get a value from the repository?  We'll check to see          if it matches our token.  If so, we call it success.  If not          and we're told to steal locks, we remember the existing lock          token and fall through to the locking code; othewise, we          sleep and retry. */
if|if
condition|(
name|reposlocktoken
condition|)
block|{
if|if
condition|(
name|svn_string_compare
argument_list|(
name|reposlocktoken
argument_list|,
name|mylocktoken
argument_list|)
condition|)
block|{
operator|*
name|lock_string_p
operator|=
name|mylocktoken
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|steal_lock
condition|)
block|{
if|if
condition|(
name|retry_func
condition|)
name|SVN_ERR
argument_list|(
name|retry_func
argument_list|(
name|retry_baton
argument_list|,
name|reposlocktoken
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_sleep
argument_list|(
name|apr_time_from_sec
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|stolen_lock_p
condition|)
operator|*
name|stolen_lock_p
operator|=
name|svn_string_dup
argument_list|(
name|reposlocktoken
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|unset
operator|=
name|reposlocktoken
expr_stmt|;
block|}
block|}
comment|/* No lock value in the repository, or we plan to steal it?          Well, if we've got a spare iteration, we'll try to set the          lock.  (We use the spare iteration to verify that we still          have the lock after setting it.) */
if|if
condition|(
name|i
operator|<
name|num_retries
operator|-
literal|1
condition|)
block|{
comment|/* Except in the very last iteration, try to set the lock. */
name|err
operator|=
name|svn_ra_change_rev_prop2
argument_list|(
name|session
argument_list|,
literal|0
argument_list|,
name|lock_revprop_name
argument_list|,
name|be_atomic
condition|?
operator|&
name|unset
else|:
name|NULL
argument_list|,
name|mylocktoken
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_atomic
operator|&&
name|err
operator|&&
name|is_atomicity_error
argument_list|(
name|err
argument_list|)
condition|)
block|{
comment|/* Someone else has the lock.  No problem, we'll loop again. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be_atomic
operator|&&
name|err
operator|==
name|SVN_NO_ERROR
condition|)
block|{
comment|/* Yay!  We have the lock!  However, for compatibility                  with concurrent processes that don't support                  atomicity, loop anyway to double-check that they                  haven't overwritten our lock.               */
continue|continue;
block|}
else|else
block|{
comment|/* We have a genuine error, or aren't atomic and need                  to loop.  */
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Couldn't get lock on destination repos "
literal|"after %d attempts"
argument_list|)
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

end_unit

