begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * compat.c:  compatibility compliance logic  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This is just like svn_sort_compare_revisions, save that it sorts    the revisions in *ascending* order. */
end_comment

begin_function
specifier|static
name|int
name|compare_revisions
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|svn_revnum_t
name|a_rev
init|=
operator|*
operator|(
specifier|const
name|svn_revnum_t
operator|*
operator|)
name|a
decl_stmt|;
name|svn_revnum_t
name|b_rev
init|=
operator|*
operator|(
specifier|const
name|svn_revnum_t
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|a_rev
operator|==
name|b_rev
condition|)
return|return
literal|0
return|;
return|return
name|a_rev
operator|<
name|b_rev
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given the CHANGED_PATHS and REVISION from an instance of a    svn_log_message_receiver_t function, determine at which location    PATH may be expected in the next log message, and set *PREV_PATH_P    to that value.  KIND is the node kind of PATH.  Set *ACTION_P to a    character describing the change that caused this revision (as    listed in svn_log_changed_path_t) and set *COPYFROM_REV_P to the    revision PATH was copied from, or SVN_INVALID_REVNUM if it was not    copied.  ACTION_P and COPYFROM_REV_P may be NULL, in which case    they are not used.  Perform all allocations in POOL.     This is useful for tracking the various changes in location a    particular resource has undergone when performing an RA->get_logs()    operation on that resource. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prev_log_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|prev_path_p
parameter_list|,
name|char
modifier|*
name|action_p
parameter_list|,
name|svn_revnum_t
modifier|*
name|copyfrom_rev_p
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_log_changed_path_t
modifier|*
name|change
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_path
init|=
name|NULL
decl_stmt|;
comment|/* It's impossible to find the predecessor path of a NULL path. */
name|SVN_ERR_ASSERT
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Initialize our return values for the action and copyfrom_rev in      case we have an unhandled case later on. */
if|if
condition|(
name|action_p
condition|)
operator|*
name|action_p
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|copyfrom_rev_p
condition|)
operator|*
name|copyfrom_rev_p
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|changed_paths
condition|)
block|{
comment|/* See if PATH was explicitly changed in this revision. */
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|changed_paths
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
condition|)
block|{
comment|/* If PATH was not newly added in this revision, then it may or may              not have also been part of a moved subtree.  In this case, set a              default previous path, but still look through the parents of this              path for a possible copy event. */
if|if
condition|(
name|change
operator|->
name|action
operator|!=
literal|'A'
operator|&&
name|change
operator|->
name|action
operator|!=
literal|'R'
condition|)
block|{
name|prev_path
operator|=
name|path
expr_stmt|;
block|}
else|else
block|{
comment|/* PATH is new in this revision.  This means it cannot have been                  part of a copied subtree. */
if|if
condition|(
name|change
operator|->
name|copyfrom_path
condition|)
name|prev_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
else|else
name|prev_path
operator|=
name|NULL
expr_stmt|;
operator|*
name|prev_path_p
operator|=
name|prev_path
expr_stmt|;
if|if
condition|(
name|action_p
condition|)
operator|*
name|action_p
operator|=
name|change
operator|->
name|action
expr_stmt|;
if|if
condition|(
name|copyfrom_rev_p
condition|)
operator|*
name|copyfrom_rev_p
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|changed_paths
argument_list|)
condition|)
block|{
comment|/* The path was not explicitly changed in this revision.  The              fact that we're hearing about this revision implies, then,              that the path was a child of some copied directory.  We need              to find that directory, and effectively "re-base" our path on              that directory's copyfrom_path. */
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
comment|/* Build a sorted list of the changed paths. */
name|paths
operator|=
name|svn_sort__hash
argument_list|(
name|changed_paths
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Now, walk the list of paths backwards, looking a parent of              our path that has copyfrom information. */
for|for
control|(
name|i
operator|=
name|paths
operator|->
name|nelts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ch_path
init|=
name|item
operator|.
name|key
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|ch_path
argument_list|)
decl_stmt|;
comment|/* See if our path is the child of this change path.  If                  not, keep looking.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|strncmp
argument_list|(
name|ch_path
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|path
index|[
name|len
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
continue|continue;
comment|/* Okay, our path *is* a child of this change path.  If                  this change was copied, we just need to apply the                  portion of our path that is relative to this change's                  path, to the change's copyfrom path.  Otherwise, this                  change isn't really interesting to us, and our search                  continues. */
name|change
operator|=
name|item
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|copyfrom_path
condition|)
block|{
if|if
condition|(
name|action_p
condition|)
operator|*
name|action_p
operator|=
name|change
operator|->
name|action
expr_stmt|;
if|if
condition|(
name|copyfrom_rev_p
condition|)
operator|*
name|copyfrom_rev_p
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
name|prev_path
operator|=
name|svn_fspath__join
argument_list|(
name|change
operator|->
name|copyfrom_path
argument_list|,
name|path
operator|+
name|len
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* If we didn't find what we expected to find, return an error.      (Because directories bubble-up, we get a bunch of logs we might      not want.  Be forgiving in that case.)  */
if|if
condition|(
operator|!
name|prev_path
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|prev_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing changed-path information for "
literal|"'%s' in revision %ld"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|revision
argument_list|)
return|;
block|}
operator|*
name|prev_path_p
operator|=
name|prev_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *FS_PATH_P to the absolute filesystem path associated with the    URL built from SESSION's URL and REL_PATH (which is relative to    session's URL.  Use POOL for allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_fs_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fs_path_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|url
decl_stmt|,
modifier|*
name|fs_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|session
argument_list|,
operator|&
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_root
argument_list|(
name|session
argument_list|,
operator|&
name|fs_path
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fs_path_p
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|svn_relpath_join
argument_list|(
name|fs_path
argument_list|,
name|rel_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Fallback implementation of svn_ra_get_locations(). ***/
end_comment

begin_comment
comment|/* ### This is to support 1.0 servers. */
end_comment

begin_struct
struct|struct
name|log_receiver_baton
block|{
comment|/* The kind of the path we're tracing. */
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* The path at which we are trying to find our versioned resource in      the log output. */
specifier|const
name|char
modifier|*
name|last_path
decl_stmt|;
comment|/* Input revisions and output hash; the whole point of this little game. */
name|svn_revnum_t
name|peg_revision
decl_stmt|;
name|apr_array_header_t
modifier|*
name|location_revisions
decl_stmt|;
specifier|const
name|char
modifier|*
name|peg_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|locations
decl_stmt|;
comment|/* A pool from which to allocate stuff stored in this baton. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_log_entry_receiver_t; helper for slow_get_locations.    As input, takes log_receiver_baton (defined above) and attempts to    "fill in" locations in the baton over the course of many    iterations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_receiver_baton
modifier|*
name|lrb
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|hash_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|lrb
operator|->
name|locations
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|current_path
init|=
name|lrb
operator|->
name|last_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_path
decl_stmt|;
comment|/* No paths were changed in this revision.  Nothing to do. */
if|if
condition|(
operator|!
name|log_entry
operator|->
name|changed_paths2
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If we've run off the end of the path's history, there's nothing      to do.  (This should never happen with a properly functioning      server, since we'd get no more log messages after the one where      path was created.  But a malfunctioning server shouldn't cause us      to trigger an assertion failure.) */
if|if
condition|(
operator|!
name|current_path
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If we haven't found our peg path yet, and we are now looking at a      revision equal to or older than the peg revision, then our      "current" path is our peg path. */
if|if
condition|(
operator|(
operator|!
name|lrb
operator|->
name|peg_path
operator|)
operator|&&
operator|(
name|log_entry
operator|->
name|revision
operator|<=
name|lrb
operator|->
name|peg_revision
operator|)
condition|)
name|lrb
operator|->
name|peg_path
operator|=
name|apr_pstrdup
argument_list|(
name|lrb
operator|->
name|pool
argument_list|,
name|current_path
argument_list|)
expr_stmt|;
comment|/* Determine the paths for any of the revisions for which we haven't      gotten paths already. */
while|while
condition|(
name|lrb
operator|->
name|location_revisions
operator|->
name|nelts
condition|)
block|{
name|svn_revnum_t
name|next
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lrb
operator|->
name|location_revisions
argument_list|,
name|lrb
operator|->
name|location_revisions
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_revnum_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|<=
name|next
condition|)
block|{
name|apr_hash_set
argument_list|(
name|lrb
operator|->
name|locations
argument_list|,
name|apr_pmemdup
argument_list|(
name|hash_pool
argument_list|,
operator|&
name|next
argument_list|,
sizeof|sizeof
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|next
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|hash_pool
argument_list|,
name|current_path
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_pop
argument_list|(
name|lrb
operator|->
name|location_revisions
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Figure out at which repository path our object of interest lived      in the previous revision. */
name|SVN_ERR
argument_list|(
name|prev_log_path
argument_list|(
operator|&
name|prev_path
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|,
name|current_path
argument_list|,
name|lrb
operator|->
name|kind
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Squirrel away our "next place to look" path (suffer the strcmp      hit to save on allocations). */
if|if
condition|(
operator|!
name|prev_path
condition|)
name|lrb
operator|->
name|last_path
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|prev_path
argument_list|,
name|current_path
argument_list|)
operator|!=
literal|0
condition|)
name|lrb
operator|->
name|last_path
operator|=
name|apr_pstrdup
argument_list|(
name|lrb
operator|->
name|pool
argument_list|,
name|prev_path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__locations_from_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locations_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|location_revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|locations
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|struct
name|log_receiver_baton
name|lrb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|svn_revnum_t
name|youngest_requested
decl_stmt|,
name|oldest_requested
decl_stmt|,
name|youngest
decl_stmt|,
name|oldest
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
comment|/* Fetch the absolute FS path associated with PATH. */
name|SVN_ERR
argument_list|(
name|get_fs_path
argument_list|(
operator|&
name|fs_path
argument_list|,
name|session
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sanity check: verify that the peg-object exists in repos. */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|session
argument_list|,
name|path
argument_list|,
name|peg_revision
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in revision %ld"
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|peg_revision
argument_list|)
return|;
comment|/* Easy out: no location revisions. */
if|if
condition|(
operator|!
name|location_revisions
operator|->
name|nelts
condition|)
block|{
operator|*
name|locations_p
operator|=
name|locations
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Figure out the youngest and oldest revs (amongst the set of      requested revisions + the peg revision) so we can avoid      unnecessary log parsing. */
name|qsort
argument_list|(
name|location_revisions
operator|->
name|elts
argument_list|,
name|location_revisions
operator|->
name|nelts
argument_list|,
name|location_revisions
operator|->
name|elt_size
argument_list|,
name|compare_revisions
argument_list|)
expr_stmt|;
name|oldest_requested
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|location_revisions
argument_list|,
literal|0
argument_list|,
name|svn_revnum_t
argument_list|)
expr_stmt|;
name|youngest_requested
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|location_revisions
argument_list|,
name|location_revisions
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_revnum_t
argument_list|)
expr_stmt|;
name|youngest
operator|=
name|peg_revision
expr_stmt|;
name|youngest
operator|=
operator|(
name|oldest_requested
operator|>
name|youngest
operator|)
condition|?
name|oldest_requested
else|:
name|youngest
expr_stmt|;
name|youngest
operator|=
operator|(
name|youngest_requested
operator|>
name|youngest
operator|)
condition|?
name|youngest_requested
else|:
name|youngest
expr_stmt|;
name|oldest
operator|=
name|peg_revision
expr_stmt|;
name|oldest
operator|=
operator|(
name|oldest_requested
operator|<
name|oldest
operator|)
condition|?
name|oldest_requested
else|:
name|oldest
expr_stmt|;
name|oldest
operator|=
operator|(
name|youngest_requested
operator|<
name|oldest
operator|)
condition|?
name|youngest_requested
else|:
name|oldest
expr_stmt|;
comment|/* Populate most of our log receiver baton structure. */
name|lrb
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|lrb
operator|.
name|last_path
operator|=
name|fs_path
expr_stmt|;
name|lrb
operator|.
name|location_revisions
operator|=
name|apr_array_copy
argument_list|(
name|pool
argument_list|,
name|location_revisions
argument_list|)
expr_stmt|;
name|lrb
operator|.
name|peg_revision
operator|=
name|peg_revision
expr_stmt|;
name|lrb
operator|.
name|peg_path
operator|=
name|NULL
expr_stmt|;
name|lrb
operator|.
name|locations
operator|=
name|locations
expr_stmt|;
name|lrb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Let the RA layer drive our log information handler, which will do      the work of finding the actual locations for our resource.      Notice that we always run on the youngest rev of the 3 inputs. */
name|targets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_log2
argument_list|(
name|session
argument_list|,
name|targets
argument_list|,
name|youngest
argument_list|,
name|oldest
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|log_receiver
argument_list|,
operator|&
name|lrb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the received log information did not cover any of the      requested revisions, use the last known path.  (This normally      just means that FS_PATH was not modified between the requested      revision and OLDEST.  If the file was created at some point after      OLDEST, then lrb.last_path should be NULL.) */
if|if
condition|(
operator|!
name|lrb
operator|.
name|peg_path
condition|)
name|lrb
operator|.
name|peg_path
operator|=
name|lrb
operator|.
name|last_path
expr_stmt|;
if|if
condition|(
name|lrb
operator|.
name|last_path
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|location_revisions
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_revnum_t
name|rev
init|=
name|APR_ARRAY_IDX
argument_list|(
name|location_revisions
argument_list|,
name|i
argument_list|,
name|svn_revnum_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|apr_hash_get
argument_list|(
name|locations
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
condition|)
name|apr_hash_set
argument_list|(
name|locations
argument_list|,
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|lrb
operator|.
name|last_path
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check that we got the peg path. */
if|if
condition|(
operator|!
name|lrb
operator|.
name|peg_path
condition|)
return|return
name|svn_error_createf
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to find repository location for '%s' in revision %ld"
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|peg_revision
argument_list|)
return|;
comment|/* Sanity check: make sure that our calculated peg path is the same      as what we expected it to be. */
if|if
condition|(
name|strcmp
argument_list|(
name|fs_path
argument_list|,
name|lrb
operator|.
name|peg_path
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' in revision %ld is an unrelated object"
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|youngest
argument_list|)
return|;
operator|*
name|locations_p
operator|=
name|locations
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Fallback implementation of svn_ra_get_location_segments(). ***/
end_comment

begin_struct
struct|struct
name|gls_log_receiver_baton
block|{
comment|/* The kind of the path we're tracing. */
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* Are we finished (and just listening to log entries because our      caller won't shut up?). */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* The path at which we are trying to find our versioned resource in      the log output. */
specifier|const
name|char
modifier|*
name|last_path
decl_stmt|;
comment|/* Input data. */
name|svn_revnum_t
name|start_rev
decl_stmt|;
comment|/* Output intermediate state and callback/baton. */
name|svn_revnum_t
name|range_end
decl_stmt|;
name|svn_location_segment_receiver_t
name|receiver
decl_stmt|;
name|void
modifier|*
name|receiver_baton
decl_stmt|;
comment|/* A pool from which to allocate stuff stored in this baton. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Build a node location segment object from PATH, RANGE_START, and    RANGE_END, and pass it off to RECEIVER/RECEIVER_BATON. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_crop_and_send_segment
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|range_start
parameter_list|,
name|svn_revnum_t
name|range_end
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_location_segment_t
modifier|*
name|segment
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|segment
argument_list|)
argument_list|)
decl_stmt|;
name|segment
operator|->
name|path
operator|=
name|path
condition|?
operator|(
operator|(
operator|*
name|path
operator|==
literal|'/'
operator|)
condition|?
name|path
operator|+
literal|1
else|:
name|path
operator|)
else|:
name|NULL
expr_stmt|;
name|segment
operator|->
name|range_start
operator|=
name|range_start
expr_stmt|;
name|segment
operator|->
name|range_end
operator|=
name|range_end
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|range_start
operator|<=
name|start_rev
condition|)
block|{
if|if
condition|(
name|segment
operator|->
name|range_end
operator|>
name|start_rev
condition|)
name|segment
operator|->
name|range_end
operator|=
name|start_rev
expr_stmt|;
return|return
name|receiver
argument_list|(
name|segment
argument_list|,
name|receiver_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|gls_log_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|gls_log_receiver_baton
modifier|*
name|lrb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|current_path
init|=
name|lrb
operator|->
name|last_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_path
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* If we're done, ignore this invocation. */
if|if
condition|(
name|lrb
operator|->
name|done
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Figure out at which repository path our object of interest lived      in the previous revision, and if its current location is the      result of copy since then. */
name|SVN_ERR
argument_list|(
name|prev_log_path
argument_list|(
operator|&
name|prev_path
argument_list|,
name|NULL
argument_list|,
operator|&
name|copyfrom_rev
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|,
name|current_path
argument_list|,
name|lrb
operator|->
name|kind
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we've run off the end of the path's history, we need to report      our final segment (and then, we're done). */
if|if
condition|(
operator|!
name|prev_path
condition|)
block|{
name|lrb
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|maybe_crop_and_send_segment
argument_list|(
name|current_path
argument_list|,
name|lrb
operator|->
name|start_rev
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|lrb
operator|->
name|range_end
argument_list|,
name|lrb
operator|->
name|receiver
argument_list|,
name|lrb
operator|->
name|receiver_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
comment|/* If there was a copy operation of interest... */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
block|{
comment|/* ...then report the segment between this revision and the          last-reported revision. */
name|SVN_ERR
argument_list|(
name|maybe_crop_and_send_segment
argument_list|(
name|current_path
argument_list|,
name|lrb
operator|->
name|start_rev
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|lrb
operator|->
name|range_end
argument_list|,
name|lrb
operator|->
name|receiver
argument_list|,
name|lrb
operator|->
name|receiver_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lrb
operator|->
name|range_end
operator|=
name|log_entry
operator|->
name|revision
operator|-
literal|1
expr_stmt|;
comment|/* And if there was a revision gap, we need to report that, too. */
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|-
name|copyfrom_rev
operator|>
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|maybe_crop_and_send_segment
argument_list|(
name|NULL
argument_list|,
name|lrb
operator|->
name|start_rev
argument_list|,
name|copyfrom_rev
operator|+
literal|1
argument_list|,
name|lrb
operator|->
name|range_end
argument_list|,
name|lrb
operator|->
name|receiver
argument_list|,
name|lrb
operator|->
name|receiver_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lrb
operator|->
name|range_end
operator|=
name|copyfrom_rev
expr_stmt|;
block|}
comment|/* Update our state variables. */
name|lrb
operator|->
name|last_path
operator|=
name|apr_pstrdup
argument_list|(
name|lrb
operator|->
name|pool
argument_list|,
name|prev_path
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__location_segments_from_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|gls_log_receiver_baton
name|lrb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
comment|/* Fetch the absolute FS path associated with PATH. */
name|SVN_ERR
argument_list|(
name|get_fs_path
argument_list|(
operator|&
name|fs_path
argument_list|,
name|session
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If PEG_REVISION is invalid, it means HEAD.  If START_REV is      invalid, it means HEAD.  If END_REV is SVN_INVALID_REVNUM, we'll      use 0. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|peg_revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|session
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|peg_revision
operator|=
name|youngest_rev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|youngest_rev
argument_list|)
condition|)
name|start_rev
operator|=
name|youngest_rev
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|session
argument_list|,
operator|&
name|start_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
condition|)
block|{
name|end_rev
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The API demands a certain ordering of our revision inputs. Enforce it. */
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|peg_revision
operator|>=
name|start_rev
operator|)
operator|&&
operator|(
name|start_rev
operator|>=
name|end_rev
operator|)
argument_list|)
expr_stmt|;
comment|/* Sanity check: verify that the peg-object exists in repos. */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|session
argument_list|,
name|path
argument_list|,
name|peg_revision
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in revision %ld"
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|start_rev
argument_list|)
return|;
comment|/* Populate most of our log receiver baton structure. */
name|lrb
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|lrb
operator|.
name|last_path
operator|=
name|fs_path
expr_stmt|;
name|lrb
operator|.
name|done
operator|=
name|FALSE
expr_stmt|;
name|lrb
operator|.
name|start_rev
operator|=
name|start_rev
expr_stmt|;
name|lrb
operator|.
name|range_end
operator|=
name|start_rev
expr_stmt|;
name|lrb
operator|.
name|receiver
operator|=
name|receiver
expr_stmt|;
name|lrb
operator|.
name|receiver_baton
operator|=
name|receiver_baton
expr_stmt|;
name|lrb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Let the RA layer drive our log information handler, which will do      the work of finding the actual locations for our resource.      Notice that we always run on the youngest rev of the 3 inputs. */
name|targets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_log2
argument_list|(
name|session
argument_list|,
name|targets
argument_list|,
name|peg_revision
argument_list|,
name|end_rev
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|gls_log_receiver
argument_list|,
operator|&
name|lrb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we didn't finish, we need to do so with a final segment send. */
if|if
condition|(
operator|!
name|lrb
operator|.
name|done
condition|)
name|SVN_ERR
argument_list|(
name|maybe_crop_and_send_segment
argument_list|(
name|lrb
operator|.
name|last_path
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|lrb
operator|.
name|range_end
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Fallback implementation of svn_ra_get_file_revs(). ***/
end_comment

begin_comment
comment|/* The metadata associated with a particular revision. */
end_comment

begin_struct
struct|struct
name|rev
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* the revision number */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* the absolute repository path */
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* the revprops for this revision */
name|struct
name|rev
modifier|*
name|next
decl_stmt|;
comment|/* the next revision */
block|}
struct|;
end_struct

begin_comment
comment|/* File revs log message baton. */
end_comment

begin_struct
struct|struct
name|fr_log_message_baton
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The path to be processed */
name|struct
name|rev
modifier|*
name|eldest
decl_stmt|;
comment|/* The eldest revision processed */
name|char
name|action
decl_stmt|;
comment|/* The action associated with the eldest */
name|svn_revnum_t
name|copyrev
decl_stmt|;
comment|/* The revision the eldest was copied from */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback for log messages: implements svn_log_entry_receiver_t and    accumulates revision metadata into a chronologically ordered list stored in    the baton. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fr_log_message_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|fr_log_message_baton
modifier|*
name|lmb
init|=
name|baton
decl_stmt|;
name|struct
name|rev
modifier|*
name|rev
decl_stmt|;
name|rev
operator|=
name|apr_palloc
argument_list|(
name|lmb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|rev
operator|->
name|revision
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
name|rev
operator|->
name|path
operator|=
name|lmb
operator|->
name|path
expr_stmt|;
name|rev
operator|->
name|next
operator|=
name|lmb
operator|->
name|eldest
expr_stmt|;
name|lmb
operator|->
name|eldest
operator|=
name|rev
expr_stmt|;
comment|/* Duplicate log_entry revprops into rev->props */
name|rev
operator|->
name|props
operator|=
name|svn_prop_hash_dup
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|lmb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|prev_log_path
argument_list|(
operator|&
name|lmb
operator|->
name|path
argument_list|,
operator|&
name|lmb
operator|->
name|action
argument_list|,
operator|&
name|lmb
operator|->
name|copyrev
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|,
name|lmb
operator|->
name|path
argument_list|,
name|svn_node_file
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|lmb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__file_revs_from_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_url
decl_stmt|,
modifier|*
name|session_url
decl_stmt|,
modifier|*
name|fs_path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|condensed_targets
decl_stmt|;
name|struct
name|fr_log_message_baton
name|lmb
decl_stmt|;
name|struct
name|rev
modifier|*
name|rev
decl_stmt|;
name|apr_hash_t
modifier|*
name|last_props
decl_stmt|;
name|svn_stream_t
modifier|*
name|last_stream
decl_stmt|;
name|apr_pool_t
modifier|*
name|currpool
decl_stmt|,
modifier|*
name|lastpool
decl_stmt|;
comment|/* Fetch the absolute FS path associated with PATH. */
name|SVN_ERR
argument_list|(
name|get_fs_path
argument_list|(
operator|&
name|fs_path
argument_list|,
name|ra_session
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to make sure we're dealing with a file. */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|path
argument_list|,
name|end
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|fs_path
argument_list|)
return|;
name|condensed_targets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|condensed_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|lmb
operator|.
name|path
operator|=
name|fs_path
expr_stmt|;
name|lmb
operator|.
name|eldest
operator|=
name|NULL
expr_stmt|;
name|lmb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Accumulate revision metadata by walking the revisions      backwards; this allows us to follow moves/copies      correctly. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_log2
argument_list|(
name|ra_session
argument_list|,
name|condensed_targets
argument_list|,
name|end
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
comment|/* no limit */
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|fr_log_message_receiver
argument_list|,
operator|&
name|lmb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reparent the session while we go back through the history. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|ra_session
argument_list|,
operator|&
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|currpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|lastpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* We want the first txdelta to be against the empty file. */
name|last_props
operator|=
name|apr_hash_make
argument_list|(
name|lastpool
argument_list|)
expr_stmt|;
name|last_stream
operator|=
name|svn_stream_empty
argument_list|(
name|lastpool
argument_list|)
expr_stmt|;
comment|/* Walk the revision list in chronological order, downloading each fulltext,      diffing it with its predecessor, and calling the file_revs handler for      each one.  Use two iteration pools rather than one, because the diff      routines need to look at a sliding window of revisions.  Two pools gives      us a ring buffer of sorts. */
for|for
control|(
name|rev
operator|=
name|lmb
operator|.
name|eldest
init|;
name|rev
condition|;
name|rev
operator|=
name|rev
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|temp_path
decl_stmt|;
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_array_header_t
modifier|*
name|prop_diffs
decl_stmt|;
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
decl_stmt|;
name|svn_txdelta_window_handler_t
name|delta_handler
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|delta_baton
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|currpool
argument_list|)
expr_stmt|;
comment|/* Get the contents of the file from the repository, and put them in          a temporary local file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|temp_path
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|currpool
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
name|rev
operator|->
name|path
operator|+
literal|1
argument_list|,
name|rev
operator|->
name|revision
argument_list|,
name|stream
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open up a stream to the local file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|temp_path
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|currpool
argument_list|)
expr_stmt|;
comment|/* Calculate the property diff */
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|prop_diffs
argument_list|,
name|props
argument_list|,
name|last_props
argument_list|,
name|lastpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the file_rev handler */
name|SVN_ERR
argument_list|(
name|handler
argument_list|(
name|handler_baton
argument_list|,
name|rev
operator|->
name|path
argument_list|,
name|rev
operator|->
name|revision
argument_list|,
name|rev
operator|->
name|props
argument_list|,
name|FALSE
argument_list|,
comment|/* merged revision */
operator|&
name|delta_handler
argument_list|,
operator|&
name|delta_baton
argument_list|,
name|prop_diffs
argument_list|,
name|lastpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute and send delta if client asked for it. */
if|if
condition|(
name|delta_handler
condition|)
block|{
comment|/* Get the content delta. Don't calculate checksums as we don't            * use them. */
name|svn_txdelta2
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|last_stream
argument_list|,
name|stream
argument_list|,
name|FALSE
argument_list|,
name|lastpool
argument_list|)
expr_stmt|;
comment|/* And send. */
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_txstream
argument_list|(
name|delta_stream
argument_list|,
name|delta_handler
argument_list|,
name|delta_baton
argument_list|,
name|lastpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Switch the pools and data for the next iteration */
name|tmppool
operator|=
name|currpool
expr_stmt|;
name|currpool
operator|=
name|lastpool
expr_stmt|;
name|lastpool
operator|=
name|tmppool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|last_stream
argument_list|)
argument_list|)
expr_stmt|;
name|last_stream
operator|=
name|stream
expr_stmt|;
name|last_props
operator|=
name|props
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|last_stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|currpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|lastpool
argument_list|)
expr_stmt|;
comment|/* Reparent the session back to the original URL. */
return|return
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|session_url
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Fallback implementation of svn_ra_get_deleted_rev(). ***/
end_comment

begin_comment
comment|/* svn_ra_get_log2() receiver_baton for svn_ra__get_deleted_rev_from_log(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|log_path_del_rev_t
block|{
comment|/* Absolute repository path. */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Revision PATH was first deleted or replaced. */
name|svn_revnum_t
name|revision_deleted
decl_stmt|;
block|}
name|log_path_del_rev_t
typedef|;
end_typedef

begin_comment
comment|/* A svn_log_entry_receiver_t callback for finding the revision    ((log_path_del_rev_t *)BATON)->PATH was first deleted or replaced.    Stores that revision in ((log_path_del_rev_t *)BATON)->REVISION_DELETED.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_path_del_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|log_path_del_rev_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* No paths were changed in this revision.  Nothing to do. */
if|if
condition|(
operator|!
name|log_entry
operator|->
name|changed_paths2
condition|)
return|return
name|SVN_NO_ERROR
return|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|svn_log_changed_path_t
modifier|*
name|log_item
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|log_item
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|svn_path_compare_paths
argument_list|(
name|b
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|log_item
operator|->
name|action
operator|==
literal|'D'
operator|||
name|log_item
operator|->
name|action
operator|==
literal|'R'
operator|)
condition|)
block|{
comment|/* Found the first deletion or replacement, we are done. */
name|b
operator|->
name|revision_deleted
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
break|break;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__get_deleted_rev_from_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_deleted_path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision_deleted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
name|log_path_del_rev_t
name|log_path_deleted_baton
decl_stmt|;
comment|/* Fetch the absolute FS path associated with PATH. */
name|SVN_ERR
argument_list|(
name|get_fs_path
argument_list|(
operator|&
name|fs_path
argument_list|,
name|session
argument_list|,
name|rel_deleted_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|peg_revision
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid peg revision %ld"
argument_list|)
argument_list|,
name|peg_revision
argument_list|)
return|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_revision
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid end revision %ld"
argument_list|)
argument_list|,
name|end_revision
argument_list|)
return|;
if|if
condition|(
name|end_revision
operator|<=
name|peg_revision
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Peg revision must precede end revision"
argument_list|)
argument_list|)
return|;
name|log_path_deleted_baton
operator|.
name|path
operator|=
name|fs_path
expr_stmt|;
name|log_path_deleted_baton
operator|.
name|revision_deleted
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Examine the logs of SESSION's URL to find when DELETED_PATH was first      deleted or replaced. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_log2
argument_list|(
name|session
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|end_revision
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|log_path_del_receiver
argument_list|,
operator|&
name|log_path_deleted_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|revision_deleted
operator|=
name|log_path_deleted_baton
operator|.
name|revision_deleted
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra__get_inherited_props_walk
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|inherited_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_url
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|inherited_props
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk to the root of the repository getting inherited      props for PATH. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|session
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|session
argument_list|,
operator|&
name|session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|parent_url
operator|=
name|session_url
expr_stmt|;
while|while
condition|(
name|strcmp
argument_list|(
name|repos_root_url
argument_list|,
name|parent_url
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|parent_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|final_hash
init|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|parent_url
operator|=
name|svn_uri_dirname
argument_list|(
name|parent_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|session
argument_list|,
name|parent_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|session
operator|->
name|vtable
operator|->
name|get_dir
argument_list|(
name|session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|parent_props
argument_list|,
literal|""
argument_list|,
name|revision
argument_list|,
name|SVN_DIRENT_ALL
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If the user doesn't have read access to a parent path then          skip, but allow them to inherit from further up. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_NOT_AUTHORIZED
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_FORBIDDEN
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|parent_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|klen
init|=
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|==
name|svn_prop_regular_kind
condition|)
block|{
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|final_hash
argument_list|,
name|name
argument_list|,
name|klen
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|final_hash
argument_list|)
condition|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|new_iprop
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_iprop
argument_list|)
argument_list|)
decl_stmt|;
name|new_iprop
operator|->
name|path_or_url
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|parent_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|new_iprop
operator|->
name|prop_hash
operator|=
name|final_hash
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
operator|&
name|new_iprop
argument_list|,
operator|*
name|inherited_props
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reparent session back to original URL. */
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|session
argument_list|,
name|session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

