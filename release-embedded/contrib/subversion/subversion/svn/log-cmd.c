begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * log-cmd.c -- Display log messages  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_fnmatch.h>
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Baton for log_entry_receiver() and log_entry_receiver_xml(). */
end_comment

begin_struct
struct|struct
name|log_receiver_baton
block|{
comment|/* Client context. */
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
comment|/* The target of the log operation. */
specifier|const
name|char
modifier|*
name|target_path_or_url
decl_stmt|;
name|svn_opt_revision_t
name|target_peg_revision
decl_stmt|;
comment|/* Don't print log message body nor its line count. */
name|svn_boolean_t
name|omit_log_message
decl_stmt|;
comment|/* Whether to show diffs in the log. (maps to --diff) */
name|svn_boolean_t
name|show_diff
decl_stmt|;
comment|/* Depth applied to diff output. */
name|svn_depth_t
name|depth
decl_stmt|;
comment|/* Diff arguments received from command line. */
specifier|const
name|char
modifier|*
name|diff_extensions
decl_stmt|;
comment|/* Stack which keeps track of merge revision nesting, using svn_revnum_t's */
name|apr_array_header_t
modifier|*
name|merge_stack
decl_stmt|;
comment|/* Log message search patterns. Log entries will only be shown if the author,    * the log message, or a changed path matches one of these patterns. */
name|apr_array_header_t
modifier|*
name|search_patterns
decl_stmt|;
comment|/* Pool for persistent allocations. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The separator between log messages. */
end_comment

begin_define
define|#
directive|define
name|SEP_STRING
define|\
value|"------------------------------------------------------------------------\n"
end_define

begin_comment
comment|/* Display a diff of the subtree TARGET_PATH_OR_URL@TARGET_PEG_REVISION as  * it changed in the revision that LOG_ENTRY describes.  *  * Restrict the diff to depth DEPTH.  Pass DIFF_EXTENSIONS along to the diff  * subroutine.  *  * Write the diff to OUTSTREAM and write any stderr output to ERRSTREAM.  * ### How is exit code handled? 0 and 1 -> SVN_NO_ERROR, else an svn error?  * ### Should we get rid of ERRSTREAM and use svn_error_t instead?  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|display_diff
parameter_list|(
specifier|const
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|target_peg_revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|diff_extensions
parameter_list|,
name|svn_stream_t
modifier|*
name|outstream
parameter_list|,
name|svn_stream_t
modifier|*
name|errstream
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|diff_options
decl_stmt|;
name|svn_opt_revision_t
name|start_revision
decl_stmt|;
name|svn_opt_revision_t
name|end_revision
decl_stmt|;
comment|/* Fall back to "" to get options initialized either way. */
if|if
condition|(
name|diff_extensions
condition|)
name|diff_options
operator|=
name|svn_cstring_split
argument_list|(
name|diff_extensions
argument_list|,
literal|" \t\n\r"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|diff_options
operator|=
name|NULL
expr_stmt|;
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|start_revision
operator|.
name|value
operator|.
name|number
operator|=
name|log_entry
operator|->
name|revision
operator|-
literal|1
expr_stmt|;
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|end_revision
operator|.
name|value
operator|.
name|number
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|outstream
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_diff_peg6
argument_list|(
name|diff_options
argument_list|,
name|target_path_or_url
argument_list|,
name|target_peg_revision
argument_list|,
operator|&
name|start_revision
argument_list|,
operator|&
name|end_revision
argument_list|,
name|NULL
argument_list|,
name|depth
argument_list|,
name|FALSE
comment|/* ignore ancestry */
argument_list|,
name|FALSE
comment|/* no diff added */
argument_list|,
name|TRUE
comment|/* no diff deleted */
argument_list|,
name|FALSE
comment|/* show copies as adds */
argument_list|,
name|FALSE
comment|/* ignore content type */
argument_list|,
name|FALSE
comment|/* ignore prop diff */
argument_list|,
name|FALSE
comment|/* properties only */
argument_list|,
name|FALSE
comment|/* use git diff format */
argument_list|,
name|svn_cmdline_output_encoding
argument_list|(
name|pool
argument_list|)
argument_list|,
name|outstream
argument_list|,
name|errstream
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|outstream
argument_list|,
name|_
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if SEARCH_PATTERN matches the AUTHOR, DATE, LOG_MESSAGE,  * or a path in the set of keys of the CHANGED_PATHS hash. Else, return FALSE.  * Any of AUTHOR, DATE, LOG_MESSAGE, and CHANGED_PATHS may be NULL. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|match_search_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|search_pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|date
parameter_list|,
specifier|const
name|char
modifier|*
name|log_message
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Match any substring containing the pattern, like UNIX 'grep' does. */
specifier|const
name|char
modifier|*
name|pattern
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"*%s*"
argument_list|,
name|search_pattern
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Does the author match the search pattern? */
if|if
condition|(
name|author
operator|&&
name|apr_fnmatch
argument_list|(
name|pattern
argument_list|,
name|author
argument_list|,
name|flags
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
return|return
name|TRUE
return|;
comment|/* Does the date the search pattern? */
if|if
condition|(
name|date
operator|&&
name|apr_fnmatch
argument_list|(
name|pattern
argument_list|,
name|date
argument_list|,
name|flags
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
return|return
name|TRUE
return|;
comment|/* Does the log message the search pattern? */
if|if
condition|(
name|log_message
operator|&&
name|apr_fnmatch
argument_list|(
name|pattern
argument_list|,
name|log_message
argument_list|,
name|flags
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|changed_paths
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Does a changed path match the search pattern? */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|changed_paths
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_log_changed_path2_t
modifier|*
name|log_item
decl_stmt|;
if|if
condition|(
name|apr_fnmatch
argument_list|(
name|pattern
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
return|return
name|TRUE
return|;
comment|/* Match copy-from paths, too. */
name|log_item
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_item
operator|->
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|log_item
operator|->
name|copyfrom_rev
argument_list|)
operator|&&
name|apr_fnmatch
argument_list|(
name|pattern
argument_list|,
name|log_item
operator|->
name|copyfrom_path
argument_list|,
name|flags
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Match all search patterns in SEARCH_PATTERNS against AUTHOR, DATE, MESSAGE,  * and CHANGED_PATHS. Return TRUE if any pattern matches, else FALSE.  * SCRACH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|match_search_patterns
parameter_list|(
name|apr_array_header_t
modifier|*
name|search_patterns
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|date
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|match
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|search_patterns
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_array_header_t
modifier|*
name|pattern_group
decl_stmt|;
name|int
name|j
decl_stmt|;
name|pattern_group
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|search_patterns
argument_list|,
name|i
argument_list|,
name|apr_array_header_t
operator|*
argument_list|)
expr_stmt|;
comment|/* All patterns within the group must match. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pattern_group
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|pattern_group
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|match
operator|=
name|match_search_pattern
argument_list|(
name|pattern
argument_list|,
name|author
argument_list|,
name|date
argument_list|,
name|message
argument_list|,
name|changed_paths
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
block|}
name|match
operator|=
operator|(
name|match
operator|&&
name|j
operator|==
name|pattern_group
operator|->
name|nelts
operator|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/* Implement `svn_log_entry_receiver_t', printing the logs in  * a human-readable and machine-parseable format.  *  * BATON is of type `struct log_receiver_baton'.  *  * First, print a header line.  Then if CHANGED_PATHS is non-null,  * print all affected paths in a list headed "Changed paths:\n",  * immediately following the header line.  Then print a newline  * followed by the message body, unless BATON->omit_log_message is true.  *  * Here are some examples of the output:  *  * $ svn log -r1847:1846  * ------------------------------------------------------------------------  * rev 1847:  cmpilato | Wed 1 May 2002 15:44:26 | 7 lines  *  * Fix for Issue #694.  *  * * subversion/libsvn_repos/delta.c  *   (delta_files): Rework the logic in this function to only call  * send_text_deltas if there are deltas to send, and within that case,  * only use a real delta stream if the caller wants real text deltas.  *  * ------------------------------------------------------------------------  * rev 1846:  whoever | Wed 1 May 2002 15:23:41 | 1 line  *  * imagine an example log message here  * ------------------------------------------------------------------------  *  * Or:  *  * $ svn log -r1847:1846 -v  * ------------------------------------------------------------------------  * rev 1847:  cmpilato | Wed 1 May 2002 15:44:26 | 7 lines  * Changed paths:  *    M /trunk/subversion/libsvn_repos/delta.c  *  * Fix for Issue #694.  *  * * subversion/libsvn_repos/delta.c  *   (delta_files): Rework the logic in this function to only call  * send_text_deltas if there are deltas to send, and within that case,  * only use a real delta stream if the caller wants real text deltas.  *  * ------------------------------------------------------------------------  * rev 1846:  whoever | Wed 1 May 2002 15:23:41 | 1 line  * Changed paths:  *    M /trunk/notes/fs_dumprestore.txt  *    M /trunk/subversion/libsvn_repos/dump.c  *  * imagine an example log message here  * ------------------------------------------------------------------------  *  * Or:  *  * $ svn log -r1847:1846 -q  * ------------------------------------------------------------------------  * rev 1847:  cmpilato | Wed 1 May 2002 15:44:26  * ------------------------------------------------------------------------  * rev 1846:  whoever | Wed 1 May 2002 15:23:41  * ------------------------------------------------------------------------  *  * Or:  *  * $ svn log -r1847:1846 -qv  * ------------------------------------------------------------------------  * rev 1847:  cmpilato | Wed 1 May 2002 15:44:26  * Changed paths:  *    M /trunk/subversion/libsvn_repos/delta.c  * ------------------------------------------------------------------------  * rev 1846:  whoever | Wed 1 May 2002 15:23:41  * Changed paths:  *    M /trunk/notes/fs_dumprestore.txt  *    M /trunk/subversion/libsvn_repos/dump.c  * ------------------------------------------------------------------------  *  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_entry_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_receiver_baton
modifier|*
name|lb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
decl_stmt|;
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_compat_log_revprops_out
argument_list|(
operator|&
name|author
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|message
argument_list|,
name|log_entry
operator|->
name|revprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|==
literal|0
operator|&&
name|message
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|log_entry
operator|->
name|revision
argument_list|)
condition|)
block|{
name|apr_array_pop
argument_list|(
name|lb
operator|->
name|merge_stack
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* ### See http://subversion.tigris.org/issues/show_bug.cgi?id=807      for more on the fallback fuzzy conversions below. */
if|if
condition|(
name|author
operator|==
name|NULL
condition|)
name|author
operator|=
name|_
argument_list|(
literal|"(no author)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|&&
name|date
index|[
literal|0
index|]
condition|)
comment|/* Convert date to a format for humans. */
name|SVN_ERR
argument_list|(
name|svn_cl__time_cstring_to_human_cstring
argument_list|(
operator|&
name|date
argument_list|,
name|date
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|date
operator|=
name|_
argument_list|(
literal|"(no date)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lb
operator|->
name|omit_log_message
operator|&&
name|message
operator|==
name|NULL
condition|)
name|message
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|lb
operator|->
name|search_patterns
operator|&&
operator|!
name|match_search_patterns
argument_list|(
name|lb
operator|->
name|search_patterns
argument_list|,
name|author
argument_list|,
name|date
argument_list|,
name|message
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|,
name|pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|log_entry
operator|->
name|has_children
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|lb
operator|->
name|merge_stack
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|SEP_STRING
literal|"r%ld | %s | %s"
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|author
argument_list|,
name|date
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
comment|/* Number of lines in the msg. */
name|int
name|lines
init|=
name|svn_cstring_count_newlines
argument_list|(
name|message
argument_list|)
operator|+
literal|1
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|Q_
argument_list|(
literal|" | %d line"
argument_list|,
literal|" | %d lines"
argument_list|,
name|lines
argument_list|)
argument_list|,
name|lines
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|changed_paths2
condition|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_paths
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get an array of sorted hash keys. */
name|sorted_paths
operator|=
name|svn_sort__hash
argument_list|(
name|log_entry
operator|->
name|changed_paths2
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Changed paths:\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
modifier|*
name|item
init|=
operator|&
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|sorted_paths
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|item
operator|->
name|key
decl_stmt|;
name|svn_log_changed_path2_t
modifier|*
name|log_item
init|=
name|item
operator|->
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_data
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_item
operator|->
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|log_item
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|copy_data
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|" (from %s:%ld)"
argument_list|)
argument_list|,
name|log_item
operator|->
name|copyfrom_path
argument_list|,
name|log_item
operator|->
name|copyfrom_rev
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"   %c %s%s\n"
argument_list|,
name|log_item
operator|->
name|action
argument_list|,
name|path
argument_list|,
name|copy_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lb
operator|->
name|merge_stack
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Print the result of merge line */
if|if
condition|(
name|log_entry
operator|->
name|subtractive_merge
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Reverse merged via:"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Merged via:"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lb
operator|->
name|merge_stack
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_revnum_t
name|rev
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lb
operator|->
name|merge_stack
argument_list|,
name|i
argument_list|,
name|svn_revnum_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|" r%ld%c"
argument_list|,
name|rev
argument_list|,
name|i
operator|==
name|lb
operator|->
name|merge_stack
operator|->
name|nelts
operator|-
literal|1
condition|?
literal|'\n'
else|:
literal|','
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
comment|/* A blank line always precedes the log message. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"\n%s\n"
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print a diff if requested. */
if|if
condition|(
name|lb
operator|->
name|show_diff
condition|)
block|{
name|svn_stream_t
modifier|*
name|outstream
decl_stmt|;
name|svn_stream_t
modifier|*
name|errstream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|outstream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stderr
argument_list|(
operator|&
name|errstream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|display_diff
argument_list|(
name|log_entry
argument_list|,
name|lb
operator|->
name|target_path_or_url
argument_list|,
operator|&
name|lb
operator|->
name|target_peg_revision
argument_list|,
name|lb
operator|->
name|depth
argument_list|,
name|lb
operator|->
name|diff_extensions
argument_list|,
name|outstream
argument_list|,
name|errstream
argument_list|,
name|lb
operator|->
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|outstream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|errstream
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_entry
operator|->
name|has_children
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|lb
operator|->
name|merge_stack
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_log_entry_receiver_t', printing the logs in XML.  *  * BATON is of type `struct log_receiver_baton'.  *  * Here is an example of the output; note that the "<log>" and  * "</log>" tags are not emitted by this function:  *  * $ svn log --xml -r 1648:1649  *<log>  *<logentry  *    revision="1648">  *<author>david</author>  *<date>2002-04-06T16:34:51.428043Z</date>  *<msg> * packages/rpm/subversion.spec : Now requires apache 2.0.36.  *</msg>  *</logentry>  *<logentry  *    revision="1649">  *<author>cmpilato</author>  *<date>2002-04-06T17:01:28.185136Z</date>  *<msg>Fix error handling when the $EDITOR is needed but unavailable.  Ah  * ... now that&apos;s *much* nicer.  *  * * subversion/clients/cmdline/util.c  *   (svn_cl__edit_externally): Clean up the&quot;no external editor&quot;  *   error message.  *   (svn_cl__get_log_message): Wrap&quot;no external editor&quot;  *   errors with helpful hints about the -m and -F options.  *  * * subversion/libsvn_client/commit.c  *   (svn_client_commit): Actually capture and propagate&quot;no external  *   editor&quot; errors.</msg>  *</logentry>  *</log>  *  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_entry_receiver_xml
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_receiver_baton
modifier|*
name|lb
init|=
name|baton
decl_stmt|;
comment|/* Collate whole log message into sb before printing. */
name|svn_stringbuf_t
modifier|*
name|sb
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|char
modifier|*
name|revstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
decl_stmt|;
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_compat_log_revprops_out
argument_list|(
operator|&
name|author
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|message
argument_list|,
name|log_entry
operator|->
name|revprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|==
literal|0
operator|&&
name|message
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|log_entry
operator|->
name|revision
argument_list|)
condition|)
block|{
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"logentry"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__error_checked_fputs
argument_list|(
name|sb
operator|->
name|data
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_pop
argument_list|(
name|lb
operator|->
name|merge_stack
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Match search pattern before XML-escaping. */
if|if
condition|(
name|lb
operator|->
name|search_patterns
operator|&&
operator|!
name|match_search_patterns
argument_list|(
name|lb
operator|->
name|search_patterns
argument_list|,
name|author
argument_list|,
name|date
argument_list|,
name|message
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|,
name|pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|log_entry
operator|->
name|has_children
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|lb
operator|->
name|merge_stack
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|author
condition|)
name|author
operator|=
name|svn_xml_fuzzy_escape
argument_list|(
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|date
operator|=
name|svn_xml_fuzzy_escape
argument_list|(
name|date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|message
operator|=
name|svn_xml_fuzzy_escape
argument_list|(
name|message
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|revstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|)
expr_stmt|;
comment|/*<logentry revision="xxx"> */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"logentry"
argument_list|,
literal|"revision"
argument_list|,
name|revstr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*<author>xxx</author> */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"author"
argument_list|,
name|author
argument_list|)
expr_stmt|;
comment|/* Print the full, uncut, date.  This is machine output. */
comment|/* According to the docs for svn_log_entry_receiver_t, either      NULL or the empty string represents no date.  Avoid outputting an      empty date element. */
if|if
condition|(
name|date
operator|&&
name|date
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|date
operator|=
name|NULL
expr_stmt|;
comment|/*<date>xxx</date> */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"date"
argument_list|,
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|changed_paths2
condition|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_paths
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*<paths> */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"paths"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get an array of sorted hash keys. */
name|sorted_paths
operator|=
name|svn_sort__hash
argument_list|(
name|log_entry
operator|->
name|changed_paths2
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
modifier|*
name|item
init|=
operator|&
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|sorted_paths
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|item
operator|->
name|key
decl_stmt|;
name|svn_log_changed_path2_t
modifier|*
name|log_item
init|=
name|item
operator|->
name|value
decl_stmt|;
name|char
name|action
index|[
literal|2
index|]
decl_stmt|;
name|action
index|[
literal|0
index|]
operator|=
name|log_item
operator|->
name|action
expr_stmt|;
name|action
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|log_item
operator|->
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|log_item
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
comment|/*<path action="X" copyfrom-path="xxx" copyfrom-rev="xxx"> */
name|revstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|log_item
operator|->
name|copyfrom_rev
argument_list|)
expr_stmt|;
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
literal|"path"
argument_list|,
literal|"action"
argument_list|,
name|action
argument_list|,
literal|"copyfrom-path"
argument_list|,
name|log_item
operator|->
name|copyfrom_path
argument_list|,
literal|"copyfrom-rev"
argument_list|,
name|revstr
argument_list|,
literal|"kind"
argument_list|,
name|svn_cl__node_kind_str_xml
argument_list|(
name|log_item
operator|->
name|node_kind
argument_list|)
argument_list|,
literal|"text-mods"
argument_list|,
name|svn_tristate__to_word
argument_list|(
name|log_item
operator|->
name|text_modified
argument_list|)
argument_list|,
literal|"prop-mods"
argument_list|,
name|svn_tristate__to_word
argument_list|(
name|log_item
operator|->
name|props_modified
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*<path action="X"> */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
literal|"path"
argument_list|,
literal|"action"
argument_list|,
name|action
argument_list|,
literal|"kind"
argument_list|,
name|svn_cl__node_kind_str_xml
argument_list|(
name|log_item
operator|->
name|node_kind
argument_list|)
argument_list|,
literal|"text-mods"
argument_list|,
name|svn_tristate__to_word
argument_list|(
name|log_item
operator|->
name|text_modified
argument_list|)
argument_list|,
literal|"prop-mods"
argument_list|,
name|svn_tristate__to_word
argument_list|(
name|log_item
operator|->
name|props_modified
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* xxx</path> */
name|svn_xml_escape_cdata_cstring
argument_list|(
operator|&
name|sb
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"path"
argument_list|)
expr_stmt|;
block|}
comment|/*</paths> */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"paths"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
comment|/*<msg>xxx</msg> */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"msg"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|svn_compat_log_revprops_clear
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revprops
operator|&&
name|apr_hash_count
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|)
operator|>
literal|0
condition|)
block|{
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"revprops"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__print_xml_prop_hash
argument_list|(
operator|&
name|sb
argument_list|,
name|log_entry
operator|->
name|revprops
argument_list|,
name|FALSE
argument_list|,
comment|/* name_only */
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"revprops"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_entry
operator|->
name|has_children
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|lb
operator|->
name|merge_stack
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
else|else
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"logentry"
argument_list|)
expr_stmt|;
return|return
name|svn_cl__error_checked_fputs
argument_list|(
name|sb
operator|->
name|data
argument_list|,
name|stdout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the `svn_opt_subcommand_t' interface. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cl__log
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cl__opt_state_t
modifier|*
name|opt_state
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|opt_state
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|ctx
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|struct
name|log_receiver_baton
name|lb
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|revprops
decl_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|xml
condition|)
block|{
if|if
condition|(
name|opt_state
operator|->
name|all_revprops
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'with-all-revprops' option only valid in"
literal|" XML mode"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|no_revprops
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'with-no-revprops' option only valid in"
literal|" XML mode"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|revprop_table
operator|!=
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'with-revprop' option only valid in"
literal|" XML mode"
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|opt_state
operator|->
name|show_diff
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'diff' option is not supported in "
literal|"XML mode"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|opt_state
operator|->
name|quiet
operator|&&
name|opt_state
operator|->
name|show_diff
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'quiet' and 'diff' options are "
literal|"mutually exclusive"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|diff
operator|.
name|diff_cmd
operator|&&
operator|(
operator|!
name|opt_state
operator|->
name|show_diff
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'diff-cmd' option requires 'diff' "
literal|"option"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|diff
operator|.
name|internal_diff
operator|&&
operator|(
operator|!
name|opt_state
operator|->
name|show_diff
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'internal-diff' option requires "
literal|"'diff' option"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|extensions
operator|&&
operator|(
operator|!
name|opt_state
operator|->
name|show_diff
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'extensions' option requires 'diff' "
literal|"option"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|depth
operator|!=
name|svn_depth_unknown
operator|&&
operator|(
operator|!
name|opt_state
operator|->
name|show_diff
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'depth' option requires 'diff' option"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cl__args_to_target_array_print_reserved
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|opt_state
operator|->
name|targets
argument_list|,
name|ctx
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add "." if user passed 0 arguments */
name|svn_opt_push_implicit_dot_target
argument_list|(
name|targets
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Determine if they really want a two-revision range. */
if|if
condition|(
name|opt_state
operator|->
name|used_change_arg
condition|)
block|{
if|if
condition|(
name|opt_state
operator|->
name|used_revision_arg
operator|&&
name|opt_state
operator|->
name|revision_ranges
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"-c and -r are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_state
operator|->
name|revision_ranges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
decl_stmt|;
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|opt_state
operator|->
name|revision_ranges
argument_list|,
name|i
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|value
operator|.
name|number
operator|<
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|number
condition|)
name|range
operator|->
name|start
operator|.
name|value
operator|.
name|number
operator|++
expr_stmt|;
else|else
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|number
operator|++
expr_stmt|;
block|}
block|}
comment|/* Parse the first target into path-or-url and peg revision. */
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_parse_path
argument_list|(
operator|&
name|lb
operator|.
name|target_peg_revision
argument_list|,
operator|&
name|lb
operator|.
name|target_path_or_url
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|.
name|target_peg_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|lb
operator|.
name|target_peg_revision
operator|.
name|kind
operator|=
operator|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|?
name|svn_opt_revision_head
else|:
name|svn_opt_revision_working
operator|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|lb
operator|.
name|target_path_or_url
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
operator|||
name|target
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Only relative paths can be specified"
literal|" after a URL for 'svn log', "
literal|"but '%s' is not a relative path"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
name|lb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|lb
operator|.
name|omit_log_message
operator|=
name|opt_state
operator|->
name|quiet
expr_stmt|;
name|lb
operator|.
name|show_diff
operator|=
name|opt_state
operator|->
name|show_diff
expr_stmt|;
name|lb
operator|.
name|depth
operator|=
name|opt_state
operator|->
name|depth
operator|==
name|svn_depth_unknown
condition|?
name|svn_depth_infinity
else|:
name|opt_state
operator|->
name|depth
expr_stmt|;
name|lb
operator|.
name|diff_extensions
operator|=
name|opt_state
operator|->
name|extensions
expr_stmt|;
name|lb
operator|.
name|merge_stack
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
name|lb
operator|.
name|search_patterns
operator|=
name|opt_state
operator|->
name|search_patterns
expr_stmt|;
name|lb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|xml
condition|)
block|{
comment|/* If output is not incremental, output the XML header and wrap          everything in a top-level element. This makes the output in          its entirety a well-formed XML document. */
if|if
condition|(
operator|!
name|opt_state
operator|->
name|incremental
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__xml_print_header
argument_list|(
literal|"log"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|all_revprops
condition|)
name|revprops
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_state
operator|->
name|no_revprops
condition|)
block|{
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_state
operator|->
name|revprop_table
operator|!=
name|NULL
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|apr_hash_count
argument_list|(
name|opt_state
operator|->
name|revprop_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|opt_state
operator|->
name|revprop_table
argument_list|)
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|property
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|&&
name|value
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"cannot assign with 'with-revprop'"
literal|" option (drop the '=')"
argument_list|)
argument_list|)
return|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|property
expr_stmt|;
block|}
block|}
else|else
block|{
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_AUTHOR
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_DATE
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_LOG
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client_log5
argument_list|(
name|targets
argument_list|,
operator|&
name|lb
operator|.
name|target_peg_revision
argument_list|,
name|opt_state
operator|->
name|revision_ranges
argument_list|,
name|opt_state
operator|->
name|limit
argument_list|,
name|opt_state
operator|->
name|verbose
argument_list|,
name|opt_state
operator|->
name|stop_on_copy
argument_list|,
name|opt_state
operator|->
name|use_merge_history
argument_list|,
name|revprops
argument_list|,
name|log_entry_receiver_xml
argument_list|,
operator|&
name|lb
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|incremental
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__xml_print_footer
argument_list|(
literal|"log"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* default output format */
block|{
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_AUTHOR
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_DATE
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_LOG
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_log5
argument_list|(
name|targets
argument_list|,
operator|&
name|lb
operator|.
name|target_peg_revision
argument_list|,
name|opt_state
operator|->
name|revision_ranges
argument_list|,
name|opt_state
operator|->
name|limit
argument_list|,
name|opt_state
operator|->
name|verbose
argument_list|,
name|opt_state
operator|->
name|stop_on_copy
argument_list|,
name|opt_state
operator|->
name|use_merge_history
argument_list|,
name|revprops
argument_list|,
name|log_entry_receiver
argument_list|,
operator|&
name|lb
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|incremental
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|SEP_STRING
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

