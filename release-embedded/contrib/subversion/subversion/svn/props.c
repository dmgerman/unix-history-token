begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * props.c: Utility functions for property handling  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_function
name|svn_error_t
modifier|*
name|svn_cl__revprop_prepare
parameter_list|(
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|URL
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_number
operator|&&
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_date
operator|&&
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_head
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Must specify the revision as a number, a date or 'HEAD' "
literal|"when operating on a revision property"
argument_list|)
argument_list|)
return|;
comment|/* There must be exactly one target at this point.  If it was optional and      unspecified by the user, the caller has already added the implicit '.'. */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|!=
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Wrong number of targets specified"
argument_list|)
argument_list|)
return|;
comment|/* (The docs say the target must be either a URL or implicit '.', but      explicit WC targets are also accepted.) */
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_url_from_path2
argument_list|(
name|URL
argument_list|,
name|target
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|URL
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNVERSIONED_RESOURCE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Either a URL or versioned item is required"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_cl__check_boolean_prop_val
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|propval
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|propbuf
decl_stmt|;
if|if
condition|(
operator|!
name|svn_prop_is_boolean
argument_list|(
name|propname
argument_list|)
condition|)
return|return;
name|propbuf
operator|=
name|svn_stringbuf_create
argument_list|(
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|propbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|propbuf
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|svn_cstring_casecmp
argument_list|(
name|propbuf
operator|->
name|data
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
operator|||
name|svn_cstring_casecmp
argument_list|(
name|propbuf
operator|->
name|data
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
operator|||
name|svn_cstring_casecmp
argument_list|(
name|propbuf
operator|->
name|data
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|||
name|svn_cstring_casecmp
argument_list|(
name|propbuf
operator|->
name|data
argument_list|,
literal|"false"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROPERTY_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"To turn off the %s property, use 'svn propdel';\n"
literal|"setting the property to '%s' will not turn it off."
argument_list|)
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
decl_stmt|;
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Context for sorting property names */
end_comment

begin_struct
struct|struct
name|simprop_context_t
block|{
name|svn_string_t
name|name
decl_stmt|;
comment|/* The name of the property we're comparing with */
name|svn_membuf_t
name|buffer
decl_stmt|;
comment|/* Buffer for similarity testing */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|simprop_t
block|{
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
comment|/* The original svn: property name */
name|svn_string_t
name|name
decl_stmt|;
comment|/* The property name without the svn: prefix */
name|unsigned
name|int
name|score
decl_stmt|;
comment|/* The similarity score */
name|apr_size_t
name|diff
decl_stmt|;
comment|/* Number of chars different from context.name */
name|struct
name|simprop_context_t
modifier|*
name|context
decl_stmt|;
comment|/* Sorting context for qsort() */
block|}
struct|;
end_struct

begin_comment
comment|/* Similarity test between two property names */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|unsigned
name|int
name|simprop_key_diff
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|key
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|ctx
parameter_list|,
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|diff
parameter_list|)
block|{
name|apr_size_t
name|lcs
decl_stmt|;
specifier|const
name|unsigned
name|int
name|score
init|=
name|svn_string__similarity
argument_list|(
name|key
argument_list|,
name|ctx
argument_list|,
name|buffer
argument_list|,
operator|&
name|lcs
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|len
operator|>
name|ctx
operator|->
name|len
condition|)
operator|*
name|diff
operator|=
name|key
operator|->
name|len
operator|-
name|lcs
expr_stmt|;
else|else
operator|*
name|diff
operator|=
name|ctx
operator|->
name|len
operator|-
name|lcs
expr_stmt|;
return|return
name|score
return|;
block|}
end_function

begin_comment
comment|/* Key comparator for qsort for simprop_t */
end_comment

begin_function
specifier|static
name|int
name|simprop_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|pkeya
parameter_list|,
specifier|const
name|void
modifier|*
name|pkeyb
parameter_list|)
block|{
name|struct
name|simprop_t
modifier|*
specifier|const
name|keya
init|=
operator|*
operator|(
expr|struct
name|simprop_t
operator|*
specifier|const
operator|*
operator|)
name|pkeya
decl_stmt|;
name|struct
name|simprop_t
modifier|*
specifier|const
name|keyb
init|=
operator|*
operator|(
expr|struct
name|simprop_t
operator|*
specifier|const
operator|*
operator|)
name|pkeyb
decl_stmt|;
name|struct
name|simprop_context_t
modifier|*
specifier|const
name|context
init|=
name|keya
operator|->
name|context
decl_stmt|;
if|if
condition|(
name|keya
operator|->
name|score
operator|==
operator|-
literal|1
condition|)
name|keya
operator|->
name|score
operator|=
name|simprop_key_diff
argument_list|(
operator|&
name|keya
operator|->
name|name
argument_list|,
operator|&
name|context
operator|->
name|name
argument_list|,
operator|&
name|context
operator|->
name|buffer
argument_list|,
operator|&
name|keya
operator|->
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyb
operator|->
name|score
operator|==
operator|-
literal|1
condition|)
name|keyb
operator|->
name|score
operator|=
name|simprop_key_diff
argument_list|(
operator|&
name|keyb
operator|->
name|name
argument_list|,
operator|&
name|context
operator|->
name|name
argument_list|,
operator|&
name|context
operator|->
name|buffer
argument_list|,
operator|&
name|keyb
operator|->
name|diff
argument_list|)
expr_stmt|;
return|return
operator|(
name|keya
operator|->
name|score
operator|<
name|keyb
operator|->
name|score
condition|?
literal|1
else|:
operator|(
name|keya
operator|->
name|score
operator|>
name|keyb
operator|->
name|score
condition|?
operator|-
literal|1
else|:
operator|(
name|keya
operator|->
name|diff
operator|>
name|keyb
operator|->
name|diff
condition|?
literal|1
else|:
operator|(
name|keya
operator|->
name|diff
operator|<
name|keyb
operator|->
name|diff
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|force_prop_option_message
parameter_list|(
name|svn_cl__prop_use_t
name|prop_use
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
switch|switch
condition|(
name|prop_use
condition|)
block|{
case|case
name|svn_cl__prop_use_set
case|:
return|return
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"(To set the '%s' property, re-run with '--force'.)"
argument_list|)
argument_list|,
name|prop_name
argument_list|)
return|;
case|case
name|svn_cl__prop_use_edit
case|:
return|return
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"(To edit the '%s' property, re-run with '--force'.)"
argument_list|)
argument_list|,
name|prop_name
argument_list|)
return|;
case|case
name|svn_cl__prop_use_use
case|:
default|default:
return|return
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"(To use the '%s' property, re-run with '--force'.)"
argument_list|)
argument_list|,
name|prop_name
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|wrong_prop_error_message
parameter_list|(
name|svn_cl__prop_use_t
name|prop_use
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
switch|switch
condition|(
name|prop_use
condition|)
block|{
case|case
name|svn_cl__prop_use_set
case|:
return|return
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid %s property name;"
literal|" re-run with '--force' to set it"
argument_list|)
argument_list|,
name|prop_name
argument_list|,
name|SVN_PROP_PREFIX
argument_list|)
return|;
case|case
name|svn_cl__prop_use_edit
case|:
return|return
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid %s property name;"
literal|" re-run with '--force' to edit it"
argument_list|)
argument_list|,
name|prop_name
argument_list|,
name|SVN_PROP_PREFIX
argument_list|)
return|;
case|case
name|svn_cl__prop_use_use
case|:
default|default:
return|return
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid %s property name;"
literal|" re-run with '--force' to use it"
argument_list|)
argument_list|,
name|prop_name
argument_list|,
name|SVN_PROP_PREFIX
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__check_svn_prop_name
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|svn_boolean_t
name|revprop
parameter_list|,
name|svn_cl__prop_use_t
name|prop_use
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|nodeprops
index|[]
init|=
block|{
name|SVN_PROP_NODE_ALL_PROPS
block|}
decl_stmt|;
specifier|static
specifier|const
name|apr_size_t
name|nodeprops_len
init|=
sizeof|sizeof
argument_list|(
name|nodeprops
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|nodeprops
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|revprops
index|[]
init|=
block|{
name|SVN_PROP_REVISION_ALL_PROPS
block|}
decl_stmt|;
specifier|static
specifier|const
name|apr_size_t
name|revprops_len
init|=
sizeof|sizeof
argument_list|(
name|revprops
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|revprops
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
specifier|const
name|proplist
init|=
operator|(
name|revprop
condition|?
name|revprops
else|:
name|nodeprops
operator|)
decl_stmt|;
specifier|const
name|apr_size_t
name|numprops
init|=
operator|(
name|revprop
condition|?
name|revprops_len
else|:
name|nodeprops_len
operator|)
decl_stmt|;
name|struct
name|simprop_t
modifier|*
modifier|*
name|propkeys
decl_stmt|;
name|struct
name|simprop_t
modifier|*
name|propbuf
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|struct
name|simprop_context_t
name|context
decl_stmt|;
name|svn_string_t
name|prefix
decl_stmt|;
name|context
operator|.
name|name
operator|.
name|data
operator|=
name|propname
expr_stmt|;
name|context
operator|.
name|name
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|propname
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|data
operator|=
name|SVN_PROP_PREFIX
expr_stmt|;
name|prefix
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|SVN_PROP_PREFIX
argument_list|)
expr_stmt|;
name|svn_membuf__create
argument_list|(
operator|&
name|context
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* First, check if the name is even close to being in the svn: namespace.      It must contain a colon in the right place, and we only allow      one-char typos or a single transposition. */
if|if
condition|(
name|context
operator|.
name|name
operator|.
name|len
operator|<
name|prefix
operator|.
name|len
operator|||
name|context
operator|.
name|name
operator|.
name|data
index|[
name|prefix
operator|.
name|len
operator|-
literal|1
index|]
operator|!=
name|prefix
operator|.
name|data
index|[
name|prefix
operator|.
name|len
operator|-
literal|1
index|]
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Wrong prefix, ignore */
else|else
block|{
name|apr_size_t
name|lcs
decl_stmt|;
specifier|const
name|apr_size_t
name|name_len
init|=
name|context
operator|.
name|name
operator|.
name|len
decl_stmt|;
name|context
operator|.
name|name
operator|.
name|len
operator|=
name|prefix
operator|.
name|len
expr_stmt|;
comment|/* Only check up to the prefix length */
name|svn_string__similarity
argument_list|(
operator|&
name|context
operator|.
name|name
argument_list|,
operator|&
name|prefix
argument_list|,
operator|&
name|context
operator|.
name|buffer
argument_list|,
operator|&
name|lcs
argument_list|)
expr_stmt|;
name|context
operator|.
name|name
operator|.
name|len
operator|=
name|name_len
expr_stmt|;
comment|/* Restore the original propname length */
if|if
condition|(
name|lcs
operator|<
name|prefix
operator|.
name|len
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Wrong prefix, ignore */
comment|/* If the prefix is slightly different, the rest must be          identical in order to trigger the error. */
if|if
condition|(
name|lcs
operator|==
name|prefix
operator|.
name|len
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numprops
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|proplist
index|[
name|i
index|]
operator|+
name|prefix
operator|.
name|len
argument_list|,
name|propname
operator|+
name|prefix
operator|.
name|len
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid %s property name;"
literal|" did you mean '%s'?\n%s"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|proplist
index|[
name|i
index|]
argument_list|,
name|force_prop_option_message
argument_list|(
name|prop_use
argument_list|,
name|propname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Now find the closest match from amongst the set of reserved      node or revision property names. Skip the prefix while matching,      we already know that it's the same and looking at it would only      skew the results. */
name|propkeys
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|numprops
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|simprop_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|propbuf
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|numprops
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|simprop_t
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|name
operator|.
name|data
operator|+=
name|prefix
operator|.
name|len
expr_stmt|;
name|context
operator|.
name|name
operator|.
name|len
operator|-=
name|prefix
operator|.
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numprops
condition|;
operator|++
name|i
control|)
block|{
name|propkeys
index|[
name|i
index|]
operator|=
operator|&
name|propbuf
index|[
name|i
index|]
expr_stmt|;
name|propbuf
index|[
name|i
index|]
operator|.
name|propname
operator|=
name|proplist
index|[
name|i
index|]
expr_stmt|;
name|propbuf
index|[
name|i
index|]
operator|.
name|name
operator|.
name|data
operator|=
name|proplist
index|[
name|i
index|]
operator|+
name|prefix
operator|.
name|len
expr_stmt|;
name|propbuf
index|[
name|i
index|]
operator|.
name|name
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|propbuf
index|[
name|i
index|]
operator|.
name|name
operator|.
name|data
argument_list|)
expr_stmt|;
name|propbuf
index|[
name|i
index|]
operator|.
name|score
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|propbuf
index|[
name|i
index|]
operator|.
name|context
operator|=
operator|&
name|context
expr_stmt|;
block|}
name|qsort
argument_list|(
name|propkeys
argument_list|,
name|numprops
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|propkeys
argument_list|)
argument_list|,
name|simprop_compare
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|propkeys
index|[
literal|0
index|]
operator|->
name|diff
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We found an exact match. */
comment|/* See if we can suggest a sane alternative spelling */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numprops
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|propkeys
index|[
name|i
index|]
operator|->
name|score
operator|<
literal|666
condition|)
comment|/* 2/3 similarity required */
break|break;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
comment|/* The best alternative isn't good enough */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|wrong_prop_error_message
argument_list|(
name|prop_use
argument_list|,
name|propname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
case|case
literal|1
case|:
comment|/* There is only one good candidate */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid %s property name; did you mean '%s'?\n%s"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|propkeys
index|[
literal|0
index|]
operator|->
name|propname
argument_list|,
name|force_prop_option_message
argument_list|(
name|prop_use
argument_list|,
name|propname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
comment|/* Suggest a list of the most likely candidates */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid %s property name\n"
literal|"Did you mean '%s' or '%s'?\n%s"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|propkeys
index|[
literal|0
index|]
operator|->
name|propname
argument_list|,
name|propkeys
index|[
literal|1
index|]
operator|->
name|propname
argument_list|,
name|force_prop_option_message
argument_list|(
name|prop_use
argument_list|,
name|propname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
default|default:
comment|/* Never suggest more than three candidates */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid %s property name\n"
literal|"Did you mean '%s', '%s' or '%s'?\n%s"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|propkeys
index|[
literal|0
index|]
operator|->
name|propname
argument_list|,
name|propkeys
index|[
literal|1
index|]
operator|->
name|propname
argument_list|,
name|propkeys
index|[
literal|2
index|]
operator|->
name|propname
argument_list|,
name|force_prop_option_message
argument_list|(
name|prop_use
argument_list|,
name|propname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

end_unit

