begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* load.c --- parsing a 'dumpfile'-formatted stream.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** The parser and related helper funcs **/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_ran_dry
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Premature end of content data in dumpstream"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_malformed
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Dumpstream data appears to be malformed"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new hash *HEADERS in POOL, and read a series of    RFC822-style headers from STREAM.  Duplicate each header's name and    value into POOL and store in hash as a const char * ==> const char *.     The headers are assumed to be terminated by a single blank line,    which will be permanently sucked from the stream and tossed.     If the caller has already read in the first header line, it should    be passed in as FIRST_HEADER.  If not, pass NULL instead.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_header_block
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|first_header
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|headers
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|headers
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|header_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first_header
operator|!=
name|NULL
condition|)
block|{
name|header_str
operator|=
name|first_header
expr_stmt|;
name|first_header
operator|=
name|NULL
expr_stmt|;
comment|/* so we never visit this block again. */
name|eof
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
comment|/* Read the next line into a stringbuf. */
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|header_str
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_stringbuf_isempty
argument_list|(
name|header_str
argument_list|)
condition|)
break|break;
comment|/* end of header block */
elseif|else
if|if
condition|(
name|eof
condition|)
return|return
name|stream_ran_dry
argument_list|()
return|;
comment|/* Find the next colon in the stringbuf. */
while|while
condition|(
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Dump stream contains a malformed "
literal|"header (with no ':') at '%.20s'"
argument_list|)
argument_list|,
name|header_str
operator|->
name|data
argument_list|)
return|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Create a 'name' string and point to it. */
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|header_str
operator|->
name|data
expr_stmt|;
comment|/* Skip over the NULL byte and the space following it.  */
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|header_str
operator|->
name|len
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Dump stream contains a malformed "
literal|"header (with no value) at '%.20s'"
argument_list|)
argument_list|,
name|header_str
operator|->
name|data
argument_list|)
return|;
comment|/* Point to the 'value' string. */
name|value
operator|=
name|header_str
operator|->
name|data
operator|+
name|i
expr_stmt|;
comment|/* Store name/value in hash. */
name|svn_hash_sets
argument_list|(
operator|*
name|headers
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *PBUF to a string of length LEN, allocated in POOL, read from STREAM.    Also read a newline from STREAM and increase *ACTUAL_LEN by the total    number of bytes read from STREAM.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_key_or_val
parameter_list|(
name|char
modifier|*
modifier|*
name|pbuf
parameter_list|,
name|svn_filesize_t
modifier|*
name|actual_length
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|apr_size_t
name|numread
decl_stmt|;
name|char
name|c
decl_stmt|;
name|numread
operator|=
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|,
operator|&
name|numread
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|actual_length
operator|+=
name|numread
expr_stmt|;
if|if
condition|(
name|numread
operator|!=
name|len
condition|)
return|return
name|svn_error_trace
argument_list|(
name|stream_ran_dry
argument_list|()
argument_list|)
return|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Suck up extra newline after key data */
name|numread
operator|=
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|numread
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|actual_length
operator|+=
name|numread
expr_stmt|;
if|if
condition|(
name|numread
operator|!=
literal|1
condition|)
return|return
name|svn_error_trace
argument_list|(
name|stream_ran_dry
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
return|return
name|svn_error_trace
argument_list|(
name|stream_malformed
argument_list|()
argument_list|)
return|;
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read CONTENT_LENGTH bytes from STREAM, parsing the bytes as an    encoded Subversion properties hash, and making multiple calls to    PARSE_FNS->set_*_property on RECORD_BATON (depending on the value    of IS_NODE.)     Set *ACTUAL_LENGTH to the number of bytes consumed from STREAM.    If an error is returned, the value of *ACTUAL_LENGTH is undefined.     Use POOL for all allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_property_block
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_filesize_t
name|content_length
parameter_list|,
specifier|const
name|svn_repos_parse_fns3_t
modifier|*
name|parse_fns
parameter_list|,
name|void
modifier|*
name|record_baton
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|svn_boolean_t
name|is_node
parameter_list|,
name|svn_filesize_t
modifier|*
name|actual_length
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|strbuf
decl_stmt|;
name|apr_pool_t
modifier|*
name|proppool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
operator|*
name|actual_length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|content_length
operator|!=
operator|*
name|actual_length
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* a pointer into the stringbuf's data */
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|proppool
argument_list|)
expr_stmt|;
comment|/* Read a key length line.  (Actually, it might be PROPS_END). */
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|strbuf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|proppool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
comment|/* We could just use stream_ran_dry() or stream_malformed(),              but better to give a non-generic property block error. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Incomplete or unterminated property block"
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|actual_length
operator|+=
operator|(
name|strbuf
operator|->
name|len
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* +1 because we read a \n too. */
name|buf
operator|=
name|strbuf
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"PROPS-END"
argument_list|)
condition|)
break|break;
comment|/* no more properties. */
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'K'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|' '
operator|)
condition|)
block|{
name|char
modifier|*
name|keybuf
decl_stmt|;
name|apr_uint64_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|len
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
name|APR_SIZE_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_key_or_val
argument_list|(
operator|&
name|keybuf
argument_list|,
name|actual_length
argument_list|,
name|stream
argument_list|,
operator|(
name|apr_size_t
operator|)
name|len
argument_list|,
name|proppool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read a val length line */
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|strbuf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|proppool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
return|return
name|stream_ran_dry
argument_list|()
return|;
operator|*
name|actual_length
operator|+=
operator|(
name|strbuf
operator|->
name|len
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* +1 because we read \n too */
name|buf
operator|=
name|strbuf
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'V'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|' '
operator|)
condition|)
block|{
name|svn_string_t
name|propstring
decl_stmt|;
name|char
modifier|*
name|valbuf
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|buf
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|propstring
operator|.
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_key_or_val
argument_list|(
operator|&
name|valbuf
argument_list|,
name|actual_length
argument_list|,
name|stream
argument_list|,
name|propstring
operator|.
name|len
argument_list|,
name|proppool
argument_list|)
argument_list|)
expr_stmt|;
name|propstring
operator|.
name|data
operator|=
name|valbuf
expr_stmt|;
comment|/* Now, send the property pair to the vtable! */
if|if
condition|(
name|is_node
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|set_node_property
argument_list|(
name|record_baton
argument_list|,
name|keybuf
argument_list|,
operator|&
name|propstring
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|set_revision_property
argument_list|(
name|record_baton
argument_list|,
name|keybuf
argument_list|,
operator|&
name|propstring
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|stream_malformed
argument_list|()
return|;
comment|/* didn't find expected 'V' line */
block|}
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|' '
operator|)
condition|)
block|{
name|char
modifier|*
name|keybuf
decl_stmt|;
name|apr_uint64_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|len
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
name|APR_SIZE_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_key_or_val
argument_list|(
operator|&
name|keybuf
argument_list|,
name|actual_length
argument_list|,
name|stream
argument_list|,
operator|(
name|apr_size_t
operator|)
name|len
argument_list|,
name|proppool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't expect these in revision properties, and if we see              one when we don't have a delete_node_property callback,              then we're seeing a v3 feature in a v2 dump. */
if|if
condition|(
operator|!
name|is_node
operator|||
operator|!
name|parse_fns
operator|->
name|delete_node_property
condition|)
return|return
name|stream_malformed
argument_list|()
return|;
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|delete_node_property
argument_list|(
name|record_baton
argument_list|,
name|keybuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|stream_malformed
argument_list|()
return|;
comment|/* didn't find expected 'K' line */
block|}
comment|/* while (1) */
name|svn_pool_destroy
argument_list|(
name|proppool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read CONTENT_LENGTH bytes from STREAM, and use    PARSE_FNS->set_fulltext to push those bytes as replace fulltext for    a node.  Use BUFFER/BUFLEN to push the fulltext in "chunks".     Use POOL for all allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_text_block
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_filesize_t
name|content_length
parameter_list|,
name|svn_boolean_t
name|is_delta
parameter_list|,
specifier|const
name|svn_repos_parse_fns3_t
modifier|*
name|parse_fns
parameter_list|,
name|void
modifier|*
name|record_baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
name|buflen
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|text_stream
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|num_to_read
decl_stmt|,
name|rlen
decl_stmt|,
name|wlen
decl_stmt|;
if|if
condition|(
name|is_delta
condition|)
block|{
name|svn_txdelta_window_handler_t
name|wh
decl_stmt|;
name|void
modifier|*
name|whb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|apply_textdelta
argument_list|(
operator|&
name|wh
argument_list|,
operator|&
name|whb
argument_list|,
name|record_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
condition|)
name|text_stream
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|wh
argument_list|,
name|whb
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get a stream to which we can push the data. */
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|set_fulltext
argument_list|(
operator|&
name|text_stream
argument_list|,
name|record_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no contents to read, just write an empty buffer      through our callback. */
if|if
condition|(
name|content_length
operator|==
literal|0
condition|)
block|{
name|wlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|text_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|text_stream
argument_list|,
literal|""
argument_list|,
operator|&
name|wlen
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Regardless of whether or not we have a sink for our data, we      need to read it. */
while|while
condition|(
name|content_length
condition|)
block|{
if|if
condition|(
name|content_length
operator|>=
operator|(
name|svn_filesize_t
operator|)
name|buflen
condition|)
name|rlen
operator|=
name|buflen
expr_stmt|;
else|else
name|rlen
operator|=
operator|(
name|apr_size_t
operator|)
name|content_length
expr_stmt|;
name|num_to_read
operator|=
name|rlen
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|rlen
argument_list|)
argument_list|)
expr_stmt|;
name|content_length
operator|-=
name|rlen
expr_stmt|;
if|if
condition|(
name|rlen
operator|!=
name|num_to_read
condition|)
return|return
name|stream_ran_dry
argument_list|()
return|;
if|if
condition|(
name|text_stream
condition|)
block|{
comment|/* write however many bytes you read. */
name|wlen
operator|=
name|rlen
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|text_stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|wlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlen
operator|!=
name|rlen
condition|)
block|{
comment|/* Uh oh, didn't write as many bytes as we read. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_UNEXPECTED_EOF
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected EOF writing contents"
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/* If we opened a stream, we must close it. */
if|if
condition|(
name|text_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|text_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse VERSIONSTRING and verify that we support the dumpfile format    version number, setting *VERSION appropriately. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_format_version
parameter_list|(
name|int
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|versionstring
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|magic_len
init|=
sizeof|sizeof
argument_list|(
name|SVN_REPOS_DUMPFILE_MAGIC_HEADER
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|versionstring
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|!=
operator|(
name|versionstring
operator|+
name|magic_len
operator|)
operator|||
name|strncmp
argument_list|(
name|versionstring
argument_list|,
name|SVN_REPOS_DUMPFILE_MAGIC_HEADER
argument_list|,
name|magic_len
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed dumpfile header '%s'"
argument_list|)
argument_list|,
name|versionstring
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
operator|&
name|value
argument_list|,
name|p
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|SVN_REPOS_DUMPFILE_FORMAT_VERSION
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported dumpfile version: %d"
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
operator|*
name|version
operator|=
name|value
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** The public routines **/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_parse_dumpstream3
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|svn_repos_parse_fns3_t
modifier|*
name|parse_fns
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|svn_boolean_t
name|deltas_are_text
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|linebuf
decl_stmt|;
name|void
modifier|*
name|rev_baton
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|apr_size_t
name|buflen
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|apr_pool_t
modifier|*
name|linepool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|revpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|nodepool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|version
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|linebuf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|linepool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
return|return
name|stream_ran_dry
argument_list|()
return|;
comment|/* The first two lines of the stream are the dumpfile-format version      number, and a blank line.  To preserve backward compatibility,      don't assume the existence of newer parser-vtable functions. */
name|SVN_ERR
argument_list|(
name|parse_format_version
argument_list|(
operator|&
name|version
argument_list|,
name|linebuf
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_fns
operator|->
name|magic_header_record
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|magic_header_record
argument_list|(
name|version
argument_list|,
name|parse_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A dumpfile "record" is defined to be a header-block of      rfc822-style headers, possibly followed by a content-block.         - A header-block is always terminated by a single blank line (\n\n)         - We know whether the record has a content-block by looking for          a 'Content-length:' header.  The content-block will always be          of a specific length, plus an extra newline.       Once a record is fully sucked from the stream, an indeterminate      number of blank lines (or lines that begin with whitespace) may      follow before the next record (or the end of the stream.)   */
while|while
condition|(
literal|1
condition|)
block|{
name|apr_hash_t
modifier|*
name|headers
decl_stmt|;
name|void
modifier|*
name|node_baton
decl_stmt|;
name|svn_boolean_t
name|found_node
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|old_v1_with_cl
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|content_length
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_cl
decl_stmt|;
specifier|const
name|char
modifier|*
name|text_cl
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|svn_filesize_t
name|actual_prop_length
decl_stmt|;
comment|/* Clear our per-line pool. */
name|svn_pool_clear
argument_list|(
name|linepool
argument_list|)
expr_stmt|;
comment|/* Check for cancellation. */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep reading blank lines until we discover a new record, or until          the stream runs out. */
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|linebuf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|linepool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
if|if
condition|(
name|svn_stringbuf_isempty
argument_list|(
name|linebuf
argument_list|)
condition|)
break|break;
comment|/* end of stream, go home. */
else|else
return|return
name|stream_ran_dry
argument_list|()
return|;
block|}
if|if
condition|(
operator|(
name|linebuf
operator|->
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|svn_ctype_isspace
argument_list|(
name|linebuf
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* empty line ... loop */
comment|/*** Found the beginning of a new record. ***/
comment|/* The last line we read better be a header of some sort.          Read the whole header-block into a hash. */
name|SVN_ERR
argument_list|(
name|read_header_block
argument_list|(
name|stream
argument_list|,
name|linebuf
argument_list|,
operator|&
name|headers
argument_list|,
name|linepool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*** Handle the various header blocks. ***/
comment|/* Is this a revision record? */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
argument_list|)
condition|)
block|{
comment|/* If we already have a rev_baton open, we need to close it              and clear the per-revision subpool. */
if|if
condition|(
name|rev_baton
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|close_revision
argument_list|(
name|rev_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|new_revision_record
argument_list|(
operator|&
name|rev_baton
argument_list|,
name|headers
argument_list|,
name|parse_baton
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Or is this, perhaps, a node record? */
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|new_node_record
argument_list|(
operator|&
name|node_baton
argument_list|,
name|headers
argument_list|,
name|rev_baton
argument_list|,
name|nodepool
argument_list|)
argument_list|)
expr_stmt|;
name|found_node
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Or is this the repos UUID? */
elseif|else
if|if
condition|(
operator|(
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_UUID
argument_list|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|uuid_record
argument_list|(
name|value
argument_list|,
name|parse_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Or perhaps a dumpfile format? */
comment|/* ### TODO: use parse_format_version */
elseif|else
if|if
condition|(
operator|(
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_MAGIC_HEADER
argument_list|)
operator|)
condition|)
block|{
comment|/* ### someday, switch modes of operation here. */
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
operator|&
name|version
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Or is this bogosity?! */
else|else
block|{
comment|/* What the heck is this record?!? */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unrecognized record type in stream"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Need 3 values below to determine v1 dump type           Old (pre 0.14?) v1 dumps don't have Prop-content-length          and Text-content-length fields, but always have a properties          block in a block with Content-Length> 0 */
name|content_length
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|prop_cl
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|text_cl
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|old_v1_with_cl
operator|=
name|version
operator|==
literal|1
operator|&&
name|content_length
operator|&&
operator|!
name|prop_cl
operator|&&
operator|!
name|text_cl
expr_stmt|;
comment|/* Is there a props content-block to parse? */
if|if
condition|(
name|prop_cl
operator|||
name|old_v1_with_cl
condition|)
block|{
specifier|const
name|char
modifier|*
name|delta
init|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_DELTA
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|is_delta
init|=
operator|(
name|delta
operator|&&
name|strcmp
argument_list|(
name|delta
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
comment|/* First, remove all node properties, unless this is a delta              property block. */
if|if
condition|(
name|found_node
operator|&&
operator|!
name|is_delta
condition|)
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|remove_node_props
argument_list|(
name|node_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_property_block
argument_list|(
name|stream
argument_list|,
name|svn__atoui64
argument_list|(
name|prop_cl
condition|?
name|prop_cl
else|:
name|content_length
argument_list|)
argument_list|,
name|parse_fns
argument_list|,
name|found_node
condition|?
name|node_baton
else|:
name|rev_baton
argument_list|,
name|parse_baton
argument_list|,
name|found_node
argument_list|,
operator|&
name|actual_prop_length
argument_list|,
name|found_node
condition|?
name|nodepool
else|:
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Is there a text content-block to parse? */
if|if
condition|(
name|text_cl
condition|)
block|{
specifier|const
name|char
modifier|*
name|delta
init|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|is_delta
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|deltas_are_text
condition|)
name|is_delta
operator|=
operator|(
name|delta
operator|&&
name|strcmp
argument_list|(
name|delta
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_text_block
argument_list|(
name|stream
argument_list|,
name|svn__atoui64
argument_list|(
name|text_cl
argument_list|)
argument_list|,
name|is_delta
argument_list|,
name|parse_fns
argument_list|,
name|found_node
condition|?
name|node_baton
else|:
name|rev_baton
argument_list|,
name|buffer
argument_list|,
name|buflen
argument_list|,
name|found_node
condition|?
name|nodepool
else|:
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_v1_with_cl
condition|)
block|{
comment|/* An old-v1 block with a Content-length might have a text block.              If the property block did not consume all the bytes of the              Content-length, then it clearly does have a text block.              If not, then we must deduce whether we have an *empty* text              block or an *absent* text block.  The rules are:              - "Node-kind: file" blocks have an empty (i.e. present, but                zero-length) text block, since they represent a file                modification.  Note that file-copied-text-unmodified blocks                have no Content-length - even if they should have contained                a modified property block, the pre-0.14 dumper forgets to                dump the modified properties.              - If it is not a file node, then it is a revision or directory,                and so has an absent text block.           */
specifier|const
name|char
modifier|*
name|node_kind
decl_stmt|;
name|svn_filesize_t
name|cl_value
init|=
name|svn__atoui64
argument_list|(
name|content_length
argument_list|)
operator|-
name|actual_prop_length
decl_stmt|;
if|if
condition|(
name|cl_value
operator|||
operator|(
operator|(
name|node_kind
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|node_kind
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|parse_text_block
argument_list|(
name|stream
argument_list|,
name|cl_value
argument_list|,
name|FALSE
argument_list|,
name|parse_fns
argument_list|,
name|found_node
condition|?
name|node_baton
else|:
name|rev_baton
argument_list|,
name|buffer
argument_list|,
name|buflen
argument_list|,
name|found_node
condition|?
name|nodepool
else|:
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if we have a content-length header, did we read all of it?          in case of an old v1, we *always* read all of it, because          text-content-length == content-length - prop-content-length       */
if|if
condition|(
name|content_length
operator|&&
operator|!
name|old_v1_with_cl
condition|)
block|{
name|apr_size_t
name|rlen
decl_stmt|,
name|num_to_read
decl_stmt|;
name|svn_filesize_t
name|remaining
init|=
name|svn__atoui64
argument_list|(
name|content_length
argument_list|)
operator|-
operator|(
name|prop_cl
condition|?
name|svn__atoui64
argument_list|(
name|prop_cl
argument_list|)
else|:
literal|0
operator|)
operator|-
operator|(
name|text_cl
condition|?
name|svn__atoui64
argument_list|(
name|text_cl
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|remaining
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Sum of subblock sizes larger than "
literal|"total block content length"
argument_list|)
argument_list|)
return|;
comment|/* Consume remaining bytes in this content block */
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|remaining
operator|>=
operator|(
name|svn_filesize_t
operator|)
name|buflen
condition|)
name|rlen
operator|=
name|buflen
expr_stmt|;
else|else
name|rlen
operator|=
operator|(
name|apr_size_t
operator|)
name|remaining
expr_stmt|;
name|num_to_read
operator|=
name|rlen
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|rlen
argument_list|)
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|rlen
expr_stmt|;
if|if
condition|(
name|rlen
operator|!=
name|num_to_read
condition|)
return|return
name|stream_ran_dry
argument_list|()
return|;
block|}
block|}
comment|/* If we just finished processing a node record, we need to          close the node record and clear the per-node subpool. */
if|if
condition|(
name|found_node
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|close_node
argument_list|(
name|node_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|nodepool
argument_list|)
expr_stmt|;
block|}
comment|/*** End of processing for one record. ***/
block|}
comment|/* end of stream */
comment|/* Close out whatever revision we're in. */
if|if
condition|(
name|rev_baton
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|parse_fns
operator|->
name|close_revision
argument_list|(
name|rev_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|linepool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|nodepool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

