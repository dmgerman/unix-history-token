begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  load_editor.c: The svn_delta_editor_t editor used by svnrdump to  *  load revisions.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"svnrdump.h"
end_include

begin_define
define|#
directive|define
name|SVNRDUMP_PROP_LOCK
value|SVN_PROP_PREFIX "rdump-lock"
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|LDR_DBG
parameter_list|(
name|x
parameter_list|)
value|SVN_DBG(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LDR_DBG
parameter_list|(
name|x
parameter_list|)
value|while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/**  * General baton used by the parser functions.  */
end_comment

begin_struct
struct|struct
name|parse_baton
block|{
comment|/* Commit editor and baton used to transfer loaded revisions to      the target repository. */
specifier|const
name|svn_delta_editor_t
modifier|*
name|commit_editor
decl_stmt|;
name|void
modifier|*
name|commit_edit_baton
decl_stmt|;
comment|/* RA session(s) for committing to the target repository. */
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|aux_session
decl_stmt|;
comment|/* To bleep, or not to bleep?  (What kind of question is that?) */
name|svn_boolean_t
name|quiet
decl_stmt|;
comment|/* UUID found in the dumpstream, if any; NULL otherwise. */
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
comment|/* Root URL of the target repository. */
specifier|const
name|char
modifier|*
name|root_url
decl_stmt|;
comment|/* The "parent directory" of the target repository in which to load.      (This is essentially the difference between ROOT_URL and      SESSION's url, and roughly equivalent to the 'svnadmin load      --parent-dir' option.) */
specifier|const
name|char
modifier|*
name|parent_dir
decl_stmt|;
comment|/* A mapping of svn_revnum_t * dump stream revisions to their      corresponding svn_revnum_t * target repository revisions. */
comment|/* ### See http://subversion.tigris.org/issues/show_bug.cgi?id=3903      ### for discussion about improving the memory costs of this mapping. */
name|apr_hash_t
modifier|*
name|rev_map
decl_stmt|;
comment|/* The most recent (youngest) revision from the dump stream mapped in      REV_MAP, or SVN_INVALID_REVNUM if no revisions have been mapped. */
name|svn_revnum_t
name|last_rev_mapped
decl_stmt|;
comment|/* The oldest revision loaded from the dump stream, or      SVN_INVALID_REVNUM if none have been loaded. */
name|svn_revnum_t
name|oldest_dumpstream_rev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Use to wrap the dir_context_t in commit.c so we can keep track of  * depth, relpath and parent for open_directory and close_directory.  */
end_comment

begin_struct
struct|struct
name|directory_baton
block|{
name|void
modifier|*
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|struct
name|directory_baton
modifier|*
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Baton used to represent a node; to be used by the parser  * functions. Contains a link to the revision baton.  */
end_comment

begin_struct
struct|struct
name|node_baton
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|enum
name|svn_node_action
name|action
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|void
modifier|*
name|file_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_checksum
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Baton used to represet a revision; used by the parser  * functions. Contains a link to the parser baton.  */
end_comment

begin_struct
struct|struct
name|revision_baton
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_hash_t
modifier|*
name|revprop_table
decl_stmt|;
name|apr_int32_t
name|rev_offset
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|datestamp
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|author
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
decl_stmt|;
name|struct
name|directory_baton
modifier|*
name|db
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Record the mapping of FROM_REV to TO_REV in REV_MAP, ensuring that    anything added to the hash is allocated in the hash's pool. */
end_comment

begin_function
specifier|static
name|void
name|set_revision_mapping
parameter_list|(
name|apr_hash_t
modifier|*
name|rev_map
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|,
name|svn_revnum_t
name|to_rev
parameter_list|)
block|{
name|svn_revnum_t
modifier|*
name|mapped_revs
init|=
name|apr_palloc
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|rev_map
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|mapped_revs
index|[
literal|0
index|]
operator|=
name|from_rev
expr_stmt|;
name|mapped_revs
index|[
literal|1
index|]
operator|=
name|to_rev
expr_stmt|;
name|apr_hash_set
argument_list|(
name|rev_map
argument_list|,
name|mapped_revs
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|,
name|mapped_revs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the revision to which FROM_REV maps in REV_MAP, or    SVN_INVALID_REVNUM if no such mapping exists. */
end_comment

begin_function
specifier|static
name|svn_revnum_t
name|get_revision_mapping
parameter_list|(
name|apr_hash_t
modifier|*
name|rev_map
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|)
block|{
name|svn_revnum_t
modifier|*
name|to_rev
init|=
name|apr_hash_get
argument_list|(
name|rev_map
argument_list|,
operator|&
name|from_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|from_rev
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|to_rev
condition|?
operator|*
name|to_rev
else|:
name|SVN_INVALID_REVNUM
return|;
block|}
end_function

begin_comment
comment|/* Prepend the mergeinfo source paths in MERGEINFO_ORIG with    PARENT_DIR, and return it in *MERGEINFO_VAL. */
end_comment

begin_comment
comment|/* ### FIXME:  Consider somehow sharing code with    ### libsvn_repos/load-fs-vtable.c:prefix_mergeinfo_paths() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prefix_mergeinfo_paths
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|mergeinfo_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|mergeinfo_orig
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|prefixed_mergeinfo
decl_stmt|,
modifier|*
name|mergeinfo
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|void
modifier|*
name|rangelist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo_orig
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prefixed_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|merge_source
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|rangelist
argument_list|)
expr_stmt|;
name|merge_source
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|key
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* The svn:mergeinfo property syntax demands a repos abspath */
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|svn_relpath_join
argument_list|(
name|parent_dir
argument_list|,
name|merge_source
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|prefixed_mergeinfo
argument_list|,
name|path
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_mergeinfo_to_string
argument_list|(
name|mergeinfo_val
argument_list|,
name|prefixed_mergeinfo
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Examine the mergeinfo in INITIAL_VAL, renumber revisions in rangelists    as appropriate, and return the (possibly new) mergeinfo in *FINAL_VAL    (allocated from POOL). */
end_comment

begin_comment
comment|/* ### FIXME:  Consider somehow sharing code with    ### libsvn_repos/load-fs-vtable.c:renumber_mergeinfo_revs() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|renumber_mergeinfo_revs
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|final_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|initial_val
parameter_list|,
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|,
name|predates_stream_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|final_mergeinfo
init|=
name|apr_hash_make
argument_list|(
name|subpool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|initial_val
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue #3020      http://subversion.tigris.org/issues/show_bug.cgi?id=3020#desc16      Remove mergeinfo older than the oldest revision in the dump stream      and adjust its revisions by the difference between the head rev of      the target repository and the current dump stream rev. */
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|oldest_dumpstream_rev
operator|>
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|predates_stream_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|rb
operator|->
name|pb
operator|->
name|oldest_dumpstream_rev
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|rb
operator|->
name|pb
operator|->
name|oldest_dumpstream_rev
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__adjust_mergeinfo_rangelists
argument_list|(
operator|&
name|predates_stream_mergeinfo
argument_list|,
name|predates_stream_mergeinfo
argument_list|,
operator|-
name|rb
operator|->
name|rev_offset
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|predates_stream_mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|void
modifier|*
name|path
decl_stmt|;
name|apr_ssize_t
name|pathlen
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|pathlen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|rangelist
operator|=
name|val
expr_stmt|;
comment|/* Possibly renumber revisions in merge source's rangelist. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_revnum_t
name|rev_from_map
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|rev_from_map
operator|=
name|get_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|range
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev_from_map
argument_list|)
condition|)
block|{
name|range
operator|->
name|start
operator|=
name|rev_from_map
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range
operator|->
name|start
operator|==
name|pb
operator|->
name|oldest_dumpstream_rev
operator|-
literal|1
condition|)
block|{
comment|/* Since the start revision of svn_merge_range_t are not                  inclusive there is one possible valid start revision that                  won't be found in the PB->REV_MAP mapping of load stream                  revsions to loaded revisions: The revision immediately                  preceeding the oldest revision from the load stream.                  This is a valid revision for mergeinfo, but not a valid                  copy from revision (which PB->REV_MAP also maps for) so it                  will never be in the mapping.                   If that is what we have here, then find the mapping for the                  oldest rev from the load stream and subtract 1 to get the                  renumbered, non-inclusive, start revision. */
name|rev_from_map
operator|=
name|get_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|pb
operator|->
name|oldest_dumpstream_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev_from_map
argument_list|)
condition|)
name|range
operator|->
name|start
operator|=
name|rev_from_map
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If we can't remap the start revision then don't even bother                  trying to remap the end revision.  It's possible we might                  actually succeed at the latter, which can result in invalid                  mergeinfo with a start rev> end rev.  If that gets into the                  repository then a world of bustage breaks loose anytime that                  bogus mergeinfo is parsed.  See                  http://subversion.tigris.org/issues/show_bug.cgi?id=3020#desc16.                  */
continue|continue;
block|}
name|rev_from_map
operator|=
name|get_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|range
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev_from_map
argument_list|)
condition|)
name|range
operator|->
name|end
operator|=
name|rev_from_map
expr_stmt|;
block|}
name|apr_hash_set
argument_list|(
name|final_mergeinfo
argument_list|,
name|path
argument_list|,
name|pathlen
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|predates_stream_mergeinfo
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|final_mergeinfo
argument_list|,
name|predates_stream_mergeinfo
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_sort
argument_list|(
name|final_mergeinfo
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mergeinfo revision sources for r0 and r1 are invalid; you can't merge r0      or r1.  However, svndumpfilter can be abused to produce r1 merge source      revs.  So if we encounter any, then strip them out, no need to put them      into the load target. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|final_mergeinfo
argument_list|,
name|final_mergeinfo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
name|final_val
argument_list|,
name|final_mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_callback
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
comment|/* ### Don't print directly; generate a notification. */
if|if
condition|(
operator|!
name|pb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"* Loaded revision %ld.\n"
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the mapping of the dumpstream revision to the committed revision. */
name|set_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|rb
operator|->
name|rev
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|)
expr_stmt|;
comment|/* If the incoming dump stream has non-contiguous revisions (e.g. from      using svndumpfilter --drop-empty-revs without --renumber-revs) then      we must account for the missing gaps in PB->REV_MAP.  Otherwise we      might not be able to map all mergeinfo source revisions to the correct      revisions in the target repos. */
if|if
condition|(
operator|(
name|pb
operator|->
name|last_rev_mapped
operator|!=
name|SVN_INVALID_REVNUM
operator|)
operator|&&
operator|(
name|rb
operator|->
name|rev
operator|!=
name|pb
operator|->
name|last_rev_mapped
operator|+
literal|1
operator|)
condition|)
block|{
name|svn_revnum_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|pb
operator|->
name|last_rev_mapped
operator|+
literal|1
init|;
name|i
operator|<
name|rb
operator|->
name|rev
condition|;
name|i
operator|++
control|)
block|{
name|set_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|i
argument_list|,
name|pb
operator|->
name|last_rev_mapped
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update our "last revision mapped". */
name|pb
operator|->
name|last_rev_mapped
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements `svn_ra__lock_retry_func_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock_retry_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|reposlocktoken
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Failed to get lock on destination "
literal|"repos, currently held by '%s'\n"
argument_list|)
argument_list|,
name|reposlocktoken
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fstream
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_file
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|fstream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|tmp_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
literal|0
comment|/* Dirent fields */
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_props
operator|=
name|svn_prop_hash_to_array
argument_list|(
operator|*
name|props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|tmp_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_delta_shim_callbacks_t
modifier|*
name|get_shim_callbacks
parameter_list|(
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_baton
operator|=
name|rb
expr_stmt|;
return|return
name|callbacks
return|;
block|}
end_function

begin_comment
comment|/* Acquire a lock (of sorts) on the repository associated with the  * given RA SESSION. This lock is just a revprop change attempt in a  * time-delay loop. This function is duplicated by svnsync in  * svnsync/svnsync.c  *  * ### TODO: Make this function more generic and  * expose it through a header for use by other Subversion  * applications to avoid duplication.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|lock_string_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|be_atomic
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|be_atomic
condition|)
block|{
comment|/* Pre-1.7 servers can't lock without a race condition.  (Issue #3546) */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Target server does not support atomic revision "
literal|"property edits; consider upgrading it to 1.7."
argument_list|)
argument_list|)
decl_stmt|;
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svnrdump: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_ra__get_operational_lock
argument_list|(
name|lock_string_p
argument_list|,
name|NULL
argument_list|,
name|session
argument_list|,
name|SVNRDUMP_PROP_LOCK
argument_list|,
name|FALSE
argument_list|,
literal|10
comment|/* retries */
argument_list|,
name|lock_retry_func
argument_list|,
name|NULL
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_revision_record
parameter_list|(
name|void
modifier|*
modifier|*
name|revision_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_revnum_t
name|head_rev
decl_stmt|;
name|rb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rb
argument_list|)
argument_list|)
expr_stmt|;
name|pb
operator|=
name|parse_baton
expr_stmt|;
name|rb
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|rb
operator|->
name|pb
operator|=
name|pb
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|headers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|hname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|hval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
argument_list|)
operator|==
literal|0
condition|)
name|rb
operator|->
name|rev
operator|=
name|atoi
argument_list|(
name|hval
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|pb
operator|->
name|session
argument_list|,
operator|&
name|head_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: This is a lame fallback loading multiple segments of dump in      several separate operations. It is highly susceptible to race conditions.      Calculate the revision 'offset' for finding copyfrom sources.      It might be positive or negative. */
name|rb
operator|->
name|rev_offset
operator|=
call|(
name|apr_int32_t
call|)
argument_list|(
operator|(
name|rb
operator|->
name|rev
operator|)
operator|-
operator|(
name|head_rev
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Stash the oldest (non-zero) dumpstream revision seen. */
if|if
condition|(
operator|(
name|rb
operator|->
name|rev
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|pb
operator|->
name|oldest_dumpstream_rev
argument_list|)
operator|)
condition|)
name|pb
operator|->
name|oldest_dumpstream_rev
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
comment|/* Set the commit_editor/ commit_edit_baton to NULL and wait for      them to be created in new_node_record */
name|rb
operator|->
name|pb
operator|->
name|commit_editor
operator|=
name|NULL
expr_stmt|;
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
operator|=
name|NULL
expr_stmt|;
name|rb
operator|->
name|revprop_table
operator|=
name|apr_hash_make
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|revision_baton
operator|=
name|rb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|magic_header_record
parameter_list|(
name|int
name|version
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|uuid_record
parameter_list|(
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton
modifier|*
name|pb
decl_stmt|;
name|pb
operator|=
name|parse_baton
expr_stmt|;
name|pb
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_node_record
parameter_list|(
name|void
modifier|*
modifier|*
name|node_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|revision_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|revision_baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|void
modifier|*
name|commit_edit_baton
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|nb
decl_stmt|;
name|struct
name|directory_baton
modifier|*
name|child_db
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|void
modifier|*
name|child_baton
decl_stmt|;
name|char
modifier|*
name|relpath_compose
decl_stmt|;
specifier|const
name|char
modifier|*
name|nb_dirname
decl_stmt|;
name|nb
operator|=
name|apr_pcalloc
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nb
argument_list|)
argument_list|)
expr_stmt|;
name|nb
operator|->
name|rb
operator|=
name|rb
expr_stmt|;
name|nb
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|nb
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* If the creation of commit_editor is pending, create it now and      open_root on it; also create a top-level directory baton. */
if|if
condition|(
operator|!
name|commit_editor
condition|)
block|{
comment|/* The revprop_table should have been filled in with important          information like svn:log in set_revision_property. We can now          use it all this information to create our commit_editor. But          first, clear revprops that we aren't allowed to set with the          commit_editor. We'll set them separately using the RA API          after closing the editor (see close_revision). */
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
name|get_shim_callbacks
argument_list|(
name|rb
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
operator|&
name|commit_editor
argument_list|,
operator|&
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|revision_baton
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|pb
operator|->
name|commit_editor
operator|=
name|commit_editor
expr_stmt|;
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
operator|=
name|commit_edit_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_root
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Opened root %p\n"
operator|,
name|child_baton
operator|)
argument_list|)
expr_stmt|;
comment|/* child_db corresponds to the root directory baton here */
name|child_db
operator|=
name|apr_pcalloc
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child_db
argument_list|)
argument_list|)
expr_stmt|;
name|child_db
operator|->
name|baton
operator|=
name|child_baton
expr_stmt|;
name|child_db
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|child_db
operator|->
name|relpath
operator|=
literal|""
expr_stmt|;
name|child_db
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|child_db
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|headers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|hname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|hval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
comment|/* Parse the different kinds of headers we can encounter and          stuff them into the node_baton for writing later */
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|kind
operator|=
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|?
name|svn_node_file
else|:
name|svn_node_dir
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_add
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"change"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_change
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_delete
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"replace"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_replace
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|base_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|copyfrom_rev
operator|=
name|atoi
argument_list|(
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|hval
argument_list|)
expr_stmt|;
block|}
name|nb_dirname
operator|=
name|svn_relpath_dirname
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_compare_paths
argument_list|(
name|nb_dirname
argument_list|,
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ancestor_path
decl_stmt|;
name|apr_size_t
name|residual_close_count
decl_stmt|;
name|apr_array_header_t
modifier|*
name|residual_open_path
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_size_t
name|n
decl_stmt|;
comment|/* Before attempting to handle the action, call open_directory          for all the path components and set the directory baton          accordingly */
name|ancestor_path
operator|=
name|svn_relpath_get_longest_ancestor
argument_list|(
name|nb_dirname
argument_list|,
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|residual_close_count
operator|=
name|svn_path_component_count
argument_list|(
name|svn_relpath_skip_ancestor
argument_list|(
name|ancestor_path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|)
argument_list|)
expr_stmt|;
name|residual_open_path
operator|=
name|svn_path_decompose
argument_list|(
name|svn_relpath_skip_ancestor
argument_list|(
name|ancestor_path
argument_list|,
name|nb_dirname
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* First close all as many directories as there are after          skip_ancestor, and then open fresh directories */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|residual_close_count
condition|;
name|n
operator|++
control|)
block|{
comment|/* Don't worry about destroying the actual rb->db object,              since the pool we're using has the lifetime of one              revision anyway */
name|LDR_DBG
argument_list|(
operator|(
literal|"Closing dir %p\n"
operator|,
name|rb
operator|->
name|db
operator|->
name|baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|rb
operator|->
name|db
operator|->
name|parent
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|residual_open_path
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|relpath_compose
operator|=
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|residual_open_path
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_directory
argument_list|(
name|relpath_compose
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Opened dir %p\n"
operator|,
name|child_baton
operator|)
argument_list|)
expr_stmt|;
name|child_db
operator|=
name|apr_pcalloc
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child_db
argument_list|)
argument_list|)
expr_stmt|;
name|child_db
operator|->
name|baton
operator|=
name|child_baton
expr_stmt|;
name|child_db
operator|->
name|depth
operator|=
name|rb
operator|->
name|db
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
name|child_db
operator|->
name|relpath
operator|=
name|relpath_compose
expr_stmt|;
name|child_db
operator|->
name|parent
operator|=
name|rb
operator|->
name|db
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|child_db
expr_stmt|;
block|}
block|}
comment|/* Fix up the copyfrom information in light of mapped revisions and      non-root load targets, and convert copyfrom path into a full      URL. */
if|if
condition|(
name|nb
operator|->
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|nb
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* Try to find the copyfrom revision in the revision map;          failing that, fall back to the revision offset approach. */
name|copyfrom_rev
operator|=
name|get_revision_mapping
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|rev_map
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
name|copyfrom_rev
operator|=
name|nb
operator|->
name|copyfrom_rev
operator|-
name|rb
operator|->
name|rev_offset
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Relative source revision %ld is not"
literal|" available in current repository"
argument_list|)
argument_list|,
name|copyfrom_rev
argument_list|)
return|;
name|nb
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
condition|)
name|nb
operator|->
name|copyfrom_path
operator|=
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|nb
operator|->
name|copyfrom_path
operator|=
name|svn_path_url_add_component2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|root_url
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|nb
operator|->
name|action
condition|)
block|{
case|case
name|svn_node_action_delete
case|:
case|case
name|svn_node_action_replace
case|:
name|LDR_DBG
argument_list|(
operator|(
literal|"Deleting entry %s in %p\n"
operator|,
name|nb
operator|->
name|path
operator|,
name|rb
operator|->
name|db
operator|->
name|baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|delete_entry
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|->
name|action
operator|==
name|svn_node_action_delete
condition|)
break|break;
else|else
comment|/* FALL THROUGH */
empty_stmt|;
case|case
name|svn_node_action_add
case|:
switch|switch
condition|(
name|nb
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|add_file
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Added file %s to dir %p as %p\n"
operator|,
name|nb
operator|->
name|path
operator|,
name|rb
operator|->
name|db
operator|->
name|baton
operator|,
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_dir
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|add_directory
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Added dir %s to dir %p as %p\n"
operator|,
name|nb
operator|->
name|path
operator|,
name|rb
operator|->
name|db
operator|->
name|baton
operator|,
name|child_baton
operator|)
argument_list|)
expr_stmt|;
name|child_db
operator|=
name|apr_pcalloc
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child_db
argument_list|)
argument_list|)
expr_stmt|;
name|child_db
operator|->
name|baton
operator|=
name|child_baton
expr_stmt|;
name|child_db
operator|->
name|depth
operator|=
name|rb
operator|->
name|db
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
name|child_db
operator|->
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|nb
operator|->
name|path
argument_list|)
expr_stmt|;
name|child_db
operator|->
name|parent
operator|=
name|rb
operator|->
name|db
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|child_db
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|svn_node_action_change
case|:
switch|switch
condition|(
name|nb
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_file
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_directory
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|child_db
operator|=
name|apr_pcalloc
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child_db
argument_list|)
argument_list|)
expr_stmt|;
name|child_db
operator|->
name|baton
operator|=
name|child_baton
expr_stmt|;
name|child_db
operator|->
name|depth
operator|=
name|rb
operator|->
name|db
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
name|child_db
operator|->
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|nb
operator|->
name|path
argument_list|)
expr_stmt|;
name|child_db
operator|->
name|parent
operator|=
name|rb
operator|->
name|db
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|child_db
expr_stmt|;
break|break;
block|}
break|break;
block|}
operator|*
name|node_baton
operator|=
name|nb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_revision_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rdump__normalize_prop
argument_list|(
name|name
argument_list|,
operator|&
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|rev
operator|>
literal|0
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|revprop_table
argument_list|,
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rb
operator|->
name|rev_offset
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Special case: set revision 0 properties directly (which is          safe because the commit_editor hasn't been created yet), but          only when loading into an 'empty' filesystem. */
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remember any datestamp/ author that passes through (see comment      in close_revision). */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
condition|)
name|rb
operator|->
name|datestamp
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
condition|)
name|rb
operator|->
name|author
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_node_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
if|if
condition|(
name|value
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|renumbered_mergeinfo
decl_stmt|;
name|svn_string_t
name|prop_val
decl_stmt|;
comment|/* Tolerate mergeinfo with "\r\n" line endings because some          dumpstream sources might contain as much.  If so normalize          the line endings to '\n' and make a notification to          PARSE_BATON->FEEDBACK_STREAM that we have made this          correction. */
if|if
condition|(
name|strstr
argument_list|(
name|value
operator|->
name|data
argument_list|,
literal|"\r"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|prop_eol_normalized
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|value
operator|->
name|data
argument_list|,
operator|&
name|prop_eol_normalized
argument_list|,
literal|"\n"
argument_list|,
comment|/* translate to LF */
name|FALSE
argument_list|,
comment|/* no repair */
name|NULL
argument_list|,
comment|/* no keywords */
name|FALSE
argument_list|,
comment|/* no expansion */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prop_val
operator|.
name|data
operator|=
name|prop_eol_normalized
expr_stmt|;
name|prop_val
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|prop_eol_normalized
argument_list|)
expr_stmt|;
name|value
operator|=
operator|&
name|prop_val
expr_stmt|;
comment|/* ### TODO: notify? */
block|}
comment|/* Renumber mergeinfo as appropriate. */
name|SVN_ERR
argument_list|(
name|renumber_mergeinfo_revs
argument_list|(
operator|&
name|renumbered_mergeinfo
argument_list|,
name|value
argument_list|,
name|nb
operator|->
name|rb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|renumbered_mergeinfo
expr_stmt|;
if|if
condition|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|parent_dir
condition|)
block|{
comment|/* Prefix the merge source paths with PB->parent_dir. */
comment|/* ASSUMPTION: All source paths are included in the dump stream. */
name|svn_string_t
modifier|*
name|mergeinfo_val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|prefix_mergeinfo_paths
argument_list|(
operator|&
name|mergeinfo_val
argument_list|,
name|value
argument_list|,
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|parent_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|mergeinfo_val
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_rdump__normalize_prop
argument_list|(
name|name
argument_list|,
operator|&
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nb
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
name|LDR_DBG
argument_list|(
operator|(
literal|"Applying properties on %p\n"
operator|,
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|change_file_prop
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_dir
case|:
name|LDR_DBG
argument_list|(
operator|(
literal|"Applying properties on %p\n"
operator|,
name|nb
operator|->
name|rb
operator|->
name|db
operator|->
name|baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|change_dir_prop
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_node_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|change_file_prop
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|change_dir_prop
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_node_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
if|if
condition|(
operator|(
name|nb
operator|->
name|action
operator|==
name|svn_node_action_add
operator|||
name|nb
operator|->
name|action
operator|==
name|svn_node_action_replace
operator|)
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|nb
operator|->
name|copyfrom_rev
argument_list|)
condition|)
comment|/* Add-without-history; no "old" properties to worry about. */
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* nb->kind == svn_node_dir */
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_prop_kind_t
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_prop_regular_kind
condition|)
name|SVN_ERR
argument_list|(
name|set_node_property
argument_list|(
name|nb
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_fulltext
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|svn_txdelta_window_handler_t
name|handler
decl_stmt|;
name|void
modifier|*
name|handler_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Setting fulltext for %p\n"
operator|,
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|apply_textdelta
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|nb
operator|->
name|base_checksum
argument_list|,
name|pool
argument_list|,
operator|&
name|handler
argument_list|,
operator|&
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_txdelta_target_push
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Applying textdelta to %p\n"
operator|,
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|apply_textdelta
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|nb
operator|->
name|base_checksum
argument_list|,
name|pool
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_node
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
comment|/* Pass a file node closure through to the editor *unless* we      deleted the file (which doesn't require us to open it). */
if|if
condition|(
operator|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
operator|(
name|nb
operator|->
name|file_baton
operator|)
condition|)
block|{
name|LDR_DBG
argument_list|(
operator|(
literal|"Closing file %p\n"
operator|,
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_file
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|nb
operator|->
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The svn_node_dir case is handled in close_revision */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_revision
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|void
modifier|*
name|commit_edit_baton
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
decl_stmt|;
name|svn_revnum_t
name|committed_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* Fake revision 0 */
if|if
condition|(
name|rb
operator|->
name|rev
operator|==
literal|0
condition|)
block|{
comment|/* ### Don't print directly; generate a notification. */
if|if
condition|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
literal|"* Loaded revision 0.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commit_editor
condition|)
block|{
comment|/* Close all pending open directories, and then close the edit          session itself */
while|while
condition|(
name|rb
operator|->
name|db
operator|&&
name|rb
operator|->
name|db
operator|->
name|parent
condition|)
block|{
name|LDR_DBG
argument_list|(
operator|(
literal|"Closing dir %p\n"
operator|,
name|rb
operator|->
name|db
operator|->
name|baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|rb
operator|->
name|db
operator|->
name|parent
expr_stmt|;
block|}
comment|/* root dir's baton */
name|LDR_DBG
argument_list|(
operator|(
literal|"Closing edit on %p\n"
operator|,
name|commit_edit_baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_edit
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|child_baton
decl_stmt|;
comment|/* Legitimate revision with no node information */
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
operator|&
name|commit_editor
argument_list|,
operator|&
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|baton
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_root
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Opened root %p\n"
operator|,
name|child_baton
operator|)
argument_list|)
expr_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"Closing edit on %p\n"
operator|,
name|commit_edit_baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|child_baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_edit
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* svn_fs_commit_txn() rewrites the datestamp and author properties;      we'll rewrite them again by hand after closing the commit_editor.      The only time we don't do this is for revision 0 when loaded into      a non-empty repository.  */
if|if
condition|(
name|rb
operator|->
name|rev
operator|>
literal|0
condition|)
block|{
name|committed_rev
operator|=
name|get_revision_mapping
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|rev_map
argument_list|,
name|rb
operator|->
name|rev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rb
operator|->
name|rev_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|committed_rev
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|committed_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|SVN_PROP_REVISION_DATE
argument_list|,
name|rb
operator|->
name|datestamp
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
name|committed_rev
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|datestamp
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|rb
operator|->
name|author
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
name|committed_rev
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|author
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rdump__load_dumpstream
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|aux_session
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_parse_fns3_t
modifier|*
name|parser
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|parse_baton
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|lock_string
decl_stmt|;
name|svn_boolean_t
name|be_atomic
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_url
decl_stmt|,
modifier|*
name|root_url
decl_stmt|,
modifier|*
name|parent_dir
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_lock
argument_list|(
operator|&
name|lock_string
argument_list|,
name|session
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|session
argument_list|,
operator|&
name|root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|session
argument_list|,
operator|&
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_root
argument_list|(
name|session
argument_list|,
operator|&
name|parent_dir
argument_list|,
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|magic_header_record
operator|=
name|magic_header_record
expr_stmt|;
name|parser
operator|->
name|uuid_record
operator|=
name|uuid_record
expr_stmt|;
name|parser
operator|->
name|new_revision_record
operator|=
name|new_revision_record
expr_stmt|;
name|parser
operator|->
name|new_node_record
operator|=
name|new_node_record
expr_stmt|;
name|parser
operator|->
name|set_revision_property
operator|=
name|set_revision_property
expr_stmt|;
name|parser
operator|->
name|set_node_property
operator|=
name|set_node_property
expr_stmt|;
name|parser
operator|->
name|delete_node_property
operator|=
name|delete_node_property
expr_stmt|;
name|parser
operator|->
name|remove_node_props
operator|=
name|remove_node_props
expr_stmt|;
name|parser
operator|->
name|set_fulltext
operator|=
name|set_fulltext
expr_stmt|;
name|parser
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|parser
operator|->
name|close_node
operator|=
name|close_node
expr_stmt|;
name|parser
operator|->
name|close_revision
operator|=
name|close_revision
expr_stmt|;
name|parse_baton
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parse_baton
argument_list|)
argument_list|)
expr_stmt|;
name|parse_baton
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|parse_baton
operator|->
name|aux_session
operator|=
name|aux_session
expr_stmt|;
name|parse_baton
operator|->
name|quiet
operator|=
name|quiet
expr_stmt|;
name|parse_baton
operator|->
name|root_url
operator|=
name|root_url
expr_stmt|;
name|parse_baton
operator|->
name|parent_dir
operator|=
name|parent_dir
expr_stmt|;
name|parse_baton
operator|->
name|rev_map
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|parse_baton
operator|->
name|last_rev_mapped
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|parse_baton
operator|->
name|oldest_dumpstream_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|err
operator|=
name|svn_repos_parse_dumpstream3
argument_list|(
name|stream
argument_list|,
name|parser
argument_list|,
name|parse_baton
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If all goes well, or if we're cancelled cleanly, don't leave a      stray lock behind. */
if|if
condition|(
operator|(
operator|!
name|err
operator|)
operator|||
operator|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CANCELLED
operator|)
operator|)
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_ra__release_operational_lock
argument_list|(
name|session
argument_list|,
name|SVNRDUMP_PROP_LOCK
argument_list|,
name|lock_string
argument_list|,
name|pool
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

