begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * cyrus_auth.c :  functions for Cyrus SASL-based authentication  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
end_ifdef

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra_svn.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/ra_svn_sasl.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mutex.h"
end_include

begin_include
include|#
directive|include
file|"ra_svn.h"
end_include

begin_comment
comment|/* Note: In addition to being used via svn_atomic__init_once to control  *       initialization of the SASL code this will also be referenced in  *       the various functions that work with sasl mutexes to determine  *       if the sasl pool has been destroyed.  This should be safe, since  *       it is only set back to zero in the sasl pool's cleanups, which  *       only happens during apr_terminate, which we assume is occurring  *       in atexit processing, at which point we are already running in  *       single threaded mode.  */
end_comment

begin_decl_stmt
specifier|volatile
name|svn_atomic_t
name|svn_ra_svn__sasl_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialized by svn_ra_svn__sasl_common_init(). */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|svn_atomic_t
name|sasl_ctx_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|apr_pool_t
modifier|*
name|sasl_pool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pool cleanup called when sasl_pool is destroyed. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|sasl_done_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* Reset svn_ra_svn__sasl_status, in case the client calls      apr_initialize()/apr_terminate() more than once. */
name|svn_ra_svn__sasl_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|svn_atomic_dec
argument_list|(
operator|&
name|sasl_ctx_count
argument_list|)
operator|==
literal|0
condition|)
name|sasl_done
argument_list|()
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_comment
comment|/* Cyrus SASL is thread-safe only if we supply it with mutex functions  * (with sasl_set_mutex()).  To make this work with APR, we need to use the  * global sasl_pool for the mutex allocations.  Freeing a mutex actually  * returns it to a global array.  We allocate mutexes from this  * array if it is non-empty, or directly from the pool otherwise.  * We also need a mutex to serialize accesses to the array itself.  */
end_comment

begin_comment
comment|/* An array of allocated, but unused, apr_thread_mutex_t's. */
end_comment

begin_decl_stmt
specifier|static
name|apr_array_header_t
modifier|*
name|free_mutexes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A mutex to serialize access to the array. */
end_comment

begin_decl_stmt
specifier|static
name|svn_mutex__t
modifier|*
name|array_mutex
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callbacks we pass to sasl_set_mutex(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sasl_mutex_alloc_cb_internal
parameter_list|(
name|svn_mutex__t
modifier|*
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|apr_is_empty_array
argument_list|(
name|free_mutexes
argument_list|)
condition|)
return|return
name|svn_mutex__init
argument_list|(
name|mutex
argument_list|,
name|TRUE
argument_list|,
name|sasl_pool
argument_list|)
return|;
else|else
operator|*
name|mutex
operator|=
operator|*
operator|(
operator|(
name|svn_mutex__t
operator|*
operator|*
operator|)
name|apr_array_pop
argument_list|(
name|free_mutexes
argument_list|)
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|sasl_mutex_alloc_cb
parameter_list|(
name|void
parameter_list|)
block|{
name|svn_mutex__t
modifier|*
name|mutex
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|svn_ra_svn__sasl_status
condition|)
return|return
name|NULL
return|;
name|err
operator|=
name|svn_mutex__lock
argument_list|(
name|array_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_mutex__unlock
argument_list|(
name|array_mutex
argument_list|,
name|sasl_mutex_alloc_cb_internal
argument_list|(
operator|&
name|mutex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mutex
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_result
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sasl_mutex_lock_cb
parameter_list|(
name|void
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_ra_svn__sasl_status
condition|)
return|return
literal|0
return|;
return|return
name|check_result
argument_list|(
name|svn_mutex__lock
argument_list|(
name|mutex
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sasl_mutex_unlock_cb
parameter_list|(
name|void
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_ra_svn__sasl_status
condition|)
return|return
literal|0
return|;
return|return
name|check_result
argument_list|(
name|svn_mutex__unlock
argument_list|(
name|mutex
argument_list|,
name|SVN_NO_ERROR
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sasl_mutex_free_cb_internal
parameter_list|(
name|void
modifier|*
name|mutex
parameter_list|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|free_mutexes
argument_list|,
name|svn_mutex__t
operator|*
argument_list|)
operator|=
name|mutex
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sasl_mutex_free_cb
parameter_list|(
name|void
modifier|*
name|mutex
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|svn_ra_svn__sasl_status
condition|)
return|return;
name|err
operator|=
name|svn_mutex__lock
argument_list|(
name|array_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_mutex__unlock
argument_list|(
name|array_mutex
argument_list|,
name|sasl_mutex_free_cb_internal
argument_list|(
name|mutex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_THREADS */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn__sasl_common_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|sasl_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|sasl_ctx_count
operator|=
literal|1
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|sasl_pool
argument_list|,
name|NULL
argument_list|,
name|sasl_done_cb
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|sasl_set_mutex
argument_list|(
name|sasl_mutex_alloc_cb
argument_list|,
name|sasl_mutex_lock_cb
argument_list|,
name|sasl_mutex_unlock_cb
argument_list|,
name|sasl_mutex_free_cb
argument_list|)
expr_stmt|;
name|free_mutexes
operator|=
name|apr_array_make
argument_list|(
name|sasl_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_mutex__t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mutex__init
argument_list|(
operator|&
name|array_mutex
argument_list|,
name|TRUE
argument_list|,
name|sasl_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* We are going to look at errno when we get SASL_FAIL but we don't    know for sure whether SASL always sets errno.  Clearing errno    before calling SASL functions helps in cases where SASL does    nothing to set errno. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|apr_set_os_error
end_ifdef

begin_define
define|#
directive|define
name|clear_sasl_errno
parameter_list|()
value|apr_set_os_error(APR_SUCCESS)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|clear_sasl_errno
parameter_list|()
value|(void)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sometimes SASL returns SASL_FAIL as RESULT and sets errno.  * SASL_FAIL translates to "generic error" which is quite unhelpful.  * Try to append a more informative error message based on errno so  * should be called before doing anything that may change errno. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sasl_errno_msg
parameter_list|(
name|int
name|result
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|apr_get_os_error
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|SASL_FAIL
operator|&&
name|apr_get_os_error
argument_list|()
operator|!=
literal|0
condition|)
return|return
name|apr_psprintf
argument_list|(
name|result_pool
argument_list|,
literal|": %s"
argument_list|,
name|svn_strerror
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Wrap an error message from SASL with a prefix that allows users  * to tell that the error message came from SASL.  Queries errno and  * so should be called before doing anything that may change errno. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sasl_error
parameter_list|(
name|sasl_conn_t
modifier|*
name|sasl_ctx
parameter_list|,
name|int
name|result
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sasl_errno_msg
init|=
name|get_sasl_errno_msg
argument_list|(
name|result
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
return|return
name|apr_psprintf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"SASL authentication error: %s%s"
argument_list|)
argument_list|,
name|sasl_errdetail
argument_list|(
name|sasl_ctx
argument_list|)
argument_list|,
name|sasl_errno_msg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sasl_init_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__sasl_common_init
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_client_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
specifier|const
name|char
modifier|*
name|sasl_errno_msg
init|=
name|get_sasl_errno_msg
argument_list|(
name|result
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not initialized the SASL library: %s%s"
argument_list|)
argument_list|,
name|sasl_errstring
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|sasl_errno_msg
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn__sasl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_atomic__init_once
argument_list|(
operator|&
name|svn_ra_svn__sasl_status
argument_list|,
name|sasl_init_cb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|sasl_dispose_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|sasl_conn_t
modifier|*
name|sasl_ctx
init|=
name|data
decl_stmt|;
name|sasl_dispose
argument_list|(
operator|&
name|sasl_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_atomic_dec
argument_list|(
operator|&
name|sasl_ctx_count
argument_list|)
operator|==
literal|0
condition|)
name|sasl_done
argument_list|()
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|svn_ra_svn__default_secprops
parameter_list|(
name|sasl_security_properties_t
modifier|*
name|secprops
parameter_list|)
block|{
comment|/* The minimum and maximum security strength factors that the chosen      SASL mechanism should provide.  0 means 'no encryption', 256 means      '256-bit encryption', which is about the best that any SASL      mechanism can provide.  Using these values effectively means 'use      whatever encryption the other side wants'.  Note that SASL will try      to use better encryption whenever possible, so if both the server and      the client use these values the highest possible encryption strength      will be used. */
name|secprops
operator|->
name|min_ssf
operator|=
literal|0
expr_stmt|;
name|secprops
operator|->
name|max_ssf
operator|=
literal|256
expr_stmt|;
comment|/* Set maxbufsize to the maximum amount of data we can read at any one time.      This value needs to be commmunicated to the peer if a security layer      is negotiated. */
name|secprops
operator|->
name|maxbufsize
operator|=
name|SVN_RA_SVN__READBUF_SIZE
expr_stmt|;
name|secprops
operator|->
name|security_flags
operator|=
literal|0
expr_stmt|;
name|secprops
operator|->
name|property_names
operator|=
name|secprops
operator|->
name|property_values
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A baton type used by the SASL username and password callbacks. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cred_baton
block|{
name|svn_auth_baton_t
modifier|*
name|auth_baton
decl_stmt|;
name|svn_auth_iterstate_t
modifier|*
name|iterstate
decl_stmt|;
specifier|const
name|char
modifier|*
name|realmstring
decl_stmt|;
comment|/* Unfortunately SASL uses two separate callbacks for the username and      password, but we must fetch both of them at the same time. So we cache      their values in the baton, set them to NULL individually when SASL      demands them, and fetch the next pair when both are NULL. */
specifier|const
name|char
modifier|*
name|username
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
comment|/* Any errors we receive from svn_auth_{first,next}_credentials      are saved here. */
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* This flag is set when we run out of credential providers. */
name|svn_boolean_t
name|no_more_creds
decl_stmt|;
comment|/* Were the auth callbacks ever called? */
name|svn_boolean_t
name|was_used
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|cred_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Call svn_auth_{first,next}_credentials. If successful, set BATON->username    and BATON->password to the new username and password and return TRUE,    otherwise return FALSE. If there are no more credentials, set    BATON->no_more_creds to TRUE. Any errors are saved in BATON->err. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|get_credentials
parameter_list|(
name|cred_baton_t
modifier|*
name|baton
parameter_list|)
block|{
name|void
modifier|*
name|creds
decl_stmt|;
if|if
condition|(
name|baton
operator|->
name|iterstate
condition|)
name|baton
operator|->
name|err
operator|=
name|svn_auth_next_credentials
argument_list|(
operator|&
name|creds
argument_list|,
name|baton
operator|->
name|iterstate
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|baton
operator|->
name|err
operator|=
name|svn_auth_first_credentials
argument_list|(
operator|&
name|creds
argument_list|,
operator|&
name|baton
operator|->
name|iterstate
argument_list|,
name|SVN_AUTH_CRED_SIMPLE
argument_list|,
name|baton
operator|->
name|realmstring
argument_list|,
name|baton
operator|->
name|auth_baton
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|baton
operator|->
name|err
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|creds
condition|)
block|{
name|baton
operator|->
name|no_more_creds
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|baton
operator|->
name|username
operator|=
operator|(
operator|(
name|svn_auth_cred_simple_t
operator|*
operator|)
name|creds
operator|)
operator|->
name|username
expr_stmt|;
name|baton
operator|->
name|password
operator|=
operator|(
operator|(
name|svn_auth_cred_simple_t
operator|*
operator|)
name|creds
operator|)
operator|->
name|password
expr_stmt|;
name|baton
operator|->
name|was_used
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The username callback. Implements the sasl_getsimple_t interface. */
end_comment

begin_function
specifier|static
name|int
name|get_username_cb
parameter_list|(
name|void
modifier|*
name|b
parameter_list|,
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|username
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|cred_baton_t
modifier|*
name|baton
init|=
name|b
decl_stmt|;
if|if
condition|(
name|baton
operator|->
name|username
operator|||
name|get_credentials
argument_list|(
name|baton
argument_list|)
condition|)
block|{
operator|*
name|username
operator|=
name|baton
operator|->
name|username
expr_stmt|;
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
name|strlen
argument_list|(
name|baton
operator|->
name|username
argument_list|)
expr_stmt|;
name|baton
operator|->
name|username
operator|=
name|NULL
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
return|return
name|SASL_FAIL
return|;
block|}
end_function

begin_comment
comment|/* The password callback. Implements the sasl_getsecret_t interface. */
end_comment

begin_function
specifier|static
name|int
name|get_password_cb
parameter_list|(
name|sasl_conn_t
modifier|*
name|conn
parameter_list|,
name|void
modifier|*
name|b
parameter_list|,
name|int
name|id
parameter_list|,
name|sasl_secret_t
modifier|*
modifier|*
name|psecret
parameter_list|)
block|{
name|cred_baton_t
modifier|*
name|baton
init|=
name|b
decl_stmt|;
if|if
condition|(
name|baton
operator|->
name|password
operator|||
name|get_credentials
argument_list|(
name|baton
argument_list|)
condition|)
block|{
name|sasl_secret_t
modifier|*
name|secret
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|baton
operator|->
name|password
argument_list|)
decl_stmt|;
comment|/* sasl_secret_t is a struct with a variable-sized array as a final          member, which means we need to allocate len-1 supplementary bytes          (one byte is part of sasl_secret_t, and we don't need a NULL          terminator). */
name|secret
operator|=
name|apr_palloc
argument_list|(
name|baton
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|secret
argument_list|)
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|secret
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|secret
operator|->
name|data
argument_list|,
name|baton
operator|->
name|password
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|baton
operator|->
name|password
operator|=
name|NULL
expr_stmt|;
operator|*
name|psecret
operator|=
name|secret
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
return|return
name|SASL_FAIL
return|;
block|}
end_function

begin_comment
comment|/* Create a new SASL context. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_sasl_ctx
parameter_list|(
name|sasl_conn_t
modifier|*
modifier|*
name|sasl_ctx
parameter_list|,
name|svn_boolean_t
name|is_tunneled
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|local_addrport
parameter_list|,
specifier|const
name|char
modifier|*
name|remote_addrport
parameter_list|,
name|sasl_callback_t
modifier|*
name|callbacks
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|sasl_security_properties_t
name|secprops
decl_stmt|;
name|int
name|result
decl_stmt|;
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_client_new
argument_list|(
name|SVN_RA_SVN_SASL_NAME
argument_list|,
name|hostname
argument_list|,
name|local_addrport
argument_list|,
name|remote_addrport
argument_list|,
name|callbacks
argument_list|,
name|SASL_SUCCESS_DATA
argument_list|,
name|sasl_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
specifier|const
name|char
modifier|*
name|sasl_errno_msg
init|=
name|get_sasl_errno_msg
argument_list|(
name|result
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not create SASL context: %s%s"
argument_list|)
argument_list|,
name|sasl_errstring
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|sasl_errno_msg
argument_list|)
return|;
block|}
name|svn_atomic_inc
argument_list|(
operator|&
name|sasl_ctx_count
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|sasl_ctx
argument_list|,
name|sasl_dispose_cb
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tunneled
condition|)
block|{
comment|/* We need to tell SASL that this connection is tunneled,          otherwise it will ignore EXTERNAL. The third parameter          should be the username, but since SASL doesn't seem          to use it on the client side, any non-empty string will do. */
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|sasl_ctx
argument_list|,
name|SASL_AUTH_EXTERNAL
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
operator|*
name|sasl_ctx
argument_list|,
name|result
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Set security properties. */
name|svn_ra_svn__default_secprops
argument_list|(
operator|&
name|secprops
argument_list|)
expr_stmt|;
name|sasl_setprop
argument_list|(
operator|*
name|sasl_ctx
argument_list|,
name|SASL_SEC_PROPS
argument_list|,
operator|&
name|secprops
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform an authentication exchange */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|try_auth
parameter_list|(
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
parameter_list|,
name|sasl_conn_t
modifier|*
name|sasl_ctx
parameter_list|,
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|last_err
parameter_list|,
specifier|const
name|char
modifier|*
name|mechstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|sasl_interact_t
modifier|*
name|client_interact
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|mech
decl_stmt|,
modifier|*
name|status
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|arg
init|=
name|NULL
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|int
name|result
decl_stmt|;
name|unsigned
name|int
name|outlen
decl_stmt|;
name|svn_boolean_t
name|again
decl_stmt|;
do|do
block|{
name|again
operator|=
name|FALSE
expr_stmt|;
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_client_start
argument_list|(
name|sasl_ctx
argument_list|,
name|mechstring
argument_list|,
operator|&
name|client_interact
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|&
name|mech
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|SASL_OK
case|:
case|case
name|SASL_CONTINUE
case|:
comment|/* Success. */
break|break;
case|case
name|SASL_NOMECH
case|:
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_NO_MECHANISMS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|SASL_BADPARAM
case|:
case|case
name|SASL_NOMEM
case|:
comment|/* Fatal error.  Fail the authentication. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
name|sasl_ctx
argument_list|,
name|result
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
default|default:
comment|/* For anything else, delete the mech from the list                and try again. */
block|{
specifier|const
name|char
modifier|*
name|pmech
init|=
name|strstr
argument_list|(
name|mechstring
argument_list|,
name|mech
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|head
init|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|mechstring
argument_list|,
name|pmech
operator|-
name|mechstring
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
init|=
name|pmech
operator|+
name|strlen
argument_list|(
name|mech
argument_list|)
decl_stmt|;
name|mechstring
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|again
condition|)
do|;
comment|/* Prepare the initial authentication token. */
if|if
condition|(
name|outlen
operator|>
literal|0
operator|||
name|strcmp
argument_list|(
name|mech
argument_list|,
literal|"EXTERNAL"
argument_list|)
operator|==
literal|0
condition|)
name|arg
operator|=
name|svn_base64_encode_string2
argument_list|(
name|svn_string_ncreate
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Send the initial client response */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__auth_response
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|mech
argument_list|,
name|arg
condition|?
name|arg
operator|->
name|data
else|:
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|SASL_CONTINUE
condition|)
block|{
comment|/* Read the server response */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(?s)"
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Authentication failed.  Use the next set of credentials */
operator|*
name|success
operator|=
name|FALSE
expr_stmt|;
comment|/* Remember the message sent by the server because we'll want to              return a meaningful error if we run out of auth providers. */
operator|*
name|last_err
operator|=
name|in
condition|?
name|in
operator|->
name|data
else|:
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"success"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"step"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|in
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected server response"
literal|" to authentication"
argument_list|)
argument_list|)
return|;
comment|/* If the mech is CRAM-MD5 we don't base64-decode the server response. */
if|if
condition|(
name|strcmp
argument_list|(
name|mech
argument_list|,
literal|"CRAM-MD5"
argument_list|)
operator|!=
literal|0
condition|)
name|in
operator|=
name|svn_base64_decode_string
argument_list|(
name|in
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_client_step
argument_list|(
name|sasl_ctx
argument_list|,
name|in
operator|->
name|data
argument_list|,
operator|(
specifier|const
name|unsigned
name|int
operator|)
name|in
operator|->
name|len
argument_list|,
operator|&
name|client_interact
argument_list|,
operator|&
name|out
argument_list|,
comment|/* Filled in by SASL. */
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
operator|&&
name|result
operator|!=
name|SASL_CONTINUE
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
name|sasl_ctx
argument_list|,
name|result
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* If the server thinks we're done, then don't send any response. */
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|outlen
operator|>
literal|0
condition|)
block|{
name|arg
operator|=
name|svn_string_ncreate
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Write our response. */
comment|/* For CRAM-MD5, we don't use base64-encoding. */
if|if
condition|(
name|strcmp
argument_list|(
name|mech
argument_list|,
literal|"CRAM-MD5"
argument_list|)
operator|!=
literal|0
condition|)
name|arg
operator|=
name|svn_base64_encode_string2
argument_list|(
name|arg
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cstring
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|arg
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cstring
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|status
operator|||
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"step"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a client-send-last mech.  Read the last server response. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(?s)"
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|success
operator|=
name|FALSE
expr_stmt|;
operator|*
name|last_err
operator|=
name|in
condition|?
name|in
operator|->
name|data
else|:
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We're done */
operator|*
name|success
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected server response"
literal|" to authentication"
argument_list|)
argument_list|)
return|;
block|}
else|else
operator|*
name|success
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for a SASL encrypted svn_ra_svn__stream_t. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|sasl_baton
block|{
name|svn_ra_svn__stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Inherited stream. */
name|sasl_conn_t
modifier|*
name|ctx
decl_stmt|;
comment|/* The SASL context for this connection. */
name|unsigned
name|int
name|maxsize
decl_stmt|;
comment|/* The maximum amount of data we can encode. */
specifier|const
name|char
modifier|*
name|read_buf
decl_stmt|;
comment|/* The buffer returned by sasl_decode. */
name|unsigned
name|int
name|read_len
decl_stmt|;
comment|/* Its current length. */
specifier|const
name|char
modifier|*
name|write_buf
decl_stmt|;
comment|/* The buffer returned by sasl_encode. */
name|unsigned
name|int
name|write_len
decl_stmt|;
comment|/* Its length. */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
name|sasl_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Functions to implement a SASL encrypted svn_ra_svn__stream_t. */
end_comment

begin_comment
comment|/* Implements svn_read_fn_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sasl_read_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|sasl_baton_t
modifier|*
name|sasl_baton
init|=
name|baton
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* A copy of *len, used by the wrapped stream. */
name|apr_size_t
name|len2
init|=
operator|*
name|len
decl_stmt|;
comment|/* sasl_decode might need more data than a single read can provide,      hence the need to put a loop around the decoding. */
while|while
condition|(
operator|!
name|sasl_baton
operator|->
name|read_buf
operator|||
name|sasl_baton
operator|->
name|read_len
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__stream_read
argument_list|(
name|sasl_baton
operator|->
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|len2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
operator|==
literal|0
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_decode
argument_list|(
name|sasl_baton
operator|->
name|ctx
argument_list|,
name|buffer
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len2
argument_list|,
operator|&
name|sasl_baton
operator|->
name|read_buf
argument_list|,
operator|&
name|sasl_baton
operator|->
name|read_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
name|sasl_baton
operator|->
name|ctx
argument_list|,
name|result
argument_list|,
name|sasl_baton
operator|->
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* The buffer returned by sasl_decode might be larger than what the      caller wants.  If this is the case, we only copy back *len bytes now      (the rest will be returned by subsequent calls to this function).      If not, we just copy back the whole thing. */
if|if
condition|(
operator|*
name|len
operator|>=
name|sasl_baton
operator|->
name|read_len
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|sasl_baton
operator|->
name|read_buf
argument_list|,
name|sasl_baton
operator|->
name|read_len
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|sasl_baton
operator|->
name|read_len
expr_stmt|;
name|sasl_baton
operator|->
name|read_buf
operator|=
name|NULL
expr_stmt|;
name|sasl_baton
operator|->
name|read_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|sasl_baton
operator|->
name|read_buf
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|sasl_baton
operator|->
name|read_len
operator|-=
operator|*
name|len
expr_stmt|;
name|sasl_baton
operator|->
name|read_buf
operator|+=
operator|*
name|len
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_write_fn_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sasl_write_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|sasl_baton_t
modifier|*
name|sasl_baton
init|=
name|baton
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|sasl_baton
operator|->
name|write_buf
operator|||
name|sasl_baton
operator|->
name|write_len
operator|==
literal|0
condition|)
block|{
comment|/* Make sure we don't write too much. */
operator|*
name|len
operator|=
operator|(
operator|*
name|len
operator|>
name|sasl_baton
operator|->
name|maxsize
operator|)
condition|?
name|sasl_baton
operator|->
name|maxsize
else|:
operator|*
name|len
expr_stmt|;
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_encode
argument_list|(
name|sasl_baton
operator|->
name|ctx
argument_list|,
name|buffer
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|len
argument_list|,
operator|&
name|sasl_baton
operator|->
name|write_buf
argument_list|,
operator|&
name|sasl_baton
operator|->
name|write_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
name|sasl_baton
operator|->
name|ctx
argument_list|,
name|result
argument_list|,
name|sasl_baton
operator|->
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
do|do
block|{
name|apr_size_t
name|tmplen
init|=
name|sasl_baton
operator|->
name|write_len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__stream_write
argument_list|(
name|sasl_baton
operator|->
name|stream
argument_list|,
name|sasl_baton
operator|->
name|write_buf
argument_list|,
operator|&
name|tmplen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplen
operator|==
literal|0
condition|)
block|{
comment|/* The output buffer and its length will be preserved in sasl_baton            and will be written out during the next call to this function            (which will have the same arguments). */
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|sasl_baton
operator|->
name|write_len
operator|-=
operator|(
name|unsigned
name|int
operator|)
name|tmplen
expr_stmt|;
name|sasl_baton
operator|->
name|write_buf
operator|+=
name|tmplen
expr_stmt|;
block|}
do|while
condition|(
name|sasl_baton
operator|->
name|write_len
operator|>
literal|0
condition|)
do|;
name|sasl_baton
operator|->
name|write_buf
operator|=
name|NULL
expr_stmt|;
name|sasl_baton
operator|->
name|write_len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements ra_svn_timeout_fn_t. */
end_comment

begin_function
specifier|static
name|void
name|sasl_timeout_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_interval_time_t
name|interval
parameter_list|)
block|{
name|sasl_baton_t
modifier|*
name|sasl_baton
init|=
name|baton
decl_stmt|;
name|svn_ra_svn__stream_timeout
argument_list|(
name|sasl_baton
operator|->
name|stream
argument_list|,
name|interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implements ra_svn_pending_fn_t. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|sasl_pending_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|sasl_baton_t
modifier|*
name|sasl_baton
init|=
name|baton
decl_stmt|;
return|return
name|svn_ra_svn__stream_pending
argument_list|(
name|sasl_baton
operator|->
name|stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn__enable_sasl_encryption
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|sasl_conn_t
modifier|*
name|sasl_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|sasl_ssf_t
modifier|*
name|ssfp
decl_stmt|;
if|if
condition|(
operator|!
name|conn
operator|->
name|encrypted
condition|)
block|{
name|int
name|result
decl_stmt|;
comment|/* Get the strength of the security layer. */
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_getprop
argument_list|(
name|sasl_ctx
argument_list|,
name|SASL_SSF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ssfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
name|sasl_ctx
argument_list|,
name|result
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|*
name|ssfp
operator|>
literal|0
condition|)
block|{
name|sasl_baton_t
modifier|*
name|sasl_baton
decl_stmt|;
specifier|const
name|void
modifier|*
name|maxsize
decl_stmt|;
comment|/* Flush the connection, as we're about to replace its stream. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__flush
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create and initialize the stream baton. */
name|sasl_baton
operator|=
name|apr_pcalloc
argument_list|(
name|conn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sasl_baton
argument_list|)
argument_list|)
expr_stmt|;
name|sasl_baton
operator|->
name|ctx
operator|=
name|sasl_ctx
expr_stmt|;
name|sasl_baton
operator|->
name|scratch_pool
operator|=
name|conn
operator|->
name|pool
expr_stmt|;
comment|/* Find out the maximum input size for sasl_encode. */
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_getprop
argument_list|(
name|sasl_ctx
argument_list|,
name|SASL_MAXOUTBUF
argument_list|,
operator|&
name|maxsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
name|sasl_ctx
argument_list|,
name|result
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|sasl_baton
operator|->
name|maxsize
operator|=
operator|*
operator|(
operator|(
specifier|const
name|unsigned
name|int
operator|*
operator|)
name|maxsize
operator|)
expr_stmt|;
comment|/* If there is any data left in the read buffer at this point,              we need to decrypt it. */
if|if
condition|(
name|conn
operator|->
name|read_end
operator|>
name|conn
operator|->
name|read_ptr
condition|)
block|{
name|clear_sasl_errno
argument_list|()
expr_stmt|;
name|result
operator|=
name|sasl_decode
argument_list|(
name|sasl_ctx
argument_list|,
name|conn
operator|->
name|read_ptr
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|conn
operator|->
name|read_end
operator|-
name|conn
operator|->
name|read_ptr
argument_list|)
argument_list|,
operator|&
name|sasl_baton
operator|->
name|read_buf
argument_list|,
operator|&
name|sasl_baton
operator|->
name|read_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|get_sasl_error
argument_list|(
name|sasl_ctx
argument_list|,
name|result
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|conn
operator|->
name|read_end
operator|=
name|conn
operator|->
name|read_ptr
expr_stmt|;
block|}
comment|/* Wrap the existing stream. */
name|sasl_baton
operator|->
name|stream
operator|=
name|conn
operator|->
name|stream
expr_stmt|;
name|conn
operator|->
name|stream
operator|=
name|svn_ra_svn__stream_create
argument_list|(
name|sasl_baton
argument_list|,
name|sasl_read_cb
argument_list|,
name|sasl_write_cb
argument_list|,
name|sasl_timeout_cb
argument_list|,
name|sasl_pending_cb
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Yay, we have a security layer! */
name|conn
operator|->
name|encrypted
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn__get_addresses
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|local_addrport
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|remote_addrport
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|conn
operator|->
name|sock
condition|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_sockaddr_t
modifier|*
name|local_sa
decl_stmt|,
modifier|*
name|remote_sa
decl_stmt|;
name|char
modifier|*
name|local_addr
decl_stmt|,
modifier|*
name|remote_addr
decl_stmt|;
name|apr_err
operator|=
name|apr_socket_addr_get
argument_list|(
operator|&
name|local_sa
argument_list|,
name|APR_LOCAL
argument_list|,
name|conn
operator|->
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|)
return|;
name|apr_err
operator|=
name|apr_socket_addr_get
argument_list|(
operator|&
name|remote_sa
argument_list|,
name|APR_REMOTE
argument_list|,
name|conn
operator|->
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|)
return|;
name|apr_err
operator|=
name|apr_sockaddr_ip_get
argument_list|(
operator|&
name|local_addr
argument_list|,
name|local_sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|)
return|;
name|apr_err
operator|=
name|apr_sockaddr_ip_get
argument_list|(
operator|&
name|remote_addr
argument_list|,
name|remote_sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Format the IP address and port number like this: a.b.c.d;port */
operator|*
name|local_addrport
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|local_addr
argument_list|,
literal|";"
argument_list|,
name|apr_itoa
argument_list|(
name|pool
argument_list|,
operator|(
name|int
operator|)
name|local_sa
operator|->
name|port
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|remote_addrport
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|remote_addr
argument_list|,
literal|";"
argument_list|,
name|apr_itoa
argument_list|(
name|pool
argument_list|,
operator|(
name|int
operator|)
name|remote_sa
operator|->
name|port
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn__do_cyrus_auth
parameter_list|(
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|mechlist
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|sasl_conn_t
modifier|*
name|sasl_ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|mechstring
init|=
literal|""
decl_stmt|,
modifier|*
name|last_err
init|=
literal|""
decl_stmt|,
modifier|*
name|realmstring
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_addrport
init|=
name|NULL
decl_stmt|,
modifier|*
name|remote_addrport
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|success
decl_stmt|;
name|sasl_callback_t
modifier|*
name|callbacks
decl_stmt|;
name|cred_baton_t
name|cred_baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sess
operator|->
name|is_tunneled
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__get_addresses
argument_list|(
operator|&
name|local_addrport
argument_list|,
operator|&
name|remote_addrport
argument_list|,
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prefer EXTERNAL, then ANONYMOUS, then let SASL decide. */
if|if
condition|(
name|svn_ra_svn__find_mech
argument_list|(
name|mechlist
argument_list|,
literal|"EXTERNAL"
argument_list|)
condition|)
name|mechstring
operator|=
literal|"EXTERNAL"
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_ra_svn__find_mech
argument_list|(
name|mechlist
argument_list|,
literal|"ANONYMOUS"
argument_list|)
condition|)
name|mechstring
operator|=
literal|"ANONYMOUS"
expr_stmt|;
else|else
block|{
comment|/* Create a string containing the list of mechanisms, separated by spaces. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mechlist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|elt
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|mechlist
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
name|mechstring
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|mechstring
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|elt
operator|->
name|u
operator|.
name|word
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|realmstring
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s"
argument_list|,
name|sess
operator|->
name|realm_prefix
argument_list|,
name|realm
argument_list|)
expr_stmt|;
comment|/* Initialize the credential baton. */
name|cred_baton
operator|.
name|auth_baton
operator|=
name|sess
operator|->
name|callbacks
operator|->
name|auth_baton
expr_stmt|;
name|cred_baton
operator|.
name|realmstring
operator|=
name|realmstring
expr_stmt|;
name|cred_baton
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Reserve space for 3 callbacks (for the username, password and the      array terminator).  These structures must persist until the      disposal of the SASL context at pool cleanup, however the      callback functions will not be invoked outside this function so      other structures can have a shorter lifetime. */
name|callbacks
operator|=
name|apr_palloc
argument_list|(
name|sess
operator|->
name|conn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|callbacks
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* Initialize the callbacks array. */
comment|/* The username callback. */
name|callbacks
index|[
literal|0
index|]
operator|.
name|id
operator|=
name|SASL_CB_AUTHNAME
expr_stmt|;
name|callbacks
index|[
literal|0
index|]
operator|.
name|proc
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|get_username_cb
expr_stmt|;
name|callbacks
index|[
literal|0
index|]
operator|.
name|context
operator|=
operator|&
name|cred_baton
expr_stmt|;
comment|/* The password callback. */
name|callbacks
index|[
literal|1
index|]
operator|.
name|id
operator|=
name|SASL_CB_PASS
expr_stmt|;
name|callbacks
index|[
literal|1
index|]
operator|.
name|proc
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|get_password_cb
expr_stmt|;
name|callbacks
index|[
literal|1
index|]
operator|.
name|context
operator|=
operator|&
name|cred_baton
expr_stmt|;
comment|/* Mark the end of the array. */
name|callbacks
index|[
literal|2
index|]
operator|.
name|id
operator|=
name|SASL_CB_LIST_END
expr_stmt|;
name|callbacks
index|[
literal|2
index|]
operator|.
name|proc
operator|=
name|NULL
expr_stmt|;
name|callbacks
index|[
literal|2
index|]
operator|.
name|context
operator|=
name|NULL
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* If last_err was set to a non-empty string, it needs to be duplicated          to the parent pool before the subpool is cleared. */
if|if
condition|(
operator|*
name|last_err
condition|)
name|last_err
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|last_err
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|new_sasl_ctx
argument_list|(
operator|&
name|sasl_ctx
argument_list|,
name|sess
operator|->
name|is_tunneled
argument_list|,
name|sess
operator|->
name|hostname
argument_list|,
name|local_addrport
argument_list|,
name|remote_addrport
argument_list|,
name|callbacks
argument_list|,
name|sess
operator|->
name|conn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|try_auth
argument_list|(
name|sess
argument_list|,
name|sasl_ctx
argument_list|,
operator|&
name|success
argument_list|,
operator|&
name|last_err
argument_list|,
name|mechstring
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* If we encountered an error while fetching credentials, that error          has priority. */
if|if
condition|(
name|cred_baton
operator|.
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|cred_baton
operator|.
name|err
return|;
block|}
if|if
condition|(
name|cred_baton
operator|.
name|no_more_creds
operator|||
operator|(
operator|!
name|err
operator|&&
operator|!
name|success
operator|&&
operator|!
name|cred_baton
operator|.
name|was_used
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If we ran out of authentication providers, or if we got a server              error and our callbacks were never called, there's no point in              retrying authentication.  Return the last error sent by the              server. */
if|if
condition|(
operator|*
name|last_err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Authentication error from server: %s"
argument_list|)
argument_list|,
name|last_err
argument_list|)
return|;
comment|/* Hmm, we don't have a server error. Return a generic error. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get username or password"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_SVN_NO_MECHANISMS
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We could not find a supported mechanism in the list sent by the                  server. In many cases this happens because the client is missing                  the CRAM-MD5 or ANONYMOUS plugins, in which case we can simply use                  the built-in implementation. In all other cases this call will be                  useless, but hey, at least we'll get consistent error messages. */
return|return
name|svn_ra_svn__do_internal_auth
argument_list|(
name|sess
argument_list|,
name|mechlist
argument_list|,
name|realm
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|err
return|;
block|}
block|}
do|while
condition|(
operator|!
name|success
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__enable_sasl_encryption
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|sasl_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_auth_save_credentials
argument_list|(
name|cred_baton
operator|.
name|iterstate
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_SASL */
end_comment

end_unit

