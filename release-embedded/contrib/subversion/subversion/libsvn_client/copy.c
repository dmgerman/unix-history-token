begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * copy.c:  copy/move wrappers around wc 'copy' functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_comment
comment|/*  * OUR BASIC APPROACH TO COPIES  * ============================  *  * for each source/destination pair  *   if (not exist src_path)  *     return ERR_BAD_SRC error  *  *   if (exist dst_path)  *     return ERR_OBSTRUCTION error  *   else  *     copy src_path into parent_of_dst_path as basename (dst_path)  *  *   if (this is a move)  *     delete src_path  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Extend the mergeinfo for the single WC path TARGET_WCPATH, adding    MERGEINFO to any mergeinfo pre-existing in the WC. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|extend_wc_mergeinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|wc_mergeinfo
decl_stmt|;
comment|/* Get a fresh copy of the pre-existing state of the WC's mergeinfo      updating it. */
name|SVN_ERR
argument_list|(
name|svn_client__parse_mergeinfo
argument_list|(
operator|&
name|wc_mergeinfo
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Combine the provided mergeinfo with any mergeinfo from the WC. */
if|if
condition|(
name|wc_mergeinfo
operator|&&
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|wc_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wc_mergeinfo
condition|)
name|wc_mergeinfo
operator|=
name|mergeinfo
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_client__record_wc_mergeinfo
argument_list|(
name|target_abspath
argument_list|,
name|wc_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the longest common ancestor of paths in COPY_PAIRS.  If    SRC_ANCESTOR is NULL, ignore source paths in this calculation.  If    DST_ANCESTOR is NULL, ignore destination paths in this calculation.    COMMON_ANCESTOR will be the common ancestor of both the    SRC_ANCESTOR and DST_ANCESTOR, and will only be set if it is not    NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_copy_pair_ancestors
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|src_ancestor
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dst_ancestor
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|common_ancestor
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|first
decl_stmt|;
specifier|const
name|char
modifier|*
name|first_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|first_src
decl_stmt|;
specifier|const
name|char
modifier|*
name|top_dst
decl_stmt|;
name|svn_boolean_t
name|src_is_url
decl_stmt|;
name|svn_boolean_t
name|dst_is_url
decl_stmt|;
name|char
modifier|*
name|top_src
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
literal|0
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Because all the destinations are in the same directory, we can easily      determine their common ancestor. */
name|first_dst
operator|=
name|first
operator|->
name|dst_abspath_or_url
expr_stmt|;
name|dst_is_url
operator|=
name|svn_path_is_url
argument_list|(
name|first_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_pairs
operator|->
name|nelts
operator|==
literal|1
condition|)
name|top_dst
operator|=
name|apr_pstrdup
argument_list|(
name|subpool
argument_list|,
name|first_dst
argument_list|)
expr_stmt|;
else|else
name|top_dst
operator|=
name|dst_is_url
condition|?
name|svn_uri_dirname
argument_list|(
name|first_dst
argument_list|,
name|subpool
argument_list|)
else|:
name|svn_dirent_dirname
argument_list|(
name|first_dst
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* Sources can came from anywhere, so we have to actually do some      work for them.  */
name|first_src
operator|=
name|first
operator|->
name|src_abspath_or_url
expr_stmt|;
name|src_is_url
operator|=
name|svn_path_is_url
argument_list|(
name|first_src
argument_list|)
expr_stmt|;
name|top_src
operator|=
name|apr_pstrdup
argument_list|(
name|subpool
argument_list|,
name|first_src
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* We don't need to clear the subpool here for several reasons:          1)  If we do, we can't use it to allocate the initial versions of              top_src and top_dst (above).          2)  We don't return any errors in the following loop, so we              are guanteed to destroy the subpool at the end of this function.          3)  The number of iterations is likely to be few, and the loop will              be through quickly, so memory leakage will not be significant,              in time or space.       */
specifier|const
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|top_src
operator|=
name|src_is_url
condition|?
name|svn_uri_get_longest_ancestor
argument_list|(
name|top_src
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|subpool
argument_list|)
else|:
name|svn_dirent_get_longest_ancestor
argument_list|(
name|top_src
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src_ancestor
condition|)
operator|*
name|src_ancestor
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|top_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_ancestor
condition|)
operator|*
name|dst_ancestor
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|top_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_ancestor
condition|)
operator|*
name|common_ancestor
operator|=
name|src_is_url
condition|?
name|svn_uri_get_longest_ancestor
argument_list|(
name|top_src
argument_list|,
name|top_dst
argument_list|,
name|pool
argument_list|)
else|:
name|svn_dirent_get_longest_ancestor
argument_list|(
name|top_src
argument_list|,
name|top_dst
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The guts of do_wc_to_wc_copies */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_wc_to_wc_copies_with_write_lock
parameter_list|(
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_parent
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|dst_abspath
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Check for cancellation */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform the copy */
name|dst_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|pair
operator|->
name|base_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|svn_wc_copy3
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|dst_abspath
argument_list|,
name|FALSE
comment|/* metadata_only */
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy each COPY_PAIR->SRC into COPY_PAIR->DST.  Use POOL for temporary    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_wc_to_wc_copies
parameter_list|(
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dst_parent
decl_stmt|,
modifier|*
name|dst_parent_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_copy_pair_ancestors
argument_list|(
name|copy_pairs
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst_parent
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_pairs
operator|->
name|nelts
operator|==
literal|1
condition|)
name|dst_parent
operator|=
name|svn_dirent_dirname
argument_list|(
name|dst_parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|dst_parent_abspath
argument_list|,
name|dst_parent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|do_wc_to_wc_copies_with_write_lock
argument_list|(
name|timestamp_sleep
argument_list|,
name|copy_pairs
argument_list|,
name|dst_parent
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dst_parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The locked bit of do_wc_to_wc_moves. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_wc_to_wc_moves_with_locks2
parameter_list|(
name|svn_client__copy_pair_t
modifier|*
name|pair
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_parent_abspath
parameter_list|,
name|svn_boolean_t
name|lock_src
parameter_list|,
name|svn_boolean_t
name|lock_dst
parameter_list|,
name|svn_boolean_t
name|allow_mixed_revisions
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dst_abspath
decl_stmt|;
name|dst_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dst_parent_abspath
argument_list|,
name|pair
operator|->
name|base_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__move2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|dst_abspath
argument_list|,
name|metadata_only
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrapper to add an optional second lock */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_wc_to_wc_moves_with_locks1
parameter_list|(
name|svn_client__copy_pair_t
modifier|*
name|pair
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_parent_abspath
parameter_list|,
name|svn_boolean_t
name|lock_src
parameter_list|,
name|svn_boolean_t
name|lock_dst
parameter_list|,
name|svn_boolean_t
name|allow_mixed_revisions
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|lock_dst
condition|)
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|do_wc_to_wc_moves_with_locks2
argument_list|(
name|pair
argument_list|,
name|dst_parent_abspath
argument_list|,
name|lock_src
argument_list|,
name|lock_dst
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|metadata_only
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dst_parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|do_wc_to_wc_moves_with_locks2
argument_list|(
name|pair
argument_list|,
name|dst_parent_abspath
argument_list|,
name|lock_src
argument_list|,
name|lock_dst
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|metadata_only
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Move each COPY_PAIR->SRC into COPY_PAIR->DST, deleting COPY_PAIR->SRC    afterwards.  Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_wc_to_wc_moves
parameter_list|(
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|svn_boolean_t
name|allow_mixed_revisions
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|src_parent_abspath
decl_stmt|;
name|svn_boolean_t
name|lock_src
decl_stmt|,
name|lock_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_wcroot_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_wcroot_abspath
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Check for cancellation */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|src_parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|src_wcroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|src_parent_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|dst_wcroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We now need to lock the right combination of batons.          Four cases:            1) src_parent == dst_parent            2) src_parent is parent of dst_parent            3) dst_parent is parent of src_parent            4) src_parent and dst_parent are disjoint          We can handle 1) as either 2) or 3) */
if|if
condition|(
name|strcmp
argument_list|(
name|src_parent_abspath
argument_list|,
name|pair
operator|->
name|dst_parent_abspath
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|svn_dirent_is_child
argument_list|(
name|src_parent_abspath
argument_list|,
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|svn_dirent_is_child
argument_list|(
name|src_parent_abspath
argument_list|,
name|dst_wcroot_abspath
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|lock_src
operator|=
name|TRUE
expr_stmt|;
name|lock_dst
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_dirent_is_child
argument_list|(
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|src_parent_abspath
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|svn_dirent_is_child
argument_list|(
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|src_wcroot_abspath
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|lock_src
operator|=
name|FALSE
expr_stmt|;
name|lock_dst
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|lock_src
operator|=
name|TRUE
expr_stmt|;
name|lock_dst
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
comment|/* Perform the copy and then the delete. */
if|if
condition|(
name|lock_src
condition|)
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|do_wc_to_wc_moves_with_locks1
argument_list|(
name|pair
argument_list|,
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|lock_src
argument_list|,
name|lock_dst
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|metadata_only
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|src_parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|do_wc_to_wc_moves_with_locks1
argument_list|(
name|pair
argument_list|,
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|lock_src
argument_list|,
name|lock_dst
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|metadata_only
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the destinations stored in COPY_PAIRS are valid working copy    destinations and set pair->dst_parent_abspath and pair->base_name for each    item to the resulting location if they do */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_wc_dsts
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_boolean_t
name|is_move
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Check that DST does not exist, but its parent does */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|dst_kind
decl_stmt|,
name|dst_parent_kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If DST_PATH does not exist, then its basename will become a new          file or dir added to its parent (possibly an implicit '.').          Else, just error out. */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|dst_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|FALSE
comment|/* show_deleted */
argument_list|,
name|TRUE
comment|/* show_hidden */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_kind
operator|!=
name|svn_node_none
condition|)
block|{
name|svn_boolean_t
name|is_excluded
decl_stmt|;
name|svn_boolean_t
name|is_server_excluded
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_is_not_present
argument_list|(
name|NULL
argument_list|,
operator|&
name|is_excluded
argument_list|,
operator|&
name|is_server_excluded
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_excluded
operator|||
name|is_server_excluded
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' exists, but is excluded"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Check that there is no unversioned obstruction */
if|if
condition|(
name|metadata_only
condition|)
name|dst_kind
operator|=
name|svn_node_none
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
operator|&
name|dst_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_kind
operator|!=
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|is_move
operator|&&
name|copy_pairs
operator|->
name|nelts
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|dst_apr
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
comment|/* We have a rename inside a directory, which might collide                  just because the case insensivity of the filesystem makes                  the source match the destination. */
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|dst
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_merge
argument_list|(
operator|&
name|dst_apr
argument_list|,
name|NULL
argument_list|,
name|dst
argument_list|,
name|APR_FILEPATH_TRUENAME
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_err
condition|)
block|{
comment|/* And now bring it back to our canonical format */
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
operator|&
name|dst
argument_list|,
name|dst_apr
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|svn_dirent_canonicalize
argument_list|(
name|dst
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* else: Don't report this error; just report the normal error */
if|if
condition|(
operator|!
name|apr_err
operator|&&
name|strcmp
argument_list|(
name|dst
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Ok, we have a single case only rename. Get out of here */
name|svn_dirent_split
argument_list|(
operator|&
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
operator|&
name|pair
operator|->
name|base_name
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists as unversioned node"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|svn_dirent_split
argument_list|(
operator|&
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
operator|&
name|pair
operator|->
name|base_name
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Make sure the destination parent is a directory and produce a clear          error message if it is not. */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|dst_parent_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_parents
operator|&&
name|dst_parent_kind
operator|==
name|svn_node_none
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__make_local_parents
argument_list|(
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst_parent_kind
operator|!=
name|svn_node_dir
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
operator|&
name|dst_parent_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_parent_kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|dst_parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_wc_srcs_and_dsts
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_boolean_t
name|is_move
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Check that all of our SRCs exist. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_boolean_t
name|deleted_ok
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|deleted_ok
operator|=
operator|(
name|pair
operator|->
name|src_peg_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_base
operator|||
name|pair
operator|->
name|src_op_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_base
operator|)
expr_stmt|;
comment|/* Verify that SRC_PATH exists. */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|pair
operator|->
name|src_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|deleted_ok
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|src_kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|verify_wc_dsts
argument_list|(
name|copy_pairs
argument_list|,
name|make_parents
argument_list|,
name|is_move
argument_list|,
name|metadata_only
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Path-specific state used as part of path_driver_cb_baton. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|path_driver_info_t
block|{
specifier|const
name|char
modifier|*
name|src_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_path
decl_stmt|;
name|svn_node_kind_t
name|src_kind
decl_stmt|;
name|svn_revnum_t
name|src_revnum
decl_stmt|;
name|svn_boolean_t
name|resurrection
decl_stmt|;
name|svn_boolean_t
name|dir_add
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo
decl_stmt|;
comment|/* the new mergeinfo for the target */
block|}
name|path_driver_info_t
typedef|;
end_typedef

begin_comment
comment|/* The baton used with the path_driver_cb_func() callback for a copy    or move operation. */
end_comment

begin_struct
struct|struct
name|path_driver_cb_baton
block|{
comment|/* The editor (and its state) used to perform the operation. */
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
comment|/* A hash of path -> path_driver_info_t *'s. */
name|apr_hash_t
modifier|*
name|action_hash
decl_stmt|;
comment|/* Whether the operation is a move or copy. */
name|svn_boolean_t
name|is_move
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|path_driver_cb_func
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|path_driver_cb_baton
modifier|*
name|cb_baton
init|=
name|callback_baton
decl_stmt|;
name|svn_boolean_t
name|do_delete
init|=
name|FALSE
decl_stmt|,
name|do_add
init|=
name|FALSE
decl_stmt|;
name|path_driver_info_t
modifier|*
name|path_info
init|=
name|svn_hash_gets
argument_list|(
name|cb_baton
operator|->
name|action_hash
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|/* Initialize return value. */
operator|*
name|dir_baton
operator|=
name|NULL
expr_stmt|;
comment|/* This function should never get an empty PATH.  We can neither      create nor delete the empty PATH, so if someone is calling us      with such, the code is just plain wrong. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|svn_path_is_empty
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if we need to add the path as a directory. */
if|if
condition|(
name|path_info
operator|->
name|dir_add
condition|)
block|{
return|return
name|cb_baton
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
return|;
block|}
comment|/* If this is a resurrection, we know the source and dest paths are      the same, and that our driver will only be calling us once.  */
if|if
condition|(
name|path_info
operator|->
name|resurrection
condition|)
block|{
comment|/* If this is a move, we do nothing.  Otherwise, we do the copy.  */
if|if
condition|(
operator|!
name|cb_baton
operator|->
name|is_move
condition|)
name|do_add
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Not a resurrection. */
else|else
block|{
comment|/* If this is a move, we check PATH to see if it is the source          or the destination of the move. */
if|if
condition|(
name|cb_baton
operator|->
name|is_move
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|path_info
operator|->
name|src_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
name|do_delete
operator|=
name|TRUE
expr_stmt|;
else|else
name|do_add
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Not a move?  This must just be the copy addition. */
else|else
block|{
name|do_add
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_delete
condition|)
block|{
name|SVN_ERR
argument_list|(
name|cb_baton
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|parent_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_add
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_path_check_valid
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_info
operator|->
name|src_kind
operator|==
name|svn_node_file
condition|)
block|{
name|void
modifier|*
name|file_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cb_baton
operator|->
name|editor
operator|->
name|add_file
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|path_info
operator|->
name|src_url
argument_list|,
name|path_info
operator|->
name|src_revnum
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_info
operator|->
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|cb_baton
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|path_info
operator|->
name|mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cb_baton
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|cb_baton
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|path_info
operator|->
name|src_url
argument_list|,
name|path_info
operator|->
name|src_revnum
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_info
operator|->
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|cb_baton
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
operator|*
name|dir_baton
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|path_info
operator|->
name|mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Starting with the path DIR relative to the RA_SESSION's session    URL, work up through DIR's parents until an existing node is found.    Push each nonexistent path onto the array NEW_DIRS, allocating in    POOL.  Raise an error if the existing node is not a directory.     ### Multiple requests for HEAD (SVN_INVALID_REVNUM) make this    ### implementation susceptible to race conditions.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_absent_parents1
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|apr_array_header_t
modifier|*
name|new_dirs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|dir
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|new_dirs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|dir
expr_stmt|;
name|dir
operator|=
name|svn_dirent_dirname
argument_list|(
name|dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|dir
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ALREADY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists, but is not a "
literal|"directory"
argument_list|)
argument_list|,
name|dir
argument_list|)
return|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Starting with the URL *TOP_DST_URL which is also the root of    RA_SESSION, work up through its parents until an existing node is    found. Push each nonexistent URL onto the array NEW_DIRS,    allocating in POOL.  Raise an error if the existing node is not a    directory.     Set *TOP_DST_URL and the RA session's root to the existing node's URL.     ### Multiple requests for HEAD (SVN_INVALID_REVNUM) make this    ### implementation susceptible to race conditions.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_absent_parents2
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|top_dst_url
parameter_list|,
name|apr_array_header_t
modifier|*
name|new_dirs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|root_url
init|=
operator|*
name|top_dst_url
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|new_dirs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|root_url
expr_stmt|;
name|root_url
operator|=
name|svn_uri_dirname
argument_list|(
name|root_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ALREADY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists, but is not a directory"
argument_list|)
argument_list|,
name|root_url
argument_list|)
return|;
operator|*
name|top_dst_url
operator|=
name|root_url
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repos_to_repos_copy
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|is_move
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|2
operator|*
name|copy_pairs
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|action_hash
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|path_infos
decl_stmt|;
specifier|const
name|char
modifier|*
name|top_url
decl_stmt|,
modifier|*
name|top_url_all
decl_stmt|,
modifier|*
name|top_url_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|,
modifier|*
name|repos_root
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|struct
name|path_driver_cb_baton
name|cb_baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_dirs
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|commit_revprops
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|first_pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
literal|0
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Open an RA session to the first copy pair's destination.  We'll      be verifying that every one of our copy source and destination      URLs is or is beneath this sucker's repository root URL as a form      of a cheap(ish) sanity check.  */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|first_pair
operator|->
name|src_abspath_or_url
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify that sources and destinations are all at or under      REPOS_ROOT.  While here, create a path_info struct for each      src/dst pair and initialize portions of it with normalized source      location information.  */
name|path_infos
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|copy_pairs
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|path_driver_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|path_driver_info_t
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|mergeinfo
decl_stmt|;
comment|/* Are the source and destination URLs at or under REPOS_ROOT? */
if|if
condition|(
operator|!
operator|(
name|svn_uri__is_ancestor
argument_list|(
name|repos_root
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|)
operator|&&
name|svn_uri__is_ancestor
argument_list|(
name|repos_root
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Source and destination URLs appear not to point to the "
literal|"same repository."
argument_list|)
argument_list|)
return|;
comment|/* Run the history function to get the source's URL and revnum in the          operational revision. */
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__repos_locations
argument_list|(
operator|&
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
operator|&
name|pair
operator|->
name|src_revnum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ra_session
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
operator|&
name|pair
operator|->
name|src_peg_revision
argument_list|,
operator|&
name|pair
operator|->
name|src_op_revision
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go ahead and grab mergeinfo from the source, too. */
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|ra_session
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
comment|/*squelch_incapable*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|info
operator|->
name|mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Plop an INFO structure onto our array thereof. */
name|info
operator|->
name|src_url
operator|=
name|pair
operator|->
name|src_abspath_or_url
expr_stmt|;
name|info
operator|->
name|src_revnum
operator|=
name|pair
operator|->
name|src_revnum
expr_stmt|;
name|info
operator|->
name|resurrection
operator|=
name|FALSE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|path_infos
argument_list|,
name|path_driver_info_t
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
comment|/* If this is a move, we have to open our session to the longest      path common to all SRC_URLS and DST_URLS in the repository so we      can do existence checks on all paths, and so we can operate on      all paths in the case of a move.  But if this is *not* a move,      then opening our session at the longest path common to sources      *and* destinations might be an optimization when the user is      authorized to access all that stuff, but could cause the      operation to fail altogether otherwise.  See issue #3242.  */
name|SVN_ERR
argument_list|(
name|get_copy_pair_ancestors
argument_list|(
name|copy_pairs
argument_list|,
name|NULL
argument_list|,
operator|&
name|top_url_dst
argument_list|,
operator|&
name|top_url_all
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|top_url
operator|=
name|is_move
condition|?
name|top_url_all
else|:
name|top_url_dst
expr_stmt|;
comment|/* Check each src/dst pair for resurrection, and verify that TOP_URL      is anchored high enough to cover all the editor_t activities      required for this operation.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|path_driver_info_t
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_infos
argument_list|,
name|i
argument_list|,
name|path_driver_info_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Source and destination are the same?  It's a resurrection. */
if|if
condition|(
name|strcmp
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|->
name|resurrection
operator|=
name|TRUE
expr_stmt|;
comment|/* We need to add each dst_URL, and (in a move) we'll need to          delete each src_URL.  Our selection of TOP_URL so far ensures          that all our destination URLs (and source URLs, for moves)          are at least as deep as TOP_URL, but we need to make sure          that TOP_URL is an *ancestor* of all our to-be-edited paths.           Issue #683 is demonstrates this scenario.  If you're          resurrecting a deleted item like this: 'svn cp -rN src_URL          dst_URL', then src_URL == dst_URL == top_url.  In this          situation, we want to open an RA session to be at least the          *parent* of all three. */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|top_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|top_url
argument_list|,
name|repos_root
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|top_url
operator|=
name|svn_uri_dirname
argument_list|(
name|top_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_move
operator|&&
operator|(
name|strcmp
argument_list|(
name|top_url
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|top_url
argument_list|,
name|repos_root
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|top_url
operator|=
name|svn_uri_dirname
argument_list|(
name|top_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Point the RA session to our current TOP_URL. */
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|top_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're allowed to create nonexistent parent directories of our      destinations, then make a list in NEW_DIRS of the parent      directories of the destination that don't yet exist.  */
if|if
condition|(
name|make_parents
condition|)
block|{
name|new_dirs
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a move, TOP_URL is at least the common ancestor of          all the paths (sources and destinations) involved.  Assuming          the sources exist (which is fair, because if they don't, this          whole operation will fail anyway), TOP_URL must also exist.          So it's the paths between TOP_URL and the destinations which          we have to check for existence.  But here, we take advantage          of the knowledge of our caller.  We know that if there are          multiple copy/move operations being requested, then the          destinations of the copies/moves will all be siblings of one          another.  Therefore, we need only to check for the          nonexistent paths between TOP_URL and *one* of our          destinations to find nonexistent parents of all of them.  */
if|if
condition|(
name|is_move
condition|)
block|{
comment|/* Imagine a situation where the user tries to copy an              existing source directory to nonexistent directory with              --parents options specified:                  svn copy --parents URL/src URL/dst               where src exists and dst does not.  If the dirname of the              destination path is equal to TOP_URL,              do not try to add dst to the NEW_DIRS list since it              will be added to the commit items array later in this              function. */
specifier|const
name|char
modifier|*
name|dir
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|top_url
argument_list|,
name|svn_uri_dirname
argument_list|(
name|first_pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|&&
operator|*
name|dir
condition|)
name|SVN_ERR
argument_list|(
name|find_absent_parents1
argument_list|(
name|ra_session
argument_list|,
name|dir
argument_list|,
name|new_dirs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If, however, this is *not* a move, TOP_URL only points to the          common ancestor of our destination path(s), or possibly one          level higher.  We'll need to do an existence crawl toward the          root of the repository, starting with one of our destinations          (see "... take advantage of the knowledge of our caller ..."          above), and possibly adjusting TOP_URL as we go. */
else|else
block|{
name|apr_array_header_t
modifier|*
name|new_urls
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|find_absent_parents2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|top_url
argument_list|,
name|new_urls
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert absolute URLs into relpaths relative to TOP_URL. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_urls
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|new_url
init|=
name|APR_ARRAY_IDX
argument_list|(
name|new_urls
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|top_url
argument_list|,
name|new_url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|new_dirs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|dir
expr_stmt|;
block|}
block|}
block|}
comment|/* For each src/dst pair, check to see if that SRC_URL is a child of      the DST_URL (excepting the case where DST_URL is the repo root).      If it is, and the parent of DST_URL is the current TOP_URL, then we      need to reparent the session one directory higher, the parent of      the DST_URL. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|path_driver_info_t
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_infos
argument_list|,
name|i
argument_list|,
name|path_driver_info_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|repos_root
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|relpath
operator|!=
name|NULL
operator|&&
operator|*
name|relpath
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|info
operator|->
name|resurrection
operator|=
name|TRUE
expr_stmt|;
name|top_url
operator|=
name|svn_uri_dirname
argument_list|(
name|top_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|top_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the portions of the SRC and DST URLs that are relative to      TOP_URL (URI-decoding them while we're at it), verify that the      source exists and the proposed destination does not, and toss      what we've learned into the INFO array.  (For copies -- that is,      non-moves -- the relative source URL NULL because it isn't a      child of the TOP_URL at all.  That's okay, we'll deal with      it.)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|path_driver_info_t
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_infos
argument_list|,
name|i
argument_list|,
name|path_driver_info_t
operator|*
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|dst_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_rel
decl_stmt|,
modifier|*
name|dst_rel
decl_stmt|;
name|src_rel
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|top_url
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_rel
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|src_rel
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|,
operator|&
name|info
operator|->
name|src_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|old_url
decl_stmt|;
name|src_rel
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|is_move
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_url
argument_list|,
name|ra_session
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|,
operator|&
name|info
operator|->
name|src_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|old_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|src_kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' does not exist in revision %ld"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|)
return|;
comment|/* Figure out the basename that will result from this operation,          and ensure that we aren't trying to overwrite existing paths.  */
name|dst_rel
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|top_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|dst_rel
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|dst_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_kind
operator|!=
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ALREADY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists"
argument_list|)
argument_list|,
name|dst_rel
argument_list|)
return|;
comment|/* More info for our INFO structure.  */
name|info
operator|->
name|src_path
operator|=
name|src_rel
expr_stmt|;
name|info
operator|->
name|dst_path
operator|=
name|dst_rel
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|action_hash
argument_list|,
name|info
operator|->
name|dst_path
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_move
operator|&&
operator|(
operator|!
name|info
operator|->
name|resurrection
operator|)
condition|)
name|svn_hash_sets
argument_list|(
name|action_hash
argument_list|,
name|info
operator|->
name|src_path
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SVN_CLIENT__HAS_LOG_MSG_FUNC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* Produce a list of new paths to add, and provide it to the          mechanism used to acquire a log message. */
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|2
operator|*
name|copy_pairs
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|item
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Add any intermediate directories to the message */
if|if
condition|(
name|make_parents
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_dirs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|new_dirs
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|top_url
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_infos
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|path_driver_info_t
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_infos
argument_list|,
name|i
argument_list|,
name|path_driver_info_t
operator|*
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|top_url
argument_list|,
name|info
operator|->
name|dst_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|is_move
operator|&&
operator|(
operator|!
name|info
operator|->
name|resurrection
operator|)
condition|)
block|{
name|item
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|top_url
argument_list|,
name|info
operator|->
name|src_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_DELETE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_client__get_log_msg
argument_list|(
operator|&
name|message
argument_list|,
operator|&
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|message
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|message
operator|=
literal|""
expr_stmt|;
comment|/* Setup our PATHS for the path-based editor drive. */
comment|/* First any intermediate directories. */
if|if
condition|(
name|make_parents
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_dirs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|new_dirs
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|path_driver_info_t
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|->
name|dst_path
operator|=
name|relpath
expr_stmt|;
name|info
operator|->
name|dir_add
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|relpath
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|action_hash
argument_list|,
name|relpath
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Then our copy destinations and move sources (if any). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_infos
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|path_driver_info_t
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_infos
argument_list|,
name|i
argument_list|,
name|path_driver_info_t
operator|*
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|info
operator|->
name|dst_path
expr_stmt|;
if|if
condition|(
name|is_move
operator|&&
operator|(
operator|!
name|info
operator|->
name|resurrection
operator|)
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|info
operator|->
name|src_path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__ensure_revprop_table
argument_list|(
operator|&
name|commit_revprops
argument_list|,
name|revprop_table
argument_list|,
name|message
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch RA commit editor. */
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|ra_session
argument_list|,
name|svn_client__get_shim_callbacks
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|commit_revprops
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
comment|/* No lock tokens */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the callback baton. */
name|cb_baton
operator|.
name|editor
operator|=
name|editor
expr_stmt|;
name|cb_baton
operator|.
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|cb_baton
operator|.
name|action_hash
operator|=
name|action_hash
expr_stmt|;
name|cb_baton
operator|.
name|is_move
operator|=
name|is_move
expr_stmt|;
comment|/* Call the path-based editor driver. */
name|err
operator|=
name|svn_delta_path_driver2
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|paths
argument_list|,
name|TRUE
argument_list|,
name|path_driver_cb_func
argument_list|,
operator|&
name|cb_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* At least try to abort the edit (and fs txn) before throwing err. */
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Close the edit. */
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for check_url_kind */
end_comment

begin_struct
struct|struct
name|check_url_kind_baton
block|{
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|svn_boolean_t
name|should_reparent
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_client__check_url_kind_t for wc_to_repos_copy */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_url_kind
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|check_url_kind_baton
modifier|*
name|cukb
init|=
name|baton
decl_stmt|;
comment|/* If we don't have a session or can't use the session, get one */
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|cukb
operator|->
name|repos_root_url
argument_list|,
name|url
argument_list|)
condition|)
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
else|else
block|{
name|cukb
operator|->
name|should_reparent
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|cukb
operator|->
name|session
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|cukb
operator|->
name|session
argument_list|,
literal|""
argument_list|,
name|revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ### Copy ...  * COMMIT_INFO_P is ...  * COPY_PAIRS is ... such that each 'src_abspath_or_url' is a local abspath  * and each 'dst_abspath_or_url' is a URL.  * MAKE_PARENTS is ...  * REVPROP_TABLE is ...  * CTX is ... */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|wc_to_repos_copy
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
specifier|const
name|char
modifier|*
name|top_src_path
decl_stmt|,
modifier|*
name|top_dst_url
decl_stmt|;
name|struct
name|check_url_kind_baton
name|cukb
decl_stmt|;
specifier|const
name|char
modifier|*
name|top_src_abspath
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|apr_hash_t
modifier|*
name|relpath_map
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|svn_client__committables_t
modifier|*
name|committables
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_dirs
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|commit_revprops
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|first_pair
decl_stmt|;
name|apr_pool_t
modifier|*
name|session_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find the common root of all the source paths */
name|SVN_ERR
argument_list|(
name|get_copy_pair_ancestors
argument_list|(
name|copy_pairs
argument_list|,
operator|&
name|top_src_path
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we need to lock the working copy?  1.6 didn't take a write      lock, but what happens if the working copy changes during the copy      operation? */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Determine the longest common ancestor for the destinations, and open an RA      session to that location. */
comment|/* ### But why start by getting the _parent_ of the first one? */
comment|/* --- That works because multiple destinations always point to the same    *     directory. I'm rather wondering why we need to find a common    *     destination parent here at all, instead of simply getting    *     top_dst_url from get_copy_pair_ancestors() above?    *     It looks like the entire block of code hanging off this comment    *     is redundant. */
name|first_pair
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
literal|0
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
expr_stmt|;
name|top_dst_url
operator|=
name|svn_uri_dirname
argument_list|(
name|first_pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|top_dst_url
operator|=
name|svn_uri_get_longest_ancestor
argument_list|(
name|top_dst_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|top_src_abspath
argument_list|,
name|top_src_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open a session to help while determining the exact targets */
name|SVN_ERR
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
operator|&
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|top_dst_url
argument_list|,
name|top_src_abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
comment|/* write_dav_props */
argument_list|,
name|TRUE
comment|/* read_dav_props */
argument_list|,
name|ctx
argument_list|,
name|session_pool
argument_list|,
name|session_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If requested, determine the nearest existing parent of the destination,      and reparent the ra session there. */
if|if
condition|(
name|make_parents
condition|)
block|{
name|new_dirs
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_absent_parents2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|top_dst_url
argument_list|,
name|new_dirs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Figure out the basename that will result from each copy and check to make      sure it doesn't exist already. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_node_kind_t
name|dst_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_rel
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|dst_rel
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|top_dst_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|dst_rel
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|dst_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_kind
operator|!=
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ALREADY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists"
argument_list|)
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|SVN_CLIENT__HAS_LOG_MSG_FUNC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* Produce a list of new paths to add, and provide it to the          mechanism used to acquire a log message. */
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|commit_items
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|copy_pairs
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add any intermediate directories to the message */
if|if
condition|(
name|make_parents
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_dirs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|APR_ARRAY_IDX
argument_list|(
name|new_dirs
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|url
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|pair
operator|->
name|dst_abspath_or_url
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__get_log_msg
argument_list|(
operator|&
name|message
argument_list|,
operator|&
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|message
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|session_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
name|message
operator|=
literal|""
expr_stmt|;
name|cukb
operator|.
name|session
operator|=
name|ra_session
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|cukb
operator|.
name|repos_root_url
argument_list|,
name|session_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cukb
operator|.
name|should_reparent
operator|=
name|FALSE
expr_stmt|;
comment|/* Crawl the working copy for commit items. */
comment|/* ### TODO: Pass check_url_func for issue #3314 handling */
name|SVN_ERR
argument_list|(
name|svn_client__get_copy_committables
argument_list|(
operator|&
name|committables
argument_list|,
name|copy_pairs
argument_list|,
name|check_url_kind
argument_list|,
operator|&
name|cukb
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The committables are keyed by the repository root */
name|commit_items
operator|=
name|svn_hash_gets
argument_list|(
name|committables
operator|->
name|by_repository
argument_list|,
name|cukb
operator|.
name|repos_root_url
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|commit_items
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cukb
operator|.
name|should_reparent
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|top_dst_url
argument_list|,
name|session_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are creating intermediate directories, tack them onto the list      of committables. */
if|if
condition|(
name|make_parents
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_dirs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|APR_ARRAY_IDX
argument_list|(
name|new_dirs
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|url
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
name|item
operator|->
name|incoming_prop_changes
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
block|}
comment|/* ### TODO: This extra loop would be unnecessary if this code lived      ### in svn_client__get_copy_committables(), which is incidentally      ### only used above (so should really be in this source file). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_hash_t
modifier|*
name|mergeinfo
decl_stmt|,
modifier|*
name|wc_mergeinfo
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|src_origin
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__wc_node_get_origin
argument_list|(
operator|&
name|src_origin
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the mergeinfo for the destination to the combined merge          info known to the WC and the repository. */
name|item
operator|->
name|outgoing_prop_changes
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Repository mergeinfo (or NULL if it's locally added)... */
if|if
condition|(
name|src_origin
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|ra_session
argument_list|,
name|src_origin
operator|->
name|url
argument_list|,
name|src_origin
operator|->
name|rev
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
comment|/*sqelch_inc.*/
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
comment|/* ... and WC mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_client__parse_mergeinfo
argument_list|(
operator|&
name|wc_mergeinfo
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_mergeinfo
operator|&&
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|mergeinfo
argument_list|,
name|wc_mergeinfo
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|mergeinfo
condition|)
name|mergeinfo
operator|=
name|wc_mergeinfo
expr_stmt|;
if|if
condition|(
name|mergeinfo
condition|)
block|{
comment|/* Push a mergeinfo prop representing MERGEINFO onto the            * OUTGOING_PROP_CHANGES array. */
name|svn_prop_t
modifier|*
name|mergeinfo_prop
init|=
name|apr_palloc
argument_list|(
name|item
operator|->
name|outgoing_prop_changes
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|prop_value
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|prop_value
argument_list|,
name|mergeinfo
argument_list|,
name|item
operator|->
name|outgoing_prop_changes
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_prop
operator|->
name|name
operator|=
name|SVN_PROP_MERGEINFO
expr_stmt|;
name|mergeinfo_prop
operator|->
name|value
operator|=
name|prop_value
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|item
operator|->
name|outgoing_prop_changes
argument_list|,
name|svn_prop_t
operator|*
argument_list|)
operator|=
name|mergeinfo_prop
expr_stmt|;
block|}
block|}
comment|/* Sort and condense our COMMIT_ITEMS. */
name|SVN_ERR
argument_list|(
name|svn_client__condense_commit_items
argument_list|(
operator|&
name|top_dst_url
argument_list|,
name|commit_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_EV2_SHIMS
if|if
condition|(
name|commit_items
condition|)
block|{
name|relpath_map
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|path
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relpath
condition|)
name|svn_hash_sets
argument_list|(
name|relpath_map
argument_list|,
name|relpath
argument_list|,
name|item
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Close the initial session, to reopen a new session with commit handling */
name|svn_pool_clear
argument_list|(
name|session_pool
argument_list|)
expr_stmt|;
comment|/* Open a new RA session to DST_URL. */
name|SVN_ERR
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
operator|&
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|top_dst_url
argument_list|,
name|NULL
argument_list|,
name|commit_items
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|session_pool
argument_list|,
name|session_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_revprop_table
argument_list|(
operator|&
name|commit_revprops
argument_list|,
name|revprop_table
argument_list|,
name|message
argument_list|,
name|ctx
argument_list|,
name|session_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch RA commit editor. */
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|ra_session
argument_list|,
name|svn_client__get_shim_callbacks
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|relpath_map
argument_list|,
name|session_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|commit_revprops
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
comment|/* No lock tokens */
name|session_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform the commit. */
name|SVN_ERR_W
argument_list|(
name|svn_client__do_commit
argument_list|(
name|top_dst_url
argument_list|,
name|commit_items
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
literal|0
argument_list|,
comment|/* ### any notify_path_offset needed? */
name|NULL
argument_list|,
name|ctx
argument_list|,
name|session_pool
argument_list|,
name|session_pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Commit failed (details follow):"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|session_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A baton for notification_adjust_func(). */
end_comment

begin_struct
struct|struct
name|notification_adjust_baton
block|{
name|svn_wc_notify_func2_t
name|inner_func
decl_stmt|;
name|void
modifier|*
name|inner_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|checkout_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_abspath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A svn_wc_notify_func2_t function that wraps BATON->inner_func (whose  * baton is BATON->inner_baton) and adjusts the notification paths that  * start with BATON->checkout_abspath to start instead with  * BATON->final_abspath. */
end_comment

begin_function
specifier|static
name|void
name|notification_adjust_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_wc_notify_t
modifier|*
name|notify
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|notification_adjust_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|svn_wc_notify_t
modifier|*
name|inner_notify
init|=
name|svn_wc_dup_notify
argument_list|(
name|notify
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|nb
operator|->
name|checkout_abspath
argument_list|,
name|notify
operator|->
name|path
argument_list|)
expr_stmt|;
name|inner_notify
operator|->
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|nb
operator|->
name|final_abspath
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|->
name|inner_func
condition|)
name|nb
operator|->
name|inner_func
argument_list|(
name|nb
operator|->
name|inner_baton
argument_list|,
name|inner_notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Peform each individual copy operation for a repos -> wc copy.  A    helper for repos_to_wc_copy().     Resolve PAIR->src_revnum to a real revision number if it isn't already. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repos_to_wc_copy_single
parameter_list|(
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
name|svn_client__copy_pair_t
modifier|*
name|pair
parameter_list|,
name|svn_boolean_t
name|same_repositories
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|src_mergeinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_abspath
init|=
name|pair
operator|->
name|dst_abspath_or_url
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|dst_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_repositories
operator|&&
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify_url
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|svn_wc_notify_foreign_copy_begin
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|pair
operator|->
name|src_kind
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Allow a theoretical cancel to get through. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|same_repositories
condition|)
block|{
name|svn_boolean_t
name|sleep_needed
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpdir_abspath
decl_stmt|,
modifier|*
name|tmp_abspath
decl_stmt|;
comment|/* Find a temporary location in which to check out the copy source. */
name|SVN_ERR
argument_list|(
name|svn_wc__get_tmpdir
argument_list|(
operator|&
name|tmpdir_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dst_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|tmp_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a new checkout of the requested source. While doing so,            * resolve pair->src_revnum to an actual revision number in case it            * was until now 'invalid' meaning 'head'.  Ask this function not to            * sleep for timestamps, by passing a sleep_needed output param.            * Send notifications for all nodes except the root node, and adjust            * them to refer to the destination rather than this temporary path. */
block|{
name|svn_wc_notify_func2_t
name|old_notify_func2
init|=
name|ctx
operator|->
name|notify_func2
decl_stmt|;
name|void
modifier|*
name|old_notify_baton2
init|=
name|ctx
operator|->
name|notify_baton2
decl_stmt|;
name|struct
name|notification_adjust_baton
name|nb
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|nb
operator|.
name|inner_func
operator|=
name|ctx
operator|->
name|notify_func2
expr_stmt|;
name|nb
operator|.
name|inner_baton
operator|=
name|ctx
operator|->
name|notify_baton2
expr_stmt|;
name|nb
operator|.
name|checkout_abspath
operator|=
name|tmp_abspath
expr_stmt|;
name|nb
operator|.
name|final_abspath
operator|=
name|dst_abspath
expr_stmt|;
name|ctx
operator|->
name|notify_func2
operator|=
name|notification_adjust_func
expr_stmt|;
name|ctx
operator|->
name|notify_baton2
operator|=
operator|&
name|nb
expr_stmt|;
name|err
operator|=
name|svn_client__checkout_internal
argument_list|(
operator|&
name|pair
operator|->
name|src_revnum
argument_list|,
name|pair
operator|->
name|src_original
argument_list|,
name|tmp_abspath
argument_list|,
operator|&
name|pair
operator|->
name|src_peg_revision
argument_list|,
operator|&
name|pair
operator|->
name|src_op_revision
argument_list|,
name|svn_depth_infinity
argument_list|,
name|ignore_externals
argument_list|,
name|FALSE
argument_list|,
operator|&
name|sleep_needed
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|notify_func2
operator|=
name|old_notify_func2
expr_stmt|;
name|ctx
operator|->
name|notify_baton2
operator|=
name|old_notify_baton2
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
operator|*
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
comment|/* Schedule dst_path for addition in parent, with copy history.          Don't send any notification here.          Then remove the temporary checkout's .svn dir in preparation for          moving the rest of it into the final destination. */
name|SVN_ERR
argument_list|(
name|svn_wc_copy3
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|tmp_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|TRUE
comment|/* metadata_only */
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__acquire_write_lock
argument_list|(
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|tmp_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_remove_from_revision_control2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|tmp_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the temporary disk tree into place. */
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|tmp_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__copy_foreign
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|dst_abspath
argument_list|,
operator|&
name|pair
operator|->
name|src_peg_revision
argument_list|,
operator|&
name|pair
operator|->
name|src_op_revision
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
comment|/* make_parents */
argument_list|,
name|TRUE
comment|/* already_locked */
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* end directory case */
elseif|else
if|if
condition|(
name|pair
operator|->
name|src_kind
operator|==
name|svn_node_file
condition|)
block|{
name|apr_hash_t
modifier|*
name|new_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_rel
decl_stmt|;
name|svn_stream_t
modifier|*
name|new_base_contents
init|=
name|svn_stream_buffered
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_session
argument_list|(
name|ra_session
argument_list|,
operator|&
name|src_rel
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the file content. While doing so, resolve pair->src_revnum        * to an actual revision number if it's 'invalid' meaning 'head'. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
name|src_rel
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|,
name|new_base_contents
argument_list|,
operator|&
name|pair
operator|->
name|src_revnum
argument_list|,
operator|&
name|new_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_props
operator|&&
operator|!
name|same_repositories
condition|)
name|svn_hash_sets
argument_list|(
name|new_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_add_repos_file4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dst_abspath
argument_list|,
name|new_base_contents
argument_list|,
name|NULL
argument_list|,
name|new_props
argument_list|,
name|NULL
argument_list|,
name|same_repositories
condition|?
name|pair
operator|->
name|src_abspath_or_url
else|:
name|NULL
argument_list|,
name|same_repositories
condition|?
name|pair
operator|->
name|src_revnum
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record the implied mergeinfo (before the notification callback      is invoked for the root node). */
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo
argument_list|(
operator|&
name|src_mergeinfo
argument_list|,
name|ra_session
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
comment|/*squelch_incapable*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|extend_wc_mergeinfo
argument_list|(
name|dst_abspath
argument_list|,
name|src_mergeinfo
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do our own notification for the root node, even if we could possibly      have delegated it.  See also issue #1552.       ### Maybe this notification should mention the mergeinfo change. */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|dst_abspath
argument_list|,
name|svn_wc_notify_add
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|pair
operator|->
name|src_kind
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repos_to_wc_copy_locked
parameter_list|(
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
specifier|const
name|char
modifier|*
name|top_dst_path
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|same_repositories
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* We've already checked for physical obstruction by a working file.      But there could also be logical obstruction by an entry whose      working file happens to be missing.*/
name|SVN_ERR
argument_list|(
name|verify_wc_dsts
argument_list|(
name|copy_pairs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
comment|/* metadata_only */
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decide whether the two repositories are the same or not. */
block|{
name|svn_error_t
modifier|*
name|src_err
decl_stmt|,
modifier|*
name|dst_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_uuid
decl_stmt|,
modifier|*
name|dst_uuid
decl_stmt|;
comment|/* Get the repository uuid of SRC_URL */
name|src_err
operator|=
name|svn_ra_get_uuid2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|src_uuid
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_err
operator|&&
name|src_err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_RA_NO_REPOS_UUID
condition|)
return|return
name|svn_error_trace
argument_list|(
name|src_err
argument_list|)
return|;
comment|/* Get repository uuid of dst's parent directory, since dst may        not exist.  ### TODO:  we should probably walk up the wc here,        in case the parent dir has an imaginary URL.  */
if|if
condition|(
name|copy_pairs
operator|->
name|nelts
operator|==
literal|1
condition|)
name|parent
operator|=
name|svn_dirent_dirname
argument_list|(
name|top_dst_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|parent
operator|=
name|top_dst_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|parent_abspath
argument_list|,
name|parent
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|dst_err
operator|=
name|svn_client_get_repos_root
argument_list|(
name|NULL
comment|/* root_url */
argument_list|,
operator|&
name|dst_uuid
argument_list|,
name|parent_abspath
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_err
operator|&&
name|dst_err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_RA_NO_REPOS_UUID
condition|)
return|return
name|dst_err
return|;
comment|/* If either of the UUIDs are nonexistent, then at least one of        the repositories must be very old.  Rather than punish the        user, just assume the repositories are different, so no        copy-history is attempted. */
if|if
condition|(
name|src_err
operator|||
name|dst_err
operator|||
operator|(
operator|!
name|src_uuid
operator|)
operator|||
operator|(
operator|!
name|dst_uuid
operator|)
condition|)
name|same_repositories
operator|=
name|FALSE
expr_stmt|;
else|else
name|same_repositories
operator|=
operator|(
name|strcmp
argument_list|(
name|src_uuid
argument_list|,
name|dst_uuid
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Perform the move for each of the copy_pairs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check for cancellation */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repos_to_wc_copy_single
argument_list|(
name|timestamp_sleep
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
argument_list|,
name|same_repositories
argument_list|,
name|ignore_externals
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repos_to_wc_copy
parameter_list|(
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
specifier|const
name|char
modifier|*
name|top_src_url
decl_stmt|,
modifier|*
name|top_dst_path
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_abspath
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the real path for the source, based upon its peg revision. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__repos_locations
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|pair
operator|->
name|src_revnum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
operator|&
name|pair
operator|->
name|src_peg_revision
argument_list|,
operator|&
name|pair
operator|->
name|src_op_revision
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|pair
operator|->
name|src_original
operator|=
name|pair
operator|->
name|src_abspath_or_url
expr_stmt|;
name|pair
operator|->
name|src_abspath_or_url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|get_copy_pair_ancestors
argument_list|(
name|copy_pairs
argument_list|,
operator|&
name|top_src_url
argument_list|,
operator|&
name|top_dst_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock_abspath
operator|=
name|top_dst_path
expr_stmt|;
if|if
condition|(
name|copy_pairs
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
name|top_src_url
operator|=
name|svn_uri_dirname
argument_list|(
name|top_src_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|lock_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|top_dst_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Open a repository session to the longest common src ancestor.  We do not      (yet) have a working copy, so we don't have a corresponding path and      tempfiles cannot go into the admin area. */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|top_src_url
argument_list|,
name|lock_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the correct src path for the peg revision used, and verify that we      aren't overwriting an existing path. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|dst_parent_kind
decl_stmt|,
name|dst_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_rel
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Next, make sure that the path exists in the repository. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_session
argument_list|(
name|ra_session
argument_list|,
operator|&
name|src_rel
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|src_rel
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|,
operator|&
name|pair
operator|->
name|src_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|src_kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|pair
operator|->
name|src_revnum
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' not found in revision %ld"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|src_revnum
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' not found in head revision"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|)
return|;
block|}
comment|/* Figure out about dst. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
operator|&
name|dst_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_kind
operator|!=
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Make sure the destination parent is a directory and produce a clear          error message if it is not. */
name|dst_parent
operator|=
name|svn_dirent_dirname
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_parent
argument_list|,
operator|&
name|dst_parent_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_parents
operator|&&
name|dst_parent_kind
operator|==
name|svn_node_none
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__make_local_parents
argument_list|(
name|dst_parent
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst_parent_kind
operator|!=
name|svn_node_dir
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_parent
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|repos_to_wc_copy_locked
argument_list|(
name|timestamp_sleep
argument_list|,
name|copy_pairs
argument_list|,
name|top_dst_path
argument_list|,
name|ignore_externals
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|lock_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NEED_REPOS_REVNUM
parameter_list|(
name|revision
parameter_list|)
define|\
value|((revision.kind != svn_opt_revision_unspecified) \&& (revision.kind != svn_opt_revision_working))
end_define

begin_comment
comment|/* ...  *  * Set *TIMESTAMP_SLEEP to TRUE if a sleep is required; otherwise do not  * change *TIMESTAMP_SLEEP.  This output will be valid even if the  * function returns an error.  *  * Perform all allocations in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|try_copy
parameter_list|(
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|sources
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path_in
parameter_list|,
name|svn_boolean_t
name|is_move
parameter_list|,
name|svn_boolean_t
name|allow_mixed_revisions
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|copy_pairs
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|sources
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_client__copy_pair_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|srcs_are_urls
decl_stmt|,
name|dst_is_url
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Are either of our paths URLs?  Just check the first src_path.  If      there are more than one, we'll check for homogeneity among them      down below. */
name|srcs_are_urls
operator|=
name|svn_path_is_url
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|sources
argument_list|,
literal|0
argument_list|,
name|svn_client_copy_source_t
operator|*
argument_list|)
operator|->
name|path
argument_list|)
expr_stmt|;
name|dst_is_url
operator|=
name|svn_path_is_url
argument_list|(
name|dst_path_in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst_is_url
condition|)
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|dst_path_in
argument_list|,
name|dst_path_in
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have multiple source paths, it implies the dst_path is a      directory we are moving or copying into.  Populate the COPY_PAIRS      array to contain a destination path for each of the source paths. */
if|if
condition|(
name|sources
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sources
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_copy_source_t
modifier|*
name|source
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sources
argument_list|,
name|i
argument_list|,
name|svn_client_copy_source_t
operator|*
argument_list|)
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pair
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_basename
decl_stmt|;
name|svn_boolean_t
name|src_is_url
init|=
name|svn_path_is_url
argument_list|(
name|source
operator|->
name|path
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_is_url
condition|)
block|{
name|pair
operator|->
name|src_abspath_or_url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|source
operator|->
name|path
argument_list|)
expr_stmt|;
name|src_basename
operator|=
name|svn_uri_basename
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|source
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|src_basename
operator|=
name|svn_dirent_basename
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|pair
operator|->
name|src_op_revision
operator|=
operator|*
name|source
operator|->
name|revision
expr_stmt|;
name|pair
operator|->
name|src_peg_revision
operator|=
operator|*
name|source
operator|->
name|peg_revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_resolve_revisions
argument_list|(
operator|&
name|pair
operator|->
name|src_peg_revision
argument_list|,
operator|&
name|pair
operator|->
name|src_op_revision
argument_list|,
name|src_is_url
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if all the sources are urls or all working copy            * paths. */
if|if
condition|(
name|src_is_url
operator|!=
name|srcs_are_urls
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot mix repository and working copy sources"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|dst_is_url
condition|)
name|pair
operator|->
name|dst_abspath_or_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|dst_path_in
argument_list|,
name|src_basename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|pair
operator|->
name|dst_abspath_or_url
operator|=
name|svn_dirent_join
argument_list|(
name|dst_path_in
argument_list|,
name|src_basename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|copy_pairs
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
operator|=
name|pair
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Only one source path. */
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pair
argument_list|)
argument_list|)
decl_stmt|;
name|svn_client_copy_source_t
modifier|*
name|source
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sources
argument_list|,
literal|0
argument_list|,
name|svn_client_copy_source_t
operator|*
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|src_is_url
init|=
name|svn_path_is_url
argument_list|(
name|source
operator|->
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_is_url
condition|)
name|pair
operator|->
name|src_abspath_or_url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|source
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|source
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pair
operator|->
name|src_op_revision
operator|=
operator|*
name|source
operator|->
name|revision
expr_stmt|;
name|pair
operator|->
name|src_peg_revision
operator|=
operator|*
name|source
operator|->
name|peg_revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_resolve_revisions
argument_list|(
operator|&
name|pair
operator|->
name|src_peg_revision
argument_list|,
operator|&
name|pair
operator|->
name|src_op_revision
argument_list|,
name|src_is_url
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pair
operator|->
name|dst_abspath_or_url
operator|=
name|dst_path_in
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|copy_pairs
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
operator|=
name|pair
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|srcs_are_urls
operator|&&
operator|!
name|dst_is_url
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_dirent_is_child
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|iterpool
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy path '%s' into its own child '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* A file external should not be moved since the file external is      implemented as a switched file and it would delete the file the      file external is switched to, which is not the behavior the user      would probably want. */
if|if
condition|(
name|is_move
operator|&&
operator|!
name|srcs_are_urls
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|external_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|defining_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_external_info
argument_list|(
operator|&
name|external_kind
argument_list|,
operator|&
name|defining_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_kind
operator|!=
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CANNOT_MOVE_FILE_EXTERNAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot move the external at '%s'; please "
literal|"edit the svn:externals property on '%s'."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|defining_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_move
condition|)
block|{
comment|/* Disallow moves between the working copy and the repository. */
if|if
condition|(
name|srcs_are_urls
operator|!=
name|dst_is_url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Moves between the working copy and the repository are not "
literal|"supported"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Disallow moving any path/URL onto or into itself. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|srcs_are_urls
condition|?
name|_
argument_list|(
literal|"Cannot move URL '%s' into itself"
argument_list|)
else|:
name|_
argument_list|(
literal|"Cannot move path '%s' into itself"
argument_list|)
argument_list|,
name|srcs_are_urls
condition|?
name|pair
operator|->
name|src_abspath_or_url
else|:
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|srcs_are_urls
condition|)
block|{
comment|/* If we are doing a wc->* copy, but with an operational revision              other than the working copy revision, we are really doing a              repo->* copy, because we're going to need to get the rev from the              repo. */
name|svn_boolean_t
name|need_repos_op_rev
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|need_repos_peg_rev
init|=
name|FALSE
decl_stmt|;
comment|/* Check to see if any revision is something other than              svn_opt_revision_unspecified or svn_opt_revision_working. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|NEED_REPOS_REVNUM
argument_list|(
name|pair
operator|->
name|src_op_revision
argument_list|)
condition|)
name|need_repos_op_rev
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|NEED_REPOS_REVNUM
argument_list|(
name|pair
operator|->
name|src_peg_revision
argument_list|)
condition|)
name|need_repos_peg_rev
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|need_repos_op_rev
operator|||
name|need_repos_peg_rev
condition|)
break|break;
block|}
if|if
condition|(
name|need_repos_op_rev
operator|||
name|need_repos_peg_rev
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|copyfrom_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copy_pairs
argument_list|,
name|i
argument_list|,
name|svn_client__copy_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
name|NULL
argument_list|,
operator|&
name|copyfrom_rev
argument_list|,
operator|&
name|copyfrom_repos_relpath
argument_list|,
operator|&
name|copyfrom_repos_root_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyfrom_repos_relpath
condition|)
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|copyfrom_repos_root_url
argument_list|,
name|copyfrom_repos_relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_MISSING_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not have a URL associated with it"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|pair
operator|->
name|src_abspath_or_url
operator|=
name|url
expr_stmt|;
if|if
condition|(
operator|!
name|need_repos_peg_rev
operator|||
name|pair
operator|->
name|src_peg_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_base
condition|)
block|{
comment|/* Default the peg revision to that of the WC entry. */
name|pair
operator|->
name|src_peg_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|pair
operator|->
name|src_peg_revision
operator|.
name|value
operator|.
name|number
operator|=
name|copyfrom_rev
expr_stmt|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_op_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_base
condition|)
block|{
comment|/* Use the entry's revision as the operational rev. */
name|pair
operator|->
name|src_op_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|pair
operator|->
name|src_op_revision
operator|.
name|value
operator|.
name|number
operator|=
name|copyfrom_rev
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|srcs_are_urls
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, call the right handler for the operation. */
if|if
condition|(
operator|(
operator|!
name|srcs_are_urls
operator|)
operator|&&
operator|(
operator|!
name|dst_is_url
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|verify_wc_srcs_and_dsts
argument_list|(
name|copy_pairs
argument_list|,
name|make_parents
argument_list|,
name|is_move
argument_list|,
name|metadata_only
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy or move all targets. */
if|if
condition|(
name|is_move
condition|)
return|return
name|svn_error_trace
argument_list|(
name|do_wc_to_wc_moves
argument_list|(
name|timestamp_sleep
argument_list|,
name|copy_pairs
argument_list|,
name|dst_path_in
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|metadata_only
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|else
block|{
comment|/* We ignore these values, so assert the default value */
name|SVN_ERR_ASSERT
argument_list|(
name|allow_mixed_revisions
operator|&&
operator|!
name|metadata_only
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|do_wc_to_wc_copies
argument_list|(
name|timestamp_sleep
argument_list|,
name|copy_pairs
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|srcs_are_urls
operator|)
operator|&&
operator|(
name|dst_is_url
operator|)
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|wc_to_repos_copy
argument_list|(
name|copy_pairs
argument_list|,
name|make_parents
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|srcs_are_urls
operator|)
operator|&&
operator|(
operator|!
name|dst_is_url
operator|)
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|repos_to_wc_copy
argument_list|(
name|timestamp_sleep
argument_list|,
name|copy_pairs
argument_list|,
name|make_parents
argument_list|,
name|ignore_externals
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|repos_to_repos_copy
argument_list|(
name|copy_pairs
argument_list|,
name|make_parents
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|is_move
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Public Interfaces */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client_copy6
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|sources
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|svn_boolean_t
name|copy_as_child
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|timestamp_sleep
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|sources
operator|->
name|nelts
operator|>
literal|1
operator|&&
operator|!
name|copy_as_child
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|err
operator|=
name|try_copy
argument_list|(
operator|&
name|timestamp_sleep
argument_list|,
name|sources
argument_list|,
name|dst_path
argument_list|,
name|FALSE
comment|/* is_move */
argument_list|,
name|TRUE
comment|/* allow_mixed_revisions */
argument_list|,
name|FALSE
comment|/* metadata_only */
argument_list|,
name|make_parents
argument_list|,
name|ignore_externals
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* If the destination exists, try to copy the sources as children of the      destination. */
if|if
condition|(
name|copy_as_child
operator|&&
name|err
operator|&&
operator|(
name|sources
operator|->
name|nelts
operator|==
literal|1
operator|)
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_EXISTS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_ALREADY_EXISTS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|src_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sources
argument_list|,
literal|0
argument_list|,
name|svn_client_copy_source_t
operator|*
argument_list|)
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_basename
decl_stmt|;
name|svn_boolean_t
name|src_is_url
init|=
name|svn_path_is_url
argument_list|(
name|src_path
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|dst_is_url
init|=
name|svn_path_is_url
argument_list|(
name|dst_path
argument_list|)
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|src_basename
operator|=
name|src_is_url
condition|?
name|svn_uri_basename
argument_list|(
name|src_path
argument_list|,
name|subpool
argument_list|)
else|:
name|svn_dirent_basename
argument_list|(
name|src_path
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|dst_path
operator|=
name|dst_is_url
condition|?
name|svn_path_url_add_component2
argument_list|(
name|dst_path
argument_list|,
name|src_basename
argument_list|,
name|subpool
argument_list|)
else|:
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|src_basename
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|try_copy
argument_list|(
operator|&
name|timestamp_sleep
argument_list|,
name|sources
argument_list|,
name|dst_path
argument_list|,
name|FALSE
comment|/* is_move */
argument_list|,
name|TRUE
comment|/* allow_mixed_revisions */
argument_list|,
name|FALSE
comment|/* metadata_only */
argument_list|,
name|make_parents
argument_list|,
name|ignore_externals
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Sleep if required.  DST_PATH is not a URL in these cases. */
if|if
condition|(
name|timestamp_sleep
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|dst_path
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_move7
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|src_paths
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|svn_boolean_t
name|move_as_child
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_boolean_t
name|allow_mixed_revisions
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_opt_revision_t
name|head_revision
init|=
block|{
name|svn_opt_revision_head
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|timestamp_sleep
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sources
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|src_paths
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|svn_client_copy_source_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_paths
operator|->
name|nelts
operator|>
literal|1
operator|&&
operator|!
name|move_as_child
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|src_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|src_paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_client_copy_source_t
modifier|*
name|copy_source
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|copy_source
argument_list|)
argument_list|)
decl_stmt|;
name|copy_source
operator|->
name|path
operator|=
name|src_path
expr_stmt|;
name|copy_source
operator|->
name|revision
operator|=
operator|&
name|head_revision
expr_stmt|;
name|copy_source
operator|->
name|peg_revision
operator|=
operator|&
name|head_revision
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|sources
argument_list|,
name|svn_client_copy_source_t
operator|*
argument_list|)
operator|=
name|copy_source
expr_stmt|;
block|}
name|err
operator|=
name|try_copy
argument_list|(
operator|&
name|timestamp_sleep
argument_list|,
name|sources
argument_list|,
name|dst_path
argument_list|,
name|TRUE
comment|/* is_move */
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|metadata_only
argument_list|,
name|make_parents
argument_list|,
name|FALSE
comment|/* ignore_externals */
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* If the destination exists, try to move the sources as children of the      destination. */
if|if
condition|(
name|move_as_child
operator|&&
name|err
operator|&&
operator|(
name|src_paths
operator|->
name|nelts
operator|==
literal|1
operator|)
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_EXISTS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_ALREADY_EXISTS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|src_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|src_paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_basename
decl_stmt|;
name|svn_boolean_t
name|src_is_url
init|=
name|svn_path_is_url
argument_list|(
name|src_path
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|dst_is_url
init|=
name|svn_path_is_url
argument_list|(
name|dst_path
argument_list|)
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|src_basename
operator|=
name|src_is_url
condition|?
name|svn_uri_basename
argument_list|(
name|src_path
argument_list|,
name|pool
argument_list|)
else|:
name|svn_dirent_basename
argument_list|(
name|src_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_path
operator|=
name|dst_is_url
condition|?
name|svn_path_url_add_component2
argument_list|(
name|dst_path
argument_list|,
name|src_basename
argument_list|,
name|subpool
argument_list|)
else|:
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|src_basename
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|try_copy
argument_list|(
operator|&
name|timestamp_sleep
argument_list|,
name|sources
argument_list|,
name|dst_path
argument_list|,
name|TRUE
comment|/* is_move */
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|metadata_only
argument_list|,
name|make_parents
argument_list|,
name|FALSE
comment|/* ignore_externals */
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Sleep if required.  DST_PATH is not a URL in these cases. */
if|if
condition|(
name|timestamp_sleep
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|dst_path
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

