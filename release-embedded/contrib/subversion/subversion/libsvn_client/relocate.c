begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * relocate.c:  wrapper around wc relocation functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Repository root and UUID for a repository. */
end_comment

begin_struct
struct|struct
name|url_uuid_t
block|{
specifier|const
name|char
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|validator_baton_t
block|{
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|url_uuids
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validator_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|root_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|validator_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|struct
name|url_uuid_t
modifier|*
name|url_uuid
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|disable_checks
decl_stmt|;
name|apr_array_header_t
modifier|*
name|uuids
init|=
name|b
operator|->
name|url_uuids
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uuids
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|url_uuid_t
modifier|*
name|uu
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|uuids
argument_list|,
name|i
argument_list|,
expr|struct
name|url_uuid_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_uri__is_ancestor
argument_list|(
name|uu
operator|->
name|root
argument_list|,
name|url
argument_list|)
condition|)
block|{
name|url_uuid
operator|=
name|uu
expr_stmt|;
break|break;
block|}
block|}
name|disable_checks
operator|=
name|getenv
argument_list|(
literal|"SVN_I_LOVE_CORRUPTED_WORKING_COPIES_SO_DISABLE_RELOCATE_VALIDATION"
argument_list|)
expr_stmt|;
if|if
condition|(
name|disable_checks
operator|&&
operator|(
name|strcmp
argument_list|(
name|disable_checks
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Lie about URL_UUID's components, claiming they match the          expectations of the validation code below.  */
name|url_uuid
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|url_uuid
argument_list|)
argument_list|)
expr_stmt|;
name|url_uuid
operator|->
name|root
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|root_url
argument_list|)
expr_stmt|;
name|url_uuid
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
block|}
comment|/* We use an RA session in a subpool to get the UUID of the      repository at the new URL so we can force the RA session to close      by destroying the subpool. */
if|if
condition|(
operator|!
name|url_uuid
condition|)
block|{
name|apr_pool_t
modifier|*
name|sesspool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|url_uuid
operator|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|uuids
argument_list|,
expr|struct
name|url_uuid_t
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_get_repos_root
argument_list|(
operator|&
name|url_uuid
operator|->
name|root
argument_list|,
operator|&
name|url_uuid
operator|->
name|uuid
argument_list|,
name|url
argument_list|,
name|b
operator|->
name|ctx
argument_list|,
name|pool
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the url is a repository root if desired. */
if|if
condition|(
name|root_url
operator|&&
name|strcmp
argument_list|(
name|root_url
argument_list|,
name|url_uuid
operator|->
name|root
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_RELOCATION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not the root of the repository"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
comment|/* Make sure the UUIDs match. */
if|if
condition|(
name|uuid
operator|&&
name|strcmp
argument_list|(
name|uuid
argument_list|,
name|url_uuid
operator|->
name|uuid
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_RELOCATION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The repository at '%s' has uuid '%s', but the WC has '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|url_uuid
operator|->
name|uuid
argument_list|,
name|uuid
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Examing the array of svn_wc_external_item2_t's EXT_DESC (parsed    from the svn:externals property set on LOCAL_ABSPATH) and determine    if the external working copies described by such should be    relocated as a side-effect of the relocation of their parent    working copy (from OLD_PARENT_REPOS_ROOT_URL to    NEW_PARENT_REPOS_ROOT_URL).  If so, attempt said relocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|relocate_externals
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_array_header_t
modifier|*
name|ext_desc
parameter_list|,
specifier|const
name|char
modifier|*
name|old_parent_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|new_parent_repos_root_url
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Parse an externals definition into an array of external items. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ext_desc
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_wc_external_item2_t
modifier|*
name|ext_item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ext_desc
argument_list|,
name|i
argument_list|,
name|svn_wc_external_item2_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If this external isn't pulled in via a relative URL, ignore          it.  There's no sense in relocating a working copy only to          have the next 'svn update' try to point it back to another          location. */
if|if
condition|(
operator|!
operator|(
operator|(
name|strncmp
argument_list|(
literal|"../"
argument_list|,
name|ext_item
operator|->
name|url
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
literal|"^/"
argument_list|,
name|ext_item
operator|->
name|url
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
continue|continue;
comment|/* If the external working copy's not-yet-relocated repos root          URL matches the primary working copy's pre-relocated          repository root URL, try to relocate that external, too.          You might wonder why this check is needed, given that we're          already limiting ourselves to externals pulled via URLs          relative to their primary working copy.  Well, it's because          you can use "../" to "crawl up" above one repository's URL          space and down into another one.  */
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|target_abspath
argument_list|,
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|ext_item
operator|->
name|target_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client_get_repos_root
argument_list|(
operator|&
name|target_repos_root_url
argument_list|,
name|NULL
comment|/* uuid */
argument_list|,
name|target_abspath
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Ignore externals that aren't present in the working copy.        * This can happen if an external is deleted from disk accidentally,        * or if an external is configured on a locally added directory. */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_repos_root_url
argument_list|,
name|old_parent_repos_root_url
argument_list|)
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_client_relocate2
argument_list|(
name|target_abspath
argument_list|,
name|old_parent_repos_root_url
argument_list|,
name|new_parent_repos_root_url
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_relocate2
parameter_list|(
specifier|const
name|char
modifier|*
name|wcroot_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|from_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|to_prefix
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|validator_baton_t
name|vb
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_hash_t
modifier|*
name|externals_hash
init|=
name|NULL
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_repos_root_url
decl_stmt|,
modifier|*
name|new_repos_root_url
decl_stmt|;
comment|/* Populate our validator callback baton, and call the relocate code. */
name|vb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|vb
operator|.
name|path
operator|=
name|wcroot_dir
expr_stmt|;
name|vb
operator|.
name|url_uuids
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|url_uuid_t
argument_list|)
argument_list|)
expr_stmt|;
name|vb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|wcroot_dir
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|wcroot_dir
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|wcroot_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're ignoring externals, just relocate and get outta here. */
if|if
condition|(
name|ignore_externals
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc_relocate4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|from_prefix
argument_list|,
name|to_prefix
argument_list|,
name|validator_func
argument_list|,
operator|&
name|vb
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fetch our current root URL. */
name|SVN_ERR
argument_list|(
name|svn_client_get_repos_root
argument_list|(
operator|&
name|old_repos_root_url
argument_list|,
name|NULL
comment|/* uuid */
argument_list|,
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform the relocation. */
name|SVN_ERR
argument_list|(
name|svn_wc_relocate4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|from_prefix
argument_list|,
name|to_prefix
argument_list|,
name|validator_func
argument_list|,
operator|&
name|vb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now fetch new current root URL. */
name|SVN_ERR
argument_list|(
name|svn_client_get_repos_root
argument_list|(
operator|&
name|new_repos_root_url
argument_list|,
name|NULL
comment|/* uuid */
argument_list|,
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Relocate externals, too (if any). */
name|SVN_ERR
argument_list|(
name|svn_wc__externals_gather_definitions
argument_list|(
operator|&
name|externals_hash
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_hash_count
argument_list|(
name|externals_hash
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|externals_hash
argument_list|)
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|this_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|ext_desc
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_parse_externals_description3
argument_list|(
operator|&
name|ext_desc
argument_list|,
name|this_abspath
argument_list|,
name|value
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_desc
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|relocate_externals
argument_list|(
name|this_abspath
argument_list|,
name|ext_desc
argument_list|,
name|old_repos_root_url
argument_list|,
name|new_repos_root_url
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

