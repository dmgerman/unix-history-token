begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * repos_diff.c -- The diff editor for comparing two repository versions  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* This code uses an editor driven by a tree delta between two  * repository revisions (REV1 and REV2). For each file encountered in  * the delta the editor constructs two temporary files, one for each  * revision. This necessitates a separate request for the REV1 version  * of the file when the delta shows the file being modified or  * deleted. Files that are added by the delta do not require a  * separate request, the REV1 version is empty and the delta is  * sufficient to construct the REV2 version. When both versions of  * each file have been created the diff callback is invoked to display  * the difference between the two files.  */
end_comment

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_comment
comment|/* Overall crawler editor baton.  */
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
comment|/* The passed depth */
name|svn_depth_t
name|depth
decl_stmt|;
comment|/* The result processor */
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
decl_stmt|;
comment|/* RA_SESSION is the open session for making requests to the RA layer */
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
comment|/* The rev1 from the '-r Rev1:Rev2' command line option */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* The rev2 from the '-r Rev1:Rev2' option, specifically set by      set_target_revision(). */
name|svn_revnum_t
name|target_revision
decl_stmt|;
comment|/* The path to a temporary empty file used for add/delete      differences.  The path is cached here so that it can be reused,      since all empty files are the same. */
specifier|const
name|char
modifier|*
name|empty_file
decl_stmt|;
comment|/* Empty hash used for adds. */
name|apr_hash_t
modifier|*
name|empty_hash
decl_stmt|;
comment|/* Whether to report text deltas */
name|svn_boolean_t
name|text_deltas
decl_stmt|;
comment|/* A callback used to see if the client wishes to cancel the running      operation. */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
comment|/* A baton to pass to the cancellation callback. */
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|deleted_path_notify_t
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc_notify_action_t
name|action
decl_stmt|;
name|svn_wc_notify_state_t
name|state
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
block|}
name|deleted_path_notify_t
typedef|;
end_typedef

begin_comment
comment|/* Directory level baton.  */
end_comment

begin_struct
struct|struct
name|dir_baton
block|{
comment|/* Gets set if the directory is added rather than replaced/unchanged. */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* Gets set if this operation caused a tree-conflict on this directory    * (does not show tree-conflicts persisting from before this operation). */
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
comment|/* If TRUE, this node is skipped entirely.    * This is used to skip all children of a tree-conflicted    * directory without setting TREE_CONFLICTED to TRUE everywhere. */
name|svn_boolean_t
name|skip
decl_stmt|;
comment|/* If TRUE, all children of this directory are skipped. */
name|svn_boolean_t
name|skip_children
decl_stmt|;
comment|/* The path of the directory within the repository */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The baton for the parent directory, or null if this is the root of the      hierarchy to be compared. */
name|struct
name|dir_baton
modifier|*
name|parent_baton
decl_stmt|;
comment|/* The overall crawler editor baton. */
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
comment|/* A cache of any property changes (svn_prop_t) received for this dir. */
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
comment|/* Boolean indicating whether a node property was changed */
name|svn_boolean_t
name|has_propchange
decl_stmt|;
comment|/* Baton for svn_diff_tree_processor_t */
name|void
modifier|*
name|pdb
decl_stmt|;
name|svn_diff_source_t
modifier|*
name|left_source
decl_stmt|;
name|svn_diff_source_t
modifier|*
name|right_source
decl_stmt|;
comment|/* The pool passed in by add_dir, open_dir, or open_root.      Also, the pool this dir baton is allocated in. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Base revision of directory. */
name|svn_revnum_t
name|base_revision
decl_stmt|;
comment|/* Number of users of baton. Its pool will be destroyed 0 */
name|int
name|users
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* File level baton.  */
end_comment

begin_struct
struct|struct
name|file_baton
block|{
comment|/* Reference to parent baton */
name|struct
name|dir_baton
modifier|*
name|parent_baton
decl_stmt|;
comment|/* Gets set if the file is added rather than replaced. */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* Gets set if this operation caused a tree-conflict on this file    * (does not show tree-conflicts persisting from before this operation). */
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
comment|/* If TRUE, this node is skipped entirely.    * This is currently used to skip all children of a tree-conflicted    * directory. */
name|svn_boolean_t
name|skip
decl_stmt|;
comment|/* The path of the file within the repository */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The path and APR file handle to the temporary file that contains the      first repository version.  Also, the pristine-property list of      this file. */
specifier|const
name|char
modifier|*
name|path_start_revision
decl_stmt|;
name|apr_hash_t
modifier|*
name|pristine_props
decl_stmt|;
name|svn_revnum_t
name|base_revision
decl_stmt|;
comment|/* The path and APR file handle to the temporary file that contains the      second repository version.  These fields are set when processing      textdelta and file deletion, and will be NULL if there's no      textual difference between the two revisions. */
specifier|const
name|char
modifier|*
name|path_end_revision
decl_stmt|;
comment|/* APPLY_HANDLER/APPLY_BATON represent the delta application baton. */
name|svn_txdelta_window_handler_t
name|apply_handler
decl_stmt|;
name|void
modifier|*
name|apply_baton
decl_stmt|;
comment|/* The overall crawler editor baton. */
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
comment|/* Holds the checksum of the start revision file */
name|svn_checksum_t
modifier|*
name|start_md5_checksum
decl_stmt|;
comment|/* Holds the resulting md5 digest of a textdelta transform */
name|unsigned
name|char
name|result_digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|svn_checksum_t
modifier|*
name|result_md5_checksum
decl_stmt|;
comment|/* A cache of any property changes (svn_prop_t) received for this file. */
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
comment|/* Boolean indicating whether a node property was changed */
name|svn_boolean_t
name|has_propchange
decl_stmt|;
comment|/* Baton for svn_diff_tree_processor_t */
name|void
modifier|*
name|pfb
decl_stmt|;
name|svn_diff_source_t
modifier|*
name|left_source
decl_stmt|;
name|svn_diff_source_t
modifier|*
name|right_source
decl_stmt|;
comment|/* The pool passed in by add_file or open_file.      Also, the pool this file_baton is allocated in. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create a new directory baton for PATH in POOL.  ADDED is set if  * this directory is being added rather than replaced. PARENT_BATON is  * the baton of the parent directory (or NULL if this is the root of  * the comparison hierarchy). The directory and its parent may or may  * not exist in the working copy.  EDIT_BATON is the overall crawler  * editor baton.  */
end_comment

begin_function
specifier|static
name|struct
name|dir_baton
modifier|*
name|make_dir_baton
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|parent_baton
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|edit_baton
parameter_list|,
name|svn_boolean_t
name|added
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|dir_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|dir_baton
init|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dir_baton
argument_list|)
argument_list|)
decl_stmt|;
name|dir_baton
operator|->
name|parent_baton
operator|=
name|parent_baton
expr_stmt|;
name|dir_baton
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|dir_baton
operator|->
name|added
operator|=
name|added
expr_stmt|;
name|dir_baton
operator|->
name|tree_conflicted
operator|=
name|FALSE
expr_stmt|;
name|dir_baton
operator|->
name|skip
operator|=
name|FALSE
expr_stmt|;
name|dir_baton
operator|->
name|skip_children
operator|=
name|FALSE
expr_stmt|;
name|dir_baton
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|dir_baton
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|dir_pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|dir_baton
operator|->
name|propchanges
operator|=
name|apr_array_make
argument_list|(
name|dir_pool
argument_list|,
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
name|dir_baton
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
name|dir_baton
operator|->
name|users
operator|++
expr_stmt|;
if|if
condition|(
name|parent_baton
condition|)
name|parent_baton
operator|->
name|users
operator|++
expr_stmt|;
return|return
name|dir_baton
return|;
block|}
end_function

begin_comment
comment|/* New function. Called by everyone who has a reference when done */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|release_dir
parameter_list|(
name|struct
name|dir_baton
modifier|*
name|db
parameter_list|)
block|{
name|assert
argument_list|(
name|db
operator|->
name|users
operator|>
literal|0
argument_list|)
expr_stmt|;
name|db
operator|->
name|users
operator|--
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|users
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|db
operator|->
name|parent_baton
decl_stmt|;
name|svn_pool_destroy
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|release_dir
argument_list|(
name|pb
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a new file baton for PATH in POOL, which is a child of  * directory PARENT_PATH. ADDED is set if this file is being added  * rather than replaced.  EDIT_BATON is a pointer to the global edit  * baton.  */
end_comment

begin_function
specifier|static
name|struct
name|file_baton
modifier|*
name|make_file_baton
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|parent_baton
parameter_list|,
name|svn_boolean_t
name|added
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|file_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|file_baton
init|=
name|apr_pcalloc
argument_list|(
name|file_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file_baton
argument_list|)
argument_list|)
decl_stmt|;
name|file_baton
operator|->
name|parent_baton
operator|=
name|parent_baton
expr_stmt|;
name|file_baton
operator|->
name|edit_baton
operator|=
name|parent_baton
operator|->
name|edit_baton
expr_stmt|;
name|file_baton
operator|->
name|added
operator|=
name|added
expr_stmt|;
name|file_baton
operator|->
name|tree_conflicted
operator|=
name|FALSE
expr_stmt|;
name|file_baton
operator|->
name|skip
operator|=
name|FALSE
expr_stmt|;
name|file_baton
operator|->
name|pool
operator|=
name|file_pool
expr_stmt|;
name|file_baton
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|file_pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|file_baton
operator|->
name|propchanges
operator|=
name|apr_array_make
argument_list|(
name|file_pool
argument_list|,
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
name|file_baton
operator|->
name|base_revision
operator|=
name|parent_baton
operator|->
name|edit_baton
operator|->
name|revision
expr_stmt|;
name|parent_baton
operator|->
name|users
operator|++
expr_stmt|;
return|return
name|file_baton
return|;
block|}
end_function

begin_comment
comment|/* Get revision FB->base_revision of the file described by FB from the  * repository, through FB->edit_baton->ra_session.  *  * Unless PROPS_ONLY is true:  *   Set FB->path_start_revision to the path of a new temporary file containing  *   the file's text.  *   Set FB->start_md5_checksum to that file's MD-5 checksum.  *   Install a pool cleanup handler on FB->pool to delete the file.  *  * Always:  *   Set FB->pristine_props to a new hash containing the file's properties.  *  * Allocate all results in FB->pool.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_from_ra
parameter_list|(
name|struct
name|file_baton
modifier|*
name|fb
parameter_list|,
name|svn_boolean_t
name|props_only
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|props_only
condition|)
block|{
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fstream
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|path_start_revision
operator|)
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fstream
operator|=
name|svn_stream_checksummed2
argument_list|(
name|fstream
argument_list|,
name|NULL
argument_list|,
operator|&
name|fb
operator|->
name|start_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Retrieve the file and its properties */
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|fb
operator|->
name|edit_baton
operator|->
name|ra_session
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|fb
operator|->
name|base_revision
argument_list|,
name|fstream
argument_list|,
name|NULL
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|pristine_props
operator|)
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|fb
operator|->
name|edit_baton
operator|->
name|ra_session
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|fb
operator|->
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|pristine_props
operator|)
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove every no-op property change from CHANGES: that is, remove every    entry in which the target value is the same as the value of the    corresponding property in PRISTINE_PROPS.       Issue #3657 'dav update report handler in skelta mode can cause      spurious conflicts'.  When communicating with the repository via ra_serf,      the change_dir_prop and change_file_prop svn_delta_editor_t      callbacks are called (obviously) when a directory or file property has      changed between the start and end of the edit.  Less obvious however,      is that these callbacks may be made describing *all* of the properties      on FILE_BATON->PATH when using the DAV providers, not just the change(s).      (Specifically ra_serf does it for diff/merge/update/switch).       This means that the change_[file|dir]_prop svn_delta_editor_t callbacks      may be made where there are no property changes (i.e. a noop change of      NAME from VALUE to VALUE).  Normally this is harmless, but during a      merge it can result in spurious conflicts if the WC's pristine property      NAME has a value other than VALUE.  In an ideal world the mod_dav_svn      update report handler, when in 'skelta' mode and describing changes to      a path on which a property has changed, wouldn't ask the client to later      fetch all properties and figure out what has changed itself.  The server      already knows which properties have changed!       Regardless, such a change is not yet implemented, and even when it is,      the client should DTRT with regard to older servers which behave this      way.  Hence this little hack:  We populate FILE_BATON->PROPCHANGES only      with *actual* property changes.       See http://subversion.tigris.org/issues/show_bug.cgi?id=3657#desc9 and      http://svn.haxx.se/dev/archive-2010-08/0351.shtml for more details.  */
end_comment

begin_function
specifier|static
name|void
name|remove_non_prop_changes
parameter_list|(
name|apr_hash_t
modifier|*
name|pristine_props
parameter_list|,
name|apr_array_header_t
modifier|*
name|changes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changes
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_t
modifier|*
name|change
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|changes
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
operator|->
name|value
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|old_val
init|=
name|svn_hash_gets
argument_list|(
name|pristine_props
argument_list|,
name|change
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_val
operator|&&
name|svn_string_compare
argument_list|(
name|old_val
argument_list|,
name|change
operator|->
name|value
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Remove the matching change by shifting the rest */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|changes
operator|->
name|nelts
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|APR_ARRAY_IDX
argument_list|(
name|changes
argument_list|,
name|j
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|changes
argument_list|,
name|j
operator|+
literal|1
argument_list|,
name|svn_prop_t
argument_list|)
expr_stmt|;
block|}
name|changes
operator|->
name|nelts
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get the empty file associated with the edit baton. This is cached so  * that it can be reused, all empty files are the same.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_empty_file
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|empty_file_path
parameter_list|)
block|{
comment|/* Create the file if it does not exist */
comment|/* Note that we tried to use /dev/null in r857294, but      that won't work on Windows: it's impossible to stat NUL */
if|if
condition|(
operator|!
name|eb
operator|->
name|empty_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
operator|(
name|eb
operator|->
name|empty_file
operator|)
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|eb
operator|->
name|pool
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|empty_file_path
operator|=
name|eb
operator|->
name|empty_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|eb
operator|->
name|target_revision
operator|=
name|target_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. The root of the comparison hierarchy */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|make_dir_baton
argument_list|(
literal|""
argument_list|,
name|NULL
argument_list|,
name|eb
argument_list|,
name|FALSE
argument_list|,
name|base_revision
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|db
operator|->
name|left_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|revision
argument_list|,
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|db
operator|->
name|right_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|target_revision
argument_list|,
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_opened
argument_list|(
operator|&
name|db
operator|->
name|pdb
argument_list|,
operator|&
name|db
operator|->
name|skip
argument_list|,
operator|&
name|db
operator|->
name|skip_children
argument_list|,
literal|""
argument_list|,
name|db
operator|->
name|left_source
argument_list|,
name|db
operator|->
name|right_source
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|db
operator|->
name|pool
comment|/* scratch_pool */
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_baton
operator|=
name|db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compare a file being deleted against an empty file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|diff_deleted_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|make_file_baton
argument_list|(
name|path
argument_list|,
name|db
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|skip
init|=
name|FALSE
decl_stmt|;
name|svn_diff_source_t
modifier|*
name|left_source
init|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|revision
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|cancel_func
argument_list|(
name|eb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|file_opened
argument_list|(
operator|&
name|fb
operator|->
name|pfb
argument_list|,
operator|&
name|skip
argument_list|,
name|path
argument_list|,
name|left_source
argument_list|,
name|NULL
comment|/* right_source */
argument_list|,
name|NULL
comment|/* copyfrom_source */
argument_list|,
name|db
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|cancel_func
argument_list|(
name|eb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|get_file_from_ra
argument_list|(
name|fb
argument_list|,
operator|!
name|eb
operator|->
name|text_deltas
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|file_deleted
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|left_source
argument_list|,
name|fb
operator|->
name|path_start_revision
argument_list|,
name|fb
operator|->
name|pristine_props
argument_list|,
name|fb
operator|->
name|pfb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Recursively walk tree rooted at DIR (at EB->revision) in the repository,  * reporting all children as deleted.  Part of a workaround for issue 2333.  *  * DIR is a repository path relative to the URL in EB->ra_session.  EB is  * the overall crawler editor baton.  EB->revision must be a valid revision  * number, not SVN_INVALID_REVNUM.  Use EB->cancel_func (if not null) with  * EB->cancel_baton for cancellation.  */
end_comment

begin_comment
comment|/* ### TODO: Handle depth. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|diff_deleted_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|skip
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|skip_children
init|=
name|FALSE
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|left_props
init|=
name|NULL
decl_stmt|;
name|svn_diff_source_t
modifier|*
name|left_source
init|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|revision
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|db
operator|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|pb
operator|->
name|edit_baton
argument_list|,
name|FALSE
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|eb
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|cancel_func
argument_list|(
name|eb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_opened
argument_list|(
operator|&
name|db
operator|->
name|pdb
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|skip_children
argument_list|,
name|path
argument_list|,
name|left_source
argument_list|,
name|NULL
comment|/* right_source */
argument_list|,
name|NULL
comment|/* copyfrom_source */
argument_list|,
name|pb
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
operator|||
operator|!
name|skip_children
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|skip_children
condition|?
name|NULL
else|:
operator|&
name|dirents
argument_list|,
name|NULL
argument_list|,
name|skip
condition|?
name|NULL
else|:
operator|&
name|left_props
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|revision
argument_list|,
name|SVN_DIRENT_KIND
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The "old" dir will be skipped by the repository report.  If required,    * crawl it recursively, diffing each file against the empty file.  This    * is a workaround for issue 2333 "'svn diff URL1 URL2' not reverse of    * 'svn diff URL2 URL1'". */
if|if
condition|(
operator|!
name|skip_children
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|child_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_dirent_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_path
operator|=
name|svn_relpath_join
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|diff_deleted_file
argument_list|(
name|child_path
argument_list|,
name|db
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|diff_deleted_dir
argument_list|(
name|child_path
argument_list|,
name|db
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_deleted
argument_list|(
name|path
argument_list|,
name|left_source
argument_list|,
name|left_props
argument_list|,
name|db
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|release_dir
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
comment|/* Process skips. */
if|if
condition|(
name|pb
operator|->
name|skip_children
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* We need to know if this is a directory or a file */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|revision
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
block|{
name|SVN_ERR
argument_list|(
name|diff_deleted_file
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|svn_node_dir
case|:
block|{
name|SVN_ERR
argument_list|(
name|diff_deleted_dir
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
decl_stmt|;
comment|/* ### TODO: support copyfrom? */
name|db
operator|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|eb
argument_list|,
name|TRUE
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pb
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|db
expr_stmt|;
comment|/* Skip *everything* within a newly tree-conflicted directory,    * and directories the children of which should be skipped. */
if|if
condition|(
name|pb
operator|->
name|skip_children
condition|)
block|{
name|db
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|skip_children
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|db
operator|->
name|right_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|target_revision
argument_list|,
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_opened
argument_list|(
operator|&
name|db
operator|->
name|pdb
argument_list|,
operator|&
name|db
operator|->
name|skip
argument_list|,
operator|&
name|db
operator|->
name|skip_children
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|db
operator|->
name|right_source
argument_list|,
name|NULL
comment|/* copyfrom_source */
argument_list|,
name|pb
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|eb
argument_list|,
name|FALSE
argument_list|,
name|base_revision
argument_list|,
name|pb
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|db
expr_stmt|;
comment|/* Process Skips. */
if|if
condition|(
name|pb
operator|->
name|skip_children
condition|)
block|{
name|db
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|skip_children
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|db
operator|->
name|left_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|revision
argument_list|,
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|db
operator|->
name|right_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|target_revision
argument_list|,
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_opened
argument_list|(
operator|&
name|db
operator|->
name|pdb
argument_list|,
operator|&
name|db
operator|->
name|skip
argument_list|,
operator|&
name|db
operator|->
name|skip_children
argument_list|,
name|path
argument_list|,
name|db
operator|->
name|left_source
argument_list|,
name|db
operator|->
name|right_source
argument_list|,
name|NULL
comment|/* copyfrom */
argument_list|,
name|pb
condition|?
name|pb
operator|->
name|pdb
else|:
name|NULL
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
comment|/* ### TODO: support copyfrom? */
name|fb
operator|=
name|make_file_baton
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|TRUE
argument_list|,
name|pb
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
comment|/* Process Skips. */
if|if
condition|(
name|pb
operator|->
name|skip_children
condition|)
block|{
name|fb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|fb
operator|->
name|pristine_props
operator|=
name|pb
operator|->
name|edit_baton
operator|->
name|empty_hash
expr_stmt|;
name|fb
operator|->
name|right_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|target_revision
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|file_opened
argument_list|(
operator|&
name|fb
operator|->
name|pfb
argument_list|,
operator|&
name|fb
operator|->
name|skip
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|fb
operator|->
name|right_source
argument_list|,
name|NULL
comment|/* copy source */
argument_list|,
name|pb
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|fb
operator|=
name|make_file_baton
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|FALSE
argument_list|,
name|pb
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
comment|/* Process Skips. */
if|if
condition|(
name|pb
operator|->
name|skip_children
condition|)
block|{
name|fb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|fb
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
name|fb
operator|->
name|left_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|revision
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|fb
operator|->
name|right_source
operator|=
name|svn_diff__source_create
argument_list|(
name|eb
operator|->
name|target_revision
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|file_opened
argument_list|(
operator|&
name|fb
operator|->
name|pfb
argument_list|,
operator|&
name|fb
operator|->
name|skip
argument_list|,
name|path
argument_list|,
name|fb
operator|->
name|left_source
argument_list|,
name|fb
operator|->
name|right_source
argument_list|,
name|NULL
comment|/* copy source */
argument_list|,
name|pb
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Do the work of applying the text delta.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|window_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|window_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|fb
operator|->
name|apply_handler
argument_list|(
name|window
argument_list|,
name|fb
operator|->
name|apply_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
block|{
name|fb
operator|->
name|result_md5_checksum
operator|=
name|svn_checksum__from_digest_md5
argument_list|(
name|fb
operator|->
name|result_digest
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_lazyopen_func_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lazy_open_source
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
name|stream
argument_list|,
name|fb
operator|->
name|path_start_revision
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_lazyopen_func_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lazy_open_result
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
name|stream
argument_list|,
operator|&
name|fb
operator|->
name|path_end_revision
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_md5_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|src_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|result_stream
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|fb
operator|->
name|pool
decl_stmt|;
comment|/* Skip *everything* within a newly tree-conflicted directory. */
if|if
condition|(
name|fb
operator|->
name|skip
condition|)
block|{
operator|*
name|handler
operator|=
name|svn_delta_noop_window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we're not sending file text, then ignore any that we receive. */
if|if
condition|(
operator|!
name|fb
operator|->
name|edit_baton
operator|->
name|text_deltas
condition|)
block|{
comment|/* Supply valid paths to indicate there is a text change. */
name|SVN_ERR
argument_list|(
name|get_empty_file
argument_list|(
name|fb
operator|->
name|edit_baton
argument_list|,
operator|&
name|fb
operator|->
name|path_start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_empty_file
argument_list|(
name|fb
operator|->
name|edit_baton
argument_list|,
operator|&
name|fb
operator|->
name|path_end_revision
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|handler
operator|=
name|svn_delta_noop_window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We need the expected pristine file, so go get it */
if|if
condition|(
operator|!
name|fb
operator|->
name|added
condition|)
name|SVN_ERR
argument_list|(
name|get_file_from_ra
argument_list|(
name|fb
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|get_empty_file
argument_list|(
name|fb
operator|->
name|edit_baton
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|path_start_revision
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|fb
operator|->
name|path_start_revision
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_md5_digest
operator|!=
name|NULL
condition|)
block|{
name|svn_checksum_t
modifier|*
name|base_md5_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|base_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|base_md5_digest
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|base_md5_checksum
argument_list|,
name|fb
operator|->
name|start_md5_checksum
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_checksum_mismatch_err
argument_list|(
name|base_md5_checksum
argument_list|,
name|fb
operator|->
name|start_md5_checksum
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Base checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|fb
operator|->
name|path
argument_list|)
argument_list|)
return|;
block|}
comment|/* Open the file to be used as the base for second revision */
name|src_stream
operator|=
name|svn_stream_lazyopen_create
argument_list|(
name|lazy_open_source
argument_list|,
name|fb
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Open the file that will become the second revision after applying the      text delta, it starts empty */
name|result_stream
operator|=
name|svn_stream_lazyopen_create
argument_list|(
name|lazy_open_result
argument_list|,
name|fb
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_txdelta_apply
argument_list|(
name|src_stream
argument_list|,
name|result_stream
argument_list|,
name|fb
operator|->
name|result_digest
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|apply_handler
operator|)
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|apply_baton
operator|)
argument_list|)
expr_stmt|;
operator|*
name|handler
operator|=
name|window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|file_baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  When the file is closed we have a temporary  * file containing a pristine version of the repository file. This can  * be compared against the working copy.  *  * ### Ignore TEXT_CHECKSUM for now.  Someday we can use it to verify  * ### the integrity of the file being diffed.  Done efficiently, this  * ### would probably involve calculating the checksum as the data is  * ### received, storing the final checksum in the file_baton, and  * ### comparing against it here.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|expected_md5_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|fb
operator|->
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
comment|/* Skip *everything* within a newly tree-conflicted directory. */
if|if
condition|(
name|fb
operator|->
name|skip
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|release_dir
argument_list|(
name|pb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|scratch_pool
operator|=
name|fb
operator|->
name|pool
expr_stmt|;
if|if
condition|(
name|expected_md5_digest
operator|&&
name|eb
operator|->
name|text_deltas
condition|)
block|{
name|svn_checksum_t
modifier|*
name|expected_md5_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|expected_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|expected_md5_digest
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|expected_md5_checksum
argument_list|,
name|fb
operator|->
name|result_md5_checksum
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_checksum_mismatch_err
argument_list|(
name|expected_md5_checksum
argument_list|,
name|fb
operator|->
name|result_md5_checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|fb
operator|->
name|path
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|fb
operator|->
name|added
operator|||
name|fb
operator|->
name|path_end_revision
operator|||
name|fb
operator|->
name|has_propchange
condition|)
block|{
name|apr_hash_t
modifier|*
name|right_props
decl_stmt|;
if|if
condition|(
operator|!
name|fb
operator|->
name|added
operator|&&
operator|!
name|fb
operator|->
name|pristine_props
condition|)
block|{
comment|/* We didn't receive a text change, so we have no pristine props.              Retrieve just the props now. */
name|SVN_ERR
argument_list|(
name|get_file_from_ra
argument_list|(
name|fb
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fb
operator|->
name|pristine_props
condition|)
name|remove_non_prop_changes
argument_list|(
name|fb
operator|->
name|pristine_props
argument_list|,
name|fb
operator|->
name|propchanges
argument_list|)
expr_stmt|;
name|right_props
operator|=
name|svn_prop__patch
argument_list|(
name|fb
operator|->
name|pristine_props
argument_list|,
name|fb
operator|->
name|propchanges
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|added
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|file_added
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|NULL
comment|/* copyfrom_src */
argument_list|,
name|fb
operator|->
name|right_source
argument_list|,
name|NULL
comment|/* copyfrom_file */
argument_list|,
name|fb
operator|->
name|path_end_revision
argument_list|,
name|NULL
comment|/* copyfrom_props */
argument_list|,
name|right_props
argument_list|,
name|fb
operator|->
name|pfb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|file_changed
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|fb
operator|->
name|left_source
argument_list|,
name|fb
operator|->
name|right_source
argument_list|,
name|fb
operator|->
name|path_end_revision
condition|?
name|fb
operator|->
name|path_start_revision
else|:
name|NULL
argument_list|,
name|fb
operator|->
name|path_end_revision
argument_list|,
name|fb
operator|->
name|pristine_props
argument_list|,
name|right_props
argument_list|,
operator|(
name|fb
operator|->
name|path_end_revision
operator|!=
name|NULL
operator|)
argument_list|,
name|fb
operator|->
name|propchanges
argument_list|,
name|fb
operator|->
name|pfb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Destroy file and scratch pool */
name|SVN_ERR
argument_list|(
name|release_dir
argument_list|(
name|pb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Report any accumulated prop changes via the 'dir_props_changed' callback,  * and then call the 'dir_closed' callback.  Notify about any deleted paths  * within this directory that have not already been notified, and then about  * this directory itself (unless it was added, in which case the notification  * was done at that time).  *  * An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|pristine_props
decl_stmt|;
name|svn_boolean_t
name|send_changed
init|=
name|FALSE
decl_stmt|;
name|scratch_pool
operator|=
name|db
operator|->
name|pool
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|->
name|has_propchange
operator|||
name|db
operator|->
name|added
operator|)
operator|&&
operator|!
name|db
operator|->
name|skip
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|added
condition|)
block|{
name|pristine_props
operator|=
name|eb
operator|->
name|empty_hash
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pristine_props
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|db
operator|->
name|base_revision
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|->
name|propchanges
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|remove_non_prop_changes
argument_list|(
name|pristine_props
argument_list|,
name|db
operator|->
name|propchanges
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|->
name|propchanges
operator|->
name|nelts
operator|>
literal|0
operator|||
name|db
operator|->
name|added
condition|)
block|{
name|apr_hash_t
modifier|*
name|right_props
decl_stmt|;
name|right_props
operator|=
name|svn_prop__patch
argument_list|(
name|pristine_props
argument_list|,
name|db
operator|->
name|propchanges
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|added
condition|)
block|{
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_added
argument_list|(
name|db
operator|->
name|path
argument_list|,
name|NULL
comment|/* copyfrom */
argument_list|,
name|db
operator|->
name|right_source
argument_list|,
name|NULL
comment|/* copyfrom props */
argument_list|,
name|right_props
argument_list|,
name|db
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_changed
argument_list|(
name|db
operator|->
name|path
argument_list|,
name|db
operator|->
name|left_source
argument_list|,
name|db
operator|->
name|right_source
argument_list|,
name|pristine_props
argument_list|,
name|right_props
argument_list|,
name|db
operator|->
name|propchanges
argument_list|,
name|db
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|send_changed
operator|=
name|TRUE
expr_stmt|;
comment|/* Skip dir_closed */
block|}
block|}
if|if
condition|(
operator|!
name|db
operator|->
name|skip
operator|&&
operator|!
name|send_changed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|dir_closed
argument_list|(
name|db
operator|->
name|path
argument_list|,
name|db
operator|->
name|left_source
argument_list|,
name|db
operator|->
name|right_source
argument_list|,
name|db
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|release_dir
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Record a prop change, which we will report later in close_file().  *  * An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|svn_prop_t
modifier|*
name|propchange
decl_stmt|;
name|svn_prop_kind_t
name|propkind
decl_stmt|;
comment|/* Skip *everything* within a newly tree-conflicted directory. */
if|if
condition|(
name|fb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|propkind
operator|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|propkind
operator|==
name|svn_prop_wc_kind
condition|)
return|return
name|SVN_NO_ERROR
return|;
elseif|else
if|if
condition|(
name|propkind
operator|==
name|svn_prop_regular_kind
condition|)
name|fb
operator|->
name|has_propchange
operator|=
name|TRUE
expr_stmt|;
name|propchange
operator|=
name|apr_array_push
argument_list|(
name|fb
operator|->
name|propchanges
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|value
operator|=
name|value
condition|?
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make a note of this prop change, to be reported when the dir is closed.  *  * An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|svn_prop_t
modifier|*
name|propchange
decl_stmt|;
name|svn_prop_kind_t
name|propkind
decl_stmt|;
comment|/* Skip *everything* within a newly tree-conflicted directory. */
if|if
condition|(
name|db
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|propkind
operator|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|propkind
operator|==
name|svn_prop_wc_kind
condition|)
return|return
name|SVN_NO_ERROR
return|;
elseif|else
if|if
condition|(
name|propkind
operator|==
name|svn_prop_regular_kind
condition|)
name|db
operator|->
name|has_propchange
operator|=
name|TRUE
expr_stmt|;
name|propchange
operator|=
name|apr_array_push
argument_list|(
name|db
operator|->
name|propchanges
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|value
operator|=
name|value
condition|?
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|db
operator|->
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|svn_pool_destroy
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Notify that the node at PATH is 'missing'.  * An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|node_absent
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Notify that the node at PATH is 'missing'.  * An svn_delta_editor_t function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|processor
operator|->
name|node_absent
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|pdb
argument_list|,
name|eb
operator|->
name|processor
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|tmp_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
literal|0
comment|/* Dirent fields */
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_props
operator|=
name|svn_prop_hash_to_array
argument_list|(
operator|*
name|props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|tmp_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fstream
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_file
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|fstream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a repository diff editor and baton.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_diff_editor2
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|editor_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|tree_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|editor_pool
argument_list|)
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|editor_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|editor_pool
argument_list|)
decl_stmt|;
name|eb
operator|->
name|pool
operator|=
name|editor_pool
expr_stmt|;
name|eb
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|eb
operator|->
name|processor
operator|=
name|processor
expr_stmt|;
name|eb
operator|->
name|ra_session
operator|=
name|ra_session
expr_stmt|;
name|eb
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|eb
operator|->
name|empty_file
operator|=
name|NULL
expr_stmt|;
name|eb
operator|->
name|empty_hash
operator|=
name|apr_hash_make
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|text_deltas
operator|=
name|text_deltas
expr_stmt|;
name|eb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|eb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|tree_editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|tree_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|tree_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|tree_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|tree_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|tree_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|tree_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|tree_editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|tree_editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|tree_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|tree_editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|tree_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
name|tree_editor
operator|->
name|absent_directory
operator|=
name|absent_directory
expr_stmt|;
name|tree_editor
operator|->
name|absent_file
operator|=
name|absent_file
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|tree_editor
argument_list|,
name|eb
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_baton
operator|=
name|eb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|shim_callbacks
argument_list|,
name|result_pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

