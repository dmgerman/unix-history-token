begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * patch.c: patch application support  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_fnmatch.h>
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_eol_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|hunk_info_t
block|{
comment|/* The hunk. */
name|svn_diff_hunk_t
modifier|*
name|hunk
decl_stmt|;
comment|/* The line where the hunk matched in the target file. */
name|svn_linenum_t
name|matched_line
decl_stmt|;
comment|/* Whether this hunk has been rejected. */
name|svn_boolean_t
name|rejected
decl_stmt|;
comment|/* Whether this hunk has already been applied (either manually    * or by an earlier run of patch). */
name|svn_boolean_t
name|already_applied
decl_stmt|;
comment|/* The fuzz factor used when matching this hunk, i.e. how many    * lines of leading and trailing context to ignore during matching. */
name|svn_linenum_t
name|fuzz
decl_stmt|;
block|}
name|hunk_info_t
typedef|;
end_typedef

begin_comment
comment|/* A struct carrying information related to the patched and unpatched  * content of a target, be it a property or the text of a file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|target_content_t
block|{
comment|/* Indicates whether unpatched content existed prior to patching. */
name|svn_boolean_t
name|existed
decl_stmt|;
comment|/* The line last read from the unpatched content. */
name|svn_linenum_t
name|current_line
decl_stmt|;
comment|/* The EOL-style of the unpatched content. Either 'none', 'fixed',    * or 'native'. See the documentation of svn_subst_eol_style_t. */
name|svn_subst_eol_style_t
name|eol_style
decl_stmt|;
comment|/* If the EOL_STYLE above is not 'none', this is the EOL string    * corresponding to the EOL-style. Else, it is the EOL string the    * last line read from the target file was using. */
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
comment|/* An array containing apr_off_t offsets marking the beginning of    * each line in the unpatched content. */
name|apr_array_header_t
modifier|*
name|lines
decl_stmt|;
comment|/* An array containing hunk_info_t structures for hunks already matched. */
name|apr_array_header_t
modifier|*
name|hunks
decl_stmt|;
comment|/* True if end-of-file was reached while reading from the unpatched    * content. */
name|svn_boolean_t
name|eof
decl_stmt|;
comment|/* The keywords of the target. They will be contracted when reading    * unpatched content and expanded when writing patched content.    * When patching properties this hash is always empty. */
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
comment|/* A callback, with an associated baton, to read a line of unpatched    * content. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|readline
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
name|void
modifier|*
name|read_baton
decl_stmt|;
comment|/* A callback to get the current byte offset within the unpatched    * content. Uses the read baton. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|tell
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* A callback to seek to an offset within the unpatched content.    * Uses the read baton. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|seek
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* A callback to write data to the patched content, with an    * associated baton. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|write
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
name|void
modifier|*
name|write_baton
decl_stmt|;
block|}
name|target_content_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|prop_patch_target_t
block|{
comment|/* The name of the property */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The property value. This is NULL in case the property did not exist    * prior to patch application (see also CONTENT->existed).    * Note that the patch implementation does not support binary properties,    * so this string is not expected to contain embedded NUL characters. */
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
comment|/* The patched property value.    * This is equivalent to the target, except that in appropriate    * places it contains the modified text as it appears in the patch file. */
name|svn_stringbuf_t
modifier|*
name|patched_value
decl_stmt|;
comment|/* All information that is specific to the content of the property. */
name|target_content_t
modifier|*
name|content
decl_stmt|;
comment|/* Represents the operation performed on the property. It can be added,    * deleted or modified.    * ### Should we use flags instead since we're not using all enum values? */
name|svn_diff_operation_kind_t
name|operation
decl_stmt|;
comment|/* ### Here we'll add flags telling if the prop was added, deleted,    * ### had_rejects, had_local_mods prior to patching and so on. */
block|}
name|prop_patch_target_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|patch_target_t
block|{
comment|/* The target path as it appeared in the patch file,    * but in canonicalised form. */
specifier|const
name|char
modifier|*
name|canon_path_from_patchfile
decl_stmt|;
comment|/* The target path, relative to the working copy directory the    * patch is being applied to. A patch strip count applies to this    * and only this path. This is never NULL. */
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
comment|/* The absolute path of the target on the filesystem.    * Any symlinks the path from the patch file may contain are resolved.    * Is not always known, so it may be NULL. */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* The target file, read-only. This is NULL in case the target    * file did not exist prior to patch application (see also    * CONTENT->existed). */
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* The target file is a symlink */
name|svn_boolean_t
name|is_symlink
decl_stmt|;
comment|/* The patched file.    * This is equivalent to the target, except that in appropriate    * places it contains the modified text as it appears in the patch file.    * The data in this file is written in repository-normal form.    * EOL transformation and keyword contraction is performed when the    * patched result is installed in the working copy. */
name|apr_file_t
modifier|*
name|patched_file
decl_stmt|;
comment|/* Path to the patched file. */
specifier|const
name|char
modifier|*
name|patched_path
decl_stmt|;
comment|/* Hunks that are rejected will be written to this file. */
name|apr_file_t
modifier|*
name|reject_file
decl_stmt|;
comment|/* Path to the reject file. */
specifier|const
name|char
modifier|*
name|reject_path
decl_stmt|;
comment|/* The node kind of the target as found in WC-DB prior    * to patch application. */
name|svn_node_kind_t
name|db_kind
decl_stmt|;
comment|/* The target's kind on disk prior to patch application. */
name|svn_node_kind_t
name|kind_on_disk
decl_stmt|;
comment|/* True if the target was locally deleted prior to patching. */
name|svn_boolean_t
name|locally_deleted
decl_stmt|;
comment|/* True if the target had to be skipped for some reason. */
name|svn_boolean_t
name|skipped
decl_stmt|;
comment|/* True if the target has been filtered by the patch callback. */
name|svn_boolean_t
name|filtered
decl_stmt|;
comment|/* True if at least one hunk was rejected. */
name|svn_boolean_t
name|had_rejects
decl_stmt|;
comment|/* True if at least one property hunk was rejected. */
name|svn_boolean_t
name|had_prop_rejects
decl_stmt|;
comment|/* True if the target file had local modifications before the    * patch was applied to it. */
name|svn_boolean_t
name|local_mods
decl_stmt|;
comment|/* True if the target was added by the patch, which means that it did    * not exist on disk before patching and has content after patching. */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* True if the target ended up being deleted by the patch. */
name|svn_boolean_t
name|deleted
decl_stmt|;
comment|/* True if the target ended up being replaced by the patch    * (i.e. a new file was added on top locally deleted node). */
name|svn_boolean_t
name|replaced
decl_stmt|;
comment|/* True if the target has the executable bit set. */
name|svn_boolean_t
name|executable
decl_stmt|;
comment|/* True if the patch changed the text of the target. */
name|svn_boolean_t
name|has_text_changes
decl_stmt|;
comment|/* True if the patch changed any of the properties of the target. */
name|svn_boolean_t
name|has_prop_changes
decl_stmt|;
comment|/* True if the patch contained a svn:special property. */
name|svn_boolean_t
name|is_special
decl_stmt|;
comment|/* All the information that is specific to the content of the target. */
name|target_content_t
modifier|*
name|content
decl_stmt|;
comment|/* A hash table of prop_patch_target_t objects keyed by property names. */
name|apr_hash_t
modifier|*
name|prop_targets
decl_stmt|;
block|}
name|patch_target_t
typedef|;
end_typedef

begin_comment
comment|/* A smaller struct containing a subset of patch_target_t.  * Carries the minimal amount of information we still need for a  * target after we're done patching it so we can free other resources. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|patch_target_info_t
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_boolean_t
name|deleted
decl_stmt|;
block|}
name|patch_target_info_t
typedef|;
end_typedef

begin_comment
comment|/* Strip STRIP_COUNT components from the front of PATH, returning  * the result in *RESULT, allocated in RESULT_POOL.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|strip_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|components
decl_stmt|;
name|apr_array_header_t
modifier|*
name|stripped
decl_stmt|;
name|components
operator|=
name|svn_path_decompose
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_count
operator|>
name|components
operator|->
name|nelts
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot strip %u components from '%s'"
argument_list|)
argument_list|,
name|strip_count
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|stripped
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|components
operator|->
name|nelts
operator|-
name|strip_count
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strip_count
init|;
name|i
operator|<
name|components
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|stripped
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|component
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|svn_path_compose
argument_list|(
name|stripped
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Obtain KEYWORDS, EOL_STYLE and EOL_STR for LOCAL_ABSPATH.  * WC_CTX is a context for the working copy the patch is applied to.  * Use RESULT_POOL for allocations of fields in TARGET.  * Use SCRATCH_POOL for all other allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|obtain_eol_and_keywords_for_file
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|keywords
parameter_list|,
name|svn_subst_eol_style_t
modifier|*
name|eol_style
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_string_t
modifier|*
name|keywords_val
decl_stmt|,
modifier|*
name|eol_style_val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_prop_list2
argument_list|(
operator|&
name|props
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|keywords_val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|keywords_val
condition|)
block|{
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_changed_info
argument_list|(
operator|&
name|changed_rev
argument_list|,
operator|&
name|changed_date
argument_list|,
operator|&
name|author
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rev_str
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|changed_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_url
argument_list|(
operator|&
name|url
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|root_url
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_build_keywords3
argument_list|(
name|keywords
argument_list|,
name|keywords_val
operator|->
name|data
argument_list|,
name|rev_str
argument_list|,
name|url
argument_list|,
name|root_url
argument_list|,
name|changed_date
argument_list|,
name|author
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|eol_style_val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_style_val
condition|)
block|{
name|svn_subst_eol_style_from_value
argument_list|(
name|eol_style
argument_list|,
name|eol_str
argument_list|,
name|eol_style_val
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Resolve the exact path for a patch TARGET at path PATH_FROM_PATCHFILE,  * which is the path of the target as it appeared in the patch file.  * Put a canonicalized version of PATH_FROM_PATCHFILE into  * TARGET->CANON_PATH_FROM_PATCHFILE.  * WC_CTX is a context for the working copy the patch is applied to.  * If possible, determine TARGET->WC_PATH, TARGET->ABS_PATH, TARGET->KIND,  * TARGET->ADDED, and TARGET->PARENT_DIR_EXISTS.  * Indicate in TARGET->SKIPPED whether the target should be skipped.  * STRIP_COUNT specifies the number of leading path components  * which should be stripped from target paths in the patch.  * PROP_CHANGES_ONLY specifies whether the target path is allowed to have  * only property changes, and no content changes (in which case the target  * must be a directory).  * Use RESULT_POOL for allocations of fields in TARGET.  * Use SCRATCH_POOL for all other allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_target_path
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|path_from_patchfile
parameter_list|,
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|prop_changes_only
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|stripped_path
decl_stmt|;
name|svn_wc_status3_t
modifier|*
name|status
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|under_root
decl_stmt|;
name|target
operator|->
name|canon_path_from_patchfile
operator|=
name|svn_dirent_internal_style
argument_list|(
name|path_from_patchfile
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* We allow properties to be set on the wc root dir. */
if|if
condition|(
operator|!
name|prop_changes_only
operator|&&
name|target
operator|->
name|canon_path_from_patchfile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* An empty patch target path? What gives? Skip this. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
name|target
operator|->
name|local_relpath
operator|=
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strip_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|strip_path
argument_list|(
operator|&
name|stripped_path
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|strip_count
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stripped_path
operator|=
name|target
operator|->
name|canon_path_from_patchfile
expr_stmt|;
if|if
condition|(
name|svn_dirent_is_absolute
argument_list|(
name|stripped_path
argument_list|)
condition|)
block|{
name|target
operator|->
name|local_relpath
operator|=
name|svn_dirent_is_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|stripped_path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|local_relpath
condition|)
block|{
comment|/* The target path is either outside of the working copy            * or it is the working copy itself. Skip it. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
name|target
operator|->
name|local_relpath
operator|=
name|stripped_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
name|target
operator|->
name|local_relpath
operator|=
name|stripped_path
expr_stmt|;
block|}
comment|/* Make sure the path is secure to use. We want the target to be inside    * of the working copy and not be fooled by symlinks it might contain. */
name|SVN_ERR
argument_list|(
name|svn_dirent_is_under_root
argument_list|(
operator|&
name|under_root
argument_list|,
operator|&
name|target
operator|->
name|local_abspath
argument_list|,
name|wcroot_abspath
argument_list|,
name|target
operator|->
name|local_relpath
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|under_root
condition|)
block|{
comment|/* The target path is outside of the working copy. Skip it. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Skip things we should not be messing with. */
name|err
operator|=
name|svn_wc_status3
argument_list|(
operator|&
name|status
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|target
operator|->
name|locally_deleted
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|db_kind
operator|=
name|svn_node_none
expr_stmt|;
name|status
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_ignored
operator|||
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_unversioned
operator|||
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_missing
operator|||
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_obstructed
operator|||
name|status
operator|->
name|conflicted
condition|)
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_deleted
condition|)
block|{
name|target
operator|->
name|locally_deleted
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&&
operator|(
name|status
operator|->
name|kind
operator|!=
name|svn_node_unknown
operator|)
condition|)
name|target
operator|->
name|db_kind
operator|=
name|status
operator|->
name|kind
expr_stmt|;
else|else
name|target
operator|->
name|db_kind
operator|=
name|svn_node_none
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
operator|&
name|target
operator|->
name|kind_on_disk
argument_list|,
operator|&
name|target
operator|->
name|is_symlink
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|locally_deleted
condition|)
block|{
specifier|const
name|char
modifier|*
name|moved_to_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_was_moved_away
argument_list|(
operator|&
name|moved_to_abspath
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_to_abspath
condition|)
block|{
name|target
operator|->
name|local_abspath
operator|=
name|moved_to_abspath
expr_stmt|;
name|target
operator|->
name|local_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|wcroot_abspath
argument_list|,
name|moved_to_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|target
operator|->
name|local_relpath
operator|&&
name|target
operator|->
name|local_relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* As far as we are concerned this target is not locally deleted. */
name|target
operator|->
name|locally_deleted
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
operator|&
name|target
operator|->
name|kind_on_disk
argument_list|,
operator|&
name|target
operator|->
name|is_symlink
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|!=
name|svn_node_none
condition|)
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for reading from properties. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|prop_read_baton_t
block|{
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
block|}
name|prop_read_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Allocate *STRINGBUF in RESULT_POOL, and read into it one line from  * the unpatched property value accessed via BATON.  * Reading stops either after a line-terminator was found, or if  * the property value runs out in which case *EOF is set to TRUE.  * The line-terminator is not stored in *STRINGBUF.  *  * If the line is empty or could not be read, *line is set to NULL.  *  * The line-terminator is detected automatically and stored in *EOL  * if EOL is not NULL. If the end of the property value is reached  * and does not end with a newline character, and EOL is not NULL,  * *EOL is set to NULL.  *  * SCRATCH_POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_read_baton_t
modifier|*
name|b
init|=
operator|(
name|prop_read_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|svn_boolean_t
name|found_eof
decl_stmt|;
if|if
condition|(
operator|(
name|apr_uint64_t
operator|)
name|b
operator|->
name|offset
operator|>=
operator|(
name|apr_uint64_t
operator|)
name|b
operator|->
name|value
operator|->
name|len
condition|)
block|{
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Read bytes into STR up to and including, but not storing,    * the next EOL sequence. */
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|c
operator|=
name|b
operator|->
name|value
operator|->
name|data
operator|+
name|b
operator|->
name|offset
expr_stmt|;
name|b
operator|->
name|offset
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|found_eof
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r"
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|c
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r\n"
expr_stmt|;
name|b
operator|->
name|offset
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|80
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|eol_str
condition|)
break|break;
block|}
do|while
condition|(
name|c
operator|<
name|b
operator|->
name|value
operator|->
name|data
operator|+
name|b
operator|->
name|value
operator|->
name|len
condition|)
do|;
if|if
condition|(
name|eof
condition|)
operator|*
name|eof
operator|=
name|found_eof
expr_stmt|;
operator|*
name|line
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return in *OFFSET the current byte offset for reading from the  * unpatched property value accessed via BATON.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tell_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_read_baton_t
modifier|*
name|b
init|=
operator|(
name|prop_read_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
operator|*
name|offset
operator|=
name|b
operator|->
name|offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Seek to the specified by OFFSET in the unpatched property value accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_read_baton_t
modifier|*
name|b
init|=
operator|(
name|prop_read_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|b
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes from BUF into the patched property value accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|patched_value
init|=
operator|(
name|svn_stringbuf_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|patched_value
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Initialize a PROP_TARGET structure for PROP_NAME on the patch target  * at LOCAL_ABSPATH. OPERATION indicates the operation performed on the  * property. Use working copy context WC_CTX.  * Allocate results in RESULT_POOL.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_prop_target
parameter_list|(
name|prop_patch_target_t
modifier|*
modifier|*
name|prop_target
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|svn_diff_operation_kind_t
name|operation
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_patch_target_t
modifier|*
name|new_prop_target
decl_stmt|;
name|target_content_t
modifier|*
name|content
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|prop_read_baton_t
modifier|*
name|prop_read_baton
decl_stmt|;
name|content
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|content
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All other fields are FALSE or NULL due to apr_pcalloc(). */
name|content
operator|->
name|current_line
operator|=
literal|1
expr_stmt|;
name|content
operator|->
name|eol_style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
name|content
operator|->
name|lines
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|hunks
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hunk_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|keywords
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|new_prop_target
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_prop_target
argument_list|)
argument_list|)
expr_stmt|;
name|new_prop_target
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
name|new_prop_target
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|new_prop_target
operator|->
name|content
operator|=
name|content
expr_stmt|;
name|err
operator|=
name|svn_wc_prop_get2
argument_list|(
operator|&
name|value
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|prop_name
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|content
operator|->
name|existed
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
expr_stmt|;
name|new_prop_target
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|new_prop_target
operator|->
name|patched_value
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Wire up the read and write callbacks. */
name|prop_read_baton
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop_read_baton
argument_list|)
argument_list|)
expr_stmt|;
name|prop_read_baton
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|prop_read_baton
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|content
operator|->
name|readline
operator|=
name|readline_prop
expr_stmt|;
name|content
operator|->
name|tell
operator|=
name|tell_prop
expr_stmt|;
name|content
operator|->
name|seek
operator|=
name|seek_prop
expr_stmt|;
name|content
operator|->
name|read_baton
operator|=
name|prop_read_baton
expr_stmt|;
name|content
operator|->
name|write
operator|=
name|write_prop
expr_stmt|;
name|content
operator|->
name|write_baton
operator|=
name|new_prop_target
operator|->
name|patched_value
expr_stmt|;
operator|*
name|prop_target
operator|=
name|new_prop_target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate *STRINGBUF in RESULT_POOL, and read into it one line from  * the unpatched file content accessed via BATON.  * Reading stops either after a line-terminator was found,  * or if EOF is reached in which case *EOF is set to TRUE.  * The line-terminator is not stored in *STRINGBUF.  *  * If the line is empty or could not be read, *line is set to NULL.  *  * The line-terminator is detected automatically and stored in *EOL  * if EOL is not NULL. If EOF is reached and FILE does not end  * with a newline character, and EOL is not NULL, *EOL is set to NULL.  *  * SCRATCH_POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|numbytes
decl_stmt|;
name|char
name|c
decl_stmt|;
name|svn_boolean_t
name|found_eof
decl_stmt|;
comment|/* Read bytes into STR up to and including, but not storing,    * the next EOL sequence. */
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
name|numbytes
operator|=
literal|1
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|found_eof
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|numbytes
argument_list|,
operator|&
name|found_eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbytes
operator|!=
literal|1
condition|)
block|{
name|found_eof
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r"
expr_stmt|;
if|if
condition|(
operator|!
name|found_eof
condition|)
block|{
name|apr_off_t
name|pos
decl_stmt|;
comment|/* Check for "\r\n" by peeking at the next byte. */
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|numbytes
argument_list|,
operator|&
name|found_eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbytes
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r\n"
expr_stmt|;
block|}
else|else
block|{
comment|/* Pretend we never peeked. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
name|numbytes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|80
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|eol_str
condition|)
break|break;
block|}
if|if
condition|(
name|eof
condition|)
operator|*
name|eof
operator|=
name|found_eof
expr_stmt|;
operator|*
name|line
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return in *OFFSET the current byte offset for reading from the  * unpatched file content accessed via BATON.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tell_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Seek to the specified by OFFSET in the unpatched file content accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes from BUF into the patched file content accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handling symbolic links:  *  * In Subversion, symlinks can be represented on disk in two distinct ways.  * On systems which support symlinks, a symlink is created on disk.  * On systems which do not support symlink, a file is created on disk  * which contains the "normal form" of the symlink, which looks like:  *   link TARGET  * where TARGET is the file the symlink points to.  *  * When reading symlinks (i.e. the link itself, not the file the symlink  * is pointing to) through the svn_subst_create_specialfile() function  * into a buffer, the buffer always contains the "normal form" of the symlink.  * Due to this representation symlinks always contain a single line of text.  *  * The functions below are needed to deal with the case where a patch  * wants to change the TARGET that a symlink points to.  */
end_comment

begin_comment
comment|/* Baton for the (readline|tell|seek|write)_symlink functions. */
end_comment

begin_struct
struct|struct
name|symlink_baton_t
block|{
comment|/* The path to the symlink on disk (not the path to the target of the link) */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* Indicates whether the "normal form" of the symlink has been read. */
name|svn_boolean_t
name|at_eof
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate *STRINGBUF in RESULT_POOL, and store into it the "normal form"  * of the symlink accessed via BATON.  *  * Otherwise behaves like readline_file(), which see.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|eof
condition|)
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eol_str
condition|)
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|at_eof
condition|)
block|{
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|svn_string_t
modifier|*
name|dest
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_link
argument_list|(
operator|&
name|dest
argument_list|,
name|sb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"link %s"
argument_list|,
name|dest
operator|->
name|data
argument_list|)
expr_stmt|;
name|sb
operator|->
name|at_eof
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *OFFSET to 1 or 0 depending on whether the "normal form" of  * the symlink has already been read. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tell_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
operator|*
name|offset
operator|=
name|sb
operator|->
name|at_eof
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If offset is non-zero, mark the symlink as having been read in its  * "normal form". Else, mark the symlink as not having been read yet. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
name|sb
operator|->
name|at_eof
operator|=
operator|(
name|offset
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the target of the symlink accessed via BATON.  * The contents of BUF must be a valid "normal form" of a symlink. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|link
init|=
name|apr_pstrndup
argument_list|(
name|scratch_pool
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|link
argument_list|,
literal|"link "
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid link representation"
argument_list|)
argument_list|)
return|;
name|link
operator|+=
literal|5
expr_stmt|;
comment|/* Skip "link " */
comment|/* We assume the entire symlink is written at once, as the patch      format is line based */
name|SVN_ERR
argument_list|(
name|svn_io_create_unique_link
argument_list|(
operator|&
name|new_name
argument_list|,
name|target_abspath
argument_list|,
name|link
argument_list|,
literal|".tmp"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|new_name
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a suitable filename for the target of PATCH.  * Examine the ``old'' and ``new'' file names, and choose the file name  * with the fewest path components, the shortest basename, and the shortest  * total file name length (in that order). In case of a tie, return the new  * filename. This heuristic is also used by Larry Wall's UNIX patch (except  * that it prompts for a filename in case of a tie).  * Additionally, for compatibility with git, if one of the filenames  * is "/dev/null", use the other filename. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|choose_target_filename
parameter_list|(
specifier|const
name|svn_patch_t
modifier|*
name|patch
parameter_list|)
block|{
name|apr_size_t
name|old
decl_stmt|;
name|apr_size_t
name|new
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|,
literal|"/dev/null"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|patch
operator|->
name|new_filename
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|,
literal|"/dev/null"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|patch
operator|->
name|old_filename
return|;
name|old
operator|=
name|svn_path_component_count
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|)
expr_stmt|;
name|new
operator|=
name|svn_path_component_count
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
block|{
name|old
operator|=
name|strlen
argument_list|(
name|svn_dirent_basename
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|strlen
argument_list|(
name|svn_dirent_basename
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
block|{
name|old
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|)
expr_stmt|;
name|new
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|old
operator|<
name|new
operator|)
condition|?
name|patch
operator|->
name|old_filename
else|:
name|patch
operator|->
name|new_filename
return|;
block|}
end_function

begin_comment
comment|/* Attempt to initialize a *PATCH_TARGET structure for a target file  * described by PATCH. Use working copy context WC_CTX.  * STRIP_COUNT specifies the number of leading path components  * which should be stripped from target paths in the patch.  * The patch target structure is allocated in RESULT_POOL, but if the target  * should be skipped, PATCH_TARGET->SKIPPED is set and the target should be  * treated as not fully initialized, e.g. the caller should not not do any  * further operations on the target if it is marked to be skipped.  * If REMOVE_TEMPFILES is TRUE, set up temporary files to be removed as  * soon as they are no longer needed.  * Use SCRATCH_POOL for all other allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_patch_target
parameter_list|(
name|patch_target_t
modifier|*
modifier|*
name|patch_target
parameter_list|,
specifier|const
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|patch_target_t
modifier|*
name|target
decl_stmt|;
name|target_content_t
modifier|*
name|content
decl_stmt|;
name|svn_boolean_t
name|has_prop_changes
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|prop_changes_only
init|=
name|FALSE
decl_stmt|;
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|patch
operator|->
name|prop_patches
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_prop_patch_t
modifier|*
name|prop_patch
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|has_prop_changes
condition|)
name|has_prop_changes
operator|=
name|prop_patch
operator|->
name|hunks
operator|->
name|nelts
operator|>
literal|0
expr_stmt|;
else|else
break|break;
block|}
block|}
name|prop_changes_only
operator|=
name|has_prop_changes
operator|&&
name|patch
operator|->
name|hunks
operator|->
name|nelts
operator|==
literal|0
expr_stmt|;
name|content
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|content
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All other fields in content are FALSE or NULL due to apr_pcalloc().*/
name|content
operator|->
name|current_line
operator|=
literal|1
expr_stmt|;
name|content
operator|->
name|eol_style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
name|content
operator|->
name|lines
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|hunks
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hunk_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|keywords
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|target
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All other fields in target are FALSE or NULL due to apr_pcalloc(). */
name|target
operator|->
name|db_kind
operator|=
name|svn_node_none
expr_stmt|;
name|target
operator|->
name|kind_on_disk
operator|=
name|svn_node_none
expr_stmt|;
name|target
operator|->
name|content
operator|=
name|content
expr_stmt|;
name|target
operator|->
name|prop_targets
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|resolve_target_path
argument_list|(
name|target
argument_list|,
name|choose_target_filename
argument_list|(
name|patch
argument_list|)
argument_list|,
name|wcroot_abspath
argument_list|,
name|strip_count
argument_list|,
name|prop_changes_only
argument_list|,
name|wc_ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
specifier|const
name|char
modifier|*
name|diff_header
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* Create a temporary file to write the patched result to.        * Also grab various bits of information about the file. */
if|if
condition|(
name|target
operator|->
name|is_symlink
condition|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
argument_list|)
decl_stmt|;
name|content
operator|->
name|existed
operator|=
name|TRUE
expr_stmt|;
name|sb
operator|->
name|local_abspath
operator|=
name|target
operator|->
name|local_abspath
expr_stmt|;
comment|/* Wire up the read callbacks. */
name|content
operator|->
name|read_baton
operator|=
name|sb
expr_stmt|;
name|content
operator|->
name|readline
operator|=
name|readline_symlink
expr_stmt|;
name|content
operator|->
name|seek
operator|=
name|seek_symlink
expr_stmt|;
name|content
operator|->
name|tell
operator|=
name|tell_symlink
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|target
operator|->
name|file
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_text_modified_p2
argument_list|(
operator|&
name|target
operator|->
name|local_mods
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_is_file_executable
argument_list|(
operator|&
name|target
operator|->
name|executable
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|obtain_eol_and_keywords_for_file
argument_list|(
operator|&
name|content
operator|->
name|keywords
argument_list|,
operator|&
name|content
operator|->
name|eol_style
argument_list|,
operator|&
name|content
operator|->
name|eol_str
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|existed
operator|=
name|TRUE
expr_stmt|;
comment|/* Wire up the read callbacks. */
name|content
operator|->
name|readline
operator|=
name|readline_file
expr_stmt|;
name|content
operator|->
name|seek
operator|=
name|seek_file
expr_stmt|;
name|content
operator|->
name|tell
operator|=
name|tell_file
expr_stmt|;
name|content
operator|->
name|read_baton
operator|=
name|target
operator|->
name|file
expr_stmt|;
block|}
comment|/* ### Is it ok to set the operation of the target already here? Isn't        * ### the target supposed to be marked with an operation after we have        * ### determined that the changes will apply cleanly to the WC? Maybe        * ### we should have kept the patch field in patch_target_t to be        * ### able to distinguish between 'what the patch says we should do'        * ### and 'what we can do with the given state of our WC'. */
if|if
condition|(
name|patch
operator|->
name|operation
operator|==
name|svn_diff_op_added
condition|)
name|target
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|patch
operator|->
name|operation
operator|==
name|svn_diff_op_deleted
condition|)
name|target
operator|->
name|deleted
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|is_symlink
condition|)
block|{
comment|/* Open a temporary file to write the patched result to. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|target
operator|->
name|patched_file
argument_list|,
operator|&
name|target
operator|->
name|patched_path
argument_list|,
name|NULL
argument_list|,
name|remove_tempfiles
condition|?
name|svn_io_file_del_on_pool_cleanup
else|:
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the write callback in place. */
name|content
operator|->
name|write
operator|=
name|write_file
expr_stmt|;
name|content
operator|->
name|write_baton
operator|=
name|target
operator|->
name|patched_file
expr_stmt|;
block|}
else|else
block|{
comment|/* Put the write callback in place. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|target
operator|->
name|patched_path
argument_list|,
name|NULL
argument_list|,
name|remove_tempfiles
condition|?
name|svn_io_file_del_on_pool_cleanup
else|:
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|write_baton
operator|=
operator|(
name|void
operator|*
operator|)
name|target
operator|->
name|patched_path
expr_stmt|;
name|content
operator|->
name|write
operator|=
name|write_symlink
expr_stmt|;
block|}
comment|/* Open a temporary file to write rejected hunks to. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|target
operator|->
name|reject_file
argument_list|,
operator|&
name|target
operator|->
name|reject_path
argument_list|,
name|NULL
argument_list|,
name|remove_tempfiles
condition|?
name|svn_io_file_del_on_pool_cleanup
else|:
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The reject file needs a diff header. */
name|diff_header
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"--- %s%s+++ %s%s"
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|APR_EOL_STR
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|diff_header
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|diff_header
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle properties. */
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|result_pool
argument_list|,
name|patch
operator|->
name|prop_patches
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|prop_name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_prop_patch_t
modifier|*
name|prop_patch
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|SVN_ERR
argument_list|(
name|init_prop_target
argument_list|(
operator|&
name|prop_target
argument_list|,
name|prop_name
argument_list|,
name|prop_patch
operator|->
name|operation
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|target
operator|->
name|prop_targets
argument_list|,
name|prop_name
argument_list|,
name|prop_target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|patch_target
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a *LINE from CONTENT. If the line has not been read before  * mark the line in CONTENT->LINES.  * If a line could be read successfully, increase CONTENT->CURRENT_LINE,  * and allocate *LINE in RESULT_POOL.  * Do temporary allocations in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline
parameter_list|(
name|target_content_t
modifier|*
name|content
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|line_raw
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_linenum_t
name|max_line
init|=
operator|(
name|svn_linenum_t
operator|)
name|content
operator|->
name|lines
operator|->
name|nelts
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|content
operator|->
name|eof
operator|||
name|content
operator|->
name|readline
operator|==
name|NULL
condition|)
block|{
operator|*
name|line
operator|=
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|content
operator|->
name|current_line
operator|<=
name|max_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|current_line
operator|==
name|max_line
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|tell
argument_list|(
name|content
operator|->
name|read_baton
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|content
operator|->
name|lines
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|offset
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|content
operator|->
name|readline
argument_list|(
name|content
operator|->
name|read_baton
argument_list|,
operator|&
name|line_raw
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|content
operator|->
name|eof
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|eol_style
operator|==
name|svn_subst_eol_style_none
condition|)
name|content
operator|->
name|eol_str
operator|=
name|eol_str
expr_stmt|;
if|if
condition|(
name|line_raw
condition|)
block|{
comment|/* Contract keywords. */
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|line_raw
operator|->
name|data
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|line
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|line_raw
operator|&&
name|line_raw
operator|->
name|len
operator|>
literal|0
operator|)
operator|||
name|eol_str
condition|)
name|content
operator|->
name|current_line
operator|++
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|content
operator|->
name|current_line
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Seek to the specified LINE in CONTENT.  * Mark any lines not read before in CONTENT->LINES.  * Do temporary allocations in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_to_line
parameter_list|(
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_linenum_t
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_linenum_t
name|saved_line
decl_stmt|;
name|svn_boolean_t
name|saved_eof
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|line
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|content
operator|->
name|current_line
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|saved_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
name|saved_eof
operator|=
name|content
operator|->
name|eof
expr_stmt|;
if|if
condition|(
name|line
operator|<=
operator|(
name|svn_linenum_t
operator|)
name|content
operator|->
name|lines
operator|->
name|nelts
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|offset
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|content
operator|->
name|lines
argument_list|,
name|line
operator|-
literal|1
argument_list|,
name|apr_off_t
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|seek
argument_list|(
name|content
operator|->
name|read_baton
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|current_line
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|dummy
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|content
operator|->
name|eof
operator|&&
name|content
operator|->
name|current_line
operator|<
name|line
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|dummy
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* After seeking backwards from EOF position clear EOF indicator. */
if|if
condition|(
name|saved_eof
operator|&&
name|saved_line
operator|>
name|content
operator|->
name|current_line
condition|)
name|content
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Indicate in *MATCHED whether the original text of HUNK matches the patch  * CONTENT at its current line. Lines within FUZZ lines of the start or  * end of HUNK will always match. If IGNORE_WHITESPACE is set, we ignore  * whitespace when doing the matching. When this function returns, neither  * CONTENT->CURRENT_LINE nor the file offset in the target file will  * have changed. If MATCH_MODIFIED is TRUE, match the modified hunk text,  * rather than the original hunk text.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|match_hunk
parameter_list|(
name|svn_boolean_t
modifier|*
name|matched
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_linenum_t
name|fuzz
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|match_modified
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_line
decl_stmt|;
name|svn_linenum_t
name|lines_read
decl_stmt|;
name|svn_linenum_t
name|saved_line
decl_stmt|;
name|svn_boolean_t
name|hunk_eof
decl_stmt|;
name|svn_boolean_t
name|lines_matched
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_linenum_t
name|hunk_length
decl_stmt|;
name|svn_linenum_t
name|leading_context
decl_stmt|;
name|svn_linenum_t
name|trailing_context
decl_stmt|;
operator|*
name|matched
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|eof
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|saved_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
name|lines_read
operator|=
literal|0
expr_stmt|;
name|lines_matched
operator|=
name|FALSE
expr_stmt|;
name|leading_context
operator|=
name|svn_diff_hunk_get_leading_context
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|trailing_context
operator|=
name|svn_diff_hunk_get_trailing_context
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_modified
condition|)
block|{
name|svn_diff_hunk_reset_modified_text
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|hunk_length
operator|=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_diff_hunk_reset_original_text
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|hunk_length
operator|=
name|svn_diff_hunk_get_original_length
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
do|do
block|{
specifier|const
name|char
modifier|*
name|hunk_line_translated
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_modified
condition|)
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_modified_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
name|NULL
argument_list|,
operator|&
name|hunk_eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_original_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
name|NULL
argument_list|,
operator|&
name|hunk_eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Contract keywords, if any, before matching. */
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|hunk_line
operator|->
name|data
argument_list|,
operator|&
name|hunk_line_translated
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|target_line
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|lines_read
operator|++
expr_stmt|;
comment|/* If the last line doesn't have a newline, we get EOF but still        * have a non-empty line to compare. */
if|if
condition|(
operator|(
name|hunk_eof
operator|&&
name|hunk_line
operator|->
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|content
operator|->
name|eof
operator|&&
operator|*
name|target_line
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/* Leading/trailing fuzzy lines always match. */
if|if
condition|(
operator|(
name|lines_read
operator|<=
name|fuzz
operator|&&
name|leading_context
operator|>
name|fuzz
operator|)
operator|||
operator|(
name|lines_read
operator|>
name|hunk_length
operator|-
name|fuzz
operator|&&
name|trailing_context
operator|>
name|fuzz
operator|)
condition|)
name|lines_matched
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ignore_whitespace
condition|)
block|{
name|char
modifier|*
name|hunk_line_trimmed
decl_stmt|;
name|char
modifier|*
name|target_line_trimmed
decl_stmt|;
name|hunk_line_trimmed
operator|=
name|apr_pstrdup
argument_list|(
name|iterpool
argument_list|,
name|hunk_line_translated
argument_list|)
expr_stmt|;
name|target_line_trimmed
operator|=
name|apr_pstrdup
argument_list|(
name|iterpool
argument_list|,
name|target_line
argument_list|)
expr_stmt|;
name|apr_collapse_spaces
argument_list|(
name|hunk_line_trimmed
argument_list|,
name|hunk_line_trimmed
argument_list|)
expr_stmt|;
name|apr_collapse_spaces
argument_list|(
name|target_line_trimmed
argument_list|,
name|target_line_trimmed
argument_list|)
expr_stmt|;
name|lines_matched
operator|=
operator|!
name|strcmp
argument_list|(
name|hunk_line_trimmed
argument_list|,
name|target_line_trimmed
argument_list|)
expr_stmt|;
block|}
else|else
name|lines_matched
operator|=
operator|!
name|strcmp
argument_list|(
name|hunk_line_translated
argument_list|,
name|target_line
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|lines_matched
condition|)
do|;
operator|*
name|matched
operator|=
name|lines_matched
operator|&&
name|hunk_eof
operator|&&
name|hunk_line
operator|->
name|len
operator|==
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|saved_line
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Scan lines of CONTENT for a match of the original text of HUNK,  * up to but not including the specified UPPER_LINE. Use fuzz factor FUZZ.  * If UPPER_LINE is zero scan until EOF occurs when reading from TARGET.  * Return the line at which HUNK was matched in *MATCHED_LINE.  * If the hunk did not match at all, set *MATCHED_LINE to zero.  * If the hunk matched multiple times, and MATCH_FIRST is TRUE,  * return the line number at which the first match occurred in *MATCHED_LINE.  * If the hunk matched multiple times, and MATCH_FIRST is FALSE,  * return the line number at which the last match occurred in *MATCHED_LINE.  * If IGNORE_WHITESPACE is set, ignore whitespace during the matching.  * If MATCH_MODIFIED is TRUE, match the modified hunk text,  * rather than the original hunk text.  * Call cancel CANCEL_FUNC with baton CANCEL_BATON to trigger cancellation.  * Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|scan_for_match
parameter_list|(
name|svn_linenum_t
modifier|*
name|matched_line
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_boolean_t
name|match_first
parameter_list|,
name|svn_linenum_t
name|upper_line
parameter_list|,
name|svn_linenum_t
name|fuzz
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|match_modified
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
operator|*
name|matched_line
operator|=
literal|0
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|content
operator|->
name|current_line
operator|<
name|upper_line
operator|||
name|upper_line
operator|==
literal|0
operator|)
operator|&&
operator|!
name|content
operator|->
name|eof
condition|)
block|{
name|svn_boolean_t
name|matched
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|match_hunk
argument_list|(
operator|&
name|matched
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|match_modified
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched
condition|)
block|{
name|svn_boolean_t
name|taken
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't allow hunks to match at overlapping locations. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_linenum_t
name|length
decl_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
specifier|const
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_modified
condition|)
name|length
operator|=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|svn_diff_hunk_get_original_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|taken
operator|=
operator|(
operator|!
name|hi
operator|->
name|rejected
operator|&&
name|content
operator|->
name|current_line
operator|>=
name|hi
operator|->
name|matched_line
operator|&&
name|content
operator|->
name|current_line
operator|<
operator|(
name|hi
operator|->
name|matched_line
operator|+
name|length
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|taken
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|taken
condition|)
block|{
operator|*
name|matched_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
if|if
condition|(
name|match_first
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|content
operator|->
name|eof
condition|)
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|content
operator|->
name|current_line
operator|+
literal|1
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Indicate in *MATCH whether the content described by CONTENT  * matches the modified text of HUNK.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|match_existing_target
parameter_list|(
name|svn_boolean_t
modifier|*
name|match
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|lines_matched
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|hunk_eof
decl_stmt|;
name|svn_linenum_t
name|saved_line
decl_stmt|;
name|svn_diff_hunk_reset_modified_text
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|saved_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|line_translated
decl_stmt|;
specifier|const
name|char
modifier|*
name|hunk_line_translated
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|line
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_modified_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
name|NULL
argument_list|,
operator|&
name|hunk_eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Contract keywords. */
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|line
argument_list|,
operator|&
name|line_translated
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|hunk_line
operator|->
name|data
argument_list|,
operator|&
name|hunk_line_translated
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|lines_matched
operator|=
operator|!
name|strcmp
argument_list|(
name|line_translated
argument_list|,
name|hunk_line_translated
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|eof
operator|!=
name|hunk_eof
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|match
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
do|while
condition|(
name|lines_matched
operator|&&
operator|!
name|content
operator|->
name|eof
operator|&&
operator|!
name|hunk_eof
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|match
operator|=
operator|(
name|lines_matched
operator|&&
name|content
operator|->
name|eof
operator|==
name|hunk_eof
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|saved_line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine the line at which a HUNK applies to CONTENT of the TARGET  * file, and return an appropriate hunk_info object in *HI, allocated from  * RESULT_POOL. Use fuzz factor FUZZ. Set HI->FUZZ to FUZZ. If no correct  * line can be determined, set HI->REJECTED to TRUE.  * IGNORE_WHITESPACE tells whether whitespace should be considered when  * matching. IS_PROP_HUNK indicates whether the hunk patches file content  * or a property.  * When this function returns, neither CONTENT->CURRENT_LINE nor  * the file offset in the target file will have changed.  * Call cancel CANCEL_FUNC with baton CANCEL_BATON to trigger cancellation.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_hunk_info
parameter_list|(
name|hunk_info_t
modifier|*
modifier|*
name|hi
parameter_list|,
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_linenum_t
name|fuzz
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|is_prop_hunk
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_linenum_t
name|matched_line
decl_stmt|;
name|svn_linenum_t
name|original_start
decl_stmt|;
name|svn_boolean_t
name|already_applied
decl_stmt|;
name|original_start
operator|=
name|svn_diff_hunk_get_original_start
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|already_applied
operator|=
name|FALSE
expr_stmt|;
comment|/* An original offset of zero means that this hunk wants to create    * a new file. Don't bother matching hunks in that case, since    * the hunk applies at line 1. If the file already exists, the hunk    * is rejected, unless the file is versioned and its content matches    * the file the patch wants to create.  */
if|if
condition|(
name|original_start
operator|==
literal|0
operator|&&
name|fuzz
operator|>
literal|0
condition|)
block|{
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject any fuzz for new files */
block|}
elseif|else
if|if
condition|(
name|original_start
operator|==
literal|0
operator|&&
operator|!
name|is_prop_hunk
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
block|{
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dirent
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
operator|!
name|dirent
operator|->
name|special
operator|&&
name|dirent
operator|->
name|filesize
operator|==
literal|0
condition|)
block|{
name|matched_line
operator|=
literal|1
expr_stmt|;
comment|/* Matched an on-disk empty file */
block|}
else|else
block|{
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_boolean_t
name|file_matches
decl_stmt|;
comment|/* ### I can't reproduce anything but a no-match here.                          The content is already at eof, so any hunk fails */
name|SVN_ERR
argument_list|(
name|match_existing_target
argument_list|(
operator|&
name|file_matches
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_matches
condition|)
block|{
name|matched_line
operator|=
literal|1
expr_stmt|;
name|already_applied
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject */
block|}
else|else
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject */
block|}
block|}
else|else
name|matched_line
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Same conditions apply as for the file case above.    *    * ### Since the hunk says the prop should be added we just assume so for    * ### now and don't bother with storing the previous lines and such. When    * ### we have the diff operation available we can just check for adds. */
elseif|else
if|if
condition|(
name|original_start
operator|==
literal|0
operator|&&
name|is_prop_hunk
condition|)
block|{
if|if
condition|(
name|content
operator|->
name|existed
condition|)
block|{
name|svn_boolean_t
name|prop_matches
decl_stmt|;
name|SVN_ERR
argument_list|(
name|match_existing_target
argument_list|(
operator|&
name|prop_matches
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_matches
condition|)
block|{
name|matched_line
operator|=
literal|1
expr_stmt|;
name|already_applied
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject */
block|}
else|else
name|matched_line
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|original_start
operator|>
literal|0
operator|&&
name|content
operator|->
name|existed
condition|)
block|{
name|svn_linenum_t
name|saved_line
init|=
name|content
operator|->
name|current_line
decl_stmt|;
comment|/* Scan for a match at the line where the hunk thinks it        * should be going. */
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|original_start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|current_line
operator|!=
name|original_start
condition|)
block|{
comment|/* Seek failed. */
name|matched_line
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|TRUE
argument_list|,
name|original_start
operator|+
literal|1
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched_line
operator|!=
name|original_start
condition|)
block|{
comment|/* Check if the hunk is already applied.            * We only check for an exact match here, and don't bother checking            * for already applied patches with offset/fuzz, because such a            * check would be ambiguous. */
if|if
condition|(
name|fuzz
operator|==
literal|0
condition|)
block|{
name|svn_linenum_t
name|modified_start
decl_stmt|;
name|modified_start
operator|=
name|svn_diff_hunk_get_modified_start
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified_start
operator|==
literal|0
condition|)
block|{
comment|/* Patch wants to delete the file. */
name|already_applied
operator|=
name|target
operator|->
name|locally_deleted
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|modified_start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|TRUE
argument_list|,
name|modified_start
operator|+
literal|1
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|already_applied
operator|=
operator|(
name|matched_line
operator|==
name|modified_start
operator|)
expr_stmt|;
block|}
block|}
else|else
name|already_applied
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|already_applied
condition|)
block|{
comment|/* Scan the whole file again from the start. */
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan forward towards the hunk's line and look for a line                * where the hunk matches. */
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|FALSE
argument_list|,
name|original_start
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In tie-break situations, we arbitrarily prefer early matches                * to save us from scanning the rest of the file. */
if|if
condition|(
name|matched_line
operator|==
literal|0
condition|)
block|{
comment|/* Scan forward towards the end of the file and look                    * for a line where the hunk matches. */
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|saved_line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The hunk wants to modify a file which doesn't exist. */
name|matched_line
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|*
name|hi
operator|)
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|hunk_info_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|hunk
operator|=
name|hunk
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|matched_line
operator|=
name|matched_line
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|rejected
operator|=
operator|(
name|matched_line
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|already_applied
operator|=
name|already_applied
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|fuzz
operator|=
name|fuzz
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy lines to the patched content until the specified LINE has been  * reached. Indicate in *EOF whether end-of-file was encountered while  * reading from the target.  * If LINE is zero, copy lines until end-of-file has been reached.  * Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_lines_to_target
parameter_list|(
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_linenum_t
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|content
operator|->
name|current_line
operator|<
name|line
operator|||
name|line
operator|==
literal|0
operator|)
operator|&&
operator|!
name|content
operator|->
name|eof
condition|)
block|{
specifier|const
name|char
modifier|*
name|target_line
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|target_line
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|content
operator|->
name|eof
condition|)
name|target_line
operator|=
name|apr_pstrcat
argument_list|(
name|iterpool
argument_list|,
name|target_line
argument_list|,
name|content
operator|->
name|eol_str
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|target_line
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|write
argument_list|(
name|content
operator|->
name|write_baton
argument_list|,
name|target_line
argument_list|,
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the diff text of HUNK to TARGET's reject file,  * and mark TARGET as having had rejects.  * We don't expand keywords, nor normalise line-endings, in reject files.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reject_hunk
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hunk_header
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|text_atat
init|=
literal|"@@"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|prop_atat
init|=
literal|"##"
decl_stmt|;
specifier|const
name|char
modifier|*
name|atat
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
if|if
condition|(
name|prop_name
condition|)
block|{
specifier|const
name|char
modifier|*
name|prop_header
decl_stmt|;
comment|/* ### Print 'Added', 'Deleted' or 'Modified' instead of 'Property'.        */
name|prop_header
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"Property: %s\n"
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|prop_header
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|prop_header
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|atat
operator|=
name|prop_atat
expr_stmt|;
block|}
else|else
block|{
name|atat
operator|=
name|text_atat
expr_stmt|;
block|}
name|hunk_header
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s -%lu,%lu +%lu,%lu %s%s"
argument_list|,
name|atat
argument_list|,
name|svn_diff_hunk_get_original_start
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|svn_diff_hunk_get_original_length
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|svn_diff_hunk_get_modified_start
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|atat
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|hunk_header
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|hunk_header
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_diff_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
block|{
if|if
condition|(
name|hunk_line
operator|->
name|len
operator|>=
literal|1
condition|)
block|{
name|len
operator|=
name|hunk_line
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|hunk_line
operator|->
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eol_str
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|eol_str
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|eol_str
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
condition|)
name|target
operator|->
name|had_prop_rejects
operator|=
name|TRUE
expr_stmt|;
else|else
name|target
operator|->
name|had_rejects
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the modified text of the hunk described by HI to the patched  * CONTENT. TARGET is the patch target.  * If PROP_NAME is not NULL, the hunk is assumed to be targeted for  * a property with the given name.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_hunk
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|hunk_info_t
modifier|*
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_linenum_t
name|lines_read
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* ### Is there a cleaner way to describe if we have an existing target?    */
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
operator|||
name|prop_name
condition|)
block|{
name|svn_linenum_t
name|line
decl_stmt|;
comment|/* Move forward to the hunk's line, copying data as we go.        * Also copy leading lines of context which matched with fuzz.        * The target has changed on the fuzzy-matched lines,        * so we should retain the target's version of those lines. */
name|SVN_ERR
argument_list|(
name|copy_lines_to_target
argument_list|(
name|content
argument_list|,
name|hi
operator|->
name|matched_line
operator|+
name|hi
operator|->
name|fuzz
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the target's version of the hunk.        * Don't skip trailing lines which matched with fuzz. */
name|line
operator|=
name|content
operator|->
name|current_line
operator|+
name|svn_diff_hunk_get_original_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
operator|-
operator|(
literal|2
operator|*
name|hi
operator|->
name|fuzz
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|line
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|current_line
operator|!=
name|line
operator|&&
operator|!
name|content
operator|->
name|eof
condition|)
block|{
comment|/* Seek failed, reject this hunk. */
name|hi
operator|->
name|rejected
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|content
argument_list|,
name|hi
operator|->
name|hunk
argument_list|,
name|prop_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Write the hunk's version to the patched result.    * Don't write the lines which matched with fuzz. */
name|lines_read
operator|=
literal|0
expr_stmt|;
name|svn_diff_hunk_reset_modified_text
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_modified_text
argument_list|(
name|hi
operator|->
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|lines_read
operator|++
expr_stmt|;
if|if
condition|(
name|lines_read
operator|>
name|hi
operator|->
name|fuzz
operator|&&
name|lines_read
operator|<=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
operator|-
name|hi
operator|->
name|fuzz
condition|)
block|{
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
name|hunk_line
operator|->
name|len
operator|>=
literal|1
condition|)
block|{
name|len
operator|=
name|hunk_line
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|write
argument_list|(
name|content
operator|->
name|write_baton
argument_list|,
name|hunk_line
operator|->
name|data
argument_list|,
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eol_str
condition|)
block|{
comment|/* Use the EOL as it was read from the patch file,                * unless the target's EOL style is set by svn:eol-style */
if|if
condition|(
name|content
operator|->
name|eol_style
operator|!=
name|svn_subst_eol_style_none
condition|)
name|eol_str
operator|=
name|content
operator|->
name|eol_str
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|eol_str
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|write
argument_list|(
name|content
operator|->
name|write_baton
argument_list|,
name|eol_str
argument_list|,
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
condition|)
name|target
operator|->
name|has_prop_changes
operator|=
name|TRUE
expr_stmt|;
else|else
name|target
operator|->
name|has_text_changes
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Use client context CTX to send a suitable notification for hunk HI,  * using TARGET to determine the path. If the hunk is a property hunk,  * PROP_NAME must be the name of the property, else NULL.  * Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_hunk_notification
parameter_list|(
specifier|const
name|hunk_info_t
modifier|*
name|hi
parameter_list|,
specifier|const
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
specifier|const
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_wc_notify_action_t
name|action
decl_stmt|;
if|if
condition|(
name|hi
operator|->
name|already_applied
condition|)
name|action
operator|=
name|svn_wc_notify_patch_hunk_already_applied
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|->
name|rejected
condition|)
name|action
operator|=
name|svn_wc_notify_patch_rejected_hunk
expr_stmt|;
else|else
name|action
operator|=
name|svn_wc_notify_patch_applied_hunk
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|target
operator|->
name|local_abspath
condition|?
name|target
operator|->
name|local_abspath
else|:
name|target
operator|->
name|local_relpath
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_original_start
operator|=
name|svn_diff_hunk_get_original_start
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_original_length
operator|=
name|svn_diff_hunk_get_original_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_modified_start
operator|=
name|svn_diff_hunk_get_modified_start
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_modified_length
operator|=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_matched_line
operator|=
name|hi
operator|->
name|matched_line
expr_stmt|;
name|notify
operator|->
name|hunk_fuzz
operator|=
name|hi
operator|->
name|fuzz
expr_stmt|;
name|notify
operator|->
name|prop_name
operator|=
name|prop_name
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Use client context CTX to send a suitable notification for a patch TARGET.  * Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_patch_notification
parameter_list|(
specifier|const
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_wc_notify_action_t
name|action
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|notify_func2
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|target
operator|->
name|skipped
condition|)
name|action
operator|=
name|svn_wc_notify_skip
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|deleted
condition|)
name|action
operator|=
name|svn_wc_notify_delete
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|replaced
condition|)
name|action
operator|=
name|svn_wc_notify_add
expr_stmt|;
else|else
name|action
operator|=
name|svn_wc_notify_patch
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|target
operator|->
name|local_abspath
condition|?
name|target
operator|->
name|local_abspath
else|:
name|target
operator|->
name|local_relpath
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|svn_wc_notify_skip
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_none
operator|||
name|target
operator|->
name|db_kind
operator|==
name|svn_node_unknown
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_missing
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_dir
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_obstructed
expr_stmt|;
else|else
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_unknown
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|->
name|had_rejects
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|local_mods
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|has_text_changes
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|had_prop_rejects
condition|)
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|has_prop_changes
condition|)
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
block|}
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|svn_wc_notify_patch
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hash_index
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|send_hunk_notification
argument_list|(
name|hi
argument_list|,
name|target
argument_list|,
name|NULL
comment|/* prop_name */
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hash_index
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|target
operator|->
name|prop_targets
argument_list|)
init|;
name|hash_index
condition|;
name|hash_index
operator|=
name|apr_hash_next
argument_list|(
name|hash_index
argument_list|)
control|)
block|{
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|prop_target
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Don't notify on the hunk level for added or deleted props. */
if|if
condition|(
name|prop_target
operator|->
name|operation
operator|!=
name|svn_diff_op_added
operator|&&
name|prop_target
operator|->
name|operation
operator|!=
name|svn_diff_op_deleted
condition|)
name|SVN_ERR
argument_list|(
name|send_hunk_notification
argument_list|(
name|hi
argument_list|,
name|target
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Apply a PATCH to a working copy at ABS_WC_PATH and put the result  * into temporary files, to be installed in the working copy later.  * Return information about the patch target in *PATCH_TARGET, allocated  * in RESULT_POOL. Use WC_CTX as the working copy context.  * STRIP_COUNT specifies the number of leading path components  * which should be stripped from target paths in the patch.  * REMOVE_TEMPFILES, PATCH_FUNC, and PATCH_BATON as in svn_client_patch().  * IGNORE_WHITESPACE tells whether whitespace should be considered when  * doing the matching.  * Call cancel CANCEL_FUNC with baton CANCEL_BATON to trigger cancellation.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_one_patch
parameter_list|(
name|patch_target_t
modifier|*
modifier|*
name|patch_target
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
name|svn_client_patch_func_t
name|patch_func
parameter_list|,
name|void
modifier|*
name|patch_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|patch_target_t
modifier|*
name|target
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|svn_linenum_t
name|MAX_FUZZ
init|=
literal|2
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hash_index
decl_stmt|;
name|SVN_ERR
argument_list|(
name|init_patch_target
argument_list|(
operator|&
name|target
argument_list|,
name|patch
argument_list|,
name|abs_wc_path
argument_list|,
name|wc_ctx
argument_list|,
name|strip_count
argument_list|,
name|remove_tempfiles
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|skipped
condition|)
block|{
operator|*
name|patch_target
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|patch_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|patch_func
argument_list|(
name|patch_baton
argument_list|,
operator|&
name|target
operator|->
name|filtered
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|target
operator|->
name|patched_path
argument_list|,
name|target
operator|->
name|reject_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|filtered
condition|)
block|{
operator|*
name|patch_target
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Match hunks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patch
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_diff_hunk_t
modifier|*
name|hunk
decl_stmt|;
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_linenum_t
name|fuzz
init|=
literal|0
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|hunk
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|patch
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|svn_diff_hunk_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Determine the line the hunk should be applied at.        * If no match is found initially, try with fuzz. */
do|do
block|{
name|SVN_ERR
argument_list|(
name|get_hunk_info
argument_list|(
operator|&
name|hi
argument_list|,
name|target
argument_list|,
name|target
operator|->
name|content
argument_list|,
name|hunk
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
comment|/* is_prop_hunk */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|fuzz
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|hi
operator|->
name|rejected
operator|&&
name|fuzz
operator|<=
name|MAX_FUZZ
operator|&&
operator|!
name|hi
operator|->
name|already_applied
condition|)
do|;
name|APR_ARRAY_PUSH
argument_list|(
name|target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
operator|=
name|hi
expr_stmt|;
block|}
comment|/* Apply or reject hunks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|already_applied
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|hi
operator|->
name|rejected
condition|)
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|content
argument_list|,
name|hi
operator|->
name|hunk
argument_list|,
name|NULL
comment|/* prop_name */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|apply_hunk
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|content
argument_list|,
name|hi
argument_list|,
name|NULL
comment|/* prop_name */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
block|{
comment|/* Copy any remaining lines to target. */
name|SVN_ERR
argument_list|(
name|copy_lines_to_target
argument_list|(
name|target
operator|->
name|content
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|content
operator|->
name|eof
condition|)
block|{
comment|/* We could not copy the entire target file to the temporary file,            * and would truncate the target if we copied the temporary file            * on top of it. Skip this target. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Match property hunks. */
for|for
control|(
name|hash_index
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|patch
operator|->
name|prop_patches
argument_list|)
init|;
name|hash_index
condition|;
name|hash_index
operator|=
name|apr_hash_next
argument_list|(
name|hash_index
argument_list|)
control|)
block|{
name|svn_prop_patch_t
modifier|*
name|prop_patch
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|prop_name
operator|=
name|svn__apr_hash_index_key
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
name|prop_patch
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop_name
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
condition|)
name|target
operator|->
name|is_special
operator|=
name|TRUE
expr_stmt|;
comment|/* We'll store matched hunks in prop_content. */
name|prop_target
operator|=
name|svn_hash_gets
argument_list|(
name|target
operator|->
name|prop_targets
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_patch
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_diff_hunk_t
modifier|*
name|hunk
decl_stmt|;
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_linenum_t
name|fuzz
init|=
literal|0
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|hunk
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_patch
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|svn_diff_hunk_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Determine the line the hunk should be applied at.            * If no match is found initially, try with fuzz. */
do|do
block|{
name|SVN_ERR
argument_list|(
name|get_hunk_info
argument_list|(
operator|&
name|hi
argument_list|,
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hunk
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|TRUE
comment|/* is_prop_hunk */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|fuzz
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|hi
operator|->
name|rejected
operator|&&
name|fuzz
operator|<=
name|MAX_FUZZ
operator|&&
operator|!
name|hi
operator|->
name|already_applied
condition|)
do|;
name|APR_ARRAY_PUSH
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
operator|=
name|hi
expr_stmt|;
block|}
block|}
comment|/* Apply or reject property hunks. */
for|for
control|(
name|hash_index
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|target
operator|->
name|prop_targets
argument_list|)
init|;
name|hash_index
condition|;
name|hash_index
operator|=
name|apr_hash_next
argument_list|(
name|hash_index
argument_list|)
control|)
block|{
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|prop_target
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|already_applied
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|hi
operator|->
name|rejected
condition|)
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hi
operator|->
name|hunk
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|apply_hunk
argument_list|(
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hi
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_target
operator|->
name|content
operator|->
name|existed
condition|)
block|{
comment|/* Copy any remaining lines to target. */
name|SVN_ERR
argument_list|(
name|copy_lines_to_target
argument_list|(
name|prop_target
operator|->
name|content
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_target
operator|->
name|content
operator|->
name|eof
condition|)
block|{
comment|/* We could not copy the entire target property to the                  * temporary file, and would truncate the target if we                  * copied the temporary file on top of it. Skip this target.  */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|is_symlink
condition|)
block|{
comment|/* Now close files we don't need any longer to get their contents        * flushed to disk.        * But we're not closing the reject file -- it still needed and        * will be closed later in write_out_rejected_hunks(). */
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|target
operator|->
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|target
operator|->
name|patched_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|apr_finfo_t
name|working_file
decl_stmt|;
name|apr_finfo_t
name|patched_file
decl_stmt|;
comment|/* Get sizes of the patched temporary file and the working file.        * We'll need those to figure out whether we should delete the        * patched file. */
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|patched_file
argument_list|,
name|target
operator|->
name|patched_path
argument_list|,
name|APR_FINFO_SIZE
operator||
name|APR_FINFO_LINK
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|working_file
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|APR_FINFO_SIZE
operator||
name|APR_FINFO_LINK
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|working_file
operator|.
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|patched_file
operator|.
name|size
operator|==
literal|0
operator|&&
name|working_file
operator|.
name|size
operator|>
literal|0
condition|)
block|{
comment|/* If a unidiff removes all lines from a file, that usually            * means deletion, so we can confidently schedule the target            * for deletion. In the rare case where the unidiff was really            * meant to replace a file with an empty one, this may not            * be desirable. But the deletion can easily be reverted and            * creating an empty file manually is not exactly hard either. */
name|target
operator|->
name|deleted
operator|=
operator|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_file
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patched_file
operator|.
name|size
operator|==
literal|0
operator|&&
name|working_file
operator|.
name|size
operator|==
literal|0
condition|)
block|{
comment|/* The target was empty or non-existent to begin with            * and no content was changed by patching.            * Report this as skipped if it didn't exist, unless in the special            * case of adding an empty file which has properties set on it or            * adding an empty file with a 'git diff' */
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_none
operator|&&
operator|!
name|target
operator|->
name|has_prop_changes
operator|&&
operator|!
name|target
operator|->
name|added
condition|)
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patched_file
operator|.
name|size
operator|>
literal|0
operator|&&
name|working_file
operator|.
name|size
operator|==
literal|0
condition|)
block|{
comment|/* The patch has created a file. */
if|if
condition|(
name|target
operator|->
name|locally_deleted
condition|)
name|target
operator|->
name|replaced
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_none
condition|)
name|target
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
operator|*
name|patch_target
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Try to create missing parent directories for TARGET in the working copy  * rooted at ABS_WC_PATH, and add the parents to version control.  * If the parents cannot be created, mark the target as skipped.  * Use client context CTX. If DRY_RUN is true, do not create missing  * parents but issue notifications only.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_missing_parents
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|components
decl_stmt|;
name|int
name|present_components
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Check if we can safely create the target's parent. */
name|local_abspath
operator|=
name|abs_wc_path
expr_stmt|;
name|components
operator|=
name|svn_path_decompose
argument_list|(
name|target
operator|->
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|present_components
operator|=
literal|0
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|components
operator|->
name|nelts
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|,
name|disk_kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|component
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|wc_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|==
name|svn_node_file
operator|||
name|wc_kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* on-disk files and missing files are obstructions */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|disk_kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_dir
condition|)
name|present_components
operator|++
expr_stmt|;
else|else
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|wc_kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* Node is missing */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* It's not a file, it's not a dir...              Let's add a dir */
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|local_abspath
operator|=
name|abs_wc_path
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|present_components
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|component
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dry_run
operator|&&
name|present_components
operator|<
name|components
operator|->
name|nelts
operator|-
literal|1
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|abs_wc_path
argument_list|,
name|svn_relpath_dirname
argument_list|(
name|target
operator|->
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|present_components
init|;
name|i
operator|<
name|components
operator|->
name|nelts
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|component
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
comment|/* Just do notification. */
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_add
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Create the missing component and add it                * to version control. Allow cancellation since we                * have not modified the working copy yet for this                * target. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Install a patched TARGET into the working copy at ABS_WC_PATH.  * Use client context CTX to retrieve WC_CTX, and possibly doing  * notifications. If DRY_RUN is TRUE, don't modify the working copy.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|install_patched_target
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|target
operator|->
name|deleted
condition|)
block|{
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
comment|/* Schedule the target for deletion.  Suppress            * notification, we'll do it manually in a minute            * because we also need to notify during dry-run.            * Also suppress cancellation, because we'd rather            * notify about what we did before aborting. */
name|SVN_ERR
argument_list|(
name|svn_wc_delete4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_local */
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|svn_node_kind_t
name|parent_db_kind
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|replaced
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If the target's parent directory does not yet exist            * we need to create it before we can copy the patched            * result in place. */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|parent_db_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't add targets under nodes scheduled for delete, so add              a new directory if needed. */
if|if
condition|(
name|parent_db_kind
operator|==
name|svn_node_dir
operator|||
name|parent_db_kind
operator|==
name|svn_node_file
condition|)
block|{
if|if
condition|(
name|parent_db_kind
operator|!=
name|svn_node_dir
condition|)
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|parent_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|!=
name|svn_node_dir
condition|)
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
name|SVN_ERR
argument_list|(
name|create_missing_parents
argument_list|(
name|target
argument_list|,
name|abs_wc_path
argument_list|,
name|ctx
argument_list|,
name|dry_run
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
comment|/* The target should exist */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|wc_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_none
operator|||
name|wc_kind
operator|!=
name|target
operator|->
name|kind_on_disk
condition|)
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|dry_run
operator|&&
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|is_special
condition|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|patched_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|patched_stream
argument_list|,
name|target
operator|->
name|patched_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_create_specialfile
argument_list|(
operator|&
name|stream
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|patched_stream
argument_list|,
name|stream
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|repair_eol
decl_stmt|;
comment|/* Copy the patched file on top of the target file.                * Always expand keywords in the patched file, but repair EOL                * only if svn:eol-style dictates a particular style. */
name|repair_eol
operator|=
operator|(
name|target
operator|->
name|content
operator|->
name|eol_style
operator|==
name|svn_subst_eol_style_fixed
operator|||
name|target
operator|->
name|content
operator|->
name|eol_style
operator|==
name|svn_subst_eol_style_native
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_copy_and_translate4
argument_list|(
name|target
operator|->
name|patched_path
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|target
operator|->
name|content
operator|->
name|eol_str
argument_list|,
name|repair_eol
argument_list|,
name|target
operator|->
name|content
operator|->
name|keywords
argument_list|,
name|TRUE
comment|/* expand */
argument_list|,
name|FALSE
comment|/* special */
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|replaced
condition|)
block|{
comment|/* The target file didn't exist previously,                * so add it to version control.                * Suppress notification, we'll do that later (and also                * during dry-run). Don't allow cancellation because                * we'd rather notify about what we did before aborting. */
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the target's executable bit if necessary. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
name|target
operator|->
name|executable
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out rejected hunks, if any, to TARGET->REJECT_PATH. If DRY_RUN is  * TRUE, don't modify the working copy.  * Do temporary allocations in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_out_rejected_hunks
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
operator|&&
operator|(
name|target
operator|->
name|had_rejects
operator|||
name|target
operator|->
name|had_prop_rejects
operator|)
condition|)
block|{
comment|/* Write out rejected hunks, if any. */
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|target
operator|->
name|reject_path
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s.svnpatch.rej"
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### TODO mark file as conflicted. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Install the patched properties for TARGET. Use client context CTX to  * retrieve WC_CTX. If DRY_RUN is TRUE, don't modify the working copy.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|install_patched_prop_targets
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|target
operator|->
name|prop_targets
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|prop_patch_target_t
modifier|*
name|prop_target
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|prop_val
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a deleted prop we only set the value to NULL. */
if|if
condition|(
name|prop_target
operator|->
name|operation
operator|==
name|svn_diff_op_deleted
condition|)
block|{
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_prop_set4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
name|svn_depth_empty
argument_list|,
name|TRUE
comment|/* skip_checks */
argument_list|,
name|NULL
comment|/* changelist_filter */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* cancellation */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* notification */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the patch target doesn't exist yet, the patch wants to add an        * empty file with properties set on it. So create an empty file and        * add it to version control. But if the patch was in the 'git format'        * then the file has already been added.        *        * ### How can we tell whether the patch really wanted to create        * ### an empty directory? */
if|if
condition|(
operator|!
name|target
operator|->
name|has_text_changes
operator|&&
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_none
operator|&&
operator|!
name|target
operator|->
name|added
condition|)
block|{
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
literal|""
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
comment|/* suppress notification */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Attempt to set the property, and reject all hunks if this          fails.  If the property had a non-empty value, but now has          an empty one, we'll just delete the property altogether.  */
if|if
condition|(
name|prop_target
operator|->
name|value
operator|&&
name|prop_target
operator|->
name|value
operator|->
name|len
operator|&&
name|prop_target
operator|->
name|patched_value
operator|&&
operator|!
name|prop_target
operator|->
name|patched_value
operator|->
name|len
condition|)
name|prop_val
operator|=
name|NULL
expr_stmt|;
else|else
name|prop_val
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|prop_target
operator|->
name|patched_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|canon_propval
decl_stmt|;
name|err
operator|=
name|svn_wc_canonicalize_svn_prop
argument_list|(
operator|&
name|canon_propval
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|prop_val
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|target
operator|->
name|db_kind
argument_list|,
name|TRUE
argument_list|,
comment|/* ### Skipping checks */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|svn_wc_prop_set4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|prop_val
argument_list|,
name|svn_depth_empty
argument_list|,
name|TRUE
comment|/* skip_checks */
argument_list|,
name|NULL
comment|/* changelist_filter */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* cancellation */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* notification */
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* ### The errors which svn_wc_canonicalize_svn_prop() will            * ### return aren't documented. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ILLEGAL_TARGET
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_NODE_UNEXPECTED_KIND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_IO_UNKNOWN_EOL
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_BAD_MIME_TYPE
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|hunk_info_t
modifier|*
name|hunk_info
decl_stmt|;
name|hunk_info
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
name|hunk_info
operator|->
name|rejected
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hunk_info
operator|->
name|hunk
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for can_delete_callback */
end_comment

begin_struct
struct|struct
name|can_delete_baton_t
block|{
name|svn_boolean_t
name|must_keep
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|targets_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_wc_status_func4_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|can_delete_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|can_delete_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|status
operator|->
name|node_status
condition|)
block|{
case|case
name|svn_wc_status_none
case|:
case|case
name|svn_wc_status_deleted
case|:
return|return
name|SVN_NO_ERROR
return|;
default|default:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cb
operator|->
name|local_abspath
argument_list|,
name|abspath
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Only interested in descendants */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|targets_info
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|patch_target_info_t
modifier|*
name|target_info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|cb
operator|->
name|targets_info
argument_list|,
name|i
argument_list|,
specifier|const
name|patch_target_info_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_info
operator|->
name|local_abspath
argument_list|,
name|abspath
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_info
operator|->
name|deleted
condition|)
return|return
name|SVN_NO_ERROR
return|;
break|break;
comment|/* Cease invocation; must keep */
block|}
block|}
name|cb
operator|->
name|must_keep
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CEASE_INVOCATION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_ancestor_delete
parameter_list|(
specifier|const
name|char
modifier|*
name|deleted_target
parameter_list|,
name|apr_array_header_t
modifier|*
name|targets_info
parameter_list|,
specifier|const
name|char
modifier|*
name|apply_root
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|can_delete_baton_t
name|cb
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|deleted_target
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
while|while
condition|(
name|svn_dirent_is_child
argument_list|(
name|apply_root
argument_list|,
name|dir_abspath
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|cb
operator|.
name|local_abspath
operator|=
name|dir_abspath
expr_stmt|;
name|cb
operator|.
name|must_keep
operator|=
name|FALSE
expr_stmt|;
name|cb
operator|.
name|targets_info
operator|=
name|targets_info
expr_stmt|;
name|err
operator|=
name|svn_wc_walk_status
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|can_delete_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_CEASE_INVOCATION
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|must_keep
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_delete4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|patch_target_info_t
modifier|*
name|pti
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pti
argument_list|)
argument_list|)
decl_stmt|;
name|pti
operator|->
name|local_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|dir_abspath
argument_list|)
expr_stmt|;
name|pti
operator|->
name|deleted
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|targets_info
argument_list|,
name|patch_target_info_t
operator|*
argument_list|)
operator|=
name|pti
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|dir_abspath
argument_list|,
name|svn_wc_notify_delete
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* And check if we must also delete the parent */
name|dir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This function is the main entry point into the patch code. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_patches
parameter_list|(
comment|/* The path to the patch file. */
specifier|const
name|char
modifier|*
name|patch_abspath
parameter_list|,
comment|/* The abspath to the working copy the patch should be applied to. */
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
comment|/* Indicates whether we're doing a dry run. */
name|svn_boolean_t
name|dry_run
parameter_list|,
comment|/* Number of leading components to strip from patch target paths. */
name|int
name|strip_count
parameter_list|,
comment|/* Whether to apply the patch in reverse. */
name|svn_boolean_t
name|reverse
parameter_list|,
comment|/* Whether to ignore whitespace when matching context lines. */
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
comment|/* As in svn_client_patch(). */
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
comment|/* As in svn_client_patch(). */
name|svn_client_patch_func_t
name|patch_func
parameter_list|,
name|void
modifier|*
name|patch_baton
parameter_list|,
comment|/* The client context. */
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_patch_t
modifier|*
name|patch
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_patch_file_t
modifier|*
name|patch_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets_info
decl_stmt|;
comment|/* Try to open the patch file. */
name|SVN_ERR
argument_list|(
name|svn_diff_open_patch_file
argument_list|(
operator|&
name|patch_file
argument_list|,
name|patch_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Apply patches. */
name|targets_info
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|patch_target_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_parse_next_patch
argument_list|(
operator|&
name|patch
argument_list|,
name|patch_file
argument_list|,
name|reverse
argument_list|,
name|ignore_whitespace
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
condition|)
block|{
name|patch_target_t
modifier|*
name|target
decl_stmt|;
name|SVN_ERR
argument_list|(
name|apply_one_patch
argument_list|(
operator|&
name|target
argument_list|,
name|patch
argument_list|,
name|abs_wc_path
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|strip_count
argument_list|,
name|ignore_whitespace
argument_list|,
name|remove_tempfiles
argument_list|,
name|patch_func
argument_list|,
name|patch_baton
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|filtered
condition|)
block|{
comment|/* Save info we'll still need when we're done patching. */
name|patch_target_info_t
modifier|*
name|target_info
init|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|patch_target_info_t
argument_list|)
argument_list|)
decl_stmt|;
name|target_info
operator|->
name|local_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
name|target_info
operator|->
name|deleted
operator|=
name|target
operator|->
name|deleted
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|targets_info
argument_list|,
name|patch_target_info_t
operator|*
argument_list|)
operator|=
name|target_info
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|has_text_changes
operator|||
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|deleted
condition|)
name|SVN_ERR
argument_list|(
name|install_patched_target
argument_list|(
name|target
argument_list|,
name|abs_wc_path
argument_list|,
name|ctx
argument_list|,
name|dry_run
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|has_prop_changes
operator|&&
operator|(
operator|!
name|target
operator|->
name|deleted
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|install_patched_prop_targets
argument_list|(
name|target
argument_list|,
name|ctx
argument_list|,
name|dry_run
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_out_rejected_hunks
argument_list|(
name|target
argument_list|,
name|dry_run
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|send_patch_notification
argument_list|(
name|target
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|deleted
operator|&&
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|SVN_ERR
argument_list|(
name|check_ancestor_delete
argument_list|(
name|target_info
operator|->
name|local_abspath
argument_list|,
name|targets_info
argument_list|,
name|abs_wc_path
argument_list|,
name|dry_run
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|patch
condition|)
do|;
name|SVN_ERR
argument_list|(
name|svn_diff_close_patch_file
argument_list|(
name|patch_file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_patch
parameter_list|(
specifier|const
name|char
modifier|*
name|patch_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_dir_abspath
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|reverse
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
name|svn_client_patch_func_t
name|patch_func
parameter_list|,
name|void
modifier|*
name|patch_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
name|strip_count
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"strip count must be positive"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|wc_dir_abspath
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|patch_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|patch_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|patch_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|wc_dir_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|apply_patches
argument_list|(
name|patch_abspath
argument_list|,
name|wc_dir_abspath
argument_list|,
name|dry_run
argument_list|,
name|strip_count
argument_list|,
name|reverse
argument_list|,
name|ignore_whitespace
argument_list|,
name|remove_tempfiles
argument_list|,
name|patch_func
argument_list|,
name|patch_baton
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|wc_dir_abspath
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

