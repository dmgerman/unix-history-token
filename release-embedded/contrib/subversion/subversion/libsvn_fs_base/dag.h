begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dag.h : DAG-like interface filesystem, private to libsvn_fs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_LIBSVN_FS_DAG_H
end_ifndef

begin_define
define|#
directive|define
name|SVN_LIBSVN_FS_DAG_H
end_define

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"trail.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* The interface in this file provides all the essential filesystem    operations, but exposes the filesystem's DAG structure.  This makes    it simpler to implement than the public interface, since a client    of this interface has to understand and cope with shared structure    directly as it appears in the database.  However, it's still a    self-consistent set of invariants to maintain, making it    (hopefully) a useful interface boundary.     In other words:     - The dag_node_t interface exposes the internal DAG structure of      the filesystem, while the svn_fs.h interface does any cloning      necessary to make the filesystem look like a tree.     - The dag_node_t interface exposes the existence of copy nodes,      whereas the svn_fs.h handles them transparently.     - dag_node_t's must be explicitly cloned, whereas the svn_fs.h      operations make clones implicitly.     - Callers of the dag_node_t interface use Berkeley DB transactions      to ensure consistency between operations, while callers of the      svn_fs.h interface use Subversion transactions.  */
comment|/* Initializing a filesystem.  */
comment|/* Given a filesystem FS, which contains all the necessary tables,    create the initial revision 0, and the initial root directory.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_init_fs
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
function_decl|;
comment|/* Generic DAG node stuff.  */
typedef|typedef
name|struct
name|dag_node_t
name|dag_node_t
typedef|;
comment|/* Fill *NODE with a dag_node_t representing node revision ID in FS,    allocating in POOL.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Return a new dag_node_t object referring to the same node as NODE,    allocated in POOL.  */
name|dag_node_t
modifier|*
name|svn_fs_base__dag_dup
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Return the filesystem containing NODE.  */
name|svn_fs_t
modifier|*
name|svn_fs_base__dag_get_fs
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
comment|/* Set *REV to NODE's revision number, as part of TRAIL.  If NODE has    never been committed as part of a revision, set *REV to    SVN_INVALID_REVNUM.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_revision
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Return the node revision ID of NODE.  The value returned is shared    with NODE, and will be deallocated when NODE is.  */
specifier|const
name|svn_fs_id_t
modifier|*
name|svn_fs_base__dag_get_id
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
comment|/* Return the created path of NODE.  The value returned is shared    with NODE, and will be deallocated when NODE is.  */
specifier|const
name|char
modifier|*
name|svn_fs_base__dag_get_created_path
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
comment|/* Set *ID_P to the node revision ID of NODE's immediate predecessor,    or NULL if NODE has no predecessor, as part of TRAIL.  The returned    ID will be allocated in POOL.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_predecessor_id
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set *COUNT to the number of predecessors NODE has (recursively), or    -1 if not known, as part of TRAIL.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_predecessor_count
parameter_list|(
name|int
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Return non-zero IFF NODE is currently mutable under Subversion    transaction TXN_ID.  */
name|svn_boolean_t
name|svn_fs_base__dag_check_mutable
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|)
function_decl|;
comment|/* Return the node kind of NODE. */
name|svn_node_kind_t
name|svn_fs_base__dag_node_kind
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
comment|/* Set *PROPLIST_P to a PROPLIST hash representing the entire property    list of NODE, as part of TRAIL.  The hash has const char * names    (the property names) and svn_string_t * values (the property values).     If properties do not exist on NODE, *PROPLIST_P will be set to NULL.     The returned property list is allocated in POOL.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set the property list of NODE to PROPLIST, as part of TRAIL.  The    node being changed must be mutable.  TXN_ID is the Subversion    transaction under which this occurs.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_set_proplist
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Mergeinfo tracking stuff. */
comment|/* If HAS_MERGEINFO is not null, set *HAS_MERGEINFO to TRUE iff NODE    records that its property list contains merge tracking information.     If COUNT is not null, set *COUNT to the number of nodes --    including NODE itself -- in the subtree rooted at NODE which claim    to carry merge tracking information.     Do this as part of TRAIL, and use POOL for necessary allocations.     NOTE:  No validation against NODE's actual property list is    performed. */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_mergeinfo_stats
parameter_list|(
name|svn_boolean_t
modifier|*
name|has_mergeinfo
parameter_list|,
name|apr_int64_t
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* If HAS_MERGEINFO is set, record on NODE that its property list    carries merge tracking information.  Otherwise, record on NODE its    property list does *not* carry merge tracking information.  NODE    must be mutable under TXN_ID (the Subversion transaction under    which this operation occurs).  Set *HAD_MERGEINFO to the previous    state of this record.     Update the mergeinfo count on NODE as necessary.     Do all of this as part of TRAIL, and use POOL for necessary    allocations.     NOTE:  No validation against NODE's actual property list is    performed. */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_set_has_mergeinfo
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_boolean_t
name|has_mergeinfo
parameter_list|,
name|svn_boolean_t
modifier|*
name|had_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Record on NODE a change of COUNT_DELTA nodes -- including NODE    itself -- in the subtree rooted at NODE claim to carry merge    tracking information.  That is, add COUNT_DELTA to NODE's current    mergeinfo count (regardless of whether COUNT_DELTA is a positive or    negative integer).     NODE must be mutable under TXN_ID (the Subversion transaction under    which this operation occurs).  Do this as part of TRAIL, and use    POOL for necessary allocations.     NOTE:  No validation of these claims is performed. */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_adjust_mergeinfo_count
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_int64_t
name|count_delta
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Revision and transaction roots.  */
comment|/* Open the root of revision REV of filesystem FS, as part of TRAIL.    Set *NODE_P to the new node.  Allocate the node in POOL.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_revision_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set *NODE_P to the root of transaction TXN_ID in FS, as part    of TRAIL.  Allocate the node in POOL.     Note that the root node of TXN_ID is not necessarily mutable.  If no    changes have been made in the transaction, then it may share its    root directory with its base revision.  To get a mutable root node    for a transaction, call svn_fs_base__dag_clone_root.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_txn_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set *NODE_P to the base root of transaction TXN_ID in FS, as part    of TRAIL.  Allocate the node in POOL.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_txn_base_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Clone the root directory of TXN_ID in FS, and update the    `transactions' table entry to point to it, unless this has been    done already.  In either case, set *ROOT_P to a reference to the    root directory clone.  Do all this as part of TRAIL, and allocate    *ROOT_P in POOL.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_clone_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Commit the transaction TXN->id in TXN->FS, as part of TRAIL.  Store the    new revision number in *NEW_REV.  This entails:    - marking the tree of mutable nodes at TXN->id's root as immutable,      and marking all their contents as stable    - creating a new revision, with TXN->id's root as its root directory    - promoting TXN->id to a "committed" transaction.     Beware!  This does not make sure that TXN->id is based on the very    latest revision in TXN->FS.  If the caller doesn't take care of this,    you may lose people's work!     Do any necessary temporary allocation in a subpool of POOL.    Consume temporary space at most proportional to the maximum depth    of SVN_TXN's tree of mutable nodes.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_commit_txn
parameter_list|(
name|svn_revnum_t
modifier|*
name|new_rev
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Directories.  */
comment|/* Open the node named NAME in the directory PARENT, as part of TRAIL.    Set *CHILD_P to the new node, allocated in POOL.  NAME must be a    single path component; it cannot be a slash-separated directory    path.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_open
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set *ENTRIES_P to a hash table of NODE's entries, as part of TRAIL,    or NULL if NODE has no entries.  The keys of the table are entry    names, and the values are svn_fs_dirent_t's.     The returned table is allocated in POOL.     NOTE: the 'kind' field of the svn_fs_dirent_t's is set to    svn_node_unknown by this function -- callers that need in    interesting value in these slots should fill them in using a new    TRAIL, since the list of entries can be arbitrarily large.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set ENTRY_NAME in NODE to point to ID, as part of TRAIL.  NODE must    be a mutable directory.  ID can refer to a mutable or immutable    node.  If ENTRY_NAME does not exist, it will be created.  TXN_ID is    the Subversion transaction under which this occurs.*/
name|svn_error_t
modifier|*
name|svn_fs_base__dag_set_entry
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry_name
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Make a new mutable clone of the node named NAME in PARENT, and    adjust PARENT's directory entry to point to it, as part of TRAIL,    unless NAME in PARENT already refers to a mutable node.  In either    case, set *CHILD_P to a reference to the new node, allocated in    POOL.  PARENT must be mutable.  NAME must be a single path    component; it cannot be a slash-separated directory path.    PARENT_PATH must be the canonicalized absolute path of the parent    directory.     COPY_ID, if non-NULL, is a key into the `copies' table, and    indicates that this new node is being created as the result of a    copy operation, and specifically which operation that was.     PATH is the canonicalized absolute path at which this node is being    created.     TXN_ID is the Subversion transaction under which this occurs.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_clone_child
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Delete the directory entry named NAME from PARENT, as part of    TRAIL.  PARENT must be mutable.  NAME must be a single path    component; it cannot be a slash-separated directory path.  If the    entry being deleted points to a mutable node revision, also remove    that node revision and (if it is a directory) all mutable node    revisions reachable from it.  Also delete the node-origins record    for each deleted node revision that had no predecessor.     TXN_ID is the Subversion transaction under which this occurs.     If return SVN_ERR_FS_NO_SUCH_ENTRY, then there is no entry NAME in    PARENT.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_delete
parameter_list|(
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Delete the node revision assigned to node ID from FS's `nodes'    table, as part of TRAIL.  Also delete any mutable representations    and strings associated with that node revision.  Also delete the    node-origins record for this node revision's node id, if this node    revision had no predecessor.     ID may refer to a file or directory, which must be mutable.  TXN_ID    is the Subversion transaction under which this occurs.     NOTE: If ID represents a directory, and that directory has mutable    children, you risk orphaning those children by leaving them    dangling, disconnected from all DAG trees.  It is assumed that    callers of this interface know what in the world they are doing.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_remove_node
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Delete all mutable node revisions reachable from node ID, including    ID itself, from FS's `nodes' table, as part of TRAIL.  Also delete    any mutable representations and strings associated with that node    revision.  Also delete the node-origins record for each deleted    node revision that had no predecessor.     ID may refer to a file or directory, which may be mutable or    immutable.  TXN_ID is the Subversion transaction under which this    occurs.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_delete_if_mutable
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Create a new mutable directory named NAME in PARENT, as part of    TRAIL.  Set *CHILD_P to a reference to the new node, allocated in    POOL.  The new directory has no contents, and no properties.    PARENT must be mutable.  NAME must be a single path component; it    cannot be a slash-separated directory path.  PARENT_PATH must be    the canonicalized absolute path of the parent directory.  PARENT    must not currently have an entry named NAME.  Do any temporary    allocation in POOL.  TXN_ID is the Subversion transaction    under which this occurs.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_make_dir
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Files.  */
comment|/* Set *CONTENTS to a readable generic stream which yields the    contents of FILE, as part of TRAIL.  Allocate the stream in POOL.    If FILE is not a file, return SVN_ERR_FS_NOT_FILE.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Return a generic writable stream in *CONTENTS with which to set the    contents of FILE as part of TRAIL.  Allocate the stream in POOL.    TXN_ID is the Subversion transaction under which this occurs.  Any    previous edits on the file will be deleted, and a new edit stream    will be constructed.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_edit_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Signify the completion of edits to FILE made using the stream    returned by svn_fs_base__dag_get_edit_stream, as part of TRAIL.  TXN_ID    is the Subversion transaction under which this occurs.     If CHECKSUM is non-null, it must match the checksum for FILE's    contents (note: this is not recalculated, the recorded checksum is    used), else the error SVN_ERR_CHECKSUM_MISMATCH is returned.     This operation is a no-op if no edits are present.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_finalize_edits
parameter_list|(
name|dag_node_t
modifier|*
name|file
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set *LENGTH to the length of the contents of FILE, as part of TRAIL. */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Put the checksum of type CHECKSUM_KIND recorded for FILE into  * CHECKSUM, as part of TRAIL.  *  * If no stored checksum of the requested kind is available, do not  * calculate the checksum, just put NULL into CHECKSUM.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_checksum_kind_t
name|checksum_kind
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Create a new mutable file named NAME in PARENT, as part of TRAIL.    Set *CHILD_P to a reference to the new node, allocated in    POOL.  The new file's contents are the empty string, and it    has no properties.  PARENT must be mutable.  NAME must be a single    path component; it cannot be a slash-separated directory path.    PARENT_PATH must be the canonicalized absolute path of the parent    directory.  TXN_ID is the Subversion transaction under which this    occurs.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_make_file
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Copies */
comment|/* Make ENTRY in TO_NODE be a copy of FROM_NODE, as part of TRAIL.    TO_NODE must be mutable.  TXN_ID is the Subversion transaction    under which this occurs.     If PRESERVE_HISTORY is true, the new node will record that it was    copied from FROM_PATH in FROM_REV; therefore, FROM_NODE should be    the node found at FROM_PATH in FROM_REV, although this is not    checked.     If PRESERVE_HISTORY is false, FROM_PATH and FROM_REV are ignored.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_copy
parameter_list|(
name|dag_node_t
modifier|*
name|to_node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry
parameter_list|,
name|dag_node_t
modifier|*
name|from_node
parameter_list|,
name|svn_boolean_t
name|preserve_history
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Deltification */
comment|/* Change TARGET's representation to be a delta against SOURCE, as    part of TRAIL.  If TARGET or SOURCE does not exist, do nothing and    return success.  If PROPS_ONLY is non-zero, only the node property    portion of TARGET will be deltified.     If TXN_ID is non-NULL, it is the transaction ID in which TARGET's    representation(s) must have been created (otherwise deltification    is silently not attempted).     WARNING WARNING WARNING: Do *NOT* call this with a mutable SOURCE    node.  Things will go *very* sour if you deltify TARGET against a    node that might just disappear from the filesystem in the (near)    future.  */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_deltify
parameter_list|(
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|svn_boolean_t
name|props_only
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Index NODE's backing data representations by their checksum.  Do    this as part of TRAIL.  Use POOL for allocations. */
name|svn_error_t
modifier|*
name|svn_fs_base__dag_index_checksums
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Comparison */
comment|/* Find out what is the same between two nodes.     If PROPS_CHANGED is non-null, set *PROPS_CHANGED to 1 if the two    nodes have different property lists, or to 0 if same.     If CONTENTS_CHANGED is non-null, set *CONTENTS_CHANGED to 1 if the    two nodes have different contents, or to 0 if same.  For files,    file contents are compared; for directories, the entries lists are    compared.  If one is a file and the other is a directory, the one's    contents will be compared to the other's entries list.  (Not    terribly useful, I suppose, but that's the caller's business.)     ### todo: This function only compares rep keys at the moment.  This    may leave us with a slight chance of a false positive, though I    don't really see how that would happen in practice.  Nevertheless,    it should probably be fixed.  */
name|svn_error_t
modifier|*
name|svn_fs_base__things_different
parameter_list|(
name|svn_boolean_t
modifier|*
name|props_changed
parameter_list|,
name|svn_boolean_t
modifier|*
name|contents_changed
parameter_list|,
name|dag_node_t
modifier|*
name|node1
parameter_list|,
name|dag_node_t
modifier|*
name|node2
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_LIBSVN_FS_DAG_H */
end_comment

end_unit

