begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dag.c : DAG-like interface filesystem, private to libsvn_fs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"key-gen.h"
end_include

begin_include
include|#
directive|include
file|"node-rev.h"
end_include

begin_include
include|#
directive|include
file|"trail.h"
end_include

begin_include
include|#
directive|include
file|"reps-strings.h"
end_include

begin_include
include|#
directive|include
file|"revs-txns.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"util/fs_skels.h"
end_include

begin_include
include|#
directive|include
file|"bdb/txn-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/rev-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/nodes-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/copies-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/reps-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/strings-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/checksum-reps-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/changes-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/node-origins-table.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Initializing a filesystem.  */
end_comment

begin_struct
struct|struct
name|dag_node_t
block|{
comment|/*** NOTE: Keeping in-memory representations of disk data that can        be changed by other accessors is a nasty business.  Such        representations are basically a cache with some pretty complex        invalidation rules.  For example, the "node revision"        associated with a DAG node ID can look completely different to        a process that has modified that information as part of a        Berkeley DB transaction than it does to some other process.        That said, there are some aspects of a "node revision" which        never change, like its 'id' or 'kind'.  Our best bet is to        limit ourselves to exposing outside of this interface only        those immutable aspects of a DAG node representation.  ***/
comment|/* The filesystem this dag node came from. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* The node revision ID for this dag node. */
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
comment|/* The node's type (file, dir, etc.) */
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* the path at which this node was created. */
specifier|const
name|char
modifier|*
name|created_path
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Trivial helper/accessor functions. */
end_comment

begin_function
name|svn_node_kind_t
name|svn_fs_base__dag_node_kind
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|kind
return|;
block|}
end_function

begin_function
specifier|const
name|svn_fs_id_t
modifier|*
name|svn_fs_base__dag_get_id
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|id
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_base__dag_get_created_path
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|created_path
return|;
block|}
end_function

begin_function
name|svn_fs_t
modifier|*
name|svn_fs_base__dag_get_fs
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|fs
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fs_base__dag_check_mutable
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|svn_fs_base__id_txn_id
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|txn_id
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|new_node
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Construct the node. */
name|new_node
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|new_node
operator|->
name|id
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Grab the contents so we can cache some of the immutable parts of it. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the KIND and CREATED_PATH attributes */
name|new_node
operator|->
name|kind
operator|=
name|noderev
operator|->
name|kind
expr_stmt|;
name|new_node
operator|->
name|created_path
operator|=
name|noderev
operator|->
name|created_path
expr_stmt|;
comment|/* Return a fresh new node */
operator|*
name|node
operator|=
name|new_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_revision
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Use the txn ID from the NODE's id to look up the transaction and      get its revision number.  */
return|return
name|svn_fs_base__txn_get_revision
argument_list|(
name|rev
argument_list|,
name|svn_fs_base__dag_get_fs
argument_list|(
name|node
argument_list|)
argument_list|,
name|svn_fs_base__id_txn_id
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_predecessor_id
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|noderev
operator|->
name|predecessor_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_predecessor_count
parameter_list|(
name|int
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Trail body for svn_fs_base__dag_init_fs. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_dag_init_fs
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|node_revision_t
name|noderev
decl_stmt|;
name|revision_t
name|revision
decl_stmt|;
name|svn_revnum_t
name|rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|trail
operator|->
name|fs
decl_stmt|;
name|svn_string_t
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_id
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|root_id
init|=
name|svn_fs_base__id_create
argument_list|(
literal|"0"
argument_list|,
literal|"0"
argument_list|,
literal|"0"
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
decl_stmt|;
comment|/* Create empty root directory with node revision 0.0.0. */
name|memset
argument_list|(
operator|&
name|noderev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|noderev
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|noderev
operator|.
name|created_path
operator|=
literal|"/"
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|root_id
argument_list|,
operator|&
name|noderev
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new transaction (better have an id of "0") */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__create_txn
argument_list|(
operator|&
name|txn_id
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|txn_id
argument_list|,
literal|"0"
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Corrupt DB: initial transaction id not '0' in filesystem '%s'"
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
comment|/* Create a default copy (better have an id of "0") */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__reserve_copy_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|copy_id
argument_list|,
literal|"0"
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Corrupt DB: initial copy id not '0' in filesystem '%s'"
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__create_copy
argument_list|(
name|fs
argument_list|,
name|copy_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|root_id
argument_list|,
name|copy_kind_real
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Link it into filesystem revision 0. */
name|revision
operator|.
name|txn_id
operator|=
name|txn_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|fs
argument_list|,
operator|&
name|revision
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Corrupt DB: initial revision number "
literal|"is not '0' in filesystem '%s'"
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
comment|/* Promote our transaction to a "committed" transaction. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__txn_make_committed
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|rev
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a date on revision 0. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__set_rev_prop
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|NULL
argument_list|,
operator|&
name|date
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_init_fs
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_dag_init_fs
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Directory node functions ***/
end_comment

begin_comment
comment|/* Some of these are helpers for functions outside this section. */
end_comment

begin_comment
comment|/* Given directory NODEREV in FS, set *ENTRIES_P to its entries list    hash, as part of TRAIL, or to NULL if NODEREV has no entries.  The    entries list will be allocated in POOL, and the entries in that    list will not have interesting value in their 'kind' fields.  If    NODEREV is not a directory, return the error SVN_ERR_FS_NOT_DIRECTORY. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_string_t
name|entries_raw
decl_stmt|;
name|svn_skel_t
modifier|*
name|entries_skel
decl_stmt|;
comment|/* Error if this is not a directory. */
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to get entries of a non-directory node"
argument_list|)
argument_list|)
return|;
comment|/* If there's a DATA-KEY, there might be entries to fetch. */
if|if
condition|(
name|noderev
operator|->
name|data_key
condition|)
block|{
comment|/* Now we have a rep, follow through to get the entries. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents
argument_list|(
operator|&
name|entries_raw
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|data_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|entries_skel
operator|=
name|svn_skel__parse
argument_list|(
name|entries_raw
operator|.
name|data
argument_list|,
name|entries_raw
operator|.
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Were there entries?  Make a hash from them. */
if|if
condition|(
name|entries_skel
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__parse_entries_skel
argument_list|(
operator|&
name|entries
argument_list|,
name|entries_skel
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* No hash?  No problem.  */
operator|*
name|entries_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|entries
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Else, convert the hash from a name->id mapping to a name->dirent one.  */
operator|*
name|entries_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dirent
argument_list|)
argument_list|)
decl_stmt|;
comment|/* KEY will be the entry name in ancestor, VAL the id.  */
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|name
operator|=
name|key
expr_stmt|;
name|dirent
operator|->
name|id
operator|=
name|val
expr_stmt|;
name|dirent
operator|->
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|apr_hash_set
argument_list|(
operator|*
name|entries_p
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|dirent
argument_list|)
expr_stmt|;
block|}
comment|/* Return our findings. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *ID_P to the node-id for entry NAME in PARENT, as part of    TRAIL.  If no such entry, set *ID_P to NULL but do not error.  The    entry is allocated in POOL or in the same pool as PARENT;    the caller should copy if it cares.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dir_entry_id_from_node
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|parent
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
condition|)
name|dirent
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|dirent
operator|=
name|NULL
expr_stmt|;
operator|*
name|id_p
operator|=
name|dirent
condition|?
name|dirent
operator|->
name|id
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add or set in PARENT a directory entry NAME pointing to ID.    Allocations are done in TRAIL.     Assumptions:    - PARENT is a mutable directory.    - ID does not refer to an ancestor of parent    - NAME is a single path component */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_entry
parameter_list|(
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|parent_noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|rep_key
decl_stmt|,
modifier|*
name|mutable_rep_key
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|wstream
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_string_t
name|raw_entries
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|raw_entries_buf
decl_stmt|;
name|svn_skel_t
modifier|*
name|entries_skel
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|parent
argument_list|)
decl_stmt|;
comment|/* Get the parent's node-revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|fs
argument_list|,
name|parent
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep_key
operator|=
name|parent_noderev
operator|->
name|data_key
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_mutable_rep
argument_list|(
operator|&
name|mutable_rep_key
argument_list|,
name|rep_key
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the parent node already pointed at a mutable representation,      we don't need to do anything.  But if it didn't, either because      the parent didn't refer to any rep yet or because it referred to      an immutable one, we must make the parent refer to the mutable      rep we just created. */
if|if
condition|(
operator|!
name|svn_fs_base__same_keys
argument_list|(
name|rep_key
argument_list|,
name|mutable_rep_key
argument_list|)
condition|)
block|{
name|parent_noderev
operator|->
name|data_key
operator|=
name|mutable_rep_key
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|parent
operator|->
name|id
argument_list|,
name|parent_noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the new representation inherited nothing, start a new entries      list for it.  Else, go read its existing entries list. */
if|if
condition|(
name|rep_key
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents
argument_list|(
operator|&
name|raw_entries
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|entries_skel
operator|=
name|svn_skel__parse
argument_list|(
name|raw_entries
operator|.
name|data
argument_list|,
name|raw_entries
operator|.
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries_skel
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__parse_entries_skel
argument_list|(
operator|&
name|entries
argument_list|,
name|entries_skel
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we still have no ENTRIES hash, make one here.  */
if|if
condition|(
operator|!
name|entries
condition|)
name|entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Now, add our new entry to the entries list. */
name|svn_hash_sets
argument_list|(
name|entries
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Finally, replace the old entries list with the new one. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__unparse_entries_skel
argument_list|(
operator|&
name|entries_skel
argument_list|,
name|entries
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|raw_entries_buf
operator|=
name|svn_skel__unparse
argument_list|(
name|entries_skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_write_stream
argument_list|(
operator|&
name|wstream
argument_list|,
name|fs
argument_list|,
name|mutable_rep_key
argument_list|,
name|txn_id
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|raw_entries_buf
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|wstream
argument_list|,
name|raw_entries_buf
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stream_close
argument_list|(
name|wstream
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a new entry named NAME in PARENT, as part of TRAIL.  If IS_DIR    is true, then the node revision the new entry points to will be a    directory, else it will be a file.  The new node will be allocated    in POOL.  PARENT must be mutable, and must not have an entry    named NAME.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_entry
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_boolean_t
name|is_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|new_node_id
decl_stmt|;
name|node_revision_t
name|new_noderev
decl_stmt|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to create a node with an illegal name '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that parent is a directory */
if|if
condition|(
name|parent
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to create entry in non-directory parent"
argument_list|)
argument_list|)
return|;
comment|/* Check that the parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|parent
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to clone child of non-mutable node"
argument_list|)
argument_list|)
return|;
comment|/* Check that parent does not already have an entry named NAME. */
name|SVN_ERR
argument_list|(
name|dir_entry_id_from_node
argument_list|(
operator|&
name|new_node_id
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_node_id
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ALREADY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to create entry that already exists"
argument_list|)
argument_list|)
return|;
comment|/* Create the new node's NODE-REVISION */
name|memset
argument_list|(
operator|&
name|new_noderev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|new_noderev
argument_list|)
argument_list|)
expr_stmt|;
name|new_noderev
operator|.
name|kind
operator|=
name|is_dir
condition|?
name|svn_node_dir
else|:
name|svn_node_file
expr_stmt|;
name|new_noderev
operator|.
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|parent_path
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__create_node
argument_list|(
operator|&
name|new_node_id
argument_list|,
name|svn_fs_base__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
operator|&
name|new_noderev
argument_list|,
name|svn_fs_base__id_copy_id
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|parent
argument_list|)
argument_list|)
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new dag_node_t for our new node */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|svn_fs_base__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
name|new_node_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can safely call set_entry because we already know that      PARENT is mutable, and we just created CHILD, so we know it has      no ancestors (therefore, PARENT cannot be an ancestor of CHILD) */
return|return
name|set_entry
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
operator|*
name|child_p
argument_list|)
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_dir_entries
argument_list|(
name|entries
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_set_entry
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry_name
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Check it's a directory. */
if|if
condition|(
name|node
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set entry in non-directory node"
argument_list|)
argument_list|)
return|;
comment|/* Check it's mutable. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|node
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set entry in immutable node"
argument_list|)
argument_list|)
return|;
return|return
name|set_entry
argument_list|(
name|node
argument_list|,
name|entry_name
argument_list|,
name|id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Proplists. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
init|=
name|NULL
decl_stmt|;
name|svn_string_t
name|raw_proplist
decl_stmt|;
name|svn_skel_t
modifier|*
name|proplist_skel
decl_stmt|;
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get property key (returning early if there isn't one) . */
if|if
condition|(
operator|!
name|noderev
operator|->
name|prop_key
condition|)
block|{
operator|*
name|proplist_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Get the string associated with the property rep, parsing it as a      skel, and then attempt to parse *that* into a property hash.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents
argument_list|(
operator|&
name|raw_proplist
argument_list|,
name|svn_fs_base__dag_get_fs
argument_list|(
name|node
argument_list|)
argument_list|,
name|noderev
operator|->
name|prop_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|proplist_skel
operator|=
name|svn_skel__parse
argument_list|(
name|raw_proplist
operator|.
name|data
argument_list|,
name|raw_proplist
operator|.
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|proplist_skel
condition|)
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|proplist_skel
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_set_proplist
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|rep_key
decl_stmt|,
modifier|*
name|mutable_rep_key
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|wstream
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_skel_t
modifier|*
name|proplist_skel
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|raw_proplist_buf
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Sanity check: this node better be mutable! */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|node
argument_list|,
name|txn_id
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_base__id_unparse
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't set proplist on *immutable* node-revision %s"
argument_list|)
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep_key
operator|=
name|noderev
operator|->
name|prop_key
expr_stmt|;
comment|/* Flatten the proplist into a string. */
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|proplist_skel
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|raw_proplist_buf
operator|=
name|svn_skel__unparse
argument_list|(
name|proplist_skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If this repository supports representation sharing, and the      resulting property list is exactly the same as another string in      the database, just use the previously existing string and get      outta here. */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_REP_SHARING_FORMAT
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|dup_rep_key
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|raw_proplist_buf
operator|->
name|data
argument_list|,
name|raw_proplist_buf
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_bdb__get_checksum_rep
argument_list|(
operator|&
name|dup_rep_key
argument_list|,
name|fs
argument_list|,
name|checksum
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
if|if
condition|(
name|noderev
operator|->
name|prop_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__delete_rep_if_mutable
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|prop_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|prop_key
operator|=
name|dup_rep_key
expr_stmt|;
return|return
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_FS_NO_SUCH_CHECKSUM_REP
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
block|}
comment|/* Get a mutable version of this rep (updating the node revision if      this isn't a NOOP)  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_mutable_rep
argument_list|(
operator|&
name|mutable_rep_key
argument_list|,
name|rep_key
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_base__same_keys
argument_list|(
name|mutable_rep_key
argument_list|,
name|rep_key
argument_list|)
condition|)
block|{
name|noderev
operator|->
name|prop_key
operator|=
name|mutable_rep_key
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the old property list with the new one. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_write_stream
argument_list|(
operator|&
name|wstream
argument_list|,
name|fs
argument_list|,
name|mutable_rep_key
argument_list|,
name|txn_id
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|raw_proplist_buf
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|wstream
argument_list|,
name|raw_proplist_buf
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|wstream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Roots. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_revision_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__rev_get_root
argument_list|(
operator|&
name|root_id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_txn_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|,
modifier|*
name|ignored
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_txn_ids
argument_list|(
operator|&
name|root_id
argument_list|,
operator|&
name|ignored
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_txn_base_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|base_root_id
decl_stmt|,
modifier|*
name|ignored
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_txn_ids
argument_list|(
operator|&
name|ignored
argument_list|,
operator|&
name|base_root_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
name|base_root_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_clone_child
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|cur_entry
decl_stmt|;
comment|/* parent's current entry named NAME */
specifier|const
name|svn_fs_id_t
modifier|*
name|new_node_id
decl_stmt|;
comment|/* node id we'll put into NEW_NODE */
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|parent
argument_list|)
decl_stmt|;
comment|/* First check that the parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|parent
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to clone child of non-mutable node"
argument_list|)
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to make a child clone with an illegal name '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Find the node named NAME in PARENT's entries list if it exists. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_open
argument_list|(
operator|&
name|cur_entry
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for mutability in the node we found.  If it's mutable, we      don't need to clone it. */
if|if
condition|(
name|svn_fs_base__dag_check_mutable
argument_list|(
name|cur_entry
argument_list|,
name|txn_id
argument_list|)
condition|)
block|{
comment|/* This has already been cloned */
name|new_node_id
operator|=
name|cur_entry
operator|->
name|id
expr_stmt|;
block|}
else|else
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get a fresh NODE-REVISION for current child node. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|cur_entry
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the clone thingy here. */
name|noderev
operator|->
name|predecessor_id
operator|=
name|cur_entry
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|noderev
operator|->
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|parent_path
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__create_successor
argument_list|(
operator|&
name|new_node_id
argument_list|,
name|fs
argument_list|,
name|cur_entry
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the ID in the parent's ENTRY list with the ID which          refers to the mutable clone of this child. */
name|SVN_ERR
argument_list|(
name|set_entry
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|new_node_id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the youngster. */
return|return
name|svn_fs_base__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|fs
argument_list|,
name|new_node_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_clone_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|base_root_id
decl_stmt|,
modifier|*
name|root_id
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Get the node ID's of the root directories of the transaction and      its base revision.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_txn_ids
argument_list|(
operator|&
name|root_id
argument_list|,
operator|&
name|base_root_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Oh, give me a clone...      (If they're the same, we haven't cloned the transaction's root      directory yet.)  */
if|if
condition|(
name|svn_fs_base__id_eq
argument_list|(
name|root_id
argument_list|,
name|base_root_id
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|base_copy_id
init|=
name|svn_fs_base__id_copy_id
argument_list|(
name|base_root_id
argument_list|)
decl_stmt|;
comment|/* Of my own flesh and bone...          (Get the NODE-REVISION for the base node, and then write          it back out as the clone.) */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|base_root_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* With its Y-chromosome changed to X...          (Store it with an updated predecessor count.) */
comment|/* ### TODO: Does it even makes sense to have a different copy id for          the root node?  That is, does this function need a copy_id          passed in?  */
name|noderev
operator|->
name|predecessor_id
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|base_root_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__create_successor
argument_list|(
operator|&
name|root_id
argument_list|,
name|fs
argument_list|,
name|base_root_id
argument_list|,
name|noderev
argument_list|,
name|base_copy_id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... And when it is grown        *      Then my own little clone        *        Will be of the opposite sex!        */
name|SVN_ERR
argument_list|(
name|svn_fs_base__set_txn_root
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|root_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * (Sung to the tune of "Home, Home on the Range", with thanks to    * Randall Garrett and Isaac Asimov.)    */
comment|/* One way or another, root_id now identifies a cloned root node. */
return|return
name|svn_fs_base__dag_get_node
argument_list|(
name|root_p
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_delete
parameter_list|(
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|parent_noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|rep_key
decl_stmt|,
modifier|*
name|mutable_rep_key
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|entries_skel
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|parent
operator|->
name|fs
decl_stmt|;
name|svn_string_t
name|str
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|id
init|=
name|NULL
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Make sure parent is a directory. */
if|if
condition|(
name|parent
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to delete entry '%s' from *non*-directory node"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|parent
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to delete entry '%s' from immutable directory node"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to delete a node with an illegal name '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Get a fresh NODE-REVISION for the parent node. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|fs
argument_list|,
name|parent
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the key for the parent's entries list (data) representation. */
name|rep_key
operator|=
name|parent_noderev
operator|->
name|data_key
expr_stmt|;
comment|/* No REP_KEY means no representation, and no representation means      no data, and no data means no entries...there's nothing here to      delete! */
if|if
condition|(
operator|!
name|rep_key
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_ENTRY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Delete failed: directory has no entry '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Ensure we have a key to a mutable representation of the entries      list.  We'll have to update the NODE-REVISION if it points to an      immutable version.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_mutable_rep
argument_list|(
operator|&
name|mutable_rep_key
argument_list|,
name|rep_key
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_base__same_keys
argument_list|(
name|mutable_rep_key
argument_list|,
name|rep_key
argument_list|)
condition|)
block|{
name|parent_noderev
operator|->
name|data_key
operator|=
name|mutable_rep_key
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|parent
operator|->
name|id
argument_list|,
name|parent_noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Read the representation, then use it to get the string that holds      the entries list.  Parse that list into a skel, and parse *that*      into a hash. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents
argument_list|(
operator|&
name|str
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|entries_skel
operator|=
name|svn_skel__parse
argument_list|(
name|str
operator|.
name|data
argument_list|,
name|str
operator|.
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries_skel
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__parse_entries_skel
argument_list|(
operator|&
name|entries
argument_list|,
name|entries_skel
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find NAME in the ENTRIES skel.  */
if|if
condition|(
name|entries
condition|)
name|id
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If we never found ID in ENTRIES (perhaps because there are no      ENTRIES, perhaps because ID just isn't in the existing ENTRIES      ... it doesn't matter), return an error.  */
if|if
condition|(
operator|!
name|id
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_ENTRY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Delete failed: directory has no entry '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Use the ID of this ENTRY to get the entry's node.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|svn_fs_base__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If mutable, remove it and any mutable children from db. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_delete_if_mutable
argument_list|(
name|parent
operator|->
name|fs
argument_list|,
name|id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove this entry from its parent's entries list. */
name|svn_hash_sets
argument_list|(
name|entries
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Replace the old entries list with the new one. */
block|{
name|svn_stream_t
modifier|*
name|ws
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|unparsed_entries
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__unparse_entries_skel
argument_list|(
operator|&
name|entries_skel
argument_list|,
name|entries
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|unparsed_entries
operator|=
name|svn_skel__unparse
argument_list|(
name|entries_skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_write_stream
argument_list|(
operator|&
name|ws
argument_list|,
name|fs
argument_list|,
name|mutable_rep_key
argument_list|,
name|txn_id
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|unparsed_entries
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|ws
argument_list|,
name|unparsed_entries
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|ws
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_remove_node
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Fetch the node. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If immutable, do nothing and return immediately. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|node
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted removal of immutable node"
argument_list|)
argument_list|)
return|;
comment|/* Get a fresh node-revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete any mutable property representation. */
if|if
condition|(
name|noderev
operator|->
name|prop_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__delete_rep_if_mutable
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|prop_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete any mutable data representation. */
if|if
condition|(
name|noderev
operator|->
name|data_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__delete_rep_if_mutable
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|data_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete any mutable edit representation (files only). */
if|if
condition|(
name|noderev
operator|->
name|edit_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__delete_rep_if_mutable
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|edit_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete the node revision itself. */
return|return
name|svn_fs_base__delete_node_revision
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|noderev
operator|->
name|predecessor_id
operator|==
name|NULL
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_delete_if_mutable
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Get the node. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If immutable, do nothing and return immediately. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|node
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Else it's mutable.  Recurse on directories... */
if|if
condition|(
name|node
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Loop over hash entries */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|val
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|dirent
operator|=
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_delete_if_mutable
argument_list|(
name|fs
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ... then delete the node itself, any mutable representations and      strings it points to, and possibly its node-origins record. */
return|return
name|svn_fs_base__dag_remove_node
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_make_file
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Call our little helper function */
return|return
name|make_entry
argument_list|(
name|child_p
argument_list|,
name|parent
argument_list|,
name|parent_path
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_make_dir
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Call our little helper function */
return|return
name|make_entry
argument_list|(
name|child_p
argument_list|,
name|parent
argument_list|,
name|parent_path
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to get textual contents of a *non*-file node"
argument_list|)
argument_list|)
return|;
comment|/* Go get a fresh node-revision for FILE. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|file
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Our job is to _return_ a stream on the file's contents, so the      stream has to be trail-independent.  Here, we pass NULL to tell      the stream that we're not providing it a trail that lives across      reads.  This means the stream will do each read in a one-off,      temporary trail.  */
return|return
name|svn_fs_base__rep_contents_read_stream
argument_list|(
name|contents
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
operator|->
name|data_key
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
comment|/* Note that we're not registering any `close' func, because there's      nothing to cleanup outside of our trail.  When the trail is      freed, the stream/baton will be too. */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to get length of a *non*-file node"
argument_list|)
argument_list|)
return|;
comment|/* Go get a fresh node-revision for FILE, and . */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|file
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_size
argument_list|(
name|length
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
operator|->
name|data_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_checksum_kind_t
name|checksum_kind
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to get checksum of a *non*-file node"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|file
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noderev
operator|->
name|data_key
condition|)
block|{
operator|*
name|checksum
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|checksum_kind
operator|==
name|svn_checksum_md5
condition|)
return|return
name|svn_fs_base__rep_contents_checksums
argument_list|(
name|checksum
argument_list|,
name|NULL
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
operator|->
name|data_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
elseif|else
if|if
condition|(
name|checksum_kind
operator|==
name|svn_checksum_sha1
condition|)
return|return
name|svn_fs_base__rep_contents_checksums
argument_list|(
name|NULL
argument_list|,
name|checksum
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
operator|->
name|data_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_CHECKSUM_KIND
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_edit_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|file
operator|->
name|fs
decl_stmt|;
comment|/* just for nicer indentation */
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|mutable_rep_key
decl_stmt|;
name|svn_stream_t
modifier|*
name|ws
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set textual contents of a *non*-file node"
argument_list|)
argument_list|)
return|;
comment|/* Make sure our node is mutable. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|file
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set textual contents of an immutable node"
argument_list|)
argument_list|)
return|;
comment|/* Get the node revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|file
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this node already has an EDIT-DATA-KEY, destroy the data      associated with that key.  */
if|if
condition|(
name|noderev
operator|->
name|edit_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__delete_rep_if_mutable
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|edit_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, let's ensure that we have a new EDIT-DATA-KEY available for      use. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_mutable_rep
argument_list|(
operator|&
name|mutable_rep_key
argument_list|,
name|NULL
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We made a new rep, so update the node revision. */
name|noderev
operator|->
name|edit_key
operator|=
name|mutable_rep_key
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|file
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return a writable stream with which to set new contents. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_write_stream
argument_list|(
operator|&
name|ws
argument_list|,
name|fs
argument_list|,
name|mutable_rep_key
argument_list|,
name|txn_id
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|ws
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_finalize_edits
parameter_list|(
name|dag_node_t
modifier|*
name|file
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|file
operator|->
name|fs
decl_stmt|;
comment|/* just for nicer indentation */
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_data_key
decl_stmt|,
modifier|*
name|new_data_key
decl_stmt|,
modifier|*
name|useless_data_key
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|data_key_uniquifier
init|=
name|NULL
decl_stmt|;
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|,
modifier|*
name|sha1_checksum
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set textual contents of a *non*-file node"
argument_list|)
argument_list|)
return|;
comment|/* Make sure our node is mutable. */
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|file
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set textual contents of an immutable node"
argument_list|)
argument_list|)
return|;
comment|/* Get the node revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|file
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this node has no EDIT-DATA-KEY, this is a no-op. */
if|if
condition|(
operator|!
name|noderev
operator|->
name|edit_key
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Get our representation's checksums. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_checksums
argument_list|(
operator|&
name|md5_checksum
argument_list|,
operator|&
name|sha1_checksum
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|edit_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If our caller provided a checksum of the right kind to compare, do so. */
if|if
condition|(
name|checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|test_checksum
decl_stmt|;
if|if
condition|(
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_md5
condition|)
name|test_checksum
operator|=
name|md5_checksum
expr_stmt|;
elseif|else
if|if
condition|(
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_sha1
condition|)
name|test_checksum
operator|=
name|sha1_checksum
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_CHECKSUM_KIND
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|checksum
argument_list|,
name|test_checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|checksum
argument_list|,
name|test_checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch on representation '%s'"
argument_list|)
argument_list|,
name|noderev
operator|->
name|edit_key
argument_list|)
return|;
block|}
comment|/* Now, we want to delete the old representation and replace it with      the new.  Of course, we don't actually delete anything until      everything is being properly referred to by the node-revision      skel.       Now, if the result of all this editing is that we've created a      representation that describes content already represented      immutably in our database, we don't even need to keep these edits.      We can simply point our data_key at that pre-existing      representation and throw away our work!  In this situation,      though, we'll need a unique ID to help other code distinguish      between "the contents weren't touched" and "the contents were      touched but still look the same" (to state it oversimply).  */
name|old_data_key
operator|=
name|noderev
operator|->
name|data_key
expr_stmt|;
if|if
condition|(
name|sha1_checksum
operator|&&
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_REP_SHARING_FORMAT
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_bdb__get_checksum_rep
argument_list|(
operator|&
name|new_data_key
argument_list|,
name|fs
argument_list|,
name|sha1_checksum
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|useless_data_key
operator|=
name|noderev
operator|->
name|edit_key
expr_stmt|;
name|err
operator|=
name|svn_fs_bdb__reserve_rep_reuse_id
argument_list|(
operator|&
name|data_key_uniquifier
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_CHECKSUM_REP
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|new_data_key
operator|=
name|noderev
operator|->
name|edit_key
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_data_key
operator|=
name|noderev
operator|->
name|edit_key
expr_stmt|;
block|}
name|noderev
operator|->
name|data_key
operator|=
name|new_data_key
expr_stmt|;
name|noderev
operator|->
name|data_key_uniquifier
operator|=
name|data_key_uniquifier
expr_stmt|;
name|noderev
operator|->
name|edit_key
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|file
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only *now* can we safely destroy the old representation (if it      even existed in the first place). */
if|if
condition|(
name|old_data_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__delete_rep_if_mutable
argument_list|(
name|fs
argument_list|,
name|old_data_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we've got a discardable rep (probably because we ended up      re-using a preexisting one), throw out the discardable rep. */
if|if
condition|(
name|useless_data_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__delete_rep_if_mutable
argument_list|(
name|fs
argument_list|,
name|useless_data_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|dag_node_t
modifier|*
name|svn_fs_base__dag_dup
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Allocate our new node. */
name|dag_node_t
modifier|*
name|new_node
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|)
decl_stmt|;
name|new_node
operator|->
name|fs
operator|=
name|node
operator|->
name|fs
expr_stmt|;
name|new_node
operator|->
name|id
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|kind
operator|=
name|node
operator|->
name|kind
expr_stmt|;
name|new_node
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|node
operator|->
name|created_path
argument_list|)
expr_stmt|;
return|return
name|new_node
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_open
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
comment|/* Ensure that NAME exists in PARENT's entry list. */
name|SVN_ERR
argument_list|(
name|dir_entry_id_from_node
argument_list|(
operator|&
name|node_id
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node_id
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to open non-existent child node '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to open node with an illegal name '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Now get the node that was requested. */
return|return
name|svn_fs_base__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|svn_fs_base__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
name|node_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_copy
parameter_list|(
name|dag_node_t
modifier|*
name|to_node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry
parameter_list|,
name|dag_node_t
modifier|*
name|from_node
parameter_list|,
name|svn_boolean_t
name|preserve_history
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|preserve_history
condition|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_id
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|from_node
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|src_id
init|=
name|svn_fs_base__dag_get_id
argument_list|(
name|from_node
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_txn_id
init|=
name|NULL
decl_stmt|;
comment|/* Make a copy of the original node revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|from_node
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reserve a copy ID for this new copy. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__reserve_copy_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a successor with its predecessor pointing at the copy          source. */
name|noderev
operator|->
name|predecessor_id
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|src_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|noderev
operator|->
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|svn_fs_base__dag_get_created_path
argument_list|(
name|to_node
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__create_successor
argument_list|(
operator|&
name|id
argument_list|,
name|fs
argument_list|,
name|src_id
argument_list|,
name|noderev
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Translate FROM_REV into a transaction ID. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rev_get_txn_id
argument_list|(
operator|&
name|from_txn_id
argument_list|,
name|fs
argument_list|,
name|from_rev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that we've done the copy, we need to add the information          about the copy to the `copies' table, using the COPY_ID we          reserved above.  */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__create_copy
argument_list|(
name|fs
argument_list|,
name|copy_id
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|from_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|from_txn_id
argument_list|,
name|id
argument_list|,
name|copy_kind_real
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, add the COPY_ID to the transaction's list of copies          so that, if this transaction is aborted, the `copies' table          entry we added above will be cleaned up. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__add_txn_copy
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|copy_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* don't preserve history */
block|{
name|id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|from_node
argument_list|)
expr_stmt|;
block|}
comment|/* Set the entry in to_node to the new id. */
return|return
name|svn_fs_base__dag_set_entry
argument_list|(
name|to_node
argument_list|,
name|entry
argument_list|,
name|id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Deltification ***/
end_comment

begin_comment
comment|/* Maybe change the representation identified by TARGET_REP_KEY to be    a delta against the representation identified by SOURCE_REP_KEY.    Some reasons why we wouldn't include:        - TARGET_REP_KEY and SOURCE_REP_KEY are the same key.        - TARGET_REP_KEY's representation isn't mutable in TXN_ID (if         TXN_ID is non-NULL).        - The delta provides less space savings that a fulltext (this is         a detail handled by lower logic layers, not this function).     Do this work in TRAIL, using POOL for necessary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_deltify_mutable_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|target_rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|source_rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|target_rep_key
operator|&&
name|source_rep_key
operator|&&
operator|(
name|strcmp
argument_list|(
name|target_rep_key
argument_list|,
name|source_rep_key
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|txn_id
condition|)
block|{
name|representation_t
modifier|*
name|target_rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|target_rep
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|target_rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_rep
operator|->
name|txn_id
argument_list|,
name|txn_id
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_fs_base__rep_deltify
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|target_rep_key
argument_list|,
name|source_rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_deltify
parameter_list|(
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|svn_boolean_t
name|props_only
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|source_nr
decl_stmt|,
modifier|*
name|target_nr
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|/* Get node revisions for the two nodes.  */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|target_nr
argument_list|,
name|fs
argument_list|,
name|target
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|source_nr
argument_list|,
name|fs
argument_list|,
name|source
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If TARGET and SOURCE both have properties, and are not sharing a      property key, deltify TARGET's properties.  */
name|SVN_ERR
argument_list|(
name|maybe_deltify_mutable_rep
argument_list|(
name|target_nr
operator|->
name|prop_key
argument_list|,
name|source_nr
operator|->
name|prop_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are not only attending to properties, and if TARGET and      SOURCE both have data, and are not sharing a data key, deltify      TARGET's data.  */
if|if
condition|(
operator|!
name|props_only
condition|)
name|SVN_ERR
argument_list|(
name|maybe_deltify_mutable_rep
argument_list|(
name|target_nr
operator|->
name|data_key
argument_list|,
name|source_nr
operator|->
name|data_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Maybe store a `checksum-reps' index record for the representation whose    key is REP.  (If there's already a rep for this checksum, we don't    bother overwriting it.)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_store_checksum_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|rep
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|trail
operator|->
name|fs
decl_stmt|;
name|svn_checksum_t
modifier|*
name|sha1_checksum
decl_stmt|;
comment|/* We want the SHA1 checksum, if any. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_checksums
argument_list|(
name|NULL
argument_list|,
operator|&
name|sha1_checksum
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_checksum
condition|)
block|{
name|err
operator|=
name|svn_fs_bdb__set_checksum_rep
argument_list|(
name|fs
argument_list|,
name|sha1_checksum
argument_list|,
name|rep
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_ALREADY_EXISTS
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_index_checksums
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|node_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|node_rev
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node_rev
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
name|node_rev
operator|->
name|data_key
condition|)
name|SVN_ERR
argument_list|(
name|maybe_store_checksum_rep
argument_list|(
name|node_rev
operator|->
name|data_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_rev
operator|->
name|prop_key
condition|)
name|SVN_ERR
argument_list|(
name|maybe_store_checksum_rep
argument_list|(
name|node_rev
operator|->
name|prop_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Committing ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_commit_txn
parameter_list|(
name|svn_revnum_t
modifier|*
name|new_rev
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|revision_t
name|revision
decl_stmt|;
name|svn_string_t
name|date
decl_stmt|;
name|apr_hash_t
modifier|*
name|txnprops
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|txn
operator|->
name|id
decl_stmt|;
comment|/* Remove any temporary transaction properties initially created by      begin_txn().  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__txn_proplist_in_trail
argument_list|(
operator|&
name|txnprops
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add new revision entry to `revisions' table. */
name|revision
operator|.
name|txn_id
operator|=
name|txn_id
expr_stmt|;
operator|*
name|new_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_rev
argument_list|(
name|new_rev
argument_list|,
name|fs
argument_list|,
operator|&
name|revision
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__set_txn_prop
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|,
name|NULL
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__set_txn_prop
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|,
name|NULL
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Promote the unfinished transaction to a committed one. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__txn_make_committed
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
operator|*
name|new_rev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a date on the commit.  We wait until now to fetch the date,      so it's definitely newer than any previous revision's date. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__set_rev_prop
argument_list|(
name|fs
argument_list|,
operator|*
name|new_rev
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|NULL
argument_list|,
operator|&
name|date
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Comparison. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__things_different
parameter_list|(
name|svn_boolean_t
modifier|*
name|props_changed
parameter_list|,
name|svn_boolean_t
modifier|*
name|contents_changed
parameter_list|,
name|dag_node_t
modifier|*
name|node1
parameter_list|,
name|dag_node_t
modifier|*
name|node2
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev1
decl_stmt|,
modifier|*
name|noderev2
decl_stmt|;
comment|/* If we have no place to store our results, don't bother doing      anything. */
if|if
condition|(
operator|!
name|props_changed
operator|&&
operator|!
name|contents_changed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* The node revision skels for these two nodes. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev1
argument_list|,
name|node1
operator|->
name|fs
argument_list|,
name|node1
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev2
argument_list|,
name|node2
operator|->
name|fs
argument_list|,
name|node2
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compare property keys. */
if|if
condition|(
name|props_changed
operator|!=
name|NULL
condition|)
operator|*
name|props_changed
operator|=
operator|(
operator|!
name|svn_fs_base__same_keys
argument_list|(
name|noderev1
operator|->
name|prop_key
argument_list|,
name|noderev2
operator|->
name|prop_key
argument_list|)
operator|)
expr_stmt|;
comment|/* Compare contents keys and their (optional) uniquifiers. */
if|if
condition|(
name|contents_changed
operator|!=
name|NULL
condition|)
operator|*
name|contents_changed
operator|=
operator|(
operator|!
operator|(
name|svn_fs_base__same_keys
argument_list|(
name|noderev1
operator|->
name|data_key
argument_list|,
name|noderev2
operator|->
name|data_key
argument_list|)
comment|/* Technically, these uniquifiers aren't used and "keys",              but keys are base-36 stringified numbers, so we'll take              this liberty. */
operator|&&
operator|(
name|svn_fs_base__same_keys
argument_list|(
name|noderev1
operator|->
name|data_key_uniquifier
argument_list|,
name|noderev2
operator|->
name|data_key_uniquifier
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Mergeinfo tracking stuff ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_get_mergeinfo_stats
parameter_list|(
name|svn_boolean_t
modifier|*
name|has_mergeinfo
parameter_list|,
name|apr_int64_t
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|node_rev
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
init|=
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|node_rev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mergeinfo
condition|)
operator|*
name|has_mergeinfo
operator|=
name|node_rev
operator|->
name|has_mergeinfo
expr_stmt|;
if|if
condition|(
name|count
condition|)
operator|*
name|count
operator|=
name|node_rev
operator|->
name|mergeinfo_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_set_has_mergeinfo
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_boolean_t
name|has_mergeinfo
parameter_list|,
name|svn_boolean_t
modifier|*
name|had_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|node_rev
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
init|=
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__test_required_feature_format
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
literal|"mergeinfo"
argument_list|,
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|node
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted merge tracking info change on "
literal|"immutable node"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|node_rev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|had_mergeinfo
operator|=
name|node_rev
operator|->
name|has_mergeinfo
expr_stmt|;
comment|/* Are we changing the node? */
if|if
condition|(
operator|(
operator|!
name|has_mergeinfo
operator|)
operator|!=
operator|(
operator|!
operator|*
name|had_mergeinfo
operator|)
condition|)
block|{
comment|/* Note the new has-mergeinfo state. */
name|node_rev
operator|->
name|has_mergeinfo
operator|=
name|has_mergeinfo
expr_stmt|;
comment|/* Increment or decrement the mergeinfo count as necessary. */
if|if
condition|(
name|has_mergeinfo
condition|)
name|node_rev
operator|->
name|mergeinfo_count
operator|++
expr_stmt|;
else|else
name|node_rev
operator|->
name|mergeinfo_count
operator|--
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|node_rev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__dag_adjust_mergeinfo_count
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_int64_t
name|count_delta
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|node_rev
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
init|=
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__test_required_feature_format
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
literal|"mergeinfo"
argument_list|,
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_base__dag_check_mutable
argument_list|(
name|node
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted mergeinfo count change on "
literal|"immutable node"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|count_delta
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|node_rev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_rev
operator|->
name|mergeinfo_count
operator|=
name|node_rev
operator|->
name|mergeinfo_count
operator|+
name|count_delta
expr_stmt|;
if|if
condition|(
operator|(
name|node_rev
operator|->
name|mergeinfo_count
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|node
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
operator|(
name|node_rev
operator|->
name|mergeinfo_count
operator|>
literal|1
operator|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Invalid value (%%%s) for node "
literal|"revision mergeinfo count"
argument_list|)
argument_list|,
name|APR_INT64_T_FMT
argument_list|)
argument_list|,
name|node_rev
operator|->
name|mergeinfo_count
argument_list|)
return|;
return|return
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|node_rev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

