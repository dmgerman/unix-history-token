begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * dirent_uri.c:   a library to manipulate URIs and directory entries.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_comment
comment|/* The canonical empty path.  Can this be changed?  Well, change the empty    test below and the path library will work, not so sure about the fs/wc    libraries. */
end_comment

begin_define
define|#
directive|define
name|SVN_EMPTY_PATH
value|""
end_define

begin_comment
comment|/* TRUE if s is the canonical empty path, FALSE otherwise */
end_comment

begin_define
define|#
directive|define
name|SVN_PATH_IS_EMPTY
parameter_list|(
name|s
parameter_list|)
value|((s)[0] == '\0')
end_define

begin_comment
comment|/* TRUE if s,n is the platform's empty path ("."), FALSE otherwise. Can    this be changed?  Well, the path library will work, not so sure about    the OS! */
end_comment

begin_define
define|#
directive|define
name|SVN_PATH_IS_PLATFORM_EMPTY
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|((n) == 1&& (s)[0] == '.')
end_define

begin_comment
comment|/* This check must match the check on top of dirent_uri-tests.c and    path-tests.c */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SVN_USE_DOS_PATHS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Path type definition. Used only by internal functions. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|path_type_t
block|{
name|type_uri
block|,
name|type_dirent
block|,
name|type_relpath
block|}
name|path_type_t
typedef|;
end_typedef

begin_comment
comment|/**** Forward declarations *****/
end_comment

begin_function_decl
specifier|static
name|svn_boolean_t
name|relpath_is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**** Internal implementation functions *****/
end_comment

begin_comment
comment|/* Return an internal-style new path based on PATH, allocated in POOL.  *  * "Internal-style" means that separators are all '/'.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|internal_style
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
literal|'/'
operator|!=
name|SVN_PATH_LOCAL_SEPARATOR
block|{
name|char
modifier|*
name|p
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|path
operator|=
name|p
expr_stmt|;
comment|/* Convert all local-style separators to the canonical ones. */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|SVN_PATH_LOCAL_SEPARATOR
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Locale insensitive tolower() for converting parts of dirents and urls    while canonicalizing */
end_comment

begin_function
specifier|static
name|char
name|canonicalize_to_lower
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<
literal|'A'
operator|||
name|c
operator|>
literal|'Z'
condition|)
return|return
name|c
return|;
else|else
return|return
call|(
name|char
call|)
argument_list|(
name|c
operator|-
literal|'A'
operator|+
literal|'a'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Locale insensitive toupper() for converting parts of dirents and urls    while canonicalizing */
end_comment

begin_function
specifier|static
name|char
name|canonicalize_to_upper
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
condition|)
return|return
name|c
return|;
else|else
return|return
call|(
name|char
call|)
argument_list|(
name|c
operator|-
literal|'a'
operator|+
literal|'A'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Calculates the length of the dirent absolute or non absolute root in    DIRENT, return 0 if dirent is not rooted  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|dirent_root_length
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|dirent
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|len
operator|>
literal|2
operator|&&
name|dirent
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|?
literal|3
else|:
literal|2
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|dirent
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|apr_size_t
name|i
init|=
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|dirent
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|len
condition|)
return|return
name|len
return|;
comment|/* Cygwin drive alias, invalid path on WIN32 */
name|i
operator|++
expr_stmt|;
comment|/* Skip '/' */
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|dirent
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
if|if
condition|(
name|len
operator|>=
literal|1
operator|&&
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the length of substring necessary to encompass the entire  * previous dirent segment in DIRENT, which should be a LEN byte string.  *  * A trailing slash will not be included in the returned length except  * in the case in which DIRENT is absolute and there are no more  * previous segments.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|dirent_previous_segment
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|--
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|dirent
index|[
name|len
index|]
operator|!=
literal|'/'
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
operator|&&
operator|(
name|dirent
index|[
name|len
index|]
operator|!=
literal|':'
operator|||
name|len
operator|!=
literal|1
operator|)
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
condition|)
operator|--
name|len
expr_stmt|;
comment|/* check if the remaining segment including trailing '/' is a root dirent */
if|if
condition|(
name|dirent_root_length
argument_list|(
name|dirent
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|==
name|len
operator|+
literal|1
condition|)
return|return
name|len
operator|+
literal|1
return|;
else|else
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Calculates the length occupied by the schema defined root of URI */
end_comment

begin_function
specifier|static
name|apr_size_t
name|uri_schema_root_length
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uri
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|uri
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
name|i
operator|<
name|len
operator|-
literal|1
operator|&&
name|uri
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* We have an absolute uri */
if|if
condition|(
name|i
operator|==
literal|5
operator|&&
name|strncmp
argument_list|(
literal|"file"
argument_list|,
name|uri
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|7
return|;
comment|/* file:// */
else|else
block|{
for|for
control|(
name|i
operator|+=
literal|2
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|uri
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
return|return
name|i
return|;
return|return
name|len
return|;
comment|/* Only a hostname is found */
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if svn_dirent_is_absolute(dirent) or when dirent has    a non absolute root. (E.g. '/' or 'F:' on Windows) */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|dirent_is_rooted
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dirent
condition|)
return|return
name|FALSE
return|;
comment|/* Root on all systems */
if|if
condition|(
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
name|TRUE
return|;
comment|/* On Windows, dirent is also absolute when it starts with 'H:' or 'H:/'      where 'H' is any letter. */
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
operator|(
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
operator|)
operator|&&
operator|(
name|dirent
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return the length of substring necessary to encompass the entire  * previous relpath segment in RELPATH, which should be a LEN byte string.  *  * A trailing slash will not be included in the returned length.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|relpath_previous_segment
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|--
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|relpath
index|[
name|len
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|len
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Return the length of substring necessary to encompass the entire  * previous uri segment in URI, which should be a LEN byte string.  *  * A trailing slash will not be included in the returned length except  * in the case in which URI is absolute and there are no more  * previous segments.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|uri_previous_segment
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|apr_size_t
name|root_length
decl_stmt|;
name|apr_size_t
name|i
init|=
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|root_length
operator|=
name|uri_schema_root_length
argument_list|(
name|uri
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|root_length
operator|&&
name|uri
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|len
operator|>
literal|1
operator|&&
operator|*
name|uri
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return the canonicalized version of PATH, of type TYPE, allocated in  * POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|canonicalize
parameter_list|(
name|path_type_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|canon
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|apr_size_t
name|seglen
decl_stmt|;
name|apr_size_t
name|schemelen
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|canon_segments
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|url
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|schema_data
init|=
name|NULL
decl_stmt|;
comment|/* "" is already canonical, so just return it; note that later code      depends on path not being zero-length.  */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|type
operator|!=
name|type_uri
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
name|dst
operator|=
name|canon
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is supposed to be an URI, it should start with      "scheme://".  We'll copy the scheme, host name, etc. to DST and      set URL = TRUE. */
name|src
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|type_uri
condition|)
block|{
name|assert
argument_list|(
operator|*
name|src
operator|!=
literal|'/'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|':'
operator|)
condition|)
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|':'
operator|&&
operator|*
operator|(
name|src
operator|+
literal|1
operator|)
operator|==
literal|'/'
operator|&&
operator|*
operator|(
name|src
operator|+
literal|2
operator|)
operator|==
literal|'/'
condition|)
block|{
specifier|const
name|char
modifier|*
name|seg
decl_stmt|;
name|url
operator|=
name|TRUE
expr_stmt|;
comment|/* Found a scheme, convert to lowercase and copy to dst. */
name|src
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|':'
condition|)
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_lower
argument_list|(
operator|(
operator|*
name|src
operator|++
operator|)
argument_list|)
expr_stmt|;
name|schemelen
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|':'
expr_stmt|;
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|src
operator|+=
literal|3
expr_stmt|;
name|schemelen
operator|+=
literal|3
expr_stmt|;
comment|/* This might be the hostname */
name|seg
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|'@'
operator|)
condition|)
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'@'
condition|)
block|{
comment|/* Copy the username& password. */
name|seglen
operator|=
name|src
operator|-
name|seg
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|seg
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|seglen
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
else|else
name|src
operator|=
name|seg
expr_stmt|;
comment|/* Found a hostname, convert to lowercase and copy to dst. */
if|if
condition|(
operator|*
name|src
operator|==
literal|'['
condition|)
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
expr_stmt|;
comment|/* Copy '[' */
while|while
condition|(
operator|*
name|src
operator|==
literal|':'
operator|||
operator|(
operator|*
name|src
operator|>=
literal|'0'
operator|&&
operator|(
operator|*
name|src
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|*
name|src
operator|>=
literal|'a'
operator|&&
operator|(
operator|*
name|src
operator|<=
literal|'f'
operator|)
operator|)
operator|||
operator|(
operator|*
name|src
operator|>=
literal|'A'
operator|&&
operator|(
operator|*
name|src
operator|<=
literal|'F'
operator|)
operator|)
condition|)
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_lower
argument_list|(
operator|(
operator|*
name|src
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|']'
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
expr_stmt|;
comment|/* Copy ']' */
block|}
else|else
while|while
condition|(
operator|*
name|src
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|':'
operator|)
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_lower
argument_list|(
operator|(
operator|*
name|src
operator|++
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|':'
condition|)
block|{
comment|/* We probably have a port number: Is it a default portnumber                  which doesn't belong in a canonical url? */
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'8'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|src
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
operator|!
name|src
index|[
literal|3
index|]
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|canon
argument_list|,
literal|"http:"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|src
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'4'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'4'
operator|&&
name|src
index|[
literal|3
index|]
operator|==
literal|'3'
operator|&&
operator|(
name|src
index|[
literal|4
index|]
operator|==
literal|'/'
operator|||
operator|!
name|src
index|[
literal|4
index|]
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|canon
argument_list|,
literal|"https:"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|src
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'3'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'6'
operator|&&
name|src
index|[
literal|3
index|]
operator|==
literal|'9'
operator|&&
name|src
index|[
literal|4
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|src
index|[
literal|5
index|]
operator|==
literal|'/'
operator|||
operator|!
name|src
index|[
literal|5
index|]
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|canon
argument_list|,
literal|"svn:"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|src
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|!
name|src
index|[
literal|1
index|]
condition|)
block|{
name|src
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|src
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|'/'
operator|)
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_lower
argument_list|(
operator|(
operator|*
name|src
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy trailing slash, or null-terminator. */
operator|*
operator|(
name|dst
operator|)
operator|=
operator|*
operator|(
name|src
operator|)
expr_stmt|;
comment|/* Move src and dst forward only if we are not            * at null-terminator yet. */
if|if
condition|(
operator|*
name|src
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|schema_data
operator|=
name|dst
expr_stmt|;
block|}
name|canon_segments
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Copy to DST any separator or drive letter that must come before the      first regular path segment. */
if|if
condition|(
operator|!
name|url
operator|&&
name|type
operator|!=
name|type_relpath
condition|)
block|{
name|src
operator|=
name|path
expr_stmt|;
comment|/* If this is an absolute path, then just copy over the initial          separator character. */
if|if
condition|(
operator|*
name|src
operator|==
literal|'/'
condition|)
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* On Windows permit two leading separator characters which means an            * UNC path. */
if|if
condition|(
operator|(
name|type
operator|==
name|type_dirent
operator|)
operator|&&
operator|*
name|src
operator|==
literal|'/'
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
block|}
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* On Windows the first segment can be a drive letter, which we normalize          to upper case. */
elseif|else
if|if
condition|(
name|type
operator|==
name|type_dirent
operator|&&
operator|(
operator|(
operator|*
name|src
operator|>=
literal|'a'
operator|&&
operator|*
name|src
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|src
operator|>=
literal|'A'
operator|&&
operator|*
name|src
operator|<=
literal|'Z'
operator|)
operator|)
operator|&&
operator|(
name|src
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_upper
argument_list|(
operator|*
operator|(
name|src
operator|++
operator|)
argument_list|)
expr_stmt|;
comment|/* Leave the ':' to be processed as (or as part of) a path segment              by the following code block, so we need not care whether it has              a slash after it. */
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
block|}
while|while
condition|(
operator|*
name|src
condition|)
block|{
comment|/* Parse each segment, finding the closing '/' (which might look          like '%2F' for URIs).  */
specifier|const
name|char
modifier|*
name|next
init|=
name|src
decl_stmt|;
name|apr_size_t
name|slash_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|next
operator|&&
operator|(
name|next
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|!
operator|(
name|type
operator|==
name|type_uri
operator|&&
name|next
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|next
index|[
literal|1
index|]
operator|==
literal|'2'
operator|&&
name|canonicalize_to_upper
argument_list|(
name|next
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'F'
operator|)
operator|)
condition|)
block|{
operator|++
name|next
expr_stmt|;
block|}
comment|/* Record how long our "slash" is. */
if|if
condition|(
name|next
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|slash_len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|type_uri
operator|&&
name|next
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
name|slash_len
operator|=
literal|3
expr_stmt|;
name|seglen
operator|=
name|next
operator|-
name|src
expr_stmt|;
if|if
condition|(
name|seglen
operator|==
literal|0
operator|||
operator|(
name|seglen
operator|==
literal|1
operator|&&
name|src
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|type
operator|==
name|type_uri
operator|&&
name|seglen
operator|==
literal|3
operator|&&
name|src
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'2'
operator|&&
name|canonicalize_to_upper
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'E'
operator|)
condition|)
block|{
comment|/* Empty or noop segment, so do nothing.  (For URIs, '%2E'              is equivalent to '.').  */
block|}
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* If this is the first path segment of a file:// URI and it contains a          windows drive letter, convert the drive letter to upper case. */
elseif|else
if|if
condition|(
name|url
operator|&&
name|canon_segments
operator|==
literal|1
operator|&&
name|seglen
operator|==
literal|2
operator|&&
operator|(
name|strncmp
argument_list|(
name|canon
argument_list|,
literal|"file:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|src
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|src
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_upper
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
operator|*
name|next
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|*
name|next
expr_stmt|;
name|canon_segments
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
else|else
block|{
comment|/* An actual segment, append it to the destination path */
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|seglen
expr_stmt|;
if|if
condition|(
name|slash_len
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|canon_segments
operator|++
expr_stmt|;
block|}
comment|/* Skip over trailing slash to the next segment. */
name|src
operator|=
name|next
operator|+
name|slash_len
expr_stmt|;
block|}
comment|/* Remove the trailing slash if there was at least one    * canonical segment and the last segment ends with a slash.    *    * But keep in mind that, for URLs, the scheme counts as a    * canonical segment -- so if path is ONLY a scheme (such    * as "https://") we should NOT remove the trailing slash. */
if|if
condition|(
operator|(
name|canon_segments
operator|>
literal|0
operator|&&
operator|*
operator|(
name|dst
operator|-
literal|1
operator|)
operator|==
literal|'/'
operator|)
operator|&&
operator|!
operator|(
name|url
operator|&&
name|path
index|[
name|schemelen
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|dst
operator|--
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* Skip leading double slashes when there are less than 2    * canon segments. UNC paths *MUST* have two segments. */
if|if
condition|(
operator|(
name|type
operator|==
name|type_dirent
operator|)
operator|&&
name|canon
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|canon
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|canon_segments
operator|<
literal|2
condition|)
return|return
name|canon
operator|+
literal|1
return|;
else|else
block|{
comment|/* Now we're sure this is a valid UNC path, convert the server name              (the first path segment) to lowercase as Windows treats it as case              insensitive.              Note: normally the share name is treated as case insensitive too,              but it seems to be possible to configure Samba to treat those as              case sensitive, so better leave that alone. */
for|for
control|(
name|dst
operator|=
name|canon
operator|+
literal|2
init|;
operator|*
name|dst
operator|&&
operator|*
name|dst
operator|!=
literal|'/'
condition|;
name|dst
operator|++
control|)
operator|*
name|dst
operator|=
name|canonicalize_to_lower
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
comment|/* Check the normalization of characters in a uri */
if|if
condition|(
name|schema_data
condition|)
block|{
name|int
name|need_extra
init|=
literal|0
decl_stmt|;
name|src
operator|=
name|schema_data
expr_stmt|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'/'
case|:
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
name|svn_ctype_isxdigit
argument_list|(
operator|*
operator|(
name|src
operator|+
literal|1
operator|)
argument_list|)
operator|||
operator|!
name|svn_ctype_isxdigit
argument_list|(
operator|*
operator|(
name|src
operator|+
literal|2
operator|)
argument_list|)
condition|)
name|need_extra
operator|+=
literal|2
expr_stmt|;
else|else
name|src
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|svn_uri__char_validity
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
index|]
condition|)
name|need_extra
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|need_extra
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|pre_schema_size
init|=
call|(
name|apr_size_t
call|)
argument_list|(
name|schema_data
operator|-
name|canon
argument_list|)
decl_stmt|;
name|dst
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
call|(
name|apr_size_t
call|)
argument_list|(
name|src
operator|-
name|canon
argument_list|)
operator|+
name|need_extra
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|canon
argument_list|,
name|pre_schema_size
argument_list|)
expr_stmt|;
name|canon
operator|=
name|dst
expr_stmt|;
name|dst
operator|+=
name|pre_schema_size
expr_stmt|;
block|}
else|else
name|dst
operator|=
name|schema_data
expr_stmt|;
name|src
operator|=
name|schema_data
expr_stmt|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'/'
case|:
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
name|svn_ctype_isxdigit
argument_list|(
operator|*
operator|(
name|src
operator|+
literal|1
operator|)
argument_list|)
operator|||
operator|!
name|svn_ctype_isxdigit
argument_list|(
operator|*
operator|(
name|src
operator|+
literal|2
operator|)
argument_list|)
condition|)
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'%'
expr_stmt|;
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'2'
expr_stmt|;
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'5'
expr_stmt|;
block|}
else|else
block|{
name|char
name|digitz
index|[
literal|3
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
name|digitz
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|++
name|src
operator|)
expr_stmt|;
name|digitz
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|++
name|src
operator|)
expr_stmt|;
name|digitz
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|digitz
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_uri__char_validity
index|[
operator|(
name|unsigned
name|char
operator|)
name|val
index|]
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
else|else
block|{
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
literal|'%'
expr_stmt|;
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_upper
argument_list|(
name|digitz
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|canonicalize_to_upper
argument_list|(
name|digitz
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|svn_uri__char_validity
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
index|]
condition|)
block|{
name|apr_snprintf
argument_list|(
name|dst
argument_list|,
literal|4
argument_list|,
literal|"%%%02X"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|3
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|*
name|src
expr_stmt|;
break|break;
block|}
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|canon
return|;
block|}
end_function

begin_comment
comment|/* Return the string length of the longest common ancestor of PATH1 and PATH2.  * Pass type_uri for TYPE if PATH1 and PATH2 are URIs, and type_dirent if  * PATH1 and PATH2 are regular paths.  *  * If the two paths do not share a common ancestor, return 0.  *  * New strings are allocated in POOL.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|get_longest_ancestor_length
parameter_list|(
name|path_type_t
name|types
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|path1_len
decl_stmt|,
name|path2_len
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|last_dirsep
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
name|svn_boolean_t
name|unc
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|path1_len
operator|=
name|strlen
argument_list|(
name|path1
argument_list|)
expr_stmt|;
name|path2_len
operator|=
name|strlen
argument_list|(
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path1
argument_list|)
operator|||
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path2
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|path1
index|[
name|i
index|]
operator|==
name|path2
index|[
name|i
index|]
condition|)
block|{
comment|/* Keep track of the last directory separator we hit. */
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|last_dirsep
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* If we get to the end of either path, break out. */
if|if
condition|(
operator|(
name|i
operator|==
name|path1_len
operator|)
operator|||
operator|(
name|i
operator|==
name|path2_len
operator|)
condition|)
break|break;
block|}
comment|/* two special cases:      1. '/' is the longest common ancestor of '/' and '/foo' */
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|path1
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|path2
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
comment|/* 2. '' is the longest common ancestor of any non-matching    * strings 'foo' and 'bar' */
if|if
condition|(
name|types
operator|==
name|type_dirent
operator|&&
name|i
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Handle some windows specific cases */
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
name|types
operator|==
name|type_dirent
condition|)
block|{
comment|/* don't count the '//' from UNC paths */
if|if
condition|(
name|last_dirsep
operator|==
literal|1
operator|&&
name|path1
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|path1
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|last_dirsep
operator|=
literal|0
expr_stmt|;
name|unc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* X:/ and X:/foo */
if|if
condition|(
name|i
operator|==
literal|3
operator|&&
name|path1
index|[
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|path1
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
return|return
name|i
return|;
comment|/* Cannot use SVN_ERR_ASSERT here, so we'll have to crash, sorry.        * Note that this assertion triggers only if the code above has        * been broken. The code below relies on this assertion, because        * it uses [i - 1] as index. */
name|assert
argument_list|(
name|i
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* X: and X:/ */
if|if
condition|(
operator|(
name|path1
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|path2
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
name|path1
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
literal|0
return|;
comment|/* X: and X:foo */
if|if
condition|(
name|path1
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
operator|||
name|path2
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
return|return
name|i
return|;
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
comment|/* last_dirsep is now the offset of the last directory separator we      crossed before reaching a non-matching byte.  i is the offset of      that non-matching byte, and is guaranteed to be<= the length of      whichever path is shorter.      If one of the paths is the common part return that. */
if|if
condition|(
operator|(
operator|(
name|i
operator|==
name|path1_len
operator|)
operator|&&
operator|(
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|==
name|path2_len
operator|)
operator|&&
operator|(
name|path1
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|==
name|path1_len
operator|)
operator|&&
operator|(
name|i
operator|==
name|path2_len
operator|)
operator|)
condition|)
return|return
name|i
return|;
else|else
block|{
comment|/* Nothing in common but the root folder '/' or 'X:/' for Windows          dirents. */
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
operator|!
name|unc
condition|)
block|{
comment|/* X:/foo and X:/bar returns X:/ */
if|if
condition|(
operator|(
name|types
operator|==
name|type_dirent
operator|)
operator|&&
name|last_dirsep
operator|==
literal|2
operator|&&
name|path1
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|path1
index|[
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|path2
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|path2
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
return|return
literal|3
return|;
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
if|if
condition|(
name|last_dirsep
operator|==
literal|0
operator|&&
name|path1
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|path2
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
block|}
endif|#
directive|endif
block|}
return|return
name|last_dirsep
return|;
block|}
end_function

begin_comment
comment|/* Determine whether PATH2 is a child of PATH1.  *  * PATH2 is a child of PATH1 if  * 1) PATH1 is empty, and PATH2 is not empty and not an absolute path.  * or  * 2) PATH2 is has n components, PATH1 has x< n components,  *    and PATH1 matches PATH2 in all its x components.  *    Components are separated by a slash, '/'.  *  * Pass type_uri for TYPE if PATH1 and PATH2 are URIs, and type_dirent if  * PATH1 and PATH2 are regular paths.  *  * If PATH2 is not a child of PATH1, return NULL.  *  * If PATH2 is a child of PATH1, and POOL is not NULL, allocate a copy  * of the child part of PATH2 in POOL and return a pointer to the  * newly allocated child part.  *  * If PATH2 is a child of PATH1, and POOL is NULL, return a pointer  * pointing to the child part of PATH2.  * */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|is_child
parameter_list|(
name|path_type_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
comment|/* Allow "" and "foo" or "H:foo" to be parent/child */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path1
argument_list|)
condition|)
comment|/* "" is the parent  */
block|{
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path2
argument_list|)
condition|)
comment|/* "" not a child    */
return|return
name|NULL
return|;
comment|/* check if this is an absolute path */
if|if
condition|(
operator|(
name|type
operator|==
name|type_uri
operator|)
operator|||
operator|(
name|type
operator|==
name|type_dirent
operator|&&
name|dirent_is_rooted
argument_list|(
name|path2
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
else|else
comment|/* everything else is child */
return|return
name|pool
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path2
argument_list|)
else|:
name|path2
return|;
block|}
comment|/* Reach the end of at least one of the paths.  How should we handle      things like path1:"foo///bar" and path2:"foo/bar/baz"?  It doesn't      appear to arise in the current Subversion code, it's not clear to me      if they should be parent/child or not. */
comment|/* Hmmm... aren't paths assumed to be canonical in this function?    * How can "foo///bar" even happen if the paths are canonical? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|path1
index|[
name|i
index|]
operator|&&
name|path2
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|!=
name|path2
index|[
name|i
index|]
condition|)
return|return
name|NULL
return|;
comment|/* FIXME: This comment does not really match    * the checks made in the code it refers to: */
comment|/* There are two cases that are parent/child           ...      path1[i] == '\0'           .../foo  path2[i] == '/'       or           /        path1[i] == '\0'           /foo     path2[i] != '/'       Other root paths (like X:/) fall under the former case:           X:/        path1[i] == '\0'           X:/foo     path2[i] != '/'       Check for '//' to avoid matching '/' and '//srv'.   */
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|==
literal|'\0'
operator|&&
name|path2
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|path1
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
operator|||
operator|(
operator|(
name|type
operator|==
name|type_dirent
operator|)
operator|&&
name|path1
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
comment|/* .../              * ..../              *     i   */
return|return
name|NULL
return|;
else|else
comment|/* .../              * .../foo              *     i    */
return|return
name|pool
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path2
operator|+
name|i
argument_list|)
else|:
name|path2
operator|+
name|i
return|;
block|}
elseif|else
if|if
condition|(
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|path2
index|[
name|i
operator|+
literal|1
index|]
condition|)
comment|/* ...              * .../foo              *    i    */
return|return
name|pool
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path2
operator|+
name|i
operator|+
literal|1
argument_list|)
else|:
name|path2
operator|+
name|i
operator|+
literal|1
return|;
else|else
comment|/* ...              * .../              *    i    */
return|return
name|NULL
return|;
block|}
block|}
comment|/* Otherwise, path2 isn't a child. */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/**** Public API functions ****/
end_comment

begin_function
specifier|const
name|char
modifier|*
name|svn_dirent_internal_style
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_canonicalize
argument_list|(
name|internal_style
argument_list|(
name|dirent
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_dirent_local_style
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Internally, Subversion represents the current directory with the      empty string.  But users like to see "." . */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|dirent
argument_list|)
condition|)
return|return
literal|"."
return|;
if|#
directive|if
literal|'/'
operator|!=
name|SVN_PATH_LOCAL_SEPARATOR
block|{
name|char
modifier|*
name|p
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|dirent
argument_list|)
decl_stmt|;
name|dirent
operator|=
name|p
expr_stmt|;
comment|/* Convert all canonical separators to the local-style ones. */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
name|SVN_PATH_LOCAL_SEPARATOR
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|dirent
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_relpath__internal_style
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_relpath_canonicalize
argument_list|(
name|internal_style
argument_list|(
name|relpath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We decided against using apr_filepath_root here because of the negative    performance impact (creating a pool and converting strings ). */
end_comment

begin_function
name|svn_boolean_t
name|svn_dirent_is_root
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* On Windows and Cygwin, 'H:' or 'H:/' (where 'H' is any letter)      are also root directories */
if|if
condition|(
operator|(
name|len
operator|==
literal|2
operator|||
operator|(
operator|(
name|len
operator|==
literal|3
operator|)
operator|&&
operator|(
name|dirent
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
operator|&&
operator|(
name|dirent
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* On Windows and Cygwin //server/share is a root directory,      and on Cygwin //drive is a drive alias */
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|dirent
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|dirent
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|int
name|segments
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>=
literal|2
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|dirent
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|segments
operator|++
expr_stmt|;
if|if
condition|(
name|segments
operator|>
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|__CYGWIN__
return|return
operator|(
name|segments
operator|<=
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|segments
operator|==
literal|1
operator|)
return|;
comment|/* //drive is invalid on plain Windows */
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* directory is root if it's equal to '/' */
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_uri_is_root
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|assert
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|uri
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|==
name|uri_schema_root_length
argument_list|(
name|uri
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_dirent_join
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|blen
init|=
name|strlen
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|apr_size_t
name|clen
init|=
name|strlen
argument_list|(
name|component
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dirent
decl_stmt|;
name|int
name|add_separator
decl_stmt|;
name|assert
argument_list|(
name|svn_dirent_is_canonical
argument_list|(
name|base
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_dirent_is_canonical
argument_list|(
name|component
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the component is absolute, then return it.  */
if|if
condition|(
name|svn_dirent_is_absolute
argument_list|(
name|component
argument_list|)
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
return|;
comment|/* If either is empty return the other */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|base
argument_list|)
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
return|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|component
argument_list|)
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|base
argument_list|,
name|blen
operator|+
literal|1
argument_list|)
return|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
name|component
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* '/' is drive relative on Windows, not absolute like on Posix */
if|if
condition|(
name|dirent_is_rooted
argument_list|(
name|base
argument_list|)
condition|)
block|{
comment|/* Join component without '/' to root-of(base) */
name|blen
operator|=
name|dirent_root_length
argument_list|(
name|base
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|component
operator|++
expr_stmt|;
name|clen
operator|--
expr_stmt|;
if|if
condition|(
name|blen
operator|==
literal|2
operator|&&
name|base
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
comment|/* "C:" case */
block|{
name|char
modifier|*
name|root
init|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|base
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|root
index|[
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
comment|/* We don't need the final '\0' */
name|base
operator|=
name|root
expr_stmt|;
name|blen
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
return|return
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|base
argument_list|,
name|blen
argument_list|)
return|;
block|}
else|else
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dirent_is_rooted
argument_list|(
name|component
argument_list|)
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
return|;
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
comment|/* if last character of base is already a separator, don't add a '/' */
name|add_separator
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|base
index|[
name|blen
operator|-
literal|1
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
operator|||
name|base
index|[
name|blen
operator|-
literal|1
index|]
operator|==
literal|':'
endif|#
directive|endif
condition|)
name|add_separator
operator|=
literal|0
expr_stmt|;
comment|/* Construct the new, combined dirent. */
name|dirent
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|blen
operator|+
name|add_separator
operator|+
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dirent
argument_list|,
name|base
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_separator
condition|)
name|dirent
index|[
name|blen
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|dirent
operator|+
name|blen
operator|+
name|add_separator
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|dirent
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_dirent_join_many
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
modifier|...
parameter_list|)
block|{
define|#
directive|define
name|MAX_SAVED_LENGTHS
value|10
name|apr_size_t
name|saved_lengths
index|[
name|MAX_SAVED_LENGTHS
index|]
decl_stmt|;
name|apr_size_t
name|total_len
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|va_list
name|va
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|char
modifier|*
name|dirent
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|add_separator
decl_stmt|;
name|int
name|base_arg
init|=
literal|0
decl_stmt|;
name|total_len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_dirent_is_canonical
argument_list|(
name|base
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if last character of base is already a separator, don't add a '/' */
name|add_separator
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|total_len
operator|==
literal|0
operator|||
name|base
index|[
name|total_len
operator|-
literal|1
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
operator|||
name|base
index|[
name|total_len
operator|-
literal|1
index|]
operator|==
literal|':'
endif|#
directive|endif
condition|)
name|add_separator
operator|=
literal|0
expr_stmt|;
name|saved_lengths
index|[
literal|0
index|]
operator|=
name|total_len
expr_stmt|;
comment|/* Compute the length of the resulting string. */
name|nargs
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|va_arg
argument_list|(
name|va
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_dirent_is_canonical
argument_list|(
name|s
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nargs
operator|++
operator|<
name|MAX_SAVED_LENGTHS
condition|)
name|saved_lengths
index|[
name|nargs
index|]
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dirent_is_rooted
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|total_len
operator|=
name|len
expr_stmt|;
name|base_arg
operator|=
name|nargs
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
operator|!
name|svn_dirent_is_absolute
argument_list|(
name|s
argument_list|)
condition|)
comment|/* Handle non absolute roots */
block|{
comment|/* Set new base and skip the current argument */
name|base
operator|=
name|s
operator|=
name|svn_dirent_join
argument_list|(
name|base
argument_list|,
name|s
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|base_arg
operator|++
expr_stmt|;
name|saved_lengths
index|[
literal|0
index|]
operator|=
name|total_len
operator|=
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
block|{
name|base
operator|=
literal|""
expr_stmt|;
comment|/* Don't add base */
name|saved_lengths
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|add_separator
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
operator|||
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
endif|#
directive|endif
condition|)
name|add_separator
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|<=
name|base_arg
operator|+
literal|1
condition|)
block|{
name|total_len
operator|+=
name|add_separator
operator|+
name|len
expr_stmt|;
block|}
else|else
block|{
name|total_len
operator|+=
literal|1
operator|+
name|len
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* base == "/" and no further components. just return that. */
if|if
condition|(
name|add_separator
operator|==
literal|0
operator|&&
name|total_len
operator|==
literal|1
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
return|;
comment|/* we got the total size. allocate it, with room for a NULL character. */
name|dirent
operator|=
name|p
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|total_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* if we aren't supposed to skip forward to an absolute component, and if      this is not an empty base that we are skipping, then copy the base      into the output. */
if|if
condition|(
operator|!
name|SVN_PATH_IS_EMPTY
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|base
argument_list|,
name|len
operator|=
name|saved_lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
name|nargs
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|va_arg
argument_list|(
name|va
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|++
name|nargs
operator|<
name|base_arg
condition|)
continue|continue;
if|if
condition|(
name|nargs
operator|<
name|MAX_SAVED_LENGTHS
condition|)
name|len
operator|=
name|saved_lengths
index|[
name|nargs
index|]
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* insert a separator if we aren't copying in the first component          (which can happen when base_arg is set). also, don't put in a slash          if the prior character is a slash (occurs when prior component          is "/"). */
if|if
condition|(
name|p
operator|!=
name|dirent
operator|&&
operator|(
operator|!
operator|(
name|nargs
operator|-
literal|1
operator|<=
name|base_arg
operator|)
operator|||
name|add_separator
operator|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* copy the new component and advance the pointer */
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
call|(
name|apr_size_t
call|)
argument_list|(
name|p
operator|-
name|dirent
argument_list|)
operator|==
name|total_len
argument_list|)
expr_stmt|;
return|return
name|dirent
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_relpath_join
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|blen
init|=
name|strlen
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|apr_size_t
name|clen
init|=
name|strlen
argument_list|(
name|component
argument_list|)
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If either is empty return the other */
if|if
condition|(
name|blen
operator|==
literal|0
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
return|;
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|base
argument_list|,
name|blen
operator|+
literal|1
argument_list|)
return|;
name|path
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|blen
operator|+
literal|1
operator|+
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|base
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|path
index|[
name|blen
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|blen
operator|+
literal|1
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_dirent_dirname
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|dirent
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|svn_dirent_is_canonical
argument_list|(
name|dirent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|dirent_root_length
argument_list|(
name|dirent
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|dirent
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|dirent
argument_list|,
name|dirent_previous_segment
argument_list|(
name|dirent
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_dirent_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|dirent
argument_list|)
decl_stmt|;
name|apr_size_t
name|start
decl_stmt|;
name|assert
argument_list|(
operator|!
name|pool
operator|||
name|svn_dirent_is_canonical
argument_list|(
name|dirent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_dirent_is_root
argument_list|(
name|dirent
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|""
return|;
else|else
block|{
name|start
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|start
operator|>
literal|0
operator|&&
name|dirent
index|[
name|start
operator|-
literal|1
index|]
operator|!=
literal|'/'
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
operator|&&
name|dirent
index|[
name|start
operator|-
literal|1
index|]
operator|!=
literal|':'
endif|#
directive|endif
condition|)
operator|--
name|start
expr_stmt|;
block|}
if|if
condition|(
name|pool
condition|)
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|dirent
operator|+
name|start
argument_list|,
name|len
operator|-
name|start
argument_list|)
return|;
else|else
return|return
name|dirent
operator|+
name|start
return|;
block|}
end_function

begin_function
name|void
name|svn_dirent_split
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dirpath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|base_name
parameter_list|,
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|dirpath
operator|!=
name|base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirpath
condition|)
operator|*
name|dirpath
operator|=
name|svn_dirent_dirname
argument_list|(
name|dirent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
condition|)
operator|*
name|base_name
operator|=
name|svn_dirent_basename
argument_list|(
name|dirent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_relpath_dirname
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|relpath
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|relpath
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|relpath
argument_list|,
name|relpath_previous_segment
argument_list|(
name|relpath
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_relpath_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|relpath
argument_list|)
decl_stmt|;
name|apr_size_t
name|start
decl_stmt|;
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|relpath
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|start
operator|>
literal|0
operator|&&
name|relpath
index|[
name|start
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|start
expr_stmt|;
if|if
condition|(
name|pool
condition|)
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|relpath
operator|+
name|start
argument_list|,
name|len
operator|-
name|start
argument_list|)
return|;
else|else
return|return
name|relpath
operator|+
name|start
return|;
block|}
end_function

begin_function
name|void
name|svn_relpath_split
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dirpath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|base_name
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|dirpath
operator|!=
name|base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirpath
condition|)
operator|*
name|dirpath
operator|=
name|svn_relpath_dirname
argument_list|(
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
condition|)
operator|*
name|base_name
operator|=
name|svn_relpath_basename
argument_list|(
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_uri_dirname
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|uri
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_uri_is_root
argument_list|(
name|uri
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|uri
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|uri
argument_list|,
name|uri_previous_segment
argument_list|(
name|uri
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_uri_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|apr_size_t
name|start
decl_stmt|;
name|assert
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|uri
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_uri_is_root
argument_list|(
name|uri
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|""
return|;
name|start
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|start
operator|>
literal|0
operator|&&
name|uri
index|[
name|start
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|start
expr_stmt|;
return|return
name|svn_path_uri_decode
argument_list|(
name|uri
operator|+
name|start
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_uri_split
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dirpath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|base_name
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|dirpath
operator|!=
name|base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirpath
condition|)
operator|*
name|dirpath
operator|=
name|svn_uri_dirname
argument_list|(
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
condition|)
operator|*
name|base_name
operator|=
name|svn_uri_basename
argument_list|(
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_dirent_get_longest_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent1
parameter_list|,
specifier|const
name|char
modifier|*
name|dirent2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|dirent1
argument_list|,
name|get_longest_ancestor_length
argument_list|(
name|type_dirent
argument_list|,
name|dirent1
argument_list|,
name|dirent2
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_relpath_get_longest_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath1
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|relpath1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|relpath2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|relpath1
argument_list|,
name|get_longest_ancestor_length
argument_list|(
name|type_relpath
argument_list|,
name|relpath1
argument_list|,
name|relpath2
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_uri_get_longest_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|uri1
parameter_list|,
specifier|const
name|char
modifier|*
name|uri2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|uri_ancestor_len
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|uri1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|uri2
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find ':' */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* No shared protocol => no common prefix */
if|if
condition|(
name|uri1
index|[
name|i
index|]
operator|!=
name|uri2
index|[
name|i
index|]
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|SVN_EMPTY_PATH
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_EMPTY_PATH
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|uri1
index|[
name|i
index|]
operator|==
literal|':'
condition|)
break|break;
comment|/* They're both URLs, so EOS can't come before ':' */
name|assert
argument_list|(
operator|(
name|uri1
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|uri2
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|+=
literal|3
expr_stmt|;
comment|/* Advance past '://' */
name|uri_ancestor_len
operator|=
name|get_longest_ancestor_length
argument_list|(
name|type_uri
argument_list|,
name|uri1
operator|+
name|i
argument_list|,
name|uri2
operator|+
name|i
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri_ancestor_len
operator|==
literal|0
operator|||
operator|(
name|uri_ancestor_len
operator|==
literal|1
operator|&&
operator|(
name|uri1
operator|+
name|i
operator|)
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|SVN_EMPTY_PATH
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_EMPTY_PATH
argument_list|)
argument_list|)
return|;
else|else
return|return
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|uri1
argument_list|,
name|uri_ancestor_len
operator|+
name|i
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_dirent_is_child
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_dirent
parameter_list|,
specifier|const
name|char
modifier|*
name|child_dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|is_child
argument_list|(
name|type_dirent
argument_list|,
name|parent_dirent
argument_list|,
name|child_dirent
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_dirent_skip_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_dirent
parameter_list|,
specifier|const
name|char
modifier|*
name|child_dirent
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|parent_dirent
argument_list|)
decl_stmt|;
name|apr_size_t
name|root_len
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|parent_dirent
argument_list|,
name|child_dirent
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* parent_dirent is no ancestor of child_dirent */
if|if
condition|(
name|child_dirent
index|[
name|len
index|]
operator|==
literal|0
condition|)
return|return
literal|""
return|;
comment|/* parent_dirent == child_dirent */
comment|/* Child == parent + more-characters */
name|root_len
operator|=
name|dirent_root_length
argument_list|(
name|child_dirent
argument_list|,
name|strlen
argument_list|(
name|child_dirent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|root_len
operator|>
name|len
condition|)
comment|/* Different root, e.g. ("" "/...") or ("//z" "//z/share") */
return|return
name|NULL
return|;
comment|/* Now, child == [root-of-parent] + [rest-of-parent] + more-characters.    * It must be one of the following forms.    *    * rlen parent    child       bad?  rlen=len? c[len]=/?    *  0   ""        "foo"               *    *  0   "b"       "bad"         !    *  0   "b"       "b/foo"                       *    *  1   "/"       "/foo"              *    *  1   "/b"      "/bad"        !    *  1   "/b"      "/b/foo"                      *    *  2   "a:"      "a:foo"             *    *  2   "a:b"     "a:bad"       !    *  2   "a:b"     "a:b/foo"                     *    *  3   "a:/"     "a:/foo"            *    *  3   "a:/b"    "a:/bad"      !    *  3   "a:/b"    "a:/b/foo"                    *    *  5   "//s/s"   "//s/s/foo"         *         *    *  5   "//s/s/b" "//s/s/bad"   !    *  5   "//s/s/b" "//s/s/b/foo"                 *    */
if|if
condition|(
name|child_dirent
index|[
name|len
index|]
operator|==
literal|'/'
condition|)
comment|/* "parent|child" is one of:      * "[a:]b|/foo" "[a:]/b|/foo" "//s/s|/foo" "//s/s/b|/foo" */
return|return
name|child_dirent
operator|+
name|len
operator|+
literal|1
return|;
if|if
condition|(
name|root_len
operator|==
name|len
condition|)
comment|/* "parent|child" is "|foo" "/|foo" "a:|foo" "a:/|foo" "//s/s|/foo" */
return|return
name|child_dirent
operator|+
name|len
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_relpath_skip_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|child_relpath
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|parent_relpath
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|parent_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|relpath_is_canonical
argument_list|(
name|child_relpath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|child_relpath
return|;
if|if
condition|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|parent_relpath
argument_list|,
name|child_relpath
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* parent_relpath is no ancestor of child_relpath */
if|if
condition|(
name|child_relpath
index|[
name|len
index|]
operator|==
literal|0
condition|)
return|return
literal|""
return|;
comment|/* parent_relpath == child_relpath */
if|if
condition|(
name|child_relpath
index|[
name|len
index|]
operator|==
literal|'/'
condition|)
return|return
name|child_relpath
operator|+
name|len
operator|+
literal|1
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|uri_skip_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_uri
parameter_list|,
specifier|const
name|char
modifier|*
name|child_uri
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|parent_uri
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|parent_uri
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|child_uri
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|parent_uri
argument_list|,
name|child_uri
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* parent_uri is no ancestor of child_uri */
if|if
condition|(
name|child_uri
index|[
name|len
index|]
operator|==
literal|0
condition|)
return|return
literal|""
return|;
comment|/* parent_uri == child_uri */
if|if
condition|(
name|child_uri
index|[
name|len
index|]
operator|==
literal|'/'
condition|)
return|return
name|child_uri
operator|+
name|len
operator|+
literal|1
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_uri_skip_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_uri
parameter_list|,
specifier|const
name|char
modifier|*
name|child_uri
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
init|=
name|uri_skip_ancestor
argument_list|(
name|parent_uri
argument_list|,
name|child_uri
argument_list|)
decl_stmt|;
return|return
name|result
condition|?
name|svn_path_uri_decode
argument_list|(
name|result
argument_list|,
name|result_pool
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_dirent_is_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_dirent
parameter_list|,
specifier|const
name|char
modifier|*
name|child_dirent
parameter_list|)
block|{
return|return
name|svn_dirent_skip_ancestor
argument_list|(
name|parent_dirent
argument_list|,
name|child_dirent
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_uri__is_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_uri
parameter_list|,
specifier|const
name|char
modifier|*
name|child_uri
parameter_list|)
block|{
return|return
name|uri_skip_ancestor
argument_list|(
name|parent_uri
argument_list|,
name|child_uri
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_dirent_is_absolute
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dirent
condition|)
return|return
name|FALSE
return|;
comment|/* dirent is absolute if it starts with '/' on non-Windows platforms      or with '//' on Windows platforms */
if|if
condition|(
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
operator|&&
name|dirent
index|[
literal|1
index|]
operator|==
literal|'/'
comment|/* Single '/' depends on current drive */
endif|#
directive|endif
condition|)
return|return
name|TRUE
return|;
comment|/* On Windows, dirent is also absolute when it starts with 'H:/'      where 'H' is any letter. */
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
operator|(
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|)
operator|&&
operator|(
name|dirent
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|dirent
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_dirent_get_absolute
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pabsolute
parameter_list|,
specifier|const
name|char
modifier|*
name|relative
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|svn_path_is_url
argument_list|(
name|relative
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge the current working directory with the relative dirent. */
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|relative
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_merge
argument_list|(
operator|&
name|buffer
argument_list|,
name|NULL
argument_list|,
name|path_apr
argument_list|,
name|APR_FILEPATH_NOTRELATIVE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
comment|/* In some cases when the passed path or its ancestor(s) do not exist          or no longer exist apr returns an error.           In many of these cases we would like to return a path anyway, when the          passed path was already a safe absolute path. So check for that now to          avoid an error.           svn_dirent_is_absolute() doesn't perform the necessary checks to see          if the path doesn't need post processing to be in the canonical absolute          format.          */
if|if
condition|(
name|svn_dirent_is_absolute
argument_list|(
name|relative
argument_list|)
operator|&&
name|svn_dirent_is_canonical
argument_list|(
name|relative
argument_list|,
name|pool
argument_list|)
operator|&&
operator|!
name|svn_path_is_backpath_present
argument_list|(
name|relative
argument_list|)
condition|)
block|{
operator|*
name|pabsolute
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|relative
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Couldn't determine absolute path of '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|relative
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
name|pabsolute
argument_list|,
name|buffer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pabsolute
operator|=
name|svn_dirent_canonicalize
argument_list|(
operator|*
name|pabsolute
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_uri_canonicalize
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|canonicalize
argument_list|(
name|type_uri
argument_list|,
name|uri
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_relpath_canonicalize
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|canonicalize
argument_list|(
name|type_relpath
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_dirent_canonicalize
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dst
init|=
name|canonicalize
argument_list|(
name|type_dirent
argument_list|,
name|dirent
argument_list|,
name|pool
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* Handle a specific case on Windows where path == "X:/". Here we have to      append the final '/', as svn_path_canonicalize will chop this of. */
if|if
condition|(
operator|(
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|dirent
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|dirent
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
operator|)
operator|&&
name|dirent
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|dirent
index|[
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|dst
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|dst_slash
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|dst_slash
index|[
literal|0
index|]
operator|=
name|canonicalize_to_upper
argument_list|(
name|dirent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dst_slash
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|dst_slash
index|[
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
name|dst_slash
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dst_slash
return|;
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
return|return
name|dst
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_dirent_is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|dirent
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* Check for UNC paths */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
block|{
comment|/* TODO: Scan hostname and sharename and fall back to part code */
comment|/* ### Fall back to old implementation */
return|return
operator|(
name|strcmp
argument_list|(
name|dirent
argument_list|,
name|svn_dirent_canonicalize
argument_list|(
name|dirent
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
block|}
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|ptr
operator|>=
literal|'a'
operator|&&
operator|*
name|ptr
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|>=
literal|'A'
operator|&&
operator|*
name|ptr
operator|<=
literal|'Z'
operator|)
operator|)
operator|&&
operator|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* The only canonical drive names are "A:"..."Z:", no lower case */
if|if
condition|(
operator|*
name|ptr
operator|<
literal|'A'
operator|||
operator|*
name|ptr
operator|>
literal|'Z'
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
name|ptr
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
return|return
name|relpath_is_canonical
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|relpath_is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|relpath
decl_stmt|,
modifier|*
name|seg
init|=
name|relpath
decl_stmt|;
comment|/* RELPATH is canonical if it has:    *  - no '.' segments    *  - no start and closing '/'    *  - no '//'    */
if|if
condition|(
operator|*
name|relpath
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
return|return
name|FALSE
return|;
comment|/* Now validate the rest of the path. */
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|seglen
init|=
name|ptr
operator|-
name|seg
decl_stmt|;
if|if
condition|(
name|seglen
operator|==
literal|1
operator|&&
operator|*
name|seg
operator|==
literal|'.'
condition|)
return|return
name|FALSE
return|;
comment|/*  /./   */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
operator|&&
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|'/'
condition|)
return|return
name|FALSE
return|;
comment|/*  //    */
if|if
condition|(
operator|!
operator|*
name|ptr
operator|&&
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|==
literal|'/'
condition|)
return|return
name|FALSE
return|;
comment|/* foo/  */
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
break|break;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
name|ptr
operator|++
expr_stmt|;
name|seg
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'/'
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_relpath_is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|)
block|{
return|return
name|relpath_is_canonical
argument_list|(
name|relpath
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_uri_is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|uri
decl_stmt|,
modifier|*
name|seg
init|=
name|uri
decl_stmt|;
specifier|const
name|char
modifier|*
name|schema_data
init|=
name|NULL
decl_stmt|;
comment|/* URI is canonical if it has:    *  - lowercase URL scheme    *  - lowercase URL hostname    *  - no '.' segments    *  - no closing '/'    *  - no '//'    *  - uppercase hex-encoded pair digits ("%AB", not "%ab")    */
if|if
condition|(
operator|*
name|uri
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|uri
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Skip the scheme. */
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|':'
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* No scheme?  No good. */
if|if
condition|(
operator|!
operator|(
operator|*
name|ptr
operator|==
literal|':'
operator|&&
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|'/'
operator|&&
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|==
literal|'/'
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Found a scheme, check that it's all lowercase. */
name|ptr
operator|=
name|uri
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|>=
literal|'A'
operator|&&
operator|*
name|ptr
operator|<=
literal|'Z'
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* Skip :// */
name|ptr
operator|+=
literal|3
expr_stmt|;
comment|/* Scheme only?  That works. */
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
return|return
name|TRUE
return|;
comment|/* This might be the hostname */
name|seg
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'@'
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'@'
condition|)
name|seg
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
comment|/* Found a hostname, check that it's all lowercase. */
name|ptr
operator|=
name|seg
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'['
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|':'
operator|||
operator|(
operator|*
name|ptr
operator|>=
literal|'0'
operator|&&
operator|*
name|ptr
operator|<=
literal|'9'
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|>=
literal|'a'
operator|&&
operator|*
name|ptr
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|']'
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|'/'
operator|&&
operator|*
name|ptr
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|>=
literal|'A'
operator|&&
operator|*
name|ptr
operator|<=
literal|'Z'
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* Found a portnumber */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|':'
condition|)
block|{
name|apr_int64_t
name|port
init|=
literal|0
decl_stmt|;
name|ptr
operator|++
expr_stmt|;
name|schema_data
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|>=
literal|'0'
operator|&&
operator|*
name|ptr
operator|<=
literal|'9'
condition|)
block|{
name|port
operator|=
literal|10
operator|*
name|port
operator|+
operator|(
operator|*
name|ptr
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|schema_data
condition|)
return|return
name|FALSE
return|;
comment|/* Fail on "http://host:" */
if|if
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|'/'
condition|)
return|return
name|FALSE
return|;
comment|/* Not a port number */
if|if
condition|(
name|port
operator|==
literal|80
operator|&&
name|strncmp
argument_list|(
name|uri
argument_list|,
literal|"http:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|port
operator|==
literal|443
operator|&&
name|strncmp
argument_list|(
name|uri
argument_list|,
literal|"https:"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|port
operator|==
literal|3690
operator|&&
name|strncmp
argument_list|(
name|uri
argument_list|,
literal|"svn:"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
name|schema_data
operator|=
name|ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
if|if
condition|(
name|schema_data
operator|&&
operator|*
name|ptr
operator|==
literal|'/'
condition|)
block|{
comment|/* If this is a file url, ptr now points to the third '/' in          file:///C:/path. Check that if we have such a URL the drive          letter is in uppercase. */
if|if
condition|(
name|strncmp
argument_list|(
name|uri
argument_list|,
literal|"file:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|>=
literal|'A'
operator|&&
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|<=
literal|'Z'
operator|)
operator|&&
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|==
literal|':'
condition|)
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
comment|/* Now validate the rest of the URI. */
name|seg
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'/'
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|seglen
init|=
name|ptr
operator|-
name|seg
decl_stmt|;
if|if
condition|(
name|seglen
operator|==
literal|1
operator|&&
operator|*
name|seg
operator|==
literal|'.'
condition|)
return|return
name|FALSE
return|;
comment|/*  /./   */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
operator|&&
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|'/'
condition|)
return|return
name|FALSE
return|;
comment|/*  //    */
if|if
condition|(
operator|!
operator|*
name|ptr
operator|&&
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|==
literal|'/'
operator|&&
name|ptr
operator|-
literal|1
operator|!=
name|uri
condition|)
return|return
name|FALSE
return|;
comment|/* foo/  */
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
break|break;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
name|ptr
operator|++
expr_stmt|;
name|seg
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'/'
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
name|schema_data
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'%'
condition|)
block|{
name|char
name|digitz
index|[
literal|3
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* Can't usesvn_ctype_isxdigit() because lower case letters are              not in our canonical format */
if|if
condition|(
operator|(
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|<
literal|'0'
operator|||
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|>
literal|'9'
operator|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|<
literal|'A'
operator|||
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|>
literal|'F'
operator|)
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|<
literal|'0'
operator|||
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|>
literal|'9'
operator|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|<
literal|'A'
operator|||
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|>
literal|'F'
operator|)
condition|)
return|return
name|FALSE
return|;
name|digitz
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
name|digitz
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
name|digitz
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|digitz
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_uri__char_validity
index|[
name|val
index|]
condition|)
return|return
name|FALSE
return|;
comment|/* Should not have been escaped */
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'/'
operator|&&
operator|!
name|svn_uri__char_validity
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
index|]
condition|)
return|return
name|FALSE
return|;
comment|/* Character should have been escaped */
name|ptr
operator|++
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_dirent_condense_targets
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pcommon
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|pcondensed_targets
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_boolean_t
name|remove_redundancies
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_condensed
init|=
name|targets
operator|->
name|nelts
decl_stmt|;
name|svn_boolean_t
modifier|*
name|removed
decl_stmt|;
name|apr_array_header_t
modifier|*
name|abs_targets
decl_stmt|;
comment|/* Early exit when there's no data to work on. */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<=
literal|0
condition|)
block|{
operator|*
name|pcommon
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pcondensed_targets
condition|)
operator|*
name|pcondensed_targets
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Get the absolute path of the first target. */
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
name|pcommon
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Early exit when there's only one dirent to work on. */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
operator|*
name|pcommon
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
operator|*
name|pcommon
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcondensed_targets
condition|)
operator|*
name|pcondensed_targets
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Copy the targets array, but with absolute dirents instead of      relative.  Also, find the pcommon argument by finding what is      common in all of the absolute dirents. NOTE: This is not as      efficient as it could be.  The calculation of the basedir could      be done in the loop below, which would save some calls to      svn_dirent_get_longest_ancestor.  I decided to do it this way      because I thought it would be simpler, since this way, we don't      even do the loop if we don't need to condense the targets. */
name|removed
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
operator|(
name|targets
operator|->
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|svn_boolean_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|abs_targets
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|abs_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
operator|*
name|pcommon
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|rel
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|absolute
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|absolute
argument_list|,
name|rel
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|abs_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|absolute
expr_stmt|;
operator|*
name|pcommon
operator|=
name|svn_dirent_get_longest_ancestor
argument_list|(
operator|*
name|pcommon
argument_list|,
name|absolute
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|pcommon
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
operator|*
name|pcommon
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcondensed_targets
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|basedir_len
decl_stmt|;
if|if
condition|(
name|remove_redundancies
condition|)
block|{
comment|/* Find the common part of each pair of targets.  If              common part is equal to one of the dirents, the other              is a child of it, and can be removed.  If a target is              equal to *pcommon, it can also be removed. */
comment|/* First pass: when one non-removed target is a child of              another non-removed target, remove the child. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abs_targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|removed
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|abs_targets
operator|->
name|nelts
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|char
modifier|*
name|abs_targets_i
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_targets_j
decl_stmt|;
specifier|const
name|char
modifier|*
name|ancestor
decl_stmt|;
if|if
condition|(
name|removed
index|[
name|j
index|]
condition|)
continue|continue;
name|abs_targets_i
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|abs_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|abs_targets_j
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|abs_targets
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|ancestor
operator|=
name|svn_dirent_get_longest_ancestor
argument_list|(
name|abs_targets_i
argument_list|,
name|abs_targets_j
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ancestor
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|ancestor
argument_list|,
name|abs_targets_i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|removed
index|[
name|j
index|]
operator|=
name|TRUE
expr_stmt|;
name|num_condensed
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ancestor
argument_list|,
name|abs_targets_j
argument_list|)
operator|==
literal|0
condition|)
block|{
name|removed
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|num_condensed
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Second pass: when a target is the same as *pcommon,              remove the target. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abs_targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|abs_targets_i
init|=
name|APR_ARRAY_IDX
argument_list|(
name|abs_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|abs_targets_i
argument_list|,
operator|*
name|pcommon
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|removed
index|[
name|i
index|]
operator|)
condition|)
block|{
name|removed
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|num_condensed
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Now create the return array, and copy the non-removed items */
name|basedir_len
operator|=
name|strlen
argument_list|(
operator|*
name|pcommon
argument_list|)
expr_stmt|;
operator|*
name|pcondensed_targets
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|num_condensed
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abs_targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|rel_item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|abs_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Skip this if it's been removed. */
if|if
condition|(
name|removed
index|[
name|i
index|]
condition|)
continue|continue;
comment|/* If a common prefix was found, condensed_targets are given              relative to that prefix.  */
if|if
condition|(
name|basedir_len
operator|>
literal|0
condition|)
block|{
comment|/* Only advance our pointer past a dirent separator if                  REL_ITEM isn't the same as *PCOMMON.                   If *PCOMMON is a root dirent, basedir_len will already                  include the closing '/', so never advance the pointer                  here.                  */
name|rel_item
operator|+=
name|basedir_len
expr_stmt|;
if|if
condition|(
name|rel_item
index|[
literal|0
index|]
operator|&&
operator|!
name|svn_dirent_is_root
argument_list|(
operator|*
name|pcommon
argument_list|,
name|basedir_len
argument_list|)
condition|)
name|rel_item
operator|++
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|pcondensed_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|rel_item
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_uri_condense_targets
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pcommon
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|pcondensed_targets
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_boolean_t
name|remove_redundancies
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_condensed
init|=
name|targets
operator|->
name|nelts
decl_stmt|;
name|apr_array_header_t
modifier|*
name|uri_targets
decl_stmt|;
name|svn_boolean_t
modifier|*
name|removed
decl_stmt|;
comment|/* Early exit when there's no data to work on. */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<=
literal|0
condition|)
block|{
operator|*
name|pcommon
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pcondensed_targets
condition|)
operator|*
name|pcondensed_targets
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|pcommon
operator|=
name|svn_uri_canonicalize
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Early exit when there's only one uri to work on. */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
operator|*
name|pcommon
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
operator|*
name|pcommon
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcondensed_targets
condition|)
operator|*
name|pcondensed_targets
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Find the pcommon argument by finding what is common in all of the      uris. NOTE: This is not as efficient as it could be.  The calculation      of the basedir could be done in the loop below, which would      save some calls to svn_uri_get_longest_ancestor.  I decided to do it      this way because I thought it would be simpler, since this way, we don't      even do the loop if we don't need to condense the targets. */
name|removed
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
operator|(
name|targets
operator|->
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|svn_boolean_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|uri_targets
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|uri_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
operator|*
name|pcommon
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|uri
init|=
name|svn_uri_canonicalize
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|uri_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|uri
expr_stmt|;
comment|/* If the commonmost ancestor so far is empty, there's no point          in continuing to search for a common ancestor at all.  But          we'll keep looping for the sake of canonicalizing the          targets, I suppose.  */
if|if
condition|(
operator|*
operator|*
name|pcommon
operator|!=
literal|'\0'
condition|)
operator|*
name|pcommon
operator|=
name|svn_uri_get_longest_ancestor
argument_list|(
operator|*
name|pcommon
argument_list|,
name|uri
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|pcommon
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
operator|*
name|pcommon
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcondensed_targets
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|basedir_len
decl_stmt|;
if|if
condition|(
name|remove_redundancies
condition|)
block|{
comment|/* Find the common part of each pair of targets.  If              common part is equal to one of the dirents, the other              is a child of it, and can be removed.  If a target is              equal to *pcommon, it can also be removed. */
comment|/* First pass: when one non-removed target is a child of              another non-removed target, remove the child. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uri_targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|removed
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|uri_targets
operator|->
name|nelts
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|char
modifier|*
name|uri_i
decl_stmt|;
specifier|const
name|char
modifier|*
name|uri_j
decl_stmt|;
specifier|const
name|char
modifier|*
name|ancestor
decl_stmt|;
if|if
condition|(
name|removed
index|[
name|j
index|]
condition|)
continue|continue;
name|uri_i
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|uri_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|uri_j
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|uri_targets
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|ancestor
operator|=
name|svn_uri_get_longest_ancestor
argument_list|(
name|uri_i
argument_list|,
name|uri_j
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ancestor
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|ancestor
argument_list|,
name|uri_i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|removed
index|[
name|j
index|]
operator|=
name|TRUE
expr_stmt|;
name|num_condensed
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ancestor
argument_list|,
name|uri_j
argument_list|)
operator|==
literal|0
condition|)
block|{
name|removed
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|num_condensed
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Second pass: when a target is the same as *pcommon,              remove the target. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uri_targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|uri_targets_i
init|=
name|APR_ARRAY_IDX
argument_list|(
name|uri_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|uri_targets_i
argument_list|,
operator|*
name|pcommon
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|removed
index|[
name|i
index|]
operator|)
condition|)
block|{
name|removed
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|num_condensed
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Now create the return array, and copy the non-removed items */
name|basedir_len
operator|=
name|strlen
argument_list|(
operator|*
name|pcommon
argument_list|)
expr_stmt|;
operator|*
name|pcondensed_targets
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|num_condensed
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uri_targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|rel_item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|uri_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Skip this if it's been removed. */
if|if
condition|(
name|removed
index|[
name|i
index|]
condition|)
continue|continue;
comment|/* If a common prefix was found, condensed_targets are given              relative to that prefix.  */
if|if
condition|(
name|basedir_len
operator|>
literal|0
condition|)
block|{
comment|/* Only advance our pointer past a dirent separator if                  REL_ITEM isn't the same as *PCOMMON.                   If *PCOMMON is a root dirent, basedir_len will already                  include the closing '/', so never advance the pointer                  here.                  */
name|rel_item
operator|+=
name|basedir_len
expr_stmt|;
if|if
condition|(
operator|(
name|rel_item
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|rel_item
index|[
literal|0
index|]
operator|&&
operator|!
name|svn_uri_is_root
argument_list|(
operator|*
name|pcommon
argument_list|,
name|basedir_len
argument_list|)
operator|)
condition|)
block|{
name|rel_item
operator|++
expr_stmt|;
block|}
block|}
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|pcondensed_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_path_uri_decode
argument_list|(
name|rel_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_dirent_is_under_root
parameter_list|(
name|svn_boolean_t
modifier|*
name|under_root
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|result_path
parameter_list|,
specifier|const
name|char
modifier|*
name|base_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|char
modifier|*
name|full_path
decl_stmt|;
operator|*
name|under_root
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|result_path
condition|)
operator|*
name|result_path
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|apr_filepath_merge
argument_list|(
operator|&
name|full_path
argument_list|,
name|base_path
argument_list|,
name|path
argument_list|,
name|APR_FILEPATH_NOTABOVEROOT
operator||
name|APR_FILEPATH_SECUREROOTTEST
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
block|{
if|if
condition|(
name|result_path
condition|)
operator|*
name|result_path
operator|=
name|svn_dirent_canonicalize
argument_list|(
name|full_path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|under_root
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|APR_EABOVEROOT
condition|)
block|{
operator|*
name|under_root
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_uri_get_dirent_from_file_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dirent
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_uri_is_canonical
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify that the URL is well-formed (loosely) */
comment|/* First, check for the "file://" prefix. */
if|if
condition|(
name|strncmp
argument_list|(
name|url
argument_list|,
literal|"file://"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Local URL '%s' does not contain 'file://' "
literal|"prefix"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
comment|/* Find the HOSTNAME portion and the PATH portion of the URL.  The host      name is between the "file://" prefix and the next occurence of '/'.  We      are considering everything from that '/' until the end of the URL to be      the absolute path portion of the URL.      If we got just "file://", treat it the same as "file:///". */
name|hostname
operator|=
name|url
operator|+
literal|7
expr_stmt|;
name|path
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|hostname
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|hostname
argument_list|,
name|path
operator|-
name|hostname
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
literal|"/"
expr_stmt|;
comment|/* URI-decode HOSTNAME, and set it to NULL if it is "" or "localhost". */
if|if
condition|(
operator|*
name|hostname
operator|==
literal|'\0'
condition|)
name|hostname
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|hostname
operator|=
name|svn_path_uri_decode
argument_list|(
name|hostname
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hostname
argument_list|,
literal|"localhost"
argument_list|)
operator|==
literal|0
condition|)
name|hostname
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Duplicate the URL, starting at the top of the path.      At the same time, we URI-decode the path. */
ifdef|#
directive|ifdef
name|SVN_USE_DOS_PATHS
comment|/* On Windows, we'll typically have to skip the leading / if the      path starts with a drive letter.  Like most Web browsers, We      support two variants of this scheme:           file:///X:/path    and          file:///X|/path      Note that, at least on WinNT and above,  file:////./X:/path  will     also work, so we must make sure the transformation doesn't break     that, and  file:///path  (that looks within the current drive     only) should also keep working.     If we got a non-empty hostname other than localhost, we convert this     into an UNC path.  In this case, we obviously don't strip the slash     even if the path looks like it starts with a drive letter.   */
block|{
specifier|static
specifier|const
name|char
name|valid_drive_letters
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
decl_stmt|;
comment|/* Casting away const! */
name|char
modifier|*
name|dup_path
init|=
operator|(
name|char
operator|*
operator|)
name|svn_path_uri_decode
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* This check assumes ':' and '|' are already decoded! */
if|if
condition|(
operator|!
name|hostname
operator|&&
name|dup_path
index|[
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|valid_drive_letters
argument_list|,
name|dup_path
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|dup_path
index|[
literal|2
index|]
operator|==
literal|':'
operator|||
name|dup_path
index|[
literal|2
index|]
operator|==
literal|'|'
operator|)
condition|)
block|{
comment|/* Skip the leading slash. */
operator|++
name|dup_path
expr_stmt|;
if|if
condition|(
name|dup_path
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
name|dup_path
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|dup_path
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|dup_path
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|dup_path
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* A valid dirent for the driveroot must be like "C:/" instead of                    just "C:" or svn_dirent_join() will use the current directory                    on the drive instead */
name|char
modifier|*
name|new_path
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|new_path
index|[
literal|0
index|]
operator|=
name|dup_path
index|[
literal|0
index|]
expr_stmt|;
name|new_path
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|new_path
index|[
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
name|new_path
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dup_path
operator|=
name|new_path
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hostname
condition|)
block|{
if|if
condition|(
name|dup_path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|dup_path
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Local URL '%s' contains only a hostname, "
literal|"no path"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
comment|/* We still know that the path starts with a slash. */
operator|*
name|dirent
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"//"
argument_list|,
name|hostname
argument_list|,
name|dup_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|dirent
operator|=
name|dup_path
expr_stmt|;
block|}
else|#
directive|else
comment|/* !SVN_USE_DOS_PATHS */
comment|/* Currently, the only hostnames we are allowing on non-Win32 platforms      are the empty string and 'localhost'. */
if|if
condition|(
name|hostname
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Local URL '%s' contains unsupported hostname"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
operator|*
name|dirent
operator|=
name|svn_path_uri_decode
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SVN_USE_DOS_PATHS */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_uri_get_file_url_from_dirent
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|svn_dirent_is_canonical
argument_list|(
name|dirent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|dirent
argument_list|,
name|dirent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|dirent
operator|=
name|svn_path_uri_encode
argument_list|(
name|dirent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SVN_USE_DOS_PATHS
if|if
condition|(
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|dirent
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|dirent
operator|=
name|NULL
expr_stmt|;
comment|/* "file://" is the canonical form of "file:///" */
operator|*
name|url
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"file://"
argument_list|,
name|dirent
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dirent
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Handle UNC paths //server/share -> file://server/share */
name|assert
argument_list|(
name|dirent
index|[
literal|1
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Expect UNC, not non-absolute */
operator|*
name|url
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"file:"
argument_list|,
name|dirent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|uri
init|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"file:///"
argument_list|,
name|dirent
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|apr_size_t
name|len
init|=
literal|8
comment|/* strlen("file:///") */
operator|+
name|strlen
argument_list|(
name|dirent
argument_list|)
decl_stmt|;
comment|/* "C:/" is a canonical dirent on Windows,          but "file:///C:/" is not a canonical uri */
if|if
condition|(
name|uri
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|uri
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|url
operator|=
name|uri
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* -------------- The fspath API (see private/svn_fspath.h) -------------- */
end_comment

begin_function
name|svn_boolean_t
name|svn_fspath__is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|fspath
parameter_list|)
block|{
return|return
name|fspath
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|relpath_is_canonical
argument_list|(
name|fspath
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fspath__canonicalize
parameter_list|(
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fspath
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|fspath
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
literal|"/"
return|;
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|fspath
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fspath__is_root
parameter_list|(
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
comment|/* directory is root if it's equal to '/' */
return|return
operator|(
name|len
operator|==
literal|1
operator|&&
name|fspath
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fspath__skip_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_fspath
parameter_list|,
specifier|const
name|char
modifier|*
name|child_fspath
parameter_list|)
block|{
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|parent_fspath
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|child_fspath
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_relpath_skip_ancestor
argument_list|(
name|parent_fspath
operator|+
literal|1
argument_list|,
name|child_fspath
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fspath__dirname
parameter_list|(
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|fspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fspath
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|fspath
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|fspath
argument_list|)
return|;
else|else
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|svn_relpath_dirname
argument_list|(
name|fspath
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fspath__basename
parameter_list|(
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|fspath
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|svn_relpath_basename
argument_list|(
name|fspath
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strchr
argument_list|(
name|result
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|svn_fspath__split
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dirpath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|base_name
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|assert
argument_list|(
name|dirpath
operator|!=
name|base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirpath
condition|)
operator|*
name|dirpath
operator|=
name|svn_fspath__dirname
argument_list|(
name|fspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
condition|)
operator|*
name|base_name
operator|=
name|svn_fspath__basename
argument_list|(
name|fspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_fspath__join
parameter_list|(
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|fspath
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_relpath_is_canonical
argument_list|(
name|relpath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fspath
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
literal|"/"
argument_list|,
name|relpath
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|fspath
argument_list|,
literal|"/"
argument_list|,
name|relpath
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_fspath__get_longest_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|fspath1
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath2
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|fspath1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|fspath2
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
literal|"/"
argument_list|,
name|svn_relpath_get_longest_ancestor
argument_list|(
name|fspath1
operator|+
literal|1
argument_list|,
name|fspath2
operator|+
literal|1
argument_list|,
name|result_pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_fspath__is_canonical
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* -------------- The urlpath API (see private/svn_fspath.h) ------------- */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|svn_urlpath__canonicalize
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|uri
argument_list|)
condition|)
block|{
name|uri
operator|=
name|svn_uri_canonicalize
argument_list|(
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uri
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Do a little dance to normalize hex encoding. */
name|uri
operator|=
name|svn_path_uri_decode
argument_list|(
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|uri
operator|=
name|svn_path_uri_encode
argument_list|(
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|uri
return|;
block|}
end_function

end_unit

