begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sorts.c:   all sorts of sorts  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for qsort()   */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** svn_sort__hash() ***/
end_comment

begin_comment
comment|/* (Should this be a permanent part of APR?)     OK, folks, here's what's going on.  APR hash tables hash on    key/klen objects, and store associated generic values.  They work    great, but they have no ordering.     The point of this exercise is to somehow arrange a hash's keys into    an "ordered list" of some kind -- in this case, a nicely sorted    one.     We're using APR arrays, therefore, because that's what they are:    ordered lists.  However, what "keys" should we put in the array?    Clearly, (const char *) objects aren't general enough.  Or rather,    they're not as general as APR's hash implementation, which stores    (void *)/length as keys.  We don't want to lose this information.     Therefore, it makes sense to store pointers to {void *, size_t}    structures in our array.  No such apr object exists... BUT... if we    can use a new type svn_sort__item_t which contains {char *, size_t, void    *}.  If store these objects in our array, we get the hash value    *for free*.  When looping over the final array, we don't need to    call apr_hash_get().  Major bonus!  */
end_comment

begin_function
name|int
name|svn_sort_compare_items_as_paths
parameter_list|(
specifier|const
name|svn_sort__item_t
modifier|*
name|a
parameter_list|,
specifier|const
name|svn_sort__item_t
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|astr
decl_stmt|,
modifier|*
name|bstr
decl_stmt|;
name|astr
operator|=
name|a
operator|->
name|key
expr_stmt|;
name|bstr
operator|=
name|b
operator|->
name|key
expr_stmt|;
name|assert
argument_list|(
name|astr
index|[
name|a
operator|->
name|klen
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bstr
index|[
name|b
operator|->
name|klen
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|svn_path_compare_paths
argument_list|(
name|astr
argument_list|,
name|bstr
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svn_sort_compare_items_lexically
parameter_list|(
specifier|const
name|svn_sort__item_t
modifier|*
name|a
parameter_list|,
specifier|const
name|svn_sort__item_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* Compare bytes of a's key and b's key up to the common length. */
name|len
operator|=
operator|(
name|a
operator|->
name|klen
operator|<
name|b
operator|->
name|klen
operator|)
condition|?
name|a
operator|->
name|klen
else|:
name|b
operator|->
name|klen
expr_stmt|;
name|val
operator|=
name|memcmp
argument_list|(
name|a
operator|->
name|key
argument_list|,
name|b
operator|->
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* They match up until one of them ends; whichever is longer is greater. */
return|return
operator|(
name|a
operator|->
name|klen
operator|<
name|b
operator|->
name|klen
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|a
operator|->
name|klen
operator|>
name|b
operator|->
name|klen
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svn_sort_compare_revisions
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|svn_revnum_t
name|a_rev
init|=
operator|*
operator|(
specifier|const
name|svn_revnum_t
operator|*
operator|)
name|a
decl_stmt|;
name|svn_revnum_t
name|b_rev
init|=
operator|*
operator|(
specifier|const
name|svn_revnum_t
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|a_rev
operator|==
name|b_rev
condition|)
return|return
literal|0
return|;
return|return
name|a_rev
operator|<
name|b_rev
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|svn_sort_compare_paths
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|item1
init|=
operator|*
operator|(
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|item2
init|=
operator|*
operator|(
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
return|return
name|svn_path_compare_paths
argument_list|(
name|item1
argument_list|,
name|item2
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svn_sort_compare_ranges
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_merge_range_t
modifier|*
name|item1
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_merge_range_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|svn_merge_range_t
modifier|*
name|item2
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_merge_range_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
if|if
condition|(
name|item1
operator|->
name|start
operator|==
name|item2
operator|->
name|start
operator|&&
name|item1
operator|->
name|end
operator|==
name|item2
operator|->
name|end
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|item1
operator|->
name|start
operator|==
name|item2
operator|->
name|start
condition|)
return|return
name|item1
operator|->
name|end
operator|<
name|item2
operator|->
name|end
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
name|item1
operator|->
name|start
operator|<
name|item2
operator|->
name|start
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_function
name|apr_array_header_t
modifier|*
name|svn_sort__hash
parameter_list|(
name|apr_hash_t
modifier|*
name|ht
parameter_list|,
name|int
function_decl|(
modifier|*
name|comparison_func
function_decl|)
parameter_list|(
specifier|const
name|svn_sort__item_t
modifier|*
parameter_list|,
specifier|const
name|svn_sort__item_t
modifier|*
parameter_list|)
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|ary
decl_stmt|;
name|svn_boolean_t
name|sorted
decl_stmt|;
name|svn_sort__item_t
modifier|*
name|prev_item
decl_stmt|;
comment|/* allocate an array with enough elements to hold all the keys. */
name|ary
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|apr_hash_count
argument_list|(
name|ht
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_sort__item_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* loop over hash table and push all keys into the array */
name|sorted
operator|=
name|TRUE
expr_stmt|;
name|prev_item
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|ht
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_sort__item_t
modifier|*
name|item
init|=
name|apr_array_push
argument_list|(
name|ary
argument_list|)
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|item
operator|->
name|key
argument_list|,
operator|&
name|item
operator|->
name|klen
argument_list|,
operator|&
name|item
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_item
operator|==
name|NULL
condition|)
block|{
name|prev_item
operator|=
name|item
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sorted
condition|)
block|{
name|sorted
operator|=
operator|(
name|comparison_func
argument_list|(
name|prev_item
argument_list|,
name|item
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
name|prev_item
operator|=
name|item
expr_stmt|;
block|}
block|}
comment|/* quicksort the array if it isn't already sorted.  */
if|if
condition|(
operator|!
name|sorted
condition|)
name|qsort
argument_list|(
name|ary
operator|->
name|elts
argument_list|,
name|ary
operator|->
name|nelts
argument_list|,
name|ary
operator|->
name|elt_size
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|comparison_func
argument_list|)
expr_stmt|;
return|return
name|ary
return|;
block|}
end_function

begin_comment
comment|/* Return the lowest index at which the element *KEY should be inserted into    the array at BASE which has NELTS elements of size ELT_SIZE bytes each,    according to the ordering defined by COMPARE_FUNC.    0<= NELTS<= INT_MAX, 1<= ELT_SIZE<= INT_MAX.    The array must already be sorted in the ordering defined by COMPARE_FUNC.    COMPARE_FUNC is defined as for the C stdlib function bsearch().    Note: This function is modeled on bsearch() and on lower_bound() in the    C++ STL.  */
end_comment

begin_function
specifier|static
name|int
name|bsearch_lower_bound
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|base
parameter_list|,
name|int
name|nelts
parameter_list|,
name|int
name|elt_size
parameter_list|,
name|int
function_decl|(
modifier|*
name|compare_func
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|lower
init|=
literal|0
decl_stmt|;
name|int
name|upper
init|=
name|nelts
operator|-
literal|1
decl_stmt|;
comment|/* Binary search for the lowest position at which to insert KEY. */
while|while
condition|(
name|lower
operator|<=
name|upper
condition|)
block|{
name|int
name|try
init|=
name|lower
operator|+
operator|(
name|upper
operator|-
name|lower
operator|)
operator|/
literal|2
decl_stmt|;
comment|/* careful to avoid overflow */
name|int
name|cmp
init|=
name|compare_func
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
operator|+
name|try
operator|*
name|elt_size
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|lower
operator|=
name|try
operator|+
literal|1
expr_stmt|;
else|else
name|upper
operator|=
name|try
operator|-
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|lower
operator|==
name|upper
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|lower
return|;
block|}
end_function

begin_function
name|int
name|svn_sort__bsearch_lower_bound
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|array
parameter_list|,
name|int
function_decl|(
modifier|*
name|compare_func
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
return|return
name|bsearch_lower_bound
argument_list|(
name|key
argument_list|,
name|array
operator|->
name|elts
argument_list|,
name|array
operator|->
name|nelts
argument_list|,
name|array
operator|->
name|elt_size
argument_list|,
name|compare_func
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_sort__array_insert
parameter_list|(
specifier|const
name|void
modifier|*
name|new_element
parameter_list|,
name|apr_array_header_t
modifier|*
name|array
parameter_list|,
name|int
name|insert_index
parameter_list|)
block|{
name|int
name|elements_to_move
decl_stmt|;
name|char
modifier|*
name|new_position
decl_stmt|;
name|assert
argument_list|(
literal|0
operator|<=
name|insert_index
operator|&&
name|insert_index
operator|<=
name|array
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|elements_to_move
operator|=
name|array
operator|->
name|nelts
operator|-
name|insert_index
expr_stmt|;
comment|/* before bumping nelts */
comment|/* Grow the array, allocating a new space at the end. Note: this can      reallocate the array's "elts" at a different address. */
name|apr_array_push
argument_list|(
name|array
argument_list|)
expr_stmt|;
comment|/* Move the elements after INSERT_INDEX along. (When elements_to_move == 0,      this is a no-op.) */
name|new_position
operator|=
operator|(
name|char
operator|*
operator|)
name|array
operator|->
name|elts
operator|+
name|insert_index
operator|*
name|array
operator|->
name|elt_size
expr_stmt|;
name|memmove
argument_list|(
name|new_position
operator|+
name|array
operator|->
name|elt_size
argument_list|,
name|new_position
argument_list|,
name|array
operator|->
name|elt_size
operator|*
name|elements_to_move
argument_list|)
expr_stmt|;
comment|/* Copy in the new element */
name|memcpy
argument_list|(
name|new_position
argument_list|,
name|new_element
argument_list|,
name|array
operator|->
name|elt_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_sort__array_delete
parameter_list|(
name|apr_array_header_t
modifier|*
name|arr
parameter_list|,
name|int
name|delete_index
parameter_list|,
name|int
name|elements_to_delete
parameter_list|)
block|{
comment|/* Do we have a valid index and are there enough elements? */
if|if
condition|(
name|delete_index
operator|>=
literal|0
operator|&&
name|delete_index
operator|<
name|arr
operator|->
name|nelts
operator|&&
name|elements_to_delete
operator|>
literal|0
operator|&&
operator|(
name|elements_to_delete
operator|+
name|delete_index
operator|)
operator|<=
name|arr
operator|->
name|nelts
condition|)
block|{
comment|/* If we are not deleting a block of elements that extends to the end          of the array, then we need to move the remaining elements to keep          the array contiguous. */
if|if
condition|(
operator|(
name|elements_to_delete
operator|+
name|delete_index
operator|)
operator|<
name|arr
operator|->
name|nelts
condition|)
name|memmove
argument_list|(
name|arr
operator|->
name|elts
operator|+
name|arr
operator|->
name|elt_size
operator|*
name|delete_index
argument_list|,
name|arr
operator|->
name|elts
operator|+
operator|(
name|arr
operator|->
name|elt_size
operator|*
operator|(
name|delete_index
operator|+
name|elements_to_delete
operator|)
operator|)
argument_list|,
name|arr
operator|->
name|elt_size
operator|*
operator|(
name|arr
operator|->
name|nelts
operator|-
name|elements_to_delete
operator|-
name|delete_index
operator|)
argument_list|)
expr_stmt|;
comment|/* Delete the last ELEMENTS_TO_DELETE elements. */
name|arr
operator|->
name|nelts
operator|-=
name|elements_to_delete
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_sort__array_reverse
parameter_list|(
name|apr_array_header_t
modifier|*
name|array
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|array
operator|->
name|elt_size
operator|==
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|->
name|nelts
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|swap_index
init|=
name|array
operator|->
name|nelts
operator|-
name|i
operator|-
literal|1
decl_stmt|;
name|void
modifier|*
name|tmp
init|=
name|APR_ARRAY_IDX
argument_list|(
name|array
argument_list|,
name|i
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|array
argument_list|,
name|i
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|array
argument_list|,
name|swap_index
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|array
argument_list|,
name|swap_index
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
block|{
name|apr_size_t
name|sz
init|=
name|array
operator|->
name|elt_size
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|sz
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|->
name|nelts
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|swap_index
init|=
name|array
operator|->
name|nelts
operator|-
name|i
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|x
init|=
name|array
operator|->
name|elts
operator|+
operator|(
name|sz
operator|*
name|i
operator|)
decl_stmt|;
name|char
modifier|*
name|y
init|=
name|array
operator|->
name|elts
operator|+
operator|(
name|sz
operator|*
name|swap_index
operator|)
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|x
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|y
argument_list|,
name|tmp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

