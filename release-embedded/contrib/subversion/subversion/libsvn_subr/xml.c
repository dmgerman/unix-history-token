begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * xml.c:  xml helper code shared among the Subversion libraries.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* for SVN_HAVE_OLD_EXPAT */
end_comment

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_OLD_EXPAT
end_ifdef

begin_include
include|#
directive|include
file|<xmlparse.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XML_UNICODE
end_ifdef

begin_error
error|#
directive|error
error|Expat is unusable -- it has been compiled for wide characters
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The private internals for a parser object. */
end_comment

begin_struct
struct|struct
name|svn_xml_parser_t
block|{
comment|/** the expat parser */
name|XML_Parser
name|parser
decl_stmt|;
comment|/** the SVN callbacks to call from the Expat callbacks */
name|svn_xml_start_elem
name|start_handler
decl_stmt|;
name|svn_xml_end_elem
name|end_handler
decl_stmt|;
name|svn_xml_char_data
name|data_handler
decl_stmt|;
comment|/** the user's baton for private data */
name|void
modifier|*
name|baton
decl_stmt|;
comment|/** if non-@c NULL, an error happened while parsing */
name|svn_error_t
modifier|*
name|error
decl_stmt|;
comment|/** where this object is allocated, so we can free it easily */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/*** XML character validation ***/
end_comment

begin_function
name|svn_boolean_t
name|svn_xml_is_xml_safe
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|svn_utf__is_valid
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|p
operator|=
name|data
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|svn_ctype_iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|!=
name|SVN_CTYPE_ASCII_TAB
operator|)
operator|&&
operator|(
name|c
operator|!=
name|SVN_CTYPE_ASCII_LINEFEED
operator|)
operator|&&
operator|(
name|c
operator|!=
name|SVN_CTYPE_ASCII_CARRIAGERETURN
operator|)
operator|&&
operator|(
name|c
operator|!=
name|SVN_CTYPE_ASCII_DELETE
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** XML escaping. ***/
end_comment

begin_comment
comment|/* ### ...?  *  * If *OUTSTR is @c NULL, set *OUTSTR to a new stringbuf allocated  * in POOL, else append to the existing stringbuf there.  */
end_comment

begin_function
specifier|static
name|void
name|xml_escape_cdata
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|data
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|*
name|outstr
operator|==
name|NULL
condition|)
operator|*
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find a character which needs to be quoted and append bytes up          to that point.  Strictly speaking, '>' only needs to be          quoted if it follows "]]", but it's easier to quote it all          the time.           So, why are we escaping '\r' here?  Well, according to the          XML spec, '\r\n' gets converted to '\n' during XML parsing.          Also, any '\r' not followed by '\n' is converted to '\n'.  By          golly, if we say we want to escape a '\r', we want to make          sure it remains a '\r'!  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|end
operator|&&
operator|*
name|q
operator|!=
literal|'&'
operator|&&
operator|*
name|q
operator|!=
literal|'<'
operator|&&
operator|*
name|q
operator|!=
literal|'>'
operator|&&
operator|*
name|q
operator|!=
literal|'\r'
condition|)
name|q
operator|++
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
operator|*
name|outstr
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
comment|/* We may already be a winner.  */
if|if
condition|(
name|q
operator|==
name|end
condition|)
break|break;
comment|/* Append the entity reference for the character.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|'&'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'<'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'>'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'\r'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&#13;"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Essentially the same as xml_escape_cdata, with the addition of    whitespace and quote characters. */
end_comment

begin_function
specifier|static
name|void
name|xml_escape_attr
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|data
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|*
name|outstr
operator|==
name|NULL
condition|)
operator|*
name|outstr
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find a character which needs to be quoted and append bytes up          to that point. */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|end
operator|&&
operator|*
name|q
operator|!=
literal|'&'
operator|&&
operator|*
name|q
operator|!=
literal|'<'
operator|&&
operator|*
name|q
operator|!=
literal|'>'
operator|&&
operator|*
name|q
operator|!=
literal|'"'
operator|&&
operator|*
name|q
operator|!=
literal|'\''
operator|&&
operator|*
name|q
operator|!=
literal|'\r'
operator|&&
operator|*
name|q
operator|!=
literal|'\n'
operator|&&
operator|*
name|q
operator|!=
literal|'\t'
condition|)
name|q
operator|++
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
operator|*
name|outstr
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
comment|/* We may already be a winner.  */
if|if
condition|(
name|q
operator|==
name|end
condition|)
break|break;
comment|/* Append the entity reference for the character.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|'&'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'<'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'>'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'"'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&quot;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'\''
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&apos;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'\r'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&#13;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'\n'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&#10;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'\t'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
literal|"&#9;"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_xml_escape_cdata_stringbuf
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xml_escape_cdata
argument_list|(
name|outstr
argument_list|,
name|string
operator|->
name|data
argument_list|,
name|string
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_escape_cdata_string
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xml_escape_cdata
argument_list|(
name|outstr
argument_list|,
name|string
operator|->
name|data
argument_list|,
name|string
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_escape_cdata_cstring
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xml_escape_cdata
argument_list|(
name|outstr
argument_list|,
name|string
argument_list|,
operator|(
name|apr_size_t
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_escape_attr_stringbuf
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xml_escape_attr
argument_list|(
name|outstr
argument_list|,
name|string
operator|->
name|data
argument_list|,
name|string
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_escape_attr_string
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xml_escape_attr
argument_list|(
name|outstr
argument_list|,
name|string
operator|->
name|data
argument_list|,
name|string
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_escape_attr_cstring
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xml_escape_attr
argument_list|(
name|outstr
argument_list|,
name|string
argument_list|,
operator|(
name|apr_size_t
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_xml_fuzzy_escape
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|string
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|outstr
decl_stmt|;
name|char
name|escaped_char
index|[
literal|6
index|]
decl_stmt|;
comment|/* ? \ u u u \0 */
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|<
name|end
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|svn_ctype_iscntrl
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
operator|!
operator|(
operator|(
operator|*
name|q
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'\t'
operator|)
operator|)
condition|)
break|break;
block|}
comment|/* Return original string if no unsafe characters found. */
if|if
condition|(
name|q
operator|==
name|end
condition|)
return|return
name|string
return|;
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
comment|/* Traverse till either unsafe character or eos. */
while|while
condition|(
operator|(
name|q
operator|<
name|end
operator|)
operator|&&
operator|(
operator|(
operator|!
name|svn_ctype_iscntrl
argument_list|(
operator|*
name|q
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'\t'
operator|)
operator|)
condition|)
name|q
operator|++
expr_stmt|;
comment|/* copy chunk before marker */
name|svn_stringbuf_appendbytes
argument_list|(
name|outstr
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|end
condition|)
break|break;
comment|/* Append an escaped version of the unsafe character.           ### This format was chosen for consistency with          ### svn_utf__cstring_from_utf8_fuzzy().  The two functions          ### should probably share code, even though they escape          ### different characters.       */
name|apr_snprintf
argument_list|(
name|escaped_char
argument_list|,
sizeof|sizeof
argument_list|(
name|escaped_char
argument_list|)
argument_list|,
literal|"?\\%03u"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|outstr
argument_list|,
name|escaped_char
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|outstr
operator|->
name|data
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Map from the Expat callback types to the SVN XML types. ***/
end_comment

begin_function
specifier|static
name|void
name|expat_start_handler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|svn_xml_parser_t
modifier|*
name|svn_parser
init|=
name|userData
decl_stmt|;
call|(
modifier|*
name|svn_parser
operator|->
name|start_handler
call|)
argument_list|(
name|svn_parser
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|atts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expat_end_handler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|svn_xml_parser_t
modifier|*
name|svn_parser
init|=
name|userData
decl_stmt|;
call|(
modifier|*
name|svn_parser
operator|->
name|end_handler
call|)
argument_list|(
name|svn_parser
operator|->
name|baton
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expat_data_handler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|svn_xml_parser_t
modifier|*
name|svn_parser
init|=
name|userData
decl_stmt|;
call|(
modifier|*
name|svn_parser
operator|->
name|data_handler
call|)
argument_list|(
name|svn_parser
operator|->
name|baton
argument_list|,
name|s
argument_list|,
operator|(
name|apr_size_t
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Making a parser. ***/
end_comment

begin_function
name|svn_xml_parser_t
modifier|*
name|svn_xml_make_parser
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_xml_start_elem
name|start_handler
parameter_list|,
name|svn_xml_end_elem
name|end_handler
parameter_list|,
name|svn_xml_char_data
name|data_handler
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_xml_parser_t
modifier|*
name|svn_parser
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|start_handler
condition|?
name|expat_start_handler
else|:
name|NULL
argument_list|,
name|end_handler
condition|?
name|expat_end_handler
else|:
name|NULL
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|data_handler
condition|?
name|expat_data_handler
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* ### we probably don't want this pool; or at least we should pass it      ### to the callbacks and clear it periodically.  */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_parser
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|svn_parser
argument_list|)
argument_list|)
expr_stmt|;
name|svn_parser
operator|->
name|parser
operator|=
name|parser
expr_stmt|;
name|svn_parser
operator|->
name|start_handler
operator|=
name|start_handler
expr_stmt|;
name|svn_parser
operator|->
name|end_handler
operator|=
name|end_handler
expr_stmt|;
name|svn_parser
operator|->
name|data_handler
operator|=
name|data_handler
expr_stmt|;
name|svn_parser
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
name|svn_parser
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
comment|/* store our parser info as the UserData in the Expat parser */
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|svn_parser
argument_list|)
expr_stmt|;
return|return
name|svn_parser
return|;
block|}
end_function

begin_comment
comment|/* Free a parser */
end_comment

begin_function
name|void
name|svn_xml_free_parser
parameter_list|(
name|svn_xml_parser_t
modifier|*
name|svn_parser
parameter_list|)
block|{
comment|/* Free the expat parser */
name|XML_ParserFree
argument_list|(
name|svn_parser
operator|->
name|parser
argument_list|)
expr_stmt|;
comment|/* Free the subversion parser */
name|svn_pool_destroy
argument_list|(
name|svn_parser
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_xml_parse
parameter_list|(
name|svn_xml_parser_t
modifier|*
name|svn_parser
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_boolean_t
name|is_final
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|success
decl_stmt|;
comment|/* Parse some xml data */
name|success
operator|=
name|XML_Parse
argument_list|(
name|svn_parser
operator|->
name|parser
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|is_final
argument_list|)
expr_stmt|;
comment|/* If expat choked internally, return its error. */
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|/* Line num is "int" in Expat v1, "long" in v2; hide the difference. */
name|long
name|line
init|=
name|XML_GetCurrentLineNumber
argument_list|(
name|svn_parser
operator|->
name|parser
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed XML: %s at line %ld"
argument_list|)
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|svn_parser
operator|->
name|parser
argument_list|)
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Kill all parsers and return the expat error */
name|svn_xml_free_parser
argument_list|(
name|svn_parser
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Did an error occur somewhere *inside* the expat callbacks? */
if|if
condition|(
name|svn_parser
operator|->
name|error
condition|)
block|{
name|err
operator|=
name|svn_parser
operator|->
name|error
expr_stmt|;
name|svn_xml_free_parser
argument_list|(
name|svn_parser
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_xml_signal_bailout
parameter_list|(
name|svn_error_t
modifier|*
name|error
parameter_list|,
name|svn_xml_parser_t
modifier|*
name|svn_parser
parameter_list|)
block|{
comment|/* This will cause the current XML_Parse() call to finish quickly! */
name|XML_SetElementHandler
argument_list|(
name|svn_parser
operator|->
name|parser
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|svn_parser
operator|->
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Once outside of XML_Parse(), the existence of this field will      cause svn_delta_parse()'s main read-loop to return error. */
name|svn_parser
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Attribute walking. ***/
end_comment

begin_function
specifier|const
name|char
modifier|*
name|svn_xml_get_attr_value
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|atts
parameter_list|)
block|{
while|while
condition|(
name|atts
operator|&&
operator|(
operator|*
name|atts
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|atts
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|atts
index|[
literal|1
index|]
return|;
else|else
name|atts
operator|+=
literal|2
expr_stmt|;
comment|/* continue looping */
block|}
comment|/* Else no such attribute name seen. */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Printing XML ***/
end_comment

begin_function
name|void
name|svn_xml_make_header2
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
operator|*
name|str
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"<?xml version=\"1.0\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
condition|)
block|{
name|encoding
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|" encoding=\"%s\""
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"?>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Creating attribute hashes. ***/
end_comment

begin_comment
comment|/* Combine an existing attribute list ATTS with a HASH that itself    represents an attribute list.  Iff PRESERVE is true, then no value    already in HASH will be changed, else values from ATTS will    override previous values in HASH. */
end_comment

begin_function
specifier|static
name|void
name|amalgamate
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|,
name|apr_hash_t
modifier|*
name|ht
parameter_list|,
name|svn_boolean_t
name|preserve
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
if|if
condition|(
name|atts
condition|)
for|for
control|(
name|key
operator|=
operator|*
name|atts
init|;
name|key
condition|;
name|key
operator|=
operator|*
operator|(
operator|++
name|atts
operator|)
control|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
operator|*
operator|(
operator|++
name|atts
operator|)
decl_stmt|;
name|size_t
name|keylen
decl_stmt|;
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* kff todo: should we also insist that val be non-null here?            Probably. */
name|keylen
operator|=
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve
operator|&&
operator|(
operator|(
name|apr_hash_get
argument_list|(
name|ht
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
continue|continue;
else|else
name|apr_hash_set
argument_list|(
name|ht
argument_list|,
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
argument_list|,
name|keylen
argument_list|,
name|val
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|val
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|svn_xml_ap_to_hash
parameter_list|(
name|va_list
name|ap
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|ht
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|ht
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|ht
return|;
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|svn_xml_make_att_hash
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|ht
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|amalgamate
argument_list|(
name|atts
argument_list|,
name|ht
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* third arg irrelevant in this case */
return|return
name|ht
return|;
block|}
end_function

begin_function
name|void
name|svn_xml_hash_atts_overlaying
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|,
name|apr_hash_t
modifier|*
name|ht
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|amalgamate
argument_list|(
name|atts
argument_list|,
name|ht
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_hash_atts_preserving
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|,
name|apr_hash_t
modifier|*
name|ht
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|amalgamate
argument_list|(
name|atts
argument_list|,
name|ht
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Making XML tags. ***/
end_comment

begin_function
name|void
name|svn_xml_make_open_tag_hash
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|enum
name|svn_xml_open_tag_style
name|style
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
name|apr_hash_t
modifier|*
name|attributes
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_size_t
name|est_size
init|=
name|strlen
argument_list|(
name|tagname
argument_list|)
operator|+
literal|4
operator|+
name|apr_hash_count
argument_list|(
name|attributes
argument_list|)
operator|*
literal|30
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
operator|*
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|est_size
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|attributes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|val
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"\n   "
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"=\""
argument_list|)
expr_stmt|;
name|svn_xml_escape_attr_cstring
argument_list|(
name|str
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|svn_xml_self_closing
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|!=
name|svn_xml_protect_pcdata
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_make_open_tag_v
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|enum
name|svn_xml_open_tag_style
name|style
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|ht
init|=
name|svn_xml_ap_to_hash
argument_list|(
name|ap
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|svn_xml_make_open_tag_hash
argument_list|(
name|str
argument_list|,
name|pool
argument_list|,
name|style
argument_list|,
name|tagname
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_make_open_tag
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|enum
name|svn_xml_open_tag_style
name|style
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
name|svn_xml_make_open_tag_v
argument_list|(
name|str
argument_list|,
name|pool
argument_list|,
name|style
argument_list|,
name|tagname
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_xml_make_close_tag
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
operator|*
name|str
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|"</"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|str
argument_list|,
literal|">\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

