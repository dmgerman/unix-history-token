begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dag.c : DAG-like interface filesystem, private to libsvn_fs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"key-gen.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Initializing a filesystem.  */
end_comment

begin_struct
struct|struct
name|dag_node_t
block|{
comment|/* The filesystem this dag node came from. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* The node revision ID for this dag node, allocated in POOL.  */
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
comment|/* In the special case that this node is the root of a transaction      that has not yet been modified, the node revision ID for this dag      node's predecessor; otherwise NULL. (Used in      svn_fs_node_created_rev.) */
specifier|const
name|svn_fs_id_t
modifier|*
name|fresh_root_predecessor_id
decl_stmt|;
comment|/* The node's type (file, dir, etc.) */
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* The node's NODE-REVISION, or NULL if we haven't read it in yet.      This is allocated in this node's POOL.       If you're willing to respect all the rules above, you can munge      this yourself, but you're probably better off just calling      `get_node_revision' and `set_node_revision', which take care of      things for you.  */
name|node_revision_t
modifier|*
name|node_revision
decl_stmt|;
comment|/* The pool to allocate NODE_REVISION in. */
name|apr_pool_t
modifier|*
name|node_pool
decl_stmt|;
comment|/* the path at which this node was created. */
specifier|const
name|char
modifier|*
name|created_path
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Trivial helper/accessor functions. */
end_comment

begin_function
name|svn_node_kind_t
name|svn_fs_fs__dag_node_kind
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|kind
return|;
block|}
end_function

begin_function
specifier|const
name|svn_fs_id_t
modifier|*
name|svn_fs_fs__dag_get_id
parameter_list|(
specifier|const
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|id
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_fs__dag_get_created_path
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|created_path
return|;
block|}
end_function

begin_function
name|svn_fs_t
modifier|*
name|svn_fs_fs__dag_get_fs
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|fs
return|;
block|}
end_function

begin_function
name|void
name|svn_fs_fs__dag_set_fs
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|node
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dup NODEREV and all associated data into POOL.    Leaves the id and is_fresh_txn_root fields as zero bytes. */
end_comment

begin_function
specifier|static
name|node_revision_t
modifier|*
name|copy_node_revision
parameter_list|(
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|nr
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nr
argument_list|)
argument_list|)
decl_stmt|;
name|nr
operator|->
name|kind
operator|=
name|noderev
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_id
condition|)
name|nr
operator|->
name|predecessor_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|nr
operator|->
name|predecessor_count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|copyfrom_path
condition|)
name|nr
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|noderev
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|nr
operator|->
name|copyfrom_rev
operator|=
name|noderev
operator|->
name|copyfrom_rev
expr_stmt|;
name|nr
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
name|nr
operator|->
name|copyroot_rev
operator|=
name|noderev
operator|->
name|copyroot_rev
expr_stmt|;
name|nr
operator|->
name|data_rep
operator|=
name|svn_fs_fs__rep_copy
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|nr
operator|->
name|prop_rep
operator|=
name|svn_fs_fs__rep_copy
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|nr
operator|->
name|mergeinfo_count
operator|=
name|noderev
operator|->
name|mergeinfo_count
expr_stmt|;
name|nr
operator|->
name|has_mergeinfo
operator|=
name|noderev
operator|->
name|has_mergeinfo
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|created_path
condition|)
name|nr
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
return|return
name|nr
return|;
block|}
end_function

begin_comment
comment|/* Set *NODEREV_P to the cached node-revision for NODE.    If the node-revision was not already cached in NODE, read it in,    allocating the cache in NODE->NODE_POOL.     If you plan to change the contents of NODE, be careful!  We're    handing you a pointer directly to our cached node-revision, not    your own copy.  If you change it as part of some operation, but    then some Berkeley DB function deadlocks or gets an error, you'll    need to back out your changes, or else the cache will reflect    changes that never got committed.  It's probably best not to change    the structure at all.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_revision
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
comment|/* If we've already got a copy, there's no need to read it in.  */
if|if
condition|(
operator|!
name|node
operator|->
name|node_revision
condition|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|node
operator|->
name|node_pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|node_revision
operator|=
name|noderev
expr_stmt|;
block|}
comment|/* Now NODE->node_revision is set.  */
operator|*
name|noderev_p
operator|=
name|node
operator|->
name|node_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fs_fs__dag_check_mutable
parameter_list|(
specifier|const
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|svn_fs_fs__id_txn_id
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|new_node
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Construct the node. */
name|new_node
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|new_node
operator|->
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Grab the contents so we can inspect the node's kind and created path. */
name|new_node
operator|->
name|node_pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|new_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the KIND and CREATED_PATH attributes */
name|new_node
operator|->
name|kind
operator|=
name|noderev
operator|->
name|kind
expr_stmt|;
name|new_node
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|is_fresh_txn_root
condition|)
name|new_node
operator|->
name|fresh_root_predecessor_id
operator|=
name|noderev
operator|->
name|predecessor_id
expr_stmt|;
else|else
name|new_node
operator|->
name|fresh_root_predecessor_id
operator|=
name|NULL
expr_stmt|;
comment|/* Return a fresh new node */
operator|*
name|node
operator|=
name|new_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_revision
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* In the special case that this is an unmodified transaction root,      we need to actually get the revision of the noderev's predecessor      (the revision root); see Issue #2608. */
specifier|const
name|svn_fs_id_t
modifier|*
name|correct_id
init|=
name|node
operator|->
name|fresh_root_predecessor_id
condition|?
name|node
operator|->
name|fresh_root_predecessor_id
else|:
name|node
operator|->
name|id
decl_stmt|;
comment|/* Look up the committed revision from the Node-ID. */
operator|*
name|rev
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|correct_id
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_predecessor_id
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|noderev
operator|->
name|predecessor_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_predecessor_count
parameter_list|(
name|int
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_mergeinfo_count
parameter_list|(
name|apr_int64_t
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|noderev
operator|->
name|mergeinfo_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_has_mergeinfo
parameter_list|(
name|svn_boolean_t
modifier|*
name|has_mergeinfo
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|has_mergeinfo
operator|=
name|noderev
operator|->
name|has_mergeinfo
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_has_descendants_with_mergeinfo
parameter_list|(
name|svn_boolean_t
modifier|*
name|do_they
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
operator|*
name|do_they
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|>
literal|1
condition|)
operator|*
name|do_they
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|==
literal|1
operator|&&
operator|!
name|noderev
operator|->
name|has_mergeinfo
condition|)
operator|*
name|do_they
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|do_they
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Directory node functions ***/
end_comment

begin_comment
comment|/* Some of these are helpers for functions outside this section. */
end_comment

begin_comment
comment|/* Set *ID_P to the node-id for entry NAME in PARENT.  If no such    entry, set *ID_P to NULL but do not error.  The node-id is    allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dir_entry_id_from_node
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entry
argument_list|(
operator|&
name|dirent
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|dirent
condition|?
name|svn_fs_fs__id_copy
argument_list|(
name|dirent
operator|->
name|id
argument_list|,
name|result_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add or set in PARENT a directory entry NAME pointing to ID.    Allocations are done in POOL.     Assumptions:    - PARENT is a mutable directory.    - ID does not refer to an ancestor of parent    - NAME is a single path component */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_entry
parameter_list|(
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|parent_noderev
decl_stmt|;
comment|/* Get the parent's node-revision. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the new entry. */
return|return
name|svn_fs_fs__set_entry
argument_list|(
name|parent
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|parent_noderev
argument_list|,
name|name
argument_list|,
name|id
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a new entry named NAME in PARENT.  If IS_DIR is true, then the    node revision the new entry points to will be a directory, else it    will be a file.  The new node will be allocated in POOL.  PARENT    must be mutable, and must not have an entry named NAME.     Use POOL for all allocations, except caching the node_revision in PARENT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_entry
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_boolean_t
name|is_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|new_node_id
decl_stmt|;
name|node_revision_t
name|new_noderev
decl_stmt|,
modifier|*
name|parent_noderev
decl_stmt|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to create a node with an illegal name '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that parent is a directory */
if|if
condition|(
name|parent
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to create entry in non-directory parent"
argument_list|)
argument_list|)
return|;
comment|/* Check that the parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to clone child of non-mutable node"
argument_list|)
argument_list|)
return|;
comment|/* Create the new node's NODE-REVISION */
name|memset
argument_list|(
operator|&
name|new_noderev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|new_noderev
argument_list|)
argument_list|)
expr_stmt|;
name|new_noderev
operator|.
name|kind
operator|=
name|is_dir
condition|?
name|svn_node_dir
else|:
name|svn_node_file
expr_stmt|;
name|new_noderev
operator|.
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|parent_path
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|new_noderev
operator|.
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|parent_noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
name|new_noderev
operator|.
name|copyroot_rev
operator|=
name|parent_noderev
operator|->
name|copyroot_rev
expr_stmt|;
name|new_noderev
operator|.
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|new_noderev
operator|.
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__create_node
argument_list|(
operator|&
name|new_node_id
argument_list|,
name|svn_fs_fs__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
operator|&
name|new_noderev
argument_list|,
name|svn_fs_fs__id_copy_id
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent
argument_list|)
argument_list|)
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new dag_node_t for our new node */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|svn_fs_fs__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
name|new_node_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can safely call set_entry because we already know that      PARENT is mutable, and we just created CHILD, so we know it has      no ancestors (therefore, PARENT cannot be an ancestor of CHILD) */
return|return
name|set_entry
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
operator|*
name|child_p
argument_list|)
argument_list|,
name|new_noderev
operator|.
name|kind
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get entries of non-directory"
argument_list|)
argument_list|)
return|;
return|return
name|svn_fs_fs__rep_contents_dir
argument_list|(
name|entries
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_dir_entry
parameter_list|(
name|svn_fs_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get entries of non-directory"
argument_list|)
argument_list|)
return|;
comment|/* Get a dirent hash for this directory. */
return|return
name|svn_fs_fs__rep_contents_dir_entry
argument_list|(
name|dirent
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|name
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_set_entry
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry_name
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Check it's a directory. */
if|if
condition|(
name|node
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set entry in non-directory node"
argument_list|)
argument_list|)
return|;
comment|/* Check it's mutable. */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set entry in immutable node"
argument_list|)
argument_list|)
return|;
return|return
name|set_entry
argument_list|(
name|node
argument_list|,
name|entry_name
argument_list|,
name|id
argument_list|,
name|kind
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Proplists. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_set_proplist
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Sanity check: this node better be mutable! */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Can't set proplist on *immutable* node-revision %s"
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the new proplist. */
return|return
name|svn_fs_fs__set_proplist
argument_list|(
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_increment_mergeinfo_count
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_int64_t
name|increment
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Sanity check: this node better be mutable! */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Can't increment mergeinfo count on *immutable* node-revision %s"
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
if|if
condition|(
name|increment
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|mergeinfo_count
operator|+=
name|increment
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|<
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't increment mergeinfo count on node-revision %%s "
literal|"to negative value %%%s"
argument_list|)
argument_list|,
name|APR_INT64_T_FMT
argument_list|)
argument_list|,
name|idstr
operator|->
name|data
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
return|;
block|}
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|>
literal|1
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't increment mergeinfo count on *file* "
literal|"node-revision %%s to %%%s (> 1)"
argument_list|)
argument_list|,
name|APR_INT64_T_FMT
argument_list|)
argument_list|,
name|idstr
operator|->
name|data
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
return|;
block|}
comment|/* Flush it out. */
return|return
name|svn_fs_fs__put_node_revision
argument_list|(
name|node
operator|->
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_set_has_mergeinfo
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_boolean_t
name|has_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Sanity check: this node better be mutable! */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Can't set mergeinfo flag on *immutable* node-revision %s"
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|has_mergeinfo
operator|=
name|has_mergeinfo
expr_stmt|;
comment|/* Flush it out. */
return|return
name|svn_fs_fs__put_node_revision
argument_list|(
name|node
operator|->
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Roots. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_revision_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rev_get_root
argument_list|(
operator|&
name|root_id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_txn_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|,
modifier|*
name|ignored
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_txn_ids
argument_list|(
operator|&
name|root_id
argument_list|,
operator|&
name|ignored
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_txn_base_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|base_root_id
decl_stmt|,
modifier|*
name|ignored
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_txn_ids
argument_list|(
operator|&
name|ignored
argument_list|,
operator|&
name|base_root_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
name|base_root_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_clone_child
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_boolean_t
name|is_parent_copyroot
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|cur_entry
decl_stmt|;
comment|/* parent's current entry named NAME */
specifier|const
name|svn_fs_id_t
modifier|*
name|new_node_id
decl_stmt|;
comment|/* node id we'll put into NEW_NODE */
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* First check that the parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to clone child of non-mutable node"
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to make a child clone with an illegal name '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Find the node named NAME in PARENT's entries list if it exists. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_open
argument_list|(
operator|&
name|cur_entry
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for mutability in the node we found.  If it's mutable, we      don't need to clone it. */
if|if
condition|(
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|cur_entry
argument_list|)
condition|)
block|{
comment|/* This has already been cloned */
name|new_node_id
operator|=
name|cur_entry
operator|->
name|id
expr_stmt|;
block|}
else|else
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|,
modifier|*
name|parent_noderev
decl_stmt|;
comment|/* Go get a fresh NODE-REVISION for current child node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|cur_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_parent_copyroot
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
name|parent_noderev
operator|->
name|copyroot_rev
expr_stmt|;
name|noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|parent_noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
block|}
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|noderev
operator|->
name|predecessor_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|cur_entry
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|noderev
operator|->
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|parent_path
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__create_successor
argument_list|(
operator|&
name|new_node_id
argument_list|,
name|fs
argument_list|,
name|cur_entry
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the ID in the parent's ENTRY list with the ID which          refers to the mutable clone of this child. */
name|SVN_ERR
argument_list|(
name|set_entry
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|new_node_id
argument_list|,
name|noderev
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the youngster. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|fs
argument_list|,
name|new_node_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_clone_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|base_root_id
decl_stmt|,
modifier|*
name|root_id
decl_stmt|;
comment|/* Get the node ID's of the root directories of the transaction and      its base revision.  */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_txn_ids
argument_list|(
operator|&
name|root_id
argument_list|,
operator|&
name|base_root_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Oh, give me a clone...      (If they're the same, we haven't cloned the transaction's root      directory yet.)  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|svn_fs_fs__id_eq
argument_list|(
name|root_id
argument_list|,
name|base_root_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * (Sung to the tune of "Home, Home on the Range", with thanks to    * Randall Garrett and Isaac Asimov.)    */
comment|/* One way or another, root_id now identifies a cloned root node. */
return|return
name|svn_fs_fs__dag_get_node
argument_list|(
name|root_p
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_delete
parameter_list|(
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|parent_noderev
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|parent
operator|->
name|fs
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
comment|/* Make sure parent is a directory. */
if|if
condition|(
name|parent
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to delete entry '%s' from *non*-directory node"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to delete entry '%s' from immutable directory node"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to delete a node with an illegal name '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Get a fresh NODE-REVISION for the parent node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Search this directory for a dirent with that NAME. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir_entry
argument_list|(
operator|&
name|dirent
argument_list|,
name|fs
argument_list|,
name|parent_noderev
argument_list|,
name|name
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we never found ID in ENTRIES (perhaps because there are no      ENTRIES, perhaps because ID just isn't in the existing ENTRIES      ... it doesn't matter), return an error.  */
if|if
condition|(
operator|!
name|dirent
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_ENTRY
argument_list|,
name|NULL
argument_list|,
literal|"Delete failed--directory has no entry '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Copy the ID out of the subpool and release the rest of the      directory listing. */
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|dirent
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* If mutable, remove it and any mutable children from db. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_delete_if_mutable
argument_list|(
name|parent
operator|->
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove this entry from its parent's entries list. */
return|return
name|svn_fs_fs__set_entry
argument_list|(
name|parent
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|parent_noderev
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|svn_node_unknown
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_remove_node
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Fetch the node. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If immutable, do nothing and return immediately. */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted removal of immutable node"
argument_list|)
return|;
comment|/* Delete the node revision. */
return|return
name|svn_fs_fs__delete_node_revision
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_delete_if_mutable
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Get the node. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If immutable, do nothing and return immediately. */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Else it's mutable.  Recurse on directories... */
if|if
condition|(
name|node
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Loop over hash entries */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_delete_if_mutable
argument_list|(
name|fs
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ... then delete the node itself, after deleting any mutable      representations and strings it points to. */
return|return
name|svn_fs_fs__dag_remove_node
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_make_file
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Call our little helper function */
return|return
name|make_entry
argument_list|(
name|child_p
argument_list|,
name|parent
argument_list|,
name|parent_path
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_make_dir
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Call our little helper function */
return|return
name|make_entry
argument_list|(
name|child_p
argument_list|,
name|parent
argument_list|,
name|parent_path
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get textual contents of a *non*-file node"
argument_list|)
return|;
comment|/* Go get a fresh node-revision for FILE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get a stream to the contents. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|contents
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|src_noderev
decl_stmt|;
name|node_revision_t
modifier|*
name|tgt_noderev
decl_stmt|;
comment|/* Make sure our nodes are files. */
if|if
condition|(
operator|(
name|source
operator|&&
name|source
operator|->
name|kind
operator|!=
name|svn_node_file
operator|)
operator|||
name|target
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get textual contents of a *non*-file node"
argument_list|)
return|;
comment|/* Go get fresh node-revisions for the nodes. */
if|if
condition|(
name|source
condition|)
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|src_noderev
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src_noderev
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|tgt_noderev
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the delta stream. */
return|return
name|svn_fs_fs__get_file_delta_stream
argument_list|(
name|stream_p
argument_list|,
name|target
operator|->
name|fs
argument_list|,
name|src_noderev
argument_list|,
name|tgt_noderev
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_try_process_file_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_fs_process_contents_func_t
name|processor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get fresh node-revisions for the nodes. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__try_process_file_contents
argument_list|(
name|success
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|processor
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get length of a *non*-file node"
argument_list|)
return|;
comment|/* Go get a fresh node-revision for FILE, and . */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__file_length
argument_list|(
name|length
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get checksum of a *non*-file node"
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__file_checksum
argument_list|(
name|checksum
argument_list|,
name|noderev
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_edit_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|svn_stream_t
modifier|*
name|ws
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to set textual contents of a *non*-file node"
argument_list|)
return|;
comment|/* Make sure our node is mutable. */
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to set textual contents of an immutable node"
argument_list|)
return|;
comment|/* Get the node revision. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_contents
argument_list|(
operator|&
name|ws
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|ws
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_finalize_edits
parameter_list|(
name|dag_node_t
modifier|*
name|file
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|file_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_file_checksum
argument_list|(
operator|&
name|file_checksum
argument_list|,
name|file
argument_list|,
name|checksum
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|checksum
argument_list|,
name|file_checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|checksum
argument_list|,
name|file_checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|file
operator|->
name|created_path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|dag_node_t
modifier|*
name|svn_fs_fs__dag_dup
parameter_list|(
specifier|const
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Allocate our new node. */
name|dag_node_t
modifier|*
name|new_node
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|)
decl_stmt|;
name|new_node
operator|->
name|fs
operator|=
name|node
operator|->
name|fs
expr_stmt|;
name|new_node
operator|->
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|node
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|kind
operator|=
name|node
operator|->
name|kind
expr_stmt|;
name|new_node
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|node
operator|->
name|created_path
argument_list|)
expr_stmt|;
comment|/* Only copy cached node_revision_t for immutable nodes. */
if|if
condition|(
name|node
operator|->
name|node_revision
operator|&&
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|new_node
operator|->
name|node_revision
operator|=
name|copy_node_revision
argument_list|(
name|node
operator|->
name|node_revision
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|node_revision
operator|->
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|node
operator|->
name|node_revision
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|node_revision
operator|->
name|is_fresh_txn_root
operator|=
name|node
operator|->
name|node_revision
operator|->
name|is_fresh_txn_root
expr_stmt|;
block|}
name|new_node
operator|->
name|node_pool
operator|=
name|pool
expr_stmt|;
return|return
name|new_node
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_serialize
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
init|=
name|in
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
comment|/* create an serialization context and serialize the dag node as root */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|svn_temp_serializer__init
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
literal|1024
operator|-
name|SVN_TEMP_SERIALIZER__OVERHEAD
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* for mutable nodes, we will _never_ cache the noderev */
if|if
condition|(
name|node
operator|->
name|node_revision
operator|&&
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
name|svn_fs_fs__noderev_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|node
operator|->
name|node_revision
argument_list|)
expr_stmt|;
else|else
name|svn_temp_serializer__set_null
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|node
operator|->
name|node_revision
argument_list|)
expr_stmt|;
comment|/* The deserializer will use its own pool. */
name|svn_temp_serializer__set_null
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|node
operator|->
name|node_pool
argument_list|)
expr_stmt|;
comment|/* serialize other sub-structures */
name|svn_fs_fs__id_serialize
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|svn_fs_id_t
operator|*
operator|*
operator|)
operator|&
name|node
operator|->
name|id
argument_list|)
expr_stmt|;
name|svn_fs_fs__id_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|node
operator|->
name|fresh_root_predecessor_id
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|node
operator|->
name|created_path
argument_list|)
expr_stmt|;
comment|/* return serialized data */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_deserialize
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
init|=
operator|(
name|dag_node_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|data_len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Empty noderev in cache"
argument_list|)
argument_list|)
return|;
comment|/* Copy the _full_ buffer as it also contains the sub-structures. */
name|node
operator|->
name|fs
operator|=
name|NULL
expr_stmt|;
comment|/* fixup all references to sub-structures */
name|svn_fs_fs__id_deserialize
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|id
argument_list|)
expr_stmt|;
name|svn_fs_fs__id_deserialize
argument_list|(
name|node
argument_list|,
operator|(
name|svn_fs_id_t
operator|*
operator|*
operator|)
operator|&
name|node
operator|->
name|fresh_root_predecessor_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__noderev_deserialize
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|node_revision
argument_list|)
expr_stmt|;
name|node
operator|->
name|node_pool
operator|=
name|pool
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|node
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|node
operator|->
name|created_path
argument_list|)
expr_stmt|;
comment|/* return result */
operator|*
name|out
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_open
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
comment|/* Ensure that NAME exists in PARENT's entry list. */
name|SVN_ERR
argument_list|(
name|dir_entry_id_from_node
argument_list|(
operator|&
name|node_id
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node_id
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to open non-existent child node '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to open node with an illegal name '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Now get the node that was requested. */
return|return
name|svn_fs_fs__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|svn_fs_fs__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
name|node_id
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_copy
parameter_list|(
name|dag_node_t
modifier|*
name|to_node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry
parameter_list|,
name|dag_node_t
modifier|*
name|from_node
parameter_list|,
name|svn_boolean_t
name|preserve_history
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|preserve_history
condition|)
block|{
name|node_revision_t
modifier|*
name|from_noderev
decl_stmt|,
modifier|*
name|to_noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_id
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|src_id
init|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|from_node
argument_list|)
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|from_node
argument_list|)
decl_stmt|;
comment|/* Make a copy of the original node revision. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|from_noderev
argument_list|,
name|from_node
argument_list|)
argument_list|)
expr_stmt|;
name|to_noderev
operator|=
name|copy_node_revision
argument_list|(
name|from_noderev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Reserve a copy ID for this new copy. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__reserve_copy_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a successor with its predecessor pointing at the copy          source. */
name|to_noderev
operator|->
name|predecessor_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|src_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
name|to_noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|to_noderev
operator|->
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|to_node
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|to_noderev
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|from_path
argument_list|)
expr_stmt|;
name|to_noderev
operator|->
name|copyfrom_rev
operator|=
name|from_rev
expr_stmt|;
comment|/* Set the copyroot equal to our own id. */
name|to_noderev
operator|->
name|copyroot_path
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__create_successor
argument_list|(
operator|&
name|id
argument_list|,
name|fs
argument_list|,
name|src_id
argument_list|,
name|to_noderev
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* don't preserve history */
block|{
name|id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|from_node
argument_list|)
expr_stmt|;
block|}
comment|/* Set the entry in to_node to the new id. */
return|return
name|svn_fs_fs__dag_set_entry
argument_list|(
name|to_node
argument_list|,
name|entry
argument_list|,
name|id
argument_list|,
name|from_node
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Comparison. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_things_different
parameter_list|(
name|svn_boolean_t
modifier|*
name|props_changed
parameter_list|,
name|svn_boolean_t
modifier|*
name|contents_changed
parameter_list|,
name|dag_node_t
modifier|*
name|node1
parameter_list|,
name|dag_node_t
modifier|*
name|node2
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev1
decl_stmt|,
modifier|*
name|noderev2
decl_stmt|;
comment|/* If we have no place to store our results, don't bother doing      anything. */
if|if
condition|(
operator|!
name|props_changed
operator|&&
operator|!
name|contents_changed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* The node revision skels for these two nodes. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev1
argument_list|,
name|node1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev2
argument_list|,
name|node2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compare property keys. */
if|if
condition|(
name|props_changed
operator|!=
name|NULL
condition|)
operator|*
name|props_changed
operator|=
operator|(
operator|!
name|svn_fs_fs__noderev_same_rep_key
argument_list|(
name|noderev1
operator|->
name|prop_rep
argument_list|,
name|noderev2
operator|->
name|prop_rep
argument_list|)
operator|)
expr_stmt|;
comment|/* Compare contents keys. */
if|if
condition|(
name|contents_changed
operator|!=
name|NULL
condition|)
operator|*
name|contents_changed
operator|=
operator|(
operator|!
name|svn_fs_fs__noderev_same_rep_key
argument_list|(
name|noderev1
operator|->
name|data_rep
argument_list|,
name|noderev2
operator|->
name|data_rep
argument_list|)
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_copyroot
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get a fresh node-revision for NODE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
name|noderev
operator|->
name|copyroot_rev
expr_stmt|;
operator|*
name|path
operator|=
name|noderev
operator|->
name|copyroot_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_copyfrom_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get a fresh node-revision for NODE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
name|noderev
operator|->
name|copyfrom_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_get_copyfrom_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get a fresh node-revision for NODE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|path
operator|=
name|noderev
operator|->
name|copyfrom_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__dag_update_ancestry
parameter_list|(
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|source_noderev
decl_stmt|,
modifier|*
name|target_noderev
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to update ancestry of non-mutable node"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|source_noderev
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|target_noderev
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|target_noderev
operator|->
name|predecessor_id
operator|=
name|source
operator|->
name|id
expr_stmt|;
name|target_noderev
operator|->
name|predecessor_count
operator|=
name|source_noderev
operator|->
name|predecessor_count
expr_stmt|;
if|if
condition|(
name|target_noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
name|target_noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
return|return
name|svn_fs_fs__put_node_revision
argument_list|(
name|target
operator|->
name|fs
argument_list|,
name|target
operator|->
name|id
argument_list|,
name|target_noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

