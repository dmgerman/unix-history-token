begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * adm_ops.c: routines for affecting working copy administrative  *            information.  NOTE: this code doesn't know where the adm  *            info is actually stored.  Instead, generic handles to  *            adm data are requested via a reference to some PATH  *            (PATH being a regular, non-administrative directory or  *            file in the working copy).  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_struct
struct|struct
name|svn_wc_committed_queue_t
block|{
comment|/* The pool in which ->queue is allocated. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Mapping (const char *) local_abspath to (committed_queue_item_t *). */
name|apr_hash_t
modifier|*
name|queue
decl_stmt|;
comment|/* Is any item in the queue marked as 'recursive'? */
name|svn_boolean_t
name|have_recursive
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|committed_queue_item_t
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_boolean_t
name|recurse
decl_stmt|;
name|svn_boolean_t
name|no_unlock
decl_stmt|;
name|svn_boolean_t
name|keep_changelist
decl_stmt|;
comment|/* The pristine text checksum. */
specifier|const
name|svn_checksum_t
modifier|*
name|sha1_checksum
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_dav_cache
decl_stmt|;
block|}
name|committed_queue_item_t
typedef|;
end_typedef

begin_function
name|apr_pool_t
modifier|*
name|svn_wc__get_committed_queue_pool
parameter_list|(
specifier|const
name|struct
name|svn_wc_committed_queue_t
modifier|*
name|queue
parameter_list|)
block|{
return|return
name|queue
operator|->
name|pool
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Finishing updates and commits. ***/
end_comment

begin_comment
comment|/* Queue work items that will finish a commit of the file or directory  * LOCAL_ABSPATH in DB:  *   - queue the removal of any "revert-base" props and text files;  *   - queue an update of the DB entry for this node  *  * ### The Pristine Store equivalent should be:  *   - remember the old BASE_NODE and WORKING_NODE pristine text c'sums;  *   - queue an update of the DB entry for this node (incl. updating the  *       BASE_NODE c'sum and setting the WORKING_NODE c'sum to NULL);  *   - queue deletion of the old pristine texts by the remembered checksums.  *  * CHECKSUM is the checksum of the new text base for LOCAL_ABSPATH, and must  * be provided if there is one, else NULL.  *  * STATUS, KIND, PROP_MODS and OLD_CHECKSUM are the current in-db values of  * the node LOCAL_ABSPATH.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_committed_leaf
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|via_recurse
parameter_list|,
name|svn_wc__db_status_t
name|status
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_boolean_t
name|prop_mods
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|old_checksum
parameter_list|,
name|svn_revnum_t
name|new_revnum
parameter_list|,
name|apr_time_t
name|new_changed_date
parameter_list|,
specifier|const
name|char
modifier|*
name|new_changed_author
parameter_list|,
name|apr_hash_t
modifier|*
name|new_dav_cache
parameter_list|,
name|svn_boolean_t
name|no_unlock
parameter_list|,
name|svn_boolean_t
name|keep_changelist
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|new_changed_rev
init|=
name|new_revnum
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
init|=
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|adm_abspath
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|adm_abspath
operator|=
name|local_abspath
expr_stmt|;
else|else
name|adm_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|adm_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_base_remove
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_as_working */
argument_list|,
name|FALSE
comment|/* queue_deletes */
argument_list|,
name|TRUE
comment|/* remove_locks */
argument_list|,
operator|(
operator|!
name|via_recurse
operator|)
condition|?
name|new_revnum
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
condition|)
block|{
comment|/* We are committing the leaf of a copy operation.          We leave the not-present marker to allow pulling in excluded          children of a copy.           The next update will remove the not-present marker. */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|status
operator|==
name|svn_wc__db_status_normal
operator|||
name|status
operator|==
name|svn_wc__db_status_incomplete
operator|||
name|status
operator|==
name|svn_wc__db_status_added
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
comment|/* If we sent a delta (meaning: post-copy modification),          then this file will appear in the queue and so we should have          its checksum already. */
if|if
condition|(
name|checksum
operator|==
name|NULL
condition|)
block|{
comment|/* It was copied and not modified. We must have a text              base for it. And the node should have a checksum. */
name|SVN_ERR_ASSERT
argument_list|(
name|old_checksum
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|old_checksum
expr_stmt|;
comment|/* Is the node completely unmodified and are we recursing? */
if|if
condition|(
name|via_recurse
operator|&&
operator|!
name|prop_mods
condition|)
block|{
comment|/* If a copied node itself is not modified, but the op_root of                  the copy is committed we have to make sure that changed_rev,                  changed_date and changed_author don't change or the working                  copy used for committing will show different last modified                  information then a clean checkout of exactly the same                  revisions. (Issue #3676) */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_changed_rev
argument_list|,
operator|&
name|new_changed_date
argument_list|,
operator|&
name|new_changed_author
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_commit
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prop_mods
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The new text base will be found in the pristine store by its checksum. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_global_commit
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|new_revnum
argument_list|,
name|new_changed_rev
argument_list|,
name|new_changed_date
argument_list|,
name|new_changed_author
argument_list|,
name|checksum
argument_list|,
name|NULL
comment|/* new_children */
argument_list|,
name|new_dav_cache
argument_list|,
name|keep_changelist
argument_list|,
name|no_unlock
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__process_committed_internal
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|recurse
parameter_list|,
name|svn_boolean_t
name|top_of_recurse
parameter_list|,
name|svn_revnum_t
name|new_revnum
parameter_list|,
name|apr_time_t
name|new_date
parameter_list|,
specifier|const
name|char
modifier|*
name|rev_author
parameter_list|,
name|apr_hash_t
modifier|*
name|new_dav_cache
parameter_list|,
name|svn_boolean_t
name|no_unlock
parameter_list|,
name|svn_boolean_t
name|keep_changelist
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|sha1_checksum
parameter_list|,
specifier|const
name|svn_wc_committed_queue_t
modifier|*
name|queue
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|old_checksum
decl_stmt|;
name|svn_boolean_t
name|prop_mods
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|old_checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_mods
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: be wary of making crazy semantic changes in this function, since      svn_wc_process_committed4() calls this.  */
name|SVN_ERR
argument_list|(
name|process_committed_leaf
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|!
name|top_of_recurse
argument_list|,
name|status
argument_list|,
name|kind
argument_list|,
name|prop_mods
argument_list|,
name|old_checksum
argument_list|,
name|new_revnum
argument_list|,
name|new_date
argument_list|,
name|rev_author
argument_list|,
name|new_dav_cache
argument_list|,
name|no_unlock
argument_list|,
name|keep_changelist
argument_list|,
name|sha1_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only check for recursion on nodes that have children */
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
operator|||
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
comment|/* Node deleted -> then no longer a directory */
operator|||
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|recurse
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Read PATH's entries;  this is the absolute path. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recursively loop over all children. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_abspath
decl_stmt|;
specifier|const
name|committed_queue_item_t
modifier|*
name|cqi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|this_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|sha1_checksum
operator|=
name|NULL
expr_stmt|;
name|cqi
operator|=
name|svn_hash_gets
argument_list|(
name|queue
operator|->
name|queue
argument_list|,
name|this_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|cqi
operator|!=
name|NULL
condition|)
name|sha1_checksum
operator|=
name|cqi
operator|->
name|sha1_checksum
expr_stmt|;
comment|/* Recurse.  Pass NULL for NEW_DAV_CACHE, because the              ones present in the current call are only applicable to              this one committed item. */
name|SVN_ERR
argument_list|(
name|svn_wc__process_committed_internal
argument_list|(
name|db
argument_list|,
name|this_abspath
argument_list|,
name|TRUE
comment|/* recurse */
argument_list|,
name|FALSE
comment|/* top_of_recurse */
argument_list|,
name|new_revnum
argument_list|,
name|new_date
argument_list|,
name|rev_author
argument_list|,
name|NULL
comment|/* new_dav_cache */
argument_list|,
name|TRUE
comment|/* no_unlock */
argument_list|,
name|keep_changelist
argument_list|,
name|sha1_checksum
argument_list|,
name|queue
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|svn_wc__prop_array_to_hash
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_hash_t
modifier|*
name|prophash
decl_stmt|;
if|if
condition|(
name|props
operator|==
name|NULL
operator|||
name|props
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|prophash
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
name|APR_ARRAY_IDX
argument_list|(
name|props
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_prop_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|->
name|value
operator|!=
name|NULL
condition|)
name|svn_hash_sets
argument_list|(
name|prophash
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|prophash
return|;
block|}
end_function

begin_function
name|svn_wc_committed_queue_t
modifier|*
name|svn_wc_committed_queue_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_committed_queue_t
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|q
operator|->
name|queue
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|q
operator|->
name|have_recursive
operator|=
name|FALSE
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_queue_committed3
parameter_list|(
name|svn_wc_committed_queue_t
modifier|*
name|queue
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|recurse
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|wcprop_changes
parameter_list|,
name|svn_boolean_t
name|remove_lock
parameter_list|,
name|svn_boolean_t
name|remove_changelist
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|sha1_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|committed_queue_item_t
modifier|*
name|cqi
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|queue
operator|->
name|have_recursive
operator||=
name|recurse
expr_stmt|;
comment|/* Use the same pool as the one QUEUE was allocated in,      to prevent lifetime issues.  Intermediate operations      should use SCRATCH_POOL. */
comment|/* Add to the array with paths and options */
name|cqi
operator|=
name|apr_palloc
argument_list|(
name|queue
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cqi
argument_list|)
argument_list|)
expr_stmt|;
name|cqi
operator|->
name|local_abspath
operator|=
name|local_abspath
expr_stmt|;
name|cqi
operator|->
name|recurse
operator|=
name|recurse
expr_stmt|;
name|cqi
operator|->
name|no_unlock
operator|=
operator|!
name|remove_lock
expr_stmt|;
name|cqi
operator|->
name|keep_changelist
operator|=
operator|!
name|remove_changelist
expr_stmt|;
name|cqi
operator|->
name|sha1_checksum
operator|=
name|sha1_checksum
expr_stmt|;
name|cqi
operator|->
name|new_dav_cache
operator|=
name|svn_wc__prop_array_to_hash
argument_list|(
name|wcprop_changes
argument_list|,
name|queue
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|queue
operator|->
name|queue
argument_list|,
name|local_abspath
argument_list|,
name|cqi
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if any item of QUEUE is a parent of ITEM and will be    processed recursively, return FALSE otherwise.     The algorithmic complexity of this search implementation is O(queue    length), but it's quite quick. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|have_recursive_parent
parameter_list|(
name|apr_hash_t
modifier|*
name|queue
parameter_list|,
specifier|const
name|committed_queue_item_t
modifier|*
name|item
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|item
operator|->
name|local_abspath
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|queue
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|committed_queue_item_t
modifier|*
name|qi
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|qi
operator|==
name|item
condition|)
continue|continue;
if|if
condition|(
name|qi
operator|->
name|recurse
operator|&&
name|svn_dirent_is_child
argument_list|(
name|qi
operator|->
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_process_committed_queue2
parameter_list|(
name|svn_wc_committed_queue_t
modifier|*
name|queue
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|svn_revnum_t
name|new_revnum
parameter_list|,
specifier|const
name|char
modifier|*
name|rev_date
parameter_list|,
specifier|const
name|char
modifier|*
name|rev_author
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_queue
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_time_t
name|new_date
decl_stmt|;
name|apr_hash_t
modifier|*
name|run_wqs
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
if|if
condition|(
name|rev_date
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|new_date
argument_list|,
name|rev_date
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_date
operator|=
literal|0
expr_stmt|;
comment|/* Process the queued items in order of their paths.  (The requirement is    * probably just that a directory must be processed before its children.) */
name|sorted_queue
operator|=
name|svn_sort__hash
argument_list|(
name|queue
operator|->
name|queue
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_queue
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_sort__item_t
modifier|*
name|sort_item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|sorted_queue
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|committed_queue_item_t
modifier|*
name|cqi
init|=
name|sort_item
operator|->
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Skip this item if it is a child of a recursive item, because it has          been (or will be) accounted for when that recursive item was (or          will be) processed. */
if|if
condition|(
name|queue
operator|->
name|have_recursive
operator|&&
name|have_recursive_parent
argument_list|(
name|queue
operator|->
name|queue
argument_list|,
name|cqi
argument_list|,
name|iterpool
argument_list|)
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|svn_wc__process_committed_internal
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|cqi
operator|->
name|local_abspath
argument_list|,
name|cqi
operator|->
name|recurse
argument_list|,
name|TRUE
comment|/* top_of_recurse */
argument_list|,
name|new_revnum
argument_list|,
name|new_date
argument_list|,
name|rev_author
argument_list|,
name|cqi
operator|->
name|new_dav_cache
argument_list|,
name|cqi
operator|->
name|no_unlock
argument_list|,
name|cqi
operator|->
name|keep_changelist
argument_list|,
name|cqi
operator|->
name|sha1_checksum
argument_list|,
name|queue
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't run the wq now, but remember that we must call it for this          working copy */
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|cqi
operator|->
name|local_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|run_wqs
argument_list|,
name|wcroot_abspath
argument_list|)
condition|)
block|{
name|wcroot_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|wcroot_abspath
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|run_wqs
argument_list|,
name|wcroot_abspath
argument_list|,
name|wcroot_abspath
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure nothing happens if this function is called again.  */
name|apr_hash_clear
argument_list|(
name|queue
operator|->
name|queue
argument_list|)
expr_stmt|;
comment|/* Ok; everything is committed now. Now we can start calling callbacks */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|run_wqs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|wcroot_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Schedule the single node at LOCAL_ABSPATH, of kind KIND, for addition in  * its parent directory in the WC.  It will have the regular properties  * provided in PROPS, or none if that is NULL.  *  * If the node is a file, set its on-disk executable and read-only bits to  * match its properties and lock state,  * ### only if it has an svn:executable or svn:needs-lock property.  * ### This is to match the previous behaviour of setting its props  *     afterwards by calling svn_wc_prop_set4(), but is not very clean.  *  * Sync the on-disk executable and read-only bits accordingly.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_from_disk
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_skel_t
modifier|*
name|work_item
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|props
operator|&&
operator|(
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
operator|||
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_NEEDS_LOCK
argument_list|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_sync_file_flags
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_add_file
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|props
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_item
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_add_directory
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|props
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *REPOS_ROOT_URL and *REPOS_UUID to the repository of the parent of    LOCAL_ABSPATH.  REPOS_ROOT_URL and/or REPOS_UUID may be NULL if not    wanted.  Check that the parent of LOCAL_ABSPATH is a versioned directory    in a state in which a new child node can be scheduled for addition;    return an error if not. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_can_add_to_parent
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|repos_uuid
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_wc__db_status_t
name|parent_status
decl_stmt|;
name|svn_node_kind_t
name|parent_kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|parent_status
argument_list|,
operator|&
name|parent_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|parent_status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|parent_status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|parent_status
operator|==
name|svn_wc__db_status_server_excluded
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Can't find parent directory's node while"
literal|" trying to add '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|parent_status
operator|==
name|svn_wc__db_status_deleted
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_SCHEDULE_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't add '%s' to a parent directory"
literal|" scheduled for deletion"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|parent_kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't schedule an addition of '%s'"
literal|" below a not-directory node"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* If we haven't found the repository info yet, find it now. */
if|if
condition|(
operator|(
name|repos_root_url
operator|&&
operator|!
operator|*
name|repos_root_url
operator|)
operator|||
operator|(
name|repos_uuid
operator|&&
operator|!
operator|*
name|repos_uuid
operator|)
condition|)
block|{
if|if
condition|(
name|parent_status
operator|==
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
name|NULL
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check that the on-disk item at LOCAL_ABSPATH can be scheduled for  * addition to its WC parent directory.  *  * Set *KIND_P to the kind of node to be added, *DB_ROW_EXISTS_P to whether  * it is already a versioned path, and if so, *IS_WC_ROOT_P to whether it's  * a WC root.  *  * ### The checks here, and the outputs, are geared towards svn_wc_add4().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_can_add_node
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|db_row_exists_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_wc_root_p
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_url
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_name
init|=
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|is_wc_root
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_special
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|copyfrom_url
operator|||
operator|(
name|svn_uri_is_canonical
argument_list|(
name|copyfrom_url
argument_list|,
name|scratch_pool
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Check that the proposed node has an acceptable name. */
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|base_name
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_FORBIDDEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't create an entry with a reserved name while trying to add '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_path_check_valid
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure something's there; set KIND and *KIND_P. */
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' not found"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported node kind for path '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind_p
condition|)
operator|*
name|kind_p
operator|=
name|kind
expr_stmt|;
comment|/* Determine whether a DB row for this node EXISTS, and whether it      IS_WC_ROOT.  If it exists, check that it is in an acceptable state for      adding the new node; if not, return an error. */
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|exists
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|exists
operator|=
name|FALSE
expr_stmt|;
name|is_wc_root
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|is_wc_root
operator|=
name|FALSE
expr_stmt|;
name|exists
operator|=
name|TRUE
expr_stmt|;
comment|/* Note that the node may be in conflict even if it does not          * exist on disk (certain tree conflict scenarios). */
if|if
condition|(
name|conflicted
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_FOUND_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is an existing item in conflict; "
literal|"please mark the conflict as resolved "
literal|"before adding a new item here"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|svn_wc__db_status_not_present
case|:
break|break;
case|case
name|svn_wc__db_status_deleted
case|:
comment|/* A working copy root should never have a WORKING_NODE */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|is_wc_root
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc__db_status_normal
case|:
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_wc_root
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_wc_root
operator|&&
name|copyfrom_url
condition|)
block|{
comment|/* Integrate a sub working copy in a parent working copy                      (legacy behavior) */
break|break;
block|}
elseif|else
if|if
condition|(
name|is_wc_root
operator|&&
name|is_special
condition|)
block|{
comment|/* Adding a symlink to a working copy root.                      (special_tests.py 23: externals as symlink targets) */
break|break;
block|}
comment|/* else: Fall through in default error */
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is already under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* err */
if|if
condition|(
name|db_row_exists_p
condition|)
operator|*
name|db_row_exists_p
operator|=
name|exists
expr_stmt|;
if|if
condition|(
name|is_wc_root_p
condition|)
operator|*
name|is_wc_root_p
operator|=
name|is_wc_root
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Convert the nested pristine working copy rooted at LOCAL_ABSPATH into  * a copied subtree in the outer working copy.  *  * LOCAL_ABSPATH must be the root of a nested working copy that has no  * local modifications.  The parent directory of LOCAL_ABSPATH must be a  * versioned directory in the outer WC, and must belong to the same  * repository as the nested WC.  The nested WC will be integrated into the  * parent's WC, and will no longer be a separate WC. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|integrate_nested_wc_as_copy
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
specifier|const
name|char
modifier|*
name|moved_abspath
decl_stmt|;
comment|/* Drop any references to the wc that is to be rewritten */
name|SVN_ERR
argument_list|(
name|svn_wc__db_drop_root
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the admin dir from the wc to a temporary location: MOVED_ABSPATH */
block|{
specifier|const
name|char
modifier|*
name|tmpdir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|moved_adm_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|adm_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|tmpdir_abspath
argument_list|,
name|db
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|moved_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|moved_abspath
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|adm_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
literal|""
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|moved_adm_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|moved_abspath
argument_list|,
literal|""
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_move
argument_list|(
name|adm_abspath
argument_list|,
name|moved_adm_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy entries from temporary location into the main db */
name|SVN_ERR
argument_list|(
name|svn_wc_copy3
argument_list|(
name|wc_ctx
argument_list|,
name|moved_abspath
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
comment|/* metadata_only */
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup the temporary admin dir */
name|SVN_ERR
argument_list|(
name|svn_wc__db_drop_root
argument_list|(
name|db
argument_list|,
name|moved_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|moved_abspath
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The subdir is now part of our parent working copy. Our caller assumes      that we return the new node locked, so obtain a lock if we didn't      receive the lock via our depth infinity lock */
block|{
name|svn_boolean_t
name|owns_lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|owns_lock
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owns_lock
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_obtain
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_add4
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_url
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|db_row_exists
decl_stmt|;
name|svn_boolean_t
name|is_wc_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_can_add_node
argument_list|(
operator|&
name|kind
argument_list|,
operator|&
name|db_row_exists
argument_list|,
operator|&
name|is_wc_root
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|copyfrom_url
argument_list|,
name|copyfrom_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get REPOS_ROOT_URL and REPOS_UUID.  Check that the      parent is a versioned directory in an acceptable state. */
name|SVN_ERR
argument_list|(
name|check_can_add_to_parent
argument_list|(
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're performing a repos-to-WC copy, check that the copyfrom      repository is the same as the parent dir's repository. */
if|if
condition|(
name|copyfrom_url
operator|&&
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|copyfrom_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The URL '%s' has a different repository "
literal|"root than its parent"
argument_list|)
argument_list|,
name|copyfrom_url
argument_list|)
return|;
comment|/* Verify that we can actually integrate the inner working copy */
if|if
condition|(
name|is_wc_root
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|,
modifier|*
name|inner_repos_root_url
decl_stmt|,
modifier|*
name|inner_repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|inner_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
operator|&
name|repos_relpath
argument_list|,
operator|&
name|inner_repos_root_url
argument_list|,
operator|&
name|inner_repos_uuid
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|inner_repos_uuid
argument_list|,
name|repos_uuid
argument_list|)
operator|||
name|strcmp
argument_list|(
name|repos_root_url
argument_list|,
name|inner_repos_root_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't schedule the working copy at '%s' "
literal|"from repository '%s' with uuid '%s' "
literal|"for addition under a working copy from "
literal|"repository '%s' with uuid '%s'."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|inner_repos_root_url
argument_list|,
name|inner_repos_uuid
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|)
return|;
name|inner_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|copyfrom_url
argument_list|,
name|inner_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't add '%s' with URL '%s', but with "
literal|"the data from '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|copyfrom_url
argument_list|,
name|inner_url
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|copyfrom_url
condition|)
comment|/* Case 2a: It's a simple add */
block|{
name|SVN_ERR
argument_list|(
name|add_from_disk
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|!
name|db_row_exists
condition|)
block|{
comment|/* If using the legacy 1.6 interface the parent lock may not              be recursive and add is expected to lock the new dir.               ### Perhaps the lock should be created in the same              transaction that adds the node? */
name|svn_boolean_t
name|owns_lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|owns_lock
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owns_lock
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_obtain
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|is_wc_root
condition|)
comment|/* Case 2b: It's a copy from the repository */
block|{
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* This code should never be used, as it doesn't install proper              pristine and/or properties. But it was not an error in the old              version of this function.               ===> Use svn_wc_add_repos_file4() directly! */
name|svn_stream_t
modifier|*
name|content
init|=
name|svn_stream_empty
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_add_repos_file4
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|content
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|copyfrom_url
argument_list|,
name|copyfrom_rev
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|copyfrom_url
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy_dir
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|copyfrom_rev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|copyfrom_rev
argument_list|,
name|NULL
comment|/* children */
argument_list|,
name|FALSE
argument_list|,
name|depth
argument_list|,
name|NULL
comment|/* conflicts */
argument_list|,
name|NULL
comment|/* work items */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Case 1: Integrating a separate WC into this one, in place */
block|{
name|SVN_ERR
argument_list|(
name|integrate_nested_wc_as_copy
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Report the addition to the caller. */
if|if
condition|(
name|notify_func
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
call|(
modifier|*
name|notify_func
call|)
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_add_from_disk2
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_can_add_node
argument_list|(
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_can_add_to_parent
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Canonicalize and check the props */
if|if
condition|(
name|props
condition|)
block|{
name|apr_hash_t
modifier|*
name|new_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__canonicalize_props
argument_list|(
operator|&
name|new_props
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|props
argument_list|,
name|FALSE
comment|/* skip_some_checks */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|=
name|new_props
expr_stmt|;
block|}
comment|/* Add to the DB and maybe update on-disk executable read-only bits */
name|SVN_ERR
argument_list|(
name|add_from_disk
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Report the addition to the caller. */
if|if
condition|(
name|notify_func
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|notify
operator|->
name|mime_type
operator|=
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|notify_func
call|)
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a path where nothing exists on disk, within the admin directory    belonging to the WCROOT_ABSPATH directory.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|nonexistent_path
parameter_list|(
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|SVN_WC__ADM_NONEXISTENT_PATH
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_get_pristine_copy_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pristine_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DB is now open. This is seemingly a "light" function that a caller      may use repeatedly despite error return values. The rest of this      function should aggressively close DB, even in the error case.  */
name|err
operator|=
name|svn_wc__text_base_path_to_read
argument_list|(
name|pristine_path
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
block|{
comment|/* The node doesn't exist, so return a non-existent path located          in WCROOT/.svn/  */
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
operator|*
name|pristine_path
operator|=
name|nonexistent_path
argument_list|(
name|wcroot_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__db_close
argument_list|(
name|db
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_get_pristine_contents2
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__get_pristine_contents
argument_list|(
name|contents
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|get_pristine_lazyopen_baton_t
block|{
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|wri_abspath
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
block|}
name|get_pristine_lazyopen_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implements svn_stream_lazyopen_func_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_pristine_lazyopen_func
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|get_pristine_lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|sha1_checksum
decl_stmt|;
comment|/* svn_wc__db_pristine_read() wants a SHA1, so if we have an MD5,      we'll use it to lookup the SHA1. */
if|if
condition|(
name|b
operator|->
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_sha1
condition|)
name|sha1_checksum
operator|=
name|b
operator|->
name|checksum
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_sha1
argument_list|(
operator|&
name|sha1_checksum
argument_list|,
name|b
operator|->
name|wc_ctx
operator|->
name|db
argument_list|,
name|b
operator|->
name|wri_abspath
argument_list|,
name|b
operator|->
name|checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_read
argument_list|(
name|stream
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|wc_ctx
operator|->
name|db
argument_list|,
name|b
operator|->
name|wri_abspath
argument_list|,
name|sha1_checksum
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_pristine_contents_by_checksum
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|present
decl_stmt|;
operator|*
name|contents
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_check
argument_list|(
operator|&
name|present
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|present
condition|)
block|{
name|get_pristine_lazyopen_baton_t
modifier|*
name|gpl_baton
decl_stmt|;
name|gpl_baton
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gpl_baton
argument_list|)
argument_list|)
expr_stmt|;
name|gpl_baton
operator|->
name|wc_ctx
operator|=
name|wc_ctx
expr_stmt|;
name|gpl_baton
operator|->
name|wri_abspath
operator|=
name|wri_abspath
expr_stmt|;
name|gpl_baton
operator|->
name|checksum
operator|=
name|checksum
expr_stmt|;
operator|*
name|contents
operator|=
name|svn_stream_lazyopen_create
argument_list|(
name|get_pristine_lazyopen_func
argument_list|,
name|gpl_baton
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_add_lock2
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_lock_t
name|db_lock
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|needs_lock
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Enable after fixing callers */
comment|/*SVN_ERR(svn_wc__write_check(wc_ctx->db,                               svn_dirent_dirname(local_abspath, scratch_pool),                               scratch_pool));*/
name|db_lock
operator|.
name|token
operator|=
name|lock
operator|->
name|token
expr_stmt|;
name|db_lock
operator|.
name|owner
operator|=
name|lock
operator|->
name|owner
expr_stmt|;
name|db_lock
operator|.
name|comment
operator|=
name|lock
operator|->
name|comment
expr_stmt|;
name|db_lock
operator|.
name|date
operator|=
name|lock
operator|->
name|creation_date
expr_stmt|;
name|err
operator|=
name|svn_wc__db_lock_add
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|&
name|db_lock
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* Remap the error.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* if svn:needs-lock is present, then make the file read-write. */
name|err
operator|=
name|svn_wc__internal_propget
argument_list|(
operator|&
name|needs_lock
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_NEEDS_LOCK
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
block|{
comment|/* The node has non wc representation (e.g. deleted), so          we don't want to touch the in-wc file */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_lock
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_remove_lock2
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|needs_lock
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Enable after fixing callers */
comment|/*SVN_ERR(svn_wc__write_check(wc_ctx->db,                               svn_dirent_dirname(local_abspath, scratch_pool),                               scratch_pool));*/
name|err
operator|=
name|svn_wc__db_lock_remove
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* Remap the error.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* if svn:needs-lock is present, then make the file read-only. */
name|err
operator|=
name|svn_wc__internal_propget
argument_list|(
operator|&
name|needs_lock
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_NEEDS_LOCK
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Node is shadowed and/or deleted,                               so we shouldn't apply its lock */
block|}
if|if
condition|(
name|needs_lock
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_set_changelist2
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|new_changelist
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelist_filter
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Assert that we aren't being asked to set an empty changelist. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
operator|(
name|new_changelist
operator|&&
name|new_changelist
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_changelist
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|new_changelist
argument_list|,
name|changelist_filter
argument_list|,
name|depth
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|get_cl_fn_baton
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|apr_hash_t
modifier|*
name|clhash
decl_stmt|;
name|svn_changelist_receiver_t
name|callback_func
decl_stmt|;
name|void
modifier|*
name|callback_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_changelist
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|get_cl_fn_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|changelist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|changelist
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_wc__internal_changelist_match
argument_list|(
name|b
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|b
operator|->
name|clhash
argument_list|,
name|scratch_pool
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|callback_func
argument_list|(
name|b
operator|->
name|callback_baton
argument_list|,
name|local_abspath
argument_list|,
name|changelist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_get_changelists
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelist_filter
parameter_list|,
name|svn_changelist_receiver_t
name|callback_func
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|get_cl_fn_baton
name|gnb
decl_stmt|;
name|gnb
operator|.
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|gnb
operator|.
name|clhash
operator|=
name|NULL
expr_stmt|;
name|gnb
operator|.
name|callback_func
operator|=
name|callback_func
expr_stmt|;
name|gnb
operator|.
name|callback_baton
operator|=
name|callback_baton
expr_stmt|;
if|if
condition|(
name|changelist_filter
condition|)
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|gnb
operator|.
name|clhash
argument_list|,
name|changelist_filter
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__internal_walk_children
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|changelist_filter
argument_list|,
name|get_node_changelist
argument_list|,
operator|&
name|gnb
argument_list|,
name|depth
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_wc__internal_changelist_match
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|clhash
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|changelist
decl_stmt|;
if|if
condition|(
name|clhash
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|changelist
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
operator|(
name|changelist
operator|&&
name|svn_hash_gets
argument_list|(
operator|(
name|apr_hash_t
operator|*
operator|)
name|clhash
argument_list|,
name|changelist
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_wc__changelist_match
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|clhash
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_wc__internal_changelist_match
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|clhash
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

end_unit

