begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * adm_crawler.c:  report local WC mods to an Editor.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Helper for report_revisions_and_depths().     Perform an atomic restoration of the file LOCAL_ABSPATH; that is, copy    the file's text-base to the administrative tmp area, and then move    that file to LOCAL_ABSPATH with possible translations/expansions.  If    USE_COMMIT_TIMES is set, then set working file's timestamp to    last-commit-time.  Either way, set entry-timestamp to match that of    the working file when all is finished.     If MARK_RESOLVED_TEXT_CONFLICT is TRUE, mark as resolved any existing    text conflict on LOCAL_ABSPATH.     Not that a valid access baton with a write lock to the directory of    LOCAL_ABSPATH must be available in DB.*/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|restore_file
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_boolean_t
name|mark_resolved_text_conflict
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
comment|/* source_abspath */
argument_list|,
name|use_commit_times
argument_list|,
name|TRUE
comment|/* record_fileinfo */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### we need an existing path for wq_add. not entirely WRI_ABSPATH yet  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add
argument_list|(
name|db
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the work item immediately.  */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* ### nice to have cancel_func/baton */
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove any text conflict */
if|if
condition|(
name|mark_resolved_text_conflict
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__mark_resolved_text_conflict
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_restore
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|!=
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The existing node '%s' can not be restored."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_normal
operator|&&
operator|!
operator|(
operator|(
name|status
operator|==
name|svn_wc__db_status_added
operator|||
name|status
operator|==
name|svn_wc__db_status_incomplete
operator|)
operator|&&
operator|(
name|kind
operator|==
name|svn_node_dir
operator|||
operator|(
name|kind
operator|==
name|svn_node_file
operator|&&
name|checksum
operator|!=
name|NULL
operator|)
comment|/* || (kind == svn_node_symlink&& target)*/
operator|)
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' can not be restored."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|||
name|kind
operator|==
name|svn_node_symlink
condition|)
name|SVN_ERR
argument_list|(
name|restore_file
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|use_commit_times
argument_list|,
name|FALSE
comment|/*mark_resolved_text_conflict*/
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|local_abspath
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Try to restore LOCAL_ABSPATH of node type KIND and if successfull,    notify that the node is restored.  Use DB for accessing the working copy.    If USE_COMMIT_TIMES is set, then set working file's timestamp to    last-commit-time.     This function does all temporary allocations in SCRATCH_POOL  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|restore_node
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|||
name|kind
operator|==
name|svn_node_symlink
condition|)
block|{
comment|/* Recreate file from text-base; mark any text conflict as resolved */
name|SVN_ERR
argument_list|(
name|restore_file
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|use_commit_times
argument_list|,
name|TRUE
comment|/*mark_resolved_text_conflict*/
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* Recreating a directory is just a mkdir */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|local_abspath
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ... report the restoration to the caller.  */
if|if
condition|(
name|notify_func
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_restore
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
call|(
modifier|*
name|notify_func
call|)
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The recursive crawler that describes a mixed-revision working    copy to an RA layer.  Used to initiate updates.     This is a depth-first recursive walk of the children of DIR_ABSPATH    (not including DIR_ABSPATH itself) using DB.  Look at each node and    check if its revision is different than DIR_REV.  If so, report this    fact to REPORTER.  If a node has a different URL than expected, or    a different depth than its parent, report that to REPORTER.     Report DIR_ABSPATH to the reporter as REPORT_RELPATH.     Alternatively, if REPORT_EVERYTHING is set, then report all    children unconditionally.     DEPTH is actually the *requested* depth for the update-like    operation for which we are reporting working copy state.  However,    certain requested depths affect the depth of the report crawl.  For    example, if the requested depth is svn_depth_empty, there's no    point descending into subdirs, no matter what their depths.  So:     If DEPTH is svn_depth_empty, don't report any files and don't    descend into any subdirs.  If svn_depth_files, report files but    still don't descend into subdirs.  If svn_depth_immediates, report    files, and report subdirs themselves but not their entries.  If    svn_depth_infinity or svn_depth_unknown, report everything all the    way down.  (That last sentence might sound counterintuitive, but    since you can't go deeper than the local ambient depth anyway,    requesting svn_depth_infinity really means "as deep as the various    parts of this working copy go".  Of course, the information that    comes back from the server will be different for svn_depth_unknown    than for svn_depth_infinity.)     DIR_REPOS_RELPATH, DIR_REPOS_ROOT and DIR_DEPTH are the repository    relative path, the repository root and depth stored on the directory,    passed here to avoid another database query.     DEPTH_COMPATIBILITY_TRICK means the same thing here as it does    in svn_wc_crawl_revisions5().     If RESTORE_FILES is set, then unexpectedly missing working files    will be restored from text-base and NOTIFY_FUNC/NOTIFY_BATON    will be called to report the restoration.  USE_COMMIT_TIMES is    passed to restore_file() helper. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|report_revisions_and_depths
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|report_relpath
parameter_list|,
name|svn_revnum_t
name|dir_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_root
parameter_list|,
name|svn_depth_t
name|dir_depth
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
name|report_baton
parameter_list|,
name|svn_boolean_t
name|restore_files
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|honor_depth_exclude
parameter_list|,
name|svn_boolean_t
name|depth_compatibility_trick
parameter_list|,
name|svn_boolean_t
name|report_everything
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|base_children
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Get both the SVN Entries and the actual on-disk entries.   Also      notice that we're picking up hidden entries too (read_children never      hides children). */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_children_info
argument_list|(
operator|&
name|base_children
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_files
condition|)
block|{
name|err
operator|=
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|dir_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* There is no directory, and if we could create the directory              we would have already created it when walking the parent              directory */
name|restore_files
operator|=
name|FALSE
expr_stmt|;
name|dirents
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
name|dirents
operator|=
name|NULL
expr_stmt|;
comment|/*** Do the real reporting and recursing. ***/
comment|/* Looping over current directory's BASE children: */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|base_children
argument_list|)
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|child
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_report_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_abspath
decl_stmt|;
name|svn_boolean_t
name|this_switched
init|=
name|FALSE
decl_stmt|;
name|struct
name|svn_wc__db_base_info_t
modifier|*
name|ths
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear the iteration subpool here because the loop has a bunch          of 'continue' jump statements. */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Compute the paths and URLs we need. */
name|this_report_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|report_relpath
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|this_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/*** File Externals **/
if|if
condition|(
name|ths
operator|->
name|update_root
condition|)
block|{
comment|/* File externals are ... special.  We ignore them. */
empty_stmt|;
continue|continue;
block|}
comment|/* First check for exclusion */
if|if
condition|(
name|ths
operator|->
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
block|{
if|if
condition|(
name|honor_depth_exclude
condition|)
block|{
comment|/* Report the excluded path, no matter whether report_everything                  flag is set.  Because the report_everything flag indicates                  that the server will treat the wc as empty and thus push                  full content of the files/subdirs. But we want to prevent the                  server from pushing the full content of this_path at us. */
comment|/* The server does not support link_path report on excluded                  path. We explicitly prohibit this situation in                  svn_wc_crop_tree(). */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|dir_rev
argument_list|,
name|svn_depth_exclude
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We want to pull in the excluded target. So, report it as                  deleted, and server will respond properly. */
if|if
condition|(
operator|!
name|report_everything
condition|)
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|delete_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/*** The Big Tests: ***/
if|if
condition|(
name|ths
operator|->
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|ths
operator|->
name|status
operator|==
name|svn_wc__db_status_not_present
condition|)
block|{
comment|/* If the entry is 'absent' or 'not-present', make sure the server              knows it's gone...              ...unless we're reporting everything, in which case we're              going to report it missing later anyway.               This instructs the server to send it back to us, if it is              now available (an addition after a not-present state), or if              it is now authorized (change in authz for the absent item).  */
if|if
condition|(
operator|!
name|report_everything
condition|)
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|delete_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Is the entry NOT on the disk? We may be able to restore it.  */
if|if
condition|(
name|restore_files
operator|&&
name|svn_hash_gets
argument_list|(
name|dirents
argument_list|,
name|child
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|svn_wc__db_status_t
name|wrk_status
decl_stmt|;
name|svn_node_kind_t
name|wrk_kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|wrk_status
argument_list|,
operator|&
name|wrk_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|this_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wrk_status
operator|==
name|svn_wc__db_status_normal
operator|||
name|wrk_status
operator|==
name|svn_wc__db_status_added
operator|||
name|wrk_status
operator|==
name|svn_wc__db_status_incomplete
operator|)
operator|&&
operator|(
name|wrk_kind
operator|==
name|svn_node_dir
operator|||
name|checksum
operator|)
condition|)
block|{
name|svn_node_kind_t
name|dirent_kind
decl_stmt|;
comment|/* It is possible on a case insensitive system that the                  entry is not really missing, but just cased incorrectly.                  In this case we can't overwrite it with the pristine                  version */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|this_abspath
argument_list|,
operator|&
name|dirent_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_kind
operator|==
name|svn_node_none
condition|)
block|{
name|SVN_ERR
argument_list|(
name|restore_node
argument_list|(
name|db
argument_list|,
name|this_abspath
argument_list|,
name|wrk_kind
argument_list|,
name|use_commit_times
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* And finally prepare for reporting */
if|if
condition|(
operator|!
name|ths
operator|->
name|repos_relpath
condition|)
block|{
name|ths
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dir_repos_relpath
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|childname
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|dir_repos_relpath
argument_list|,
name|ths
operator|->
name|repos_relpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|childname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|childname
argument_list|,
name|child
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|this_switched
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Tweak THIS_DEPTH to a useful value.  */
if|if
condition|(
name|ths
operator|->
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|ths
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
comment|/*** Files ***/
if|if
condition|(
name|ths
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|ths
operator|->
name|kind
operator|==
name|svn_node_symlink
condition|)
block|{
if|if
condition|(
name|report_everything
condition|)
block|{
comment|/* Report the file unconditionally, one way or another. */
if|if
condition|(
name|this_switched
condition|)
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|link_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|dir_repos_root
argument_list|,
name|ths
operator|->
name|repos_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|ths
operator|->
name|depth
argument_list|,
name|FALSE
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|ths
operator|->
name|depth
argument_list|,
name|FALSE
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Possibly report a disjoint URL ... */
elseif|else
if|if
condition|(
name|this_switched
condition|)
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|link_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|dir_repos_root
argument_list|,
name|ths
operator|->
name|repos_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|ths
operator|->
name|depth
argument_list|,
name|FALSE
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... or perhaps just a differing revision or lock token,              or the mere presence of the file in a depth-empty dir. */
elseif|else
if|if
condition|(
name|ths
operator|->
name|revnum
operator|!=
name|dir_rev
operator|||
name|ths
operator|->
name|lock
operator|||
name|dir_depth
operator|==
name|svn_depth_empty
condition|)
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|ths
operator|->
name|depth
argument_list|,
name|FALSE
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* end file case */
comment|/*** Directories (in recursive mode) ***/
elseif|else
if|if
condition|(
name|ths
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|(
name|depth
operator|>
name|svn_depth_files
operator|||
name|depth
operator|==
name|svn_depth_unknown
operator|)
condition|)
block|{
name|svn_boolean_t
name|is_incomplete
decl_stmt|;
name|svn_boolean_t
name|start_empty
decl_stmt|;
name|svn_depth_t
name|report_depth
init|=
name|ths
operator|->
name|depth
decl_stmt|;
name|is_incomplete
operator|=
operator|(
name|ths
operator|->
name|status
operator|==
name|svn_wc__db_status_incomplete
operator|)
expr_stmt|;
name|start_empty
operator|=
name|is_incomplete
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_DEPTH_IS_RECURSIVE
argument_list|(
name|depth
argument_list|)
condition|)
name|report_depth
operator|=
name|svn_depth_empty
expr_stmt|;
comment|/* When a<= 1.6 working copy is upgraded without some of its              subdirectories we miss some information in the database. If we              report the revision as -1, the update editor will receive an              add_directory() while it still knows the directory.               This would raise strange tree conflicts and probably assertions              as it would a BASE vs BASE conflict */
if|if
condition|(
name|is_incomplete
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|ths
operator|->
name|revnum
argument_list|)
condition|)
name|ths
operator|->
name|revnum
operator|=
name|dir_rev
expr_stmt|;
if|if
condition|(
name|depth_compatibility_trick
operator|&&
name|ths
operator|->
name|depth
operator|<=
name|svn_depth_files
operator|&&
name|depth
operator|>
name|ths
operator|->
name|depth
condition|)
block|{
name|start_empty
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|report_everything
condition|)
block|{
comment|/* Report the dir unconditionally, one way or another... */
if|if
condition|(
name|this_switched
condition|)
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|link_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|dir_repos_root
argument_list|,
name|ths
operator|->
name|repos_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|report_depth
argument_list|,
name|start_empty
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|report_depth
argument_list|,
name|start_empty
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_switched
condition|)
block|{
comment|/* ...or possibly report a disjoint URL ... */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|link_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|dir_repos_root
argument_list|,
name|ths
operator|->
name|repos_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|report_depth
argument_list|,
name|start_empty
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ths
operator|->
name|revnum
operator|!=
name|dir_rev
operator|||
name|ths
operator|->
name|lock
operator|||
name|is_incomplete
operator|||
name|dir_depth
operator|==
name|svn_depth_empty
operator|||
name|dir_depth
operator|==
name|svn_depth_files
operator|||
operator|(
name|dir_depth
operator|==
name|svn_depth_immediates
operator|&&
name|ths
operator|->
name|depth
operator|!=
name|svn_depth_empty
operator|)
operator|||
operator|(
name|ths
operator|->
name|depth
operator|<
name|svn_depth_infinity
operator|&&
name|SVN_DEPTH_IS_RECURSIVE
argument_list|(
name|depth
argument_list|)
operator|)
condition|)
block|{
comment|/* ... or perhaps just a differing revision, lock token,                  incomplete subdir, the mere presence of the directory                  in a depth-empty or depth-files dir, or if the parent                  dir is at depth-immediates but the child is not at                  depth-empty.  Also describe shallow subdirs if we are                  trying to set depth to infinity. */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
name|this_report_relpath
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|report_depth
argument_list|,
name|start_empty
argument_list|,
name|ths
operator|->
name|lock
condition|?
name|ths
operator|->
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, recurse if necessary and appropriate. */
if|if
condition|(
name|SVN_DEPTH_IS_RECURSIVE
argument_list|(
name|depth
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|ths
operator|->
name|repos_relpath
decl_stmt|;
if|if
condition|(
name|repos_relpath
operator|==
name|NULL
condition|)
block|{
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dir_repos_relpath
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|report_revisions_and_depths
argument_list|(
name|db
argument_list|,
name|this_abspath
argument_list|,
name|this_report_relpath
argument_list|,
name|ths
operator|->
name|revnum
argument_list|,
name|repos_relpath
argument_list|,
name|dir_repos_root
argument_list|,
name|ths
operator|->
name|depth
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|restore_files
argument_list|,
name|depth
argument_list|,
name|honor_depth_exclude
argument_list|,
name|depth_compatibility_trick
argument_list|,
name|start_empty
argument_list|,
name|use_commit_times
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end directory case */
block|}
comment|/* end main entries loop */
comment|/* We're done examining this dir's entries, so free everything. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*** Public Interfaces ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_crawl_revisions5
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
name|report_baton
parameter_list|,
name|svn_boolean_t
name|restore_files
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|honor_depth_exclude
parameter_list|,
name|svn_boolean_t
name|depth_compatibility_trick
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
name|svn_error_t
modifier|*
name|fserr
decl_stmt|,
modifier|*
name|err
decl_stmt|;
name|svn_revnum_t
name|target_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_boolean_t
name|start_empty
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|target_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|,
modifier|*
name|repos_root_url
decl_stmt|;
name|svn_depth_t
name|target_depth
decl_stmt|;
name|svn_wc__db_lock_t
modifier|*
name|target_lock
decl_stmt|;
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|svn_depth_t
name|report_depth
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the base rev, which is the first revnum that entries will be      compared to, and some other WC info about the target. */
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|target_kind
argument_list|,
operator|&
name|target_rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|target_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|target_lock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|(
name|status
operator|!=
name|svn_wc__db_status_normal
operator|&&
name|status
operator|!=
name|svn_wc__db_status_incomplete
operator|)
condition|)
block|{
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We don't know about this node, so all we have to do is tell          the reporter that we don't know this node.           But first we have to start the report by sending some basic          information for the root. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|delete_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finish the report, which causes the update editor to be          driven. */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|finish_report
argument_list|(
name|report_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|target_depth
operator|==
name|svn_depth_unknown
condition|)
name|target_depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|start_empty
operator|=
operator|(
name|status
operator|==
name|svn_wc__db_status_incomplete
operator|)
expr_stmt|;
if|if
condition|(
name|depth_compatibility_trick
operator|&&
name|target_depth
operator|<=
name|svn_depth_immediates
operator|&&
name|depth
operator|>
name|target_depth
condition|)
block|{
name|start_empty
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|restore_files
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|disk_kind
operator|=
name|svn_node_unknown
expr_stmt|;
comment|/* Determine if there is a missing node that should be restored */
if|if
condition|(
name|restore_files
operator|&&
name|disk_kind
operator|==
name|svn_node_none
condition|)
block|{
name|svn_wc__db_status_t
name|wrk_status
decl_stmt|;
name|svn_node_kind_t
name|wrk_kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|wrk_status
argument_list|,
operator|&
name|wrk_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|wrk_status
operator|=
name|svn_wc__db_status_not_present
expr_stmt|;
name|wrk_kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wrk_status
operator|==
name|svn_wc__db_status_normal
operator|||
name|wrk_status
operator|==
name|svn_wc__db_status_added
operator|||
name|wrk_status
operator|==
name|svn_wc__db_status_incomplete
operator|)
operator|&&
operator|(
name|wrk_kind
operator|==
name|svn_node_dir
operator|||
name|checksum
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|restore_node
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|wrk_kind
argument_list|,
name|use_commit_times
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|report_depth
operator|=
name|target_depth
expr_stmt|;
if|if
condition|(
name|honor_depth_exclude
operator|&&
name|depth
operator|!=
name|svn_depth_unknown
operator|&&
name|depth
operator|<
name|target_depth
condition|)
name|report_depth
operator|=
name|depth
expr_stmt|;
comment|/* The first call to the reporter merely informs it that the        top-level directory being updated is at BASE_REV.  Its PATH        argument is ignored. */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|target_rev
argument_list|,
name|report_depth
argument_list|,
name|start_empty
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|depth
operator|!=
name|svn_depth_empty
condition|)
block|{
comment|/* Recursively crawl ROOT_DIRECTORY and report differing              revisions. */
name|err
operator|=
name|report_revisions_and_depths
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
literal|""
argument_list|,
name|target_rev
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|report_depth
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|restore_files
argument_list|,
name|depth
argument_list|,
name|honor_depth_exclude
argument_list|,
name|depth_compatibility_trick
argument_list|,
name|start_empty
argument_list|,
name|use_commit_times
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|abort_report
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|target_kind
operator|==
name|svn_node_file
operator|||
name|target_kind
operator|==
name|svn_node_symlink
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|svn_wc__db_status_t
name|parent_status
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_relpath
decl_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|parent_abspath
argument_list|,
operator|&
name|base
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* We can assume a file is in the same repository as its parent          directory, so we only look at the relpath. */
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|parent_status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|parent_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|abort_report
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|repos_relpath
argument_list|,
name|svn_relpath_join
argument_list|(
name|parent_repos_relpath
argument_list|,
name|base
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This file is disjoint with respect to its parent              directory.  Since we are looking at the actual target of              the report (not some file in a subdirectory of a target              directory), and that target is a file, we need to pass an              empty string to link_path. */
name|err
operator|=
name|reporter
operator|->
name|link_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|target_rev
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|target_lock
condition|?
name|target_lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|abort_report
goto|;
block|}
elseif|else
if|if
condition|(
name|target_lock
condition|)
block|{
comment|/* If this entry is a file node, we just want to report that              node's revision.  Since we are looking at the actual target              of the report (not some file in a subdirectory of a target              directory), and that target is a file, we need to pass an              empty string to set_path. */
name|err
operator|=
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|target_rev
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|target_lock
condition|?
name|target_lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|abort_report
goto|;
block|}
block|}
comment|/* Finish the report, which causes the update editor to be driven. */
return|return
name|svn_error_trace
argument_list|(
name|reporter
operator|->
name|finish_report
argument_list|(
name|report_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|abort_report
label|:
comment|/* Clean up the fs transaction. */
if|if
condition|(
operator|(
name|fserr
operator|=
name|reporter
operator|->
name|abort_report
argument_list|(
name|report_baton
argument_list|,
name|scratch_pool
argument_list|)
operator|)
condition|)
block|{
name|fserr
operator|=
name|svn_error_quick_wrap
argument_list|(
name|fserr
argument_list|,
name|_
argument_list|(
literal|"Error aborting report"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_compose
argument_list|(
name|err
argument_list|,
name|fserr
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*** Copying stream ***/
end_comment

begin_comment
comment|/* A copying stream is a bit like the unix tee utility:  *  * It reads the SOURCE when asked for data and while returning it,  * also writes the same data to TARGET.  */
end_comment

begin_struct
struct|struct
name|copying_stream_baton
block|{
comment|/* Stream to read input from. */
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
comment|/* Stream to write all data read to. */
name|svn_stream_t
modifier|*
name|target
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_copy
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|copying_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|btn
operator|->
name|source
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|target
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_copy
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|copying_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|btn
operator|->
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stream_close
argument_list|(
name|btn
operator|->
name|source
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a stream - allocated in POOL - which reads its input  * from SOURCE and, while returning that to the caller, at the  * same time writes that to TARGET.  */
end_comment

begin_function
specifier|static
name|svn_stream_t
modifier|*
name|copying_stream
parameter_list|(
name|svn_stream_t
modifier|*
name|source
parameter_list|,
name|svn_stream_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|copying_stream_baton
modifier|*
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|baton
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_copy
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler_copy
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Set *STREAM to a stream from which the caller can read the pristine text  * of the working version of the file at LOCAL_ABSPATH.  If the working  * version of LOCAL_ABSPATH has no pristine text because it is locally  * added, set *STREAM to an empty stream.  If the working version of  * LOCAL_ABSPATH is not a file, return an error.  *  * Set *EXPECTED_MD5_CHECKSUM to the recorded MD5 checksum.  *  * Arrange for the actual checksum of the text to be calculated and written  * into *ACTUAL_MD5_CHECKSUM when the stream is read.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_and_checksum_pristine_text
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|expected_md5_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|actual_md5_checksum
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|base_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_pristine_contents
argument_list|(
operator|&
name|base_stream
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_stream
operator|==
name|NULL
condition|)
block|{
name|base_stream
operator|=
name|svn_stream_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|expected_md5_checksum
operator|=
name|NULL
expr_stmt|;
operator|*
name|actual_md5_checksum
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|svn_checksum_t
modifier|*
name|expected_md5
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|expected_md5
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected_md5
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Pristine checksum for file '%s' is missing"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|expected_md5
operator|->
name|kind
operator|!=
name|svn_checksum_md5
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_md5
argument_list|(
operator|&
name|expected_md5
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|expected_md5
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|expected_md5_checksum
operator|=
name|expected_md5
expr_stmt|;
comment|/* Arrange to set ACTUAL_MD5_CHECKSUM to the MD5 of what is *actually*          found when the base stream is read. */
name|base_stream
operator|=
name|svn_stream_checksummed2
argument_list|(
name|base_stream
argument_list|,
name|actual_md5_checksum
argument_list|,
name|NULL
argument_list|,
name|svn_checksum_md5
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|stream
operator|=
name|base_stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_transmit_text_deltas
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|tempfile
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|new_text_base_md5_checksum
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|new_text_base_sha1_checksum
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|fulltext
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_txdelta_window_handler_t
name|handler
decl_stmt|;
name|void
modifier|*
name|wh_baton
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|expected_md5_checksum
decl_stmt|;
comment|/* recorded MD5 of BASE_S. */
name|svn_checksum_t
modifier|*
name|verify_checksum
decl_stmt|;
comment|/* calc'd MD5 of BASE_STREAM */
name|svn_checksum_t
modifier|*
name|local_md5_checksum
decl_stmt|;
comment|/* calc'd MD5 of LOCAL_STREAM */
name|svn_checksum_t
modifier|*
name|local_sha1_checksum
decl_stmt|;
comment|/* calc'd SHA1 of LOCAL_STREAM */
specifier|const
name|char
modifier|*
name|new_pristine_tmp_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stream_t
modifier|*
name|base_stream
decl_stmt|;
comment|/* delta source */
name|svn_stream_t
modifier|*
name|local_stream
decl_stmt|;
comment|/* delta target: LOCAL_ABSPATH transl. to NF */
comment|/* Translated input */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_translated_stream
argument_list|(
operator|&
name|local_stream
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|SVN_WC_TRANSLATE_TO_NF
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the caller wants a copy of the working file translated to    * repository-normal form, make the copy by tee-ing the stream and set    * *TEMPFILE to the path to it.  This is only needed for the 1.6 API,    * 1.7 doesn't set TEMPFILE.  Even when using the 1.6 API this file    * is not used by the functions that would have used it when using    * the 1.6 code.  It's possible that 3rd party users (if there are any)    * might expect this file to be a text-base. */
if|if
condition|(
name|tempfile
condition|)
block|{
name|svn_stream_t
modifier|*
name|tempstream
decl_stmt|;
comment|/* It can't be the same location as in 1.6 because the admin directory          no longer exists. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tempstream
argument_list|,
name|tempfile
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wrap the translated stream with a new stream that writes the          translated contents into the new text base file as we read from it.          Note that the new text base file will be closed when the new stream          is closed. */
name|local_stream
operator|=
name|copying_stream
argument_list|(
name|local_stream
argument_list|,
name|tempstream
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_text_base_sha1_checksum
condition|)
block|{
name|svn_stream_t
modifier|*
name|new_pristine_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__open_writable_base
argument_list|(
operator|&
name|new_pristine_stream
argument_list|,
operator|&
name|new_pristine_tmp_abspath
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_sha1_checksum
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|local_stream
operator|=
name|copying_stream
argument_list|(
name|local_stream
argument_list|,
name|new_pristine_stream
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* If sending a full text is requested, or if there is no pristine text    * (e.g. the node is locally added), then set BASE_STREAM to an empty    * stream and leave EXPECTED_MD5_CHECKSUM and VERIFY_CHECKSUM as NULL.    *    * Otherwise, set BASE_STREAM to a stream providing the base (source) text    * for the delta, set EXPECTED_MD5_CHECKSUM to its stored MD5 checksum,    * and arrange for its VERIFY_CHECKSUM to be calculated later. */
if|if
condition|(
operator|!
name|fulltext
condition|)
block|{
comment|/* We will be computing a delta against the pristine contents */
comment|/* We need the expected checksum to be an MD-5 checksum rather than a        * SHA-1 because we want to pass it to apply_textdelta(). */
name|SVN_ERR
argument_list|(
name|read_and_checksum_pristine_text
argument_list|(
operator|&
name|base_stream
argument_list|,
operator|&
name|expected_md5_checksum
argument_list|,
operator|&
name|verify_checksum
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send a fulltext. */
name|base_stream
operator|=
name|svn_stream_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|expected_md5_checksum
operator|=
name|NULL
expr_stmt|;
name|verify_checksum
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Tell the editor that we're about to apply a textdelta to the      file baton; the editor returns to us a window consumer and baton.  */
block|{
comment|/* apply_textdelta() is working against a base with this checksum */
specifier|const
name|char
modifier|*
name|base_digest_hex
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|expected_md5_checksum
condition|)
comment|/* ### Why '..._display()'?  expected_md5_checksum should never be all-        * zero, but if it is, we would want to pass NULL not an all-zero        * digest to apply_textdelta(), wouldn't we? */
name|base_digest_hex
operator|=
name|svn_checksum_to_cstring_display
argument_list|(
name|expected_md5_checksum
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|base_digest_hex
argument_list|,
name|scratch_pool
argument_list|,
operator|&
name|handler
argument_list|,
operator|&
name|wh_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Run diff processing, throwing windows at the handler. */
name|err
operator|=
name|svn_txdelta_run
argument_list|(
name|base_stream
argument_list|,
name|local_stream
argument_list|,
name|handler
argument_list|,
name|wh_baton
argument_list|,
name|svn_checksum_md5
argument_list|,
operator|&
name|local_md5_checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Close the two streams to force writing the digest */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_stream_close
argument_list|(
name|base_stream
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_stream_close
argument_list|(
name|local_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have an error, it may be caused by a corrupt text base,      so check the checksum. */
if|if
condition|(
name|expected_md5_checksum
operator|&&
name|verify_checksum
operator|&&
operator|!
name|svn_checksum_match
argument_list|(
name|expected_md5_checksum
argument_list|,
name|verify_checksum
argument_list|)
condition|)
block|{
comment|/* The entry checksum does not match the actual text          base checksum.  Extreme badness. Of course,          theoretically we could just switch to          fulltext transmission here, and everything would          work fine; after all, we're going to replace the          text base with a new one in a moment anyway, and          we'd fix the checksum then.  But it's better to          error out.  People should know that their text          bases are getting corrupted, so they can          investigate.  Other commands could be affected,          too, such as `svn diff'.  */
if|if
condition|(
name|tempfile
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_remove_file2
argument_list|(
operator|*
name|tempfile
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_checksum_mismatch_err
argument_list|(
name|expected_md5_checksum
argument_list|,
name|verify_checksum
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for text base of '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT_TEXT_BASE
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* Now, handle that delta transmission error if any, so we can stop      thinking about it after this point. */
name|SVN_ERR_W
argument_list|(
name|err
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"While preparing '%s' for commit"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_text_base_md5_checksum
condition|)
operator|*
name|new_text_base_md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|local_md5_checksum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_text_base_sha1_checksum
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_install
argument_list|(
name|db
argument_list|,
name|new_pristine_tmp_abspath
argument_list|,
name|local_sha1_checksum
argument_list|,
name|local_md5_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_text_base_sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|local_sha1_checksum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Close the file baton, and get outta here. */
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|local_md5_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_transmit_text_deltas3
parameter_list|(
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|new_text_base_md5_checksum
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|new_text_base_sha1_checksum
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|fulltext
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_wc__internal_transmit_text_deltas
argument_list|(
name|NULL
argument_list|,
name|new_text_base_md5_checksum
argument_list|,
name|new_text_base_sha1_checksum
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|fulltext
argument_list|,
name|editor
argument_list|,
name|file_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_transmit_prop_deltas
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|propmods
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_kind
argument_list|(
operator|&
name|kind
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* allow_missing */
argument_list|,
name|FALSE
comment|/* show_deleted */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* Get an array of local changes by comparing the hashes. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_propdiff
argument_list|(
operator|&
name|propmods
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Apply each local change to the baton */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propmods
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|p
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propmods
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|baton
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|baton
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_transmit_prop_deltas2
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_wc__internal_transmit_prop_deltas
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|editor
argument_list|,
name|baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

end_unit

