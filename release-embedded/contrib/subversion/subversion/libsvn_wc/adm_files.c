begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * adm_files.c: helper routines for handling files& dirs in the  *              working copy administrative area (creating,  *              deleting, opening, and closing).  This is the only  *              code that actually knows where administrative  *              information is kept.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"entries.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** File names in the adm area. ***/
end_comment

begin_comment
comment|/* The default name of the WC admin directory. This name is always    checked by svn_wc_is_adm_dir. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|default_adm_dir_name
index|[]
init|=
literal|".svn"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name that is actually used for the WC admin directory.  The    commonest case where this won't be the default is in Windows    ASP.NET development environments, which used to choke on ".svn". */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|adm_dir_name
init|=
name|default_adm_dir_name
decl_stmt|;
end_decl_stmt

begin_function
name|svn_boolean_t
name|svn_wc_is_adm_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|name
argument_list|,
name|adm_dir_name
argument_list|)
operator|||
literal|0
operator|==
name|strcmp
argument_list|(
name|name
argument_list|,
name|default_adm_dir_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_wc_get_adm_dir
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|adm_dir_name
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_set_adm_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* This is the canonical list of administrative directory names.       FIXME:      An identical list is used in        libsvn_subr/opt.c:svn_opt__args_to_target_array(),      but that function can't use this list, because that use would      create a circular dependency between libsvn_wc and libsvn_subr.      Make sure changes to the lists are always synchronized! */
specifier|static
specifier|const
name|char
modifier|*
name|valid_dir_names
index|[]
init|=
block|{
name|default_adm_dir_name
block|,
literal|"_svn"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|dir_name
decl_stmt|;
for|for
control|(
name|dir_name
operator|=
name|valid_dir_names
init|;
operator|*
name|dir_name
condition|;
operator|++
name|dir_name
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|name
argument_list|,
operator|*
name|dir_name
argument_list|)
condition|)
block|{
comment|/* Use the pointer to the statically allocated string            constant, to avoid potential pool lifetime issues. */
name|adm_dir_name
operator|=
operator|*
name|dir_name
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid administrative "
literal|"directory name"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_wc__adm_child
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|child
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
name|svn_dirent_join_many
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|,
name|adm_dir_name
argument_list|,
name|child
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_wc__adm_area_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|adm_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_wc__adm_child
argument_list|(
name|adm_abspath
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_io_check_path
argument_list|(
name|path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Return early, since kind is undefined in this case. */
return|return
name|FALSE
return|;
block|}
return|return
name|kind
operator|!=
name|svn_node_none
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Making and using files in the adm area. ***/
end_comment

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_adm_subdir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|subdir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fullpath
decl_stmt|;
name|fullpath
operator|=
name|svn_wc__adm_child
argument_list|(
name|path
argument_list|,
name|subdir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_io_dir_make
argument_list|(
name|fullpath
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Syncing files in the adm area. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__text_base_path_to_read
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sanity */
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can only get the pristine contents of files; "
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
condition|)
comment|/* We know that the delete of this node has been committed.        This should be the same as if called on an unknown path. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot get the pristine contents of '%s' "
literal|"because its delete is already committed"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_incomplete
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot get the pristine contents of '%s' "
literal|"because it has an unexpected status"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|checksum
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node '%s' has no pristine text"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_path
argument_list|(
name|result_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|checksum
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_pristine_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_filesize_t
modifier|*
name|size
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|sha1_checksum
decl_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|SVN_INVALID_FILESIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sha1_checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sanity */
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can only get the pristine contents of files; "
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_added
operator|&&
operator|!
name|sha1_checksum
condition|)
block|{
comment|/* Simply added. The pristine base does not exist. */
operator|*
name|contents
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
condition|)
comment|/* We know that the delete of this node has been committed.        This should be the same as if called on an unknown path. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot get the pristine contents of '%s' "
literal|"because its delete is already committed"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_incomplete
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot get the pristine contents of '%s' "
literal|"because it has an unexpected status"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|sha1_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_read
argument_list|(
name|contents
argument_list|,
name|size
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|sha1_checksum
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|contents
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*** Opening and closing files in the adm area. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__open_adm_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|dir_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|fname
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_open_readonly
argument_list|(
name|stream
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__open_writable_base
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|temp_base_abspath
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|md5_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|sha1_checksum
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir_abspath
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|wri_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_tempdir
argument_list|(
operator|&
name|temp_dir_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
name|stream
argument_list|,
name|temp_base_abspath
argument_list|,
name|temp_dir_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|md5_checksum
condition|)
operator|*
name|stream
operator|=
name|svn_stream_checksummed2
argument_list|(
operator|*
name|stream
argument_list|,
name|NULL
argument_list|,
name|md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_checksum
condition|)
operator|*
name|stream
operator|=
name|svn_stream_checksummed2
argument_list|(
operator|*
name|stream
argument_list|,
name|NULL
argument_list|,
name|sha1_checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Checking for and creating administrative subdirs. ***/
end_comment

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_adm_tmp_area
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* SVN_WC__ADM_TMP */
name|SVN_ERR
argument_list|(
name|make_adm_subdir
argument_list|(
name|path
argument_list|,
name|SVN_WC__ADM_TMP
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set up a new adm area for PATH, with REPOS_* as the repos info, and    INITIAL_REV as the starting revision.  The entries file starts out    marked as 'incomplete.  The adm area starts out locked; remember to    unlock it when done. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_adm
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_uuid
parameter_list|,
name|svn_revnum_t
name|initial_rev
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* First, make an empty administrative area. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make_hidden
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/** Make subdirectories. ***/
comment|/* SVN_WC__ADM_PRISTINE */
name|SVN_ERR
argument_list|(
name|make_adm_subdir
argument_list|(
name|local_abspath
argument_list|,
name|SVN_WC__ADM_PRISTINE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### want to add another directory? do a format bump to ensure that      ### all existing working copies get the new directories. or maybe      ### create-on-demand (more expensive)  */
comment|/** Init the tmp area. ***/
name|SVN_ERR
argument_list|(
name|init_adm_tmp_area
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the SDB. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_init
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|initial_rev
argument_list|,
name|depth
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stamp ENTRIES and FORMAT files for old clients.  */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
name|SVN_WC__ADM_ENTRIES
argument_list|,
name|pool
argument_list|)
argument_list|,
name|SVN_WC__NON_ENTRIES_STRING
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
name|SVN_WC__ADM_FORMAT
argument_list|,
name|pool
argument_list|)
argument_list|,
name|SVN_WC__NON_ENTRIES_STRING
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_ensure_adm
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_uuid
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|format
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_root_url
decl_stmt|;
name|svn_boolean_t
name|is_op_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|db_repos_relpath
decl_stmt|,
modifier|*
name|db_repos_root_url
decl_stmt|,
modifier|*
name|db_repos_uuid
decl_stmt|;
name|svn_revnum_t
name|db_revision
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|url
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|repos_root_url
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|repos_uuid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|repos_relpath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_check_wc
argument_list|(
operator|&
name|format
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Early out: we know we're not dealing with an existing wc, so      just create one. */
if|if
condition|(
name|format
operator|==
literal|0
condition|)
return|return
name|svn_error_trace
argument_list|(
name|init_adm
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
operator|&
name|db_revision
argument_list|,
operator|&
name|db_repos_relpath
argument_list|,
operator|&
name|db_repos_root_url
argument_list|,
operator|&
name|db_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|original_repos_relpath
argument_list|,
operator|&
name|original_root_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|is_op_root
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When the directory exists and is scheduled for deletion or is not-present    * do not check the revision or the URL.  The revision can be any    * arbitrary revision and the URL may differ if the add is    * being driven from a merge which will have a different URL. */
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_deleted
operator|&&
name|status
operator|!=
name|svn_wc__db_status_not_present
condition|)
block|{
comment|/* ### Should we match copyfrom_revision? */
if|if
condition|(
name|db_revision
operator|!=
name|revision
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld doesn't match existing "
literal|"revision %ld in '%s'"
argument_list|)
argument_list|,
name|revision
argument_list|,
name|db_revision
argument_list|,
name|local_abspath
argument_list|)
return|;
if|if
condition|(
operator|!
name|db_repos_root_url
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|db_repos_relpath
argument_list|,
operator|&
name|db_repos_root_url
argument_list|,
operator|&
name|db_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
operator|&
name|db_repos_relpath
argument_list|,
operator|&
name|db_repos_root_url
argument_list|,
operator|&
name|db_repos_uuid
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The caller gives us a URL which should match the entry. However,          some callers compensate for an old problem in entry->url and pass          the copyfrom_url instead. See ^/notes/api-errata/1.7/wc002.txt. As          a result, we allow the passed URL to match copyfrom_url if it          does not match the entry's primary URL.  */
if|if
condition|(
name|strcmp
argument_list|(
name|db_repos_uuid
argument_list|,
name|repos_uuid
argument_list|)
operator|||
name|strcmp
argument_list|(
name|db_repos_root_url
argument_list|,
name|repos_root_url
argument_list|)
operator|||
operator|!
name|svn_relpath_skip_ancestor
argument_list|(
name|db_repos_relpath
argument_list|,
name|repos_relpath
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_op_root
comment|/* copy_from was set on op-roots only */
operator|||
name|original_root_url
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|original_root_url
argument_list|,
name|repos_root_url
argument_list|)
operator|||
name|strcmp
argument_list|(
name|original_repos_relpath
argument_list|,
name|repos_relpath
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' (uuid: '%s') doesn't match existing "
literal|"URL '%s' (uuid: '%s') in '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|db_repos_uuid
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|db_repos_root_url
argument_list|,
name|db_repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|repos_uuid
argument_list|,
name|local_abspath
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_ensure_adm4
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_uuid
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__internal_ensure_adm
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__adm_destroy
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_wcroot
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|dir_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_wcroot
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Well, the coast is clear for blowing away the administrative      directory, which also removes remaining locks */
comment|/* Now close the DB, and we can delete the working copy */
if|if
condition|(
name|is_wcroot
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_drop_root
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__adm_cleanup_tmp_area
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|adm_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|adm_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|adm_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the path to the tmp area, and blow it away. */
name|tmp_path
operator|=
name|svn_wc__adm_child
argument_list|(
name|adm_abspath
argument_list|,
name|SVN_WC__ADM_TMP
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|tmp_path
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, rebuild the tmp area. */
return|return
name|svn_error_trace
argument_list|(
name|init_adm_tmp_area
argument_list|(
name|adm_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_tmpdir
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|tmpdir_abspath
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
name|tmpdir_abspath
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

