begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * diff.c :  routines for doing diffs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_comment
comment|/*  * Variance adjustment rules:  *  * See notes/variance-adjusted-patching.html  *  * ###: Expand this comment to contain the full set of adjustment  * ###: rules instead of pointing to a webpage.  */
end_comment

begin_comment
comment|/*  * In the text below consider the following:  *  * O     = Original  * M     = Modified  * L     = Latest  * A     = Ancestor  * X:Y   = diff between X and Y  * X:Y:Z = 3-way diff between X, Y and Z  * P     = O:L, possibly adjusted  *  * diff4 -- Variance adjusted diff algorithm  *  * 1. Create a diff O:L and call that P.  *  * 2. Morph P into a 3-way diff by performing the following  *    transformation: O:L -> O:O:L.  *  * 3. Create a diff A:O.  *  * 4. Using A:O...  *  * #. Using M:A...  *  * #. Resolve conflicts...  *     1. Out-range added line: decrement the line numbers in every hunk in P       that comes after the addition. This undoes the effect of the add, since       the add never happened in D.     2. Out-range deleted line: increment the line numbers in every hunk in P       that comes after the deletion. This undoes the effect of the deletion,       since the deletion never happened in D.     3. Out-range edited line: do nothing. Out-range edits are irrelevant to P.     4. Added line in context range in P: remove the corresponding line from       the context, optionally replacing it with new context based on that       region in M, and adjust line numbers and mappings appropriately.     5. Added line in affected text range in P: this is a dependency problem       -- part of the change T:18-T:19 depends on changes introduced to T after       B branched. There are several possible behaviors, depending on what the       user wants. One is to generate an informative error, stating that       T:18-T:19 depends on some other change (T:N-T:M, where N>=8, M<=18,       and M-N == 1); the exact revisions can be discovered automatically using       the same process as "cvs annotate", though it may take some time to do       so. Another option is to include the change in P, as an insertion of the       "after" version of the text, and adjust line numbers and mappings       accordingly. (And if all this isn't sounding a lot like a directory       merge algorithm, try drinking more of the Kool-Aid.) A third option is       to include it as an insertion, but with metadata (such as CVS-style       conflict markers) indicating that the line attempting to be patched       does not exist in B.     6. Deleted line that is in-range in P: request another universe -- this       situation can't happen in ours.     7. In-range edited line: reverse that edit in the "before" version of the       corresponding line in the appropriate hunk in P, to obtain the version of       the line that will be found in B when P is applied. */
end_comment

begin_function
specifier|static
name|void
name|adjust_diff
parameter_list|(
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
name|svn_diff_t
modifier|*
name|adjust
parameter_list|)
block|{
name|svn_diff_t
modifier|*
name|hunk
decl_stmt|;
name|apr_off_t
name|range_start
decl_stmt|;
name|apr_off_t
name|range_end
decl_stmt|;
name|apr_off_t
name|adjustment
decl_stmt|;
for|for
control|(
init|;
name|adjust
condition|;
name|adjust
operator|=
name|adjust
operator|->
name|next
control|)
block|{
name|range_start
operator|=
name|adjust
operator|->
name|modified_start
expr_stmt|;
name|range_end
operator|=
name|range_start
operator|+
name|adjust
operator|->
name|modified_length
expr_stmt|;
name|adjustment
operator|=
name|adjust
operator|->
name|original_length
operator|-
name|adjust
operator|->
name|modified_length
expr_stmt|;
comment|/* No change in line count, so no modifications. [3, 7] */
if|if
condition|(
name|adjustment
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|hunk
operator|=
name|diff
init|;
name|hunk
condition|;
name|hunk
operator|=
name|hunk
operator|->
name|next
control|)
block|{
comment|/* Changes are in the range before this hunk.  Adjust the start            * of the hunk. [1, 2]            */
if|if
condition|(
name|hunk
operator|->
name|modified_start
operator|>=
name|range_end
condition|)
block|{
name|hunk
operator|->
name|modified_start
operator|+=
name|adjustment
expr_stmt|;
continue|continue;
block|}
comment|/* Changes are in the range beyond this hunk.  No adjustments            * needed. [1, 2]            */
if|if
condition|(
name|hunk
operator|->
name|modified_start
operator|+
name|hunk
operator|->
name|modified_length
operator|<=
name|range_start
condition|)
continue|continue;
comment|/* From here on changes are in the range of this hunk. */
comment|/* This is a context hunk.  Adjust the length. [4]            */
if|if
condition|(
name|hunk
operator|->
name|type
operator|==
name|svn_diff__type_diff_modified
condition|)
block|{
name|hunk
operator|->
name|modified_length
operator|+=
name|adjustment
expr_stmt|;
continue|continue;
block|}
comment|/* Mark as conflicted. This happens in the reverse case when a line            * is added in range and in the forward case when a line is deleted            * in range. [5 (reverse), 6 (forward)]            */
if|if
condition|(
name|adjustment
operator|<
literal|0
condition|)
name|hunk
operator|->
name|type
operator|=
name|svn_diff__type_conflict
expr_stmt|;
comment|/* Adjust the length of this hunk (reverse the change). [5, 6] */
name|hunk
operator|->
name|modified_length
operator|-=
name|adjustment
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_diff4_2
parameter_list|(
name|svn_diff_t
modifier|*
modifier|*
name|diff
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
specifier|const
name|svn_diff_fns2_t
modifier|*
name|vtable
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff__tree_t
modifier|*
name|tree
decl_stmt|;
name|svn_diff__position_t
modifier|*
name|position_list
index|[
literal|4
index|]
decl_stmt|;
name|svn_diff__token_index_t
name|num_tokens
decl_stmt|;
name|svn_diff__token_index_t
modifier|*
name|token_counts
index|[
literal|4
index|]
decl_stmt|;
name|svn_diff_datasource_e
name|datasource
index|[]
init|=
block|{
name|svn_diff_datasource_original
block|,
name|svn_diff_datasource_modified
block|,
name|svn_diff_datasource_latest
block|,
name|svn_diff_datasource_ancestor
block|}
decl_stmt|;
name|svn_diff__lcs_t
modifier|*
name|lcs_ol
decl_stmt|;
name|svn_diff__lcs_t
modifier|*
name|lcs_adjust
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff_ol
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff_adjust
decl_stmt|;
name|svn_diff_t
modifier|*
name|hunk
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool2
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool3
decl_stmt|;
name|apr_off_t
name|prefix_lines
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|suffix_lines
init|=
literal|0
decl_stmt|;
operator|*
name|diff
operator|=
name|NULL
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|subpool2
operator|=
name|svn_pool_create
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|subpool3
operator|=
name|svn_pool_create
argument_list|(
name|subpool2
argument_list|)
expr_stmt|;
name|svn_diff__tree_create
argument_list|(
operator|&
name|tree
argument_list|,
name|subpool3
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|vtable
operator|->
name|datasources_open
argument_list|(
name|diff_baton
argument_list|,
operator|&
name|prefix_lines
argument_list|,
operator|&
name|suffix_lines
argument_list|,
name|datasource
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff__get_tokens
argument_list|(
operator|&
name|position_list
index|[
literal|0
index|]
argument_list|,
name|tree
argument_list|,
name|diff_baton
argument_list|,
name|vtable
argument_list|,
name|svn_diff_datasource_original
argument_list|,
name|prefix_lines
argument_list|,
name|subpool2
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff__get_tokens
argument_list|(
operator|&
name|position_list
index|[
literal|1
index|]
argument_list|,
name|tree
argument_list|,
name|diff_baton
argument_list|,
name|vtable
argument_list|,
name|svn_diff_datasource_modified
argument_list|,
name|prefix_lines
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff__get_tokens
argument_list|(
operator|&
name|position_list
index|[
literal|2
index|]
argument_list|,
name|tree
argument_list|,
name|diff_baton
argument_list|,
name|vtable
argument_list|,
name|svn_diff_datasource_latest
argument_list|,
name|prefix_lines
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff__get_tokens
argument_list|(
operator|&
name|position_list
index|[
literal|3
index|]
argument_list|,
name|tree
argument_list|,
name|diff_baton
argument_list|,
name|vtable
argument_list|,
name|svn_diff_datasource_ancestor
argument_list|,
name|prefix_lines
argument_list|,
name|subpool2
argument_list|)
argument_list|)
expr_stmt|;
name|num_tokens
operator|=
name|svn_diff__get_node_count
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|/* Get rid of the tokens, we don't need them to calc the diff */
if|if
condition|(
name|vtable
operator|->
name|token_discard_all
operator|!=
name|NULL
condition|)
name|vtable
operator|->
name|token_discard_all
argument_list|(
name|diff_baton
argument_list|)
expr_stmt|;
comment|/* We don't need the nodes in the tree either anymore, nor the tree itself */
name|svn_pool_clear
argument_list|(
name|subpool3
argument_list|)
expr_stmt|;
name|token_counts
index|[
literal|0
index|]
operator|=
name|svn_diff__get_token_counts
argument_list|(
name|position_list
index|[
literal|0
index|]
argument_list|,
name|num_tokens
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|token_counts
index|[
literal|1
index|]
operator|=
name|svn_diff__get_token_counts
argument_list|(
name|position_list
index|[
literal|1
index|]
argument_list|,
name|num_tokens
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|token_counts
index|[
literal|2
index|]
operator|=
name|svn_diff__get_token_counts
argument_list|(
name|position_list
index|[
literal|2
index|]
argument_list|,
name|num_tokens
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|token_counts
index|[
literal|3
index|]
operator|=
name|svn_diff__get_token_counts
argument_list|(
name|position_list
index|[
literal|3
index|]
argument_list|,
name|num_tokens
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* Get the lcs for original - latest */
name|lcs_ol
operator|=
name|svn_diff__lcs
argument_list|(
name|position_list
index|[
literal|0
index|]
argument_list|,
name|position_list
index|[
literal|2
index|]
argument_list|,
name|token_counts
index|[
literal|0
index|]
argument_list|,
name|token_counts
index|[
literal|2
index|]
argument_list|,
name|num_tokens
argument_list|,
name|prefix_lines
argument_list|,
name|suffix_lines
argument_list|,
name|subpool3
argument_list|)
expr_stmt|;
name|diff_ol
operator|=
name|svn_diff__diff
argument_list|(
name|lcs_ol
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool3
argument_list|)
expr_stmt|;
for|for
control|(
name|hunk
operator|=
name|diff_ol
init|;
name|hunk
condition|;
name|hunk
operator|=
name|hunk
operator|->
name|next
control|)
block|{
name|hunk
operator|->
name|latest_start
operator|=
name|hunk
operator|->
name|modified_start
expr_stmt|;
name|hunk
operator|->
name|latest_length
operator|=
name|hunk
operator|->
name|modified_length
expr_stmt|;
name|hunk
operator|->
name|modified_start
operator|=
name|hunk
operator|->
name|original_start
expr_stmt|;
name|hunk
operator|->
name|modified_length
operator|=
name|hunk
operator|->
name|original_length
expr_stmt|;
if|if
condition|(
name|hunk
operator|->
name|type
operator|==
name|svn_diff__type_diff_modified
condition|)
name|hunk
operator|->
name|type
operator|=
name|svn_diff__type_diff_latest
expr_stmt|;
else|else
name|hunk
operator|->
name|type
operator|=
name|svn_diff__type_diff_modified
expr_stmt|;
block|}
comment|/* Get the lcs for common ancestor - original    * Do reverse adjustements    */
name|lcs_adjust
operator|=
name|svn_diff__lcs
argument_list|(
name|position_list
index|[
literal|3
index|]
argument_list|,
name|position_list
index|[
literal|2
index|]
argument_list|,
name|token_counts
index|[
literal|3
index|]
argument_list|,
name|token_counts
index|[
literal|2
index|]
argument_list|,
name|num_tokens
argument_list|,
name|prefix_lines
argument_list|,
name|suffix_lines
argument_list|,
name|subpool3
argument_list|)
expr_stmt|;
name|diff_adjust
operator|=
name|svn_diff__diff
argument_list|(
name|lcs_adjust
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
name|subpool3
argument_list|)
expr_stmt|;
name|adjust_diff
argument_list|(
name|diff_ol
argument_list|,
name|diff_adjust
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool3
argument_list|)
expr_stmt|;
comment|/* Get the lcs for modified - common ancestor    * Do forward adjustments    */
name|lcs_adjust
operator|=
name|svn_diff__lcs
argument_list|(
name|position_list
index|[
literal|1
index|]
argument_list|,
name|position_list
index|[
literal|3
index|]
argument_list|,
name|token_counts
index|[
literal|1
index|]
argument_list|,
name|token_counts
index|[
literal|3
index|]
argument_list|,
name|num_tokens
argument_list|,
name|prefix_lines
argument_list|,
name|suffix_lines
argument_list|,
name|subpool3
argument_list|)
expr_stmt|;
name|diff_adjust
operator|=
name|svn_diff__diff
argument_list|(
name|lcs_adjust
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
name|subpool3
argument_list|)
expr_stmt|;
name|adjust_diff
argument_list|(
name|diff_ol
argument_list|,
name|diff_adjust
argument_list|)
expr_stmt|;
comment|/* Get rid of the position lists for original and ancestor, and delete    * our scratchpool.    */
name|svn_pool_destroy
argument_list|(
name|subpool2
argument_list|)
expr_stmt|;
comment|/* Now we try and resolve the conflicts we encountered */
for|for
control|(
name|hunk
operator|=
name|diff_ol
init|;
name|hunk
condition|;
name|hunk
operator|=
name|hunk
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hunk
operator|->
name|type
operator|==
name|svn_diff__type_conflict
condition|)
block|{
name|svn_diff__resolve_conflict
argument_list|(
name|hunk
argument_list|,
operator|&
name|position_list
index|[
literal|1
index|]
argument_list|,
operator|&
name|position_list
index|[
literal|2
index|]
argument_list|,
name|num_tokens
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
operator|*
name|diff
operator|=
name|diff_ol
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

