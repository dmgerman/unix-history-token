begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * parse-diff.c: functions for parsing diff files  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_eol_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_comment
comment|/* Helper macro for readability */
end_comment

begin_define
define|#
directive|define
name|starts_with
parameter_list|(
name|str
parameter_list|,
name|start
parameter_list|)
define|\
value|(strncmp((str), (start), strlen(start)) == 0)
end_define

begin_comment
comment|/* Like strlen() but for string literals. */
end_comment

begin_define
define|#
directive|define
name|STRLEN_LITERAL
parameter_list|(
name|str
parameter_list|)
value|(sizeof(str) - 1)
end_define

begin_comment
comment|/* This struct describes a range within a file, as well as the  * current cursor position within the range. All numbers are in bytes. */
end_comment

begin_struct
struct|struct
name|svn_diff__hunk_range
block|{
name|apr_off_t
name|start
decl_stmt|;
name|apr_off_t
name|end
decl_stmt|;
name|apr_off_t
name|current
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svn_diff_hunk_t
block|{
comment|/* The patch this hunk belongs to. */
name|svn_patch_t
modifier|*
name|patch
decl_stmt|;
comment|/* APR file handle to the patch file this hunk came from. */
name|apr_file_t
modifier|*
name|apr_file
decl_stmt|;
comment|/* Ranges used to keep track of this hunk's texts positions within    * the patch file. */
name|struct
name|svn_diff__hunk_range
name|diff_text_range
decl_stmt|;
name|struct
name|svn_diff__hunk_range
name|original_text_range
decl_stmt|;
name|struct
name|svn_diff__hunk_range
name|modified_text_range
decl_stmt|;
comment|/* Hunk ranges as they appeared in the patch file.    * All numbers are lines, not bytes. */
name|svn_linenum_t
name|original_start
decl_stmt|;
name|svn_linenum_t
name|original_length
decl_stmt|;
name|svn_linenum_t
name|modified_start
decl_stmt|;
name|svn_linenum_t
name|modified_length
decl_stmt|;
comment|/* Number of lines of leading and trailing hunk context. */
name|svn_linenum_t
name|leading_context
decl_stmt|;
name|svn_linenum_t
name|trailing_context
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|svn_diff_hunk_reset_diff_text
parameter_list|(
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
name|hunk
operator|->
name|diff_text_range
operator|.
name|current
operator|=
name|hunk
operator|->
name|diff_text_range
operator|.
name|start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_diff_hunk_reset_original_text
parameter_list|(
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
if|if
condition|(
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|)
name|hunk
operator|->
name|modified_text_range
operator|.
name|current
operator|=
name|hunk
operator|->
name|modified_text_range
operator|.
name|start
expr_stmt|;
else|else
name|hunk
operator|->
name|original_text_range
operator|.
name|current
operator|=
name|hunk
operator|->
name|original_text_range
operator|.
name|start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_diff_hunk_reset_modified_text
parameter_list|(
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
if|if
condition|(
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|)
name|hunk
operator|->
name|original_text_range
operator|.
name|current
operator|=
name|hunk
operator|->
name|original_text_range
operator|.
name|start
expr_stmt|;
else|else
name|hunk
operator|->
name|modified_text_range
operator|.
name|current
operator|=
name|hunk
operator|->
name|modified_text_range
operator|.
name|start
expr_stmt|;
block|}
end_function

begin_function
name|svn_linenum_t
name|svn_diff_hunk_get_original_start
parameter_list|(
specifier|const
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
return|return
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
name|hunk
operator|->
name|modified_start
else|:
name|hunk
operator|->
name|original_start
return|;
block|}
end_function

begin_function
name|svn_linenum_t
name|svn_diff_hunk_get_original_length
parameter_list|(
specifier|const
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
return|return
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
name|hunk
operator|->
name|modified_length
else|:
name|hunk
operator|->
name|original_length
return|;
block|}
end_function

begin_function
name|svn_linenum_t
name|svn_diff_hunk_get_modified_start
parameter_list|(
specifier|const
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
return|return
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
name|hunk
operator|->
name|original_start
else|:
name|hunk
operator|->
name|modified_start
return|;
block|}
end_function

begin_function
name|svn_linenum_t
name|svn_diff_hunk_get_modified_length
parameter_list|(
specifier|const
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
return|return
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
name|hunk
operator|->
name|original_length
else|:
name|hunk
operator|->
name|modified_length
return|;
block|}
end_function

begin_function
name|svn_linenum_t
name|svn_diff_hunk_get_leading_context
parameter_list|(
specifier|const
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
return|return
name|hunk
operator|->
name|leading_context
return|;
block|}
end_function

begin_function
name|svn_linenum_t
name|svn_diff_hunk_get_trailing_context
parameter_list|(
specifier|const
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|)
block|{
return|return
name|hunk
operator|->
name|trailing_context
return|;
block|}
end_function

begin_comment
comment|/* Try to parse a positive number from a decimal number encoded  * in the string NUMBER. Return parsed number in OFFSET, and return  * TRUE if parsing was successful. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|parse_offset
parameter_list|(
name|svn_linenum_t
modifier|*
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|number
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_uint64_t
name|val
decl_stmt|;
name|err
operator|=
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|val
argument_list|,
name|number
argument_list|,
literal|0
argument_list|,
name|SVN_LINENUM_MAX_VALUE
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|offset
operator|=
operator|(
name|svn_linenum_t
operator|)
name|val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Try to parse a hunk range specification from the string RANGE.  * Return parsed information in *START and *LENGTH, and return TRUE  * if the range parsed correctly. Note: This function may modify the  * input value RANGE. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|parse_range
parameter_list|(
name|svn_linenum_t
modifier|*
name|start
parameter_list|,
name|svn_linenum_t
modifier|*
name|length
parameter_list|,
name|char
modifier|*
name|range
parameter_list|)
block|{
name|char
modifier|*
name|comma
decl_stmt|;
if|if
condition|(
operator|*
name|range
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|comma
operator|=
name|strstr
argument_list|(
name|range
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|comma
operator|+
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Try to parse the length. */
if|if
condition|(
operator|!
name|parse_offset
argument_list|(
name|length
argument_list|,
name|comma
operator|+
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Snip off the end of the string,            * so we can comfortably parse the line            * number the hunk starts at. */
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* A comma but no length? */
return|return
name|FALSE
return|;
block|}
else|else
block|{
operator|*
name|length
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Try to parse the line number the hunk starts at. */
return|return
name|parse_offset
argument_list|(
name|start
argument_list|,
name|range
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to parse a hunk header in string HEADER, putting parsed information  * into HUNK. Return TRUE if the header parsed correctly. ATAT is the  * character string used to delimit the hunk header.  * Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|parse_hunk_header
parameter_list|(
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
specifier|const
name|char
modifier|*
name|atat
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|range
decl_stmt|;
name|p
operator|=
name|header
operator|+
name|strlen
argument_list|(
name|atat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
comment|/* No. */
return|return
name|FALSE
return|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
comment|/* Nah... */
return|return
name|FALSE
return|;
comment|/* OK, this may be worth allocating some memory for... */
name|range
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|31
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|start
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
comment|/* No no no... */
return|return
name|FALSE
return|;
name|svn_stringbuf_appendbytes
argument_list|(
name|range
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* Try to parse the first range. */
if|if
condition|(
operator|!
name|parse_range
argument_list|(
operator|&
name|hunk
operator|->
name|original_start
argument_list|,
operator|&
name|hunk
operator|->
name|original_length
argument_list|,
name|range
operator|->
name|data
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Clear the stringbuf so we can reuse it for the second range. */
name|svn_stringbuf_setempty
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'+'
condition|)
comment|/* Eeek! */
return|return
name|FALSE
return|;
comment|/* OK, this may be worth copying... */
name|start
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
comment|/* No no no... */
return|return
name|FALSE
return|;
name|svn_stringbuf_appendbytes
argument_list|(
name|range
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* Check for trailing @@ */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|starts_with
argument_list|(
name|p
argument_list|,
name|atat
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* There may be stuff like C-function names after the trailing @@,    * but we ignore that. */
comment|/* Try to parse the second range. */
if|if
condition|(
operator|!
name|parse_range
argument_list|(
operator|&
name|hunk
operator|->
name|modified_start
argument_list|,
operator|&
name|hunk
operator|->
name|modified_length
argument_list|,
name|range
operator|->
name|data
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Hunk header is good. */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read a line of original or modified hunk text from the specified  * RANGE within FILE. FILE is expected to contain unidiff text.  * Leading unidiff symbols ('+', '-', and ' ') are removed from the line,  * Any lines commencing with the VERBOTEN character are discarded.  * VERBOTEN should be '+' or '-', depending on which form of hunk text  * is being read.  *  * All other parameters are as in svn_diff_hunk_readline_original_text()  * and svn_diff_hunk_readline_modified_text().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hunk_readline_original_or_modified
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|struct
name|svn_diff__hunk_range
modifier|*
name|range
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|char
name|verboten
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|max_len
decl_stmt|;
name|svn_boolean_t
name|filtered
decl_stmt|;
name|apr_off_t
name|pos
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|current
operator|>=
name|range
operator|->
name|end
condition|)
block|{
comment|/* We're past the range. Indicate that no bytes can be read. */
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eol
condition|)
operator|*
name|eol
operator|=
name|NULL
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|range
operator|->
name|current
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|max_len
operator|=
name|range
operator|->
name|end
operator|-
name|range
operator|->
name|current
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|file
argument_list|,
operator|&
name|str
argument_list|,
name|eol
argument_list|,
name|eof
argument_list|,
name|max_len
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|range
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|range
operator|->
name|current
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|filtered
operator|=
operator|(
name|str
operator|->
name|data
index|[
literal|0
index|]
operator|==
name|verboten
operator|||
name|str
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|filtered
operator|&&
operator|!
operator|*
name|eof
condition|)
do|;
if|if
condition|(
name|filtered
condition|)
block|{
comment|/* EOF, return an empty string. */
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|0
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|str
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|str
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* Shave off leading unidiff symbols. */
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_create
argument_list|(
name|str
operator|->
name|data
operator|+
literal|1
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return the line as-is. */
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_dup
argument_list|(
name|str
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_hunk_readline_original_text
parameter_list|(
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|hunk_readline_original_or_modified
argument_list|(
name|hunk
operator|->
name|apr_file
argument_list|,
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
operator|&
name|hunk
operator|->
name|modified_text_range
else|:
operator|&
name|hunk
operator|->
name|original_text_range
argument_list|,
name|stringbuf
argument_list|,
name|eol
argument_list|,
name|eof
argument_list|,
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_hunk_readline_modified_text
parameter_list|(
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|hunk_readline_original_or_modified
argument_list|(
name|hunk
operator|->
name|apr_file
argument_list|,
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
operator|&
name|hunk
operator|->
name|original_text_range
else|:
operator|&
name|hunk
operator|->
name|modified_text_range
argument_list|,
name|stringbuf
argument_list|,
name|eol
argument_list|,
name|eof
argument_list|,
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_hunk_readline_diff_text
parameter_list|(
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_diff_hunk_t
name|dummy
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|apr_size_t
name|max_len
decl_stmt|;
name|apr_off_t
name|pos
decl_stmt|;
if|if
condition|(
name|hunk
operator|->
name|diff_text_range
operator|.
name|current
operator|>=
name|hunk
operator|->
name|diff_text_range
operator|.
name|end
condition|)
block|{
comment|/* We're past the range. Indicate that no bytes can be read. */
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eol
condition|)
operator|*
name|eol
operator|=
name|NULL
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|hunk
operator|->
name|apr_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|hunk
operator|->
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|hunk
operator|->
name|diff_text_range
operator|.
name|current
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|max_len
operator|=
name|hunk
operator|->
name|diff_text_range
operator|.
name|end
operator|-
name|hunk
operator|->
name|diff_text_range
operator|.
name|current
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|hunk
operator|->
name|apr_file
argument_list|,
operator|&
name|line
argument_list|,
name|eol
argument_list|,
name|eof
argument_list|,
name|max_len
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|hunk
operator|->
name|diff_text_range
operator|.
name|current
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|hunk
operator|->
name|apr_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|hunk
operator|->
name|diff_text_range
operator|.
name|current
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|hunk
operator|->
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunk
operator|->
name|patch
operator|->
name|reverse
condition|)
block|{
if|if
condition|(
name|parse_hunk_header
argument_list|(
name|line
operator|->
name|data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|"@@"
argument_list|,
name|scratch_pool
argument_list|)
condition|)
block|{
comment|/* Line is a hunk header, reverse it. */
name|line
operator|=
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"@@ -%lu,%lu +%lu,%lu @@"
argument_list|,
name|hunk
operator|->
name|modified_start
argument_list|,
name|hunk
operator|->
name|modified_length
argument_list|,
name|hunk
operator|->
name|original_start
argument_list|,
name|hunk
operator|->
name|original_length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_hunk_header
argument_list|(
name|line
operator|->
name|data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|"##"
argument_list|,
name|scratch_pool
argument_list|)
condition|)
block|{
comment|/* Line is a hunk header, reverse it. */
name|line
operator|=
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"## -%lu,%lu +%lu,%lu ##"
argument_list|,
name|hunk
operator|->
name|modified_start
argument_list|,
name|hunk
operator|->
name|modified_length
argument_list|,
name|hunk
operator|->
name|original_start
argument_list|,
name|hunk
operator|->
name|original_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|line
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|line
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|line
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|line
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
block|}
operator|*
name|stringbuf
operator|=
name|line
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse *PROP_NAME from HEADER as the part after the INDICATOR line.  * Allocate *PROP_NAME in RESULT_POOL.  * Set *PROP_NAME to NULL if no valid property name was found. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_prop_name
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|prop_name
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|indicator
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
name|prop_name
argument_list|,
name|header
operator|+
name|strlen
argument_list|(
name|indicator
argument_list|)
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|prop_name
operator|==
literal|'\0'
condition|)
operator|*
name|prop_name
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|svn_prop_name_is_valid
argument_list|(
operator|*
name|prop_name
argument_list|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|svn_stringbuf_create
argument_list|(
operator|*
name|prop_name
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|prop_name
operator|=
operator|(
name|svn_prop_name_is_valid
argument_list|(
name|buf
operator|->
name|data
argument_list|)
condition|?
name|buf
operator|->
name|data
else|:
name|NULL
operator|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the next *HUNK from a PATCH in APR_FILE.  * If no hunk can be found, set *HUNK to NULL.  * Set IS_PROPERTY to TRUE if we have a property hunk. If the returned HUNK  * is the first belonging to a certain property, then PROP_NAME and  * PROP_OPERATION will be set too. If we have a text hunk, PROP_NAME will be  * NULL.  If IGNORE_WHITESPACE is TRUE, lines without leading spaces will be  * treated as context lines.  Allocate results in RESULT_POOL.  * Use SCRATCH_POOL for all other allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_next_hunk
parameter_list|(
name|svn_diff_hunk_t
modifier|*
modifier|*
name|hunk
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_property
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|prop_name
parameter_list|,
name|svn_diff_operation_kind_t
modifier|*
name|prop_operation
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_file_t
modifier|*
name|apr_file
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|minus
init|=
literal|"--- "
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|text_atat
init|=
literal|"@@"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|prop_atat
init|=
literal|"##"
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|,
name|in_hunk
decl_stmt|,
name|hunk_seen
decl_stmt|;
name|apr_off_t
name|pos
decl_stmt|,
name|last_line
decl_stmt|;
name|apr_off_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|apr_off_t
name|original_end
decl_stmt|;
name|apr_off_t
name|modified_end
decl_stmt|;
name|svn_linenum_t
name|original_lines
decl_stmt|;
name|svn_linenum_t
name|modified_lines
decl_stmt|;
name|svn_linenum_t
name|leading_context
decl_stmt|;
name|svn_linenum_t
name|trailing_context
decl_stmt|;
name|svn_boolean_t
name|changed_line_seen
decl_stmt|;
enum|enum
block|{
name|noise_line
block|,
name|original_line
block|,
name|modified_line
block|,
name|context_line
block|}
name|last_line_type
enum|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
operator|*
name|prop_operation
operator|=
name|svn_diff_op_unchanged
expr_stmt|;
comment|/* We only set this if we have a property hunk header. */
operator|*
name|prop_name
operator|=
name|NULL
expr_stmt|;
operator|*
name|is_property
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|apr_file_eof
argument_list|(
name|apr_file
argument_list|)
operator|==
name|APR_EOF
condition|)
block|{
comment|/* No more hunks here. */
operator|*
name|hunk
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|in_hunk
operator|=
name|FALSE
expr_stmt|;
name|hunk_seen
operator|=
name|FALSE
expr_stmt|;
name|leading_context
operator|=
literal|0
expr_stmt|;
name|trailing_context
operator|=
literal|0
expr_stmt|;
name|changed_line_seen
operator|=
name|FALSE
expr_stmt|;
name|original_end
operator|=
literal|0
expr_stmt|;
name|modified_end
operator|=
literal|0
expr_stmt|;
operator|*
name|hunk
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|hunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get current seek position -- APR has no ftell() :( */
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|apr_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start out assuming noise. */
name|last_line_type
operator|=
name|noise_line
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Remember the current line's offset, and read the line. */
name|last_line
operator|=
name|pos
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|apr_file
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|,
operator|&
name|eof
argument_list|,
name|APR_SIZE_MAX
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update line offset for next iteration. */
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|apr_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Lines starting with a backslash indicate a missing EOL:        * "\ No newline at end of file" or "end of property". */
if|if
condition|(
name|line
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|in_hunk
condition|)
block|{
name|char
name|eolbuf
index|[
literal|2
index|]
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_off_t
name|off
decl_stmt|;
name|apr_off_t
name|hunk_text_end
decl_stmt|;
comment|/* Comment terminates the hunk text and says the hunk text                * has no trailing EOL. Snip off trailing EOL which is part                * of the patch file but not part of the hunk text. */
name|off
operator|=
name|last_line
operator|-
literal|2
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|off
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|eolbuf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|apr_file
argument_list|,
name|eolbuf
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eolbuf
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|eolbuf
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|hunk_text_end
operator|=
name|last_line
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|eolbuf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|eolbuf
index|[
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|hunk_text_end
operator|=
name|last_line
operator|-
literal|1
expr_stmt|;
else|else
name|hunk_text_end
operator|=
name|last_line
expr_stmt|;
if|if
condition|(
name|last_line_type
operator|==
name|original_line
operator|&&
name|original_end
operator|==
literal|0
condition|)
name|original_end
operator|=
name|hunk_text_end
expr_stmt|;
elseif|else
if|if
condition|(
name|last_line_type
operator|==
name|modified_line
operator|&&
name|modified_end
operator|==
literal|0
condition|)
name|modified_end
operator|=
name|hunk_text_end
expr_stmt|;
elseif|else
if|if
condition|(
name|last_line_type
operator|==
name|context_line
condition|)
block|{
if|if
condition|(
name|original_end
operator|==
literal|0
condition|)
name|original_end
operator|=
name|hunk_text_end
expr_stmt|;
if|if
condition|(
name|modified_end
operator|==
literal|0
condition|)
name|modified_end
operator|=
name|hunk_text_end
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|in_hunk
condition|)
block|{
name|char
name|c
decl_stmt|;
specifier|static
specifier|const
name|char
name|add
init|=
literal|'+'
decl_stmt|;
specifier|static
specifier|const
name|char
name|del
init|=
literal|'-'
decl_stmt|;
if|if
condition|(
operator|!
name|hunk_seen
condition|)
block|{
comment|/* We're reading the first line of the hunk, so the start                * of the line just read is the hunk text's byte offset. */
name|start
operator|=
name|last_line
expr_stmt|;
block|}
name|c
operator|=
name|line
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|original_lines
operator|>
literal|0
operator|&&
name|modified_lines
operator|>
literal|0
operator|&&
operator|(
operator|(
name|c
operator|==
literal|' '
operator|)
comment|/* Tolerate chopped leading spaces on empty lines. */
operator|||
operator|(
operator|!
name|eof
operator|&&
name|line
operator|->
name|len
operator|==
literal|0
operator|)
comment|/* Maybe tolerate chopped leading spaces on non-empty lines. */
operator|||
operator|(
name|ignore_whitespace
operator|&&
name|c
operator|!=
name|del
operator|&&
name|c
operator|!=
name|add
operator|)
operator|)
condition|)
block|{
comment|/* It's a "context" line in the hunk. */
name|hunk_seen
operator|=
name|TRUE
expr_stmt|;
name|original_lines
operator|--
expr_stmt|;
name|modified_lines
operator|--
expr_stmt|;
if|if
condition|(
name|changed_line_seen
condition|)
name|trailing_context
operator|++
expr_stmt|;
else|else
name|leading_context
operator|++
expr_stmt|;
name|last_line_type
operator|=
name|context_line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|original_lines
operator|>
literal|0
operator|&&
name|c
operator|==
name|del
condition|)
block|{
comment|/* It's a "deleted" line in the hunk. */
name|hunk_seen
operator|=
name|TRUE
expr_stmt|;
name|changed_line_seen
operator|=
name|TRUE
expr_stmt|;
comment|/* A hunk may have context in the middle. We only want                  trailing lines of context. */
if|if
condition|(
name|trailing_context
operator|>
literal|0
condition|)
name|trailing_context
operator|=
literal|0
expr_stmt|;
name|original_lines
operator|--
expr_stmt|;
name|last_line_type
operator|=
name|original_line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modified_lines
operator|>
literal|0
operator|&&
name|c
operator|==
name|add
condition|)
block|{
comment|/* It's an "added" line in the hunk. */
name|hunk_seen
operator|=
name|TRUE
expr_stmt|;
name|changed_line_seen
operator|=
name|TRUE
expr_stmt|;
comment|/* A hunk may have context in the middle. We only want                  trailing lines of context. */
if|if
condition|(
name|trailing_context
operator|>
literal|0
condition|)
name|trailing_context
operator|=
literal|0
expr_stmt|;
name|modified_lines
operator|--
expr_stmt|;
name|last_line_type
operator|=
name|modified_line
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|eof
condition|)
block|{
comment|/* The hunk ends at EOF. */
name|end
operator|=
name|pos
expr_stmt|;
block|}
else|else
block|{
comment|/* The start of the current line marks the first byte                    * after the hunk text. */
name|end
operator|=
name|last_line
expr_stmt|;
block|}
if|if
condition|(
name|original_end
operator|==
literal|0
condition|)
name|original_end
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|modified_end
operator|==
literal|0
condition|)
name|modified_end
operator|=
name|end
expr_stmt|;
break|break;
comment|/* Hunk was empty or has been read. */
block|}
block|}
else|else
block|{
if|if
condition|(
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
name|text_atat
argument_list|)
condition|)
block|{
comment|/* Looks like we have a hunk header, try to rip it apart. */
name|in_hunk
operator|=
name|parse_hunk_header
argument_list|(
name|line
operator|->
name|data
argument_list|,
operator|*
name|hunk
argument_list|,
name|text_atat
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_hunk
condition|)
block|{
name|original_lines
operator|=
operator|(
operator|*
name|hunk
operator|)
operator|->
name|original_length
expr_stmt|;
name|modified_lines
operator|=
operator|(
operator|*
name|hunk
operator|)
operator|->
name|modified_length
expr_stmt|;
operator|*
name|is_property
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
name|prop_atat
argument_list|)
condition|)
block|{
comment|/* Looks like we have a property hunk header, try to rip it                * apart. */
name|in_hunk
operator|=
name|parse_hunk_header
argument_list|(
name|line
operator|->
name|data
argument_list|,
operator|*
name|hunk
argument_list|,
name|prop_atat
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_hunk
condition|)
block|{
name|original_lines
operator|=
operator|(
operator|*
name|hunk
operator|)
operator|->
name|original_length
expr_stmt|;
name|modified_lines
operator|=
operator|(
operator|*
name|hunk
operator|)
operator|->
name|modified_length
expr_stmt|;
operator|*
name|is_property
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
literal|"Added: "
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_prop_name
argument_list|(
name|prop_name
argument_list|,
name|line
operator|->
name|data
argument_list|,
literal|"Added: "
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prop_name
condition|)
operator|*
name|prop_operation
operator|=
name|svn_diff_op_added
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
literal|"Deleted: "
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_prop_name
argument_list|(
name|prop_name
argument_list|,
name|line
operator|->
name|data
argument_list|,
literal|"Deleted: "
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prop_name
condition|)
operator|*
name|prop_operation
operator|=
name|svn_diff_op_deleted
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
literal|"Modified: "
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_prop_name
argument_list|(
name|prop_name
argument_list|,
name|line
operator|->
name|data
argument_list|,
literal|"Modified: "
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prop_name
condition|)
operator|*
name|prop_operation
operator|=
name|svn_diff_op_modified
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
name|minus
argument_list|)
operator|||
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
literal|"diff --git "
argument_list|)
condition|)
comment|/* This could be a header of another patch. Bail out. */
break|break;
block|}
block|}
comment|/* Check for the line length since a file may not have a newline at the    * end and we depend upon the last line to be an empty one. */
do|while
condition|(
operator|!
name|eof
operator|||
name|line
operator|->
name|len
operator|>
literal|0
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
comment|/* Rewind to the start of the line just read, so subsequent calls      * to this function or svn_diff_parse_next_patch() don't end      * up skipping the line -- it may contain a patch or hunk header. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|last_line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunk_seen
operator|&&
name|start
operator|<
name|end
condition|)
block|{
operator|(
operator|*
name|hunk
operator|)
operator|->
name|patch
operator|=
name|patch
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|apr_file
operator|=
name|apr_file
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|leading_context
operator|=
name|leading_context
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|trailing_context
operator|=
name|trailing_context
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|diff_text_range
operator|.
name|start
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|diff_text_range
operator|.
name|current
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|diff_text_range
operator|.
name|end
operator|=
name|end
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|original_text_range
operator|.
name|start
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|original_text_range
operator|.
name|current
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|original_text_range
operator|.
name|end
operator|=
name|original_end
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|modified_text_range
operator|.
name|start
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|modified_text_range
operator|.
name|current
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|hunk
operator|)
operator|->
name|modified_text_range
operator|.
name|end
operator|=
name|modified_end
expr_stmt|;
block|}
else|else
comment|/* Something went wrong, just discard the result. */
operator|*
name|hunk
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compare function for sorting hunks after parsing.  * We sort hunks by their original line offset. */
end_comment

begin_function
specifier|static
name|int
name|compare_hunks
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_diff_hunk_t
modifier|*
name|ha
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_diff_hunk_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|svn_diff_hunk_t
modifier|*
name|hb
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_diff_hunk_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
if|if
condition|(
name|ha
operator|->
name|original_start
operator|<
name|hb
operator|->
name|original_start
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ha
operator|->
name|original_start
operator|>
name|hb
operator|->
name|original_start
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Possible states of the diff header parser. */
end_comment

begin_enum
enum|enum
name|parse_state
block|{
name|state_start
block|,
comment|/* initial */
name|state_git_diff_seen
block|,
comment|/* diff --git */
name|state_git_tree_seen
block|,
comment|/* a tree operation, rather then content change */
name|state_git_minus_seen
block|,
comment|/* --- /dev/null; or --- a/ */
name|state_git_plus_seen
block|,
comment|/* +++ /dev/null; or +++ a/ */
name|state_move_from_seen
block|,
comment|/* rename from foo.c */
name|state_copy_from_seen
block|,
comment|/* copy from foo.c */
name|state_minus_seen
block|,
comment|/* --- foo.c */
name|state_unidiff_found
block|,
comment|/* valid start of a regular unidiff header */
name|state_git_header_found
comment|/* valid start of a --git diff header */
block|}
enum|;
end_enum

begin_comment
comment|/* Data type describing a valid state transition of the parser. */
end_comment

begin_struct
struct|struct
name|transition
block|{
specifier|const
name|char
modifier|*
name|expected_input
decl_stmt|;
name|enum
name|parse_state
name|required_state
decl_stmt|;
comment|/* A callback called upon each parser state transition. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|input
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* UTF-8 encode and canonicalize the content of LINE as FILE_NAME. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|grab_filename
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|file_name
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|utf8_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|canon_path
decl_stmt|;
comment|/* Grab the filename and encode it in UTF-8. */
comment|/* TODO: Allow specifying the patch file's encoding.    *       For now, we assume its encoding is native. */
comment|/* ### This can fail if the filename cannot be represented in the current    * ### locale's encoding. */
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_path
argument_list|,
name|line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Canonicalize the path name. */
name|canon_path
operator|=
name|svn_dirent_canonicalize
argument_list|(
name|utf8_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|file_name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|canon_path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the '--- ' line of a regular unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|diff_minus
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we can find a tab, it separates the filename from    * the rest of the line which we can discard. */
name|char
modifier|*
name|tab
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
condition|)
operator|*
name|tab
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|old_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"--- "
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_minus_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the '+++ ' line of a regular unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|diff_plus
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we can find a tab, it separates the filename from    * the rest of the line which we can discard. */
name|char
modifier|*
name|tab
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
condition|)
operator|*
name|tab
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|new_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"+++ "
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_unidiff_found
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the first line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_start
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|old_path_start
decl_stmt|;
name|char
modifier|*
name|old_path_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_path_start
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_path_end
decl_stmt|;
name|char
modifier|*
name|new_path_marker
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_path_marker
decl_stmt|;
comment|/* ### Add handling of escaped paths    * http://www.kernel.org/pub/software/scm/git/docs/git-diff.html:    *    * TAB, LF, double quote and backslash characters in pathnames are    * represented as \t, \n, \" and \\, respectively. If there is need for    * such substitution then the whole pathname is put in double quotes.    */
comment|/* Our line should look like this: 'diff --git a/path b/path'.    *    * If we find any deviations from that format, we return with state reset    * to start.    */
name|old_path_marker
operator|=
name|strstr
argument_list|(
name|line
argument_list|,
literal|" a/"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_path_marker
condition|)
block|{
operator|*
name|new_state
operator|=
name|state_start
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
operator|*
operator|(
name|old_path_marker
operator|+
literal|3
operator|)
condition|)
block|{
operator|*
name|new_state
operator|=
name|state_start
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|new_path_marker
operator|=
name|strstr
argument_list|(
name|old_path_marker
argument_list|,
literal|" b/"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_path_marker
condition|)
block|{
operator|*
name|new_state
operator|=
name|state_start
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
operator|*
operator|(
name|new_path_marker
operator|+
literal|3
operator|)
condition|)
block|{
operator|*
name|new_state
operator|=
name|state_start
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* By now, we know that we have a line on the form '--git diff a/.+ b/.+'    * We only need the filenames when we have deleted or added empty    * files. In those cases the old_path and new_path is identical on the    * 'diff --git' line.  For all other cases we fetch the filenames from    * other header lines. */
name|old_path_start
operator|=
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"diff --git a/"
argument_list|)
expr_stmt|;
name|new_path_end
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|new_path_start
operator|=
name|old_path_start
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|ptrdiff_t
name|len_old
decl_stmt|;
name|ptrdiff_t
name|len_new
decl_stmt|;
name|new_path_marker
operator|=
name|strstr
argument_list|(
name|new_path_start
argument_list|,
literal|" b/"
argument_list|)
expr_stmt|;
comment|/* No new path marker, bail out. */
if|if
condition|(
operator|!
name|new_path_marker
condition|)
break|break;
name|old_path_end
operator|=
name|new_path_marker
expr_stmt|;
name|new_path_start
operator|=
name|new_path_marker
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|" b/"
argument_list|)
expr_stmt|;
comment|/* No path after the marker. */
if|if
condition|(
operator|!
operator|*
name|new_path_start
condition|)
break|break;
name|len_old
operator|=
name|old_path_end
operator|-
name|old_path_start
expr_stmt|;
name|len_new
operator|=
name|new_path_end
operator|-
name|new_path_start
expr_stmt|;
comment|/* Are the paths before and after the " b/" marker the same? */
if|if
condition|(
name|len_old
operator|==
name|len_new
operator|&&
operator|!
name|strncmp
argument_list|(
name|old_path_start
argument_list|,
name|new_path_start
argument_list|,
name|len_old
argument_list|)
condition|)
block|{
operator|*
name|old_path_end
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|old_filename
argument_list|,
name|old_path_start
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|new_filename
argument_list|,
name|new_path_start
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We assume that the path is only modified until we've found a 'tree'    * header */
name|patch
operator|->
name|operation
operator|=
name|svn_diff_op_modified
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_git_diff_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the '--- ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_minus
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we can find a tab, it separates the filename from    * the rest of the line which we can discard. */
name|char
modifier|*
name|tab
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
condition|)
operator|*
name|tab
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|line
argument_list|,
literal|"--- /dev/null"
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|old_filename
argument_list|,
literal|"/dev/null"
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|old_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"--- a/"
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_git_minus_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the '+++ ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_plus
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we can find a tab, it separates the filename from    * the rest of the line which we can discard. */
name|char
modifier|*
name|tab
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
condition|)
operator|*
name|tab
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|line
argument_list|,
literal|"+++ /dev/null"
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|new_filename
argument_list|,
literal|"/dev/null"
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|new_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"+++ b/"
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_git_header_found
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the 'rename from ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_move_from
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|old_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"rename from "
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_move_from_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the 'rename to ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_move_to
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|new_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"rename to "
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|patch
operator|->
name|operation
operator|=
name|svn_diff_op_moved
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_git_tree_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the 'copy from ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_copy_from
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|old_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"copy from "
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_copy_from_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the 'copy to ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_copy_to
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|grab_filename
argument_list|(
operator|&
name|patch
operator|->
name|new_filename
argument_list|,
name|line
operator|+
name|STRLEN_LITERAL
argument_list|(
literal|"copy to "
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|patch
operator|->
name|operation
operator|=
name|svn_diff_op_copied
expr_stmt|;
operator|*
name|new_state
operator|=
name|state_git_tree_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the 'new file ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_new_file
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|patch
operator|->
name|operation
operator|=
name|svn_diff_op_added
expr_stmt|;
comment|/* Filename already retrieved from diff --git header. */
operator|*
name|new_state
operator|=
name|state_git_tree_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the 'deleted file ' line of a git extended unidiff. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|git_deleted_file
parameter_list|(
name|enum
name|parse_state
modifier|*
name|new_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|patch
operator|->
name|operation
operator|=
name|svn_diff_op_deleted
expr_stmt|;
comment|/* Filename already retrieved from diff --git header. */
operator|*
name|new_state
operator|=
name|state_git_tree_seen
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add a HUNK associated with the property PROP_NAME to PATCH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_property_hunk
parameter_list|(
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_diff_operation_kind_t
name|operation
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_prop_patch_t
modifier|*
name|prop_patch
decl_stmt|;
name|prop_patch
operator|=
name|svn_hash_gets
argument_list|(
name|patch
operator|->
name|prop_patches
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_patch
condition|)
block|{
name|prop_patch
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_patch_t
argument_list|)
argument_list|)
expr_stmt|;
name|prop_patch
operator|->
name|name
operator|=
name|prop_name
expr_stmt|;
name|prop_patch
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|prop_patch
operator|->
name|hunks
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_diff_hunk_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|patch
operator|->
name|prop_patches
argument_list|,
name|prop_name
argument_list|,
name|prop_patch
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|prop_patch
operator|->
name|hunks
argument_list|,
name|svn_diff_hunk_t
operator|*
argument_list|)
operator|=
name|hunk
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|svn_patch_file_t
block|{
comment|/* The APR file handle to the patch file. */
name|apr_file_t
modifier|*
name|apr_file
decl_stmt|;
comment|/* The file offset at which the next patch is expected. */
name|apr_off_t
name|next_patch_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|svn_error_t
modifier|*
name|svn_diff_open_patch_file
parameter_list|(
name|svn_patch_file_t
modifier|*
modifier|*
name|patch_file
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_patch_file_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|p
operator|->
name|apr_file
argument_list|,
name|local_abspath
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next_patch_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|patch_file
operator|=
name|p
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse hunks from APR_FILE and store them in PATCH->HUNKS.  * Parsing stops if no valid next hunk can be found.  * If IGNORE_WHITESPACE is TRUE, lines without  * leading spaces will be treated as context lines.  * Allocate results in RESULT_POOL.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_hunks
parameter_list|(
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
name|apr_file_t
modifier|*
name|apr_file
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_diff_hunk_t
modifier|*
name|hunk
decl_stmt|;
name|svn_boolean_t
name|is_property
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_prop_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|svn_diff_operation_kind_t
name|prop_operation
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|last_prop_name
operator|=
name|NULL
expr_stmt|;
name|patch
operator|->
name|hunks
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_diff_hunk_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|patch
operator|->
name|prop_patches
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_next_hunk
argument_list|(
operator|&
name|hunk
argument_list|,
operator|&
name|is_property
argument_list|,
operator|&
name|prop_name
argument_list|,
operator|&
name|prop_operation
argument_list|,
name|patch
argument_list|,
name|apr_file
argument_list|,
name|ignore_whitespace
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunk
operator|&&
name|is_property
condition|)
block|{
if|if
condition|(
operator|!
name|prop_name
condition|)
name|prop_name
operator|=
name|last_prop_name
expr_stmt|;
else|else
name|last_prop_name
operator|=
name|prop_name
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_property_hunk
argument_list|(
name|patch
argument_list|,
name|prop_name
argument_list|,
name|hunk
argument_list|,
name|prop_operation
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hunk
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|patch
operator|->
name|hunks
argument_list|,
name|svn_diff_hunk_t
operator|*
argument_list|)
operator|=
name|hunk
expr_stmt|;
name|last_prop_name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
do|while
condition|(
name|hunk
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* State machine for the diff header parser.  * Expected Input   Required state          Function to call */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|transition
name|transitions
index|[]
init|=
block|{
block|{
literal|"--- "
block|,
name|state_start
block|,
name|diff_minus
block|}
block|,
block|{
literal|"+++ "
block|,
name|state_minus_seen
block|,
name|diff_plus
block|}
block|,
block|{
literal|"diff --git"
block|,
name|state_start
block|,
name|git_start
block|}
block|,
block|{
literal|"--- a/"
block|,
name|state_git_diff_seen
block|,
name|git_minus
block|}
block|,
block|{
literal|"--- a/"
block|,
name|state_git_tree_seen
block|,
name|git_minus
block|}
block|,
block|{
literal|"--- /dev/null"
block|,
name|state_git_tree_seen
block|,
name|git_minus
block|}
block|,
block|{
literal|"+++ b/"
block|,
name|state_git_minus_seen
block|,
name|git_plus
block|}
block|,
block|{
literal|"+++ /dev/null"
block|,
name|state_git_minus_seen
block|,
name|git_plus
block|}
block|,
block|{
literal|"rename from "
block|,
name|state_git_diff_seen
block|,
name|git_move_from
block|}
block|,
block|{
literal|"rename to "
block|,
name|state_move_from_seen
block|,
name|git_move_to
block|}
block|,
block|{
literal|"copy from "
block|,
name|state_git_diff_seen
block|,
name|git_copy_from
block|}
block|,
block|{
literal|"copy to "
block|,
name|state_copy_from_seen
block|,
name|git_copy_to
block|}
block|,
block|{
literal|"new file "
block|,
name|state_git_diff_seen
block|,
name|git_new_file
block|}
block|,
block|{
literal|"deleted file "
block|,
name|state_git_diff_seen
block|,
name|git_deleted_file
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_diff_parse_next_patch
parameter_list|(
name|svn_patch_t
modifier|*
modifier|*
name|patch
parameter_list|,
name|svn_patch_file_t
modifier|*
name|patch_file
parameter_list|,
name|svn_boolean_t
name|reverse
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|pos
decl_stmt|,
name|last_line
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_boolean_t
name|line_after_tree_header_read
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|enum
name|parse_state
name|state
init|=
name|state_start
decl_stmt|;
if|if
condition|(
name|apr_file_eof
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|)
operator|==
name|APR_EOF
condition|)
block|{
comment|/* No more patches here. */
operator|*
name|patch
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|patch
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|patch
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|patch_file
operator|->
name|next_patch_offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|svn_boolean_t
name|valid_header_line
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Remember the current line's offset, and read the line. */
name|last_line
operator|=
name|pos
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|,
operator|&
name|eof
argument_list|,
name|APR_SIZE_MAX
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
block|{
comment|/* Update line offset for next iteration. */
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Run the state machine. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|transitions
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|transitions
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
name|transitions
index|[
name|i
index|]
operator|.
name|expected_input
argument_list|)
operator|&&
name|state
operator|==
name|transitions
index|[
name|i
index|]
operator|.
name|required_state
condition|)
block|{
name|SVN_ERR
argument_list|(
name|transitions
index|[
name|i
index|]
operator|.
name|fn
argument_list|(
operator|&
name|state
argument_list|,
name|line
operator|->
name|data
argument_list|,
operator|*
name|patch
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|valid_header_line
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|==
name|state_unidiff_found
operator|||
name|state
operator|==
name|state_git_header_found
condition|)
block|{
comment|/* We have a valid diff header, yay! */
break|break;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|state_git_tree_seen
operator|&&
name|line_after_tree_header_read
condition|)
block|{
comment|/* git patches can contain an index line after the file mode line */
if|if
condition|(
operator|!
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
literal|"index "
argument_list|)
condition|)
block|{
comment|/* We have a valid diff header for a patch with only tree changes.              * Rewind to the start of the line just read, so subsequent calls              * to this function don't end up skipping the line -- it may              * contain a patch. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|last_line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|state_git_tree_seen
condition|)
block|{
name|line_after_tree_header_read
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|valid_header_line
operator|&&
name|state
operator|!=
name|state_start
operator|&&
operator|!
name|starts_with
argument_list|(
name|line
operator|->
name|data
argument_list|,
literal|"index "
argument_list|)
condition|)
block|{
comment|/* We've encountered an invalid diff header.            *            * Rewind to the start of the line just read - it may be a new            * header that begins there. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|last_line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|state_start
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
operator|(
operator|*
name|patch
operator|)
operator|->
name|reverse
operator|=
name|reverse
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
operator|*
name|patch
operator|)
operator|->
name|old_filename
expr_stmt|;
operator|(
operator|*
name|patch
operator|)
operator|->
name|old_filename
operator|=
operator|(
operator|*
name|patch
operator|)
operator|->
name|new_filename
expr_stmt|;
operator|(
operator|*
name|patch
operator|)
operator|->
name|new_filename
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|patch
operator|)
operator|->
name|old_filename
operator|==
name|NULL
operator|||
operator|(
operator|*
name|patch
operator|)
operator|->
name|new_filename
operator|==
name|NULL
condition|)
block|{
comment|/* Something went wrong, just discard the result. */
operator|*
name|patch
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|parse_hunks
argument_list|(
operator|*
name|patch
argument_list|,
name|patch_file
operator|->
name|apr_file
argument_list|,
name|ignore_whitespace
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|patch_file
operator|->
name|next_patch_offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|patch_file
operator|->
name|next_patch_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|patch
condition|)
block|{
comment|/* Usually, hunks appear in the patch sorted by their original line        * offset. But just in case they weren't parsed in this order for        * some reason, we sort them so that our caller can assume that hunks        * are sorted as if parsed from a usual patch. */
name|qsort
argument_list|(
operator|(
operator|*
name|patch
operator|)
operator|->
name|hunks
operator|->
name|elts
argument_list|,
operator|(
operator|*
name|patch
operator|)
operator|->
name|hunks
operator|->
name|nelts
argument_list|,
operator|(
operator|*
name|patch
operator|)
operator|->
name|hunks
operator|->
name|elt_size
argument_list|,
name|compare_hunks
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_close_patch_file
parameter_list|(
name|svn_patch_file_t
modifier|*
name|patch_file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_close
argument_list|(
name|patch_file
operator|->
name|apr_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

