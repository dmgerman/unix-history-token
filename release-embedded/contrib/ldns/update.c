begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* update.c  *  * Functions for RFC 2136 Dynamic Update  *  * Copyright (c) 2005-2008, NLnet Labs. All rights reserved.  *  * See LICENSE for the license.  */
end_comment

begin_include
include|#
directive|include
file|<ldns/config.h>
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_comment
comment|/*  * RFC 2136 sections mapped to RFC 1035:  *              zone/ZO -- QD/question  *     prerequisites/PR -- AN/answers  *           updates/UP -- NS/authority records  *   additional data/AD -- AR/additional records  */
end_comment

begin_function
name|ldns_pkt
modifier|*
name|ldns_update_pkt_new
parameter_list|(
name|ldns_rdf
modifier|*
name|zone_rdf
parameter_list|,
name|ldns_rr_class
name|c
parameter_list|,
name|ldns_rr_list
modifier|*
name|pr_rrlist
parameter_list|,
name|ldns_rr_list
modifier|*
name|up_rrlist
parameter_list|,
name|ldns_rr_list
modifier|*
name|ad_rrlist
parameter_list|)
block|{
name|ldns_pkt
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|zone_rdf
operator|||
operator|!
name|up_rrlist
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|LDNS_RR_CLASS_IN
expr_stmt|;
block|}
comment|/* Create packet, fill in Zone Section. */
name|p
operator|=
name|ldns_pkt_query_new
argument_list|(
name|zone_rdf
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|c
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|zone_rdf
operator|=
name|NULL
expr_stmt|;
comment|/* No longer safe to use. */
name|ldns_pkt_set_opcode
argument_list|(
name|p
argument_list|,
name|LDNS_PACKET_UPDATE
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|p
operator|->
name|_authority
argument_list|)
expr_stmt|;
name|ldns_pkt_set_authority
argument_list|(
name|p
argument_list|,
name|ldns_rr_list_clone
argument_list|(
name|up_rrlist
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_update_set_upcount
argument_list|(
name|p
argument_list|,
name|ldns_rr_list_rr_count
argument_list|(
name|up_rrlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr_rrlist
condition|)
block|{
name|ldns_rr_list_deep_free
argument_list|(
name|p
operator|->
name|_answer
argument_list|)
expr_stmt|;
comment|/*XXX access function */
name|ldns_pkt_set_answer
argument_list|(
name|p
argument_list|,
name|ldns_rr_list_clone
argument_list|(
name|pr_rrlist
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_update_set_prcount
argument_list|(
name|p
argument_list|,
name|ldns_rr_list_rr_count
argument_list|(
name|pr_rrlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ad_rrlist
condition|)
block|{
name|ldns_rr_list_deep_free
argument_list|(
name|p
operator|->
name|_additional
argument_list|)
expr_stmt|;
name|ldns_pkt_set_additional
argument_list|(
name|p
argument_list|,
name|ldns_rr_list_clone
argument_list|(
name|ad_rrlist
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_update_set_adcount
argument_list|(
name|p
argument_list|,
name|ldns_rr_list_rr_count
argument_list|(
name|ad_rrlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_update_pkt_tsig_add
parameter_list|(
name|ldns_pkt
modifier|*
name|p
parameter_list|,
name|ldns_resolver
modifier|*
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
name|uint16_t
name|fudge
init|=
literal|300
decl_stmt|;
comment|/* Recommended fudge. [RFC2845 6.4]  */
if|if
condition|(
name|ldns_resolver_tsig_keyname
argument_list|(
name|r
argument_list|)
operator|&&
name|ldns_resolver_tsig_keydata
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|ldns_pkt_tsig_sign
argument_list|(
name|p
argument_list|,
name|ldns_resolver_tsig_keyname
argument_list|(
name|r
argument_list|)
argument_list|,
name|ldns_resolver_tsig_keydata
argument_list|(
name|r
argument_list|)
argument_list|,
name|fudge
argument_list|,
name|ldns_resolver_tsig_algorithm
argument_list|(
name|r
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
else|#
directive|else
comment|/* do nothing */
operator|(
name|void
operator|)
name|p
expr_stmt|;
operator|(
name|void
operator|)
name|r
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SSL */
comment|/* No TSIG to do. */
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Move to higher.c or similar? */
end_comment

begin_comment
comment|/* XXX doc */
end_comment

begin_function
name|ldns_status
name|ldns_update_soa_mname
parameter_list|(
name|ldns_rdf
modifier|*
name|zone
parameter_list|,
name|ldns_resolver
modifier|*
name|r
parameter_list|,
name|ldns_rr_class
name|c
parameter_list|,
name|ldns_rdf
modifier|*
modifier|*
name|mname
parameter_list|)
block|{
name|ldns_rr
modifier|*
name|soa_rr
decl_stmt|;
name|ldns_pkt
modifier|*
name|query
decl_stmt|,
modifier|*
name|resp
decl_stmt|;
comment|/* Nondestructive, so clone 'zone' here */
name|query
operator|=
name|ldns_pkt_query_new
argument_list|(
name|ldns_rdf_clone
argument_list|(
name|zone
argument_list|)
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|c
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|ldns_pkt_set_random_id
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_resolver_send_pkt
argument_list|(
operator|&
name|resp
argument_list|,
name|r
argument_list|,
name|query
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* Expect a SOA answer. */
operator|*
name|mname
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|soa_rr
operator|=
name|ldns_rr_list_pop_rr
argument_list|(
name|ldns_pkt_answer
argument_list|(
name|resp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|soa_rr
argument_list|)
operator|!=
name|LDNS_RR_TYPE_SOA
operator|||
name|ldns_rr_rdf
argument_list|(
name|soa_rr
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* [RFC1035 3.3.13] */
operator|*
name|mname
operator|=
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|soa_rr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ldns_pkt_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|*
name|mname
condition|?
name|LDNS_STATUS_OK
else|:
name|LDNS_STATUS_ERR
return|;
block|}
end_function

begin_comment
comment|/* Try to get zone and MNAME from SOA queries. */
end_comment

begin_function
name|ldns_status
name|ldns_update_soa_zone_mname
parameter_list|(
specifier|const
name|char
modifier|*
name|fqdn
parameter_list|,
name|ldns_resolver
modifier|*
name|r
parameter_list|,
name|ldns_rr_class
name|c
parameter_list|,
name|ldns_rdf
modifier|*
modifier|*
name|zone_rdf
parameter_list|,
name|ldns_rdf
modifier|*
modifier|*
name|mname_rdf
parameter_list|)
block|{
name|ldns_rr
modifier|*
name|soa_rr
decl_stmt|,
modifier|*
name|rr
decl_stmt|;
name|ldns_rdf
modifier|*
name|soa_zone
init|=
name|NULL
decl_stmt|,
modifier|*
name|soa_mname
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|ipaddr
decl_stmt|,
modifier|*
name|fqdn_rdf
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|ldns_rdf
modifier|*
modifier|*
name|nslist
decl_stmt|;
name|ldns_pkt
modifier|*
name|query
decl_stmt|,
modifier|*
name|resp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/*  	 * XXX Ok, this cannot be the best way to find this...? 	 * XXX (I run into weird cache-related stuff here) 	 */
comment|/* Step 1 - first find a nameserver that should know *something* */
name|fqdn_rdf
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|fqdn
argument_list|)
expr_stmt|;
name|query
operator|=
name|ldns_pkt_query_new
argument_list|(
name|fqdn_rdf
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|c
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|fqdn_rdf
operator|=
name|NULL
expr_stmt|;
name|ldns_pkt_set_random_id
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_resolver_send_pkt
argument_list|(
operator|&
name|resp
argument_list|,
name|r
argument_list|,
name|query
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* XXX Is it safe to only look in authority section here? */
while|while
condition|(
operator|(
name|soa_rr
operator|=
name|ldns_rr_list_pop_rr
argument_list|(
name|ldns_pkt_authority
argument_list|(
name|resp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|soa_rr
argument_list|)
operator|!=
name|LDNS_RR_TYPE_SOA
operator|||
name|ldns_rr_rdf
argument_list|(
name|soa_rr
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* [RFC1035 3.3.13] */
name|soa_mname
operator|=
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|soa_rr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ldns_pkt_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|soa_rr
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* Step 2 - find SOA MNAME IP address, add to resolver */
name|query
operator|=
name|ldns_pkt_query_new
argument_list|(
name|soa_mname
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|c
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|soa_mname
operator|=
name|NULL
expr_stmt|;
name|ldns_pkt_set_random_id
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_resolver_send_pkt
argument_list|(
operator|&
name|resp
argument_list|,
name|r
argument_list|,
name|query
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
if|if
condition|(
name|ldns_pkt_ancount
argument_list|(
name|resp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ldns_pkt_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* XXX There may be more than one answer RR here. */
name|rr
operator|=
name|ldns_rr_list_pop_rr
argument_list|(
name|ldns_pkt_answer
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|ipaddr
operator|=
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the SOA mname IP first in the nameserver list. */
name|nslist
operator|=
name|ldns_resolver_nameservers
argument_list|(
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_resolver_nameserver_count
argument_list|(
name|r
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_rdf_compare
argument_list|(
name|ipaddr
argument_list|,
name|nslist
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|tmp
operator|=
name|nslist
index|[
literal|0
index|]
expr_stmt|;
name|nslist
index|[
literal|0
index|]
operator|=
name|nslist
index|[
name|i
index|]
expr_stmt|;
name|nslist
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|ldns_resolver_nameserver_count
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* SOA mname was not part of the resolver so add it first. */
operator|(
name|void
operator|)
name|ldns_resolver_push_nameserver
argument_list|(
name|r
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
name|nslist
operator|=
name|ldns_resolver_nameservers
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|i
operator|=
name|ldns_resolver_nameserver_count
argument_list|(
name|r
argument_list|)
operator|-
literal|1
expr_stmt|;
name|tmp
operator|=
name|nslist
index|[
literal|0
index|]
expr_stmt|;
name|nslist
index|[
literal|0
index|]
operator|=
name|nslist
index|[
name|i
index|]
expr_stmt|;
name|nslist
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|ldns_pkt_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
comment|/* Make sure to ask the first in the list, i.e SOA mname */
name|ldns_resolver_set_random
argument_list|(
name|r
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Step 3 - Redo SOA query, sending to SOA MNAME directly. */
name|fqdn_rdf
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|fqdn
argument_list|)
expr_stmt|;
name|query
operator|=
name|ldns_pkt_query_new
argument_list|(
name|fqdn_rdf
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|c
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|fqdn_rdf
operator|=
name|NULL
expr_stmt|;
name|ldns_pkt_set_random_id
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_resolver_send_pkt
argument_list|(
operator|&
name|resp
argument_list|,
name|r
argument_list|,
name|query
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|ldns_pkt_free
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* XXX Is it safe to only look in authority section here, too? */
while|while
condition|(
operator|(
name|soa_rr
operator|=
name|ldns_rr_list_pop_rr
argument_list|(
name|ldns_pkt_authority
argument_list|(
name|resp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|soa_rr
argument_list|)
operator|!=
name|LDNS_RR_TYPE_SOA
operator|||
name|ldns_rr_rdf
argument_list|(
name|soa_rr
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* [RFC1035 3.3.13] */
name|soa_mname
operator|=
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|soa_rr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|soa_zone
operator|=
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_owner
argument_list|(
name|soa_rr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ldns_pkt_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|soa_rr
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* That seems to have worked, pass results to caller. */
operator|*
name|zone_rdf
operator|=
name|soa_zone
expr_stmt|;
operator|*
name|mname_rdf
operator|=
name|soa_mname
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/*  * ldns_update_{get,set}_{zo,pr,up,ad}count  */
end_comment

begin_function
name|uint16_t
name|ldns_update_zocount
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|p
parameter_list|)
block|{
return|return
name|ldns_pkt_qdcount
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|ldns_update_prcount
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|p
parameter_list|)
block|{
return|return
name|ldns_pkt_ancount
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|ldns_update_upcount
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|p
parameter_list|)
block|{
return|return
name|ldns_pkt_nscount
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|ldns_update_ad
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|p
parameter_list|)
block|{
return|return
name|ldns_pkt_arcount
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ldns_update_set_zo
parameter_list|(
name|ldns_pkt
modifier|*
name|p
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|ldns_pkt_set_qdcount
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldns_update_set_prcount
parameter_list|(
name|ldns_pkt
modifier|*
name|p
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|ldns_pkt_set_ancount
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldns_update_set_upcount
parameter_list|(
name|ldns_pkt
modifier|*
name|p
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|ldns_pkt_set_nscount
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldns_update_set_adcount
parameter_list|(
name|ldns_pkt
modifier|*
name|p
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|ldns_pkt_set_arcount
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

