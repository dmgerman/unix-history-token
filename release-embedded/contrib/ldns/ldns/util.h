begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util.h  *    * helper function header file  *   * a Net::DNS like library for C  *   * (c) NLnet Labs, 2004  *   * See the file LICENSE for the license  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_UTIL_H
end_ifndef

begin_define
define|#
directive|define
name|_UTIL_H
end_define

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ldns/common.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|dprintf
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|fprintf(stderr, (X), (Y))
comment|/* #define	dprintf(X, Y)  */
define|#
directive|define
name|LDNS_VERSION
value|"1.6.16"
define|#
directive|define
name|LDNS_REVISION
value|((1<<16)|(6<<8)|(16))
comment|/**  * splint static inline workaround  */
ifdef|#
directive|ifdef
name|S_SPLINT_S
define|#
directive|define
name|INLINE
else|#
directive|else
ifdef|#
directive|ifdef
name|SWIG
define|#
directive|define
name|INLINE
value|static
else|#
directive|else
define|#
directive|define
name|INLINE
value|static inline
endif|#
directive|endif
endif|#
directive|endif
comment|/**  * Memory management macros  */
define|#
directive|define
name|LDNS_MALLOC
parameter_list|(
name|type
parameter_list|)
value|LDNS_XMALLOC(type, 1)
define|#
directive|define
name|LDNS_XMALLOC
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
value|((type *) malloc((count) * sizeof(type)))
define|#
directive|define
name|LDNS_CALLOC
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
value|((type *) calloc((count), sizeof(type)))
define|#
directive|define
name|LDNS_REALLOC
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|)
value|LDNS_XREALLOC((ptr), type, 1)
define|#
directive|define
name|LDNS_XREALLOC
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|count
parameter_list|)
define|\
value|((type *) realloc((ptr), (count) * sizeof(type)))
define|#
directive|define
name|LDNS_FREE
parameter_list|(
name|ptr
parameter_list|)
define|\
value|do { free((ptr)); (ptr) = NULL; } while (0)
define|#
directive|define
name|LDNS_DEP
value|printf("DEPRECATED FUNCTION!\n");
comment|/*  * Copy data allowing for unaligned accesses in network byte order  * (big endian).  */
name|INLINE
name|uint16_t
name|ldns_read_uint16
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
return|return
name|ntohs
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|src
argument_list|)
return|;
else|#
directive|else
specifier|const
name|uint8_t
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|src
decl_stmt|;
return|return
operator|(
operator|(
name|uint16_t
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint16_t
operator|)
name|p
index|[
literal|1
index|]
return|;
endif|#
directive|endif
block|}
name|INLINE
name|uint32_t
name|ldns_read_uint32
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
return|return
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|src
argument_list|)
return|;
else|#
directive|else
specifier|const
name|uint8_t
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|src
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|3
index|]
operator|)
return|;
endif|#
directive|endif
block|}
comment|/*  * Copy data allowing for unaligned accesses in network byte order  * (big endian).  */
name|INLINE
name|void
name|ldns_write_uint16
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|dst
operator|=
name|htons
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|INLINE
name|void
name|ldns_write_uint32
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|dst
operator|=
name|htonl
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* warning. */
name|INLINE
name|void
name|ldns_write_uint64_as_uint48
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|uint64_t
name|data
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|40
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|32
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/**  * Structure to do a Schwartzian-like transformation, for instance when  * sorting. If you need a transformation on the objects that are sorted,  * you can sue this to store the transformed values, so you do not  * need to do the transformation again for each comparison  */
struct|struct
name|ldns_schwartzian_compare_struct
block|{
name|void
modifier|*
name|original_object
decl_stmt|;
name|void
modifier|*
name|transformed_object
decl_stmt|;
block|}
struct|;
comment|/** A general purpose lookup table  *    *  Lookup tables are arrays of (id, name) pairs,  *  So you can for instance lookup the RCODE 3, which is "NXDOMAIN",  *  and vice versa. The lookup tables themselves are defined wherever needed,  *  for instance in \ref host2str.c  */
struct|struct
name|ldns_struct_lookup_table
block|{
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|ldns_struct_lookup_table
name|ldns_lookup_table
typedef|;
comment|/**  * Looks up the table entry by name, returns NULL if not found.  * \param[in] table the lookup table to search in  * \param[in] name what to search for  * \return the item found  */
name|ldns_lookup_table
modifier|*
name|ldns_lookup_by_name
parameter_list|(
name|ldns_lookup_table
name|table
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/**  * Looks up the table entry by id, returns NULL if not found.  * \param[in] table the lookup table to search in  * \param[in] id what to search for  * \return the item found  */
name|ldns_lookup_table
modifier|*
name|ldns_lookup_by_id
parameter_list|(
name|ldns_lookup_table
name|table
index|[]
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
comment|/**  * Returns the value of the specified bit  * The bits are counted from left to right, so bit #0 is the  * left most bit.  * \param[in] bits array holding the bits  * \param[in] index to the wanted bit  * \return   */
name|int
name|ldns_get_bit
parameter_list|(
name|uint8_t
name|bits
index|[]
parameter_list|,
name|size_t
name|index
parameter_list|)
function_decl|;
comment|/**  * Returns the value of the specified bit  * The bits are counted from right to left, so bit #0 is the  * right most bit.  * \param[in] bits array holding the bits  * \param[in] index to the wanted bit  * \return 1 or 0 depending no the bit state  */
name|int
name|ldns_get_bit_r
parameter_list|(
name|uint8_t
name|bits
index|[]
parameter_list|,
name|size_t
name|index
parameter_list|)
function_decl|;
comment|/**  * sets the specified bit in the specified byte to  * 1 if value is true, 0 if false  * The bits are counted from right to left, so bit #0 is the  * right most bit.  * \param[in] byte the bit to set the bit in  * \param[in] bit_nr the bit to set (0<= n<= 7)  * \param[in] value whether to set the bit to 1 or 0  * \return 1 or 0 depending no the bit state  */
name|void
name|ldns_set_bit
parameter_list|(
name|uint8_t
modifier|*
name|byte
parameter_list|,
name|int
name|bit_nr
parameter_list|,
name|bool
name|value
parameter_list|)
function_decl|;
comment|/**  * Returns the value of a to the power of b  * (or 1 of b< 1)  */
comment|/*@unused@*/
name|INLINE
name|long
name|ldns_power
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|long
name|result
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|b
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|&
literal|1
condition|)
block|{
name|result
operator|*=
name|a
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|1
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|a
operator|*=
name|a
expr_stmt|;
name|b
operator|/=
literal|2
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**  * Returns the int value of the given (hex) digit  * \param[in] ch the hex char to convert  * \return the converted decimal value  */
name|int
name|ldns_hexdigit_to_int
parameter_list|(
name|char
name|ch
parameter_list|)
function_decl|;
comment|/**  * Returns the char (hex) representation of the given int  * \param[in] ch the int to convert  * \return the converted hex char  */
name|char
name|ldns_int_to_hexdigit
parameter_list|(
name|int
name|ch
parameter_list|)
function_decl|;
comment|/**  * Converts a hex string to binary data  *  * \param[out] data The binary result is placed here.  * At least strlen(str)/2 bytes should be allocated  * \param[in] str The hex string to convert.  * This string should not contain spaces  * \return The number of bytes of converted data, or -1 if one of the arguments * is NULL, or -2 if the string length is not an even number  */
name|int
name|ldns_hexstring_to_data
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
comment|/**  * Show the internal library version  * \return a string with the version in it  */
specifier|const
name|char
modifier|*
name|ldns_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Convert TM to seconds since epoch (midnight, January 1st, 1970).  * Like timegm(3), which is not always available.  * \param[in] tm a struct tm* with the date  * \return the seconds since epoch  */
name|time_t
name|ldns_mktime_from_utc
parameter_list|(
specifier|const
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
function_decl|;
name|time_t
name|mktime_from_utc
parameter_list|(
specifier|const
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
function_decl|;
comment|/**  * The function interprets time as the number of seconds since epoch  * with respect to now using serial arithmitics (rfc1982).  * That number of seconds is then converted to broken-out time information.  * This is especially usefull when converting the inception and expiration  * fields of RRSIG records.  *  * \param[in] time number of seconds since epoch (midnight, January 1st, 1970)  *            to be intepreted as a serial arithmitics number relative to now.  * \param[in] now number of seconds since epoch (midnight, January 1st, 1970)  *            to which the time value is compared to determine the final value.  * \param[out] result the struct with the broken-out time information  * \return result on success or NULL on error  */
name|struct
name|tm
modifier|*
name|ldns_serial_arithmitics_gmtime_r
parameter_list|(
name|int32_t
name|time
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|tm
modifier|*
name|result
parameter_list|)
function_decl|;
comment|/**  * Seed the random function.  * If the file descriptor is specified, the random generator is seeded with  * data from that file. If not, /dev/urandom is used.  *  * applications should call this if they need entropy data within ldns  * If openSSL is available, it is automatically seeded from /dev/urandom  * or /dev/random.  *  * If you need more entropy, or have no openssl available, this function  * MUST be called at the start of the program  *  * If openssl *is* available, this function just adds more entropy  *  * \param[in] fd a file providing entropy data for the seed  * \param[in] size the number of bytes to use as entropy data. If this is 0,  *            only the minimal amount is taken (usually 4 bytes)  * \return 0 if seeding succeeds, 1 if it fails  */
name|int
name|ldns_init_random
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
function_decl|;
comment|/**  * Get random number.  * \return random number.  *  */
name|uint16_t
name|ldns_get_random
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Encode data as BubbleBabble  *  * \param[in] data a pointer to data to be encoded  * \param[in] len size the number of bytes of data  * \return a string of BubbleBabble  */
name|char
modifier|*
name|ldns_bubblebabble
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|HAVE_B32_NTOP
name|int
name|ldns_b32_ntop
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
name|int
name|b32_ntop
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
name|int
name|ldns_b32_ntop_extended_hex
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
name|int
name|b32_ntop_extended_hex
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
comment|/**  * calculates the size needed to store the result of b32_ntop  */
comment|/*@unused@*/
name|INLINE
name|size_t
name|ldns_b32_ntop_calculate_size
parameter_list|(
name|size_t
name|srcsize
parameter_list|)
block|{
name|size_t
name|result
init|=
operator|(
operator|(
operator|(
operator|(
name|srcsize
operator|/
literal|5
operator|)
operator|*
literal|8
operator|)
operator|-
literal|2
operator|)
operator|+
literal|2
operator|)
decl_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
comment|/* !HAVE_B32_NTOP */
ifndef|#
directive|ifndef
name|HAVE_B32_PTON
name|int
name|ldns_b32_pton
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
name|int
name|b32_pton
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
name|int
name|ldns_b32_pton_extended_hex
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
name|int
name|b32_pton_extended_hex
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
comment|/**  * calculates the size needed to store the result of b32_pton  */
comment|/*@unused@*/
name|INLINE
name|size_t
name|ldns_b32_pton_calculate_size
parameter_list|(
name|size_t
name|srcsize
parameter_list|)
block|{
name|size_t
name|result
init|=
operator|(
operator|(
operator|(
operator|(
name|srcsize
operator|)
operator|/
literal|8
operator|)
operator|*
literal|5
operator|)
operator|)
decl_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
comment|/* !HAVE_B32_PTON */
ifndef|#
directive|ifndef
name|HAVE_B64_NTOP
name|int
name|ldns_b64_ntop
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
comment|/**  * calculates the size needed to store the result of b64_ntop  */
comment|/*@unused@*/
specifier|static
specifier|inline
name|size_t
name|ldns_b64_ntop_calculate_size
parameter_list|(
name|size_t
name|srcsize
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|srcsize
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
operator|*
literal|4
operator|)
operator|+
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !HAVE_B64_NTOP */
ifndef|#
directive|ifndef
name|HAVE_B64_PTON
name|int
name|ldns_b64_pton
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
comment|/**  * calculates the size needed to store the result of ldns_b64_pton  */
comment|/*@unused@*/
specifier|static
specifier|inline
name|size_t
name|ldns_b64_pton_calculate_size
parameter_list|(
name|size_t
name|srcsize
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|srcsize
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|3
operator|)
operator|)
operator|+
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !HAVE_B64_PTON */
name|INLINE
name|time_t
name|ldns_time
parameter_list|(
name|time_t
modifier|*
name|t
parameter_list|)
block|{
return|return
name|time
argument_list|(
name|t
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_UTIL_H */
end_comment

end_unit

