begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Copyright (c) 2009 Mojatatu Networks, Inc  *  */
end_comment

begin_comment
comment|/*  * Per draft-ietf-forces-protocol-22 */
end_comment

begin_define
define|#
directive|define
name|ForCES_VERS
value|1
end_define

begin_define
define|#
directive|define
name|ForCES_HDRL
value|24
end_define

begin_define
define|#
directive|define
name|ForCES_ALNL
value|4U
end_define

begin_define
define|#
directive|define
name|TLV_HDRL
value|4
end_define

begin_define
define|#
directive|define
name|ILV_HDRL
value|8
end_define

begin_define
define|#
directive|define
name|TOM_RSVD
value|0x0
end_define

begin_define
define|#
directive|define
name|TOM_ASSNSETUP
value|0x1
end_define

begin_define
define|#
directive|define
name|TOM_ASSNTEARD
value|0x2
end_define

begin_define
define|#
directive|define
name|TOM_CONFIG
value|0x3
end_define

begin_define
define|#
directive|define
name|TOM_QUERY
value|0x4
end_define

begin_define
define|#
directive|define
name|TOM_EVENTNOT
value|0x5
end_define

begin_define
define|#
directive|define
name|TOM_PKTREDIR
value|0x6
end_define

begin_define
define|#
directive|define
name|TOM_HEARTBT
value|0x0F
end_define

begin_define
define|#
directive|define
name|TOM_ASSNSETREP
value|0x11
end_define

begin_define
define|#
directive|define
name|TOM_CONFIGREP
value|0x13
end_define

begin_define
define|#
directive|define
name|TOM_QUERYREP
value|0x14
end_define

begin_comment
comment|/*  * tom_h Flags: resv1(8b):maxtlvs(4b):resv2(2b):mintlv(2b) */
end_comment

begin_define
define|#
directive|define
name|ZERO_TTLV
value|0x01
end_define

begin_define
define|#
directive|define
name|ZERO_MORE_TTLV
value|0x02
end_define

begin_define
define|#
directive|define
name|ONE_MORE_TTLV
value|0x04
end_define

begin_define
define|#
directive|define
name|ZERO_TLV
value|0x00
end_define

begin_define
define|#
directive|define
name|ONE_TLV
value|0x10
end_define

begin_define
define|#
directive|define
name|TWO_TLV
value|0x20
end_define

begin_define
define|#
directive|define
name|MAX_TLV
value|0xF0
end_define

begin_define
define|#
directive|define
name|TTLV_T1
value|(ONE_MORE_TTLV|ONE_TLV)
end_define

begin_define
define|#
directive|define
name|TTLV_T2
value|(ONE_MORE_TTLV|MAX_TLV)
end_define

begin_struct
struct|struct
name|tom_h
block|{
name|u_int32_t
name|v
decl_stmt|;
name|u_int16_t
name|flags
decl_stmt|;
name|u_int16_t
name|op_msk
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
function_decl|(
modifier|*
name|print
function_decl|)
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|TOM_RSV_I
block|,
name|TOM_ASS_I
block|,
name|TOM_AST_I
block|,
name|TOM_CFG_I
block|,
name|TOM_QRY_I
block|,
name|TOM_EVN_I
block|,
name|TOM_RED_I
block|,
name|TOM_HBT_I
block|,
name|TOM_ASR_I
block|,
name|TOM_CNR_I
block|,
name|TOM_QRR_I
block|,
name|_TOM_RSV_MAX
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|TOM_MAX_IND
value|(_TOM_RSV_MAX - 1)
end_define

begin_function_decl
name|int
name|lfbselect_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|redirect_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|asrtlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|asttlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gentltlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|print_metailv
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|print_metatlv
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|print_reddata
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|tom_valid
parameter_list|(
name|u_int8_t
name|tom
parameter_list|)
block|{
if|if
condition|(
name|tom
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tom
operator|>=
literal|0x7
operator|&&
name|tom
operator|<=
literal|0xe
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tom
operator|==
literal|0x10
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tom
operator|>
literal|0x14
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ForCES_node
parameter_list|(
name|u_int32_t
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|<=
literal|0x3FFFFFFF
condition|)
return|return
literal|"FE"
return|;
if|if
condition|(
name|node
operator|>=
literal|0x40000000
operator|&&
name|node
operator|<=
literal|0x7FFFFFFF
condition|)
return|return
literal|"CE"
return|;
if|if
condition|(
name|node
operator|>=
literal|0xC0000000
operator|&&
name|node
operator|<=
literal|0xFFFFFFEF
condition|)
return|return
literal|"AllMulticast"
return|;
if|if
condition|(
name|node
operator|==
literal|0xFFFFFFFD
condition|)
return|return
literal|"AllCEsBroadcast"
return|;
if|if
condition|(
name|node
operator|==
literal|0xFFFFFFFE
condition|)
return|return
literal|"AllFEsBroadcast"
return|;
if|if
condition|(
name|node
operator|==
literal|0xFFFFFFFF
condition|)
return|return
literal|"AllBroadcast"
return|;
return|return
literal|"ForCESreserved"
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ForCES_ACKp
parameter_list|(
name|u_int32_t
name|flg
parameter_list|)
block|{
if|if
condition|(
name|flg
operator|==
literal|0x0
condition|)
return|return
literal|"NoACK"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x1
condition|)
return|return
literal|"SuccessACK"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x2
condition|)
return|return
literal|"FailureACK"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x3
condition|)
return|return
literal|"AlwaysACK"
return|;
return|return
literal|"ACKUnknown"
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ForCES_EMp
parameter_list|(
name|u_int32_t
name|flg
parameter_list|)
block|{
if|if
condition|(
name|flg
operator|==
literal|0x0
condition|)
return|return
literal|"EMReserved"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x1
condition|)
return|return
literal|"execute-all-or-none"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x2
condition|)
return|return
literal|"execute-until-failure"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x3
condition|)
return|return
literal|"continue-execute-on-failure"
return|;
return|return
literal|"EMUnknown"
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ForCES_ATp
parameter_list|(
name|u_int32_t
name|flg
parameter_list|)
block|{
if|if
condition|(
name|flg
operator|==
literal|0x0
condition|)
return|return
literal|"Standalone"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x1
condition|)
return|return
literal|"2PCtransaction"
return|;
return|return
literal|"ATUnknown"
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ForCES_TPp
parameter_list|(
name|u_int32_t
name|flg
parameter_list|)
block|{
if|if
condition|(
name|flg
operator|==
literal|0x0
condition|)
return|return
literal|"StartofTransaction"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x1
condition|)
return|return
literal|"MiddleofTransaction"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x2
condition|)
return|return
literal|"EndofTransaction"
return|;
if|if
condition|(
name|flg
operator|==
literal|0x3
condition|)
return|return
literal|"abort"
return|;
return|return
literal|"TPUnknown"
return|;
block|}
end_function

begin_comment
comment|/*  * Structure of forces header, naked of TLVs.  */
end_comment

begin_struct
struct|struct
name|forcesh
block|{
name|u_int8_t
name|fm_vrsvd
decl_stmt|;
comment|/* version and reserved */
define|#
directive|define
name|ForCES_V
parameter_list|(
name|forcesh
parameter_list|)
value|((forcesh)->fm_vrsvd>> 4)
name|u_int8_t
name|fm_tom
decl_stmt|;
comment|/* type of message */
name|u_int16_t
name|fm_len
decl_stmt|;
comment|/* total length * 4 bytes */
define|#
directive|define
name|ForCES_BLN
parameter_list|(
name|forcesh
parameter_list|)
value|((u_int32_t)(EXTRACT_16BITS(&(forcesh)->fm_len)<< 2))
name|u_int32_t
name|fm_sid
decl_stmt|;
comment|/* Source ID */
define|#
directive|define
name|ForCES_SID
parameter_list|(
name|forcesh
parameter_list|)
value|EXTRACT_32BITS(&(forcesh)->fm_sid)
name|u_int32_t
name|fm_did
decl_stmt|;
comment|/* Destination ID */
define|#
directive|define
name|ForCES_DID
parameter_list|(
name|forcesh
parameter_list|)
value|EXTRACT_32BITS(&(forcesh)->fm_did)
name|u_int8_t
name|fm_cor
index|[
literal|8
index|]
decl_stmt|;
comment|/* correlator */
name|u_int32_t
name|fm_flags
decl_stmt|;
comment|/* flags */
define|#
directive|define
name|ForCES_ACK
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0xC0000000)>> 30)
define|#
directive|define
name|ForCES_PRI
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x38000000)>> 27)
define|#
directive|define
name|ForCES_RS1
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x07000000)>> 24)
define|#
directive|define
name|ForCES_EM
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00C00000)>> 22)
define|#
directive|define
name|ForCES_AT
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00200000)>> 21)
define|#
directive|define
name|ForCES_TP
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00180000)>> 19)
define|#
directive|define
name|ForCES_RS2
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x0007FFFF)>> 0)
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ForCES_HLN_VALID
parameter_list|(
name|fhl
parameter_list|,
name|tlen
parameter_list|)
value|((tlen)>= ForCES_HDRL&& \ 				   (fhl)>= ForCES_HDRL&& \ 				   (fhl) == (tlen))
end_define

begin_define
define|#
directive|define
name|F_LFB_RSVD
value|0x0
end_define

begin_define
define|#
directive|define
name|F_LFB_FEO
value|0x1
end_define

begin_define
define|#
directive|define
name|F_LFB_FEPO
value|0x2
end_define

begin_decl_stmt
specifier|const
name|struct
name|tok
name|ForCES_LFBs
index|[]
init|=
block|{
block|{
name|F_LFB_RSVD
block|,
literal|"Invalid TLV"
block|}
block|,
block|{
name|F_LFB_FEO
block|,
literal|"FEObj LFB"
block|}
block|,
block|{
name|F_LFB_FEPO
block|,
literal|"FEProtoObj LFB"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|forces_type_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|const
name|struct
name|forcesh
modifier|*
name|fhdr
parameter_list|,
specifier|register
name|u_int
name|mlen
parameter_list|,
specifier|const
name|struct
name|tom_h
modifier|*
name|tops
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
block|{
name|F_OP_RSV
block|,
name|F_OP_SET
block|,
name|F_OP_SETPROP
block|,
name|F_OP_SETRESP
block|,
name|F_OP_SETPRESP
block|,
name|F_OP_DEL
block|,
name|F_OP_DELRESP
block|,
name|F_OP_GET
block|,
name|F_OP_GETPROP
block|,
name|F_OP_GETRESP
block|,
name|F_OP_GETPRESP
block|,
name|F_OP_REPORT
block|,
name|F_OP_COMMIT
block|,
name|F_OP_RCOMMIT
block|,
name|F_OP_RTRCOMP
block|,
name|_F_OP_MAX
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|F_OP_MAX
value|(_F_OP_MAX - 1)
end_define

begin_enum
enum|enum
block|{
name|B_OP_SET
init|=
literal|1
operator|<<
operator|(
name|F_OP_SET
operator|-
literal|1
operator|)
block|,
name|B_OP_SETPROP
init|=
literal|1
operator|<<
operator|(
name|F_OP_SETPROP
operator|-
literal|1
operator|)
block|,
name|B_OP_SETRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_SETRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_SETPRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_SETPRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_DEL
init|=
literal|1
operator|<<
operator|(
name|F_OP_DEL
operator|-
literal|1
operator|)
block|,
name|B_OP_DELRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_DELRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_GET
init|=
literal|1
operator|<<
operator|(
name|F_OP_GET
operator|-
literal|1
operator|)
block|,
name|B_OP_GETPROP
init|=
literal|1
operator|<<
operator|(
name|F_OP_GETPROP
operator|-
literal|1
operator|)
block|,
name|B_OP_GETRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_GETRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_GETPRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_GETPRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_REPORT
init|=
literal|1
operator|<<
operator|(
name|F_OP_REPORT
operator|-
literal|1
operator|)
block|,
name|B_OP_COMMIT
init|=
literal|1
operator|<<
operator|(
name|F_OP_COMMIT
operator|-
literal|1
operator|)
block|,
name|B_OP_RCOMMIT
init|=
literal|1
operator|<<
operator|(
name|F_OP_RCOMMIT
operator|-
literal|1
operator|)
block|,
name|B_OP_RTRCOMP
init|=
literal|1
operator|<<
operator|(
name|F_OP_RTRCOMP
operator|-
literal|1
operator|)
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|optlv_h
block|{
name|u_int16_t
name|flags
decl_stmt|;
name|u_int16_t
name|op_msk
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
function_decl|(
modifier|*
name|print
function_decl|)
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
name|int
name|genoptlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|recpdoptlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|invoptlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OP_MIN_SIZ
value|8
end_define

begin_struct
struct|struct
name|pathdata_h
block|{
name|u_int16_t
name|pflags
decl_stmt|;
name|u_int16_t
name|pIDcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|B_FULLD
value|0x1
end_define

begin_define
define|#
directive|define
name|B_SPARD
value|0x2
end_define

begin_define
define|#
directive|define
name|B_RESTV
value|0x4
end_define

begin_define
define|#
directive|define
name|B_KEYIN
value|0x8
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|optlv_h
name|OPTLV_msg
index|[
name|F_OP_MAX
operator|+
literal|1
index|]
init|=
block|{
comment|/* F_OP_RSV */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|"Invalid OPTLV"
block|,
name|invoptlv_print
block|}
block|,
comment|/* F_OP_SET */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
block|,
literal|" Set"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_SETPROP */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
block|,
literal|" SetProp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_SETRESP */
block|{
name|TTLV_T2
block|,
name|B_RESTV
block|,
literal|" SetResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_SETPRESP */
block|{
name|TTLV_T2
block|,
name|B_RESTV
block|,
literal|" SetPropResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_DEL */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" Del"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_DELRESP */
block|{
name|TTLV_T2
block|,
name|B_RESTV
block|,
literal|" DelResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GET */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" Get"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GETPROP */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" GetProp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GETRESP */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
operator||
name|B_RESTV
block|,
literal|" GetResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GETPRESP */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_RESTV
block|,
literal|" GetPropResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_REPORT */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
block|,
literal|" Report"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_COMMIT */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" Commit"
block|,
name|NULL
block|}
block|,
comment|/* F_OP_RCOMMIT */
block|{
name|TTLV_T1
block|,
name|B_RESTV
block|,
literal|" RCommit"
block|,
name|genoptlv_print
block|}
block|,
comment|/* F_OP_RTRCOMP */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" RTRCOMP"
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|optlv_h
modifier|*
name|get_forces_optlv_h
parameter_list|(
name|u_int16_t
name|opt
parameter_list|)
block|{
if|if
condition|(
name|opt
operator|>
name|F_OP_MAX
operator|||
name|opt
operator|<=
name|F_OP_RSV
condition|)
return|return
operator|&
name|OPTLV_msg
index|[
name|F_OP_RSV
index|]
return|;
return|return
operator|&
name|OPTLV_msg
index|[
name|opt
index|]
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IND_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|IND_CHR
value|' '
end_define

begin_define
define|#
directive|define
name|IND_PREF
value|'\n'
end_define

begin_define
define|#
directive|define
name|IND_SUF
value|0x0
end_define

begin_decl_stmt
name|char
name|ind_buf
index|[
name|IND_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|indent_pr
parameter_list|(
name|int
name|indent
parameter_list|,
name|int
name|nlpref
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|ind_buf
decl_stmt|;
if|if
condition|(
name|indent
operator|>
operator|(
name|IND_SIZE
operator|-
literal|1
operator|)
condition|)
name|indent
operator|=
name|IND_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nlpref
condition|)
block|{
name|r
index|[
name|i
index|]
operator|=
name|IND_PREF
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|indent
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|indent
operator|>=
literal|0
condition|)
name|r
index|[
name|i
operator|++
index|]
operator|=
name|IND_CHR
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
name|IND_SUF
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|op_valid
parameter_list|(
name|u_int16_t
name|op
parameter_list|,
name|u_int16_t
name|mask
parameter_list|)
block|{
name|int
name|opb
init|=
literal|1
operator|<<
operator|(
name|op
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opb
operator|&
name|mask
condition|)
return|return
literal|1
return|;
comment|/* I guess we should allow vendor operations? */
if|if
condition|(
name|op
operator|>=
literal|0x8000
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|F_TLV_RSVD
value|0x0000
end_define

begin_define
define|#
directive|define
name|F_TLV_REDR
value|0x0001
end_define

begin_define
define|#
directive|define
name|F_TLV_ASRS
value|0x0010
end_define

begin_define
define|#
directive|define
name|F_TLV_ASRT
value|0x0011
end_define

begin_define
define|#
directive|define
name|F_TLV_LFBS
value|0x1000
end_define

begin_define
define|#
directive|define
name|F_TLV_PDAT
value|0x0110
end_define

begin_define
define|#
directive|define
name|F_TLV_KEYI
value|0x0111
end_define

begin_define
define|#
directive|define
name|F_TLV_FULD
value|0x0112
end_define

begin_define
define|#
directive|define
name|F_TLV_SPAD
value|0x0113
end_define

begin_define
define|#
directive|define
name|F_TLV_REST
value|0x0114
end_define

begin_define
define|#
directive|define
name|F_TLV_METD
value|0x0115
end_define

begin_define
define|#
directive|define
name|F_TLV_REDD
value|0x0116
end_define

begin_define
define|#
directive|define
name|F_TLV_VNST
value|0x8000
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_TLV
index|[]
init|=
block|{
block|{
name|F_TLV_RSVD
block|,
literal|"Invalid TLV"
block|}
block|,
block|{
name|F_TLV_REDR
block|,
literal|"REDIRECT TLV"
block|}
block|,
block|{
name|F_TLV_ASRS
block|,
literal|"ASResult TLV"
block|}
block|,
block|{
name|F_TLV_ASRT
block|,
literal|"ASTreason TLV"
block|}
block|,
block|{
name|F_TLV_LFBS
block|,
literal|"LFBselect TLV"
block|}
block|,
block|{
name|F_TLV_PDAT
block|,
literal|"PATH-DATA TLV"
block|}
block|,
block|{
name|F_TLV_KEYI
block|,
literal|"KEYINFO TLV"
block|}
block|,
block|{
name|F_TLV_FULD
block|,
literal|"FULLDATA TLV"
block|}
block|,
block|{
name|F_TLV_SPAD
block|,
literal|"SPARSEDATA TLV"
block|}
block|,
block|{
name|F_TLV_REST
block|,
literal|"RESULT TLV"
block|}
block|,
block|{
name|F_TLV_METD
block|,
literal|"METADATA TLV"
block|}
block|,
block|{
name|F_TLV_REDD
block|,
literal|"REDIRECTDATA TLV"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TLV_HLN
value|4
end_define

begin_function
specifier|static
specifier|inline
name|int
name|ttlv_valid
parameter_list|(
name|u_int16_t
name|ttlv
parameter_list|)
block|{
if|if
condition|(
name|ttlv
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ttlv
operator|==
literal|1
operator|||
name|ttlv
operator|==
literal|0x1000
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ttlv
operator|>=
literal|0x10
operator|&&
name|ttlv
operator|<=
literal|0x11
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ttlv
operator|>=
literal|0x110
operator|&&
name|ttlv
operator|<=
literal|0x116
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ttlv
operator|>=
literal|0x8000
condition|)
return|return
literal|0
return|;
comment|/* XXX: */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|forces_ilv
block|{
name|u_int32_t
name|type
decl_stmt|;
name|u_int32_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|forces_tlv
block|{
name|u_int16_t
name|type
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|int
name|otlv_print
parameter_list|(
specifier|const
name|struct
name|forces_tlv
modifier|*
name|otlv
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|F_ALN_LEN
parameter_list|(
name|len
parameter_list|)
value|( ((len)+ForCES_ALNL-1)& ~(ForCES_ALNL-1) )
end_define

begin_define
define|#
directive|define
name|GET_TOP_TLV
parameter_list|(
name|fhdr
parameter_list|)
value|((struct forces_tlv *)((fhdr) + sizeof (struct forcesh)))
end_define

begin_define
define|#
directive|define
name|TLV_SET_LEN
parameter_list|(
name|len
parameter_list|)
value|(F_ALN_LEN(TLV_HDRL) + (len))
end_define

begin_define
define|#
directive|define
name|TLV_ALN_LEN
parameter_list|(
name|len
parameter_list|)
value|F_ALN_LEN(TLV_SET_LEN(len))
end_define

begin_define
define|#
directive|define
name|TLV_RDAT_LEN
parameter_list|(
name|tlv
parameter_list|)
value|((int)(EXTRACT_16BITS(&(tlv)->length) - TLV_SET_LEN(0))
end_define

begin_define
define|#
directive|define
name|TLV_DATA
parameter_list|(
name|tlvp
parameter_list|)
value|((void*)(((char*)(tlvp)) + TLV_SET_LEN(0)))
end_define

begin_define
define|#
directive|define
name|GO_NXT_TLV
parameter_list|(
name|tlv
parameter_list|,
name|rlen
parameter_list|)
value|((rlen) -= F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length)), \ 		              (struct forces_tlv*)(((char*)(tlv)) \ 				      + F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length))))
end_define

begin_define
define|#
directive|define
name|ILV_SET_LEN
parameter_list|(
name|len
parameter_list|)
value|(F_ALN_LEN(ILV_HDRL) + (len))
end_define

begin_define
define|#
directive|define
name|ILV_ALN_LEN
parameter_list|(
name|len
parameter_list|)
value|F_ALN_LEN(ILV_SET_LEN(len))
end_define

begin_define
define|#
directive|define
name|ILV_RDAT_LEN
parameter_list|(
name|ilv
parameter_list|)
value|((int)(EXTRACT_32BITS(&(ilv)->length)) - ILV_SET_LEN(0))
end_define

begin_define
define|#
directive|define
name|ILV_DATA
parameter_list|(
name|ilvp
parameter_list|)
value|((void*)(((char*)(ilvp)) + ILV_SET_LEN(0)))
end_define

begin_define
define|#
directive|define
name|GO_NXT_ILV
parameter_list|(
name|ilv
parameter_list|,
name|rlen
parameter_list|)
value|((rlen) -= F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length)), \ 		              (struct forces_ilv *)(((char*)(ilv)) \ 				      + F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length))))
end_define

begin_define
define|#
directive|define
name|INVALID_RLEN
value|-1
end_define

begin_define
define|#
directive|define
name|INVALID_STLN
value|-2
end_define

begin_define
define|#
directive|define
name|INVALID_LTLN
value|-3
end_define

begin_define
define|#
directive|define
name|INVALID_ALEN
value|-4
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_TLV_err
index|[]
init|=
block|{
block|{
name|INVALID_RLEN
block|,
literal|"Invalid total length"
block|}
block|,
block|{
name|INVALID_STLN
block|,
literal|"xLV too short"
block|}
block|,
block|{
name|INVALID_LTLN
block|,
literal|"xLV too long"
block|}
block|,
block|{
name|INVALID_ALEN
block|,
literal|"data padding missing"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|tlv_valid
parameter_list|(
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
parameter_list|,
name|u_int
name|rlen
parameter_list|)
block|{
if|if
condition|(
name|rlen
operator|<
name|TLV_HDRL
condition|)
return|return
name|INVALID_RLEN
return|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
operator|<
name|TLV_HDRL
condition|)
return|return
name|INVALID_STLN
return|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
operator|>
name|rlen
condition|)
return|return
name|INVALID_LTLN
return|;
if|if
condition|(
name|rlen
operator|<
name|F_ALN_LEN
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
argument_list|)
condition|)
return|return
name|INVALID_ALEN
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ilv_valid
parameter_list|(
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
parameter_list|,
name|u_int
name|rlen
parameter_list|)
block|{
if|if
condition|(
name|rlen
operator|<
name|ILV_HDRL
condition|)
return|return
name|INVALID_RLEN
return|;
if|if
condition|(
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
operator|<
name|ILV_HDRL
condition|)
return|return
name|INVALID_STLN
return|;
if|if
condition|(
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
operator|>
name|rlen
condition|)
return|return
name|INVALID_LTLN
return|;
if|if
condition|(
name|rlen
operator|<
name|F_ALN_LEN
argument_list|(
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
argument_list|)
condition|)
return|return
name|INVALID_ALEN
return|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|forces_lfbsh
block|{
name|u_int32_t
name|class
decl_stmt|;
name|u_int32_t
name|instance
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ASSNS_OPS
value|(B_OP_REPORT)
end_define

begin_define
define|#
directive|define
name|CFG_OPS
value|(B_OP_SET|B_OP_SETPROP|B_OP_DEL|B_OP_COMMIT|B_OP_RTRCOMP)
end_define

begin_define
define|#
directive|define
name|CFG_ROPS
value|(B_OP_SETRESP|B_OP_SETPRESP|B_OP_DELRESP|B_OP_RCOMMIT)
end_define

begin_define
define|#
directive|define
name|CFG_QY
value|(B_OP_GET|B_OP_GETPROP)
end_define

begin_define
define|#
directive|define
name|CFG_QYR
value|(B_OP_GETRESP|B_OP_GETPRESP)
end_define

begin_define
define|#
directive|define
name|CFG_EVN
value|(B_OP_REPORT)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tom_h
name|ForCES_msg
index|[
name|TOM_MAX_IND
operator|+
literal|1
index|]
init|=
block|{
comment|/* TOM_RSV_I */
block|{
name|TOM_RSVD
block|,
name|ZERO_TTLV
block|,
literal|0
block|,
literal|"Invalid message"
block|,
name|NULL
block|}
block|,
comment|/* TOM_ASS_I */
block|{
name|TOM_ASSNSETUP
block|,
name|ZERO_MORE_TTLV
operator||
name|TWO_TLV
block|,
name|ASSNS_OPS
block|,
literal|"Association Setup"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_AST_I */
block|{
name|TOM_ASSNTEARD
block|,
name|TTLV_T1
block|,
literal|0
block|,
literal|"Association TearDown"
block|,
name|asttlv_print
block|}
block|,
comment|/* TOM_CFG_I */
block|{
name|TOM_CONFIG
block|,
name|TTLV_T2
block|,
name|CFG_OPS
block|,
literal|"Config"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_QRY_I */
block|{
name|TOM_QUERY
block|,
name|TTLV_T2
block|,
name|CFG_QY
block|,
literal|"Query"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_EVN_I */
block|{
name|TOM_EVENTNOT
block|,
name|TTLV_T1
block|,
name|CFG_EVN
block|,
literal|"Event Notification"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_RED_I */
block|{
name|TOM_PKTREDIR
block|,
name|TTLV_T2
block|,
literal|0
block|,
literal|"Packet Redirect"
block|,
name|redirect_print
block|}
block|,
comment|/* TOM_HBT_I */
block|{
name|TOM_HEARTBT
block|,
name|ZERO_TTLV
block|,
literal|0
block|,
literal|"HeartBeat"
block|,
name|NULL
block|}
block|,
comment|/* TOM_ASR_I */
block|{
name|TOM_ASSNSETREP
block|,
name|TTLV_T1
block|,
literal|0
block|,
literal|"Association Response"
block|,
name|asrtlv_print
block|}
block|,
comment|/* TOM_CNR_I */
block|{
name|TOM_CONFIGREP
block|,
name|TTLV_T2
block|,
name|CFG_ROPS
block|,
literal|"Config Response"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_QRR_I */
block|{
name|TOM_QUERYREP
block|,
name|TTLV_T2
block|,
name|CFG_QYR
block|,
literal|"Query Response"
block|,
name|lfbselect_print
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|tom_h
modifier|*
name|get_forces_tom
parameter_list|(
name|u_int8_t
name|tom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TOM_RSV_I
init|;
name|i
operator|<=
name|TOM_MAX_IND
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|tom_h
modifier|*
name|th
init|=
operator|&
name|ForCES_msg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|th
operator|->
name|v
operator|==
name|tom
condition|)
return|return
name|th
return|;
block|}
return|return
operator|&
name|ForCES_msg
index|[
name|TOM_RSV_I
index|]
return|;
block|}
end_function

begin_struct
struct|struct
name|pdata_ops
block|{
name|u_int32_t
name|v
decl_stmt|;
name|u_int16_t
name|flags
decl_stmt|;
name|u_int16_t
name|op_msk
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
function_decl|(
modifier|*
name|print
function_decl|)
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|PD_RSV_I
block|,
name|PD_SEL_I
block|,
name|PD_FDT_I
block|,
name|PD_SDT_I
block|,
name|PD_RES_I
block|,
name|PD_PDT_I
block|,
name|_PD_RSV_MAX
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|PD_MAX_IND
value|(_TOM_RSV_MAX - 1)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|pd_valid
parameter_list|(
name|u_int16_t
name|pd
parameter_list|)
block|{
if|if
condition|(
name|pd
operator|>=
name|F_TLV_PDAT
operator|&&
name|pd
operator|<=
name|F_TLV_REST
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|chk_op_type
parameter_list|(
name|u_int16_t
name|type
parameter_list|,
name|u_int16_t
name|msk
parameter_list|,
name|u_int16_t
name|omsk
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|F_TLV_PDAT
condition|)
block|{
if|if
condition|(
name|msk
operator|&
name|B_KEYIN
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|F_TLV_KEYI
condition|)
block|{
name|printf
argument_list|(
literal|"Based on flags expected KEYINFO TLV!\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|msk
operator|&
name|omsk
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal DATA encoding for type 0x%x programmed %x got %x \n"
argument_list|,
name|type
argument_list|,
name|omsk
argument_list|,
name|msk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function_decl
name|int
name|fdatatlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sdatailv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sdatatlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pdatatlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pkeyitlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pdatacnt_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|IDcnt
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pdata_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|prestlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|F_SELKEY
value|1
end_define

begin_struct
struct|struct
name|res_val
block|{
name|u_int8_t
name|result
decl_stmt|;
name|u_int8_t
name|resv1
decl_stmt|;
name|u_int16_t
name|resv2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pdata_ops
name|ForCES_pdata
index|[
name|PD_MAX_IND
operator|+
literal|1
index|]
init|=
block|{
comment|/* PD_RSV_I */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"Invalid message"
block|,
name|NULL
block|}
block|,
comment|/* PD_SEL_I */
block|{
name|F_TLV_KEYI
block|,
literal|0
block|,
literal|0
block|,
literal|"KEYINFO TLV"
block|,
name|pkeyitlv_print
block|}
block|,
comment|/* PD_FDT_I */
block|{
name|F_TLV_FULD
block|,
literal|0
block|,
name|B_FULLD
block|,
literal|"FULLDATA TLV"
block|,
name|fdatatlv_print
block|}
block|,
comment|/* PD_SDT_I */
block|{
name|F_TLV_SPAD
block|,
literal|0
block|,
name|B_SPARD
block|,
literal|"SPARSEDATA TLV"
block|,
name|sdatatlv_print
block|}
block|,
comment|/* PD_RES_I */
block|{
name|F_TLV_REST
block|,
literal|0
block|,
name|B_RESTV
block|,
literal|"RESULT TLV"
block|,
name|prestlv_print
block|}
block|,
comment|/* PD_PDT_I */
block|{
name|F_TLV_PDAT
block|,
literal|0
block|,
literal|0
block|,
literal|"Inner PATH-DATA TLV"
block|,
name|recpdoptlv_print
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|pdata_ops
modifier|*
name|get_forces_pd
parameter_list|(
name|u_int16_t
name|pd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|PD_RSV_I
operator|+
literal|1
init|;
name|i
operator|<=
name|PD_MAX_IND
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|pdata_ops
modifier|*
name|pdo
init|=
operator|&
name|ForCES_pdata
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pdo
operator|->
name|v
operator|==
name|pd
condition|)
return|return
name|pdo
return|;
block|}
return|return
operator|&
name|ForCES_pdata
index|[
name|TOM_RSV_I
index|]
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|E_SUCCESS
block|,
name|E_INVALID_HEADER
block|,
name|E_LENGTH_MISMATCH
block|,
name|E_VERSION_MISMATCH
block|,
name|E_INVALID_DESTINATION_PID
block|,
name|E_LFB_UNKNOWN
block|,
name|E_LFB_NOT_FOUND
block|,
name|E_LFB_INSTANCE_ID_NOT_FOUND
block|,
name|E_INVALID_PATH
block|,
name|E_COMPONENT_DOES_NOT_EXIST
block|,
name|E_EXISTS
block|,
name|E_NOT_FOUND
block|,
name|E_READ_ONLY
block|,
name|E_INVALID_ARRAY_CREATION
block|,
name|E_VALUE_OUT_OF_RANGE
block|,
name|E_CONTENTS_TOO_LONG
block|,
name|E_INVALID_PARAMETERS
block|,
name|E_INVALID_MESSAGE_TYPE
block|,
name|E_INVALID_FLAGS
block|,
name|E_INVALID_TLV
block|,
name|E_EVENT_ERROR
block|,
name|E_NOT_SUPPORTED
block|,
name|E_MEMORY_ERROR
block|,
name|E_INTERNAL_ERROR
block|,
comment|/* 0x18-0xFE are reserved .. */
name|E_UNSPECIFIED_ERROR
init|=
literal|0XFF
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|struct
name|tok
name|ForCES_errs
index|[]
init|=
block|{
block|{
name|E_SUCCESS
block|,
literal|"SUCCESS"
block|}
block|,
block|{
name|E_INVALID_HEADER
block|,
literal|"INVALID HEADER"
block|}
block|,
block|{
name|E_LENGTH_MISMATCH
block|,
literal|"LENGTH MISMATCH"
block|}
block|,
block|{
name|E_VERSION_MISMATCH
block|,
literal|"VERSION MISMATCH"
block|}
block|,
block|{
name|E_INVALID_DESTINATION_PID
block|,
literal|"INVALID DESTINATION PID"
block|}
block|,
block|{
name|E_LFB_UNKNOWN
block|,
literal|"LFB UNKNOWN"
block|}
block|,
block|{
name|E_LFB_NOT_FOUND
block|,
literal|"LFB NOT FOUND"
block|}
block|,
block|{
name|E_LFB_INSTANCE_ID_NOT_FOUND
block|,
literal|"LFB INSTANCE ID NOT FOUND"
block|}
block|,
block|{
name|E_INVALID_PATH
block|,
literal|"INVALID PATH"
block|}
block|,
block|{
name|E_COMPONENT_DOES_NOT_EXIST
block|,
literal|"COMPONENT DOES NOT EXIST"
block|}
block|,
block|{
name|E_EXISTS
block|,
literal|"EXISTS ALREADY"
block|}
block|,
block|{
name|E_NOT_FOUND
block|,
literal|"NOT FOUND"
block|}
block|,
block|{
name|E_READ_ONLY
block|,
literal|"READ ONLY"
block|}
block|,
block|{
name|E_INVALID_ARRAY_CREATION
block|,
literal|"INVALID ARRAY CREATION"
block|}
block|,
block|{
name|E_VALUE_OUT_OF_RANGE
block|,
literal|"VALUE OUT OF RANGE"
block|}
block|,
block|{
name|E_CONTENTS_TOO_LONG
block|,
literal|"CONTENTS TOO LONG"
block|}
block|,
block|{
name|E_INVALID_PARAMETERS
block|,
literal|"INVALID PARAMETERS"
block|}
block|,
block|{
name|E_INVALID_MESSAGE_TYPE
block|,
literal|"INVALID MESSAGE TYPE"
block|}
block|,
block|{
name|E_INVALID_FLAGS
block|,
literal|"INVALID FLAGS"
block|}
block|,
block|{
name|E_INVALID_TLV
block|,
literal|"INVALID TLV"
block|}
block|,
block|{
name|E_EVENT_ERROR
block|,
literal|"EVENT ERROR"
block|}
block|,
block|{
name|E_NOT_SUPPORTED
block|,
literal|"NOT SUPPORTED"
block|}
block|,
block|{
name|E_MEMORY_ERROR
block|,
literal|"MEMORY ERROR"
block|}
block|,
block|{
name|E_INTERNAL_ERROR
block|,
literal|"INTERNAL ERROR"
block|}
block|,
block|{
name|E_UNSPECIFIED_ERROR
block|,
literal|"UNSPECIFIED ERROR"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

