begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code  * distributions retain the above copyright notice and this paragraph  * in its entirety, and (2) distributions including binary code include  * the above copyright notice and this paragraph in its entirety in  * the documentation or other materials provided with the distribution.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND  * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT  * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE.  *  * Copyright (c) 2009 Mojatatu Networks, Inc  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_include
include|#
directive|include
file|"forces.h"
end_include

begin_define
define|#
directive|define
name|RESLEN
value|4
end_define

begin_function
name|int
name|prestlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
name|struct
name|res_val
modifier|*
name|r
init|=
operator|(
expr|struct
name|res_val
operator|*
operator|)
name|tdp
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
comment|/* 	 * pdatacnt_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
name|RESLEN
condition|)
block|{
name|printf
argument_list|(
literal|"illegal RESULT-TLV: %d bytes!\n"
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|TCHECK
argument_list|(
operator|*
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|result
operator|>=
literal|0x18
operator|&&
name|r
operator|->
name|result
operator|<=
literal|0xFE
condition|)
block|{
name|printf
argument_list|(
literal|"illegal reserved result code: 0x%x!\n"
argument_list|,
name|r
operator|->
name|result
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s  Result: %s (code 0x%x)\n"
argument_list|,
name|ib
argument_list|,
name|tok2str
argument_list|(
name|ForCES_errs
argument_list|,
name|NULL
argument_list|,
name|r
operator|->
name|result
argument_list|)
argument_list|,
name|r
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|fdatatlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
comment|/* 	 * pdatacnt_print() or pkeyitlv_print() has ensured that len 	 * (the TLV length)>= TLV_HDRL. 	 */
name|rlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|F_TLV_FULD
condition|)
block|{
name|printf
argument_list|(
literal|"Error: expecting FULLDATA!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s["
argument_list|,
operator|&
name|ib
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ib
argument_list|,
name|tdp
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s]\n"
argument_list|,
operator|&
name|ib
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sdatailv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|rlen
decl_stmt|;
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
init|=
operator|(
expr|struct
name|forces_ilv
operator|*
operator|)
name|pptr
decl_stmt|;
name|int
name|invilv
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|ILV_HDRL
condition|)
block|{
name|printf
argument_list|(
literal|"Error: BAD SPARSEDATA-TLV!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rlen
operator|=
name|len
expr_stmt|;
name|indent
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|ILV_DATA
argument_list|(
name|ilv
argument_list|)
decl_stmt|;
name|TCHECK
argument_list|(
operator|*
name|ilv
argument_list|)
expr_stmt|;
name|invilv
operator|=
name|ilv_valid
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invilv
condition|)
block|{
name|printf
argument_list|(
literal|"%s["
argument_list|,
operator|&
name|ib
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ib
argument_list|,
name|tdp
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s]\n"
argument_list|,
operator|&
name|ib
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|int
name|ilvl
init|=
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s ILV: type %x length %d\n"
argument_list|,
operator|&
name|ib
index|[
literal|1
index|]
argument_list|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|type
argument_list|)
argument_list|,
name|ilvl
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
literal|"\t\t["
argument_list|,
name|tdp
argument_list|,
name|ilvl
operator|-
name|ILV_HDRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ilv
operator|=
name|GO_NXT_ILV
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sdatatlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
comment|/* 	 * pdatacnt_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|rlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|F_TLV_SPAD
condition|)
block|{
name|printf
argument_list|(
literal|"Error: expecting SPARSEDATA!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sdatailv_print
argument_list|(
name|tdp
argument_list|,
name|rlen
argument_list|,
name|op_msk
argument_list|,
name|indent
argument_list|)
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|pkeyitlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
init|=
name|tdp
operator|+
literal|4
decl_stmt|;
specifier|const
name|struct
name|forces_tlv
modifier|*
name|kdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|dp
decl_stmt|;
name|u_int32_t
name|id
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|,
name|tll
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
name|TCHECK
argument_list|(
operator|*
name|tdp
argument_list|)
expr_stmt|;
name|id
operator|=
name|EXTRACT_32BITS
argument_list|(
name|tdp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sKeyinfo: Key 0x%x\n"
argument_list|,
name|ib
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|kdtlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|kdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|kdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
name|printf
argument_list|(
literal|"%s TLV type 0x%x len %d\n"
argument_list|,
name|tok2str
argument_list|(
name|ForCES_TLV_err
argument_list|,
name|NULL
argument_list|,
name|invtlv
argument_list|)
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|kdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * At this point, tlv_valid() has ensured that the TLV 	 * length is large enough but not too large (it doesn't 	 * go past the end of the containing TLV). 	 */
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|kdtlv
operator|->
name|length
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|kdtlv
argument_list|)
expr_stmt|;
return|return
name|fdatatlv_print
argument_list|(
name|dp
argument_list|,
name|tll
argument_list|,
name|op_msk
argument_list|,
name|indent
argument_list|)
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|pdatacnt_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|IDcnt
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_int32_t
name|id
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDcnt
condition|;
name|i
operator|++
control|)
block|{
name|TCHECK2
argument_list|(
operator|*
name|pptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
goto|goto
name|trunc
goto|;
name|id
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"%s  ID#%02u: %d\n"
argument_list|,
name|ib
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|pdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
name|u_int16_t
name|tll
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
name|u_int
name|aln
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
name|TCHECK
argument_list|(
operator|*
name|pdtlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
name|printf
argument_list|(
literal|"%s Outstanding bytes %d for TLV type 0x%x TLV len %d\n"
argument_list|,
name|tok2str
argument_list|(
name|ForCES_TLV_err
argument_list|,
name|NULL
argument_list|,
name|invtlv
argument_list|)
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|pd_err
goto|;
block|}
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
name|aln
operator|=
name|F_ALN_LEN
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aln
operator|>
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|aln
operator|>
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid padded pathdata TLV type 0x%x len %d missing %d pad bytes\n"
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|,
name|aln
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pad
operator|=
name|aln
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pd_valid
argument_list|(
name|type
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|pdata_ops
modifier|*
name|ops
init|=
name|get_forces_pd
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|vflag
operator|>=
literal|3
operator|&&
name|ops
operator|->
name|v
operator|!=
name|F_TLV_PDAT
condition|)
block|{
if|if
condition|(
name|pad
condition|)
name|printf
argument_list|(
literal|"%s  %s (Length %d DataLen %d pad %d Bytes)\n"
argument_list|,
name|ib
argument_list|,
name|ops
operator|->
name|s
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|,
name|tll
argument_list|,
name|pad
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s  %s (Length %d DataLen %d Bytes)\n"
argument_list|,
name|ib
argument_list|,
name|ops
operator|->
name|s
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|,
name|tll
argument_list|)
expr_stmt|;
block|}
name|chk_op_type
argument_list|(
name|type
argument_list|,
name|op_msk
argument_list|,
name|ops
operator|->
name|op_msk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
operator|->
name|print
argument_list|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|pdtlv
argument_list|,
name|tll
operator|+
name|pad
operator|+
name|TLV_HDRL
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|-=
operator|(
name|TLV_HDRL
operator|+
name|pad
operator|+
name|tll
operator|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Invalid path data content type 0x%x len %d\n"
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|pd_err
label|:
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
condition|)
block|{
name|hex_print_with_offset
argument_list|(
literal|"Bad Data val\n\t  ["
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
return|return
name|len
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|pdata_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|pathdata_h
modifier|*
name|pdh
init|=
operator|(
expr|struct
name|pathdata_h
operator|*
operator|)
name|pptr
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int
name|minsize
init|=
literal|0
decl_stmt|;
name|int
name|more_pd
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|idcnt
init|=
literal|0
decl_stmt|;
name|TCHECK
argument_list|(
operator|*
name|pdh
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|pathdata_h
argument_list|)
condition|)
goto|goto
name|trunc
goto|;
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\n%sPathdata: Flags 0x%x ID count %d\n"
argument_list|,
name|ib
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pflags
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pIDcnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pflags
argument_list|)
operator|&
name|F_SELKEY
condition|)
block|{
name|op_msk
operator||=
name|B_KEYIN
expr_stmt|;
block|}
name|pptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pathdata_h
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|pathdata_h
argument_list|)
expr_stmt|;
name|idcnt
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pIDcnt
argument_list|)
expr_stmt|;
name|minsize
operator|=
name|idcnt
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|minsize
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t\ttruncated IDs expected %uB got %uB\n"
argument_list|,
name|minsize
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
literal|"\t\t\tID Data["
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|more_pd
operator|=
name|pdatacnt_print
argument_list|(
name|pptr
argument_list|,
name|len
argument_list|,
name|idcnt
argument_list|,
name|op_msk
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_pd
operator|>
literal|0
condition|)
block|{
name|int
name|consumed
init|=
name|len
operator|-
name|more_pd
decl_stmt|;
name|pptr
operator|+=
name|consumed
expr_stmt|;
name|len
operator|=
name|more_pd
expr_stmt|;
comment|/* XXX: Argh, recurse some more */
return|return
name|recpdoptlv_print
argument_list|(
name|pptr
argument_list|,
name|len
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|genoptlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|pdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
name|int
name|tll
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TCHECK
argument_list|(
operator|*
name|pdtlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"genoptlvprint - %s TLV type 0x%x len %d\n"
argument_list|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invtlv
condition|)
block|{
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|pdtlv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ttlv_valid
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s TLV type 0x%x len %d\n"
argument_list|,
name|tok2str
argument_list|(
name|ForCES_TLV_err
argument_list|,
name|NULL
argument_list|,
name|invtlv
argument_list|)
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"%s%s, length %d (data length %d Bytes)"
argument_list|,
name|ib
argument_list|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|,
name|tll
argument_list|)
expr_stmt|;
return|return
name|pdata_print
argument_list|(
name|dp
argument_list|,
name|tll
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\t\t\tInvalid ForCES TLV type=%x"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|recpdoptlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|pdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|int
name|tll
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|ib
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|TCHECK
argument_list|(
operator|*
name|pdtlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
break|break;
block|}
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
name|ib
operator|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|pdtlv
argument_list|)
expr_stmt|;
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"%s%s, length %d (data encapsulated %d Bytes)"
argument_list|,
name|ib
argument_list|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata_print
argument_list|(
name|dp
argument_list|,
name|tll
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|pdtlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\tMessy PATHDATA TLV header, type (0x%x)\n\t\texcess of %d Bytes "
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
argument_list|,
name|len
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|invoptlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"%sData["
argument_list|,
operator|&
name|ib
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ib
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s]\n"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|otlv_print
parameter_list|(
specifier|const
name|struct
name|forces_tlv
modifier|*
name|otlv
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|otlv
argument_list|)
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
name|int
name|tll
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|optlv_h
modifier|*
name|ops
decl_stmt|;
comment|/* 	 * lfbselect_print() has ensured that EXTRACT_16BITS(&otlv->length) 	 *>= TLV_HDRL. 	 */
name|TCHECK
argument_list|(
operator|*
name|otlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
name|ops
operator|=
name|get_forces_optlv_h
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"%sOper TLV %s(0x%x) length %d\n"
argument_list|,
name|ib
argument_list|,
name|ops
operator|->
name|s
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* empty TLVs like COMMIT and TRCOMMIT are empty, we stop here .. */
if|if
condition|(
operator|!
name|ops
operator|->
name|flags
operator|&
name|ZERO_TTLV
condition|)
block|{
if|if
condition|(
name|tll
operator|!=
literal|0
condition|)
comment|/* instead of "if (tll)" - for readability .. */
name|printf
argument_list|(
literal|"%s: Illegal - MUST be empty\n"
argument_list|,
name|ops
operator|->
name|s
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* rest of ops must at least have 12B {pathinfo} */
if|if
condition|(
name|tll
operator|<
name|OP_MIN_SIZ
condition|)
block|{
name|printf
argument_list|(
literal|"\t\tOper TLV %s(0x%x) length %d\n"
argument_list|,
name|ops
operator|->
name|s
argument_list|,
name|type
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tTruncated data size %d minimum required %d\n"
argument_list|,
name|tll
argument_list|,
name|OP_MIN_SIZ
argument_list|)
expr_stmt|;
return|return
name|invoptlv_print
argument_list|(
name|dp
argument_list|,
name|tll
argument_list|,
name|ops
operator|->
name|op_msk
argument_list|,
name|indent
argument_list|)
return|;
block|}
name|rc
operator|=
name|ops
operator|->
name|print
argument_list|(
name|dp
argument_list|,
name|tll
argument_list|,
name|ops
operator|->
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ASTDLN
value|4
end_define

begin_define
define|#
directive|define
name|ASTMCD
value|255
end_define

begin_function
name|int
name|asttlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int32_t
name|rescode
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
name|ASTDLN
condition|)
block|{
name|printf
argument_list|(
literal|"illegal ASTresult-TLV: %d bytes!\n"
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|TCHECK2
argument_list|(
operator|*
name|pptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rescode
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescode
operator|>
name|ASTMCD
condition|)
block|{
name|printf
argument_list|(
literal|"illegal ASTresult result code: %d!\n"
argument_list|,
name|rescode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"Teardown reason:\n%s"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rescode
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"Normal Teardown"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"Loss of Heartbeats"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"Out of bandwidth"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"Out of Memory"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"Application Crash"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown Teardown reason"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"(%x)\n%s"
argument_list|,
name|rescode
argument_list|,
name|ib
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ASRDLN
value|4
end_define

begin_define
define|#
directive|define
name|ASRMCD
value|3
end_define

begin_function
name|int
name|asrtlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int32_t
name|rescode
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
name|ASRDLN
condition|)
block|{
comment|/* id, instance, oper tlv */
name|printf
argument_list|(
literal|"illegal ASRresult-TLV: %d bytes!\n"
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|TCHECK2
argument_list|(
operator|*
name|pptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rescode
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescode
operator|>
name|ASRMCD
condition|)
block|{
name|printf
argument_list|(
literal|"illegal ASRresult result code: %d!\n"
argument_list|,
name|rescode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rescode
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"Success "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"FE ID invalid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"permission denied "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"(%x)\n%s"
argument_list|,
name|rescode
argument_list|,
name|ib
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * XXX - not used.  */
end_comment

begin_function
name|int
name|gentltlv_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
name|_U_
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
name|_U_
parameter_list|)
block|{
name|u_int
name|dlen
init|=
name|len
operator|-
name|TLV_HDRL
decl_stmt|;
if|if
condition|(
name|dlen
operator|<
literal|4
condition|)
block|{
comment|/* at least 32 bits must exist */
name|printf
argument_list|(
literal|"truncated TLV: %d bytes missing! "
argument_list|,
literal|4
operator|-
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RD_MIN
value|8
end_define

begin_function
name|int
name|print_metailv
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|dlen
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* XXX: check header length */
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
init|=
operator|(
expr|struct
name|forces_ilv
operator|*
operator|)
name|pptr
decl_stmt|;
comment|/* 	 * print_metatlv() has ensured that len (what remains in the 	 * ILV)>= ILV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|ILV_HDRL
expr_stmt|;
name|rlen
operator|=
name|dlen
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|ilv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%sMetaID 0x%x length %d\n"
argument_list|,
name|ib
argument_list|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|type
argument_list|)
argument_list|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
literal|"\n\t\t\t\t["
argument_list|,
name|ILV_DATA
argument_list|(
name|ilv
argument_list|)
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|print_metatlv
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|dlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
init|=
operator|(
expr|struct
name|forces_ilv
operator|*
operator|)
name|pptr
decl_stmt|;
name|int
name|invilv
decl_stmt|;
comment|/* 	 * redirect_print() has ensured that len (what remains in the 	 * TLV)>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|rlen
operator|=
name|dlen
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s METADATA\n"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|TCHECK
argument_list|(
operator|*
name|ilv
argument_list|)
expr_stmt|;
name|invilv
operator|=
name|ilv_valid
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invilv
condition|)
break|break;
comment|/* 		 * At this point, ilv_valid() has ensured that the ILV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
name|print_metailv
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ilv
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ilv
operator|=
name|GO_NXT_ILV
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
name|int
name|print_reddata
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
name|_U_
parameter_list|)
block|{
name|u_int
name|dlen
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
comment|/* 	 * redirect_print() has ensured that len (what remains in the 	 * TLV)>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\t Redirect DATA\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|<=
name|RD_MIN
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\ttruncated Redirect data: %d bytes missing! "
argument_list|,
name|RD_MIN
operator|-
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rlen
operator|=
name|dlen
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|tlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
name|printf
argument_list|(
literal|"Redir data type 0x%x len %d\n"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * At this point, tlv_valid() has ensured that the TLV 	 * length is large enough but not too large (it doesn't 	 * go past the end of the containing TLV). 	 */
name|rlen
operator|-=
name|TLV_HDRL
expr_stmt|;
name|hex_print_with_offset
argument_list|(
literal|"\n\t\t\t["
argument_list|,
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|redirect_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|<=
name|RD_MIN
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\ttruncated Redirect TLV: %d bytes missing! "
argument_list|,
name|RD_MIN
operator|-
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rlen
operator|=
name|dlen
expr_stmt|;
name|indent
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|TCHECK
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|tlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
break|break;
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
operator|==
name|F_TLV_METD
condition|)
block|{
name|print_metatlv
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
operator|==
name|F_TLV_REDD
operator|)
condition|)
block|{
name|print_reddata
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unknown REDIRECT TLV 0x%x len %d\n"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|tlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rlen
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\tMessy Redirect TLV header, type (0x%x)\n\t\texcess of %d Bytes "
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
argument_list|,
name|rlen
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OP_OFF
value|8
end_define

begin_define
define|#
directive|define
name|OP_MIN
value|12
end_define

begin_function
name|int
name|lfbselect_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|u_int16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_lfbsh
modifier|*
name|lfbs
decl_stmt|;
specifier|const
name|struct
name|forces_tlv
modifier|*
name|otlv
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|<=
name|OP_MIN
condition|)
block|{
comment|/* id, instance, oper tlv header .. */
name|printf
argument_list|(
literal|"\n\t\ttruncated lfb selector: %d bytes missing! "
argument_list|,
name|OP_MIN
operator|-
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * At this point, we know that dlen> OP_MIN; OP_OFF< OP_MIN, so 	 * we also know that it's> OP_OFF. 	 */
name|rlen
operator|=
name|dlen
operator|-
name|OP_OFF
expr_stmt|;
name|lfbs
operator|=
operator|(
specifier|const
expr|struct
name|forces_lfbsh
operator|*
operator|)
name|pptr
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|lfbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s%s(Classid %x) instance %x\n"
argument_list|,
name|ib
argument_list|,
name|tok2str
argument_list|(
name|ForCES_LFBs
argument_list|,
name|NULL
argument_list|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|lfbs
operator|->
name|class
argument_list|)
argument_list|)
argument_list|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|lfbs
operator|->
name|class
argument_list|)
argument_list|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|lfbs
operator|->
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|otlv
operator|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
operator|(
name|lfbs
operator|+
literal|1
operator|)
expr_stmt|;
name|indent
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|TCHECK
argument_list|(
operator|*
name|otlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|otlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
break|break;
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
if|if
condition|(
name|op_valid
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
argument_list|,
name|op_msk
argument_list|)
condition|)
block|{
name|otlv_print
argument_list|(
name|otlv
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vflag
operator|<
literal|3
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tINValid oper-TLV type 0x%x length %d for this ForCES message\n"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|invoptlv_print
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|otlv
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
name|otlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|otlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rlen
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\tMessy oper TLV header, type (0x%x)\n\t\texcess of %d Bytes "
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
argument_list|,
name|rlen
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|forces_type_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|const
name|struct
name|forcesh
modifier|*
name|fhdr
name|_U_
parameter_list|,
specifier|register
name|u_int
name|mlen
parameter_list|,
specifier|const
name|struct
name|tom_h
modifier|*
name|tops
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tltlv
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|int
name|invtlv
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|ttlv
init|=
literal|0
decl_stmt|;
comment|/* 	 * forces_print() has already checked that mlen>= ForCES_HDRL 	 * by calling ForCES_HLN_VALID(). 	 */
name|rlen
operator|=
name|mlen
operator|-
name|ForCES_HDRL
expr_stmt|;
if|if
condition|(
name|rlen
operator|>
name|TLV_HLN
condition|)
block|{
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ZERO_TTLV
condition|)
block|{
name|printf
argument_list|(
literal|"<0x%x>Illegal Top level TLV!\n"
argument_list|,
name|tops
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ZERO_MORE_TTLV
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ONE_MORE_TTLV
condition|)
block|{
name|printf
argument_list|(
literal|"\tTop level TLV Data missing!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ZERO_TTLV
condition|)
block|{
return|return
literal|0
return|;
block|}
name|ttlv
operator|=
name|tops
operator|->
name|flags
operator|>>
literal|4
expr_stmt|;
name|tltlv
operator|=
name|GET_TOP_TLV
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
comment|/*XXX: 15 top level tlvs will probably be fine 	   You are nuts if you send more ;-> */
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|TCHECK
argument_list|(
operator|*
name|tltlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|tltlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
break|break;
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the packet). 		 */
if|if
condition|(
operator|!
name|ttlv_valid
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n\tInvalid ForCES Top TLV type=0x%x"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"\t%s, length %d (data length %d Bytes)"
argument_list|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|type
argument_list|)
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
argument_list|)
expr_stmt|;
name|rc
operator|=
name|tops
operator|->
name|print
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tltlv
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
argument_list|,
name|tops
operator|->
name|op_msk
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|tltlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|tltlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|ttlv
operator|--
expr_stmt|;
if|if
condition|(
name|ttlv
operator|<=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * XXX - if ttlv != 0, does that mean that the packet was too 	 * short, and didn't have *enough* TLVs in it? 	 */
if|if
condition|(
name|rlen
condition|)
block|{
name|printf
argument_list|(
literal|"\tMess TopTLV header: min %u, total %d advertised %d "
argument_list|,
name|TLV_HDRL
argument_list|,
name|rlen
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|forces_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|forcesh
modifier|*
name|fhdr
decl_stmt|;
name|u_int
name|mlen
decl_stmt|;
name|u_int32_t
name|flg_raw
decl_stmt|;
specifier|const
name|struct
name|tom_h
modifier|*
name|tops
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|fhdr
operator|=
operator|(
specifier|const
expr|struct
name|forcesh
operator|*
operator|)
name|pptr
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|fhdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tom_valid
argument_list|(
name|fhdr
operator|->
name|fm_tom
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid ForCES message type %d\n"
argument_list|,
name|fhdr
operator|->
name|fm_tom
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mlen
operator|=
name|ForCES_BLN
argument_list|(
name|fhdr
argument_list|)
expr_stmt|;
name|tops
operator|=
name|get_forces_tom
argument_list|(
name|fhdr
operator|->
name|fm_tom
argument_list|)
expr_stmt|;
if|if
condition|(
name|tops
operator|->
name|v
operator|==
name|TOM_RSVD
condition|)
block|{
name|printf
argument_list|(
literal|"\n\tUnknown ForCES message type=0x%x"
argument_list|,
name|fhdr
operator|->
name|fm_tom
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|printf
argument_list|(
literal|"\n\tForCES %s "
argument_list|,
name|tops
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ForCES_HLN_VALID
argument_list|(
name|mlen
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal ForCES pkt len - min %u, total recvd %d, advertised %d "
argument_list|,
name|ForCES_HDRL
argument_list|,
name|len
argument_list|,
name|ForCES_BLN
argument_list|(
name|fhdr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|TCHECK2
argument_list|(
operator|*
operator|(
name|pptr
operator|+
literal|20
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|flg_raw
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|>=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n\tForCES Version %d len %uB flags 0x%08x "
argument_list|,
name|ForCES_V
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|mlen
argument_list|,
name|flg_raw
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tSrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%"
name|PRIx64
argument_list|,
name|ForCES_SID
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|ForCES_node
argument_list|(
name|ForCES_SID
argument_list|(
name|fhdr
argument_list|)
argument_list|)
argument_list|,
name|ForCES_DID
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|ForCES_node
argument_list|(
name|ForCES_DID
argument_list|(
name|fhdr
argument_list|)
argument_list|)
argument_list|,
name|EXTRACT_64BITS
argument_list|(
name|fhdr
operator|->
name|fm_cor
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n\tForCES flags:\n\t  %s(0x%x), prio=%d, %s(0x%x),\n\t  %s(0x%x), %s(0x%x)\n"
argument_list|,
name|ForCES_ACKp
argument_list|(
name|ForCES_ACK
argument_list|(
name|fhdr
argument_list|)
argument_list|)
argument_list|,
name|ForCES_ACK
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|ForCES_PRI
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|ForCES_EMp
argument_list|(
name|ForCES_EM
argument_list|(
name|fhdr
argument_list|)
argument_list|)
argument_list|,
name|ForCES_EM
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|ForCES_ATp
argument_list|(
name|ForCES_AT
argument_list|(
name|fhdr
argument_list|)
argument_list|)
argument_list|,
name|ForCES_AT
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|ForCES_TPp
argument_list|(
name|ForCES_TP
argument_list|(
name|fhdr
argument_list|)
argument_list|)
argument_list|,
name|ForCES_TP
argument_list|(
name|fhdr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x\n"
argument_list|,
name|ForCES_RS1
argument_list|(
name|fhdr
argument_list|)
argument_list|,
name|ForCES_RS2
argument_list|(
name|fhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|forces_type_print
argument_list|(
name|pptr
argument_list|,
name|fhdr
argument_list|,
name|mlen
argument_list|,
name|tops
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|error
label|:
name|hex_print_with_offset
argument_list|(
literal|"\n\t["
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vflag
operator|>=
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  Raw ForCES message\n\t ["
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
literal|"\n\t "
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t ]"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
name|trunc
label|:
name|fputs
argument_list|(
literal|"[|forces]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

