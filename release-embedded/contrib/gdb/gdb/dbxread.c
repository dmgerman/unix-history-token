begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read dbx symbol tables and convert to internal format, for GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004.    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module provides three functions: dbx_symfile_init,    which initializes to read a symbol file; dbx_new_init, which     discards existing cached information when all symbols are being    discarded; and dbx_symfile_read, which reads a symbol table    from a file.     dbx_symfile_read only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.  dbx_psymtab_to_symtab() is the function that does this */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGNUSCLIB__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for bfd stuff */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* FIXME Secret internal BFD stuff for a.out */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* Needed for local_hex_string */
end_comment

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* We always use GNU stabs, not native, now */
end_comment

begin_escape
end_escape

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.  */
end_comment

begin_struct
struct|struct
name|symloc
block|{
comment|/* Offset within the file symbol table of first local symbol for this        file.  */
name|int
name|ldsymoff
decl_stmt|;
comment|/* Length (in bytes) of the section of the symbol table devoted to        this file's symbols (actually, the section bracketed may contain        more than just this file's symbols).  If ldsymlen is 0, the only        reason for this thing's existence is the dependency list.  Nothing        else will happen when it is read in.  */
name|int
name|ldsymlen
decl_stmt|;
comment|/* The size of each symbol in the symbol file (in external form).  */
name|int
name|symbol_size
decl_stmt|;
comment|/* Further information needed to locate the symbols if they are in        an ELF file.  */
name|int
name|symbol_offset
decl_stmt|;
name|int
name|string_offset
decl_stmt|;
name|int
name|file_string_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LDSYMOFF
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymoff)
end_define

begin_define
define|#
directive|define
name|LDSYMLEN
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymlen)
end_define

begin_define
define|#
directive|define
name|SYMLOC
parameter_list|(
name|p
parameter_list|)
value|((struct symloc *)((p)->read_symtab_private))
end_define

begin_define
define|#
directive|define
name|SYMBOL_SIZE
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->symbol_size)
end_define

begin_define
define|#
directive|define
name|SYMBOL_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->symbol_offset)
end_define

begin_define
define|#
directive|define
name|STRING_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->string_offset)
end_define

begin_define
define|#
directive|define
name|FILE_STRING_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->file_string_offset)
end_define

begin_escape
end_escape

begin_comment
comment|/* Remember what we deduced to be the source language of this psymtab. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|psymtab_language
init|=
name|language_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The BFD for this file -- implicit parameter to next_symbol_text.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of each symbol in the symbol file (in external form).    This is set by dbx_symfile_read when building psymtabs, and by    dbx_psymtab_to_symtab when building symtabs.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|symbol_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset of the symbol table in the executable file. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|symbol_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset of the string table in the executable file. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For elf+stab executables, the n_strx field is not a simple index    into the string table.  Instead, each .o file has a base offset in    the string table, and the associated symbols contain offsets from    this base.  The following two variables contain the base offset for    the current and next .o files. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|file_string_table_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|next_file_string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* .o and NLM files contain unrelocated addresses which are based at    0.  When non-zero, this flag disables some of the special cases for    Solaris elf+stab text addresses at location 0. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symfile_relocatable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is nonzero, N_LBRAC, N_RBRAC, and N_SLINE entries are    relative to the function start address.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|block_address_function_relative
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The lowest text address we have yet encountered.  This is needed    because in an a.out file, there is no header field which tells us    what address the program is actually going to be loaded at, so we    need to make guesses based on the symbols (which *are* relocated to    reflect the address it will be loaded at).  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|lowest_text_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if there is any line number info in the objfile.  Prevents    end_psymtab from discarding an otherwise empty psymtab.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|has_line_numbers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complaints about the symbols we have encountered.  */
end_comment

begin_function
specifier|static
name|void
name|unknown_symtype_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unknown symbol type %s"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lbrac_mismatch_complaint
parameter_list|(
name|int
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|repeated_header_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"\"repeated\" header file %s not previously seen, at symtab pos %d"
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* find_text_range --- find start and end of loadable code sections     The find_text_range function finds the shortest address range that    encloses all sections containing executable code, and stores it in    objfile's text_addr and text_size members.     dbx_symfile_read will use this to finish off the partial symbol    table, in some cases.  */
end_comment

begin_function
specifier|static
name|void
name|find_text_range
parameter_list|(
name|bfd
modifier|*
name|sym_bfd
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|found_any
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|start
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|end
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|sym_bfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|sym_bfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
name|CORE_ADDR
name|sec_start
init|=
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|sec_end
init|=
name|sec_start
operator|+
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
name|found_any
condition|)
block|{
if|if
condition|(
name|sec_start
operator|<
name|start
condition|)
name|start
operator|=
name|sec_start
expr_stmt|;
if|if
condition|(
name|sec_end
operator|>
name|end
condition|)
name|end
operator|=
name|sec_end
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|sec_start
expr_stmt|;
name|end
operator|=
name|sec_end
expr_stmt|;
block|}
name|found_any
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_any
condition|)
name|error
argument_list|(
literal|"Can't find any code sections in symbol file"
argument_list|)
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|start
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|end
operator|-
name|start
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* During initial symbol readin, we need to have a structure to keep    track of which psymtabs have which bincls in them.  This structure    is used during readin to setup the list of dependencies within each    partial symbol table. */
end_comment

begin_struct
struct|struct
name|header_file_location
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of header file */
name|int
name|instance
decl_stmt|;
comment|/* See above */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* Partial symtab that has the 				   BINCL/EINCL defs for this file */
block|}
struct|;
end_struct

begin_comment
comment|/* The actual list and controling variables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|header_file_location
modifier|*
name|bincl_list
decl_stmt|,
modifier|*
name|next_bincl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bincls_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function prototypes */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_dbxread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_ofile_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbx_psymtab_to_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbx_psymtab_to_symtab_1
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_dbx_dynamic_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_dbx_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_bincl_list
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|partial_symtab
modifier|*
name|find_corresponding_bincl_psymtab
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_bincl_to_list
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_bincl_list
parameter_list|(
name|int
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dbx_next_symbol_text
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_symbuf
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbx_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbx_new_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbx_symfile_read
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbx_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_new_header_file
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_old_header_file
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_this_object_header_file
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|partial_symtab
modifier|*
name|start_psymtab
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Free up old header file tables */
end_comment

begin_function
name|void
name|free_header_files
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|this_object_header_files
condition|)
block|{
name|xfree
argument_list|(
name|this_object_header_files
argument_list|)
expr_stmt|;
name|this_object_header_files
operator|=
name|NULL
expr_stmt|;
block|}
name|n_allocated_this_object_header_files
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate new header file tables */
end_comment

begin_function
name|void
name|init_header_files
parameter_list|(
name|void
parameter_list|)
block|{
name|n_allocated_this_object_header_files
operator|=
literal|10
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add header file number I for this object file    at the next successive FILENUM.  */
end_comment

begin_function
specifier|static
name|void
name|add_this_object_header_file
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|n_this_object_header_files
operator|==
name|n_allocated_this_object_header_files
condition|)
block|{
name|n_allocated_this_object_header_files
operator|*=
literal|2
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|this_object_header_files
argument_list|,
name|n_allocated_this_object_header_files
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this_object_header_files
index|[
name|n_this_object_header_files
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file an "old" header file, one already seen in    a previous object file.  NAME is the header file's name.    INSTANCE is its instance code, to select among multiple    symbol tables for the same header file.  */
end_comment

begin_function
specifier|static
name|void
name|add_old_header_file
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|instance
parameter_list|)
block|{
name|struct
name|header_file
modifier|*
name|p
init|=
name|HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|instance
operator|==
name|p
index|[
name|i
index|]
operator|.
name|instance
condition|)
block|{
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|repeated_header_complaint
argument_list|(
name|name
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file a "new" header file: definitions for its types follow.    NAME is the header file's name.    Most often this happens only once for each distinct header file,    but not necessarily.  If it happens more than once, INSTANCE has    a different value each time, and references to the header file    use INSTANCE values to select among them.     dbx output contains "begin" and "end" markers for each new header file,    but at this level we just need to know which files there have been;    so we record the file when its "begin" is seen and ignore the "end".  */
end_comment

begin_function
specifier|static
name|void
name|add_new_header_file
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|header_file
modifier|*
name|hfile
decl_stmt|;
comment|/* Make sure there is room for one more header file.  */
name|i
operator|=
name|N_ALLOCATED_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|N_ALLOCATED_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|=
literal|10
expr_stmt|;
name|HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|*=
literal|2
expr_stmt|;
name|N_ALLOCATED_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|=
name|i
expr_stmt|;
name|HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
argument_list|,
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create an entry for this header file.  */
name|i
operator|=
name|N_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|++
expr_stmt|;
name|hfile
operator|=
name|HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|+
name|i
expr_stmt|;
name|hfile
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|hfile
operator|->
name|instance
operator|=
name|instance
expr_stmt|;
name|hfile
operator|->
name|length
operator|=
literal|10
expr_stmt|;
name|hfile
operator|->
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hfile
operator|->
name|vector
argument_list|,
literal|0
argument_list|,
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type ** explicit_lookup_type (int real_filenum, int index) {   struct header_file *f =&HEADER_FILES (current_objfile)[real_filenum];    if (index>= f->length)     {       f->length *= 2;       f->vector = (struct type **) 	xrealloc (f->vector, f->length * sizeof (struct type *));       memset (&f->vector[f->length / 2], 	      '\0', f->length * sizeof (struct type *) / 2);     }   return&f->vector[index]; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|int
name|section
decl_stmt|;
name|asection
modifier|*
name|bfd_section
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_text
expr_stmt|;
name|section
operator|=
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_TEXT_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
name|section
operator|=
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_DATA_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
name|section
operator|=
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_BSS_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
name|section
operator|=
operator|-
literal|1
expr_stmt|;
name|bfd_section
operator|=
name|NULL
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|N_SETV
case|case
name|N_SETV
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
name|section
operator|=
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_DATA_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SETV
case|:
comment|/* I don't think this type actually exists; since a N_SETV is the result          of going over many .o files, it doesn't make sense to have one          file local.  */
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
name|section
operator|=
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_DATA_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|N_TEXT
case|:
case|case
name|N_NBTEXT
case|:
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|section
operator|=
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_TEXT_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
comment|/* Check for __DYNAMIC, which is used by Sun shared libraries.           Record it as global even if it's local, not global, so          lookup_minimal_symbol can find it.  We don't check symbol_leading_char          because for SunOS4 it always is '_'.  */
if|if
condition|(
name|name
index|[
literal|8
index|]
operator|==
literal|'C'
operator|&&
name|DEPRECATED_STREQ
argument_list|(
literal|"__DYNAMIC"
argument_list|,
name|name
argument_list|)
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
comment|/* Same with virtual function tables, both global and static.  */
block|{
name|char
modifier|*
name|tempstring
init|=
name|name
decl_stmt|;
if|if
condition|(
name|tempstring
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
operator|++
name|tempstring
expr_stmt|;
if|if
condition|(
name|is_vtable_name
argument_list|(
name|tempstring
argument_list|)
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
block|}
name|section
operator|=
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_DATA_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|ms_type
operator|=
name|mst_file_bss
expr_stmt|;
name|section
operator|=
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_section
operator|=
name|DBX_BSS_SECTION
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
name|section
operator|=
operator|-
literal|1
expr_stmt|;
name|bfd_section
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ms_type
operator|==
name|mst_file_text
operator|||
name|ms_type
operator|==
name|mst_text
operator|)
operator|&&
name|address
operator|<
name|lowest_text_address
condition|)
name|lowest_text_address
operator|=
name|address
expr_stmt|;
name|prim_record_minimal_symbol_and_info
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|,
name|NULL
argument_list|,
name|section
argument_list|,
name|bfd_section
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to dbx_symfile_init, which     put all the relevant info into a "struct dbx_symfile_info",    hung off the objfile structure.     MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).  */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_read
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|)
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|sym_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* .o and .nlm files are relocatables with text, data and bss segs based at      0.  This flag disables special (Solaris stabs-in-elf only) fixups for      symbols with a value of 0.  */
name|symfile_relocatable
operator|=
name|bfd_get_file_flags
argument_list|(
name|sym_bfd
argument_list|)
operator|&
name|HAS_RELOC
expr_stmt|;
comment|/* This is true for Solaris (and all other systems which put stabs      in sections, hopefully, since it would be silly to do things      differently from Solaris), and false for SunOS4 and other a.out      file formats.  */
name|block_address_function_relative
operator|=
operator|(
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|sym_bfd
argument_list|)
argument_list|,
literal|"elf"
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|sym_bfd
argument_list|)
argument_list|,
literal|"som"
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|sym_bfd
argument_list|)
argument_list|,
literal|"coff"
argument_list|,
literal|4
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|sym_bfd
argument_list|)
argument_list|,
literal|"pe"
argument_list|,
literal|2
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|sym_bfd
argument_list|)
argument_list|,
literal|"epoc-pe"
argument_list|,
literal|7
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|sym_bfd
argument_list|)
argument_list|,
literal|"nlm"
argument_list|,
literal|3
argument_list|)
operator|)
operator|)
expr_stmt|;
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If we are reinitializing, or if we have never loaded syms yet, init */
if|if
condition|(
name|mainline
operator|||
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|&&
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
operator|)
condition|)
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_size
operator|=
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|symbol_table_offset
operator|=
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|free_pending_blocks
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup_discard_minimal_symbols
argument_list|()
expr_stmt|;
comment|/* Read stabs data from executable file and define symbols. */
name|read_dbx_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Add the dynamic symbols.  */
name|read_dbx_dynamic_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
specifier|static
name|void
name|dbx_new_init
parameter_list|(
name|struct
name|objfile
modifier|*
name|ignore
parameter_list|)
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dbx_symfile_init ()    is the dbx-specific initialization routine for reading symbols.    It is passed a struct objfile which contains, among other things,    the BFD for the file whose symbols are being read, and a slot for a pointer    to "private data" which we fill with goodies.     We read the string table into malloc'd space and stash a pointer to it.     Since BFD doesn't know how to read debug symbols in a format-independent    way (and may never do so...), we have to do it ourselves.  We will never    be called unless this is an a.out (or very similar) file.     FIXME, there should be a cleaner peephole into the BFD environment here.  */
end_comment

begin_define
define|#
directive|define
name|DBX_STRINGTAB_SIZE_SIZE
value|sizeof(long)
end_define

begin_comment
comment|/* FIXME */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|;
name|unsigned
name|char
name|size_temp
index|[
name|DBX_STRINGTAB_SIZE_SIZE
index|]
decl_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|sym_stab_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|DBX_TEXT_SECTION
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|DBX_DATA_SECTION
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|DBX_BSS_SECTION
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
comment|/* FIXME POKING INSIDE BFD DATA STRUCTURES */
define|#
directive|define
name|STRING_TABLE_OFFSET
value|(sym_bfd->origin + obj_str_filepos (sym_bfd))
define|#
directive|define
name|SYMBOL_TABLE_OFFSET
value|(sym_bfd->origin + obj_sym_filepos (sym_bfd))
comment|/* FIXME POKING INSIDE BFD DATA STRUCTURES */
name|DBX_SYMFILE_INFO
argument_list|(
name|objfile
argument_list|)
operator|->
name|stab_section_info
operator|=
name|NULL
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_sect
condition|)
name|error
argument_list|(
literal|"Can't find .text section in symbol file"
argument_list|)
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|obj_symbol_entry_size
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_symcount
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|SYMBOL_TABLE_OFFSET
expr_stmt|;
comment|/* Read the string table and stash it away in the objfile_obstack.      When we blow away the objfile the string table goes away as well.      Note that gdb used to use the results of attempting to malloc the      string table, based on the size it read, as a form of sanity check      for botched byte swapping, on the theory that a byte swapped string      table size would be so totally bogus that the malloc would fail.  Now      that we put in on the objfile_obstack, we can't do this since gdb gets      a fatal error (out of virtual memory) if the size is bogus.  We can      however at least check to see if the size is less than the size of      the size field itself, or larger than the size of the entire file.      Note that all valid string tables have a size greater than zero, since      the bytes used to hold the size are included in the count. */
if|if
condition|(
name|STRING_TABLE_OFFSET
operator|==
literal|0
condition|)
block|{
comment|/* It appears that with the existing bfd code, STRING_TABLE_OFFSET          will never be zero, even when there is no string table.  This          would appear to be a bug in bfd. */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|size_temp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|size_temp
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
name|size_temp
argument_list|,
sizeof|sizeof
argument_list|(
name|size_temp
argument_list|)
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/* With the existing bfd code, STRING_TABLE_OFFSET will be set to 	     EOF if there is no string table, and attempting to read the size 	     from EOF will read zero bytes. */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Read some data that would appear to be the string table size. 	     If there really is a string table, then it is probably the right 	     size.  Byteswap if necessary and validate the size.  Note that 	     the minimum is DBX_STRINGTAB_SIZE_SIZE.  If we just read some 	     random data that happened to be at STRING_TABLE_OFFSET, because 	     bfd can't tell us there is no string table, the sanity checks may 	     or may not catch this. */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_h_get_32
argument_list|(
name|sym_bfd
argument_list|,
name|size_temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|size_temp
argument_list|)
operator|||
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size (%d bytes)."
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_stab_info
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|HEADER_FILES
argument_list|(
name|objfile
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
init|=
name|N_HEADER_FILES
argument_list|(
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|header_file
modifier|*
name|hfiles
init|=
name|HEADER_FILES
argument_list|(
name|objfile
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|hfiles
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|hfiles
index|[
name|i
index|]
operator|.
name|vector
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|hfiles
argument_list|)
expr_stmt|;
block|}
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_stab_info
argument_list|)
expr_stmt|;
block|}
name|free_header_files
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Buffer for reading the symbol table entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|external_nlist
name|symbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of last function encountered.  Used in Solaris to approximate    object file boundaries.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address in memory of the string table of the object file we are    reading (which might not be the "main" object file, but might be a    shared library or some other dynamically loaded thing).  This is    set by read_dbx_symtab when building psymtabs, and by    read_ofile_symtab when building symtabs, and is used only by    next_symbol_text.  FIXME: If that is true, we don't need it when    building psymtabs, right?  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stringtab_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are used to control fill_symbuf when the stabs    symbols are not contiguous (as may be the case when a COFF file is    linked using --split-by-reloc).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stab_section_list
modifier|*
name|symbuf_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|symbuf_left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|symbuf_read
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable stores a global stabs buffer, if we read stabs into    memory in one chunk in order to process relocations.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|stabs_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Refill the symbol table input buffer    and set the variables that control fetching entries from it.    Reports an error if no data available.    This function can read past the end of the symbol table    (into the string table) but this does no harm.  */
end_comment

begin_function
specifier|static
name|void
name|fill_symbuf
parameter_list|(
name|bfd
modifier|*
name|sym_bfd
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|stabs_data
condition|)
block|{
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|symbuf_left
condition|)
name|nbytes
operator|=
name|symbuf_left
expr_stmt|;
name|memcpy
argument_list|(
name|symbuf
argument_list|,
name|stabs_data
operator|+
name|symbuf_read
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbuf_sections
operator|==
name|NULL
condition|)
block|{
name|count
operator|=
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|bfd_bread
argument_list|(
name|symbuf
argument_list|,
name|count
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|symbuf_left
operator|<=
literal|0
condition|)
block|{
name|file_ptr
name|filepos
init|=
name|symbuf_sections
operator|->
name|section
operator|->
name|filepos
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|symbuf_left
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|symbuf_sections
operator|->
name|section
argument_list|)
expr_stmt|;
name|symbol_table_offset
operator|=
name|filepos
operator|-
name|symbuf_read
expr_stmt|;
name|symbuf_sections
operator|=
name|symbuf_sections
operator|->
name|next
expr_stmt|;
block|}
name|count
operator|=
name|symbuf_left
expr_stmt|;
if|if
condition|(
name|count
operator|>
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
condition|)
name|count
operator|=
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|bfd_bread
argument_list|(
name|symbuf
argument_list|,
name|count
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Premature end of file reading symbol table"
argument_list|)
expr_stmt|;
name|symbuf_end
operator|=
name|nbytes
operator|/
name|symbol_size
expr_stmt|;
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
name|symbuf_left
operator|-=
name|nbytes
expr_stmt|;
name|symbuf_read
operator|+=
name|nbytes
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stabs_seek
parameter_list|(
name|int
name|sym_offset
parameter_list|)
block|{
if|if
condition|(
name|stabs_data
condition|)
block|{
name|symbuf_read
operator|+=
name|sym_offset
expr_stmt|;
name|symbuf_left
operator|-=
name|sym_offset
expr_stmt|;
block|}
else|else
name|bfd_seek
argument_list|(
name|symfile_bfd
argument_list|,
name|sym_offset
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|INTERNALIZE_SYMBOL
parameter_list|(
name|intern
parameter_list|,
specifier|extern
parameter_list|,
name|abfd
parameter_list|)
define|\
value|{									\     (intern).n_type = bfd_h_get_8 (abfd, (extern)->e_type);		\     (intern).n_strx = bfd_h_get_32 (abfd, (extern)->e_strx);		\     (intern).n_desc = bfd_h_get_16 (abfd, (extern)->e_desc);  		\     if (bfd_get_sign_extend_vma (abfd))					\       (intern).n_value = bfd_h_get_signed_32 (abfd, (extern)->e_value);	\     else								\       (intern).n_value = bfd_h_get_32 (abfd, (extern)->e_value);	\   }
end_define

begin_comment
comment|/* Invariant: The symbol pointed to by symbuf_idx is the first one    that hasn't been swapped.  Swap the symbol at the same time    that symbuf_idx is incremented.  */
end_comment

begin_comment
comment|/* dbx allows the text of a symbol name to be continued into the    next symbol name!  When such a continuation is encountered    (a \ at the end of the text of a name)    call this function to get the continuation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dbx_next_symbol_text
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|internal_nlist
name|nlist
decl_stmt|;
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|symfile_bfd
argument_list|)
expr_stmt|;
name|symnum
operator|++
expr_stmt|;
name|INTERNALIZE_SYMBOL
argument_list|(
name|nlist
argument_list|,
operator|&
name|symbuf
index|[
name|symbuf_idx
index|]
argument_list|,
name|symfile_bfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
name|symbuf_idx
operator|++
expr_stmt|;
return|return
name|nlist
operator|.
name|n_strx
operator|+
name|stringtab_global
operator|+
name|file_string_table_offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the list of bincls to contain none and have some    allocated.  */
end_comment

begin_function
specifier|static
name|void
name|init_bincl_list
parameter_list|(
name|int
name|number
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|bincls_allocated
operator|=
name|number
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a bincl to the list.  */
end_comment

begin_function
specifier|static
name|void
name|add_bincl_to_list
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|instance
parameter_list|)
block|{
if|if
condition|(
name|next_bincl
operator|>=
name|bincl_list
operator|+
name|bincls_allocated
condition|)
block|{
name|int
name|offset
init|=
name|next_bincl
operator|-
name|bincl_list
decl_stmt|;
name|bincls_allocated
operator|*=
literal|2
expr_stmt|;
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xmrealloc
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bincl_list
argument_list|,
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|+
name|offset
expr_stmt|;
block|}
name|next_bincl
operator|->
name|pst
operator|=
name|pst
expr_stmt|;
name|next_bincl
operator|->
name|instance
operator|=
name|instance
expr_stmt|;
name|next_bincl
operator|++
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a name, value pair, find the corresponding    bincl in the list.  Return the partial symtab associated    with that header_file_location.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|find_corresponding_bincl_psymtab
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|instance
parameter_list|)
block|{
name|struct
name|header_file_location
modifier|*
name|bincl
decl_stmt|;
for|for
control|(
name|bincl
operator|=
name|bincl_list
init|;
name|bincl
operator|<
name|next_bincl
condition|;
name|bincl
operator|++
control|)
if|if
condition|(
name|bincl
operator|->
name|instance
operator|==
name|instance
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|bincl
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bincl
operator|->
name|pst
return|;
name|repeated_header_complaint
argument_list|(
name|name
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free the storage allocated for the bincl list.  */
end_comment

begin_function
specifier|static
name|void
name|free_bincl_list
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|bincl_list
argument_list|)
expr_stmt|;
name|bincls_allocated
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_bincl_list_cleanup
parameter_list|(
name|void
modifier|*
name|objfile
parameter_list|)
block|{
name|free_bincl_list
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_bincl_list
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_bincl_list_cleanup
argument_list|,
name|objfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set namestring based on nlist.  If the string table index is invalid,     give a fake name, and print a single error message per symbol file read,    rather than abort the symbol reading or flood the user with messages.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|set_namestring
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|internal_nlist
name|nlist
parameter_list|)
block|{
name|char
modifier|*
name|namestring
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|nlist
operator|.
name|n_strx
operator|+
name|file_string_table_offset
operator|)
operator|>=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"bad string table offset in symbol %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|namestring
operator|=
literal|"<bad string table offset>"
expr_stmt|;
block|}
else|else
name|namestring
operator|=
name|nlist
operator|.
name|n_strx
operator|+
name|file_string_table_offset
operator|+
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
return|return
name|namestring
return|;
block|}
end_function

begin_comment
comment|/* Scan a SunOs dynamic symbol table for symbols of interest and    add them to the minimal symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|read_dbx_dynamic_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|long
name|dynsym_size
decl_stmt|;
name|long
name|dynsym_count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|dynsyms
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symptr
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|long
name|dynrel_size
decl_stmt|;
name|long
name|dynrel_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|dynrels
decl_stmt|;
name|CORE_ADDR
name|sym_value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Check that the symbol file has dynamic symbols that we know about.      bfd_arch_unknown can happen if we are reading a sun3 symbol file      on a sun4 host (and vice versa) and bfd is not configured      --with-target=all.  This would trigger an assertion in bfd/sunos.c,      so we ignore the dynamic symbols in this case.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_aout_flavour
operator|||
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_arch_unknown
condition|)
return|return;
name|dynsym_size
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsym_size
operator|<
literal|0
condition|)
return|return;
name|dynsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dynsym_size
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
name|dynsym_count
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsym_count
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Enter dynamic symbols into the minimal symbol table      if this is a stripped executable.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|symptr
operator|=
name|dynsyms
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|dynsym_count
condition|;
name|counter
operator|++
operator|,
name|symptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
operator|*
name|symptr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|type
decl_stmt|;
name|sec
operator|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* BFD symbols are section relative.  */
name|sym_value
operator|=
name|sym
operator|->
name|value
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|N_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DATA
condition|)
block|{
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|N_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
block|{
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|N_BSS
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|type
operator||=
name|N_EXT
expr_stmt|;
name|record_minimal_symbol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sym_value
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Symbols from shared libraries have a dynamic relocation entry      that points to the associated slot in the procedure linkage table.      We make a mininal symbol table entry with type mst_solib_trampoline      at the address in the procedure linkage table.  */
name|dynrel_size
operator|=
name|bfd_get_dynamic_reloc_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynrel_size
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return;
block|}
name|dynrels
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dynrel_size
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|dynrels
argument_list|)
expr_stmt|;
name|dynrel_count
operator|=
name|bfd_canonicalize_dynamic_reloc
argument_list|(
name|abfd
argument_list|,
name|dynrels
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynrel_count
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|counter
operator|=
literal|0
operator|,
name|relptr
operator|=
name|dynrels
init|;
name|counter
operator|<
name|dynrel_count
condition|;
name|counter
operator|++
operator|,
name|relptr
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
init|=
operator|*
name|relptr
decl_stmt|;
name|CORE_ADDR
name|address
init|=
name|rel
operator|->
name|address
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
if|if
condition|(
name|rel
operator|->
name|howto
operator|->
name|type
operator|!=
name|RELOC_JMP_SLOT
condition|)
continue|continue;
break|break;
case|case
name|bfd_arch_m68k
case|:
comment|/* `16' is the type BFD produces for a jump table relocation.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|->
name|type
operator|!=
literal|16
condition|)
continue|continue;
comment|/* Adjust address in the jump table to point to 	     the start of the bsr instruction.  */
name|address
operator|-=
literal|2
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_asymbol_name
argument_list|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|mst_solib_trampoline
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
end_ifdef

begin_function
specifier|static
name|CORE_ADDR
name|find_stab_function_addr
parameter_list|(
name|char
modifier|*
name|namestring
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|namestring
expr_stmt|;
name|n
operator|=
name|p
operator|-
name|namestring
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|namestring
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
block|{
comment|/* Sun Fortran appends an underscore to the minimal symbol name,          try again with an appended underscore if the minimal symbol          was not found.  */
name|p
index|[
name|n
index|]
operator|=
literal|'_'
expr_stmt|;
name|p
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msym
operator|==
name|NULL
operator|&&
name|filename
operator|!=
name|NULL
condition|)
block|{
comment|/* Try again without the filename. */
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msym
operator|==
name|NULL
operator|&&
name|filename
operator|!=
name|NULL
condition|)
block|{
comment|/* And try again for Sun Fortran, but without the filename. */
name|p
index|[
name|n
index|]
operator|=
literal|'_'
expr_stmt|;
name|p
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
return|return
name|msym
operator|==
name|NULL
condition|?
literal|0
else|:
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOFUN_ADDRESS_MAYBE_MISSING */
end_comment

begin_function
specifier|static
name|void
name|function_outside_compilation_unit_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"function `%s' appears to be defined outside of all compilation units"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Setup partial_symtab's describing each source file for which    debugging information is available. */
end_comment

begin_function
specifier|static
name|void
name|read_dbx_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|external_nlist
modifier|*
name|bufp
init|=
literal|0
decl_stmt|;
comment|/* =0 avoids gcc -Wall glitch */
name|struct
name|internal_nlist
name|nlist
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|int
name|text_size
decl_stmt|;
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
name|nsl
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|last_o_file_start
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|last_function_start
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|textlow_not_set
decl_stmt|;
name|int
name|data_sect_index
decl_stmt|;
comment|/* Current partial symtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
name|text_addr
operator|=
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|text_size
operator|=
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME.  We probably want to change stringtab_global rather than add this      while processing every symbol entry.  FIXME.  */
name|file_string_table_offset
operator|=
literal|0
expr_stmt|;
name|next_file_string_table_offset
operator|=
literal|0
expr_stmt|;
name|stringtab_global
operator|=
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init bincl list */
name|init_bincl_list
argument_list|(
literal|20
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup_free_bincl_list
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|lowest_text_address
operator|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
expr_stmt|;
name|symfile_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* For next_text_symbol */
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
name|next_symbol_text_func
operator|=
name|dbx_next_symbol_text
expr_stmt|;
name|textlow_not_set
operator|=
literal|1
expr_stmt|;
name|has_line_numbers
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: jimb/2003-09-12: We don't apply the right section's offset      to global and static variables.  The stab for a global or static      variable doesn't give us any indication of which section it's in,      so we can't tell immediately which offset in      objfile->section_offsets we should apply to the variable's      address.       We could certainly find out which section contains the variable      by looking up the variable's unrelocated address with      find_pc_section, but that would be expensive; this is the      function that constructs the partial symbol tables by examining      every symbol in the entire executable, and it's      performance-critical.  So that expense would not be welcome.  I'm      not sure what to do about this at the moment.       What we have done for years is to simply assume that the .data      section's offset is appropriate for all global and static      variables.  Recently, this was expanded to fall back to the .bss      section's offset if there is no .data section, and then to the      .rodata section's offset.  */
name|data_sect_index
operator|=
name|objfile
operator|->
name|sect_index_data
expr_stmt|;
if|if
condition|(
name|data_sect_index
operator|==
operator|-
literal|1
condition|)
name|data_sect_index
operator|=
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_sect_index
operator|==
operator|-
literal|1
condition|)
name|data_sect_index
operator|=
name|SECT_OFF_RODATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* If data_sect_index is still -1, that's okay.  It's perfectly fine      for the file to have no .data, no .bss, and no .text at all, if      it also has no global or static variables.  If it does, we will      get an internal error from an ANOFFSET macro below when we try to      use data_sect_index.  */
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|;
name|symnum
operator|++
control|)
block|{
comment|/* Get the symbol for this run and pull out some info */
name|QUIT
expr_stmt|;
comment|/* allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
comment|/*        * Special case to speed up readin.        */
if|if
condition|(
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|bufp
operator|->
name|e_type
argument_list|)
operator|==
name|N_SLINE
condition|)
block|{
name|has_line_numbers
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|INTERNALIZE_SYMBOL
argument_list|(
name|nlist
argument_list|,
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
comment|/* Ok.  There is a lot of code duplicated in the rest of this          switch statement (for efficiency reasons).  Since I don't          like duplicating code, I will do my penance here, and          describe the code which is duplicated:           *) The assignment to namestring.          *) The call to strchr.          *) The addition of a partial symbol the the two partial          symbol lists.  This last is a large section of code, so          I've imbedded it in the following macro.       */
switch|switch
condition|(
name|nlist
operator|.
name|n_type
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	   * Standard, external, non-debugger, symbols 	   */
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
case|case
name|N_NBTEXT
operator||
name|N_EXT
case|:
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
case|case
name|N_NBDATA
operator||
name|N_EXT
case|:
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
case|case
name|N_NBBSS
operator||
name|N_EXT
case|:
case|case
name|N_SETV
operator||
name|N_EXT
case|:
comment|/* FIXME, is this in BSS? */
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|record_it
label|:
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
name|bss_ext_symbol
label|:
name|record_minimal_symbol
argument_list|(
name|namestring
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
name|nlist
operator|.
name|n_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Always */
continue|continue;
comment|/* Standard, local, non-debugger, symbols */
case|case
name|N_NBTEXT
case|:
comment|/* We need to be able to deal with both N_FN or N_TEXT, 	     because we have no way of knowing whether the sys-supplied ld 	     or GNU ld was used to make the executable.  Sequents throw 	     in another wrinkle -- they renumbered N_FN.  */
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
case|case
name|N_TEXT
case|:
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|namestring
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|namestring
index|[
literal|1
index|]
operator|==
literal|'l'
operator|)
operator|||
operator|(
name|namestring
index|[
operator|(
name|nsl
operator|=
name|strlen
argument_list|(
name|namestring
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|namestring
index|[
name|nsl
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|nlist
operator|.
name|n_value
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_lowpc
operator|=
name|last_o_file_start
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_highpc
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|past_first_source_file
operator|&&
name|pst
comment|/* The gould NP1 uses low values for .o and -l symbols 		   which are not the address.  */
operator|&&
name|nlist
operator|.
name|n_value
operator|>=
name|pst
operator|->
name|textlow
condition|)
block|{
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|nlist
operator|.
name|n_value
operator|>
name|pst
operator|->
name|texthigh
condition|?
name|nlist
operator|.
name|n_value
else|:
name|pst
operator|->
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|textlow_not_set
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|last_o_file_start
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
block|}
else|else
goto|goto
name|record_it
goto|;
continue|continue;
case|case
name|N_DATA
case|:
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
if|if
condition|(
name|nlist
operator|.
name|n_value
operator|!=
literal|0
condition|)
block|{
comment|/* This is a "Fortran COMMON" symbol.  See if the target 	       environment knows where it has been relocated to.  */
name|CORE_ADDR
name|reladdr
decl_stmt|;
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_lookup_symbol
argument_list|(
name|namestring
argument_list|,
operator|&
name|reladdr
argument_list|)
condition|)
block|{
continue|continue;
comment|/* Error in lookup; ignore symbol for now.  */
block|}
name|nlist
operator|.
name|n_type
operator|^=
operator|(
name|N_BSS
operator|^
name|N_UNDF
operator|)
expr_stmt|;
comment|/* Define it as a bss-symbol */
name|nlist
operator|.
name|n_value
operator|=
name|reladdr
expr_stmt|;
goto|goto
name|bss_ext_symbol
goto|;
block|}
continue|continue;
comment|/* Just undefined, not COMMON */
case|case
name|N_UNDF
case|:
if|if
condition|(
name|processing_acc_compilation
operator|&&
name|nlist
operator|.
name|n_strx
operator|==
literal|1
condition|)
block|{
comment|/* Deal with relative offsets in the string table 	       used in ELF+STAB under Solaris.  If we want to use the 	       n_strx field, which contains the name of the file, 	       we must adjust file_string_table_offset *before* calling 	       set_namestring().  */
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|file_string_table_offset
operator|=
name|next_file_string_table_offset
expr_stmt|;
name|next_file_string_table_offset
operator|=
name|file_string_table_offset
operator|+
name|nlist
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|next_file_string_table_offset
operator|<
name|file_string_table_offset
condition|)
name|error
argument_list|(
literal|"string table offset backs up at %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
comment|/* FIXME -- replace error() with complaint.  */
continue|continue;
block|}
continue|continue;
comment|/* Lots of symbol types we can just ignore.  */
case|case
name|N_ABS
case|:
case|case
name|N_NBDATA
case|:
case|case
name|N_NBBSS
case|:
continue|continue;
comment|/* Keep going . . . */
comment|/* 	   * Special symbol types for GNU 	   */
case|case
name|N_INDR
case|:
case|case
name|N_INDR
operator||
name|N_EXT
case|:
case|case
name|N_SETA
case|:
case|case
name|N_SETA
operator||
name|N_EXT
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETT
operator||
name|N_EXT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETD
operator||
name|N_EXT
case|:
case|case
name|N_SETB
case|:
case|case
name|N_SETB
operator||
name|N_EXT
case|:
case|case
name|N_SETV
case|:
continue|continue;
comment|/* 	   * Debugger symbols 	   */
case|case
name|N_SO
case|:
block|{
name|CORE_ADDR
name|valu
decl_stmt|;
specifier|static
name|int
name|prev_so_symnum
init|=
operator|-
literal|10
decl_stmt|;
specifier|static
name|int
name|first_so_symnum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|prev_textlow_not_set
decl_stmt|;
name|valu
operator|=
name|nlist
operator|.
name|n_value
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|prev_textlow_not_set
operator|=
name|textlow_not_set
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* A zero value is probably an indication for the SunPRO 3.0 	       compiler. end_psymtab explicitly tests for zero, so 	       don't relocate it.  */
if|if
condition|(
name|nlist
operator|.
name|n_value
operator|==
literal|0
condition|)
block|{
name|textlow_not_set
operator|=
literal|1
expr_stmt|;
name|valu
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prev_so_symnum
operator|!=
name|symnum
operator|-
literal|1
condition|)
block|{
comment|/* Here if prev stab wasn't N_SO */
name|first_so_symnum
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
name|pst
condition|)
block|{
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|valu
operator|>
name|pst
operator|->
name|texthigh
condition|?
name|valu
else|:
name|pst
operator|->
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|prev_textlow_not_set
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|prev_so_symnum
operator|=
name|symnum
expr_stmt|;
comment|/* End the current partial symtab and start a new one */
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
comment|/* Null name means end of .o file.  Don't start a new one. */
if|if
condition|(
operator|*
name|namestring
operator|==
literal|'\000'
condition|)
continue|continue;
comment|/* Some compilers (including gcc) emit a pair of initial N_SOs. 	       The first one is a directory name; the second the file name. 	       If pst exists, is empty, and has a filename ending in '/', 	       we assume the previous N_SO was a directory name. */
name|p
operator|=
name|strrchr
argument_list|(
name|namestring
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\000'
condition|)
continue|continue;
comment|/* Simply ignore directory name SOs */
comment|/* Some other compilers (C++ ones in particular) emit useless 	       SOs for non-existant .c files.  We ignore all subsequent SOs that 	       immediately follow the first.  */
if|if
condition|(
operator|!
name|pst
condition|)
name|pst
operator|=
name|start_psymtab
argument_list|(
name|objfile
argument_list|,
name|namestring
argument_list|,
name|valu
argument_list|,
name|first_so_symnum
operator|*
name|symbol_size
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|N_BINCL
case|:
block|{
name|enum
name|language
name|tmp_language
decl_stmt|;
comment|/* Add this bincl to the bincl_list for future EXCLs.  No 	       need to save the string; it'll be around until 	       read_dbx_symtab function returns */
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
name|tmp_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
comment|/* Only change the psymtab's language if we've learned 	       something useful (eg. tmp_language is not language_unknown). 	       In addition, to match what start_subfile does, never change 	       from C++ to C.  */
if|if
condition|(
name|tmp_language
operator|!=
name|language_unknown
operator|&&
operator|(
name|tmp_language
operator|!=
name|language_c
operator|||
name|psymtab_language
operator|!=
name|language_cplus
operator|)
condition|)
name|psymtab_language
operator|=
name|tmp_language
expr_stmt|;
if|if
condition|(
name|pst
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: we should not get here without a PST to work on. 		 Attempt to recover.  */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"N_BINCL %s not in entries for any file, at symtab pos %d"
argument_list|,
name|namestring
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|add_bincl_to_list
argument_list|(
name|pst
argument_list|,
name|namestring
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|)
expr_stmt|;
comment|/* Mark down an include file in the current psymtab */
goto|goto
name|record_include_file
goto|;
block|}
case|case
name|N_SOL
case|:
block|{
name|enum
name|language
name|tmp_language
decl_stmt|;
comment|/* Mark down an include file in the current psymtab */
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
name|tmp_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
comment|/* Only change the psymtab's language if we've learned 	       something useful (eg. tmp_language is not language_unknown). 	       In addition, to match what start_subfile does, never change 	       from C++ to C.  */
if|if
condition|(
name|tmp_language
operator|!=
name|language_unknown
operator|&&
operator|(
name|tmp_language
operator|!=
name|language_c
operator|||
name|psymtab_language
operator|!=
name|language_cplus
operator|)
condition|)
name|psymtab_language
operator|=
name|tmp_language
expr_stmt|;
comment|/* In C++, one may expect the same filename to come round many 	       times, when code is coming alternately from the main file 	       and from inline functions in other files. So I check to see 	       if this is a file we've seen before -- either the main 	       source file, or a previously included file.  	       This seems to be a lot of time to be spending on N_SOL, but 	       things like "break c-exp.y:435" need to work (I 	       suppose the psymtab_include_list could be hashed or put 	       in a binary tree, if profiling shows this is a major hog).  */
if|if
condition|(
name|pst
operator|&&
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|includes_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|psymtab_include_list
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
continue|continue;
block|}
name|record_include_file
label|:
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|psymtab_include_list
argument_list|,
name|orig
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
case|case
name|N_LSYM
case|:
comment|/* Typedef or automatic variable. */
case|case
name|N_STSYM
case|:
comment|/* Data seg var -- static  */
case|case
name|N_LCSYM
case|:
comment|/* BSS      "  */
case|case
name|N_ROSYM
case|:
comment|/* Read-only data seg var -- static.  */
case|case
name|N_NBSTS
case|:
comment|/* Gould nobase.  */
case|case
name|N_NBLCS
case|:
comment|/* symbols.  */
case|case
name|N_FUN
case|:
case|case
name|N_GSYM
case|:
comment|/* Global (extern) variable; can be 					   data or bss (sigh FIXME).  */
comment|/* Following may probably be ignored; I'll leave them here 	     for now (until I do Pascal and Modula 2 extensions).  */
case|case
name|N_PC
case|:
comment|/* I may or may not need this; I 					   suspect not.  */
case|case
name|N_M2C
case|:
comment|/* I suspect that I can ignore this here. */
case|case
name|N_SCOPE
case|:
comment|/* Same.   */
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
comment|/* See if this is an end of function stab.  */
if|if
condition|(
name|pst
operator|&&
name|nlist
operator|.
name|n_type
operator|==
name|N_FUN
operator|&&
operator|*
name|namestring
operator|==
literal|'\000'
condition|)
block|{
name|CORE_ADDR
name|valu
decl_stmt|;
comment|/* It's value is the size (in bytes) of the function for 	       function relative stabs, or the address of the function's 	       end for old style stabs.  */
name|valu
operator|=
name|nlist
operator|.
name|n_value
operator|+
name|last_function_start
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|texthigh
operator|==
literal|0
operator|||
name|valu
operator|>
name|pst
operator|->
name|texthigh
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|valu
expr_stmt|;
break|break;
block|}
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
comment|/* Not a debugging symbol.   */
comment|/* Main processing section for debugging symbols which 	     the initial read through the symbol tables needs to worry 	     about.  If we reach this point, the symbol which we are 	     considering is definitely one we are interested in. 	     p must also contain the (valid) index into the namestring 	     which indicates the debugging type symbol.  */
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'S'
case|:
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|data_sect_index
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
name|namestring
operator|=
name|STATIC_TRANSFORM_NAME
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'G'
case|:
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|data_sect_index
argument_list|)
expr_stmt|;
comment|/* The addresses in these entries are reported to be 	       wrong.  See the code that reads 'G's for symtabs. */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* When a 'T' entry is defining an anonymous enum, it 	       may have a name which is the empty string, or a 	       single space.  Since they're not really defining a 	       symbol, those shouldn't go in the partial symbol 	       table.  We do pick up the elements of such enums at 	       'check_enum:', below.  */
if|if
condition|(
name|p
operator|>=
name|namestring
operator|+
literal|2
operator|||
operator|(
name|p
operator|==
name|namestring
operator|+
literal|1
operator|&&
name|namestring
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Also a typedef with the same name.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
block|}
goto|goto
name|check_enum
goto|;
case|case
literal|'t'
case|:
if|if
condition|(
name|p
operator|!=
name|namestring
condition|)
comment|/* a name is there, not just :T... */
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|check_enum
label|:
comment|/* If this is an enumerated type, we need to 	       add all the enum constants to the partial symbol 	       table.  This does not cover enums without names, e.g. 	       "enum {a, b} c;" in C, but fortunately those are 	       rare.  There is no way for GDB to find those from the 	       enum type without spending too much time on it.  Thus 	       to solve this problem, the compiler needs to put out the 	       enum in a nameless type.  GCC2 does this.  */
comment|/* We are looking for something of the form<name> ":" ("t" | "T") [<number> "="] "e" 	       {<constant> ":"<value> ","} ";".  */
comment|/* Skip over the colon and the 't' or 'T'.  */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* This type may be given a number.  Also, numbers can come 	       in pairs like (0,26).  Skip over it.  */
while|while
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|')'
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'e'
condition|)
block|{
comment|/* The aix4 compiler emits extra crud before the members.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Skip over the type (?).  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip over the colon.  */
name|p
operator|++
expr_stmt|;
block|}
comment|/* We have found an enumerated type.  */
comment|/* According to comments in read_enum_type 		   a comma could end it instead of a semicolon. 		   I don't know where that happens. 		   Accept either.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Check for and handle cretinous dbx symbol name 		       continuation!  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|||
operator|(
operator|*
name|p
operator|==
literal|'?'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|p
operator|=
name|next_symbol_text
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Point to the character after the name 		       of the enum constant.  */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|;
name|q
operator|++
control|)
empty_stmt|;
comment|/* Note that the value doesn't matter for 		       enum constants in psymtabs, just in symtabs.  */
name|add_psymbol_to_list
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Point past the name.  */
name|p
operator|=
name|q
expr_stmt|;
comment|/* Skip over the value.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Advance past the comma.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'c'
case|:
comment|/* Constant, e.g. from "const" in Pascal.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|int
name|name_len
init|=
name|p
operator|-
name|namestring
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|name_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|namestring
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|name
index|[
name|name_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|function_outside_compilation_unit_complaint
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kludges for ELF/STABS with Sun ACC */
name|last_function_name
operator|=
name|namestring
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit 	       value for the bottom of the text seg in those cases. */
if|if
condition|(
name|nlist
operator|.
name|n_value
operator|==
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|minsym_valu
init|=
name|find_stab_function_addr
argument_list|(
name|namestring
argument_list|,
name|pst
operator|->
name|filename
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
comment|/* find_stab_function_addr will return 0 if the minimal 		   symbol wasn't found.  (Unfortunately, this might also 		   be a valid address.)  Anyway, if it *does* return 0, 		   it is likely that the value was set correctly to begin 		   with... */
if|if
condition|(
name|minsym_valu
operator|!=
literal|0
condition|)
name|nlist
operator|.
name|n_value
operator|=
name|minsym_valu
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|&&
name|textlow_not_set
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* End kludge.  */
comment|/* Keep track of the start of the last function so we 	       can handle end of function symbols.  */
name|last_function_start
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
comment|/* In reordered executables this function may lie outside 	       the bounds created by N_SO symbols.  If that's the case 	       use the address of this function as the low bound for 	       the partial symbol table.  */
if|if
condition|(
name|pst
operator|&&
operator|(
name|textlow_not_set
operator|||
operator|(
name|nlist
operator|.
name|n_value
operator|<
name|pst
operator|->
name|textlow
operator|&&
operator|(
name|nlist
operator|.
name|n_value
operator|!=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Global functions were ignored here, but now they 	       are put into the global psymtab like one would expect. 	       They're also in the minimal symbol table.  */
case|case
literal|'F'
case|:
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|int
name|name_len
init|=
name|p
operator|-
name|namestring
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|name_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|namestring
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|name
index|[
name|name_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|function_outside_compilation_unit_complaint
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|nlist
operator|.
name|n_value
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kludges for ELF/STABS with Sun ACC */
name|last_function_name
operator|=
name|namestring
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit 	       value for the bottom of the text seg in those cases. */
if|if
condition|(
name|nlist
operator|.
name|n_value
operator|==
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|minsym_valu
init|=
name|find_stab_function_addr
argument_list|(
name|namestring
argument_list|,
name|pst
operator|->
name|filename
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
comment|/* find_stab_function_addr will return 0 if the minimal 		   symbol wasn't found.  (Unfortunately, this might also 		   be a valid address.)  Anyway, if it *does* return 0, 		   it is likely that the value was set correctly to begin 		   with... */
if|if
condition|(
name|minsym_valu
operator|!=
literal|0
condition|)
name|nlist
operator|.
name|n_value
operator|=
name|minsym_valu
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|&&
name|textlow_not_set
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* End kludge.  */
comment|/* Keep track of the start of the last function so we 	       can handle end of function symbols.  */
name|last_function_start
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
comment|/* In reordered executables this function may lie outside 	       the bounds created by N_SO symbols.  If that's the case 	       use the address of this function as the low bound for 	       the partial symbol table.  */
if|if
condition|(
name|pst
operator|&&
operator|(
name|textlow_not_set
operator|||
operator|(
name|nlist
operator|.
name|n_value
operator|<
name|pst
operator|->
name|textlow
operator|&&
operator|(
name|nlist
operator|.
name|n_value
operator|!=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Two things show up here (hopefully); static symbols of 	       local scope (static used inside braces) or extensions 	       of structure symbols.  We can ignore both.  */
case|case
literal|'V'
case|:
case|case
literal|'('
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'-'
case|:
case|case
literal|'#'
case|:
comment|/* for symbol identification (used in live ranges) */
continue|continue;
case|case
literal|':'
case|:
comment|/* It is a C++ nested symbol.  We don't need to record it 	       (I don't think); if we try to look up foo::bar::baz, 	       then symbols for the symtab containing foo should get 	       read in, I think.  */
comment|/* Someone says sun cc puts out symbols like 	       /foo/baz/maclib::/usr/local/bin/maclib, 	       which would get here with a symbol type of ':'.  */
continue|continue;
default|default:
comment|/* Unexpected symbol descriptor.  The second and subsequent stabs 	       of a continued stab can show up here.  The question is 	       whether they ever can mimic a normal stab--it would be 	       nice if not, since we certainly don't want to spend the 	       time searching to the end of every string looking for 	       a backslash.  */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unknown symbol descriptor `%c'"
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Ignore it; perhaps it is an extension that we don't 	       know about.  */
continue|continue;
block|}
case|case
name|N_EXCL
case|:
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
comment|/* Find the corresponding bincl and mark that psymtab on the 	     psymtab dependency list */
block|{
name|struct
name|partial_symtab
modifier|*
name|needed_pst
init|=
name|find_corresponding_bincl_psymtab
argument_list|(
name|namestring
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|)
decl_stmt|;
comment|/* If this include file was defined earlier in this file, 	       leave it alone.  */
if|if
condition|(
name|needed_pst
operator|==
name|pst
condition|)
continue|continue;
if|if
condition|(
name|needed_pst
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dependencies_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dependency_list
index|[
name|i
index|]
operator|==
name|needed_pst
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If it's already in the list, skip the rest.  */
if|if
condition|(
name|found
condition|)
continue|continue;
name|dependency_list
index|[
name|dependencies_used
operator|++
index|]
operator|=
name|needed_pst
expr_stmt|;
if|if
condition|(
name|dependencies_used
operator|>=
name|dependencies_allocated
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
modifier|*
name|orig
init|=
name|dependency_list
decl_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|dependencies_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dependency_list
argument_list|,
name|orig
argument_list|,
operator|(
name|dependencies_used
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_INFO
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Had to reallocate dependency list.\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"New dependencies allocated: %d\n"
argument_list|,
name|dependencies_allocated
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
continue|continue;
case|case
name|N_ENDM
case|:
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Solaris 2 end of module, finish current partial symbol table. 	     end_psymtab will set pst->texthigh to the proper value, which 	     is necessary if a module compiled without debugging info 	     follows this module.  */
if|if
condition|(
name|pst
condition|)
block|{
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|textlow_not_set
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
case|case
name|N_RBRAC
case|:
ifdef|#
directive|ifdef
name|HANDLE_RBRAC
name|HANDLE_RBRAC
argument_list|(
name|nlist
operator|.
name|n_value
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
name|N_EINCL
case|:
case|case
name|N_DSLINE
case|:
case|case
name|N_BSLINE
case|:
case|case
name|N_SSYM
case|:
comment|/* Claim: Structure or union element. 					   Hopefully, I can ignore this.  */
case|case
name|N_ENTRY
case|:
comment|/* Alternate entry point; can ignore. */
case|case
name|N_MAIN
case|:
comment|/* Can definitely ignore this.   */
case|case
name|N_CATCH
case|:
comment|/* These are GNU C++ extensions */
case|case
name|N_EHDECL
case|:
comment|/* that can safely be ignored here. */
case|case
name|N_LENG
case|:
case|case
name|N_BCOMM
case|:
case|case
name|N_ECOMM
case|:
case|case
name|N_ECOML
case|:
case|case
name|N_FNAME
case|:
case|case
name|N_SLINE
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_LBRAC
case|:
case|case
name|N_NSYMS
case|:
comment|/* Ultrix 4.0: symbol count */
case|case
name|N_DEFD
case|:
comment|/* GNU Modula-2 */
case|case
name|N_ALIAS
case|:
comment|/* SunPro F77: alias name, ignore for now.  */
case|case
name|N_OBJ
case|:
comment|/* useless types from Solaris */
case|case
name|N_OPT
case|:
case|case
name|N_PATCH
case|:
comment|/* These symbols aren't interesting; don't worry about them */
continue|continue;
default|default:
comment|/* If we haven't found it yet, ignore it.  It's probably some 	     new type we don't know about yet.  */
name|unknown_symtype_complaint
argument_list|(
name|local_hex_string
argument_list|(
name|nlist
operator|.
name|n_type
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If there's stuff to be cleaned up, clean it up.  */
if|if
condition|(
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|>
literal|0
comment|/* We have some syms */
comment|/*FIXME, does this have a bug at start address 0? */
operator|&&
name|last_o_file_start
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|nlist
operator|.
name|n_value
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_lowpc
operator|=
name|last_o_file_start
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_highpc
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|pst
condition|)
block|{
comment|/* Don't set pst->texthigh lower than it already is.  */
name|CORE_ADDR
name|text_end
init|=
operator|(
name|lowest_text_address
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|?
operator|(
name|text_addr
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
operator|)
else|:
name|lowest_text_address
operator|)
operator|+
name|text_size
decl_stmt|;
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|text_end
operator|>
name|pst
operator|->
name|texthigh
condition|?
name|text_end
else|:
name|pst
operator|->
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|textlow_not_set
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|start_psymtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|CORE_ADDR
name|textlow
parameter_list|,
name|int
name|ldsymoff
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|result
init|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
name|filename
argument_list|,
name|textlow
argument_list|,
name|global_syms
argument_list|,
name|static_syms
argument_list|)
decl_stmt|;
name|result
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|result
argument_list|)
operator|=
name|ldsymoff
expr_stmt|;
name|result
operator|->
name|read_symtab
operator|=
name|dbx_psymtab_to_symtab
expr_stmt|;
name|SYMBOL_SIZE
argument_list|(
name|result
argument_list|)
operator|=
name|symbol_size
expr_stmt|;
name|SYMBOL_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|symbol_table_offset
expr_stmt|;
name|STRING_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|string_table_offset
expr_stmt|;
name|FILE_STRING_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|file_string_table_offset
expr_stmt|;
comment|/* If we're handling an ELF file, drag some section-relocation info      for this source file out of the ELF symbol table, to compensate for      Sun brain death.  This replaces the section_offsets in this psymtab,      if successful.  */
name|elfstab_offset_sections
argument_list|(
name|objfile
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* Deduce the source language from the filename for this psymtab. */
name|psymtab_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Close off the current usage of PST.      Returns PST or NULL if the partial symtab was empty and thrown away.     FIXME:  List variables and peculiarities of same.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|end_psymtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|,
name|char
modifier|*
modifier|*
name|include_list
parameter_list|,
name|int
name|num_includes
parameter_list|,
name|int
name|capping_symbol_offset
parameter_list|,
name|CORE_ADDR
name|capping_text
parameter_list|,
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
parameter_list|,
name|int
name|number_dependencies
parameter_list|,
name|int
name|textlow_not_set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
if|if
condition|(
name|capping_symbol_offset
operator|!=
operator|-
literal|1
condition|)
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|=
name|capping_symbol_offset
operator|-
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|capping_text
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Under Solaris, the N_SO symbols always have a value of 0,      instead of the usual address of the .o file.  Therefore,      we have to do some tricks to fill in texthigh and textlow.      The first trick is: if we see a static      or global function, and the textlow for the current pst      is not set (ie: textlow_not_set), then we use that function's      address for the textlow of the pst.  */
comment|/* Now, to fill in texthigh, we remember the last function seen      in the .o file.  Also, there's a hack in      bfd/elf.c and gdb/elfread.c to pass the ELF st_size field      to here via the misc_info field.  Therefore, we can fill in      a reliable texthigh by taking the address plus size of the      last function in the file.  */
if|if
condition|(
name|pst
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|last_function_name
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|minsym
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|last_function_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|last_function_name
expr_stmt|;
name|n
operator|=
name|p
operator|-
name|last_function_name
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|last_function_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|minsym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|pst
operator|->
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|minsym
operator|==
name|NULL
condition|)
block|{
comment|/* Sun Fortran appends an underscore to the minimal symbol name, 	     try again with an appended underscore if the minimal symbol 	     was not found.  */
name|p
index|[
name|n
index|]
operator|=
literal|'_'
expr_stmt|;
name|p
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|minsym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|pst
operator|->
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minsym
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|minsym
argument_list|)
operator|+
name|MSYMBOL_SIZE
argument_list|(
name|minsym
argument_list|)
expr_stmt|;
name|last_function_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* this test will be true if the last .o file is only data */
if|if
condition|(
name|textlow_not_set
condition|)
name|pst
operator|->
name|textlow
operator|=
name|pst
operator|->
name|texthigh
expr_stmt|;
else|else
block|{
name|struct
name|partial_symtab
modifier|*
name|p1
decl_stmt|;
comment|/* If we know our own starting text address, then walk through all other          psymtabs for this objfile, and if any didn't know their ending text          address, set it to our starting address.  Take care to not set our          own ending address to our starting address, nor to set addresses on          `dependency' files that have both textlow and texthigh zero.  */
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|p1
argument_list|)
block|{
if|if
condition|(
name|p1
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|p1
operator|->
name|textlow
operator|!=
literal|0
operator|&&
name|p1
operator|!=
name|pst
condition|)
block|{
name|p1
operator|->
name|texthigh
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
comment|/* if this file has only data, then make textlow match texthigh */
if|if
condition|(
name|p1
operator|->
name|textlow
operator|==
literal|0
condition|)
name|p1
operator|->
name|textlow
operator|=
name|p1
operator|->
name|texthigh
expr_stmt|;
block|}
block|}
block|}
comment|/* End of kludge for patching Solaris textlow and texthigh.  */
endif|#
directive|endif
comment|/* SOFUN_ADDRESS_MAYBE_MISSING.  */
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
if|if
condition|(
name|number_dependencies
condition|)
block|{
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pst
operator|->
name|dependencies
argument_list|,
name|dependency_list
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pst
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
name|allocate_psymtab
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
comment|/* Copy the sesction_offsets array from the main psymtab. */
name|subpst
operator|->
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|subpst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|subpst
argument_list|)
operator|=
name|LDSYMLEN
argument_list|(
name|subpst
argument_list|)
operator|=
name|subpst
operator|->
name|textlow
operator|=
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
comment|/* We could save slight bits of space by only making one of these,          shared by the entire set of include files.  FIXME-someday.  */
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|read_symtab
operator|=
name|pst
operator|->
name|read_symtab
expr_stmt|;
block|}
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name, remove it.      (If there is a symtab, more drastic things also happen.)      This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_includes
operator|==
literal|0
operator|&&
name|number_dependencies
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
operator|&&
name|has_line_numbers
operator|==
literal|0
condition|)
block|{
comment|/* Throw away this psymtab, it's empty.  We can't deallocate it, since          it is on the obstack, but we can forget to chain it on the list.  */
comment|/* Empty psymtabs happen as a result of header files which don't have          any symbols in them.  There can be a lot of them.  But this check          is wrong, in that a psymtab with N_SLINE entries but nothing else          is not empty, but we don't realize that.  Fixing that without slowing          things down might be tricky.  */
name|discard_psymtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Indicate that psymtab was thrown away.  */
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|pst
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dbx_psymtab_to_symtab_1
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|dbx_psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
condition|)
comment|/* Otherwise it's a dummy */
block|{
comment|/* Init stuff necessary for reading in symbols */
name|stabsread_init
argument_list|()
expr_stmt|;
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_string_table_offset
operator|=
name|FILE_STRING_OFFSET
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|symbol_size
operator|=
name|SYMBOL_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Read in this file's symbols */
name|bfd_seek
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|SYMBOL_OFFSET
argument_list|(
name|pst
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|read_ofile_symtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all of the symbols for a given psymtab for real.    Be verbose about it if the user wants that.  */
end_comment

begin_function
specifier|static
name|void
name|dbx_psymtab_to_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table,          to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|sym_bfd
operator|=
name|pst
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
name|next_symbol_text_func
operator|=
name|dbx_next_symbol_text
expr_stmt|;
if|if
condition|(
name|DBX_STAB_SECTION
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
condition|)
block|{
name|stabs_data
operator|=
name|symfile_relocate_debug_section
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|DBX_STAB_SECTION
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabs_data
condition|)
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|stabs_data
argument_list|)
expr_stmt|;
block|}
name|dbx_psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
if|if
condition|(
name|back_to
condition|)
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in a defined section of a specific object file's symbols. */
end_comment

begin_function
specifier|static
name|void
name|read_ofile_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
name|char
modifier|*
name|namestring
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|bufp
decl_stmt|;
name|struct
name|internal_nlist
name|nlist
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
name|unsigned
name|max_symnum
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|sym_offset
decl_stmt|;
comment|/* Offset to start of symbols to read */
name|int
name|sym_size
decl_stmt|;
comment|/* Size of symbols to read */
name|CORE_ADDR
name|text_offset
decl_stmt|;
comment|/* Start of text segment for symbols */
name|int
name|text_size
decl_stmt|;
comment|/* Size of text segment for symbols */
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|objfile
operator|=
name|pst
operator|->
name|objfile
expr_stmt|;
name|sym_offset
operator|=
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|sym_size
operator|=
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|text_offset
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
name|text_size
operator|=
name|pst
operator|->
name|texthigh
operator|-
name|pst
operator|->
name|textlow
expr_stmt|;
comment|/* This cannot be simply objfile->section_offsets because of      elfstab_offset_sections() which initializes the psymtab section      offsets information in a special way, and that is different from      objfile->section_offsets. */
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|subfile_stack
operator|=
name|NULL
expr_stmt|;
name|stringtab_global
operator|=
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|symfile_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* Implicit param to next_text_symbol */
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
name|symbuf_read
operator|=
literal|0
expr_stmt|;
name|symbuf_left
operator|=
name|sym_offset
operator|+
name|sym_size
expr_stmt|;
comment|/* It is necessary to actually read one symbol *before* the start      of this symtab's symbols, because the GCC_COMPILED_FLAG_SYMBOL      occurs before the N_SO symbol.       Detecting this in read_dbx_symtab      would slow down initial readin, so we look for it here instead.  */
if|if
condition|(
operator|!
name|processing_acc_compilation
operator|&&
name|sym_offset
operator|>=
operator|(
name|int
operator|)
name|symbol_size
condition|)
block|{
name|stabs_seek
argument_list|(
name|sym_offset
operator|-
name|symbol_size
argument_list|)
expr_stmt|;
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|INTERNALIZE_SYMBOL
argument_list|(
name|nlist
argument_list|,
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlist
operator|.
name|n_type
operator|==
name|N_TEXT
condition|)
block|{
specifier|const
name|char
modifier|*
name|tempstring
init|=
name|namestring
decl_stmt|;
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|tempstring
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|symfile_bfd
argument_list|)
condition|)
operator|++
name|tempstring
expr_stmt|;
if|if
condition|(
name|DEPRECATED_STREQN
argument_list|(
name|tempstring
argument_list|,
literal|"__gnu_compiled"
argument_list|,
literal|14
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Try to select a C++ demangling based on the compilation unit          producer. */
if|#
directive|if
literal|0
comment|/* For now, stay with AUTO_DEMANGLING for g++ output, as we don't 	 know whether it will use the old style or v3 mangling.  */
block|if (processing_gcc_compilation) 	{ 	  if (AUTO_DEMANGLING) 	    { 	      set_demangling_style (GNU_DEMANGLING_STYLE_STRING); 	    } 	}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* The N_SO starting this symtab is the first symbol, so we          better not check the symbol before it.  I'm not this can          happen, but it doesn't hurt to check for it.  */
name|stabs_seek
argument_list|(
name|sym_offset
argument_list|)
expr_stmt|;
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
index|]
expr_stmt|;
if|if
condition|(
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|bufp
operator|->
name|e_type
argument_list|)
operator|!=
name|N_SO
condition|)
name|error
argument_list|(
literal|"First symbol in segment of executable not a source symbol"
argument_list|)
expr_stmt|;
name|max_symnum
operator|=
name|sym_size
operator|/
name|symbol_size
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|max_symnum
condition|;
name|symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|INTERNALIZE_SYMBOL
argument_list|(
name|nlist
argument_list|,
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|bufp
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|namestring
operator|=
name|set_namestring
argument_list|(
name|objfile
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_STAB
condition|)
block|{
name|process_one_symbol
argument_list|(
name|type
argument_list|,
name|nlist
operator|.
name|n_desc
argument_list|,
name|nlist
operator|.
name|n_value
argument_list|,
name|namestring
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We skip checking for a new .o or -l file; that should never          happen in this routine. */
elseif|else
if|if
condition|(
name|type
operator|==
name|N_TEXT
condition|)
block|{
comment|/* I don't think this code will ever be executed, because 	     the GCC_COMPILED_FLAG_SYMBOL usually is right before 	     the N_SO symbol which starts this source file. 	     However, there is no reason not to accept 	     the GCC_COMPILED_FLAG_SYMBOL anywhere.  */
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
comment|/* For now, stay with AUTO_DEMANGLING for g++ output, as we don't 	     know whether it will use the old style or v3 mangling.  */
block|if (AUTO_DEMANGLING) 	    { 	      set_demangling_style (GNU_DEMANGLING_STYLE_STRING); 	    }
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|&
name|N_EXT
operator|||
name|type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_TEXT
operator|||
name|type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_NBTEXT
condition|)
block|{
comment|/* Global symbol: see if we came across a dbx defintion for 	     a corresponding symbol.  If so, store the value.  Remove 	     syms from the chain when their values are stored, but 	     search the whole chain, as there may be several syms from 	     different files with the same name. */
comment|/* This is probably not true.  Since the files will be read 	     in one at a time, each reference to a global symbol will 	     be satisfied in each file as it appears. So we skip this 	     section. */
empty_stmt|;
block|}
block|}
name|current_objfile
operator|=
name|NULL
expr_stmt|;
comment|/* In a Solaris elf file, this variable, which comes from the      value of the N_SO symbol, will still be 0.  Luckily, text_offset,      which comes from pst->textlow is correct. */
if|if
condition|(
name|last_source_start_addr
operator|==
literal|0
condition|)
name|last_source_start_addr
operator|=
name|text_offset
expr_stmt|;
comment|/* In reordered executables last_source_start_addr may not be the      lower bound for this symtab, instead use text_offset which comes      from pst->textlow which is correct.  */
if|if
condition|(
name|last_source_start_addr
operator|>
name|text_offset
condition|)
name|last_source_start_addr
operator|=
name|text_offset
expr_stmt|;
name|pst
operator|->
name|symtab
operator|=
name|end_symtab
argument_list|(
name|text_offset
operator|+
name|text_size
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This handles a single symbol from the symbol-file, building symbols    into a GDB symtab.  It takes these arguments and an implicit argument.     TYPE is the type field of the ".stab" symbol entry.    DESC is the desc field of the ".stab" entry.    VALU is the value field of the ".stab" entry.    NAME is the symbol name, in our address space.    SECTION_OFFSETS is a set of amounts by which the sections of this object    file were relocated when it was loaded into memory.    Note that these section_offsets are not the     objfile->section_offsets but the pst->section_offsets.    All symbols that refer    to memory locations need to be offset by these amounts.    OBJFILE is the object file from which we are reading symbols.    It is used in end_symtab.  */
end_comment

begin_function
name|void
name|process_one_symbol
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|desc
parameter_list|,
name|CORE_ADDR
name|valu
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|section_offsets
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
comment|/* If SUN_FIXED_LBRAC_BUG is defined, then it tells us whether we need      to correct the address of N_LBRAC's.  If it is not defined, then      we never need to correct the addresses.  */
comment|/* This records the last pc address we've seen.  We depend on there being      an SLINE or FUN or SO before the first LBRAC, since the variable does      not get reset in between reads of different symbol files.  */
specifier|static
name|CORE_ADDR
name|last_pc_address
decl_stmt|;
endif|#
directive|endif
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
comment|/* This remembers the address of the start of a function.  It is used      because in Solaris 2, N_LBRAC, N_RBRAC, and N_SLINE entries are      relative to the current function's start address.  On systems      other than Solaris 2, this just holds the SECT_OFF_TEXT value, and is      used to relocate these symbol types rather than SECTION_OFFSETS.  */
specifier|static
name|CORE_ADDR
name|function_start_offset
decl_stmt|;
comment|/* This holds the address of the start of a function, without the system      peculiarities of function_start_offset.  */
specifier|static
name|CORE_ADDR
name|last_function_start
decl_stmt|;
comment|/* If this is nonzero, we've seen an N_SLINE since the start of the      current function.  We use this to tell us to move the first sline      to the beginning of the function regardless of what its given      value is. */
specifier|static
name|int
name|sline_found_in_function
init|=
literal|1
decl_stmt|;
comment|/* If this is nonzero, we've seen a non-gcc N_OPT symbol for this source      file.  Used to detect the SunPRO solaris compiler.  */
specifier|static
name|int
name|n_opt_found
decl_stmt|;
comment|/* The stab type used for the definition of the last function.      N_STSYM or N_GSYM for SunOS4 acc; N_FUN for other compilers.  */
specifier|static
name|int
name|function_stab_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|block_address_function_relative
condition|)
comment|/* N_LBRAC, N_RBRAC and N_SLINE entries are not relative to the        function start address, so just use the text offset.  */
name|function_start_offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Something is wrong if we see real data before      seeing a source file name.  */
if|if
condition|(
name|last_source_file
operator|==
name|NULL
operator|&&
name|type
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|N_SO
condition|)
block|{
comment|/* Ignore any symbols which appear before an N_SO symbol.          Currently no one puts symbols there, but we should deal          gracefully with the case.  A complain()t might be in order,          but this should not be an error ().  */
return|return;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_FUN
case|:
case|case
name|N_FNAME
case|:
if|if
condition|(
operator|*
name|name
operator|==
literal|'\000'
condition|)
block|{
comment|/* This N_FUN marks the end of a function.  This closes off the 	     current block.  */
if|if
condition|(
name|context_stack_depth
operator|<=
literal|0
condition|)
block|{
name|lbrac_mismatch_complaint
argument_list|(
name|symnum
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The following check is added before recording line 0 at 	     end of function so as to handle hand-generated stabs 	     which may have an N_FUN stabs at the end of the function, but 	     no N_SLINE stabs.  */
if|if
condition|(
name|sline_found_in_function
condition|)
name|record_line
argument_list|(
name|current_subfile
argument_list|,
literal|0
argument_list|,
name|last_function_start
operator|+
name|valu
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|new
operator|->
name|start_addr
operator|+
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* May be switching to an assembler file which may not be using 	     block relative stabs, so reset the offset.  */
if|if
condition|(
name|block_address_function_relative
condition|)
name|function_start_offset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|sline_found_in_function
operator|=
literal|0
expr_stmt|;
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|valu
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|valu
argument_list|)
expr_stmt|;
name|last_function_start
operator|=
name|valu
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
case|case
name|N_LBRAC
case|:
comment|/* This "symbol" just indicates the start of an inner lexical          context within a function.  */
comment|/* Ignore extra outermost context from SunPRO cc and acc.  */
if|if
condition|(
name|n_opt_found
operator|&&
name|desc
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|block_address_function_relative
condition|)
comment|/* Relocate for Sun ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|else
comment|/* On most machines, the block addresses are relative to the 	   N_SO, the linker did not relocate them (sigh).  */
name|valu
operator|+=
name|last_source_start_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
if|if
condition|(
operator|!
name|SUN_FIXED_LBRAC_BUG
operator|&&
name|valu
operator|<
name|last_pc_address
condition|)
block|{
comment|/* Patch current LBRAC pc value to match last handy pc value */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"bad block start address patched"
argument_list|)
expr_stmt|;
name|valu
operator|=
name|last_pc_address
expr_stmt|;
block|}
endif|#
directive|endif
name|new
operator|=
name|push_context
argument_list|(
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
comment|/* This "symbol" just indicates the end of an inner lexical          context that was started with N_LBRAC.  */
comment|/* Ignore extra outermost context from SunPRO cc and acc.  */
if|if
condition|(
name|n_opt_found
operator|&&
name|desc
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|block_address_function_relative
condition|)
comment|/* Relocate for Sun ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|else
comment|/* On most machines, the block addresses are relative to the 	   N_SO, the linker did not relocate them (sigh).  */
name|valu
operator|+=
name|last_source_start_addr
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|<=
literal|0
condition|)
block|{
name|lbrac_mismatch_complaint
argument_list|(
name|symnum
argument_list|)
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|new
operator|->
name|depth
condition|)
name|lbrac_mismatch_complaint
argument_list|(
name|symnum
argument_list|)
expr_stmt|;
comment|/* Some compilers put the variable decls inside of an          LBRAC/RBRAC block.  This macro should be nonzero if this          is true.  DESC is N_DESC from the N_RBRAC symbol.          GCC_P is true if we've detected the GCC_COMPILED_SYMBOL          or the GCC2_COMPILED_SYMBOL.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VARIABLES_INSIDE_BLOCK
argument_list|)
define|#
directive|define
name|VARIABLES_INSIDE_BLOCK
parameter_list|(
name|desc
parameter_list|,
name|gcc_p
parameter_list|)
value|0
endif|#
directive|endif
comment|/* Can only use new->locals as local symbols here if we're in          gcc or on a machine that puts them before the lbrack.  */
if|if
condition|(
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_symbols
operator|!=
name|NULL
condition|)
block|{
comment|/* GCC development snapshots from March to December of 		 2000 would output N_LSYM entries after N_LBRAC 		 entries.  As a consequence, these symbols are simply 		 discarded.  Complain if this is the case.  Note that 		 there are some compilers which legitimately put local 		 symbols within an LBRAC/RBRAC block; this complaint 		 might also help sort out problems in which 		 VARIABLES_INSIDE_BLOCK is incorrectly defined.  */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"misplaced N_LBRAC entry; discarding local symbols which have no enclosing block"
argument_list|)
expr_stmt|;
block|}
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
if|if
condition|(
name|context_stack_depth
operator|>
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
block|{
comment|/* This is not the outermost LBRAC...RBRAC pair in the function, 	     its local symbols preceded it, and are the ones just recovered 	     from the context stack.  Define the block for them (but don't 	     bother if the block contains no symbols.  Should we complain 	     on blocks without symbols?  I can't think of any useful purpose 	     for them).  */
if|if
condition|(
name|local_symbols
operator|!=
name|NULL
condition|)
block|{
comment|/* Muzzle a compiler bug that makes end< start.  (which 	         compilers?  Is this ever harmful?).  */
if|if
condition|(
name|new
operator|->
name|start_addr
operator|>
name|valu
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"block start larger than block end"
argument_list|)
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|valu
expr_stmt|;
block|}
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is the outermost LBRAC...RBRAC pair.  There is no 	     need to do anything; leave the symbols that preceded it 	     to be attached to the function's own block.  We need to 	     indicate that we just moved outside of the function.  */
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
comment|/* Now pop locals of block just finished.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
break|break;
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
comment|/* This kind of symbol indicates the start of an object file.  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
comment|/* This type of symbol indicates the start of data          for one source file.          Finish the symbol table of the previous source file          (if any) and start accumulating a new symbol table.  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|n_opt_found
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_SOL_BROKEN
comment|/* pcc bug, occasionally puts out SO for SOL.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|start_subfile
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|last_source_file
condition|)
block|{
comment|/* Check if previous symbol was also an N_SO (with some 	     sanity checks).  If so, that one was actually the directory 	     name, and the current one is the real file name. 	     Patch things up. */
if|if
condition|(
name|previous_stab_code
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_SO
condition|)
block|{
name|patch_subfile_names
argument_list|(
name|current_subfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
comment|/* Ignore repeated SOs */
block|}
name|end_symtab
argument_list|(
name|valu
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
comment|/* Null name means this just marks the end of text for this .o file.          Don't start a new symtab in this case.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'\000'
condition|)
break|break;
if|if
condition|(
name|block_address_function_relative
condition|)
name|function_start_offset
operator|=
literal|0
expr_stmt|;
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"stabs"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
comment|/* This type of symbol indicates the start of data for          a sub-source-file, one whose contents were copied or          included in the compilation of the main source file          (whose name was given in the N_SO symbol.)  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BINCL
case|:
name|push_subfile
argument_list|()
expr_stmt|;
name|add_new_header_file
argument_list|(
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EINCL
case|:
name|start_subfile
argument_list|(
name|pop_subfile
argument_list|()
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EXCL
case|:
name|add_old_header_file
argument_list|(
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
comment|/* This type of "symbol" really just records          one line-number -- core-address correspondence.          Enter it in the line list for this symbol table.  */
comment|/* Relocate for dynamic loading and for ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
comment|/* If this is the first SLINE note in the function, record it at 	 the start of the function instead of at the listed location.  */
if|if
condition|(
name|within_function
operator|&&
name|sline_found_in_function
operator|==
literal|0
condition|)
block|{
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|desc
argument_list|,
name|last_function_start
argument_list|)
expr_stmt|;
name|sline_found_in_function
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BCOMM
case|:
name|common_block_start
argument_list|(
name|name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ECOMM
case|:
name|common_block_end
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
comment|/* The following symbol types need to have the appropriate offset added          to their value; then we process symbol definitions in the name.  */
case|case
name|N_STSYM
case|:
comment|/* Static symbol in data seg */
case|case
name|N_LCSYM
case|:
comment|/* Static symbol in BSS seg */
case|case
name|N_ROSYM
case|:
comment|/* Static symbol in Read-only data seg */
comment|/* HORRID HACK DEPT.  However, it's Sun's furgin' fault.          Solaris2's stabs-in-elf makes *most* symbols relative          but leaves a few absolute (at least for Solaris 2.1 and version          2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on the fence.          .stab "foo:S...",N_STSYM        is absolute (ld relocates it)          .stab "foo:V...",N_STSYM        is relative (section base subtracted).          This leaves us no choice but to search for the 'S' or 'V'...          (or pass the whole section_offsets stuff down ONE MORE function          call level, which we really don't want to do).  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* .o files and NLMs have non-zero text seg offsets, but don't need 	   their static syms offset in this fashion.  XXX - This is really a 	   crock that should be fixed in the solib handling code so that I 	   don't have to work around it here. */
if|if
condition|(
operator|!
name|symfile_relocatable
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'S'
condition|)
block|{
comment|/* The linker relocated it.  We don't want to add an 		   elfstab_offset_sections-type offset, but we *do* want 		   to add whatever solib.c passed to symbol_file_add as 		   addr (this is known to affect SunOS4, and I suspect ELF 		   too).  Since elfstab_offset_sections currently does not 		   muck with the text offset (there is no Ttext.text 		   symbol), we can get addr from the text offset.  If 		   elfstab_offset_sections ever starts dealing with the 		   text offset, and we still need to do this, we need to 		   invent a SECT_OFF_ADDR_KLUDGE or something.  */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
block|}
block|}
comment|/* Since it's not the kludge case, re-dispatch to the right handler. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_STSYM
case|:
goto|goto
name|case_N_STSYM
goto|;
case|case
name|N_LCSYM
case|:
goto|goto
name|case_N_LCSYM
goto|;
case|case
name|N_ROSYM
case|:
goto|goto
name|case_N_ROSYM
goto|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
block|}
name|case_N_STSYM
label|:
comment|/* Static symbol in data seg */
case|case
name|N_DSLINE
case|:
comment|/* Source line number, data seg */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
name|case_N_LCSYM
label|:
comment|/* Static symbol in BSS seg */
case|case
name|N_BSLINE
case|:
comment|/* Source line number, bss seg */
comment|/*   N_BROWS:       overlaps with N_BSLINE */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
name|case_N_ROSYM
label|:
comment|/* Static symbol in Read-only data seg */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_RODATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
case|case
name|N_ENTRY
case|:
comment|/* Alternate entry point */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
comment|/* The following symbol types we don't know how to process.  Handle          them in a "default" way, but complain to people who care.  */
default|default:
case|case
name|N_CATCH
case|:
comment|/* Exception handler catcher */
case|case
name|N_EHDECL
case|:
comment|/* Exception handler name */
case|case
name|N_PC
case|:
comment|/* Global symbol in Pascal */
case|case
name|N_M2C
case|:
comment|/* Modula-2 compilation unit */
comment|/*   N_MOD2:        overlaps with N_EHDECL */
case|case
name|N_SCOPE
case|:
comment|/* Modula-2 scope information */
case|case
name|N_ECOML
case|:
comment|/* End common (local name) */
case|case
name|N_NBTEXT
case|:
comment|/* Gould Non-Base-Register symbols??? */
case|case
name|N_NBDATA
case|:
case|case
name|N_NBBSS
case|:
case|case
name|N_NBSTS
case|:
case|case
name|N_NBLCS
case|:
name|unknown_symtype_complaint
argument_list|(
name|local_hex_string
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
comment|/* The following symbol types don't need the address field relocated,          since it is either unused, or is absolute.  */
name|define_a_symbol
label|:
case|case
name|N_GSYM
case|:
comment|/* Global variable */
case|case
name|N_NSYMS
case|:
comment|/* Number of symbols (ultrix) */
case|case
name|N_NOMAP
case|:
comment|/* No map?  (ultrix) */
case|case
name|N_RSYM
case|:
comment|/* Register variable */
case|case
name|N_DEFD
case|:
comment|/* Modula-2 GNU module dependency */
case|case
name|N_SSYM
case|:
comment|/* Struct or union element */
case|case
name|N_LSYM
case|:
comment|/* Local symbol in stack */
case|case
name|N_PSYM
case|:
comment|/* Parameter variable */
case|case
name|N_LENG
case|:
comment|/* Length of preceding symbol type */
if|if
condition|(
name|name
condition|)
block|{
name|int
name|deftype
decl_stmt|;
name|char
modifier|*
name|colon_pos
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon_pos
operator|==
name|NULL
condition|)
name|deftype
operator|=
literal|'\0'
expr_stmt|;
else|else
name|deftype
operator|=
name|colon_pos
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|function_stab_type
operator|=
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Deal with the SunPRO 3.0 compiler which omits the address 	         from N_FUN symbols.  */
if|if
condition|(
name|type
operator|==
name|N_FUN
operator|&&
name|valu
operator|==
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|minsym_valu
init|=
name|find_stab_function_addr
argument_list|(
name|name
argument_list|,
name|last_source_file
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
comment|/* find_stab_function_addr will return 0 if the minimal 		     symbol wasn't found.  (Unfortunately, this might also 		     be a valid address.)  Anyway, if it *does* return 0, 		     it is likely that the value was set correctly to begin 		     with... */
if|if
condition|(
name|minsym_valu
operator|!=
literal|0
condition|)
name|valu
operator|=
name|minsym_valu
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
comment|/* The Sun acc compiler, under SunOS4, puts out 	         functions with N_GSYM or N_STSYM.  The problem is 	         that the address of the symbol is no good (for N_GSYM 	         it doesn't even attept an address; for N_STSYM it 	         puts out an address but then it gets relocated 	         relative to the data segment, not the text segment). 	         Currently we can't fix this up later as we do for 	         some types of symbol in scan_file_globals. 	         Fortunately we do have a way of finding the address - 	         we know that the value in last_pc_address is either 	         the one we want (if we're dealing with the first 	         function in an object file), or somewhere in the 	         previous function. This means that we can use the 	         minimal symbol table to get the address.  */
comment|/* Starting with release 3.0, the Sun acc compiler, 	         under SunOS4, puts out functions with N_FUN and a value 	         of zero. This gets relocated to the start of the text 	         segment of the module, which is no good either. 	         Under SunOS4 we can deal with this as N_SLINE and N_SO 	         entries contain valid absolute addresses. 	         Release 3.0 acc also puts out N_OPT entries, which makes 	         it possible to discern acc from cc or gcc.  */
if|if
condition|(
name|type
operator|==
name|N_GSYM
operator|||
name|type
operator|==
name|N_STSYM
operator|||
operator|(
name|type
operator|==
name|N_FUN
operator|&&
name|n_opt_found
operator|&&
operator|!
name|block_address_function_relative
operator|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
name|int
name|l
init|=
name|colon_pos
operator|-
name|name
decl_stmt|;
name|m
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|last_pc_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|strncmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|m
argument_list|)
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|&&
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|m
argument_list|)
index|[
name|l
index|]
operator|==
literal|'\0'
condition|)
comment|/* last_pc_address was in this function */
name|valu
operator|=
name|SYMBOL_VALUE
argument_list|(
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|&&
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|m
operator|+
literal|1
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|m
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|&&
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|m
operator|+
literal|1
argument_list|)
index|[
name|l
index|]
operator|==
literal|'\0'
condition|)
comment|/* last_pc_address was in last function */
name|valu
operator|=
name|SYMBOL_VALUE
argument_list|(
name|m
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Not found - use last_pc_address (for finish_block) */
name|valu
operator|=
name|last_pc_address
expr_stmt|;
block|}
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
if|if
condition|(
name|block_address_function_relative
condition|)
comment|/* For Solaris 2.0 compilers, the block addresses and 		   N_SLINE's are relative to the start of the 		   function.  On normal systems, and when using gcc on 		   Solaris 2.0, these addresses are just absolute, or 		   relative to the N_SO, depending on 		   BLOCK_ADDRESS_ABSOLUTE.  */
name|function_start_offset
operator|=
name|valu
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
literal|1
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unmatched N_LBRAC before symtab pos %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
comment|/* We use N_OPT to carry the gcc2_compiled flag.  Sun uses it          for a bunch of other flags, too.  Someday we may parse their          flags; for now we ignore theirs and hope they'll ignore ours.  */
case|case
name|N_OPT
case|:
comment|/* Solaris 2:  Compiler options */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Works, but is experimental.  -fnf */
comment|/* For now, stay with AUTO_DEMANGLING for g++ output, as we don't 		 know whether it will use the old style or v3 mangling.  */
block|if (AUTO_DEMANGLING) 		{ 		  set_demangling_style (GNU_DEMANGLING_STYLE_STRING); 		}
endif|#
directive|endif
block|}
else|else
name|n_opt_found
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|N_MAIN
case|:
comment|/* Name of main routine.  */
comment|/* FIXME: If one has a symbol file with N_MAIN and then replaces 	 it with a symbol file with "main" and without N_MAIN.  I'm 	 not sure exactly what rule to follow but probably something 	 like: N_MAIN takes precedence over "main" no matter what 	 objfile it is in; If there is more than one N_MAIN, choose 	 the one in the symfile_objfile; If there is more than one 	 N_MAIN within a given objfile, complain() and choose 	 arbitrarily. (kingdon) */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|set_main_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
comment|/* The following symbol types can be ignored.  */
case|case
name|N_OBJ
case|:
comment|/* Solaris 2:  Object file dir and name */
case|case
name|N_PATCH
case|:
comment|/* Solaris2: Patch Run Time Checker.  */
comment|/*   N_UNDF:                   Solaris 2:  file separator mark */
comment|/*   N_UNDF: -- we will never encounter it, since we only process one          file's symbols at once.  */
case|case
name|N_ENDM
case|:
comment|/* Solaris 2:  End of module */
case|case
name|N_ALIAS
case|:
comment|/* SunPro F77: alias name, ignore for now.  */
break|break;
block|}
comment|/* '#' is a GNU C extension to allow one symbol to refer to another      related symbol.       Generally this is used so that an alias can refer to its main      symbol.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* Initialize symbol reference names and determine if this is           a definition.  If symbol reference is being defined, go           ahead and add it.  Otherwise, just return sym. */
name|char
modifier|*
name|s
init|=
name|name
decl_stmt|;
name|int
name|refnum
decl_stmt|;
comment|/* If this stab defines a new reference ID that is not on the          reference list, then put it on the reference list.           We go ahead and advance NAME past the reference, even though          it is not strictly necessary at this time.  */
name|refnum
operator|=
name|symbol_reference_defined
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|refnum
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|ref_search
argument_list|(
name|refnum
argument_list|)
condition|)
name|ref_add
argument_list|(
name|refnum
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|name
operator|=
name|s
expr_stmt|;
block|}
name|previous_stab_code
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME: The only difference between this and elfstab_build_psymtabs    is the call to install_minimal_symbols for elf, and the support for    split sections.  If the differences are really that small, the code    should be shared.  */
end_comment

begin_comment
comment|/* Scan and build partial symbols for an coff symbol file.    The coff file has already been processed to get its minimal symbols.     This routine is the equivalent of dbx_symfile_init and dbx_symfile_read    rolled into one.     OBJFILE is the object file we are reading symbols from.    ADDR is the address relative to which the symbols are (e.g.    the base address of the text segment).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).    TEXTADDR is the address of the text section.    TEXTSIZE is the size of the text section.    STABSECTS is the list of .stab sections in OBJFILE.    STABSTROFFSET and STABSTRSIZE define the location in OBJFILE where the    .stabstr section exists.     This routine is mostly copied from dbx_symfile_init and dbx_symfile_read,    adjusted for coff details. */
end_comment

begin_function
name|void
name|coffstab_build_psymtabs
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|,
name|CORE_ADDR
name|textaddr
parameter_list|,
name|unsigned
name|int
name|textsize
parameter_list|,
name|struct
name|stab_section_list
modifier|*
name|stabsects
parameter_list|,
name|file_ptr
name|stabstroffset
parameter_list|,
name|unsigned
name|int
name|stabstrsize
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|stabsize
decl_stmt|;
comment|/* There is already a dbx_symfile_info allocated by our caller.      It might even contain some info from the coff symtab to help us.  */
name|info
operator|=
name|objfile
operator|->
name|sym_stab_info
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|textaddr
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|textsize
expr_stmt|;
define|#
directive|define
name|COFF_STABS_SYMBOL_SIZE
value|12
comment|/* XXX FIXME XXX */
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|COFF_STABS_SYMBOL_SIZE
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabstrsize
expr_stmt|;
if|if
condition|(
name|stabstrsize
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|stabstrsize
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|stabstroffset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|stabstrsize
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|stabstrsize
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|processing_acc_compilation
operator|=
literal|1
expr_stmt|;
comment|/* In a coff file, we've already installed the minimal symbols that came      from the coff (non-stab) symbol table, so always act like an      incremental load here. */
if|if
condition|(
name|stabsects
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|stabsize
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsects
operator|->
name|section
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsize
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsects
operator|->
name|section
operator|->
name|filepos
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stab_section_list
modifier|*
name|stabsect
decl_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|stabsect
operator|=
name|stabsects
init|;
name|stabsect
operator|!=
name|NULL
condition|;
name|stabsect
operator|=
name|stabsect
operator|->
name|next
control|)
block|{
name|stabsize
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsect
operator|->
name|section
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|+=
name|stabsize
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsects
operator|->
name|section
operator|->
name|filepos
expr_stmt|;
name|symbuf_sections
operator|=
name|stabsects
operator|->
name|next
expr_stmt|;
name|symbuf_left
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsects
operator|->
name|section
argument_list|)
expr_stmt|;
name|symbuf_read
operator|=
literal|0
expr_stmt|;
block|}
name|dbx_symfile_read
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for an ELF symbol file.    This ELF file has already been processed to get its minimal symbols,    and any DWARF symbols that were in it.     This routine is the equivalent of dbx_symfile_init and dbx_symfile_read    rolled into one.     OBJFILE is the object file we are reading symbols from.    ADDR is the address relative to which the symbols are (e.g.    the base address of the text segment).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).    STABSECT is the BFD section information for the .stab section.    STABSTROFFSET and STABSTRSIZE define the location in OBJFILE where the    .stabstr section exists.     This routine is mostly copied from dbx_symfile_init and dbx_symfile_read,    adjusted for elf details. */
end_comment

begin_function
name|void
name|elfstab_build_psymtabs
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|,
name|asection
modifier|*
name|stabsect
parameter_list|,
name|file_ptr
name|stabstroffset
parameter_list|,
name|unsigned
name|int
name|stabstrsize
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|info
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|NULL
decl_stmt|;
comment|/* There is already a dbx_symfile_info allocated by our caller.      It might even contain some info from the ELF symtab to help us.  */
name|info
operator|=
name|objfile
operator|->
name|sym_stab_info
expr_stmt|;
comment|/* Find the first and last text address.  dbx_symfile_read seems to      want this.  */
name|find_text_range
argument_list|(
name|sym_bfd
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
define|#
directive|define
name|ELF_STABS_SYMBOL_SIZE
value|12
comment|/* XXX FIXME XXX */
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|ELF_STABS_SYMBOL_SIZE
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|stabsect
argument_list|)
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabstrsize
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsect
operator|->
name|filepos
expr_stmt|;
name|DBX_STAB_SECTION
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsect
expr_stmt|;
if|if
condition|(
name|stabstrsize
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|stabstrsize
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|stabstroffset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|stabstrsize
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|stabstrsize
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|processing_acc_compilation
operator|=
literal|1
expr_stmt|;
name|symbuf_read
operator|=
literal|0
expr_stmt|;
name|symbuf_left
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|stabsect
argument_list|)
expr_stmt|;
name|stabs_data
operator|=
name|symfile_relocate_debug_section
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|stabsect
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabs_data
condition|)
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|stabs_data
argument_list|)
expr_stmt|;
comment|/* In an elf file, we've already installed the minimal symbols that came      from the elf (non-stab) symbol table, so always act like an      incremental load here.  dbx_symfile_read should not generate any new      minimal symbols, since we will have already read the ELF dynamic symbol      table and normal symbol entries won't be in the ".stab" section; but in      case it does, it will install them itself.  */
name|dbx_symfile_read
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|back_to
condition|)
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for a file with special sections for stabs    and stabstrings.  The file has already been processed to get its minimal    symbols, and any other symbols that might be necessary to resolve GSYMs.     This routine is the equivalent of dbx_symfile_init and dbx_symfile_read    rolled into one.     OBJFILE is the object file we are reading symbols from.    ADDR is the address relative to which the symbols are (e.g. the base address    of the text segment).    MAINLINE is true if we are reading the main symbol table (as opposed to a    shared lib or dynamically loaded file).    STAB_NAME is the name of the section that contains the stabs.    STABSTR_NAME is the name of the section that contains the stab strings.     This routine is mostly copied from dbx_symfile_init and dbx_symfile_read. */
end_comment

begin_function
name|void
name|stabsect_build_psymtabs
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|,
name|char
modifier|*
name|stab_name
parameter_list|,
name|char
modifier|*
name|stabstr_name
parameter_list|,
name|char
modifier|*
name|text_name
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|stabsect
decl_stmt|;
name|asection
modifier|*
name|stabstrsect
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|;
name|stabsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
name|stab_name
argument_list|)
expr_stmt|;
name|stabstrsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stabsect
condition|)
return|return;
if|if
condition|(
operator|!
name|stabstrsect
condition|)
name|error
argument_list|(
literal|"stabsect_build_psymtabs:  Found stabs (%s), but not string section (%s)"
argument_list|,
name|stab_name
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|sym_stab_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
name|text_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_sect
condition|)
name|error
argument_list|(
literal|"Can't find %s section in symbol file"
argument_list|,
name|text_name
argument_list|)
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsect
argument_list|)
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabstrsect
argument_list|)
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsect
operator|->
name|filepos
expr_stmt|;
comment|/* XXX - FIXME: POKING INSIDE BFD DATA STRUCTURES */
if|if
condition|(
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_get_section_contents
argument_list|(
name|sym_bfd
argument_list|,
comment|/* bfd */
name|stabstrsect
argument_list|,
comment|/* bfd section */
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
comment|/* input buffer */
literal|0
argument_list|,
comment|/* offset into section */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* amount to read */
if|if
condition|(
operator|!
name|val
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
comment|/* Now, do an incremental load */
name|processing_acc_compilation
operator|=
literal|1
expr_stmt|;
name|dbx_symfile_read
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|aout_sym_fns
init|=
block|{
name|bfd_target_aout_flavour
block|,
name|dbx_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|dbx_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|dbx_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|dbx_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|default_symfile_offsets
block|,
comment|/* sym_offsets: parse user's offsets to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_dbxread
parameter_list|(
name|void
parameter_list|)
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|aout_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

