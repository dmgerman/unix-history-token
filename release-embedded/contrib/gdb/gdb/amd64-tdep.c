begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for AMD64.     Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Jiri Smid, SuSE Labs.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"dummy-frame.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"regset.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"amd64-tdep.h"
end_include

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_comment
comment|/* Note that the AMD64 architecture was previously known as x86-64.    The latter is (forever) engraved into the canonical system name as    returned by config.guess, and used as the name for the AMD64 port    of GNU/Linux.  The BSD's have renamed their ports to amd64; they    don't like to shout.  For GDB we prefer the amd64_-prefix over the    x86_64_-prefix since it's so much easier to type.  */
end_comment

begin_comment
comment|/* Register information.  */
end_comment

begin_struct
struct|struct
name|amd64_register_info
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|amd64_register_info
name|amd64_register_info
index|[]
init|=
block|{
block|{
literal|"rax"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"rbx"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"rcx"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"rdx"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"rsi"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"rdi"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"rbp"
block|,
operator|&
name|builtin_type_void_data_ptr
block|}
block|,
block|{
literal|"rsp"
block|,
operator|&
name|builtin_type_void_data_ptr
block|}
block|,
comment|/* %r8 is indeed register number 8.  */
block|{
literal|"r8"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"r9"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"r10"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"r11"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"r12"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"r13"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"r14"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"r15"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"rip"
block|,
operator|&
name|builtin_type_void_func_ptr
block|}
block|,
block|{
literal|"eflags"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"cs"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"ss"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"ds"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"es"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"fs"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"gs"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
comment|/* %st0 is register number 24.  */
block|{
literal|"st0"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"st1"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"st2"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"st3"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"st4"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"st5"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"st6"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"st7"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|"fctrl"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"fstat"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"ftag"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"fiseg"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"fioff"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"foseg"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"fooff"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|"fop"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
comment|/* %xmm0 is register number 40.  */
block|{
literal|"xmm0"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm1"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm2"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm3"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm4"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm5"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm6"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm7"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm8"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm9"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm10"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm11"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm12"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm13"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm14"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"xmm15"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|"mxcsr"
block|,
operator|&
name|builtin_type_int32
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of registers.  */
end_comment

begin_define
define|#
directive|define
name|AMD64_NUM_REGS
define|\
value|(sizeof (amd64_register_info) / sizeof (amd64_register_info[0]))
end_define

begin_comment
comment|/* Return the name of register REGNUM.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|amd64_register_name
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|AMD64_NUM_REGS
condition|)
return|return
name|amd64_register_info
index|[
name|regnum
index|]
operator|.
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register REGNUM. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|amd64_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|AMD64_NUM_REGS
argument_list|)
expr_stmt|;
return|return
operator|*
name|amd64_register_info
index|[
name|regnum
index|]
operator|.
name|type
return|;
block|}
end_function

begin_comment
comment|/* DWARF Register Number Mapping as defined in the System V psABI,    section 3.6.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|amd64_dwarf_regmap
index|[]
init|=
block|{
comment|/* General Purpose Registers RAX, RDX, RCX, RBX, RSI, RDI.  */
name|AMD64_RAX_REGNUM
block|,
name|AMD64_RDX_REGNUM
block|,
name|AMD64_RCX_REGNUM
block|,
name|AMD64_RBX_REGNUM
block|,
name|AMD64_RSI_REGNUM
block|,
name|AMD64_RDI_REGNUM
block|,
comment|/* Frame Pointer Register RBP.  */
name|AMD64_RBP_REGNUM
block|,
comment|/* Stack Pointer Register RSP.  */
name|AMD64_RSP_REGNUM
block|,
comment|/* Extended Integer Registers 8 - 15.  */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
comment|/* Return Address RA.  Mapped to RIP.  */
name|AMD64_RIP_REGNUM
block|,
comment|/* SSE Registers 0 - 7.  */
name|AMD64_XMM0_REGNUM
operator|+
literal|0
block|,
name|AMD64_XMM1_REGNUM
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|2
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|3
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|4
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|5
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|6
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|7
block|,
comment|/* Extended SSE Registers 8 - 15.  */
name|AMD64_XMM0_REGNUM
operator|+
literal|8
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|9
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|10
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|11
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|12
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|13
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|14
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|15
block|,
comment|/* Floating Point Registers 0-7.  */
name|AMD64_ST0_REGNUM
operator|+
literal|0
block|,
name|AMD64_ST0_REGNUM
operator|+
literal|1
block|,
name|AMD64_ST0_REGNUM
operator|+
literal|2
block|,
name|AMD64_ST0_REGNUM
operator|+
literal|3
block|,
name|AMD64_ST0_REGNUM
operator|+
literal|4
block|,
name|AMD64_ST0_REGNUM
operator|+
literal|5
block|,
name|AMD64_ST0_REGNUM
operator|+
literal|6
block|,
name|AMD64_ST0_REGNUM
operator|+
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|amd64_dwarf_regmap_len
init|=
operator|(
sizeof|sizeof
argument_list|(
name|amd64_dwarf_regmap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|amd64_dwarf_regmap
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert DWARF register number REG to the appropriate register    number used by GDB.  */
end_comment

begin_function
specifier|static
name|int
name|amd64_dwarf_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0
operator|||
name|reg
operator|<
name|amd64_dwarf_regmap_len
condition|)
name|regnum
operator|=
name|amd64_dwarf_regmap
index|[
name|reg
index|]
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Unmapped DWARF Register #%d encountered\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|regnum
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if a value of type TYPE stored in register REGNUM    needs any special handling.  */
end_comment

begin_function
specifier|static
name|int
name|amd64_convert_register_p
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register classes as defined in the psABI.  */
end_comment

begin_enum
enum|enum
name|amd64_reg_class
block|{
name|AMD64_INTEGER
block|,
name|AMD64_SSE
block|,
name|AMD64_SSEUP
block|,
name|AMD64_X87
block|,
name|AMD64_X87UP
block|,
name|AMD64_COMPLEX_X87
block|,
name|AMD64_NO_CLASS
block|,
name|AMD64_MEMORY
block|}
enum|;
end_enum

begin_comment
comment|/* Return the union class of CLASS1 and CLASS2.  See the psABI for    details.  */
end_comment

begin_function
specifier|static
name|enum
name|amd64_reg_class
name|amd64_merge_classes
parameter_list|(
name|enum
name|amd64_reg_class
name|class1
parameter_list|,
name|enum
name|amd64_reg_class
name|class2
parameter_list|)
block|{
comment|/* Rule (a): If both classes are equal, this is the resulting class.  */
if|if
condition|(
name|class1
operator|==
name|class2
condition|)
return|return
name|class1
return|;
comment|/* Rule (b): If one of the classes is NO_CLASS, the resulting class      is the other class.  */
if|if
condition|(
name|class1
operator|==
name|AMD64_NO_CLASS
condition|)
return|return
name|class2
return|;
if|if
condition|(
name|class2
operator|==
name|AMD64_NO_CLASS
condition|)
return|return
name|class1
return|;
comment|/* Rule (c): If one of the classes is MEMORY, the result is MEMORY.  */
if|if
condition|(
name|class1
operator|==
name|AMD64_MEMORY
operator|||
name|class2
operator|==
name|AMD64_MEMORY
condition|)
return|return
name|AMD64_MEMORY
return|;
comment|/* Rule (d): If one of the classes is INTEGER, the result is INTEGER.  */
if|if
condition|(
name|class1
operator|==
name|AMD64_INTEGER
operator|||
name|class2
operator|==
name|AMD64_INTEGER
condition|)
return|return
name|AMD64_INTEGER
return|;
comment|/* Rule (e): If one of the classes is X87, X87UP, COMPLEX_X87 class,      MEMORY is used as class.  */
if|if
condition|(
name|class1
operator|==
name|AMD64_X87
operator|||
name|class1
operator|==
name|AMD64_X87UP
operator|||
name|class1
operator|==
name|AMD64_COMPLEX_X87
operator|||
name|class2
operator|==
name|AMD64_X87
operator|||
name|class2
operator|==
name|AMD64_X87UP
operator|||
name|class2
operator|==
name|AMD64_COMPLEX_X87
condition|)
return|return
name|AMD64_MEMORY
return|;
comment|/* Rule (f): Otherwise class SSE is used.  */
return|return
name|AMD64_SSE
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|amd64_classify
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|enum
name|amd64_reg_class
name|class
index|[
literal|2
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return non-zero if TYPE is a non-POD structure or union type.  */
end_comment

begin_function
specifier|static
name|int
name|amd64_non_pod_p
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
comment|/* ??? A class with a base class certainly isn't POD, but does this      catch all non-POD structure types?  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Classify TYPE according to the rules for aggregate (structures and    arrays) and union types, and store the result in CLASS.  */
end_comment

begin_function
specifier|static
name|void
name|amd64_classify_aggregate
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|enum
name|amd64_reg_class
name|class
index|[
literal|2
index|]
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* 1. If the size of an object is larger than two eightbytes, or in         C++, is a non-POD structure or union type, or contains         unaligned fields, it has class memory.  */
if|if
condition|(
name|len
operator|>
literal|16
operator|||
name|amd64_non_pod_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|class
index|[
literal|0
index|]
operator|=
name|class
index|[
literal|1
index|]
operator|=
name|AMD64_MEMORY
expr_stmt|;
return|return;
block|}
comment|/* 2. Both eightbytes get initialized to class NO_CLASS.  */
name|class
index|[
literal|0
index|]
operator|=
name|class
index|[
literal|1
index|]
operator|=
name|AMD64_NO_CLASS
expr_stmt|;
comment|/* 3. Each field of an object is classified recursively so that         always two fields are considered. The resulting class is         calculated according to the classes of the fields in the         eightbyte: */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|struct
name|type
modifier|*
name|subtype
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* All fields in an array have the same type.  */
name|amd64_classify
argument_list|(
name|subtype
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|8
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|AMD64_NO_CLASS
condition|)
name|class
index|[
literal|1
index|]
operator|=
name|class
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Structure or union.  */
name|gdb_assert
argument_list|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|subtype
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|64
decl_stmt|;
name|enum
name|amd64_reg_class
name|subclass
index|[
literal|2
index|]
decl_stmt|;
comment|/* Ignore static fields.  */
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|gdb_assert
argument_list|(
name|pos
operator|==
literal|0
operator|||
name|pos
operator|==
literal|1
argument_list|)
expr_stmt|;
name|amd64_classify
argument_list|(
name|subtype
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
name|class
index|[
name|pos
index|]
operator|=
name|amd64_merge_classes
argument_list|(
name|class
index|[
name|pos
index|]
argument_list|,
name|subclass
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
name|class
index|[
literal|1
index|]
operator|=
name|amd64_merge_classes
argument_list|(
name|class
index|[
literal|1
index|]
argument_list|,
name|subclass
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 4. Then a post merger cleanup is done:  */
comment|/* Rule (a): If one of the classes is MEMORY, the whole argument is      passed in memory.  */
if|if
condition|(
name|class
index|[
literal|0
index|]
operator|==
name|AMD64_MEMORY
operator|||
name|class
index|[
literal|1
index|]
operator|==
name|AMD64_MEMORY
condition|)
name|class
index|[
literal|0
index|]
operator|=
name|class
index|[
literal|1
index|]
operator|=
name|AMD64_MEMORY
expr_stmt|;
comment|/* Rule (b): If SSEUP is not preceeded by SSE, it is converted to      SSE.  */
if|if
condition|(
name|class
index|[
literal|0
index|]
operator|==
name|AMD64_SSEUP
condition|)
name|class
index|[
literal|0
index|]
operator|=
name|AMD64_SSE
expr_stmt|;
if|if
condition|(
name|class
index|[
literal|1
index|]
operator|==
name|AMD64_SSEUP
operator|&&
name|class
index|[
literal|0
index|]
operator|!=
name|AMD64_SSE
condition|)
name|class
index|[
literal|1
index|]
operator|=
name|AMD64_SSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Classify TYPE, and store the result in CLASS.  */
end_comment

begin_function
specifier|static
name|void
name|amd64_classify
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|enum
name|amd64_reg_class
name|class
index|[
literal|2
index|]
parameter_list|)
block|{
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|class
index|[
literal|0
index|]
operator|=
name|class
index|[
literal|1
index|]
operator|=
name|AMD64_NO_CLASS
expr_stmt|;
comment|/* Arguments of types (signed and unsigned) _Bool, char, short, int,      long, long long, and pointers are in the INTEGER class.  */
if|if
condition|(
operator|(
name|code
operator|==
name|TYPE_CODE_INT
operator|||
name|code
operator|==
name|TYPE_CODE_ENUM
operator|||
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_REF
operator|)
operator|&&
operator|(
name|len
operator|==
literal|1
operator|||
name|len
operator|==
literal|2
operator|||
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|)
condition|)
name|class
index|[
literal|0
index|]
operator|=
name|AMD64_INTEGER
expr_stmt|;
comment|/* Arguments of types float, double and __m64 are in class SSE.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
operator|&&
operator|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|)
condition|)
comment|/* FIXME: __m64 .  */
name|class
index|[
literal|0
index|]
operator|=
name|AMD64_SSE
expr_stmt|;
comment|/* Arguments of types __float128 and __m128 are split into two      halves.  The least significant ones belong to class SSE, the most      significant one to class SSEUP.  */
comment|/* FIXME: __float128, __m128.  */
comment|/* The 64-bit mantissa of arguments of type long double belongs to      class X87, the 16-bit exponent plus 6 bytes of padding belongs to      class X87UP.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
operator|&&
name|len
operator|==
literal|16
condition|)
comment|/* Class X87 and X87UP.  */
name|class
index|[
literal|0
index|]
operator|=
name|AMD64_X87
operator|,
name|class
index|[
literal|1
index|]
operator|=
name|AMD64_X87UP
expr_stmt|;
comment|/* Aggregates.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
condition|)
name|amd64_classify_aggregate
argument_list|(
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|return_value_convention
name|amd64_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
name|enum
name|amd64_reg_class
name|class
index|[
literal|2
index|]
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|static
name|int
name|integer_regnum
index|[]
init|=
block|{
name|AMD64_RAX_REGNUM
block|,
name|AMD64_RDX_REGNUM
block|}
decl_stmt|;
specifier|static
name|int
name|sse_regnum
index|[]
init|=
block|{
name|AMD64_XMM0_REGNUM
block|,
name|AMD64_XMM1_REGNUM
block|}
decl_stmt|;
name|int
name|integer_reg
init|=
literal|0
decl_stmt|;
name|int
name|sse_reg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
operator|!
operator|(
name|readbuf
operator|&&
name|writebuf
operator|)
argument_list|)
expr_stmt|;
comment|/* 1. Classify the return type with the classification algorithm.  */
name|amd64_classify
argument_list|(
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* 2. If the type has class MEMORY, then the caller provides space         for the return value and passes the address of this storage in         %rdi as if it were the first argument to the function. In         effect, this address becomes a hidden first argument.  */
if|if
condition|(
name|class
index|[
literal|0
index|]
operator|==
name|AMD64_MEMORY
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
name|gdb_assert
argument_list|(
name|class
index|[
literal|1
index|]
operator|!=
name|AMD64_MEMORY
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|<=
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|len
operator|-=
literal|8
control|)
block|{
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|class
index|[
name|i
index|]
condition|)
block|{
case|case
name|AMD64_INTEGER
case|:
comment|/* 3. If the class is INTEGER, the next available register 	     of the sequence %rax, %rdx is used.  */
name|regnum
operator|=
name|integer_regnum
index|[
name|integer_reg
operator|++
index|]
expr_stmt|;
break|break;
case|case
name|AMD64_SSE
case|:
comment|/* 4. If the class is SSE, the next available SSE register              of the sequence %xmm0, %xmm1 is used.  */
name|regnum
operator|=
name|sse_regnum
index|[
name|sse_reg
operator|++
index|]
expr_stmt|;
break|break;
case|case
name|AMD64_SSEUP
case|:
comment|/* 5. If the class is SSEUP, the eightbyte is passed in the 	     upper half of the last used SSE register.  */
name|gdb_assert
argument_list|(
name|sse_reg
operator|>
literal|0
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|sse_regnum
index|[
name|sse_reg
operator|-
literal|1
index|]
expr_stmt|;
name|offset
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AMD64_X87
case|:
comment|/* 6. If the class is X87, the value is returned on the X87              stack in %st0 as 80-bit x87 number.  */
name|regnum
operator|=
name|AMD64_ST0_REGNUM
expr_stmt|;
if|if
condition|(
name|writebuf
condition|)
name|i387_return_value
argument_list|(
name|gdbarch
argument_list|,
name|regcache
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMD64_X87UP
case|:
comment|/* 7. If the class is X87UP, the value is returned together              with the previous X87 value in %st0.  */
name|gdb_assert
argument_list|(
name|i
operator|>
literal|0
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|AMD64_X87
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|AMD64_ST0_REGNUM
expr_stmt|;
name|offset
operator|=
literal|8
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|AMD64_NO_CLASS
case|:
continue|continue;
default|default:
name|gdb_assert
argument_list|(
operator|!
literal|"Unexpected register class."
argument_list|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|regnum
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf
condition|)
name|regcache_raw_read_part
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|offset
argument_list|,
name|min
argument_list|(
name|len
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|readbuf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|writebuf
condition|)
name|regcache_raw_write_part
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|offset
argument_list|,
name|min
argument_list|(
name|len
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|writebuf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|amd64_push_arguments
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|)
block|{
specifier|static
name|int
name|integer_regnum
index|[]
init|=
block|{
name|AMD64_RDI_REGNUM
block|,
comment|/* %rdi */
name|AMD64_RSI_REGNUM
block|,
comment|/* %rsi */
name|AMD64_RDX_REGNUM
block|,
comment|/* %rdx */
name|AMD64_RCX_REGNUM
block|,
comment|/* %rcx */
literal|8
block|,
comment|/* %r8 */
literal|9
comment|/* %r9 */
block|}
decl_stmt|;
specifier|static
name|int
name|sse_regnum
index|[]
init|=
block|{
comment|/* %xmm0 ... %xmm7 */
name|AMD64_XMM0_REGNUM
operator|+
literal|0
block|,
name|AMD64_XMM1_REGNUM
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|2
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|3
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|4
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|5
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|6
block|,
name|AMD64_XMM0_REGNUM
operator|+
literal|7
block|,   }
decl_stmt|;
name|struct
name|value
modifier|*
modifier|*
name|stack_args
init|=
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|num_stack_args
init|=
literal|0
decl_stmt|;
name|int
name|num_elements
init|=
literal|0
decl_stmt|;
name|int
name|element
init|=
literal|0
decl_stmt|;
name|int
name|integer_reg
init|=
literal|0
decl_stmt|;
name|int
name|sse_reg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Reserve a register for the "hidden" argument.  */
if|if
condition|(
name|struct_return
condition|)
name|integer_reg
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|amd64_reg_class
name|class
index|[
literal|2
index|]
decl_stmt|;
name|int
name|needed_integer_regs
init|=
literal|0
decl_stmt|;
name|int
name|needed_sse_regs
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Classify argument.  */
name|amd64_classify
argument_list|(
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* Calculate the number of integer and SSE registers needed for          this argument.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|class
index|[
name|j
index|]
operator|==
name|AMD64_INTEGER
condition|)
name|needed_integer_regs
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|class
index|[
name|j
index|]
operator|==
name|AMD64_SSE
condition|)
name|needed_sse_regs
operator|++
expr_stmt|;
block|}
comment|/* Check whether enough registers are available, and if the          argument should be passed in registers at all.  */
if|if
condition|(
name|integer_reg
operator|+
name|needed_integer_regs
operator|>
name|ARRAY_SIZE
argument_list|(
name|integer_regnum
argument_list|)
operator|||
name|sse_reg
operator|+
name|needed_sse_regs
operator|>
name|ARRAY_SIZE
argument_list|(
name|sse_regnum
argument_list|)
operator|||
operator|(
name|needed_integer_regs
operator|==
literal|0
operator|&&
name|needed_sse_regs
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* The argument will be passed on the stack.  */
name|num_elements
operator|+=
operator|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|stack_args
index|[
name|num_stack_args
operator|++
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* The argument will be passed in registers.  */
name|char
modifier|*
name|valbuf
init|=
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|<=
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
name|j
operator|++
operator|,
name|len
operator|-=
literal|8
control|)
block|{
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|class
index|[
name|j
index|]
condition|)
block|{
case|case
name|AMD64_INTEGER
case|:
name|regnum
operator|=
name|integer_regnum
index|[
name|integer_reg
operator|++
index|]
expr_stmt|;
break|break;
case|case
name|AMD64_SSE
case|:
name|regnum
operator|=
name|sse_regnum
index|[
name|sse_reg
operator|++
index|]
expr_stmt|;
break|break;
case|case
name|AMD64_SSEUP
case|:
name|gdb_assert
argument_list|(
name|sse_reg
operator|>
literal|0
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|sse_regnum
index|[
name|sse_reg
operator|-
literal|1
index|]
expr_stmt|;
name|offset
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|gdb_assert
argument_list|(
operator|!
literal|"Unexpected register class."
argument_list|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|regnum
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|valbuf
operator|+
name|j
operator|*
literal|8
argument_list|,
name|min
argument_list|(
name|len
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|regcache_raw_write_part
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Allocate space for the arguments on the stack.  */
name|sp
operator|-=
name|num_elements
operator|*
literal|8
expr_stmt|;
comment|/* The psABI says that "The end of the input argument area shall be      aligned on a 16 byte boundary."  */
name|sp
operator|&=
operator|~
literal|0xf
expr_stmt|;
comment|/* Write out the arguments to the stack.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_stack_args
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|stack_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|char
modifier|*
name|valbuf
init|=
name|VALUE_CONTENTS
argument_list|(
name|stack_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
name|element
operator|*
literal|8
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|element
operator|+=
operator|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
block|}
comment|/* The psABI says that "For calls that may call functions that use      varargs or stdargs (prototype-less calls or calls to functions      containing ellipsis (...) in the declaration) %al is used as      hidden argument to specify the number of SSE registers used.  */
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|AMD64_RAX_REGNUM
argument_list|,
name|sse_reg
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|amd64_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
comment|/* Pass arguments.  */
name|sp
operator|=
name|amd64_push_arguments
argument_list|(
name|regcache
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|)
expr_stmt|;
comment|/* Pass "hidden" argument".  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|AMD64_RDI_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Store return address.  */
name|sp
operator|-=
literal|8
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Finally, update the stack pointer...  */
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|AMD64_RSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* ...and fake a frame pointer.  */
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|AMD64_RBP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|sp
operator|+
literal|16
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The maximum number of saved registers.  This should include %rip.  */
end_comment

begin_define
define|#
directive|define
name|AMD64_NUM_SAVED_REGS
value|AMD64_NUM_GREGS
end_define

begin_struct
struct|struct
name|amd64_frame_cache
block|{
comment|/* Base address.  */
name|CORE_ADDR
name|base
decl_stmt|;
name|CORE_ADDR
name|sp_offset
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* Saved registers.  */
name|CORE_ADDR
name|saved_regs
index|[
name|AMD64_NUM_SAVED_REGS
index|]
decl_stmt|;
name|CORE_ADDR
name|saved_sp
decl_stmt|;
comment|/* Do we have a frame?  */
name|int
name|frameless_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate and initialize a frame cache.  */
end_comment

begin_function
specifier|static
name|struct
name|amd64_frame_cache
modifier|*
name|amd64_alloc_frame_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
modifier|*
name|cache
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|amd64_frame_cache
argument_list|)
expr_stmt|;
comment|/* Base address.  */
name|cache
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sp_offset
operator|=
operator|-
literal|8
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
literal|0
expr_stmt|;
comment|/* Saved registers.  We initialize these to -1 since zero is a valid      offset (that's where %rbp is supposed to be stored).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AMD64_NUM_SAVED_REGS
condition|;
name|i
operator|++
control|)
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|cache
operator|->
name|saved_sp
operator|=
literal|0
expr_stmt|;
comment|/* Frameless until proven otherwise.  */
name|cache
operator|->
name|frameless_p
operator|=
literal|1
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_comment
comment|/* Do a limited analysis of the prologue at PC and update CACHE    accordingly.  Bail out early if CURRENT_PC is reached.  Return the    address where the analysis stopped.     We will handle only functions beginning with:        pushq %rbp        0x55       movq %rsp, %rbp   0x48 0x89 0xe5     Any function that doesn't start with this sequence will be assumed    to have no prologue and thus no valid frame pointer in %rbp.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|amd64_analyze_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|current_pc
parameter_list|,
name|struct
name|amd64_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|proto
index|[
literal|3
index|]
init|=
block|{
literal|0x48
block|,
literal|0x89
block|,
literal|0xe5
block|}
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
if|if
condition|(
name|current_pc
operator|<=
name|pc
condition|)
return|return
name|current_pc
return|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x55
condition|)
comment|/* pushq %rbp */
block|{
comment|/* Take into account that we've executed the `pushq %rbp' that          starts this instruction sequence.  */
name|cache
operator|->
name|saved_regs
index|[
name|AMD64_RBP_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sp_offset
operator|+=
literal|8
expr_stmt|;
comment|/* If that's all, return now.  */
if|if
condition|(
name|current_pc
operator|<=
name|pc
operator|+
literal|1
condition|)
return|return
name|current_pc
return|;
comment|/* Check for `movq %rsp, %rbp'.  */
name|read_memory
argument_list|(
name|pc
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|proto
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|pc
operator|+
literal|1
return|;
comment|/* OK, we actually have a frame.  */
name|cache
operator|->
name|frameless_p
operator|=
literal|0
expr_stmt|;
return|return
name|pc
operator|+
literal|4
return|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Return PC of first real instruction.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|amd64_skip_prologue
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
name|cache
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|pc
operator|=
name|amd64_analyze_prologue
argument_list|(
name|start_pc
argument_list|,
literal|0xffffffffffffffff
argument_list|,
operator|&
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|.
name|frameless_p
condition|)
return|return
name|start_pc
return|;
return|return
name|pc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Normal frames.  */
end_comment

begin_function
specifier|static
name|struct
name|amd64_frame_cache
modifier|*
name|amd64_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
modifier|*
name|cache
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|amd64_alloc_frame_cache
argument_list|()
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|pc
operator|!=
literal|0
condition|)
name|amd64_analyze_prologue
argument_list|(
name|cache
operator|->
name|pc
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|frameless_p
condition|)
block|{
comment|/* We didn't find a valid frame.  If we're at the start of a 	 function, or somewhere half-way its prologue, the function's 	 frame probably hasn't been fully setup yet.  Try to 	 reconstruct the base address for the stack frame by looking 	 at the stack pointer.  For truly "frameless" functions this 	 might work too.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|AMD64_RSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
operator|+
name|cache
operator|->
name|sp_offset
expr_stmt|;
block|}
else|else
block|{
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|AMD64_RBP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Now that we have the base address for the stack frame we can      calculate the value of %rsp in the calling frame.  */
name|cache
operator|->
name|saved_sp
operator|=
name|cache
operator|->
name|base
operator|+
literal|16
expr_stmt|;
comment|/* For normal frames, %rip is stored at 8(%rbp).  If we don't have a      frame we find it at the same offset from the reconstructed base      address.  */
name|cache
operator|->
name|saved_regs
index|[
name|AMD64_RIP_REGNUM
index|]
operator|=
literal|8
expr_stmt|;
comment|/* Adjust all the saved registers such that they contain addresses      instead of offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AMD64_NUM_SAVED_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|+=
name|cache
operator|->
name|base
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|amd64_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
modifier|*
name|cache
init|=
name|amd64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
comment|/* This marks the outermost frame.  */
if|if
condition|(
name|cache
operator|->
name|base
operator|==
literal|0
condition|)
return|return;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
operator|+
literal|16
argument_list|,
name|cache
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amd64_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
modifier|*
name|cache
init|=
name|amd64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
operator|&&
name|cache
operator|->
name|saved_sp
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* Store the value.  */
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|,
name|cache
operator|->
name|saved_sp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|regnum
operator|<
name|AMD64_NUM_SAVED_REGS
operator|&&
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* Read the value in from memory.  */
name|read_memory
argument_list|(
operator|*
name|addrp
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|amd64_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|amd64_frame_this_id
block|,
name|amd64_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|amd64_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|amd64_frame_unwind
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Signal trampolines.  */
end_comment

begin_comment
comment|/* FIXME: kettenis/20030419: Perhaps, we can unify the 32-bit and    64-bit variants.  This would require using identical frame caches    on both platforms.  */
end_comment

begin_function
specifier|static
name|struct
name|amd64_frame_cache
modifier|*
name|amd64_sigtramp_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
modifier|*
name|cache
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|amd64_alloc_frame_cache
argument_list|()
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|AMD64_RSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
operator|-
literal|8
expr_stmt|;
name|addr
operator|=
name|tdep
operator|->
name|sigcontext_addr
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|sc_reg_offset
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|sc_num_regs
operator|<=
name|AMD64_NUM_SAVED_REGS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tdep
operator|->
name|sc_num_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tdep
operator|->
name|sc_reg_offset
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
name|addr
operator|+
name|tdep
operator|->
name|sc_reg_offset
index|[
name|i
index|]
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|amd64_sigtramp_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
modifier|*
name|cache
init|=
name|amd64_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
operator|+
literal|16
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amd64_sigtramp_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
comment|/* Make sure we've initialized the cache.  */
name|amd64_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
expr_stmt|;
name|amd64_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|amd64_sigtramp_frame_unwind
init|=
block|{
name|SIGTRAMP_FRAME
block|,
name|amd64_sigtramp_frame_this_id
block|,
name|amd64_sigtramp_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|amd64_sigtramp_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|gdb_assert
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|sigcontext_addr
argument_list|)
expr_stmt|;
return|return
operator|&
name|amd64_sigtramp_frame_unwind
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|amd64_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|amd64_frame_cache
modifier|*
name|cache
init|=
name|amd64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|cache
operator|->
name|base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|amd64_frame_base
init|=
block|{
operator|&
name|amd64_frame_unwind
block|,
name|amd64_frame_base_address
block|,
name|amd64_frame_base_address
block|,
name|amd64_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|frame_id
name|amd64_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|AMD64_RBP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|frame_id_build
argument_list|(
name|fp
operator|+
literal|16
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* 16 byte align the SP per frame requirements.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|amd64_frame_align
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
return|return
name|sp
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
literal|16
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Supply register REGNUM from the floating-point register set REGSET    to register cache REGCACHE.  If REGNUM is -1, do this for all    registers in REGSET.  */
end_comment

begin_function
specifier|static
name|void
name|amd64_supply_fpregset
parameter_list|(
specifier|const
name|struct
name|regset
modifier|*
name|regset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|fpregs
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|regset
operator|->
name|descr
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|==
name|tdep
operator|->
name|sizeof_fpregset
argument_list|)
expr_stmt|;
name|amd64_supply_fxsave
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the appropriate register set for the core section identified    by SECT_NAME and SECT_SIZE.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|regset
modifier|*
name|amd64_regset_from_core_section
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|size_t
name|sect_size
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg2"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|==
name|tdep
operator|->
name|sizeof_fpregset
condition|)
block|{
if|if
condition|(
name|tdep
operator|->
name|fpregset
operator|==
name|NULL
condition|)
block|{
name|tdep
operator|->
name|fpregset
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|regset
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|fpregset
operator|->
name|descr
operator|=
name|tdep
expr_stmt|;
name|tdep
operator|->
name|fpregset
operator|->
name|supply_regset
operator|=
name|amd64_supply_fpregset
expr_stmt|;
block|}
return|return
name|tdep
operator|->
name|fpregset
return|;
block|}
return|return
name|i386_regset_from_core_section
argument_list|(
name|gdbarch
argument_list|,
name|sect_name
argument_list|,
name|sect_size
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|amd64_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* AMD64 generally uses `fxsave' instead of `fsave' for saving its      floating-point registers.  */
name|tdep
operator|->
name|sizeof_fpregset
operator|=
name|I387_SIZEOF_FXSAVE
expr_stmt|;
comment|/* AMD64 has an FPU and 16 SSE registers.  */
name|tdep
operator|->
name|st0_regnum
operator|=
name|AMD64_ST0_REGNUM
expr_stmt|;
name|tdep
operator|->
name|num_xmm_regs
operator|=
literal|16
expr_stmt|;
comment|/* This is what all the fuss is about.  */
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* In contrast to the i386, on AMD64 a `long double' actually takes      up 128 bits, even though it's still based on the i387 extended      floating-point format which has only 80 significant bits.  */
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|AMD64_NUM_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|amd64_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|amd64_register_type
argument_list|)
expr_stmt|;
comment|/* Register numbers of various important registers.  */
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|AMD64_RSP_REGNUM
argument_list|)
expr_stmt|;
comment|/* %rsp */
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|AMD64_RIP_REGNUM
argument_list|)
expr_stmt|;
comment|/* %rip */
name|set_gdbarch_ps_regnum
argument_list|(
name|gdbarch
argument_list|,
name|AMD64_EFLAGS_REGNUM
argument_list|)
expr_stmt|;
comment|/* %eflags */
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|AMD64_ST0_REGNUM
argument_list|)
expr_stmt|;
comment|/* %st(0) */
comment|/* The "default" register numbering scheme for AMD64 is referred to      as the "DWARF Register Number Mapping" in the System V psABI.      The preferred debugging format for all known AMD64 targets is      actually DWARF2, and GCC doesn't seem to support DWARF (that is      DWARF-1), but we provide the same mapping just in case.  This      mapping is also used for stabs, which GCC does support.  */
name|set_gdbarch_stab_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|amd64_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|amd64_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf2_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|amd64_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
comment|/* We don't override SDB_REG_RO_REGNUM, since COFF doesn't seem to      be in use on any of the supported AMD64 targets.  */
comment|/* Call dummy code.  */
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|amd64_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|amd64_frame_align
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_red_zone_size
argument_list|(
name|gdbarch
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|set_gdbarch_convert_register_p
argument_list|(
name|gdbarch
argument_list|,
name|amd64_convert_register_p
argument_list|)
expr_stmt|;
name|set_gdbarch_register_to_value
argument_list|(
name|gdbarch
argument_list|,
name|i387_register_to_value
argument_list|)
expr_stmt|;
name|set_gdbarch_value_to_register
argument_list|(
name|gdbarch
argument_list|,
name|i387_value_to_register
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|amd64_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|amd64_skip_prologue
argument_list|)
expr_stmt|;
comment|/* Avoid wiring in the MMX registers for now.  */
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mm0_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|amd64_unwind_dummy_id
argument_list|)
expr_stmt|;
comment|/* FIXME: kettenis/20021026: This is ELF-specific.  Fine for now,      since all supported AMD64 targets are ELF, but that might change      in the future.  */
name|set_gdbarch_in_solib_call_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|in_plt_section
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|amd64_sigtramp_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|amd64_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|amd64_frame_base
argument_list|)
expr_stmt|;
comment|/* If we have a register mapping, enable the generic core file support.  */
if|if
condition|(
name|tdep
operator|->
name|gregset_reg_offset
condition|)
name|set_gdbarch_regset_from_core_section
argument_list|(
name|gdbarch
argument_list|,
name|amd64_regset_from_core_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|I387_ST0_REGNUM
value|AMD64_ST0_REGNUM
end_define

begin_comment
comment|/* The 64-bit FXSAVE format differs from the 32-bit format in the    sense that the instruction pointer and data pointer are simply    64-bit offsets into the code segment and the data segment instead    of a selector offset pair.  The functions below store the upper 32    bits of these pointers (instead of just the 16-bits of the segment    selector).  */
end_comment

begin_comment
comment|/* Fill register REGNUM in REGCACHE with the appropriate    floating-point or SSE register value from *FXSAVE.  If REGNUM is    -1, do this for all registers.  This function masks off any of the    reserved bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|amd64_supply_fxsave
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|fxsave
parameter_list|)
block|{
name|i387_supply_fxsave
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|fxsave
argument_list|)
expr_stmt|;
if|if
condition|(
name|fxsave
condition|)
block|{
specifier|const
name|char
modifier|*
name|regs
init|=
name|fxsave
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|I387_FISEG_REGNUM
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|I387_FISEG_REGNUM
argument_list|,
name|regs
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|I387_FOSEG_REGNUM
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|I387_FOSEG_REGNUM
argument_list|,
name|regs
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill register REGNUM (if it is a floating-point or SSE register) in    *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for    all registers.  This function doesn't touch any of the reserved    bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|amd64_collect_fxsave
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|fxsave
parameter_list|)
block|{
name|char
modifier|*
name|regs
init|=
name|fxsave
decl_stmt|;
name|i387_collect_fxsave
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|fxsave
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|I387_FISEG_REGNUM
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|I387_FISEG_REGNUM
argument_list|,
name|regs
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|I387_FOSEG_REGNUM
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|I387_FOSEG_REGNUM
argument_list|,
name|regs
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNUM (if it is a floating-point or SSE register) in    *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do    this for all registers.  This function doesn't touch any of the    reserved bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|amd64_fill_fxsave
parameter_list|(
name|char
modifier|*
name|fxsave
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|amd64_collect_fxsave
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
name|fxsave
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

