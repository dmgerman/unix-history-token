begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB CLI commands.     Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"readline/tilde.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* For baud_rate, remote_debug and remote_timeout */
end_comment

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_comment
comment|/* For shell escape implementation */
end_comment

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_comment
comment|/* Used by apropos_command */
end_comment

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_vfork.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for DOSish file names */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"disasm.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-script.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-setshow.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-cmds.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUI
end_ifdef

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_comment
comment|/* For tui_active et.al.   */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GDBINIT_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|GDBINIT_FILENAME
value|".gdbinit"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local command functions */
end_comment

begin_function_decl
specifier|static
name|void
name|complete_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|echo_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pwd_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_version
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|info_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_debug
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_debug
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_user
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shell_escape
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|edit_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|list_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|apropos_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local utility functions */
end_comment

begin_function_decl
specifier|static
name|void
name|ambiguous_line_spec
parameter_list|(
name|struct
name|symtabs_and_lines
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Limit the call depth of user-defined commands */
end_comment

begin_decl_stmt
name|int
name|max_user_call_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define all cmd_list_elements.  */
end_comment

begin_comment
comment|/* Chain containing all defined commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined info subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|infolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined enable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined disable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|disablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined toggle subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|togglelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined stop subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|stoplist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined delete subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "enable breakpoint" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablebreaklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined set subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined unset subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsetlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined show subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"set history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|sethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"show history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showhistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"unset history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined maintenance subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenancelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "maintenance info" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceinfolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "maintenance print" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setdebuglist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showdebuglist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setchecklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showchecklist
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Utility used everywhere when at least one argument is needed and    none is supplied. */
end_comment

begin_function
name|void
name|error_no_arg
parameter_list|(
name|char
modifier|*
name|why
parameter_list|)
block|{
name|error
argument_list|(
literal|"Argument required (%s)."
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "info" command is defined as a prefix, with allow_unknown = 0.    Therefore, its own definition is called only for "info" with no args.  */
end_comment

begin_function
specifier|static
name|void
name|info_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"info\" must be followed by the name of an info command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|infolist
argument_list|,
literal|"info "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "show" command with no arguments shows all the settings.  */
end_comment

begin_function
specifier|static
name|void
name|show_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide documentation on command or list given by COMMAND.  FROM_TTY    is ignored.  */
end_comment

begin_function
specifier|static
name|void
name|help_command
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|help_cmd
argument_list|(
name|command
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* String compare function for qsort.  */
end_comment

begin_function
specifier|static
name|int
name|compare_strings
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|s1
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|s2
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|*
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The "complete" command is used by Emacs to implement completion.  */
end_comment

begin_function
specifier|static
name|void
name|complete_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|argpoint
decl_stmt|;
name|char
modifier|*
modifier|*
name|completions
decl_stmt|,
modifier|*
name|point
decl_stmt|,
modifier|*
name|arg_prefix
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
literal|""
expr_stmt|;
name|argpoint
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* complete_line assumes that its first argument is somewhere within,      and except for filenames at the beginning of, the word to be completed.      The following crude imitation of readline's word-breaking tries to      accomodate this.  */
name|point
operator|=
name|arg
operator|+
name|argpoint
expr_stmt|;
while|while
condition|(
name|point
operator|>
name|arg
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|point
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|point
operator|--
expr_stmt|;
block|}
name|arg_prefix
operator|=
name|alloca
argument_list|(
name|point
operator|-
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|arg_prefix
argument_list|,
name|arg
argument_list|,
name|point
operator|-
name|arg
argument_list|)
expr_stmt|;
name|arg_prefix
index|[
name|point
operator|-
name|arg
index|]
operator|=
literal|0
expr_stmt|;
name|completions
operator|=
name|complete_line
argument_list|(
name|point
argument_list|,
name|arg
argument_list|,
name|argpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|completions
condition|)
block|{
name|int
name|item
decl_stmt|,
name|size
decl_stmt|;
for|for
control|(
name|size
operator|=
literal|0
init|;
name|completions
index|[
name|size
index|]
condition|;
operator|++
name|size
control|)
empty_stmt|;
name|qsort
argument_list|(
name|completions
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_strings
argument_list|)
expr_stmt|;
comment|/* We do extra processing here since we only want to print each 	 unique item once.  */
name|item
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|item
operator|<
name|size
condition|)
block|{
name|int
name|next_item
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s%s\n"
argument_list|,
name|arg_prefix
argument_list|,
name|completions
index|[
name|item
index|]
argument_list|)
expr_stmt|;
name|next_item
operator|=
name|item
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|next_item
operator|<
name|size
operator|&&
operator|!
name|strcmp
argument_list|(
name|completions
index|[
name|item
index|]
argument_list|,
name|completions
index|[
name|next_item
index|]
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|completions
index|[
name|next_item
index|]
argument_list|)
expr_stmt|;
operator|++
name|next_item
expr_stmt|;
block|}
name|xfree
argument_list|(
name|completions
index|[
name|item
index|]
argument_list|)
expr_stmt|;
name|item
operator|=
name|next_item
expr_stmt|;
block|}
name|xfree
argument_list|(
name|completions
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|is_complete_command
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
return|return
name|cmd_cfunc_eq
argument_list|(
name|c
argument_list|,
name|complete_command
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_version
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the quit command.  */
end_comment

begin_function
name|void
name|quit_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|quit_confirm
argument_list|()
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|quit_force
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pwd_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"The \"pwd\" command does not take an argument: %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|gdb_dirbuf
argument_list|,
name|current_directory
argument_list|)
operator|!=
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"Working directory %s\n (canonically %s).\n"
argument_list|,
name|current_directory
argument_list|,
name|gdb_dirbuf
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Working directory %s.\n"
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cd_command
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Found something other than leading repetitions of "/..".  */
name|int
name|found_real_path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If the new directory is absolute, repeat is a no-op; if relative,      repeat might be useful but is more likely to be a mistake.  */
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"new working directory"
argument_list|)
expr_stmt|;
name|dir
operator|=
name|tilde_expand
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* There's too much mess with DOSish names like "d:", "d:.",      "d:./foo" etc.  Instead of having lots of special #ifdef'ed code,      simply get the canonicalized name of the current directory.  */
name|dir
operator|=
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|dir
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Remove the trailing slash unless this is a root directory          (including a drive letter on non-Unix systems).  */
if|if
condition|(
operator|!
operator|(
name|len
operator|==
literal|1
operator|)
comment|/* "/" */
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
operator|!
operator|(
name|len
operator|==
literal|3
operator|&&
name|dir
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
comment|/* "d:/" */
endif|#
directive|endif
condition|)
name|len
operator|--
expr_stmt|;
block|}
name|dir
operator|=
name|savestring
argument_list|(
name|dir
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|dir
argument_list|)
condition|)
name|current_directory
operator|=
name|dir
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|current_directory
index|[
name|strlen
argument_list|(
name|current_directory
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|SLASH_STRING
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* Now simplify any occurrences of `.' and `..' in the pathname.  */
name|found_real_path
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|current_directory
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|found_real_path
condition|)
block|{
comment|/* Search backwards for the directory just before the "/.." 	         and obliterate it and the "/..".  */
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
name|q
operator|!=
name|current_directory
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|current_directory
condition|)
comment|/* current_directory is 		   a relative pathname ("can't happen"--leave it alone).  */
operator|++
name|p
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|q
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* We are dealing with leading repetitions of "/..", for example 	       "/../..", which is the Mach super-root.  */
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|found_real_path
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
name|forget_cached_source_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|pwd_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|source_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|args
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"source command requires pathname of file to source."
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|tilde_expand
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
name|FOPEN_RT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|perror_with_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
name|script_from_file
argument_list|(
name|stream
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|echo_command
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|text
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|text
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 	       so they won't be lost.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Force this output to appear now.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shell_escape
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CANT_FORK
comment|/* If ARG is NULL, they want an inferior shell, but `system' just      reports if the shell is available when passed a NULL arg.  */
name|int
name|rc
init|=
name|system
argument_list|(
name|arg
condition|?
name|arg
else|:
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|arg
operator|=
literal|"inferior shell"
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot execute %s: %s\n"
argument_list|,
name|arg
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s exited with status %d\n"
argument_list|,
name|arg
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GLOBAL_CURDIR
comment|/* Make sure to return to the directory GDB thinks it is, in case the      shell command we just ran changed it.  */
name|chdir
argument_list|(
name|current_directory
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Can fork.  */
name|int
name|rc
decl_stmt|,
name|status
decl_stmt|,
name|pid
decl_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|user_shell
decl_stmt|;
if|if
condition|(
operator|(
name|user_shell
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|user_shell
operator|=
literal|"/bin/sh"
expr_stmt|;
comment|/* Get the name of the shell for arg0 */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|user_shell
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|user_shell
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* Get past '/' */
if|if
condition|(
operator|!
name|arg
condition|)
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
literal|"-c"
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot execute %s: %s\n"
argument_list|,
name|user_shell
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
while|while
condition|(
operator|(
name|rc
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|rc
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
else|else
name|error
argument_list|(
literal|"Fork failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Can fork.  */
block|}
end_function

begin_function
specifier|static
name|void
name|edit_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|log10
decl_stmt|;
name|unsigned
name|m
decl_stmt|;
name|char
modifier|*
name|editor
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pull in the current default source line if necessary */
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|set_default_source_symtab_and_line
argument_list|()
expr_stmt|;
name|sal
operator|=
name|get_current_source_symtab_and_line
argument_list|()
expr_stmt|;
block|}
comment|/* bare "edit" edits file with present line.  */
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet."
argument_list|)
expr_stmt|;
name|sal
operator|.
name|line
operator|+=
name|get_lines_to_list
argument_list|()
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Now should only be one argument -- decode it in SAL */
name|arg1
operator|=
name|arg
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/*  C++  */
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification."
argument_list|)
expr_stmt|;
comment|/* if line was specified by address,          first print exactly which line, and which file.          In this case, sal.symtab == 0 means address is outside          of all known source files, not that user failed to give a filename.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
comment|/* FIXME-32x64--assumes sal.pc fits in long.  */
name|error
argument_list|(
literal|"No source file for address %s."
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|sal
operator|.
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|print_address_numeric
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is in "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" (%s:%d).\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_address_numeric
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is at %s:%d.\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If what was given does not imply a symtab, it must be an undebuggable          symbol which means no source code.  */
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line number known for %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|editor
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|editor
operator|=
literal|"/bin/ex"
expr_stmt|;
comment|/* Approximate base-10 log of line to 1 unit for digit count */
for|for
control|(
name|log10
operator|=
literal|32
operator|,
name|m
operator|=
literal|0x80000000
init|;
operator|!
operator|(
name|sal
operator|.
name|line
operator|&
name|m
operator|)
operator|&&
name|log10
operator|>
literal|0
condition|;
name|log10
operator|--
operator|,
name|m
operator|=
name|m
operator|>>
literal|1
control|)
empty_stmt|;
name|log10
operator|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
operator|(
name|log10
operator|+
operator|(
literal|0
operator|==
operator|(
operator|(
name|m
operator|-
literal|1
operator|)
operator|&
name|sal
operator|.
name|line
operator|)
operator|)
operator|)
operator|/
literal|3.32192809
argument_list|)
expr_stmt|;
name|cmdlen
operator|=
name|strlen
argument_list|(
name|editor
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|NULL
operator|==
name|sal
operator|.
name|symtab
operator|->
name|dirname
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|dirname
argument_list|)
operator|+
literal|1
operator|)
operator|+
operator|(
name|NULL
operator|==
name|sal
operator|.
name|symtab
operator|->
name|filename
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|+
literal|1
operator|)
operator|+
name|log10
operator|+
literal|2
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|cmdlen
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s +%d %s%s"
argument_list|,
name|editor
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|(
name|NULL
operator|==
name|sal
operator|.
name|symtab
operator|->
name|dirname
condition|?
literal|"./"
else|:
operator|(
name|NULL
operator|!=
name|sal
operator|.
name|symtab
operator|->
name|filename
operator|&&
operator|*
operator|(
name|sal
operator|.
name|symtab
operator|->
name|filename
operator|)
operator|!=
literal|'/'
operator|)
condition|?
name|sal
operator|.
name|symtab
operator|->
name|dirname
else|:
literal|""
operator|)
argument_list|,
operator|(
name|NULL
operator|==
name|sal
operator|.
name|symtab
operator|->
name|filename
condition|?
literal|"unknown"
else|:
name|sal
operator|.
name|symtab
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
name|shell_escape
argument_list|(
name|p
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|,
name|sals_end
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|,
name|sal_end
decl_stmt|,
name|cursal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
name|int
name|no_end
init|=
literal|1
decl_stmt|;
name|int
name|dummy_end
init|=
literal|0
decl_stmt|;
name|int
name|dummy_beg
init|=
literal|0
decl_stmt|;
name|int
name|linenum_beg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pull in the current default source line if necessary */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|set_default_source_symtab_and_line
argument_list|()
expr_stmt|;
name|cursal
operator|=
name|get_current_source_symtab_and_line
argument_list|()
expr_stmt|;
block|}
comment|/* "l" or "l +" lists next ten lines.  */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"+"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|print_source_lines
argument_list|(
name|cursal
operator|.
name|symtab
argument_list|,
name|cursal
operator|.
name|line
argument_list|,
name|cursal
operator|.
name|line
operator|+
name|get_lines_to_list
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* "l -" lists previous ten lines, the ones before the ten just listed.  */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|print_source_lines
argument_list|(
name|cursal
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|get_first_line_listed
argument_list|()
operator|-
name|get_lines_to_list
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|,
name|get_first_line_listed
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now if there is only one argument, decode it in SAL      and set NO_END.      If there are two arguments, decode them in SAL and SAL_END      and clear NO_END; however, if one of the arguments is blank,      set DUMMY_BEG or DUMMY_END to record that fact.  */
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
name|dummy_beg
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/*  C++  */
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
comment|/* Record whether the BEG arg is all digits.  */
for|for
control|(
name|p
operator|=
name|arg
init|;
name|p
operator|!=
name|arg1
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|linenum_beg
operator|=
operator|(
name|p
operator|==
name|arg1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
block|{
name|no_end
operator|=
literal|0
expr_stmt|;
name|arg1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|0
condition|)
name|dummy_end
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dummy_beg
condition|)
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals_end
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal_end
operator|=
name|sals_end
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|xfree
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|arg1
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_end
operator|&&
operator|!
name|dummy_beg
operator|&&
operator|!
name|dummy_end
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|sal_end
operator|.
name|symtab
condition|)
name|error
argument_list|(
literal|"Specified start and end are in different files."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|dummy_end
condition|)
name|error
argument_list|(
literal|"Two empty args do not say what lines to list."
argument_list|)
expr_stmt|;
comment|/* if line was specified by address,      first print exactly which line, and which file.      In this case, sal.symtab == 0 means address is outside      of all known source files, not that user failed to give a filename.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
comment|/* FIXME-32x64--assumes sal.pc fits in long.  */
name|error
argument_list|(
literal|"No source file for address %s."
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|sal
operator|.
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|print_address_numeric
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is in "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" (%s:%d).\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_address_numeric
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is at %s:%d.\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If line was not specified by just a line number,      and it does not imply a symtab, it must be an undebuggable symbol      which means no source code.  */
if|if
condition|(
operator|!
name|linenum_beg
operator|&&
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line number known for %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* If this command is repeated with RET,      turn it into the no-arg variant.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|arg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|sal_end
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
condition|)
name|print_source_lines
argument_list|(
name|sal_end
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal_end
operator|.
name|line
operator|-
operator|(
name|get_lines_to_list
argument_list|()
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal_end
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|no_end
condition|)
block|{
name|int
name|first_line
init|=
name|sal
operator|.
name|line
operator|-
name|get_lines_to_list
argument_list|()
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|first_line
operator|<
literal|1
condition|)
name|first_line
operator|=
literal|1
expr_stmt|;
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|first_line
argument_list|,
name|first_line
operator|+
name|get_lines_to_list
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|(
name|dummy_end
condition|?
name|sal
operator|.
name|line
operator|+
name|get_lines_to_list
argument_list|()
else|:
name|sal_end
operator|.
name|line
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a specified section of assembly code.  With no command line    arguments, this command will dump the assembly code for the    function surrounding the pc value in the selected frame.  With one    argument, it will dump the assembly code surrounding that pc value.    Two arguments are interpeted as bounds within which to dump    assembly.  */
end_comment

begin_function
specifier|static
name|void
name|disassemble_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|,
name|pc_masked
decl_stmt|;
name|char
modifier|*
name|space_index
decl_stmt|;
if|#
directive|if
literal|0
block|asection *section;
endif|#
directive|endif
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
if|if
condition|(
operator|!
name|deprecated_selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected.\n"
argument_list|)
expr_stmt|;
name|pc
operator|=
name|get_frame_pc
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No function contains program counter for selected frame.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
comment|/* NOTE: cagney/2003-02-13 The `tui_active' was previously 	 `tui_version'.  */
if|if
condition|(
name|tui_active
condition|)
comment|/* FIXME: cagney/2004-02-07: This should be an observer.  */
name|low
operator|=
name|tui_get_low_disassembly_address
argument_list|(
name|low
argument_list|,
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|low
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|space_index
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
block|{
comment|/* One argument.  */
name|pc
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No function contains specified address.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
comment|/* NOTE: cagney/2003-02-13 The `tui_active' was previously 	 `tui_version'.  */
if|if
condition|(
name|tui_active
condition|)
comment|/* FIXME: cagney/2004-02-07: This should be an observer.  */
name|low
operator|=
name|tui_get_low_disassembly_address
argument_list|(
name|low
argument_list|,
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|low
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
block|}
else|else
block|{
comment|/* Two arguments.  */
operator|*
name|space_index
operator|=
literal|'\0'
expr_stmt|;
name|low
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|high
operator|=
name|parse_and_eval_address
argument_list|(
name|space_index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
operator|!
name|tui_is_window_visible
argument_list|(
name|DISASSEM_WIN
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|printf_filtered
argument_list|(
literal|"Dump of assembler code "
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"for function %s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"from "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|low
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" to "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|high
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the specified range.  */
name|gdb_disassembly
argument_list|(
name|uiout
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"End of assembler dump.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
else|else
block|{
name|tui_show_assembly
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|make_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|p
operator|=
literal|"make"
expr_stmt|;
else|else
block|{
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"make "
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"make "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
literal|"make "
argument_list|)
operator|-
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|shell_escape
argument_list|(
name|p
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_user
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|args
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
name|class_user
condition|)
name|error
argument_list|(
literal|"Not a user command."
argument_list|)
expr_stmt|;
name|show_user_1
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|c
operator|=
name|cmdlist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|show_user_1
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Search through names of commands and documentations for a certain    regular expression. */
end_comment

begin_function
name|void
name|apropos_command
parameter_list|(
name|char
modifier|*
name|searchstr
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
comment|/*This is the main command list*/
name|regex_t
name|pattern
decl_stmt|;
name|char
modifier|*
name|pattern_fastmap
decl_stmt|;
name|char
name|errorbuffer
index|[
literal|512
index|]
decl_stmt|;
name|pattern_fastmap
operator|=
name|xcalloc
argument_list|(
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchstr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"REGEXP string is empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|pattern
argument_list|,
name|searchstr
argument_list|,
name|REG_ICASE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pattern
operator|.
name|fastmap
operator|=
name|pattern_fastmap
expr_stmt|;
name|re_compile_fastmap
argument_list|(
operator|&
name|pattern
argument_list|)
expr_stmt|;
name|apropos_cmd
argument_list|(
name|gdb_stdout
argument_list|,
name|cmdlist
argument_list|,
operator|&
name|pattern
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regerror
argument_list|(
name|regcomp
argument_list|(
operator|&
name|pattern
argument_list|,
name|searchstr
argument_list|,
name|REG_ICASE
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|errorbuffer
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Error in regular expression:%s"
argument_list|,
name|errorbuffer
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|pattern_fastmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a list of files and line numbers which a user may choose from    in order to list a function which was specified ambiguously (as with    `list classname::overloadedfuncname', for example).  The vector in    SALS provides the filenames and line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|ambiguous_line_spec
parameter_list|(
name|struct
name|symtabs_and_lines
modifier|*
name|sals
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|printf_filtered
argument_list|(
literal|"file: \"%s\", line number: %d\n"
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_debug
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set debug\" must be followed by the name of a print subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setdebuglist
argument_list|,
literal|"set debug "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_debug
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showdebuglist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_cmd_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|max_user_call_depth
operator|=
literal|1024
expr_stmt|;
name|cmdlist
operator|=
name|NULL
expr_stmt|;
name|infolist
operator|=
name|NULL
expr_stmt|;
name|enablelist
operator|=
name|NULL
expr_stmt|;
name|disablelist
operator|=
name|NULL
expr_stmt|;
name|togglelist
operator|=
name|NULL
expr_stmt|;
name|stoplist
operator|=
name|NULL
expr_stmt|;
name|deletelist
operator|=
name|NULL
expr_stmt|;
name|enablebreaklist
operator|=
name|NULL
expr_stmt|;
name|setlist
operator|=
name|NULL
expr_stmt|;
name|unsetlist
operator|=
name|NULL
expr_stmt|;
name|showlist
operator|=
name|NULL
expr_stmt|;
name|sethistlist
operator|=
name|NULL
expr_stmt|;
name|showhistlist
operator|=
name|NULL
expr_stmt|;
name|unsethistlist
operator|=
name|NULL
expr_stmt|;
name|maintenancelist
operator|=
name|NULL
expr_stmt|;
name|maintenanceinfolist
operator|=
name|NULL
expr_stmt|;
name|maintenanceprintlist
operator|=
name|NULL
expr_stmt|;
name|setprintlist
operator|=
name|NULL
expr_stmt|;
name|showprintlist
operator|=
name|NULL
expr_stmt|;
name|setchecklist
operator|=
name|NULL
expr_stmt|;
name|showchecklist
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_cli_cmds
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
comment|/* Define the classes of commands.      They will appear in the help list in the reverse of this order.  */
name|add_cmd
argument_list|(
literal|"internals"
argument_list|,
name|class_maintenance
argument_list|,
name|NULL
argument_list|,
literal|"Maintenance commands.\n\ Some gdb commands are provided just for use by gdb maintainers.\n\ These commands are subject to frequent change, and may not be as\n\ well documented as user commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"obscure"
argument_list|,
name|class_obscure
argument_list|,
name|NULL
argument_list|,
literal|"Obscure features."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"aliases"
argument_list|,
name|class_alias
argument_list|,
name|NULL
argument_list|,
literal|"Aliases of other commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user-defined"
argument_list|,
name|class_user
argument_list|,
name|NULL
argument_list|,
literal|"User-defined commands.\n\ The commands in this class are those defined by the user.\n\ Use the \"define\" command to define a command."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"support"
argument_list|,
name|class_support
argument_list|,
name|NULL
argument_list|,
literal|"Support facilities."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbx_commands
condition|)
name|add_cmd
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
name|NULL
argument_list|,
literal|"Status inquiries."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"files"
argument_list|,
name|class_files
argument_list|,
name|NULL
argument_list|,
literal|"Specifying and examining files."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|NULL
argument_list|,
literal|"Making program stop at certain points."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"data"
argument_list|,
name|class_vars
argument_list|,
name|NULL
argument_list|,
literal|"Examining data."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stack"
argument_list|,
name|class_stack
argument_list|,
name|NULL
argument_list|,
literal|"Examining the stack.\n\ The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\ counting from zero for the innermost (currently executing) frame.\n\n\ At any time gdb identifies one frame as the \"selected\" frame.\n\ Variable lookups are done with respect to the selected frame.\n\ When the program being debugged stops, gdb selects the innermost frame.\n\ The commands below can be used to select other frames by number or address."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"running"
argument_list|,
name|class_run
argument_list|,
name|NULL
argument_list|,
literal|"Running the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* Define general commands. */
name|add_com
argument_list|(
literal|"pwd"
argument_list|,
name|class_files
argument_list|,
name|pwd_command
argument_list|,
literal|"Print working directory.  This is used for your program as well."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"cd"
argument_list|,
name|class_files
argument_list|,
name|cd_command
argument_list|,
literal|"Set working directory to DIR for debugger and program being debugged.\n\ The change does not take effect for the program being debugged\n\ until the next time it is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"echo"
argument_list|,
name|class_support
argument_list|,
name|echo_command
argument_list|,
literal|"Print a constant string.  Give string as argument.\n\ C escape sequences may be used in the argument.\n\ No newline is added at the end of the argument;\n\ use \"\\n\" if you want a newline to be printed.\n\ Since leading and trailing whitespace are ignored in command arguments,\n\ if you want to print some you must use \"\\\" before leading whitespace\n\ to be printed or after trailing whitespace."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"document"
argument_list|,
name|class_support
argument_list|,
name|document_command
argument_list|,
literal|"Document a user-defined command.\n\ Give command name as argument.  Give documentation on following lines.\n\ End with a line of just \"end\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"define"
argument_list|,
name|class_support
argument_list|,
name|define_command
argument_list|,
literal|"Define a new command name.  Command name is argument.\n\ Definition appears on following lines, one command per line.\n\ End with a line of just \"end\".\n\ Use the \"document\" command to give documentation for the new command.\n\ Commands defined in this way may have up to ten arguments."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \""
name|GDBINIT_FILENAME
literal|"\" is read automatically in this way\n\ when gdb is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"quit"
argument_list|,
name|class_support
argument_list|,
name|quit_command
argument_list|,
literal|"Exit gdb."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"help"
argument_list|,
name|class_support
argument_list|,
name|help_command
argument_list|,
literal|"Print list of commands."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|command_completer
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"q"
argument_list|,
literal|"quit"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"verbose"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|info_verbose
argument_list|,
literal|"Set "
argument_list|,
operator|&
name|setlist
argument_list|)
operator|,
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_verbose
argument_list|)
expr_stmt|;
name|set_verbose
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|set_history
argument_list|,
literal|"Generic command for setting command history parameters."
argument_list|,
operator|&
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|show_history
argument_list|,
literal|"Generic command for showing command history parameters."
argument_list|,
operator|&
name|showhistlist
argument_list|,
literal|"show history "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"expansion"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_expansion_p
argument_list|,
literal|"Set history expansion on command input.\n\ Without an argument, history expansion is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"info"
argument_list|,
name|class_info
argument_list|,
name|info_command
argument_list|,
literal|"Generic command for showing things about the program being debugged."
argument_list|,
operator|&
name|infolist
argument_list|,
literal|"info "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"i"
argument_list|,
literal|"info"
argument_list|,
name|class_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"complete"
argument_list|,
name|class_obscure
argument_list|,
name|complete_command
argument_list|,
literal|"List the completions for the rest of the line as a command."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"show"
argument_list|,
name|class_info
argument_list|,
name|show_command
argument_list|,
literal|"Generic command for showing things about the debugger."
argument_list|,
operator|&
name|showlist
argument_list|,
literal|"show "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* Another way to get at the same thing.  */
name|add_info
argument_list|(
literal|"set"
argument_list|,
name|show_command
argument_list|,
literal|"Show all GDB settings."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"commands"
argument_list|,
name|no_class
argument_list|,
name|show_commands
argument_list|,
literal|"Show the history of commands you typed.\n\ You can supply a command number to start with, or a `+' to start after\n\ the previous command number shown."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"version"
argument_list|,
name|no_class
argument_list|,
name|show_version
argument_list|,
literal|"Show what version of GDB this is."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"while"
argument_list|,
name|class_support
argument_list|,
name|while_command
argument_list|,
literal|"Execute nested commands WHILE the conditional expression is non zero.\n\ The conditional expression must follow the word `while' and must in turn be\n\ followed by a new line.  The nested commands must be entered one per line,\n\ and should be terminated by the word `end'."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"if"
argument_list|,
name|class_support
argument_list|,
name|if_command
argument_list|,
literal|"Execute nested commands once IF the conditional expression is non zero.\n\ The conditional expression must follow the word `if' and must in turn be\n\ followed by a new line.  The nested commands must be entered one per line,\n\ and should be terminated by the word 'else' or `end'.  If an else clause\n\ is used, the same rules apply to its nested commands as to the first ones."
argument_list|)
expr_stmt|;
comment|/* If target is open when baud changes, it doesn't take effect until the      next open (I think, not sure).  */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotebaud"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|baud_rate
argument_list|,
literal|"Set baud rate for remote serial I/O.\n\ This value is used to set the speed of the serial port when debugging\n\ using remote targets."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"remotedebug"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_debug
argument_list|,
literal|"Set debugging of remote protocol.\n\ When enabled, each packet sent or received with the remote target\n\ is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|c
argument_list|,
literal|"set debug remote"
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
argument_list|,
literal|"show debug remote"
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remote"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_debug
argument_list|,
literal|"Set debugging of remote protocol.\n\ When enabled, each packet sent or received with the remote target\n\ is displayed."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotetimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_timeout
argument_list|,
literal|"Set timeout limit to wait for target to respond.\n\ This value is used to set the time limit for gdb to wait for a response\n\ from the target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"debug"
argument_list|,
name|no_class
argument_list|,
name|set_debug
argument_list|,
literal|"Generic command for setting gdb debugging flags"
argument_list|,
operator|&
name|setdebuglist
argument_list|,
literal|"set debug "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"debug"
argument_list|,
name|no_class
argument_list|,
name|show_debug
argument_list|,
literal|"Generic command for showing gdb debugging flags"
argument_list|,
operator|&
name|showdebuglist
argument_list|,
literal|"show debug "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"shell"
argument_list|,
name|class_support
argument_list|,
name|shell_escape
argument_list|,
literal|"Execute the rest of the line as a shell command.\n\ With no arguments, run an inferior shell."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"edit"
argument_list|,
name|class_files
argument_list|,
name|edit_command
argument_list|,
name|concat
argument_list|(
literal|"Edit specified file or function.\n\ With no argument, edits file containing most recent line listed.\n\ "
argument_list|,
literal|"\ Editing targets can be specified in these ways:\n\   FILE:LINENUM, to edit at that line in that file,\n\   FUNCTION, to edit at the beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\   *ADDRESS, to edit at the line containing that address.\n\ Uses EDITOR environment variable contents as editor (or ex as default)."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|location_completer
expr_stmt|;
name|add_com
argument_list|(
literal|"list"
argument_list|,
name|class_files
argument_list|,
name|list_command
argument_list|,
name|concat
argument_list|(
literal|"List specified function or line.\n\ With no argument, lists ten more lines after or around previous listing.\n\ \"list -\" lists the ten lines before a previous ten-line listing.\n\ One argument specifies a line, and ten lines are listed around that line.\n\ Two arguments with comma between specify starting and ending lines to list.\n\ "
argument_list|,
literal|"\ Lines can be specified in these ways:\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\   *ADDRESS, to list around the line containing that address.\n\ With two args if one is empty it stands for ten lines away from the other arg."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"l"
argument_list|,
literal|"list"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|add_com_alias
argument_list|(
literal|"v"
argument_list|,
literal|"list"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com_alias
argument_list|(
literal|"file"
argument_list|,
literal|"list"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"disassemble"
argument_list|,
name|class_vars
argument_list|,
name|disassemble_command
argument_list|,
literal|"Disassemble a specified section of memory.\n\ Default is the function surrounding the pc of the selected frame.\n\ With a single argument, the function surrounding that address is dumped.\n\ Two arguments are taken as a range of memory to dump."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"va"
argument_list|,
literal|"disassemble"
argument_list|,
name|class_xdb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2000-03-20: Being able to enter ``(gdb) !ls'' would      be a really useful feature.  Unfortunately, the below wont do      this.  Instead it adds support for the form ``(gdb) ! ls''      (i.e. the space is required).  If the ``!'' command below is      added the complains about no ``!'' command would be replaced by      complains about how the ``!'' command is broken :-) */
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"!"
argument_list|,
literal|"shell"
argument_list|,
name|class_support
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"make"
argument_list|,
name|class_support
argument_list|,
name|make_command
argument_list|,
literal|"Run the ``make'' program using the rest of the line as arguments."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user"
argument_list|,
name|no_class
argument_list|,
name|show_user
argument_list|,
literal|"Show definitions of user defined commands.\n\ Argument is the name of the user defined command.\n\ With no argument, show definitions of all user defined commands."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"apropos"
argument_list|,
name|class_support
argument_list|,
name|apropos_command
argument_list|,
literal|"Search for commands matching a REGEXP"
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"max-user-call-depth"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|max_user_call_depth
argument_list|,
literal|"Set the max call depth for user-defined commands.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

