begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines for name->symbol lookups in GDB.        Copyright 2003 Free Software Foundation, Inc.     Contributed by David Carlton<carlton@bactrian.org> and by Kealia,    Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or (at    your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_comment
comment|/* This file implements dictionaries, which are tables that associate    symbols to names.  They are represented by an opaque type 'struct    dictionary'.  That type has various internal implementations, which    you can choose between depending on what properties you need    (e.g. fast lookup, order-preserving, expandable).     Each dictionary starts with a 'virtual function table' that    contains the functions that actually implement the various    operations that dictionaries provide.  (Note, however, that, for    the sake of client code, we also provide some functions that can be    implemented generically in terms of the functions in the vtable.)     To add a new dictionary implementation<impl>, what you should do    is:     * Add a new element DICT_<IMPL> to dict_type.        * Create a new structure dictionary_<impl>.  If your new    implementation is a variant of an existing one, make sure that    their structs have the same initial data members.  Define accessor    macros for your new data members.     * Implement all the functions in dict_vector as static functions,    whose name is the same as the corresponding member of dict_vector    plus _<impl>.  You don't have to do this for those members where    you can reuse existing generic functions    (e.g. add_symbol_nonexpandable, free_obstack) or in the case where    your new implementation is a variant of an existing implementation    and where the variant doesn't affect the member function in    question.     * Define a static const struct dict_vector dict_<impl>_vector.     * Define a function dict_create_<impl> to create these    gizmos.  Add its declaration to dictionary.h.     To add a new operation<op> on all existing implementations, what    you should do is:     * Add a new member<op> to struct dict_vector.     * If there is useful generic behavior<op>, define a static    function<op>_something_informative that implements that behavior.    (E.g. add_symbol_nonexpandable, free_obstack.)     * For every implementation<impl> that should have its own specific    behavior for<op>, define a static function<op>_<impl>    implementing it.     * Modify all existing dict_vector_<impl>'s to include the appropriate    member.     * Define a function dict_<op> that looks up<op> in the dict_vector    and calls the appropriate function.  Add a declaration for    dict_<op> to dictionary.h.     */
end_comment

begin_comment
comment|/* An enum representing the various implementations of dictionaries.    Used only for debugging.  */
end_comment

begin_enum
enum|enum
name|dict_type
block|{
comment|/* Symbols are stored in a fixed-size hash table.  */
name|DICT_HASHED
block|,
comment|/* Symbols are stored in an expandable hash table.  */
name|DICT_HASHED_EXPANDABLE
block|,
comment|/* Symbols are stored in a fixed-size array.  */
name|DICT_LINEAR
block|,
comment|/* Symbols are stored in an expandable array.  */
name|DICT_LINEAR_EXPANDABLE
block|}
enum|;
end_enum

begin_comment
comment|/* The virtual function table.  */
end_comment

begin_struct
struct|struct
name|dict_vector
block|{
comment|/* The type of the dictionary.  This is only here to make debugging      a bit easier; it's not actually used.  */
name|enum
name|dict_type
name|type
decl_stmt|;
comment|/* The function to free a dictionary.  */
name|void
function_decl|(
modifier|*
name|free
function_decl|)
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
comment|/* Add a symbol to a dictionary, if possible.  */
name|void
function_decl|(
modifier|*
name|add_symbol
function_decl|)
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
function_decl|;
comment|/* Iterator functions.  */
name|struct
name|symbol
modifier|*
function_decl|(
modifier|*
name|iterator_first
function_decl|)
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
name|struct
name|symbol
modifier|*
function_decl|(
modifier|*
name|iterator_next
function_decl|)
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
comment|/* Functions to iterate over symbols with a given name.  */
name|struct
name|symbol
modifier|*
function_decl|(
modifier|*
name|iter_name_first
function_decl|)
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
name|struct
name|symbol
modifier|*
function_decl|(
modifier|*
name|iter_name_next
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
comment|/* A size function, for maint print symtabs.  */
name|int
function_decl|(
modifier|*
name|size
function_decl|)
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Now comes the structs used to store the data for different    implementations.  If two implementations have data in common, put    the common data at the top of their structs, ordered in the same    way.  */
end_comment

begin_struct
struct|struct
name|dictionary_hashed
block|{
name|int
name|nbuckets
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|buckets
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dictionary_hashed_expandable
block|{
comment|/* How many buckets we currently have.  */
name|int
name|nbuckets
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|buckets
decl_stmt|;
comment|/* How many syms we currently have; we need this so we will know      when to add more buckets.  */
name|int
name|nsyms
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dictionary_linear
block|{
name|int
name|nsyms
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|syms
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dictionary_linear_expandable
block|{
comment|/* How many symbols we currently have.  */
name|int
name|nsyms
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|syms
decl_stmt|;
comment|/* How many symbols we can store before needing to reallocate.  */
name|int
name|capacity
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* And now, the star of our show.  */
end_comment

begin_struct
struct|struct
name|dictionary
block|{
specifier|const
name|struct
name|dict_vector
modifier|*
name|vector
decl_stmt|;
union|union
block|{
name|struct
name|dictionary_hashed
name|hashed
decl_stmt|;
name|struct
name|dictionary_hashed_expandable
name|hashed_expandable
decl_stmt|;
name|struct
name|dictionary_linear
name|linear
decl_stmt|;
name|struct
name|dictionary_linear_expandable
name|linear_expandable
decl_stmt|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Accessor macros.  */
end_comment

begin_define
define|#
directive|define
name|DICT_VECTOR
parameter_list|(
name|d
parameter_list|)
value|(d)->vector
end_define

begin_comment
comment|/* These can be used for DICT_HASHED_EXPANDABLE, too.  */
end_comment

begin_define
define|#
directive|define
name|DICT_HASHED_NBUCKETS
parameter_list|(
name|d
parameter_list|)
value|(d)->data.hashed.nbuckets
end_define

begin_define
define|#
directive|define
name|DICT_HASHED_BUCKETS
parameter_list|(
name|d
parameter_list|)
value|(d)->data.hashed.buckets
end_define

begin_define
define|#
directive|define
name|DICT_HASHED_BUCKET
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|)
value|DICT_HASHED_BUCKETS (d) [i]
end_define

begin_define
define|#
directive|define
name|DICT_HASHED_EXPANDABLE_NSYMS
parameter_list|(
name|d
parameter_list|)
value|(d)->data.hashed_expandable.nsyms
end_define

begin_comment
comment|/* These can be used for DICT_LINEAR_EXPANDABLEs, too.  */
end_comment

begin_define
define|#
directive|define
name|DICT_LINEAR_NSYMS
parameter_list|(
name|d
parameter_list|)
value|(d)->data.linear.nsyms
end_define

begin_define
define|#
directive|define
name|DICT_LINEAR_SYMS
parameter_list|(
name|d
parameter_list|)
value|(d)->data.linear.syms
end_define

begin_define
define|#
directive|define
name|DICT_LINEAR_SYM
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|)
value|DICT_LINEAR_SYMS (d) [i]
end_define

begin_define
define|#
directive|define
name|DICT_LINEAR_EXPANDABLE_CAPACITY
parameter_list|(
name|d
parameter_list|)
define|\
value|(d)->data.linear_expandable.capacity
end_define

begin_comment
comment|/* The initial size of a DICT_*_EXPANDABLE dictionary.  */
end_comment

begin_define
define|#
directive|define
name|DICT_EXPANDABLE_INITIAL_CAPACITY
value|10
end_define

begin_comment
comment|/* This calculates the number of buckets we'll use in a hashtable,    given the number of symbols that it will contain.  */
end_comment

begin_define
define|#
directive|define
name|DICT_HASHTABLE_SIZE
parameter_list|(
name|n
parameter_list|)
value|((n)/5 + 1)
end_define

begin_comment
comment|/* Accessor macros for dict_iterators; they're here rather than    dictionary.h because code elsewhere should treat dict_iterators as    opaque.  */
end_comment

begin_comment
comment|/* The dictionary that the iterator is associated to.  */
end_comment

begin_define
define|#
directive|define
name|DICT_ITERATOR_DICT
parameter_list|(
name|iter
parameter_list|)
value|(iter)->dict
end_define

begin_comment
comment|/* For linear dictionaries, the index of the last symbol returned; for    hashed dictionaries, the bucket of the last symbol returned.  */
end_comment

begin_define
define|#
directive|define
name|DICT_ITERATOR_INDEX
parameter_list|(
name|iter
parameter_list|)
value|(iter)->index
end_define

begin_comment
comment|/* For hashed dictionaries, this points to the last symbol returned;    otherwise, this is unused.  */
end_comment

begin_define
define|#
directive|define
name|DICT_ITERATOR_CURRENT
parameter_list|(
name|iter
parameter_list|)
value|(iter)->current
end_define

begin_comment
comment|/* Declarations of functions for vectors.  */
end_comment

begin_comment
comment|/* Functions that might work across a range of dictionary types.  */
end_comment

begin_function_decl
specifier|static
name|void
name|add_symbol_nonexpandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_obstack
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for DICT_HASHED and DICT_HASHED_EXPANDABLE    dictionaries.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_first_hashed
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_next_hashed
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_first_hashed
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_next_hashed
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions only for DICT_HASHED.  */
end_comment

begin_function_decl
specifier|static
name|int
name|size_hashed
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions only for DICT_HASHED_EXPANDABLE.  */
end_comment

begin_function_decl
specifier|static
name|void
name|free_hashed_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_symbol_hashed_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|size_hashed_expandable
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for DICT_LINEAR and DICT_LINEAR_EXPANDABLE    dictionaries.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_first_linear
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_next_linear
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_first_linear
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_next_linear
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|size_linear
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions only for DICT_LINEAR_EXPANDABLE.  */
end_comment

begin_function_decl
specifier|static
name|void
name|free_linear_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_symbol_linear_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Various vectors that we'll actually use.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dict_vector
name|dict_hashed_vector
init|=
block|{
name|DICT_HASHED
block|,
comment|/* type */
name|free_obstack
block|,
comment|/* free */
name|add_symbol_nonexpandable
block|,
comment|/* add_symbol */
name|iterator_first_hashed
block|,
comment|/* iteractor_first */
name|iterator_next_hashed
block|,
comment|/* iterator_next */
name|iter_name_first_hashed
block|,
comment|/* iter_name_first */
name|iter_name_next_hashed
block|,
comment|/* iter_name_next */
name|size_hashed
block|,
comment|/* size */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dict_vector
name|dict_hashed_expandable_vector
init|=
block|{
name|DICT_HASHED_EXPANDABLE
block|,
comment|/* type */
name|free_hashed_expandable
block|,
comment|/* free */
name|add_symbol_hashed_expandable
block|,
comment|/* add_symbol */
name|iterator_first_hashed
block|,
comment|/* iteractor_first */
name|iterator_next_hashed
block|,
comment|/* iterator_next */
name|iter_name_first_hashed
block|,
comment|/* iter_name_first */
name|iter_name_next_hashed
block|,
comment|/* iter_name_next */
name|size_hashed_expandable
block|,
comment|/* size */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dict_vector
name|dict_linear_vector
init|=
block|{
name|DICT_LINEAR
block|,
comment|/* type */
name|free_obstack
block|,
comment|/* free */
name|add_symbol_nonexpandable
block|,
comment|/* add_symbol */
name|iterator_first_linear
block|,
comment|/* iteractor_first */
name|iterator_next_linear
block|,
comment|/* iterator_next */
name|iter_name_first_linear
block|,
comment|/* iter_name_first */
name|iter_name_next_linear
block|,
comment|/* iter_name_next */
name|size_linear
block|,
comment|/* size */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dict_vector
name|dict_linear_expandable_vector
init|=
block|{
name|DICT_LINEAR_EXPANDABLE
block|,
comment|/* type */
name|free_linear_expandable
block|,
comment|/* free */
name|add_symbol_linear_expandable
block|,
comment|/* add_symbol */
name|iterator_first_linear
block|,
comment|/* iteractor_first */
name|iterator_next_linear
block|,
comment|/* iterator_next */
name|iter_name_first_linear
block|,
comment|/* iter_name_first */
name|iter_name_next_linear
block|,
comment|/* iter_name_next */
name|size_linear
block|,
comment|/* size */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations of helper functions (i.e. ones that don't go into    vectors).  */
end_comment

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_hashed_advance
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_symbol_hashed
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_hashtable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The creation functions.  */
end_comment

begin_comment
comment|/* Create a dictionary implemented via a fixed-size hashtable.  All    memory it uses is allocated on OBSTACK; the environment is    initialized from SYMBOL_LIST.  */
end_comment

begin_function
name|struct
name|dictionary
modifier|*
name|dict_create_hashed
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|,
specifier|const
name|struct
name|pending
modifier|*
name|symbol_list
parameter_list|)
block|{
name|struct
name|dictionary
modifier|*
name|retval
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|,
name|nbuckets
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|buckets
decl_stmt|;
specifier|const
name|struct
name|pending
modifier|*
name|list_counter
decl_stmt|;
name|retval
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dictionary
argument_list|)
argument_list|)
expr_stmt|;
name|DICT_VECTOR
argument_list|(
name|retval
argument_list|)
operator|=
operator|&
name|dict_hashed_vector
expr_stmt|;
comment|/* Calculate the number of symbols, and allocate space for them.  */
for|for
control|(
name|list_counter
operator|=
name|symbol_list
init|;
name|list_counter
operator|!=
name|NULL
condition|;
name|list_counter
operator|=
name|list_counter
operator|->
name|next
control|)
block|{
name|nsyms
operator|+=
name|list_counter
operator|->
name|nsyms
expr_stmt|;
block|}
name|nbuckets
operator|=
name|DICT_HASHTABLE_SIZE
argument_list|(
name|nsyms
argument_list|)
expr_stmt|;
name|DICT_HASHED_NBUCKETS
argument_list|(
name|retval
argument_list|)
operator|=
name|nbuckets
expr_stmt|;
name|buckets
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buckets
argument_list|,
literal|0
argument_list|,
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|DICT_HASHED_BUCKETS
argument_list|(
name|retval
argument_list|)
operator|=
name|buckets
expr_stmt|;
comment|/* Now fill the buckets.  */
for|for
control|(
name|list_counter
operator|=
name|symbol_list
init|;
name|list_counter
operator|!=
name|NULL
condition|;
name|list_counter
operator|=
name|list_counter
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
name|list_counter
operator|->
name|nsyms
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|insert_symbol_hashed
argument_list|(
name|retval
argument_list|,
name|list_counter
operator|->
name|symbol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Create a dictionary implemented via a hashtable that grows as    necessary.  The dictionary is initially empty; to add symbols to    it, call dict_add_symbol().  Call dict_free() when you're done with    it.  */
end_comment

begin_function
specifier|extern
name|struct
name|dictionary
modifier|*
name|dict_create_hashed_expandable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dictionary
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dictionary
argument_list|)
argument_list|)
expr_stmt|;
name|DICT_VECTOR
argument_list|(
name|retval
argument_list|)
operator|=
operator|&
name|dict_hashed_expandable_vector
expr_stmt|;
name|DICT_HASHED_NBUCKETS
argument_list|(
name|retval
argument_list|)
operator|=
name|DICT_EXPANDABLE_INITIAL_CAPACITY
expr_stmt|;
name|DICT_HASHED_BUCKETS
argument_list|(
name|retval
argument_list|)
operator|=
name|xcalloc
argument_list|(
name|DICT_EXPANDABLE_INITIAL_CAPACITY
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|DICT_HASHED_EXPANDABLE_NSYMS
argument_list|(
name|retval
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Create a dictionary implemented via a fixed-size array.  All memory    it uses is allocated on OBSTACK; the environment is initialized    from the SYMBOL_LIST.  The symbols are ordered in the same order    that they're found in SYMBOL_LIST.  */
end_comment

begin_function
name|struct
name|dictionary
modifier|*
name|dict_create_linear
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|,
specifier|const
name|struct
name|pending
modifier|*
name|symbol_list
parameter_list|)
block|{
name|struct
name|dictionary
modifier|*
name|retval
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|syms
decl_stmt|;
specifier|const
name|struct
name|pending
modifier|*
name|list_counter
decl_stmt|;
name|retval
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dictionary
argument_list|)
argument_list|)
expr_stmt|;
name|DICT_VECTOR
argument_list|(
name|retval
argument_list|)
operator|=
operator|&
name|dict_linear_vector
expr_stmt|;
comment|/* Calculate the number of symbols, and allocate space for them.  */
for|for
control|(
name|list_counter
operator|=
name|symbol_list
init|;
name|list_counter
operator|!=
name|NULL
condition|;
name|list_counter
operator|=
name|list_counter
operator|->
name|next
control|)
block|{
name|nsyms
operator|+=
name|list_counter
operator|->
name|nsyms
expr_stmt|;
block|}
name|DICT_LINEAR_NSYMS
argument_list|(
name|retval
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|syms
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|DICT_LINEAR_SYMS
argument_list|(
name|retval
argument_list|)
operator|=
name|syms
expr_stmt|;
comment|/* Now fill in the symbols.  Start filling in from the back, so as      to preserve the original order of the symbols.  */
for|for
control|(
name|list_counter
operator|=
name|symbol_list
operator|,
name|j
operator|=
name|nsyms
operator|-
literal|1
init|;
name|list_counter
operator|!=
name|NULL
condition|;
name|list_counter
operator|=
name|list_counter
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
name|list_counter
operator|->
name|nsyms
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
operator|,
operator|--
name|j
control|)
block|{
name|syms
index|[
name|j
index|]
operator|=
name|list_counter
operator|->
name|symbol
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Create a dictionary implemented via an array that grows as    necessary.  The dictionary is initially empty; to add symbols to    it, call dict_add_symbol().  Call dict_free() when you're done with    it.  */
end_comment

begin_function
name|struct
name|dictionary
modifier|*
name|dict_create_linear_expandable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dictionary
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dictionary
argument_list|)
argument_list|)
expr_stmt|;
name|DICT_VECTOR
argument_list|(
name|retval
argument_list|)
operator|=
operator|&
name|dict_linear_expandable_vector
expr_stmt|;
name|DICT_LINEAR_NSYMS
argument_list|(
name|retval
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DICT_LINEAR_EXPANDABLE_CAPACITY
argument_list|(
name|retval
argument_list|)
operator|=
name|DICT_EXPANDABLE_INITIAL_CAPACITY
expr_stmt|;
name|DICT_LINEAR_SYMS
argument_list|(
name|retval
argument_list|)
operator|=
name|xmalloc
argument_list|(
name|DICT_LINEAR_EXPANDABLE_CAPACITY
argument_list|(
name|retval
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* The functions providing the dictionary interface.  */
end_comment

begin_comment
comment|/* Free the memory used by a dictionary that's not on an obstack.  (If    any.)  */
end_comment

begin_function
name|void
name|dict_free
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
operator|(
name|DICT_VECTOR
argument_list|(
name|dict
argument_list|)
operator|)
operator|->
name|free
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add SYM to DICT.  DICT had better be expandable.  */
end_comment

begin_function
name|void
name|dict_add_symbol
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
operator|(
name|DICT_VECTOR
argument_list|(
name|dict
argument_list|)
operator|)
operator|->
name|add_symbol
argument_list|(
name|dict
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize ITERATOR to point at the first symbol in DICT, and    return that first symbol, or NULL if DICT is empty.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|dict_iterator_first
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
return|return
operator|(
name|DICT_VECTOR
argument_list|(
name|dict
argument_list|)
operator|)
operator|->
name|iterator_first
argument_list|(
name|dict
argument_list|,
name|iterator
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Advance ITERATOR, and return the next symbol, or NULL if there are    no more symbols.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|dict_iterator_next
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
return|return
operator|(
name|DICT_VECTOR
argument_list|(
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
argument_list|)
operator|)
operator|->
name|iterator_next
argument_list|(
name|iterator
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
name|dict_iter_name_first
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
return|return
operator|(
name|DICT_VECTOR
argument_list|(
name|dict
argument_list|)
operator|)
operator|->
name|iter_name_first
argument_list|(
name|dict
argument_list|,
name|name
argument_list|,
name|iterator
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
name|dict_iter_name_next
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
return|return
operator|(
name|DICT_VECTOR
argument_list|(
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
argument_list|)
operator|)
operator|->
name|iter_name_next
argument_list|(
name|name
argument_list|,
name|iterator
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|dict_size
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
return|return
operator|(
name|DICT_VECTOR
argument_list|(
name|dict
argument_list|)
operator|)
operator|->
name|size
argument_list|(
name|dict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Now come functions (well, one function, currently) that are    implemented generically by means of the vtable.  Typically, they're    rarely used.  */
end_comment

begin_comment
comment|/* Test to see if DICT is empty.  */
end_comment

begin_function
name|int
name|dict_empty
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
return|return
operator|(
name|dict_iterator_first
argument_list|(
name|dict
argument_list|,
operator|&
name|iter
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The functions implementing the dictionary interface.  */
end_comment

begin_comment
comment|/* Generic functions, where appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|free_obstack
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
comment|/* Do nothing!  */
block|}
end_function

begin_function
specifier|static
name|void
name|add_symbol_nonexpandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"dict_add_symbol: non-expandable dictionary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for DICT_HASHED and DICT_HASHED_EXPANDABLE.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_first_hashed
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
operator|=
name|dict
expr_stmt|;
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|iterator_hashed_advance
argument_list|(
name|iterator
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_next_hashed
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
init|=
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|DICT_ITERATOR_CURRENT
argument_list|(
name|iterator
argument_list|)
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
name|iterator_hashed_advance
argument_list|(
name|iterator
argument_list|)
return|;
else|else
block|{
name|DICT_ITERATOR_CURRENT
argument_list|(
name|iterator
argument_list|)
operator|=
name|next
expr_stmt|;
return|return
name|next
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_hashed_advance
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
init|=
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
decl_stmt|;
name|int
name|nbuckets
init|=
name|DICT_HASHED_NBUCKETS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|nbuckets
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|DICT_HASHED_BUCKET
argument_list|(
name|dict
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|=
name|i
expr_stmt|;
name|DICT_ITERATOR_CURRENT
argument_list|(
name|iterator
argument_list|)
operator|=
name|sym
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_first_hashed
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
name|unsigned
name|int
name|hash_index
init|=
name|msymbol_hash_iw
argument_list|(
name|name
argument_list|)
operator|%
name|DICT_HASHED_NBUCKETS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
operator|=
name|dict
expr_stmt|;
comment|/* Loop through the symbols in the given bucket, breaking when SYM      first matches.  If SYM never matches, it will be set to NULL;      either way, we have the right return value.  */
for|for
control|(
name|sym
operator|=
name|DICT_HASHED_BUCKET
argument_list|(
name|dict
argument_list|,
name|hash_index
argument_list|)
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|hash_next
control|)
block|{
comment|/* Warning: the order of arguments to strcmp_iw matters!  */
if|if
condition|(
name|strcmp_iw
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|DICT_ITERATOR_CURRENT
argument_list|(
name|iterator
argument_list|)
operator|=
name|sym
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_next_hashed
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|DICT_ITERATOR_CURRENT
argument_list|(
name|iterator
argument_list|)
operator|->
name|hash_next
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next
operator|->
name|hash_next
control|)
block|{
if|if
condition|(
name|strcmp_iw
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|next
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|DICT_ITERATOR_CURRENT
argument_list|(
name|iterator
argument_list|)
operator|=
name|next
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Insert SYM into DICT.  */
end_comment

begin_function
specifier|static
name|void
name|insert_symbol_hashed
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|unsigned
name|int
name|hash_index
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|buckets
init|=
name|DICT_HASHED_BUCKETS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|hash_index
operator|=
operator|(
name|msymbol_hash_iw
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|%
name|DICT_HASHED_NBUCKETS
argument_list|(
name|dict
argument_list|)
operator|)
expr_stmt|;
name|sym
operator|->
name|hash_next
operator|=
name|buckets
index|[
name|hash_index
index|]
expr_stmt|;
name|buckets
index|[
name|hash_index
index|]
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|size_hashed
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
return|return
name|DICT_HASHED_NBUCKETS
argument_list|(
name|dict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Functions only for DICT_HASHED_EXPANDABLE.  */
end_comment

begin_function
specifier|static
name|void
name|free_hashed_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
name|xfree
argument_list|(
name|DICT_HASHED_BUCKETS
argument_list|(
name|dict
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_symbol_hashed_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|int
name|nsyms
init|=
operator|++
name|DICT_HASHED_EXPANDABLE_NSYMS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
if|if
condition|(
name|DICT_HASHTABLE_SIZE
argument_list|(
name|nsyms
argument_list|)
operator|>
name|DICT_HASHED_NBUCKETS
argument_list|(
name|dict
argument_list|)
condition|)
name|expand_hashtable
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|insert_symbol_hashed
argument_list|(
name|dict
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|DICT_HASHED_EXPANDABLE_NSYMS
argument_list|(
name|dict
argument_list|)
operator|=
name|nsyms
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|size_hashed_expandable
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
return|return
name|DICT_HASHED_EXPANDABLE_NSYMS
argument_list|(
name|dict
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_hashtable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
name|int
name|old_nbuckets
init|=
name|DICT_HASHED_NBUCKETS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|old_buckets
init|=
name|DICT_HASHED_BUCKETS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|int
name|new_nbuckets
init|=
literal|2
operator|*
name|old_nbuckets
operator|+
literal|1
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|new_buckets
init|=
name|xcalloc
argument_list|(
name|new_nbuckets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DICT_HASHED_NBUCKETS
argument_list|(
name|dict
argument_list|)
operator|=
name|new_nbuckets
expr_stmt|;
name|DICT_HASHED_BUCKETS
argument_list|(
name|dict
argument_list|)
operator|=
name|new_buckets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_nbuckets
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|next_sym
decl_stmt|;
name|sym
operator|=
name|old_buckets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|next_sym
operator|=
name|sym
operator|->
name|hash_next
init|;
name|next_sym
operator|!=
name|NULL
condition|;
name|next_sym
operator|=
name|sym
operator|->
name|hash_next
control|)
block|{
name|insert_symbol_hashed
argument_list|(
name|dict
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|sym
operator|=
name|next_sym
expr_stmt|;
block|}
name|insert_symbol_hashed
argument_list|(
name|dict
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
name|xfree
argument_list|(
name|old_buckets
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for DICT_LINEAR and DICT_LINEAR_EXPANDABLE.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_first_linear
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
operator|=
name|dict
expr_stmt|;
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|DICT_LINEAR_NSYMS
argument_list|(
name|dict
argument_list|)
condition|?
name|DICT_LINEAR_SYM
argument_list|(
name|dict
argument_list|,
literal|0
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iterator_next_linear
parameter_list|(
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
init|=
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|>=
name|DICT_LINEAR_NSYMS
argument_list|(
name|dict
argument_list|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|DICT_LINEAR_SYM
argument_list|(
name|dict
argument_list|,
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_first_linear
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
operator|=
name|dict
expr_stmt|;
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|iter_name_next_linear
argument_list|(
name|name
argument_list|,
name|iterator
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|iter_name_next_linear
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dict_iterator
modifier|*
name|iterator
parameter_list|)
block|{
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
init|=
name|DICT_ITERATOR_DICT
argument_list|(
name|iterator
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsyms
init|=
name|DICT_LINEAR_NSYMS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
name|sym
operator|=
name|DICT_LINEAR_SYM
argument_list|(
name|dict
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp_iw
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|sym
expr_stmt|;
break|break;
block|}
block|}
name|DICT_ITERATOR_INDEX
argument_list|(
name|iterator
argument_list|)
operator|=
name|i
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|size_linear
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
return|return
name|DICT_LINEAR_NSYMS
argument_list|(
name|dict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Functions only for DICT_LINEAR_EXPANDABLE.  */
end_comment

begin_function
specifier|static
name|void
name|free_linear_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
name|xfree
argument_list|(
name|DICT_LINEAR_SYMS
argument_list|(
name|dict
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_symbol_linear_expandable
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|int
name|nsyms
init|=
operator|++
name|DICT_LINEAR_NSYMS
argument_list|(
name|dict
argument_list|)
decl_stmt|;
comment|/* Do we have enough room?  If not, grow it.  */
if|if
condition|(
name|nsyms
operator|>
name|DICT_LINEAR_EXPANDABLE_CAPACITY
argument_list|(
name|dict
argument_list|)
condition|)
block|{
name|DICT_LINEAR_EXPANDABLE_CAPACITY
argument_list|(
name|dict
argument_list|)
operator|*=
literal|2
expr_stmt|;
name|DICT_LINEAR_SYMS
argument_list|(
name|dict
argument_list|)
operator|=
name|xrealloc
argument_list|(
name|DICT_LINEAR_SYMS
argument_list|(
name|dict
argument_list|)
argument_list|,
name|DICT_LINEAR_EXPANDABLE_CAPACITY
argument_list|(
name|dict
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DICT_LINEAR_SYM
argument_list|(
name|dict
argument_list|,
name|nsyms
operator|-
literal|1
argument_list|)
operator|=
name|sym
expr_stmt|;
block|}
end_function

end_unit

