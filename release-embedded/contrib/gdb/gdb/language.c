begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Multiple source language support for GDB.     Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,    2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by the Department of Computer Science at the State University    of New York at Buffalo.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains functions that return things that are specific    to languages.  Each function should examine current_language if necessary,    and return the appropriate result. */
end_comment

begin_comment
comment|/* FIXME:  Most of these would be better organized as macros which    return data out of a "language-specific" struct pointer that is set    whenever the working language changes.  That would be a lot faster.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"jv-lang.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_function_decl
specifier|extern
name|void
name|_initialize_language
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_language_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_language_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_type_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_type_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_range_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_range_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_case_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_case_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_case_str
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_range_str
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_type_str
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_lang_str
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unk_lang_error
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unk_lang_parser
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_check
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_check
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_type_range_case
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unk_lang_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unk_lang_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unk_lang_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|force_ellipses
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|unk_lang_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unk_lang_print_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unk_lang_val_print
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unk_lang_value_print
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|unk_lang_trampoline
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|language_defn
name|unknown_language_defn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current (default at startup) state of type and range checking.    (If the modes are set to "auto", though, these are changed based    on the default language at startup, and then again based on the    language of the first source file.  */
end_comment

begin_decl_stmt
name|enum
name|range_mode
name|range_mode
init|=
name|range_mode_auto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|range_check
name|range_check
init|=
name|range_check_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|type_mode
name|type_mode
init|=
name|type_mode_auto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|type_check
name|type_check
init|=
name|type_check_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|case_mode
name|case_mode
init|=
name|case_mode_auto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|case_sensitivity
name|case_sensitivity
init|=
name|case_sensitive_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current language and language_mode (see language.h) */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|language_defn
modifier|*
name|current_language
init|=
operator|&
name|unknown_language_defn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|language_mode
name|language_mode
init|=
name|language_mode_auto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The language that the user expects to be typing in (the language    of main(), or the last language we notified them about, or C).  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|language_defn
modifier|*
name|expected_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of supported languages.  The list itself is malloc'd.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|language_defn
modifier|*
modifier|*
name|languages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|languages_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|languages_allocsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_ALLOCSIZE
value|4
end_define

begin_comment
comment|/* The "set language/type/range" commands all put stuff in these    buffers.  This is to make them work as set/show commands.  The    user's string is copied here, then the set_* commands look at    them and update them to something that looks nice when it is    printed out. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|language
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|case_sensitive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warning issued when current_language and the language of the current    frame do not match. */
end_comment

begin_decl_stmt
name|char
name|lang_frame_mismatch_warn
index|[]
init|=
literal|"Warning: the current language does not match this frame."
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This page contains the functions corresponding to GDB commands    and their helpers. */
end_comment

begin_comment
comment|/* Show command.  Display a warning if the language set    does not match the frame. */
end_comment

begin_function
specifier|static
name|void
name|show_language_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|enum
name|language
name|flang
decl_stmt|;
comment|/* The language of the current frame */
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
name|flang
operator|!=
name|language_unknown
operator|&&
name|language_mode
operator|==
name|language_mode_manual
operator|&&
name|current_language
operator|->
name|la_language
operator|!=
name|flang
condition|)
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|lang_frame_mismatch_warn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set command.  Change the current working language. */
end_comment

begin_function
specifier|static
name|void
name|set_language_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|language
name|flang
decl_stmt|;
name|char
modifier|*
name|err_lang
decl_stmt|;
if|if
condition|(
operator|!
name|language
operator|||
operator|!
name|language
index|[
literal|0
index|]
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"The currently understood settings are:\n\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"local or auto    Automatic setting based on source file\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
operator|++
name|i
control|)
block|{
comment|/* Already dealt with these above.  */
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|language_unknown
operator|||
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|language_auto
condition|)
continue|continue;
comment|/* FIXME for now assume that the human-readable name is just 	     a capitalization of the internal name.  */
name|printf_unfiltered
argument_list|(
literal|"%-16s Use the %c%s language\n"
argument_list|,
name|languages
index|[
name|i
index|]
operator|->
name|la_name
argument_list|,
comment|/* Capitalize first letter of language 	     name.  */
name|toupper
argument_list|(
name|languages
index|[
name|i
index|]
operator|->
name|la_name
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|languages
index|[
name|i
index|]
operator|->
name|la_name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the silly string. */
name|set_language
argument_list|(
name|current_language
operator|->
name|la_language
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Search the list of languages for a match.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|languages
index|[
name|i
index|]
operator|->
name|la_name
argument_list|,
name|language
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found it!  Go into manual mode, and use this language.  */
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|language_auto
condition|)
block|{
comment|/* Enter auto mode.  Set to the current frame's language, if known.  */
name|language_mode
operator|=
name|language_mode_auto
expr_stmt|;
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
name|flang
operator|!=
name|language_unknown
condition|)
name|set_language
argument_list|(
name|flang
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Enter manual mode.  Set the specified language.  */
name|language_mode
operator|=
name|language_mode_manual
expr_stmt|;
name|current_language
operator|=
name|languages
index|[
name|i
index|]
expr_stmt|;
name|set_type_range_case
argument_list|()
expr_stmt|;
name|set_lang_str
argument_list|()
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Reset the language (esp. the global string "language") to the       correct values. */
name|err_lang
operator|=
name|savestring
argument_list|(
name|language
argument_list|,
name|strlen
argument_list|(
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|err_lang
argument_list|)
expr_stmt|;
comment|/* Free it after error */
name|set_language
argument_list|(
name|current_language
operator|->
name|la_language
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Unknown language `%s'."
argument_list|,
name|err_lang
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show command.  Display a warning if the type setting does    not match the current language. */
end_comment

begin_function
specifier|static
name|void
name|show_type_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|type_check
operator|!=
name|current_language
operator|->
name|la_type_check
condition|)
name|printf_unfiltered
argument_list|(
literal|"Warning: the current type check setting does not match the language.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set command.  Change the setting for type checking. */
end_comment

begin_function
specifier|static
name|void
name|set_type_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type_check
operator|=
name|type_check_on
expr_stmt|;
name|type_mode
operator|=
name|type_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"warn"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type_check
operator|=
name|type_check_warn
expr_stmt|;
name|type_mode
operator|=
name|type_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type_check
operator|=
name|type_check_off
expr_stmt|;
name|type_mode
operator|=
name|type_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type_mode
operator|=
name|type_mode_auto
expr_stmt|;
name|set_type_range_case
argument_list|()
expr_stmt|;
comment|/* Avoid hitting the set_type_str call below.  We          did it in set_type_range_case. */
return|return;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Unrecognized type check setting: \"%s\""
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|set_type_str
argument_list|()
expr_stmt|;
name|show_type_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show command.  Display a warning if the range setting does    not match the current language. */
end_comment

begin_function
specifier|static
name|void
name|show_range_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|range_check
operator|!=
name|current_language
operator|->
name|la_range_check
condition|)
name|printf_unfiltered
argument_list|(
literal|"Warning: the current range check setting does not match the language.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set command.  Change the setting for range checking. */
end_comment

begin_function
specifier|static
name|void
name|set_range_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|range
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|range_check
operator|=
name|range_check_on
expr_stmt|;
name|range_mode
operator|=
name|range_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|range
argument_list|,
literal|"warn"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|range_check
operator|=
name|range_check_warn
expr_stmt|;
name|range_mode
operator|=
name|range_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|range
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|range_check
operator|=
name|range_check_off
expr_stmt|;
name|range_mode
operator|=
name|range_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|range
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|range_mode
operator|=
name|range_mode_auto
expr_stmt|;
name|set_type_range_case
argument_list|()
expr_stmt|;
comment|/* Avoid hitting the set_range_str call below.  We          did it in set_type_range_case. */
return|return;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Unrecognized range check setting: \"%s\""
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
name|set_range_str
argument_list|()
expr_stmt|;
name|show_range_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show command.  Display a warning if the case sensitivity setting does    not match the current language. */
end_comment

begin_function
specifier|static
name|void
name|show_case_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|case_sensitivity
operator|!=
name|current_language
operator|->
name|la_case_sensitivity
condition|)
name|printf_unfiltered
argument_list|(
literal|"Warning: the current case sensitivity setting does not match the language.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set command.  Change the setting for case sensitivity. */
end_comment

begin_function
specifier|static
name|void
name|set_case_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|case_sensitive
argument_list|,
literal|"on"
argument_list|)
condition|)
block|{
name|case_sensitivity
operator|=
name|case_sensitive_on
expr_stmt|;
name|case_mode
operator|=
name|case_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|case_sensitive
argument_list|,
literal|"off"
argument_list|)
condition|)
block|{
name|case_sensitivity
operator|=
name|case_sensitive_off
expr_stmt|;
name|case_mode
operator|=
name|case_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|case_sensitive
argument_list|,
literal|"auto"
argument_list|)
condition|)
block|{
name|case_mode
operator|=
name|case_mode_auto
expr_stmt|;
name|set_type_range_case
argument_list|()
expr_stmt|;
comment|/* Avoid hitting the set_case_str call below.  We          did it in set_type_range_case. */
return|return;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Unrecognized case-sensitive setting: \"%s\""
argument_list|,
name|case_sensitive
argument_list|)
expr_stmt|;
block|}
name|set_case_str
argument_list|()
expr_stmt|;
name|show_case_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the status of range and type checking and case sensitivity based on    the current modes and the current language.    If SHOW is non-zero, then print out the current language,    type and range checking status. */
end_comment

begin_function
specifier|static
name|void
name|set_type_range_case
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|range_mode
operator|==
name|range_mode_auto
condition|)
name|range_check
operator|=
name|current_language
operator|->
name|la_range_check
expr_stmt|;
if|if
condition|(
name|type_mode
operator|==
name|type_mode_auto
condition|)
name|type_check
operator|=
name|current_language
operator|->
name|la_type_check
expr_stmt|;
if|if
condition|(
name|case_mode
operator|==
name|case_mode_auto
condition|)
name|case_sensitivity
operator|=
name|current_language
operator|->
name|la_case_sensitivity
expr_stmt|;
name|set_type_str
argument_list|()
expr_stmt|;
name|set_range_str
argument_list|()
expr_stmt|;
name|set_case_str
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current language to (enum language) LANG.  Returns previous language. */
end_comment

begin_function
name|enum
name|language
name|set_language
parameter_list|(
name|enum
name|language
name|lang
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|language
name|prev_language
decl_stmt|;
name|prev_language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|lang
condition|)
block|{
name|current_language
operator|=
name|languages
index|[
name|i
index|]
expr_stmt|;
name|set_type_range_case
argument_list|()
expr_stmt|;
name|set_lang_str
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|prev_language
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains functions that update the global vars    language, type and range. */
end_comment

begin_function
specifier|static
name|void
name|set_lang_str
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prefix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|language
condition|)
name|xfree
argument_list|(
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|language_mode
operator|==
name|language_mode_auto
condition|)
name|prefix
operator|=
literal|"auto; currently "
expr_stmt|;
name|language
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
name|current_language
operator|->
name|la_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_type_str
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|prefix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|xfree
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_mode
operator|==
name|type_mode_auto
condition|)
name|prefix
operator|=
literal|"auto; currently "
expr_stmt|;
switch|switch
condition|(
name|type_check
condition|)
block|{
case|case
name|type_check_on
case|:
name|tmp
operator|=
literal|"on"
expr_stmt|;
break|break;
case|case
name|type_check_off
case|:
name|tmp
operator|=
literal|"off"
expr_stmt|;
break|break;
case|case
name|type_check_warn
case|:
name|tmp
operator|=
literal|"warn"
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unrecognized type check setting."
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_range_str
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|pref
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|range_mode
operator|==
name|range_mode_auto
condition|)
name|pref
operator|=
literal|"auto; currently "
expr_stmt|;
switch|switch
condition|(
name|range_check
condition|)
block|{
case|case
name|range_check_on
case|:
name|tmp
operator|=
literal|"on"
expr_stmt|;
break|break;
case|case
name|range_check_off
case|:
name|tmp
operator|=
literal|"off"
expr_stmt|;
break|break;
case|case
name|range_check_warn
case|:
name|tmp
operator|=
literal|"warn"
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unrecognized range check setting."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|range
condition|)
name|xfree
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|range
operator|=
name|concat
argument_list|(
name|pref
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_case_str
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|prefix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|case_mode
operator|==
name|case_mode_auto
condition|)
name|prefix
operator|=
literal|"auto; currently "
expr_stmt|;
switch|switch
condition|(
name|case_sensitivity
condition|)
block|{
case|case
name|case_sensitive_on
case|:
name|tmp
operator|=
literal|"on"
expr_stmt|;
break|break;
case|case
name|case_sensitive_off
case|:
name|tmp
operator|=
literal|"off"
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unrecognized case-sensitive setting."
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|case_sensitive
argument_list|)
expr_stmt|;
name|case_sensitive
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the current language settings: language, range and    type checking.  If QUIETLY, print only what has changed.  */
end_comment

begin_function
name|void
name|language_info
parameter_list|(
name|int
name|quietly
parameter_list|)
block|{
if|if
condition|(
name|quietly
operator|&&
name|expected_language
operator|==
name|current_language
condition|)
return|return;
name|expected_language
operator|=
name|current_language
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Current language:  %s\n"
argument_list|,
name|language
argument_list|)
expr_stmt|;
name|show_language_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quietly
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Type checking:     %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|show_type_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Range checking:    %s\n"
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|show_range_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Case sensitivity:  %s\n"
argument_list|,
name|case_sensitive
argument_list|)
expr_stmt|;
name|show_case_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the result of a binary operation. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
unit|struct type * binop_result_type (struct value *v1, struct value *v2) {   int size, uns;   struct type *t1 = check_typedef (VALUE_TYPE (v1));   struct type *t2 = check_typedef (VALUE_TYPE (v2));    int l1 = TYPE_LENGTH (t1);   int l2 = TYPE_LENGTH (t2);    switch (current_language->la_language)     {     case language_c:     case language_cplus:     case language_objc:       if (TYPE_CODE (t1) == TYPE_CODE_FLT) 	return TYPE_CODE (t2) == TYPE_CODE_FLT&& l2> l1 ? 	  VALUE_TYPE (v2) : VALUE_TYPE (v1);       else if (TYPE_CODE (t2) == TYPE_CODE_FLT) 	return TYPE_CODE (t1) == TYPE_CODE_FLT&& l1> l2 ? 	  VALUE_TYPE (v1) : VALUE_TYPE (v2);       else if (TYPE_UNSIGNED (t1)&& l1> l2) 	return VALUE_TYPE (v1);       else if (TYPE_UNSIGNED (t2)&& l2> l1) 	return VALUE_TYPE (v2);       else
comment|/* Both are signed.  Result is the longer type */
end_comment

begin_comment
unit|return l1> l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);       break;     case language_m2:
comment|/* If we are doing type-checking, l1 should equal l2, so this is          not needed. */
end_comment

begin_comment
unit|return l1> l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);       break;     }   internal_error (__FILE__, __LINE__, "failed internal consistency check");   return (struct type *) 0;
comment|/* For lint */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This page contains functions that return format strings for    printf for printing out numbers in different formats */
end_comment

begin_comment
comment|/* Returns the appropriate printf format for hexadecimal    numbers. */
end_comment

begin_function
name|char
modifier|*
name|local_hex_format_custom
parameter_list|(
name|char
modifier|*
name|pre
parameter_list|)
block|{
specifier|static
name|char
name|form
index|[
literal|50
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|form
argument_list|,
name|local_hex_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_hex_format_specifier
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_hex_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|form
return|;
block|}
end_function

begin_comment
comment|/* Converts a LONGEST to custom hexadecimal and stores it in a static    string.  Returns a pointer to this string. */
end_comment

begin_function
name|char
modifier|*
name|local_hex_string
parameter_list|(
name|LONGEST
name|num
parameter_list|)
block|{
return|return
name|local_hex_string_custom
argument_list|(
name|num
argument_list|,
literal|"l"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Converts a LONGEST number to custom hexadecimal and stores it in a static    string.  Returns a pointer to this string. Note that the width parameter    should end with "l", e.g. "08l" as with calls to local_hex_string_custom */
end_comment

begin_function
name|char
modifier|*
name|local_hex_string_custom
parameter_list|(
name|LONGEST
name|num
parameter_list|,
name|char
modifier|*
name|width
parameter_list|)
block|{
define|#
directive|define
name|RESULT_BUF_LEN
value|50
specifier|static
name|char
name|res2
index|[
name|RESULT_BUF_LEN
index|]
decl_stmt|;
name|char
name|format
index|[
name|RESULT_BUF_LEN
index|]
decl_stmt|;
name|int
name|field_width
decl_stmt|;
name|int
name|num_len
decl_stmt|;
name|int
name|num_pad_chars
decl_stmt|;
name|char
modifier|*
name|pad_char
decl_stmt|;
comment|/* string with one character */
name|int
name|pad_on_left
decl_stmt|;
name|char
modifier|*
name|parse_ptr
decl_stmt|;
name|char
name|temp_nbr_buf
index|[
name|RESULT_BUF_LEN
index|]
decl_stmt|;
comment|/* Use phex_nz to print the number into a string, then      build the result string from local_hex_format_prefix, padding and       the hex representation as indicated by "width".  */
name|strcpy
argument_list|(
name|temp_nbr_buf
argument_list|,
name|phex_nz
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse width */
name|parse_ptr
operator|=
name|width
expr_stmt|;
name|pad_on_left
operator|=
literal|1
expr_stmt|;
name|pad_char
operator|=
literal|" "
expr_stmt|;
if|if
condition|(
operator|*
name|parse_ptr
operator|==
literal|'-'
condition|)
block|{
name|parse_ptr
operator|++
expr_stmt|;
name|pad_on_left
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|parse_ptr
operator|==
literal|'0'
condition|)
block|{
name|parse_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|pad_on_left
condition|)
name|pad_char
operator|=
literal|"0"
expr_stmt|;
comment|/* If padding is on the right, it is blank */
block|}
name|field_width
operator|=
name|atoi
argument_list|(
name|parse_ptr
argument_list|)
expr_stmt|;
name|num_len
operator|=
name|strlen
argument_list|(
name|temp_nbr_buf
argument_list|)
expr_stmt|;
name|num_pad_chars
operator|=
name|field_width
operator|-
name|strlen
argument_list|(
name|temp_nbr_buf
argument_list|)
expr_stmt|;
comment|/* possibly negative */
if|if
condition|(
name|strlen
argument_list|(
name|local_hex_format_prefix
argument_list|()
argument_list|)
operator|+
name|num_len
operator|+
name|num_pad_chars
operator|>=
name|RESULT_BUF_LEN
condition|)
comment|/* paranoia */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"local_hex_string_custom: insufficient space to store result"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|res2
argument_list|,
name|local_hex_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad_on_left
condition|)
block|{
while|while
condition|(
name|num_pad_chars
operator|>
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|res2
argument_list|,
name|pad_char
argument_list|)
expr_stmt|;
name|num_pad_chars
operator|--
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|res2
argument_list|,
name|temp_nbr_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pad_on_left
condition|)
block|{
while|while
condition|(
name|num_pad_chars
operator|>
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|res2
argument_list|,
name|pad_char
argument_list|)
expr_stmt|;
name|num_pad_chars
operator|--
expr_stmt|;
block|}
block|}
return|return
name|res2
return|;
block|}
end_function

begin_comment
comment|/* local_hex_string_custom */
end_comment

begin_comment
comment|/* Returns the appropriate printf format for octal    numbers. */
end_comment

begin_function
name|char
modifier|*
name|local_octal_format_custom
parameter_list|(
name|char
modifier|*
name|pre
parameter_list|)
block|{
specifier|static
name|char
name|form
index|[
literal|50
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|form
argument_list|,
name|local_octal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_octal_format_specifier
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_octal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|form
return|;
block|}
end_function

begin_comment
comment|/* Returns the appropriate printf format for decimal numbers. */
end_comment

begin_function
name|char
modifier|*
name|local_decimal_format_custom
parameter_list|(
name|char
modifier|*
name|pre
parameter_list|)
block|{
specifier|static
name|char
name|form
index|[
literal|50
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|form
argument_list|,
name|local_decimal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_decimal_format_specifier
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_decimal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|form
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This page contains functions that are used in type/range checking.    They all return zero if the type/range check fails.     It is hoped that these will make extending GDB to parse different    languages a little easier.  These are primarily used in eval.c when    evaluating expressions and making sure that their types are correct.    Instead of having a mess of conjucted/disjuncted expressions in an "if",    the ideas of type can be wrapped up in the following functions.     Note that some of them are not currently dependent upon which language    is currently being parsed.  For example, floats are the same in    C and Modula-2 (ie. the only floating point type has TYPE_CODE of    TYPE_CODE_FLT), while booleans are different. */
end_comment

begin_comment
comment|/* Returns non-zero if its argument is a simple type.  This is the same for    both Modula-2 and for C.  In the C case, TYPE_CODE_CHAR will never occur,    and thus will never cause the failure of the test. */
end_comment

begin_comment
unit|int simple_type (struct type *type) {   CHECK_TYPEDEF (type);   switch (TYPE_CODE (type))     {     case TYPE_CODE_INT:     case TYPE_CODE_CHAR:     case TYPE_CODE_ENUM:     case TYPE_CODE_FLT:     case TYPE_CODE_RANGE:     case TYPE_CODE_BOOL:       return 1;      default:       return 0;     } }
comment|/* Returns non-zero if its argument is of an ordered type.    An ordered type is one in which the elements can be tested for the    properties of "greater than", "less than", etc, or for which the    operations "increment" or "decrement" make sense. */
end_comment

begin_comment
unit|int ordered_type (struct type *type) {   CHECK_TYPEDEF (type);   switch (TYPE_CODE (type))     {     case TYPE_CODE_INT:     case TYPE_CODE_CHAR:     case TYPE_CODE_ENUM:     case TYPE_CODE_FLT:     case TYPE_CODE_RANGE:       return 1;      default:       return 0;     } }
comment|/* Returns non-zero if the two types are the same */
end_comment

begin_comment
unit|int same_type (struct type *arg1, struct type *arg2) {   CHECK_TYPEDEF (type);   if (structured_type (arg1) ? !structured_type (arg2) : structured_type (arg2))
comment|/* One is structured and one isn't */
end_comment

begin_comment
unit|return 0;   else if (structured_type (arg1)&& structured_type (arg2))     return arg1 == arg2;   else if (numeric_type (arg1)&& numeric_type (arg2))     return (TYPE_CODE (arg2) == TYPE_CODE (arg1))&&       (TYPE_UNSIGNED (arg1) == TYPE_UNSIGNED (arg2))       ? 1 : 0;   else     return arg1 == arg2; }
comment|/* Returns non-zero if the type is integral */
end_comment

begin_comment
unit|int integral_type (struct type *type) {   CHECK_TYPEDEF (type);   switch (current_language->la_language)     {     case language_c:     case language_cplus:     case language_objc:       return (TYPE_CODE (type) != TYPE_CODE_INT)&& 	(TYPE_CODE (type) != TYPE_CODE_ENUM) ? 0 : 1;     case language_m2:     case language_pascal:       return TYPE_CODE (type) != TYPE_CODE_INT ? 0 : 1;     default:       error ("Language not supported.");     } }
comment|/* Returns non-zero if the value is numeric */
end_comment

begin_comment
unit|int numeric_type (struct type *type) {   CHECK_TYPEDEF (type);   switch (TYPE_CODE (type))     {     case TYPE_CODE_INT:     case TYPE_CODE_FLT:       return 1;      default:       return 0;     } }
comment|/* Returns non-zero if the value is a character type */
end_comment

begin_comment
unit|int character_type (struct type *type) {   CHECK_TYPEDEF (type);   switch (current_language->la_language)     {     case language_m2:     case language_pascal:       return TYPE_CODE (type) != TYPE_CODE_CHAR ? 0 : 1;      case language_c:     case language_cplus:     case language_objc:       return (TYPE_CODE (type) == TYPE_CODE_INT)&& 	TYPE_LENGTH (type) == sizeof (char)       ? 1 : 0;     default:       return (0);     } }
comment|/* Returns non-zero if the value is a string type */
end_comment

begin_comment
unit|int string_type (struct type *type) {   CHECK_TYPEDEF (type);   switch (current_language->la_language)     {     case language_m2:     case language_pascal:       return TYPE_CODE (type) != TYPE_CODE_STRING ? 0 : 1;      case language_c:     case language_cplus:     case language_objc:
comment|/* C does not have distinct string type. */
end_comment

begin_comment
unit|return (0);     default:       return (0);     } }
comment|/* Returns non-zero if the value is a boolean type */
end_comment

begin_comment
unit|int boolean_type (struct type *type) {   CHECK_TYPEDEF (type);   if (TYPE_CODE (type) == TYPE_CODE_BOOL)     return 1;   switch (current_language->la_language)     {     case language_c:     case language_cplus:     case language_objc:
comment|/* Might be more cleanly handled by having a          TYPE_CODE_INT_NOT_BOOL for (the deleted) CHILL and such          languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
end_comment

begin_comment
unit|if (TYPE_CODE (type) == TYPE_CODE_INT) 	return 1;     default:       break;     }   return 0; }
comment|/* Returns non-zero if the value is a floating-point type */
end_comment

begin_comment
unit|int float_type (struct type *type) {   CHECK_TYPEDEF (type);   return TYPE_CODE (type) == TYPE_CODE_FLT; }
comment|/* Returns non-zero if the value is a pointer type */
end_comment

begin_comment
unit|int pointer_type (struct type *type) {   return TYPE_CODE (type) == TYPE_CODE_PTR ||     TYPE_CODE (type) == TYPE_CODE_REF; }
comment|/* Returns non-zero if the value is a structured type */
end_comment

begin_endif
unit|int structured_type (struct type *type) {   CHECK_TYPEDEF (type);   switch (current_language->la_language)     {     case language_c:     case language_cplus:     case language_objc:       return (TYPE_CODE (type) == TYPE_CODE_STRUCT) || 	(TYPE_CODE (type) == TYPE_CODE_UNION) || 	(TYPE_CODE (type) == TYPE_CODE_ARRAY);    case language_pascal:       return (TYPE_CODE(type) == TYPE_CODE_STRUCT) || 	 (TYPE_CODE(type) == TYPE_CODE_UNION) || 	 (TYPE_CODE(type) == TYPE_CODE_SET) || 	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);     case language_m2:       return (TYPE_CODE (type) == TYPE_CODE_STRUCT) || 	(TYPE_CODE (type) == TYPE_CODE_SET) || 	(TYPE_CODE (type) == TYPE_CODE_ARRAY);     default:       return (0);     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|struct
name|type
modifier|*
name|lang_bool_type
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
case|case
name|language_fortran
case|:
name|sym
operator|=
name|lookup_symbol
argument_list|(
literal|"logical"
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
return|return
name|type
return|;
block|}
return|return
name|builtin_type_f_logical_s2
return|;
case|case
name|language_cplus
case|:
case|case
name|language_pascal
case|:
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
condition|)
block|{
name|sym
operator|=
name|lookup_symbol
argument_list|(
literal|"bool"
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|lookup_symbol
argument_list|(
literal|"boolean"
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
condition|)
block|{
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
return|return
name|type
return|;
block|}
return|return
name|builtin_type_bool
return|;
case|case
name|language_java
case|:
name|sym
operator|=
name|lookup_symbol
argument_list|(
literal|"boolean"
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
return|return
name|type
return|;
block|}
return|return
name|java_boolean_type
return|;
default|default:
return|return
name|builtin_type_int
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains functions that return info about    (struct value) values used in GDB. */
end_comment

begin_comment
comment|/* Returns non-zero if the value VAL represents a true value. */
end_comment

begin_function
name|int
name|value_true
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
comment|/* It is possible that we should have some sort of error if a non-boolean      value is used in this context.  Possibly dependent on some kind of      "boolean-checking" option like range checking.  But it should probably      not depend on the language except insofar as is necessary to identify      a "boolean" value (i.e. in C using a float, pointer, etc., as a boolean      should be an error, probably).  */
return|return
operator|!
name|value_logical_not
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains functions for the printing out of    error messages that occur during type- and range-    checking. */
end_comment

begin_comment
comment|/* These are called when a language fails a type- or range-check.  The    first argument should be a printf()-style format string, and the    rest of the arguments should be its arguments.  If    [type|range]_check is [type|range]_check_on, an error is printed;    if [type|range]_check_warn, a warning; otherwise just the    message. */
end_comment

begin_function
name|void
name|type_error
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type_check
condition|)
block|{
case|case
name|type_check_warn
case|:
name|vwarning
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|type_check_on
case|:
name|verror
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|type_check_off
case|:
comment|/* FIXME: cagney/2002-01-30: Should this function print anything          when type error is off?  */
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|range_error
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|range_check
condition|)
block|{
case|case
name|range_check_warn
case|:
name|vwarning
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|range_check_on
case|:
name|verror
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|range_check_off
case|:
comment|/* FIXME: cagney/2002-01-30: Should this function print anything          when range error is off?  */
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains miscellaneous functions */
end_comment

begin_comment
comment|/* Return the language enum for a given language string. */
end_comment

begin_function
name|enum
name|language
name|language_enum
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|languages
index|[
name|i
index|]
operator|->
name|la_name
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|languages
index|[
name|i
index|]
operator|->
name|la_language
return|;
return|return
name|language_unknown
return|;
block|}
end_function

begin_comment
comment|/* Return the language struct for a given language enum. */
end_comment

begin_function
specifier|const
name|struct
name|language_defn
modifier|*
name|language_def
parameter_list|(
name|enum
name|language
name|lang
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|lang
condition|)
block|{
return|return
name|languages
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the language as a string */
end_comment

begin_function
name|char
modifier|*
name|language_str
parameter_list|(
name|enum
name|language
name|lang
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|lang
condition|)
block|{
return|return
name|languages
index|[
name|i
index|]
operator|->
name|la_name
return|;
block|}
block|}
return|return
literal|"Unknown"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_check
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set check\" must be followed by the name of a check subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setchecklist
argument_list|,
literal|"set check "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_check
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showchecklist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a language to the set of known languages.  */
end_comment

begin_function
name|void
name|add_language
parameter_list|(
specifier|const
name|struct
name|language_defn
modifier|*
name|lang
parameter_list|)
block|{
if|if
condition|(
name|lang
operator|->
name|la_magic
operator|!=
name|LANG_MAGIC
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Magic number of %s language struct wrong\n"
argument_list|,
name|lang
operator|->
name|la_name
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|languages
condition|)
block|{
name|languages_allocsize
operator|=
name|DEFAULT_ALLOCSIZE
expr_stmt|;
name|languages
operator|=
operator|(
specifier|const
expr|struct
name|language_defn
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|languages_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|languages
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|languages_size
operator|>=
name|languages_allocsize
condition|)
block|{
name|languages_allocsize
operator|*=
literal|2
expr_stmt|;
name|languages
operator|=
operator|(
specifier|const
expr|struct
name|language_defn
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|languages
argument_list|,
name|languages_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|languages
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|languages
index|[
name|languages_size
operator|++
index|]
operator|=
name|lang
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Iterate through all registered languages looking for and calling    any non-NULL struct language_defn.skip_trampoline() functions.    Return the result from the first that returns non-zero, or 0 if all    `fail'.  */
end_comment

begin_function
name|CORE_ADDR
name|skip_language_trampoline
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|skip_trampoline
condition|)
block|{
name|CORE_ADDR
name|real_pc
init|=
operator|(
name|languages
index|[
name|i
index|]
operator|->
name|skip_trampoline
operator|)
operator|(
name|pc
operator|)
decl_stmt|;
if|if
condition|(
name|real_pc
condition|)
return|return
name|real_pc
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return demangled language symbol, or NULL.      FIXME: Options are only useful for certain languages and ignored    by others, so it would be better to remove them here and have a    more flexible demangler for the languages that need it.      FIXME: Sometimes the demangler is invoked when we don't know the    language, so we can't use this everywhere.  */
end_comment

begin_function
name|char
modifier|*
name|language_demangle
parameter_list|(
specifier|const
name|struct
name|language_defn
modifier|*
name|current_language
parameter_list|,
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|int
name|options
parameter_list|)
block|{
if|if
condition|(
name|current_language
operator|!=
name|NULL
operator|&&
name|current_language
operator|->
name|la_demangle
condition|)
return|return
name|current_language
operator|->
name|la_demangle
argument_list|(
name|mangled
argument_list|,
name|options
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the default string containing the list of characters    delimiting words.  This is a reasonable default value that    most languages should be able to use.  */
end_comment

begin_function
name|char
modifier|*
name|default_word_break_characters
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';:?/>.<,-"
return|;
block|}
end_function

begin_comment
comment|/* Define the language that is no language.  */
end_comment

begin_function
specifier|static
name|int
name|unk_lang_parser
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_error
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|error
argument_list|(
literal|"Attempted to parse an expression with unknown language"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_emit_char called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_printchar called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|force_ellipses
parameter_list|)
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_printstr called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|unk_lang_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_create_fundamental_type called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_print_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|varstring
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_print_type called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unk_lang_val_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_val_print called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unk_lang_value_print
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_value_print called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|unk_lang_trampoline
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unknown languages just use the cplus demangler.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|unk_lang_demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|int
name|options
parameter_list|)
block|{
return|return
name|cplus_demangle
argument_list|(
name|mangled
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|unknown_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|unk_op_print_tab
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|OP_NULL
block|,
name|PREC_NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|unknown_language_defn
init|=
block|{
literal|"unknown"
block|,
name|language_unknown
block|,
operator|&
name|unknown_builtin_types
index|[
literal|0
index|]
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|unk_lang_parser
block|,
name|unk_lang_error
block|,
name|unk_lang_printchar
block|,
comment|/* Print character constant */
name|unk_lang_printstr
block|,
name|unk_lang_emit_char
block|,
name|unk_lang_create_fundamental_type
block|,
name|unk_lang_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|unk_lang_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|unk_lang_value_print
block|,
comment|/* Print a top-level value */
name|unk_lang_trampoline
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|unk_lang_demangle
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|unk_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These two structs define fake entries for the "local" and "auto" options. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|auto_language_defn
init|=
block|{
literal|"auto"
block|,
name|language_auto
block|,
operator|&
name|unknown_builtin_types
index|[
literal|0
index|]
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|unk_lang_parser
block|,
name|unk_lang_error
block|,
name|unk_lang_printchar
block|,
comment|/* Print character constant */
name|unk_lang_printstr
block|,
name|unk_lang_emit_char
block|,
name|unk_lang_create_fundamental_type
block|,
name|unk_lang_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|unk_lang_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|unk_lang_value_print
block|,
comment|/* Print a top-level value */
name|unk_lang_trampoline
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|unk_lang_demangle
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|unk_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|local_language_defn
init|=
block|{
literal|"local"
block|,
name|language_auto
block|,
operator|&
name|unknown_builtin_types
index|[
literal|0
index|]
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|unk_lang_parser
block|,
name|unk_lang_error
block|,
name|unk_lang_printchar
block|,
comment|/* Print character constant */
name|unk_lang_printstr
block|,
name|unk_lang_emit_char
block|,
name|unk_lang_create_fundamental_type
block|,
name|unk_lang_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|unk_lang_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|unk_lang_value_print
block|,
comment|/* Print a top-level value */
name|unk_lang_trampoline
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|unk_lang_demangle
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|unk_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the language routines */
end_comment

begin_function
name|void
name|_initialize_language
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|set
decl_stmt|,
modifier|*
name|show
decl_stmt|;
comment|/* GDB commands for language specific stuff */
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"language"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|language
argument_list|,
literal|"Set the current source language."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|set
argument_list|,
name|set_language_command
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|show
argument_list|,
name|show_language_command
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"check"
argument_list|,
name|no_class
argument_list|,
name|set_check
argument_list|,
literal|"Set the status of the type/range checker."
argument_list|,
operator|&
name|setchecklist
argument_list|,
literal|"set check "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"c"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"ch"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"check"
argument_list|,
name|no_class
argument_list|,
name|show_check
argument_list|,
literal|"Show the status of the type/range checker."
argument_list|,
operator|&
name|showchecklist
argument_list|,
literal|"show check "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"c"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"ch"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"type"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
literal|"Set type checking.  (on/warn/off/auto)"
argument_list|,
operator|&
name|setchecklist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showchecklist
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|set
argument_list|,
name|set_type_command
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|show
argument_list|,
name|show_type_command
argument_list|)
expr_stmt|;
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"range"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|range
argument_list|,
literal|"Set range checking.  (on/warn/off/auto)"
argument_list|,
operator|&
name|setchecklist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showchecklist
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|set
argument_list|,
name|set_range_command
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|show
argument_list|,
name|show_range_command
argument_list|)
expr_stmt|;
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"case-sensitive"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|case_sensitive
argument_list|,
literal|"Set case sensitivity in name search.  (on/off/auto)\n\ For Fortran the default is off; for other languages the default is on."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|set
argument_list|,
name|set_case_command
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|show
argument_list|,
name|show_case_command
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|unknown_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|local_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|auto_language_defn
argument_list|)
expr_stmt|;
name|language
operator|=
name|savestring
argument_list|(
literal|"auto"
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|savestring
argument_list|(
literal|"auto"
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
expr_stmt|;
name|range
operator|=
name|savestring
argument_list|(
literal|"auto"
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
expr_stmt|;
name|case_sensitive
operator|=
name|savestring
argument_list|(
literal|"auto"
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have the above take effect */
name|set_language
argument_list|(
name|language_auto
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

