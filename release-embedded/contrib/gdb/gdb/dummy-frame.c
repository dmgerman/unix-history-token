begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Code dealing with dummy stack frames, for GDB, the GNU debugger.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"dummy-frame.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_function_decl
specifier|static
name|void
name|dummy_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dummy frame.  This saves the processor state just prior to setting    up the inferior function call.  Older targets save the registers    on the target stack (but that really slows down function calls).  */
end_comment

begin_struct
struct|struct
name|dummy_frame
block|{
name|struct
name|dummy_frame
modifier|*
name|next
decl_stmt|;
comment|/* These values belong to the caller (the previous frame, the frame      that this unwinds back to).  */
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|CORE_ADDR
name|top
decl_stmt|;
name|struct
name|frame_id
name|id
decl_stmt|;
name|struct
name|regcache
modifier|*
name|regcache
decl_stmt|;
comment|/* Address range of the call dummy code.  Look for PC in the range      [LO..HI) (after allowing for DECR_PC_AFTER_BREAK).  */
name|CORE_ADDR
name|call_lo
decl_stmt|;
name|CORE_ADDR
name|call_hi
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dummy_frame
modifier|*
name|dummy_frame_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: find_dummy_frame(pc, fp, sp)     Search the stack of dummy frames for one matching the given PC and    FP/SP.  Unlike pc_in_dummy_frame(), this function doesn't need to    adjust for DECR_PC_AFTER_BREAK.  This is because it is only legal    to call this function after the PC has been adjusted.  */
end_comment

begin_function
specifier|static
name|struct
name|dummy_frame
modifier|*
name|find_dummy_frame
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fp
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|dummyframe
decl_stmt|;
for|for
control|(
name|dummyframe
operator|=
name|dummy_frame_stack
init|;
name|dummyframe
operator|!=
name|NULL
condition|;
name|dummyframe
operator|=
name|dummyframe
operator|->
name|next
control|)
block|{
comment|/* Does the PC fall within the dummy frame's breakpoint          instruction.  If not, discard this one.  */
if|if
condition|(
operator|!
operator|(
name|pc
operator|>=
name|dummyframe
operator|->
name|call_lo
operator|&&
name|pc
operator|<
name|dummyframe
operator|->
name|call_hi
operator|)
condition|)
continue|continue;
comment|/* Does the FP match?  */
if|if
condition|(
name|dummyframe
operator|->
name|top
operator|!=
literal|0
condition|)
block|{
comment|/* If the target architecture explicitly saved the 	     top-of-stack before the inferior function call, assume 	     that that same architecture will always pass in an FP 	     (frame base) value that eactly matches that saved TOS. 	     Don't check the saved SP and SP as they can lead to false 	     hits.  */
if|if
condition|(
name|fp
operator|!=
name|dummyframe
operator|->
name|top
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* An older target that hasn't explicitly or implicitly              saved the dummy frame's top-of-stack.  Try matching the              FP against the saved SP and FP.  NOTE: If you're trying              to fix a problem with GDB not correctly finding a dummy              frame, check the comments that go with FRAME_ALIGN() and              UNWIND_DUMMY_ID().  */
if|if
condition|(
name|fp
operator|!=
name|dummyframe
operator|->
name|fp
operator|&&
name|fp
operator|!=
name|dummyframe
operator|->
name|sp
condition|)
continue|continue;
block|}
comment|/* The FP matches this dummy frame.  */
return|return
name|dummyframe
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|regcache
modifier|*
name|deprecated_find_dummy_frame_regcache
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fp
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|dummy
init|=
name|find_dummy_frame
argument_list|(
name|pc
argument_list|,
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|dummy
operator|!=
name|NULL
condition|)
return|return
name|dummy
operator|->
name|regcache
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|deprecated_generic_find_dummy_frame
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fp
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|regcache
init|=
name|deprecated_find_dummy_frame_regcache
argument_list|(
name|pc
argument_list|,
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|regcache
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|deprecated_grub_regcache_for_registers
argument_list|(
name|regcache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: pc_in_call_dummy (pc, sp, fp)     Return true if the PC falls in a dummy frame created by gdb for an    inferior call.  The code below which allows DECR_PC_AFTER_BREAK is    for infrun.c, which may give the function a PC without that    subtracted out.  */
end_comment

begin_function
name|int
name|generic_pc_in_call_dummy
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|fp
parameter_list|)
block|{
return|return
name|pc_in_dummy_frame
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC falls in a dummy frame.     The code below which allows DECR_PC_AFTER_BREAK is for infrun.c,    which may give the function a PC without that subtracted out.     FIXME: cagney/2002-11-23: This is silly.  Surely "infrun.c" can    figure out what the real PC (as in the resume address) is BEFORE    calling this function (Oh, and I'm not even sure that this function    is called with an decremented PC, the call to pc_in_call_dummy() in    that file is conditional on    !DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET_P yet generic dummy    targets set DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET. True?).  */
end_comment

begin_function
name|int
name|pc_in_dummy_frame
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|dummyframe
decl_stmt|;
for|for
control|(
name|dummyframe
operator|=
name|dummy_frame_stack
init|;
name|dummyframe
operator|!=
name|NULL
condition|;
name|dummyframe
operator|=
name|dummyframe
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|pc
operator|>=
name|dummyframe
operator|->
name|call_lo
operator|)
operator|&&
operator|(
name|pc
operator|<
name|dummyframe
operator|->
name|call_hi
operator|+
name|DECR_PC_AFTER_BREAK
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: read_register_dummy     Find a saved register from before GDB calls a function in the inferior */
end_comment

begin_function
name|CORE_ADDR
name|deprecated_read_register_dummy
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|dummy_regs
init|=
name|deprecated_find_dummy_frame_regcache
argument_list|(
name|pc
argument_list|,
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|dummy_regs
condition|)
block|{
comment|/* NOTE: cagney/2002-08-12: Replaced a call to 	 regcache_raw_read_as_address() with a call to 	 regcache_cooked_read_unsigned().  The old, ...as_address 	 function was eventually calling extract_unsigned_integer (nee 	 extract_address) to unpack the registers value.  The below is 	 doing an unsigned extract so that it is functionally 	 equivalent.  The read needs to be cooked as, otherwise, it 	 will never correctly return the value of a register in the 	 [NUM_REGS .. NUM_REGS+NUM_PSEUDO_REGS) range.  */
name|ULONGEST
name|val
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|dummy_regs
argument_list|,
name|regno
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Save all the registers on the dummy frame stack.  Most ports save the    registers on the target stack.  This results in lots of unnecessary memory    references, which are slow when debugging via a serial line.  Instead, we    save all the registers internally, and never write them to the stack.  The    registers get restored when the called function returns to the entry point,    where a breakpoint is laying in wait.  */
end_comment

begin_function
name|void
name|generic_push_dummy_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|dummy_frame
decl_stmt|;
name|CORE_ADDR
name|fp
init|=
name|get_frame_base
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
decl_stmt|;
comment|/* check to see if there are stale dummy frames,       perhaps left over from when a longjump took us out of a       function that was called by the debugger */
name|dummy_frame
operator|=
name|dummy_frame_stack
expr_stmt|;
while|while
condition|(
name|dummy_frame
condition|)
if|if
condition|(
name|INNER_THAN
argument_list|(
name|dummy_frame
operator|->
name|fp
argument_list|,
name|fp
argument_list|)
condition|)
comment|/* stale -- destroy! */
block|{
name|dummy_frame_stack
operator|=
name|dummy_frame
operator|->
name|next
expr_stmt|;
name|regcache_xfree
argument_list|(
name|dummy_frame
operator|->
name|regcache
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dummy_frame
argument_list|)
expr_stmt|;
name|dummy_frame
operator|=
name|dummy_frame_stack
expr_stmt|;
block|}
else|else
name|dummy_frame
operator|=
name|dummy_frame
operator|->
name|next
expr_stmt|;
name|dummy_frame
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dummy_frame
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_frame
operator|->
name|regcache
operator|=
name|regcache_xmalloc
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
name|dummy_frame
operator|->
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|dummy_frame
operator|->
name|sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
name|dummy_frame
operator|->
name|top
operator|=
literal|0
expr_stmt|;
name|dummy_frame
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|dummy_frame
operator|->
name|id
operator|=
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|regcache_cpy
argument_list|(
name|dummy_frame
operator|->
name|regcache
argument_list|,
name|current_regcache
argument_list|)
expr_stmt|;
name|dummy_frame
operator|->
name|next
operator|=
name|dummy_frame_stack
expr_stmt|;
name|dummy_frame_stack
operator|=
name|dummy_frame
expr_stmt|;
block|}
end_function

begin_function
name|void
name|generic_save_dummy_frame_tos
parameter_list|(
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|dummy_frame_stack
operator|->
name|top
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the upper/lower bounds on the address of the call dummy.  */
end_comment

begin_function
name|void
name|generic_save_call_dummy_addr
parameter_list|(
name|CORE_ADDR
name|lo
parameter_list|,
name|CORE_ADDR
name|hi
parameter_list|)
block|{
name|dummy_frame_stack
operator|->
name|call_lo
operator|=
name|lo
expr_stmt|;
name|dummy_frame_stack
operator|->
name|call_hi
operator|=
name|hi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the machine state from either the saved dummy stack or a    real stack frame. */
end_comment

begin_function
name|void
name|generic_pop_current_frame
parameter_list|(
name|void
function_decl|(
modifier|*
name|popper
function_decl|)
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
if|if
condition|(
name|get_frame_type
argument_list|(
name|frame
argument_list|)
operator|==
name|DUMMY_FRAME
condition|)
comment|/* NOTE: cagney/2002-22-23: Does this ever occure?  Surely a dummy        frame will have already been poped by the "infrun.c" code.  */
name|generic_pop_dummy_frame
argument_list|()
expr_stmt|;
else|else
call|(
modifier|*
name|popper
call|)
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard the innermost dummy frame from the dummy frame stack    (passed in as a parameter).  */
end_comment

begin_function
specifier|static
name|void
name|discard_innermost_dummy
parameter_list|(
name|struct
name|dummy_frame
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|tbd
init|=
operator|(
operator|*
name|stack
operator|)
decl_stmt|;
operator|(
operator|*
name|stack
operator|)
operator|=
operator|(
operator|*
name|stack
operator|)
operator|->
name|next
expr_stmt|;
name|regcache_xfree
argument_list|(
name|tbd
operator|->
name|regcache
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tbd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|generic_pop_dummy_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|dummy_frame
init|=
name|dummy_frame_stack
decl_stmt|;
comment|/* FIXME: what if the first frame isn't the right one, eg..      because one call-by-hand function has done a longjmp into another one? */
if|if
condition|(
operator|!
name|dummy_frame
condition|)
name|error
argument_list|(
literal|"Can't pop dummy frame!"
argument_list|)
expr_stmt|;
name|regcache_cpy
argument_list|(
name|current_regcache
argument_list|,
name|dummy_frame
operator|->
name|regcache
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|discard_innermost_dummy
argument_list|(
operator|&
name|dummy_frame_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a call-dummy dummy-frame, return the registers.  Here the    register value is taken from the local copy of the register buffer.  */
end_comment

begin_function
specifier|static
name|void
name|dummy_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnum
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|dummy
decl_stmt|;
name|struct
name|frame_id
name|id
decl_stmt|;
comment|/* Call the ID method which, if at all possible, will set the      prologue cache.  */
name|dummy_frame_this_id
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|dummy
operator|=
operator|(
operator|*
name|this_prologue_cache
operator|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|dummy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Describe the register's location.  Generic dummy frames always      have the register value in an ``expression''.  */
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If needed, find and return the value of the register.  */
if|if
condition|(
name|bufferp
operator|!=
name|NULL
condition|)
block|{
comment|/* Return the actual value.  */
comment|/* Use the regcache_cooked_read() method so that it, on the fly,          constructs either a raw or pseudo register from the raw          register cache.  */
name|regcache_cooked_read
argument_list|(
name|dummy
operator|->
name|regcache
argument_list|,
name|regnum
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assuming that THIS frame is a dummy (remember, the NEXT and not    THIS frame is passed in), return the ID of THIS frame.  That ID is    determined by examining the NEXT frame's unwound registers using    the method unwind_dummy_id().  As a side effect, THIS dummy frame's    dummy cache is located and and saved in THIS_PROLOGUE_CACHE.  */
end_comment

begin_function
specifier|static
name|void
name|dummy_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|dummy
init|=
operator|(
operator|*
name|this_prologue_cache
operator|)
decl_stmt|;
if|if
condition|(
name|dummy
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|this_id
operator|)
operator|=
name|dummy
operator|->
name|id
expr_stmt|;
return|return;
block|}
comment|/* When unwinding a normal frame, the stack structure is determined      by analyzing the frame's function's code (be it using brute force      prologue analysis, or the dwarf2 CFI).  In the case of a dummy      frame, that simply isn't possible.  The The PC is either the      program entry point, or some random address on the stack.  Trying      to use that PC to apply standard frame ID unwind techniques is      just asking for trouble.  */
if|if
condition|(
name|gdbarch_unwind_dummy_id_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* Use an architecture specific method to extract the prev's 	 dummy ID from the next frame.  Note that this method uses 	 frame_register_unwind to obtain the register values needed to 	 determine the dummy frame's ID.  */
operator|(
operator|*
name|this_id
operator|)
operator|=
name|gdbarch_unwind_dummy_id
argument_list|(
name|current_gdbarch
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_relative_level
argument_list|(
name|next_frame
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We're unwinding a sentinel frame, the PC of which is pointing 	 at a stack dummy.  Fake up the dummy frame's ID using the 	 same sequence as is found a traditional unwinder.  Once all 	 architectures supply the unwind_dummy_id method, this code 	 can go away.  */
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|deprecated_read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|legacy_frame_p
argument_list|(
name|current_gdbarch
argument_list|)
operator|&&
name|get_prev_frame
argument_list|(
name|next_frame
argument_list|)
condition|)
block|{
comment|/* Things are looking seriously grim!  Assume that the legacy          get_prev_frame code has already created THIS frame and linked          it in to the frame chain (a pretty bold assumption), extract          the ID from THIS base / pc.  */
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|get_frame_base
argument_list|(
name|get_prev_frame
argument_list|(
name|next_frame
argument_list|)
argument_list|)
argument_list|,
name|get_frame_pc
argument_list|(
name|get_prev_frame
argument_list|(
name|next_frame
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ouch!  We're not trying to find the innermost frame's ID yet 	 we're trying to unwind to a dummy.  The architecture must 	 provide the unwind_dummy_id() method.  Abandon the unwind 	 process but only after first warning the user.  */
name|internal_warning
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Missing unwind_dummy_id architecture method"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|null_frame_id
expr_stmt|;
return|return;
block|}
operator|(
operator|*
name|this_prologue_cache
operator|)
operator|=
name|find_dummy_frame
argument_list|(
operator|(
operator|*
name|this_id
operator|)
operator|.
name|code_addr
argument_list|,
operator|(
operator|*
name|this_id
operator|)
operator|.
name|stack_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|frame_unwind
name|dummy_frame_unwind
init|=
block|{
name|DUMMY_FRAME
block|,
name|dummy_frame_this_id
block|,
name|dummy_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|struct
name|frame_unwind
modifier|*
name|dummy_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY_P
argument_list|()
condition|?
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|pc_in_dummy_frame
argument_list|(
name|pc
argument_list|)
condition|)
return|return
operator|&
name|dummy_frame_unwind
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fprint_dummy_frames
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|dummy_frame
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|dummy_frame_stack
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|gdb_print_host_address
argument_list|(
name|s
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" pc=0x%s"
argument_list|,
name|paddr
argument_list|(
name|s
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" fp=0x%s"
argument_list|,
name|paddr
argument_list|(
name|s
operator|->
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" sp=0x%s"
argument_list|,
name|paddr
argument_list|(
name|s
operator|->
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" top=0x%s"
argument_list|,
name|paddr
argument_list|(
name|s
operator|->
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" id="
argument_list|)
expr_stmt|;
name|fprint_frame_id
argument_list|(
name|file
argument_list|,
name|s
operator|->
name|id
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" call_lo=0x%s"
argument_list|,
name|paddr
argument_list|(
name|s
operator|->
name|call_lo
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" call_hi=0x%s"
argument_list|,
name|paddr
argument_list|(
name|s
operator|->
name|call_hi
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_print_dummy_frames
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|fprint_dummy_frames
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|ui_file
modifier|*
name|file
init|=
name|gdb_fopen
argument_list|(
name|args
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
literal|"maintenance print dummy-frames"
argument_list|)
expr_stmt|;
name|fprint_dummy_frames
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|_initialize_dummy_frame
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_dummy_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|add_cmd
argument_list|(
literal|"dummy-frames"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_dummy_frames
argument_list|,
literal|"Print the contents of the internal dummy-frame stack."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

