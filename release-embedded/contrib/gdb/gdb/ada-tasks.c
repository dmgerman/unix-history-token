begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* file ada-tasks.c: Ada tasking control for GDB    Copyright 1997 Free Software Foundation, Inc.    Contributed by Ada Core Technologies, Inc .    This file is part of GDB.     [$Id: ada-tasks.c,v 1.7 2003/06/17 20:58:32 ciceron Exp $]    Authors: Roch-Alexandre Nomine Beguin, Arnaud Charlet<charlet@gnat.com>     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__alpha_vxworks
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ada-lang.h"
end_include

begin_comment
comment|/* FIXME: move all this conditional compilation in description    files or in configure.in */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
end_if

begin_define
define|#
directive|define
name|THREAD_TO_PID
parameter_list|(
name|tid
parameter_list|,
name|lwpid
parameter_list|)
value|(tid)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_define
define|#
directive|define
name|THREAD_TO_PID
parameter_list|(
name|tid
parameter_list|,
name|lwpid
parameter_list|)
value|(0)
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|)
end_elif

begin_define
define|#
directive|define
name|THREAD_TO_PID
value|thread_to_pid
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
end_elif

begin_define
define|#
directive|define
name|THREAD_TO_PID
parameter_list|(
name|tid
parameter_list|,
name|lwpid
parameter_list|)
value|((int)lwpid)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|THREAD_TO_PID
parameter_list|(
name|tid
parameter_list|,
name|lwpid
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
end_if

begin_define
define|#
directive|define
name|THREAD_FETCH_REGISTERS
value|dec_thread_fetch_registers
end_define

begin_define
define|#
directive|define
name|GET_CURRENT_THREAD
value|dec_thread_get_current_thread
end_define

begin_function_decl
specifier|extern
name|int
name|dec_thread_get_registers
parameter_list|(
name|gdb_gregset_t
modifier|*
parameter_list|,
name|gdb_fpregset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_define
define|#
directive|define
name|THREAD_FETCH_REGISTERS
value|aix_thread_fetch_registers
end_define

begin_define
define|#
directive|define
name|GET_CURRENT_THREAD
value|aix_thread_get_current_thread
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
end_if

begin_define
define|#
directive|define
name|GET_CURRENT_THREAD
parameter_list|()
value|((void*)inferior_pid)
end_define

begin_define
define|#
directive|define
name|THREAD_FETCH_REGISTERS
parameter_list|()
value|(-1)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SVR4
argument_list|)
end_elif

begin_define
define|#
directive|define
name|GET_CURRENT_THREAD
value|solaris_thread_get_current_thread
end_define

begin_define
define|#
directive|define
name|THREAD_FETCH_REGISTERS
parameter_list|()
value|(-1)
end_define

begin_function_decl
specifier|extern
name|void
modifier|*
name|GET_CURRENT_THREAD
parameter_list|()
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|)
end_elif

begin_function_decl
specifier|extern
name|void
modifier|*
name|GET_CURRENT_THREAD
parameter_list|()
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
end_elif

begin_define
define|#
directive|define
name|GET_CURRENT_THREAD
parameter_list|()
value|(inferior_pid)
end_define

begin_define
define|#
directive|define
name|THREAD_FETCH_REGISTERS
parameter_list|()
value|(-1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GET_CURRENT_THREAD
parameter_list|()
value|(NULL)
end_define

begin_define
define|#
directive|define
name|THREAD_FETCH_REGISTERS
parameter_list|()
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|KNOWN_TASKS_NAME
value|"system__tasking__debug__known_tasks"
end_define

begin_define
define|#
directive|define
name|READ_MEMORY
parameter_list|(
name|addr
parameter_list|,
name|var
parameter_list|)
value|read_memory (addr, (char*)&var, sizeof (var))
end_define

begin_comment
comment|/* external declarations */
end_comment

begin_comment
comment|/* Global visible variables */
end_comment

begin_decl_stmt
name|struct
name|task_entry
modifier|*
name|task_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ada__tasks_check_symbol_table
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|pthread_kern_addr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
operator|)
end_if

begin_decl_stmt
name|gdb_gregset_t
name|gregset_saved
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gdb_fpregset_t
name|fpregset_saved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The maximum number of tasks known to the Ada runtime */
end_comment

begin_decl_stmt
specifier|const
name|int
name|MAX_NUMBER_OF_KNOWN_TASKS
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current task */
end_comment

begin_decl_stmt
name|int
name|current_task
init|=
operator|-
literal|1
decl_stmt|,
name|current_task_id
init|=
operator|-
literal|1
decl_stmt|,
name|current_task_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|current_thread
decl_stmt|,
modifier|*
name|current_lwp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ada_task_states
index|[]
init|=
block|{
literal|"Unactivated"
block|,
literal|"Runnable"
block|,
literal|"Terminated"
block|,
literal|"Child Activation Wait"
block|,
literal|"Accept Statement"
block|,
literal|"Waiting on entry call"
block|,
literal|"Async Select Wait"
block|,
literal|"Delay Sleep"
block|,
literal|"Child Termination Wait"
block|,
literal|"Wait Child in Term Alt"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"Asynchronous Hold"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global internal types */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ada_long_task_states
index|[]
init|=
block|{
literal|"Unactivated"
block|,
literal|"Runnable"
block|,
literal|"Terminated"
block|,
literal|"Waiting for child activation"
block|,
literal|"Blocked in accept statement"
block|,
literal|"Waiting on entry call"
block|,
literal|"Asynchronous Selective Wait"
block|,
literal|"Delay Sleep"
block|,
literal|"Waiting for children termination"
block|,
literal|"Waiting for children in terminate alternative"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"Asynchronous Hold"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global internal variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|highest_task_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|thread_support
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if the thread library in use is supported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gdbtk_task_initialization
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_task_entry
parameter_list|(
name|void
modifier|*
name|p_task_id
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|task_entry
modifier|*
name|new_task_entry
init|=
name|NULL
decl_stmt|;
name|struct
name|task_entry
modifier|*
name|pt
decl_stmt|;
name|highest_task_num
operator|++
expr_stmt|;
name|new_task_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|task_entry
argument_list|)
argument_list|)
expr_stmt|;
name|new_task_entry
operator|->
name|task_num
operator|=
name|highest_task_num
expr_stmt|;
name|new_task_entry
operator|->
name|task_id
operator|=
name|p_task_id
expr_stmt|;
name|new_task_entry
operator|->
name|known_tasks_index
operator|=
name|index
expr_stmt|;
name|new_task_entry
operator|->
name|next_task
operator|=
name|NULL
expr_stmt|;
name|pt
operator|=
name|task_list
expr_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
while|while
condition|(
name|pt
operator|->
name|next_task
condition|)
name|pt
operator|=
name|pt
operator|->
name|next_task
expr_stmt|;
name|pt
operator|->
name|next_task
operator|=
name|new_task_entry
expr_stmt|;
name|pt
operator|->
name|stack_per
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|task_list
operator|=
name|new_task_entry
expr_stmt|;
return|return
name|new_task_entry
operator|->
name|task_num
return|;
block|}
end_function

begin_function
name|int
name|get_entry_number
parameter_list|(
name|void
modifier|*
name|p_task_id
parameter_list|)
block|{
name|struct
name|task_entry
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|task_list
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|task_id
operator|==
name|p_task_id
condition|)
return|return
name|pt
operator|->
name|task_num
return|;
name|pt
operator|=
name|pt
operator|->
name|next_task
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|task_entry
modifier|*
name|get_thread_entry_vptr
parameter_list|(
name|void
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|task_entry
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|task_list
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|thread
operator|==
name|thread
condition|)
return|return
name|pt
return|;
name|pt
operator|=
name|pt
operator|->
name|next_task
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|task_entry
modifier|*
name|get_entry_vptr
parameter_list|(
name|int
name|p_task_num
parameter_list|)
block|{
name|struct
name|task_entry
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|task_list
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|task_num
operator|==
name|p_task_num
condition|)
return|return
name|pt
return|;
name|pt
operator|=
name|pt
operator|->
name|next_task
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|init_task_list
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|task_entry
modifier|*
name|pt
decl_stmt|,
modifier|*
name|old_pt
decl_stmt|;
name|pt
operator|=
name|task_list
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|old_pt
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|next_task
expr_stmt|;
name|xfree
argument_list|(
name|old_pt
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|task_list
operator|=
name|NULL
expr_stmt|;
name|highest_task_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|valid_task_id
parameter_list|(
name|int
name|task
parameter_list|)
block|{
return|return
name|get_entry_vptr
argument_list|(
name|task
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|get_self_id
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|void
modifier|*
name|self_id
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|task_entry
modifier|*
name|ent
decl_stmt|;
specifier|extern
name|int
name|do_not_insert_breakpoints
decl_stmt|;
if|#
directive|if
operator|!
operator|(
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|)
if|if
condition|(
name|thread_support
condition|)
endif|#
directive|endif
block|{
name|ent
operator|=
name|get_thread_entry_vptr
argument_list|(
name|GET_CURRENT_THREAD
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ent
condition|?
name|ent
operator|->
name|task_id
else|:
literal|0
return|;
block|}
comment|/* FIXME: calling a function in the inferior with a multithreaded application      is not reliable, so return NULL if there is no safe way to get the current      task */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|get_current_task
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
comment|/* FIXME: language_ada should be defined in defs.h */
comment|/*  if (current_language->la_language != language_ada) return -1; */
name|result
operator|=
name|get_entry_number
argument_list|(
name|get_self_id
argument_list|()
argument_list|)
expr_stmt|;
comment|/* return -1 if not found */
return|return
name|result
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
name|result
return|;
block|}
end_function

begin_comment
comment|/* Print detailed information about specified task */
end_comment

begin_function
specifier|static
name|void
name|info_task
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|void
modifier|*
name|temp_task
decl_stmt|;
name|struct
name|task_entry
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pt2
decl_stmt|;
name|void
modifier|*
name|self_id
decl_stmt|,
modifier|*
name|caller
decl_stmt|;
name|struct
name|task_fields
name|atcb
decl_stmt|,
name|atcb2
decl_stmt|;
name|struct
name|entry_call
name|call
decl_stmt|;
name|int
name|bounds
index|[
literal|2
index|]
decl_stmt|;
name|char
name|image
index|[
literal|256
index|]
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* FIXME: language_ada should be defined in defs.h */
comment|/*  if (current_language->la_language != language_ada)       {       printf_filtered ("The current language does not support tasks.\n");       return;       }     */
name|pt
operator|=
name|get_entry_vptr
argument_list|(
name|atoi
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Task %s not found.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp_task
operator|=
name|pt
operator|->
name|task_id
expr_stmt|;
comment|/* read the atcb in the inferior */
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|temp_task
argument_list|,
name|atcb
argument_list|)
expr_stmt|;
comment|/* print the Ada task id */
name|printf_filtered
argument_list|(
literal|"Ada Task: %p\n"
argument_list|,
name|temp_task
argument_list|)
expr_stmt|;
comment|/* print the name of the task */
if|if
condition|(
name|atcb
operator|.
name|image
operator|.
name|P_ARRAY
operator|!=
name|NULL
condition|)
block|{
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|image
operator|.
name|P_BOUNDS
argument_list|)
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
name|bounds
index|[
literal|1
index|]
operator|=
name|EXTRACT_INT
argument_list|(
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|image
operator|.
name|P_ARRAY
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|image
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Name: %.*s\n"
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"<no name>\n"
argument_list|)
expr_stmt|;
comment|/* print the thread id */
if|if
condition|(
operator|(
name|long
operator|)
name|pt
operator|->
name|thread
operator|<
literal|65536
condition|)
name|printf_filtered
argument_list|(
literal|"Thread: %ld\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|pt
operator|->
name|thread
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Thread: %p\n"
argument_list|,
name|pt
operator|->
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|pt
operator|->
name|lwp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|pt
operator|->
name|lwp
operator|<
literal|65536
condition|)
name|printf_filtered
argument_list|(
literal|"LWP: %ld\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|pt
operator|->
name|lwp
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"LWP: %p\n"
argument_list|,
name|pt
operator|->
name|lwp
argument_list|)
expr_stmt|;
block|}
comment|/* print the parent gdb task id */
name|num
operator|=
name|get_entry_number
argument_list|(
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|!=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Parent: %d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|pt2
operator|=
name|get_entry_vptr
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|pt2
operator|->
name|task_id
argument_list|,
name|atcb2
argument_list|)
expr_stmt|;
comment|/* print the name of the task */
if|if
condition|(
name|atcb2
operator|.
name|image
operator|.
name|P_ARRAY
operator|!=
name|NULL
condition|)
block|{
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb2
operator|.
name|image
operator|.
name|P_BOUNDS
argument_list|)
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
name|bounds
index|[
literal|1
index|]
operator|=
name|EXTRACT_INT
argument_list|(
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb2
operator|.
name|image
operator|.
name|P_ARRAY
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|image
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" (%.*s)\n"
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"No parent\n"
argument_list|)
expr_stmt|;
comment|/* print the base priority of the task */
name|printf_filtered
argument_list|(
literal|"Base Priority: %d\n"
argument_list|,
name|EXTRACT_INT
argument_list|(
name|atcb
operator|.
name|priority
argument_list|)
argument_list|)
expr_stmt|;
comment|/* print the current state of the task */
comment|/* check if this task is accepting a rendezvous */
if|if
condition|(
name|atcb
operator|.
name|call
operator|==
name|NULL
condition|)
name|caller
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|call
argument_list|)
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|caller
operator|=
name|EXTRACT_ADDRESS
argument_list|(
name|call
operator|.
name|self
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|caller
operator|!=
name|NULL
condition|)
block|{
name|num
operator|=
name|get_entry_number
argument_list|(
name|caller
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Accepting rendezvous with %d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|!=
literal|0
condition|)
block|{
name|pt2
operator|=
name|get_entry_vptr
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|pt2
operator|->
name|task_id
argument_list|,
name|atcb2
argument_list|)
expr_stmt|;
comment|/* print the name of the task */
if|if
condition|(
name|atcb2
operator|.
name|image
operator|.
name|P_ARRAY
operator|!=
name|NULL
condition|)
block|{
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb2
operator|.
name|image
operator|.
name|P_BOUNDS
argument_list|)
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
name|bounds
index|[
literal|1
index|]
operator|=
name|EXTRACT_INT
argument_list|(
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb2
operator|.
name|image
operator|.
name|P_ARRAY
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|image
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" (%.*s)\n"
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"State: %s\n"
argument_list|,
name|ada_long_task_states
index|[
name|atcb
operator|.
name|state
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* A useful function that shows the alignment of all the fields in the    tasks_fields structure  */
end_comment

begin_endif
unit|print_align (void) {   struct task_fields tf;   void *tf_base =&(tf);   void *tf_state =&(tf.state);   void *tf_entry_num =&(tf.entry_num);   void *tf_parent =&(tf.parent);   void *tf_priority =&(tf.priority);   void *tf_current_priority =&(tf.current_priority);   void *tf_image =&(tf.image);   void *tf_call =&(tf.call);   void *tf_thread =&(tf.thread);   void *tf_lwp =&(tf.lwp);   printf_filtered ("\n");   printf_filtered ("(tf_base = 0x%x)\n", tf_base);   printf_filtered ("task_fields.entry_num        at %3d (0x%x)\n", 		   tf_entry_num - tf_base, tf_entry_num);   printf_filtered ("task_fields.state            at %3d (0x%x)\n", 		   tf_state - tf_base, tf_state);   printf_filtered ("task_fields.parent           at %3d (0x%x)\n", 		   tf_parent - tf_base, tf_parent);   printf_filtered ("task_fields.priority         at %3d (0x%x)\n", 		   tf_priority - tf_base, tf_priority);   printf_filtered ("task_fields.current_priority at %3d (0x%x)\n", 		   tf_current_priority - tf_base, tf_current_priority);   printf_filtered ("task_fields.image            at %3d (0x%x)\n", 		   tf_image - tf_base, tf_image);   printf_filtered ("task_fields.call             at %3d (0x%x)\n", 		   tf_call - tf_base, tf_call);   printf_filtered ("task_fields.thread           at %3d (0x%x)\n", 		   tf_thread - tf_base, tf_thread);   printf_filtered ("task_fields.lwp              at %3d (0x%x)\n", 		   tf_lwp - tf_base, tf_lwp);   printf_filtered ("\n"); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print information about currently known tasks */
end_comment

begin_function
specifier|static
name|void
name|info_tasks
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|task_number
decl_stmt|,
name|state
decl_stmt|;
name|void
modifier|*
name|temp_task
decl_stmt|,
modifier|*
name|temp_tasks
index|[
name|MAX_NUMBER_OF_KNOWN_TASKS
index|]
decl_stmt|;
name|struct
name|task_entry
modifier|*
name|pt
decl_stmt|;
name|void
modifier|*
name|self_id
decl_stmt|,
modifier|*
name|caller
decl_stmt|,
modifier|*
name|thread_id
init|=
name|NULL
decl_stmt|;
name|struct
name|task_fields
name|atcb
decl_stmt|;
name|struct
name|entry_call
name|call
decl_stmt|;
name|int
name|bounds
index|[
literal|2
index|]
decl_stmt|;
name|char
name|image
index|[
literal|256
index|]
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
name|car
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
name|pthreadTeb_t
name|thr
decl_stmt|;
name|gdb_gregset_t
name|regs
decl_stmt|;
endif|#
directive|endif
specifier|static
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|static
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
specifier|static
name|void
modifier|*
name|known_tasks_addr
init|=
name|NULL
decl_stmt|;
name|int
name|init_only
init|=
name|gdbtk_task_initialization
decl_stmt|;
name|gdbtk_task_initialization
operator|=
literal|0
expr_stmt|;
name|task_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"The program is not being run under gdb. "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Use 'run' or 'attach' first.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ada__tasks_check_symbol_table
condition|)
block|{
name|thread_support
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
operator|)
operator|||
expr|\
name|defined
argument_list|(
name|_AIX
argument_list|)
name|thread_support
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|KNOWN_TASKS_NAME
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
name|known_tasks_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
else|else
ifndef|#
directive|ifndef
name|VXWORKS_TARGET
return|return;
else|#
directive|else
block|{
if|if
condition|(
name|target_lookup_symbol
argument_list|(
name|KNOWN_TASKS_NAME
argument_list|,
operator|&
name|known_tasks_addr
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
name|ada__tasks_check_symbol_table
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|known_tasks_addr
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
operator|!
operator|(
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
operator|)
if|if
condition|(
name|thread_support
condition|)
endif|#
directive|endif
name|thread_id
operator|=
name|GET_CURRENT_THREAD
argument_list|()
expr_stmt|;
comment|/* then we get a list of tasks created */
name|init_task_list
argument_list|()
expr_stmt|;
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|known_tasks_addr
argument_list|,
name|temp_tasks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUMBER_OF_KNOWN_TASKS
condition|;
name|i
operator|++
control|)
block|{
name|temp_task
operator|=
name|EXTRACT_ADDRESS
argument_list|(
name|temp_tasks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_task
operator|!=
name|NULL
condition|)
block|{
name|task_number
operator|=
name|get_entry_number
argument_list|(
name|temp_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|task_number
operator|==
literal|0
condition|)
name|task_number
operator|=
name|add_task_entry
argument_list|(
name|temp_task
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return without printing anything if this function was called in      order to init GDBTK tasking. */
if|if
condition|(
name|init_only
condition|)
return|return;
comment|/* print the header */
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
name|printf_filtered
argument_list|(
literal|"  ID       TID P-ID Pri Stack  %% State                  Name\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"  ID       TID P-ID Pri State                  Name\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now that we have a list of task id's, we can print them */
name|pt
operator|=
name|task_list
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|temp_task
operator|=
name|pt
operator|->
name|task_id
expr_stmt|;
comment|/* read the atcb in the inferior */
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|temp_task
argument_list|,
name|atcb
argument_list|)
expr_stmt|;
comment|/* store the thread id for future use */
name|pt
operator|->
name|thread
operator|=
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|thread
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
name|pt
operator|->
name|lwp
operator|=
operator|(
name|void
operator|*
operator|)
name|THREAD_TO_PID
argument_list|(
name|atcb
operator|.
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pt
operator|->
name|lwp
operator|=
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|lwp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* print a star if this task is the current one */
if|if
condition|(
name|thread_id
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|SGI
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
name|printf_filtered
argument_list|(
name|pt
operator|->
name|lwp
operator|==
name|thread_id
condition|?
literal|"*"
else|:
literal|" "
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
name|pt
operator|->
name|thread
operator|==
name|thread_id
condition|?
literal|"*"
else|:
literal|" "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* print the gdb task id */
name|printf_filtered
argument_list|(
literal|"%3d"
argument_list|,
name|pt
operator|->
name|task_num
argument_list|)
expr_stmt|;
comment|/* print the Ada task id */
ifndef|#
directive|ifndef
name|VXWORKS_TARGET
name|printf_filtered
argument_list|(
literal|" %9lx"
argument_list|,
operator|(
name|long
operator|)
name|temp_task
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TARGET_64
name|printf_filtered
argument_list|(
literal|" %#9lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pt
operator|->
name|thread
operator|&
literal|0x3ffffffffff
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|" %#9lx"
argument_list|,
operator|(
name|long
operator|)
name|pt
operator|->
name|thread
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* print the parent gdb task id */
name|printf_filtered
argument_list|(
literal|" %4d"
argument_list|,
name|get_entry_number
argument_list|(
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|parent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* print the base priority of the task */
name|printf_filtered
argument_list|(
literal|" %3d"
argument_list|,
name|EXTRACT_INT
argument_list|(
name|atcb
operator|.
name|priority
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
if|if
condition|(
name|pt
operator|->
name|task_num
operator|==
literal|1
operator|||
name|atcb
operator|.
name|state
operator|==
name|Terminated
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"  Unknown"
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|atcb
operator|.
name|thread
argument_list|,
operator|&
name|thr
argument_list|,
sizeof|sizeof
argument_list|(
name|thr
argument_list|)
argument_list|)
expr_stmt|;
name|current_thread
operator|=
name|atcb
operator|.
name|thread
expr_stmt|;
name|regs
operator|.
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dec_thread_get_registers
argument_list|(
operator|&
name|regs
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pt
operator|->
name|stack_per
operator|=
operator|(
literal|100
operator|*
operator|(
operator|(
name|long
operator|)
name|thr
operator|.
name|__stack_base
operator|-
name|regs
operator|.
name|regs
index|[
name|SP_REGNUM
index|]
operator|)
operator|)
operator|/
name|thr
operator|.
name|__stack_size
expr_stmt|;
comment|/* if the thread is terminated but still there, the 	     stack_base/size values are erroneous. Try to patch it */
if|if
condition|(
name|pt
operator|->
name|stack_per
operator|<
literal|0
operator|||
name|pt
operator|->
name|stack_per
operator|>
literal|100
condition|)
name|pt
operator|->
name|stack_per
operator|=
literal|0
expr_stmt|;
block|}
comment|/* print information about stack space used in the thread */
if|if
condition|(
name|thr
operator|.
name|__stack_size
operator|<
literal|1024
operator|*
literal|1024
condition|)
block|{
name|size
operator|=
name|thr
operator|.
name|__stack_size
operator|/
literal|1024
expr_stmt|;
name|car
operator|=
literal|'K'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|thr
operator|.
name|__stack_size
operator|<
literal|1024
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|size
operator|=
name|thr
operator|.
name|__stack_size
operator|/
literal|1024
operator|/
literal|1024
expr_stmt|;
name|car
operator|=
literal|'M'
expr_stmt|;
block|}
else|else
comment|/* Who knows... */
block|{
name|size
operator|=
name|thr
operator|.
name|__stack_size
operator|/
literal|1024
operator|/
literal|1024
operator|/
literal|1024
expr_stmt|;
name|car
operator|=
literal|'G'
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|" %4d%c %2d"
argument_list|,
name|size
argument_list|,
name|car
argument_list|,
name|pt
operator|->
name|stack_per
argument_list|)
expr_stmt|;
name|next
label|:
endif|#
directive|endif
comment|/* print the current state of the task */
comment|/* check if this task is accepting a rendezvous */
if|if
condition|(
name|atcb
operator|.
name|call
operator|==
name|NULL
condition|)
name|caller
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|call
argument_list|)
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|caller
operator|=
name|EXTRACT_ADDRESS
argument_list|(
name|call
operator|.
name|self
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|caller
operator|!=
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|" Accepting RV with %-4d"
argument_list|,
name|get_entry_number
argument_list|(
name|caller
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|state
operator|=
name|atcb
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|SGI
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
if|if
condition|(
name|state
operator|==
name|Runnable
operator|&&
operator|(
name|thread_id
operator|&&
name|pt
operator|->
name|lwp
operator|==
name|thread_id
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|state
operator|==
name|Runnable
operator|&&
operator|(
name|thread_id
operator|&&
name|pt
operator|->
name|thread
operator|==
name|thread_id
operator|)
condition|)
endif|#
directive|endif
comment|/* Replace "Runnable" by "Running" if this is the current task */
name|printf_filtered
argument_list|(
literal|" %-22s"
argument_list|,
literal|"Running"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" %-22s"
argument_list|,
name|ada_task_states
index|[
name|state
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* finally, print the name of the task */
if|if
condition|(
name|atcb
operator|.
name|image
operator|.
name|P_ARRAY
operator|!=
name|NULL
condition|)
block|{
name|READ_MEMORY
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|image
operator|.
name|P_BOUNDS
argument_list|)
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
name|bounds
index|[
literal|1
index|]
operator|=
name|EXTRACT_INT
argument_list|(
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|EXTRACT_ADDRESS
argument_list|(
name|atcb
operator|.
name|image
operator|.
name|P_ARRAY
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|image
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %.*s\n"
argument_list|,
name|bounds
index|[
literal|1
index|]
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"<no name>\n"
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|next_task
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Task list initialization for GDB-Tk.  We basically use info_tasks()    to initialize our variables, but abort that function before we    actually print anything. */
end_comment

begin_function
name|int
name|gdbtk_tcl_tasks_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbtk_task_initialization
operator|=
literal|1
expr_stmt|;
name|info_tasks
argument_list|(
literal|""
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|task_list
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_tasks_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|arg
operator|==
literal|'\000'
condition|)
name|info_tasks
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|info_task
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch from one thread to another. */
end_comment

begin_function
specifier|static
name|void
name|switch_to_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
return|return;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch to a specified task. */
end_comment

begin_function
specifier|static
name|int
name|task_switch
parameter_list|(
name|void
modifier|*
name|tid
parameter_list|,
name|void
modifier|*
name|lwpid
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|,
name|pid
decl_stmt|;
if|if
condition|(
name|thread_support
condition|)
block|{
name|flush_cached_frames
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_task
operator|!=
name|current_task_id
condition|)
block|{
name|res
operator|=
name|THREAD_FETCH_REGISTERS
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
operator|)
name|supply_gregset
argument_list|(
operator|&
name|gregset_saved
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset_saved
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|task_command
parameter_list|(
name|char
modifier|*
name|tidstr
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|num
decl_stmt|;
name|struct
name|task_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|tidstr
condition|)
name|error
argument_list|(
literal|"Please specify a task ID.  Use the \"info tasks\" command to\n"
literal|"see the IDs of currently known tasks."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|tidstr
argument_list|)
expr_stmt|;
name|e
operator|=
name|get_entry_vptr
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Task ID %d not known.  Use the \"info tasks\" command to\n"
literal|"see the IDs of currently known tasks."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_task_id
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
operator|)
name|fill_gregset
argument_list|(
operator|&
name|gregset_saved
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregset_saved
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_task_id
operator|=
name|get_current_task
argument_list|()
expr_stmt|;
block|}
name|current_task
operator|=
name|num
expr_stmt|;
name|current_task_index
operator|=
name|e
operator|->
name|known_tasks_index
expr_stmt|;
name|current_thread
operator|=
name|e
operator|->
name|thread
expr_stmt|;
name|current_lwp
operator|=
name|e
operator|->
name|lwp
expr_stmt|;
if|if
condition|(
name|task_switch
argument_list|(
name|e
operator|->
name|thread
argument_list|,
name|e
operator|->
name|lwp
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: find_printable_frame should be defined in frame.h, and          implemented in ada-lang.c */
comment|/*      find_printable_frame (deprecated_selected_frame, frame_relative_level (deprecated_selected_frame)); */
name|printf_filtered
argument_list|(
literal|"[Switching to task %d]\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"Unable to switch to task %d\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_tasks
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|task_cmd_list
init|=
name|NULL
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
name|add_info
argument_list|(
literal|"tasks"
argument_list|,
name|info_tasks_command
argument_list|,
literal|"Without argument: list all known Ada tasks, with status information.\n"
literal|"info tasks n: print detailed information of task n.\n"
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"task"
argument_list|,
name|class_run
argument_list|,
name|task_command
argument_list|,
literal|"Use this command to switch between tasks.\n\  The new task ID must be currently known."
argument_list|,
operator|&
name|task_cmd_list
argument_list|,
literal|"task "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

