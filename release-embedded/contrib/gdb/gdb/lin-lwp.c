begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Multi-threaded debugging support for GNU/Linux (LWP layer).    Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TKILL_SYSCALL
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|debug_lin_lwp
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strsignal
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"linux-nat.h"
end_include

begin_comment
comment|/* On GNU/Linux there are no real LWP's.  The closest thing to LWP's    are processes sharing the same VM space.  A multi-threaded process    is basically a group of such processes.  However, such a grouping    is almost entirely a user-space issue; the kernel doesn't enforce    such a grouping at all (this might change in the future).  In    general, we'll rely on the threads library (i.e. the GNU/Linux    Threads library) to provide such a grouping.     It is perfectly well possible to write a multi-threaded application    without the assistance of a threads library, by using the clone    system call directly.  This module should be able to give some    rudimentary support for debugging such applications if developers    specify the CLONE_PTRACE flag in the clone system call, and are    using the Linux kernel 2.4 or above.     Note that there are some peculiarities in GNU/Linux that affect    this code:     - In general one should specify the __WCLONE flag to waitpid in      order to make it report events for any of the cloned processes      (and leave it out for the initial process).  However, if a cloned      process has exited the exit status is only reported if the      __WCLONE flag is absent.  Linux kernel 2.4 has a __WALL flag, but      we cannot use it since GDB must work on older systems too.     - When a traced, cloned process exits and is waited for by the      debugger, the kernel reassigns it to the original parent and      keeps it around as a "zombie".  Somehow, the GNU/Linux Threads      library doesn't notice this, which leads to the "zombie problem":      When debugged a multi-threaded process that spawns a lot of      threads will run out of processes, even if the threads exit,      because the "zombies" stay around.  */
end_comment

begin_comment
comment|/* List of known LWPs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lwp_info
modifier|*
name|lwp_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of LWPs in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_lwps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we're running in "threaded" mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|threaded
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|GET_LWP
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_lwp (ptid)
end_define

begin_define
define|#
directive|define
name|GET_PID
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_pid (ptid)
end_define

begin_define
define|#
directive|define
name|is_lwp
parameter_list|(
name|ptid
parameter_list|)
value|(GET_LWP (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|BUILD_LWP
parameter_list|(
name|lwp
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, lwp, 0)
end_define

begin_comment
comment|/* If the last reported event was a SIGTRAP, this variable is set to    the process id of the LWP/thread that got it.  */
end_comment

begin_decl_stmt
name|ptid_t
name|trap_ptid
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This module's target-specific operations.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|lin_lwp_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The standard child operations.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Since we cannot wait (in lin_lwp_wait) for the initial process and    any cloned processes with a single call to waitpid, we have to use    the WNOHANG flag and call waitpid in a loop.  To optimize    things a bit we use `sigsuspend' to wake us up when a process has    something to report (it will send us a SIGCHLD if it has).  To make    this work we have to juggle with the signal mask.  We save the    original signal mask such that we can restore it before creating a    new process in order to avoid blocking certain signals in the    inferior.  We then block SIGCHLD during the waitpid/sigsuspend    loop.  */
end_comment

begin_comment
comment|/* Original signal mask.  */
end_comment

begin_decl_stmt
specifier|static
name|sigset_t
name|normal_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal mask for use with sigsuspend in lin_lwp_wait, initialized in    _initialize_lin_lwp.  */
end_comment

begin_decl_stmt
specifier|static
name|sigset_t
name|suspend_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signals to block to make that sigsuspend work.  */
end_comment

begin_decl_stmt
specifier|static
name|sigset_t
name|blocked_mask
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|stop_wait_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lin_lwp_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Convert wait status STATUS to a string.  Used for printing debug    messages only.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|status_to_str
parameter_list|(
name|int
name|status
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s (stopped)"
argument_list|,
name|strsignal
argument_list|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s (terminated)"
argument_list|,
name|strsignal
argument_list|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d (exited)"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the list of LWPs.  Note that this module, contrary to    what GDB's generic threads layer does for its thread list,    re-initializes the LWP lists whenever we mourn or detach (which    doesn't involve mourning) the inferior.  */
end_comment

begin_function
specifier|static
name|void
name|init_lwp_list
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lpnext
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|lwp_list
init|;
name|lp
condition|;
name|lp
operator|=
name|lpnext
control|)
block|{
name|lpnext
operator|=
name|lp
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
name|lwp_list
operator|=
name|NULL
expr_stmt|;
name|num_lwps
operator|=
literal|0
expr_stmt|;
name|threaded
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the LWP specified by PID to the list.  If this causes the    number of LWPs to become larger than one, go into "threaded" mode.    Return a pointer to the structure describing the new LWP.  */
end_comment

begin_function
specifier|static
name|struct
name|lwp_info
modifier|*
name|add_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|;
name|gdb_assert
argument_list|(
name|is_lwp
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|(
expr|struct
name|lwp_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lwp_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lwp_info
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|ptid
operator|=
name|ptid
expr_stmt|;
name|lp
operator|->
name|next
operator|=
name|lwp_list
expr_stmt|;
name|lwp_list
operator|=
name|lp
expr_stmt|;
if|if
condition|(
operator|++
name|num_lwps
operator|>
literal|1
condition|)
name|threaded
operator|=
literal|1
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/* Remove the LWP specified by PID from the list.  */
end_comment

begin_function
specifier|static
name|void
name|delete_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lpprev
decl_stmt|;
name|lpprev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|lwp_list
init|;
name|lp
condition|;
name|lpprev
operator|=
name|lp
operator|,
name|lp
operator|=
name|lp
operator|->
name|next
control|)
if|if
condition|(
name|ptid_equal
argument_list|(
name|lp
operator|->
name|ptid
argument_list|,
name|ptid
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|lp
condition|)
return|return;
comment|/* We don't go back to "non-threaded" mode if the number of threads      becomes less than two.  */
name|num_lwps
operator|--
expr_stmt|;
if|if
condition|(
name|lpprev
condition|)
name|lpprev
operator|->
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
else|else
name|lwp_list
operator|=
name|lp
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the structure describing the LWP corresponding    to PID.  If no corresponding LWP could be found, return NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|lwp_info
modifier|*
name|find_lwp_pid
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|;
name|int
name|lwp
decl_stmt|;
if|if
condition|(
name|is_lwp
argument_list|(
name|ptid
argument_list|)
condition|)
name|lwp
operator|=
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
else|else
name|lwp
operator|=
name|GET_PID
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|lwp_list
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
if|if
condition|(
name|lwp
operator|==
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
return|return
name|lp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Call CALLBACK with its second argument set to DATA for every LWP in    the list.  If CALLBACK returns 1 for a particular LWP, return a    pointer to the structure describing that LWP immediately.    Otherwise return NULL.  */
end_comment

begin_function
name|struct
name|lwp_info
modifier|*
name|iterate_over_lwps
parameter_list|(
name|int
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|lwp_info
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lpnext
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|lwp_list
init|;
name|lp
condition|;
name|lp
operator|=
name|lpnext
control|)
block|{
name|lpnext
operator|=
name|lp
operator|->
name|next
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|callback
call|)
argument_list|(
name|lp
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|lp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void lin_lwp_open (char *args, int from_tty) {   push_target (&lin_lwp_ops); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Attach to the LWP specified by PID.  If VERBOSE is non-zero, print    a message telling the user that a new LWP has been added to the    process.  */
end_comment

begin_function
name|void
name|lin_lwp_attach_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|;
name|gdb_assert
argument_list|(
name|is_lwp
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure SIGCHLD is blocked.  We don't want SIGCHLD events      to interrupt either the ptrace() or waitpid() calls below.  */
if|if
condition|(
operator|!
name|sigismember
argument_list|(
operator|&
name|blocked_mask
argument_list|,
name|SIGCHLD
argument_list|)
condition|)
block|{
name|sigaddset
argument_list|(
operator|&
name|blocked_mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|blocked_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf_filtered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|=
name|find_lwp_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
name|lp
operator|=
name|add_lwp
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
comment|/* We assume that we're already attached to any LWP that has an      id equal to the overall process id.  */
if|if
condition|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
operator|!=
name|GET_PID
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_ATTACH
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't attach %s: %s"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
block|{
comment|/* Try again with __WCLONE to check cloned processes.  */
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
name|__WCLONE
argument_list|)
expr_stmt|;
name|lp
operator|->
name|cloned
operator|=
literal|1
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|pid
operator|==
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
operator|&&
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|child_post_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLAL: waitpid %s received %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|status_to_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We assume that the LWP representing the original process          is already stopped.  Mark it as stopped in the data structure          that the lin-lwp layer uses to keep track of threads.  Note          that this won't have already been done since the main thread          will have, we assume, been stopped by an attach from a          different layer.  */
name|lp
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lin_lwp_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* FIXME: We should probably accept a list of process id's, and      attach all of them.  */
name|child_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Add the initial process as the first LWP to the list.  */
name|lp
operator|=
name|add_lwp
argument_list|(
name|BUILD_LWP
argument_list|(
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the initial process is stopped.  The user-level threads      layer might want to poke around in the inferior, and that won't      work if things haven't stabilized yet.  */
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
block|{
name|warning
argument_list|(
literal|"%s is a cloned process"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try again with __WCLONE to check cloned processes.  */
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
name|__WCLONE
argument_list|)
expr_stmt|;
name|lp
operator|->
name|cloned
operator|=
literal|1
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|pid
operator|==
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
operator|&&
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGSTOP
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
comment|/* Fake the SIGSTOP that core GDB expects.  */
name|lp
operator|->
name|status
operator|=
name|W_STOPCODE
argument_list|(
name|SIGSTOP
argument_list|)
expr_stmt|;
name|lp
operator|->
name|resumed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLA: waitpid %ld, faking SIGSTOP\n"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|detach_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|lp
operator|->
name|status
operator|==
literal|0
operator|||
name|WIFSTOPPED
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
operator|&&
name|lp
operator|->
name|status
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"DC:  Pending %s for %s on detach.\n"
argument_list|,
name|strsignal
argument_list|(
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|lp
operator|->
name|signalled
operator|&&
name|lp
operator|->
name|stopped
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_CONT
argument_list|,
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't continue %s: %s"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"DC:  PTRACE_CONTINUE (%s, 0, %s) (OK)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|status_to_str
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|signalled
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* FIXME drow/2003-08-26: There was a call to stop_wait_callback 	 here.  But since lp->signalled was cleared above, 	 stop_wait_callback didn't do anything; the process was left 	 running.  Shouldn't we be waiting for it to stop? 	 I've removed the call, since stop_wait_callback now does do 	 something when called with lp->signalled == 0.  */
name|gdb_assert
argument_list|(
name|lp
operator|->
name|status
operator|==
literal|0
operator|||
name|WIFSTOPPED
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We don't actually detach from the LWP that has an id equal to the      overall process id just yet.  */
if|if
condition|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
operator|!=
name|GET_PID
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_DETACH
argument_list|,
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't detach %s: %s"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"PTRACE_DETACH (%s, %s, 0) (OK)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|strsignal
argument_list|(
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delete_lwp
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lin_lwp_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|iterate_over_lwps
argument_list|(
name|detach_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Only the initial process should be left right now.  */
name|gdb_assert
argument_list|(
name|num_lwps
operator|==
literal|1
argument_list|)
expr_stmt|;
name|trap_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* Destroy LWP info; it's no longer valid.  */
name|init_lwp_list
argument_list|()
expr_stmt|;
comment|/* Restore the original signal mask.  */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|normal_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|blocked_mask
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|child_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Resume LP.  */
end_comment

begin_function
specifier|static
name|int
name|resume_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|stopped
operator|&&
name|lp
operator|->
name|status
operator|==
literal|0
condition|)
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
name|child_resume
argument_list|(
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"RC:  PTRACE_CONT %s, 0, 0 (resume sibling)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|step
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume_clear_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|lp
operator|->
name|resumed
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume_set_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|lp
operator|->
name|resumed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lin_lwp_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
decl_stmt|;
name|int
name|resume_all
decl_stmt|;
comment|/* A specific PTID means `step only this process id'.  */
name|resume_all
operator|=
operator|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|resume_all
condition|)
name|iterate_over_lwps
argument_list|(
name|resume_set_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|iterate_over_lwps
argument_list|(
name|resume_clear_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If PID is -1, it's the current inferior that should be      handled specially.  */
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|lp
operator|=
name|find_lwp_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
name|ptid
operator|=
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember if we're stepping.  */
name|lp
operator|->
name|step
operator|=
name|step
expr_stmt|;
comment|/* Mark this LWP as resumed.  */
name|lp
operator|->
name|resumed
operator|=
literal|1
expr_stmt|;
comment|/* If we have a pending wait status for this thread, there is no          point in resuming the process.  */
if|if
condition|(
name|lp
operator|->
name|status
condition|)
block|{
comment|/* FIXME: What should we do if we are supposed to continue 	     this thread with a signal?  */
name|gdb_assert
argument_list|(
name|signo
operator|==
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Mark LWP as not stopped to prevent it from being continued by          resume_callback.  */
name|lp
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|resume_all
condition|)
name|iterate_over_lwps
argument_list|(
name|resume_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|child_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLR: %s %s, %s (resume event thread)\n"
argument_list|,
name|step
condition|?
literal|"PTRACE_SINGLESTEP"
else|:
literal|"PTRACE_CONT"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|signo
condition|?
name|strsignal
argument_list|(
name|signo
argument_list|)
else|:
literal|"0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Issue kill to specified lwp.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tkill_failed
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|kill_lwp
parameter_list|(
name|int
name|lwpid
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Use tkill, if possible, in case we are using nptl threads.  If tkill    fails, then we are not using nptl threads and we should be using kill.  */
ifdef|#
directive|ifdef
name|HAVE_TKILL_SYSCALL
if|if
condition|(
operator|!
name|tkill_failed
condition|)
block|{
name|int
name|ret
init|=
name|syscall
argument_list|(
name|__NR_tkill
argument_list|,
name|lwpid
argument_list|,
name|signo
argument_list|)
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOSYS
condition|)
return|return
name|ret
return|;
name|errno
operator|=
literal|0
expr_stmt|;
name|tkill_failed
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|kill
argument_list|(
name|lwpid
argument_list|,
name|signo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for LP to stop.  Returns the wait status, or 0 if the LWP has    exited.  */
end_comment

begin_function
specifier|static
name|int
name|wait_lwp
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|thread_dead
init|=
literal|0
decl_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|lp
operator|->
name|stopped
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|lp
operator|->
name|status
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
block|{
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
name|__WCLONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
block|{
comment|/* The thread has previously exited.  We need to delete it now 	     because in the case of NPTL threads, there won't be an 	     exit event unless it is the main thread.  */
name|thread_dead
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"WL: %s vanished.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|thread_dead
condition|)
block|{
name|gdb_assert
argument_list|(
name|pid
operator|==
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"WL: waitpid %s received %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|status_to_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if the thread has exited.  */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|thread_dead
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"WL: %s exited.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thread_dead
condition|)
block|{
if|if
condition|(
name|in_thread_list
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
block|{
comment|/* Core GDB cannot deal with us deleting the current thread.  */
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|lp
operator|->
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
name|delete_thread
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[%s exited]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|delete_lwp
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|gdb_assert
argument_list|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Send a SIGSTOP to LP.  */
end_comment

begin_function
specifier|static
name|int
name|stop_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lp
operator|->
name|stopped
operator|&&
operator|!
name|lp
operator|->
name|signalled
condition|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SC:  kill %s **<SIGSTOP>**\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|kill_lwp
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SC:  lwp kill %d %s\n"
argument_list|,
name|ret
argument_list|,
name|errno
condition|?
name|safe_strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"ERRNO-OK"
argument_list|)
expr_stmt|;
block|}
name|lp
operator|->
name|signalled
operator|=
literal|1
expr_stmt|;
name|gdb_assert
argument_list|(
name|lp
operator|->
name|status
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait until LP is stopped.  If DATA is non-null it is interpreted as    a pointer to a set of signals to be flushed immediately.  */
end_comment

begin_function
specifier|static
name|int
name|stop_wait_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|sigset_t
modifier|*
name|flush_mask
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|stopped
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|wait_lwp
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ignore any signals in FLUSH_MASK.  */
if|if
condition|(
name|flush_mask
operator|&&
name|sigismember
argument_list|(
name|flush_mask
argument_list|,
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|lp
operator|->
name|signalled
condition|)
block|{
name|lp
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_CONT
argument_list|,
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"PTRACE_CONT %s, 0, 0 (%s)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|errno
condition|?
name|safe_strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"OK"
argument_list|)
expr_stmt|;
return|return
name|stop_wait_callback
argument_list|(
name|lp
argument_list|,
name|flush_mask
argument_list|)
return|;
block|}
if|if
condition|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|!=
name|SIGSTOP
condition|)
block|{
if|if
condition|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGTRAP
condition|)
block|{
comment|/* If a LWP other than the LWP that we're reporting an 	         event for has hit a GDB breakpoint (as opposed to 	         some random trap signal), then just arrange for it to 	         hit it again later.  We don't keep the SIGTRAP status 	         and don't forward the SIGTRAP signal to the LWP.  We 	         will handle the current event, eventually we will 	         resume all LWPs, and this one will get its breakpoint 	         trap again.  	         If we do not do this, then we run the risk that the 	         user will delete or disable the breakpoint, but the 	         thread will have already tripped on it.  */
comment|/* Now resume this LWP and get the SIGSTOP event. */
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_CONT
argument_list|,
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"PTRACE_CONT %s, 0, 0 (%s)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|errno
condition|?
name|safe_strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"OK"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SWC: Candidate SIGTRAP event in %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Hold the SIGTRAP for handling by lin_lwp_wait. */
name|stop_wait_callback
argument_list|(
name|lp
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If there's another event, throw it back into the queue. */
if|if
condition|(
name|lp
operator|->
name|status
condition|)
block|{
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SWC: kill %s, %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|status_to_str
argument_list|(
operator|(
name|int
operator|)
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kill_lwp
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save the sigtrap event. */
name|lp
operator|->
name|status
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* The thread was stopped with a signal other than 	         SIGSTOP, and didn't accidentally trip a breakpoint. */
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SWC: Pending event %s in %s\n"
argument_list|,
name|status_to_str
argument_list|(
operator|(
name|int
operator|)
name|status
argument_list|)
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now resume this LWP and get the SIGSTOP event. */
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_CONT
argument_list|,
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SWC: PTRACE_CONT %s, 0, 0 (%s)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|errno
condition|?
name|safe_strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"OK"
argument_list|)
expr_stmt|;
comment|/* Hold this event/waitstatus while we check to see if 	         there are any more (we still want to get that SIGSTOP). */
name|stop_wait_callback
argument_list|(
name|lp
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If the lp->status field is still empty, use it to hold 	         this event.  If not, then this event must be returned 	         to the event queue of the LWP.  */
if|if
condition|(
name|lp
operator|->
name|status
operator|==
literal|0
condition|)
name|lp
operator|->
name|status
operator|=
name|status
expr_stmt|;
else|else
block|{
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SWC: kill %s, %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|status_to_str
argument_list|(
operator|(
name|int
operator|)
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kill_lwp
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* We caught the SIGSTOP that we intended to catch, so 	     there's no SIGSTOP pending.  */
name|lp
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|signalled
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether PID has any pending signals in FLUSH_MASK.  If so set    the appropriate bits in PENDING, and return 1 - otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|lin_lwp_has_pending
parameter_list|(
name|int
name|pid
parameter_list|,
name|sigset_t
modifier|*
name|pending
parameter_list|,
name|sigset_t
modifier|*
name|flush_mask
parameter_list|)
block|{
name|sigset_t
name|blocked
decl_stmt|,
name|ignored
decl_stmt|;
name|int
name|i
decl_stmt|;
name|linux_proc_pending_signals
argument_list|(
name|pid
argument_list|,
name|pending
argument_list|,
operator|&
name|blocked
argument_list|,
operator|&
name|ignored
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flush_mask
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sigismember
argument_list|(
name|pending
argument_list|,
name|i
argument_list|)
condition|)
if|if
condition|(
operator|!
name|sigismember
argument_list|(
name|flush_mask
argument_list|,
name|i
argument_list|)
operator|||
name|sigismember
argument_list|(
operator|&
name|blocked
argument_list|,
name|i
argument_list|)
operator|||
name|sigismember
argument_list|(
operator|&
name|ignored
argument_list|,
name|i
argument_list|)
condition|)
name|sigdelset
argument_list|(
name|pending
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigisemptyset
argument_list|(
name|pending
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* DATA is interpreted as a mask of signals to flush.  If LP has    signals pending, and they are all in the flush mask, then arrange    to flush them.  LP should be stopped, as should all other threads    it might share a signal queue with.  */
end_comment

begin_function
specifier|static
name|int
name|flush_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|sigset_t
modifier|*
name|flush_mask
init|=
name|data
decl_stmt|;
name|sigset_t
name|pending
decl_stmt|,
name|intersection
decl_stmt|,
name|blocked
decl_stmt|,
name|ignored
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
comment|/* Normally, when an LWP exits, it is removed from the LWP list.  The      last LWP isn't removed till later, however.  So if there is only      one LWP on the list, make sure it's alive.  */
if|if
condition|(
name|lwp_list
operator|==
name|lp
operator|&&
name|lp
operator|->
name|next
operator|==
name|NULL
condition|)
if|if
condition|(
operator|!
name|lin_lwp_thread_alive
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Just because the LWP is stopped doesn't mean that new signals      can't arrive from outside, so this function must be careful of      race conditions.  However, because all threads are stopped, we      can assume that the pending mask will not shrink unless we resume      the LWP, and that it will then get another signal.  We can't      control which one, however.  */
if|if
condition|(
name|lp
operator|->
name|status
condition|)
block|{
if|if
condition|(
name|debug_lin_lwp
condition|)
name|printf_unfiltered
argument_list|(
literal|"FC: LP has pending status %06x\n"
argument_list|,
name|lp
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|lp
operator|->
name|status
argument_list|)
operator|&&
name|sigismember
argument_list|(
name|flush_mask
argument_list|,
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
argument_list|)
condition|)
name|lp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|lin_lwp_has_pending
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
operator|&
name|pending
argument_list|,
name|flush_mask
argument_list|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_CONT
argument_list|,
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"FC: Sent PTRACE_CONT, ret %d %d\n"
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|stop_wait_callback
argument_list|(
name|lp
argument_list|,
name|flush_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"FC: Wait finished; saved status is %d\n"
argument_list|,
name|lp
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if LP has a wait status pending.  */
end_comment

begin_function
specifier|static
name|int
name|status_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* Only report a pending wait status if we pretend that this has      indeed been resumed.  */
return|return
operator|(
name|lp
operator|->
name|status
operator|!=
literal|0
operator|&&
name|lp
operator|->
name|resumed
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if LP isn't stopped.  */
end_comment

begin_function
specifier|static
name|int
name|running_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|lp
operator|->
name|stopped
operator|==
literal|0
operator|||
operator|(
name|lp
operator|->
name|status
operator|!=
literal|0
operator|&&
name|lp
operator|->
name|resumed
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Count the LWP's that have had events.  */
end_comment

begin_function
specifier|static
name|int
name|count_events_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|count
init|=
name|data
decl_stmt|;
name|gdb_assert
argument_list|(
name|count
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Count only LWPs that have a SIGTRAP event pending.  */
if|if
condition|(
name|lp
operator|->
name|status
operator|!=
literal|0
operator|&&
name|WIFSTOPPED
argument_list|(
name|lp
operator|->
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
operator|==
name|SIGTRAP
condition|)
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Select the LWP (if any) that is currently being single-stepped.  */
end_comment

begin_function
specifier|static
name|int
name|select_singlestep_lwp_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|step
operator|&&
name|lp
operator|->
name|status
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Select the Nth LWP that has had a SIGTRAP event.  */
end_comment

begin_function
specifier|static
name|int
name|select_event_lwp_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|selector
init|=
name|data
decl_stmt|;
name|gdb_assert
argument_list|(
name|selector
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Select only LWPs that have a SIGTRAP event pending. */
if|if
condition|(
name|lp
operator|->
name|status
operator|!=
literal|0
operator|&&
name|WIFSTOPPED
argument_list|(
name|lp
operator|->
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
operator|==
name|SIGTRAP
condition|)
if|if
condition|(
operator|(
operator|*
name|selector
operator|)
operator|--
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cancel_breakpoints_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|event_lp
init|=
name|data
decl_stmt|;
comment|/* Leave the LWP that has been elected to receive a SIGTRAP alone.  */
if|if
condition|(
name|lp
operator|==
name|event_lp
condition|)
return|return
literal|0
return|;
comment|/* If a LWP other than the LWP that we're reporting an event for has      hit a GDB breakpoint (as opposed to some random trap signal),      then just arrange for it to hit it again later.  We don't keep      the SIGTRAP status and don't forward the SIGTRAP signal to the      LWP.  We will handle the current event, eventually we will resume      all LWPs, and this one will get its breakpoint trap again.       If we do not do this, then we run the risk that the user will      delete or disable the breakpoint, but the LWP will have already      tripped on it.  */
if|if
condition|(
name|lp
operator|->
name|status
operator|!=
literal|0
operator|&&
name|WIFSTOPPED
argument_list|(
name|lp
operator|->
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|lp
operator|->
name|status
argument_list|)
operator|==
name|SIGTRAP
operator|&&
name|breakpoint_inserted_here_p
argument_list|(
name|read_pc_pid
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"CBC: Push back breakpoint for %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Back up the PC if necessary.  */
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
name|write_pc_pid
argument_list|(
name|read_pc_pid
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|,
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
comment|/* Throw away the SIGTRAP.  */
name|lp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Select one LWP out of those that have events pending.  */
end_comment

begin_function
specifier|static
name|void
name|select_event_lwp
parameter_list|(
name|struct
name|lwp_info
modifier|*
modifier|*
name|orig_lp
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|int
name|num_events
init|=
literal|0
decl_stmt|;
name|int
name|random_selector
decl_stmt|;
name|struct
name|lwp_info
modifier|*
name|event_lp
decl_stmt|;
comment|/* Record the wait status for the origional LWP.  */
operator|(
operator|*
name|orig_lp
operator|)
operator|->
name|status
operator|=
operator|*
name|status
expr_stmt|;
comment|/* Give preference to any LWP that is being single-stepped.  */
name|event_lp
operator|=
name|iterate_over_lwps
argument_list|(
name|select_singlestep_lwp_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_lp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SEL: Select single-step %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|event_lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No single-stepping LWP.  Select one at random, out of those          which have had SIGTRAP events.  */
comment|/* First see how many SIGTRAP events we have.  */
name|iterate_over_lwps
argument_list|(
name|count_events_callback
argument_list|,
operator|&
name|num_events
argument_list|)
expr_stmt|;
comment|/* Now randomly pick a LWP out of those that have had a SIGTRAP.  */
name|random_selector
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|num_events
operator|*
operator|(
name|double
operator|)
name|rand
argument_list|()
operator|)
operator|/
operator|(
name|RAND_MAX
operator|+
literal|1.0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
operator|&&
name|num_events
operator|>
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"SEL: Found %d SIGTRAP events, selecting #%d\n"
argument_list|,
name|num_events
argument_list|,
name|random_selector
argument_list|)
expr_stmt|;
name|event_lp
operator|=
name|iterate_over_lwps
argument_list|(
name|select_event_lwp_callback
argument_list|,
operator|&
name|random_selector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event_lp
operator|!=
name|NULL
condition|)
block|{
comment|/* Switch the event LWP.  */
operator|*
name|orig_lp
operator|=
name|event_lp
expr_stmt|;
operator|*
name|status
operator|=
name|event_lp
operator|->
name|status
expr_stmt|;
block|}
comment|/* Flush the wait status for the event LWP.  */
operator|(
operator|*
name|orig_lp
operator|)
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if LP has been resumed.  */
end_comment

begin_function
specifier|static
name|int
name|resumed_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|lp
operator|->
name|resumed
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CHILD_WAIT
end_ifdef

begin_comment
comment|/* We need to override child_wait to support attaching to cloned    processes, since a normal wait (as done by the default version)    ignores those processes.  */
end_comment

begin_comment
comment|/* Wait for child PTID to do something.  Return id of the child,    minus_one_ptid in case of error; store status into *OURSTATUS.  */
end_comment

begin_function
name|ptid_t
name|child_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|int
name|save_errno
decl_stmt|;
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
do|do
block|{
name|set_sigint_trap
argument_list|()
expr_stmt|;
comment|/* Causes SIGINT to be passed on to the 				   attached process.  */
name|set_sigio_trap
argument_list|()
expr_stmt|;
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
comment|/* Try again with __WCLONE to check cloned processes.  */
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|status
argument_list|,
name|__WCLONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"CW:  waitpid %ld received %s\n"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|,
name|status_to_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* Make sure we don't report an event for the exit of the          original program, if we've detached from it.  */
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|pid
operator|!=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|save_errno
operator|=
name|EINTR
expr_stmt|;
block|}
comment|/* Check for stop events reported by a process we didn't already 	 know about - in this case, anything other than inferior_ptid.  	 If we're expecting to receive stopped processes after fork, 	 vfork, and clone events, then we'll just add the new one to 	 our list and go back to waiting for the event to be reported 	 - the stopped process might be returned from waitpid before 	 or after the event is.  If we want to handle debugging of 	 CLONE_PTRACE processes we need to do more here, i.e. switch 	 to multi-threaded mode.  */
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
operator|&&
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGSTOP
operator|&&
name|pid
operator|!=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|linux_record_stopped_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|save_errno
operator|=
name|EINTR
expr_stmt|;
block|}
name|clear_sigio_trap
argument_list|()
expr_stmt|;
name|clear_sigint_trap
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|save_errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Child process unexpectedly missing: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Claim it exited with unknown signal.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
return|return
name|minus_one_ptid
return|;
block|}
comment|/* Handle GNU/Linux's extended waitstatus for trace events.  */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGTRAP
operator|&&
name|status
operator|>>
literal|16
operator|!=
literal|0
condition|)
return|return
name|linux_handle_extended_wait
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
name|ourstatus
argument_list|)
return|;
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stop an active thread, verify it still exists, then resume it.  */
end_comment

begin_function
specifier|static
name|int
name|stop_and_resume_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|stopped
operator|&&
operator|!
name|lp
operator|->
name|signalled
condition|)
block|{
name|stop_callback
argument_list|(
name|lp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stop_wait_callback
argument_list|(
name|lp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Resume if the lwp still exists.  */
for|for
control|(
name|ptr
operator|=
name|lwp_list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|lp
operator|==
name|ptr
condition|)
block|{
name|resume_callback
argument_list|(
name|lp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|resume_set_callback
argument_list|(
name|lp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|lin_lwp_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|struct
name|lwp_info
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|int
name|options
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|pid_t
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|sigset_t
name|flush_mask
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|flush_mask
argument_list|)
expr_stmt|;
comment|/* Make sure SIGCHLD is blocked.  */
if|if
condition|(
operator|!
name|sigismember
argument_list|(
operator|&
name|blocked_mask
argument_list|,
name|SIGCHLD
argument_list|)
condition|)
block|{
name|sigaddset
argument_list|(
operator|&
name|blocked_mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|blocked_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|retry
label|:
comment|/* Make sure there is at least one LWP that has been resumed, at      least if there are any LWPs at all.  */
name|gdb_assert
argument_list|(
name|num_lwps
operator|==
literal|0
operator|||
name|iterate_over_lwps
argument_list|(
name|resumed_callback
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First check if there is a LWP with a wait status pending.  */
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Any LWP that's been resumed will do.  */
name|lp
operator|=
name|iterate_over_lwps
argument_list|(
name|status_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
name|status
operator|=
name|lp
operator|->
name|status
expr_stmt|;
name|lp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
operator|&&
name|status
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: Using pending wait status %s for %s.\n"
argument_list|,
name|status_to_str
argument_list|(
name|status
argument_list|)
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* But if we don't fine one, we'll have to wait, and check both          cloned and uncloned processes.  We start with the cloned          processes.  */
name|options
operator|=
name|__WCLONE
operator||
name|WNOHANG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_lwp
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: Waiting for specific LWP %s.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have a specific LWP to check.  */
name|lp
operator|=
name|find_lwp_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|status
operator|=
name|lp
operator|->
name|status
expr_stmt|;
name|lp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
operator|&&
name|status
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: Using pending wait status %s for %s.\n"
argument_list|,
name|status_to_str
argument_list|(
name|status
argument_list|)
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have to wait, take into account whether PID is a cloned          process or not.  And we have to convert it to something that          the layer beneath us can understand.  */
name|options
operator|=
name|lp
operator|->
name|cloned
condition|?
name|__WCLONE
else|:
literal|0
expr_stmt|;
name|pid
operator|=
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&&
name|lp
operator|->
name|signalled
condition|)
block|{
comment|/* A pending SIGSTOP may interfere with the normal stream of          events.  In a typical case where interference is a problem,          we have a SIGSTOP signal pending for LWP A while          single-stepping it, encounter an event in LWP B, and take the          pending SIGSTOP while trying to stop LWP A.  After processing          the event in LWP B, LWP A is continued, and we'll never see          the SIGTRAP associated with the last time we were          single-stepping LWP A.  */
comment|/* Resume the thread.  It should halt immediately returning the          pending SIGSTOP.  */
name|registers_changed
argument_list|()
expr_stmt|;
name|child_resume
argument_list|(
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
argument_list|,
name|lp
operator|->
name|step
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: %s %s, 0, 0 (expect SIGSTOP)\n"
argument_list|,
name|lp
operator|->
name|step
condition|?
literal|"PTRACE_SINGLESTEP"
else|:
literal|"PTRACE_CONT"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|gdb_assert
argument_list|(
name|lp
operator|->
name|resumed
argument_list|)
expr_stmt|;
comment|/* This should catch the pending SIGSTOP.  */
name|stop_wait_callback
argument_list|(
name|lp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|set_sigint_trap
argument_list|()
expr_stmt|;
comment|/* Causes SIGINT to be passed on to the 				   attached process. */
name|set_sigio_trap
argument_list|()
expr_stmt|;
while|while
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|pid_t
name|lwpid
decl_stmt|;
name|lwpid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwpid
operator|>
literal|0
condition|)
block|{
name|gdb_assert
argument_list|(
name|pid
operator|==
operator|-
literal|1
operator|||
name|lwpid
operator|==
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: waitpid %ld received %s\n"
argument_list|,
operator|(
name|long
operator|)
name|lwpid
argument_list|,
name|status_to_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|find_lwp_pid
argument_list|(
name|pid_to_ptid
argument_list|(
name|lwpid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for stop events reported by a process we didn't 	     already know about - anything not already in our LWP 	     list.  	     If we're expecting to receive stopped processes after 	     fork, vfork, and clone events, then we'll just add the 	     new one to our list and go back to waiting for the event 	     to be reported - the stopped process might be returned 	     from waitpid before or after the event is.  */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|lp
condition|)
block|{
name|linux_record_stopped_pid
argument_list|(
name|lwpid
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure we don't report an event for the exit of an LWP not in 	     our list, i.e.  not part of the current process.  This can happen 	     if we detach from a program we original forked and then it 	     exits.  */
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|lp
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* NOTE drow/2003-06-17: This code seems to be meant for debugging 	     CLONE_PTRACE processes which do not use the thread library - 	     otherwise we wouldn't find the new LWP this way.  That doesn't 	     currently work, and the following code is currently unreachable 	     due to the two blocks above.  If it's fixed some day, this code 	     should be broken out into a function so that we can also pick up 	     LWPs from the new interface.  */
if|if
condition|(
operator|!
name|lp
condition|)
block|{
name|lp
operator|=
name|add_lwp
argument_list|(
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|__WCLONE
condition|)
name|lp
operator|->
name|cloned
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|threaded
condition|)
block|{
name|gdb_assert
argument_list|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGSTOP
argument_list|)
expr_stmt|;
name|lp
operator|->
name|signalled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
name|add_thread
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if the thread has exited.  */
if|if
condition|(
operator|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|)
operator|&&
name|num_lwps
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|in_thread_list
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
block|{
comment|/* Core GDB cannot deal with us deleting the current 		     thread.  */
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|lp
operator|->
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
name|delete_thread
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[%s exited]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is the main thread, we must stop all threads and 	         verify if they are still alive.  This is because in the nptl 	         thread model, there is no signal issued for exiting LWPs 	         other than the main thread.  We only get the main thread 	         exit signal once all child threads have already exited. 	         If we stop all the threads and use the stop_wait_callback 	         to check if they have exited we can determine whether this 	         signal should be ignored or whether it means the end of the 	         debugged application, regardless of which threading model 	         is being used.  */
if|if
condition|(
name|GET_PID
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
operator|==
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
block|{
name|lp
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
name|iterate_over_lwps
argument_list|(
name|stop_and_resume_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: %s exited.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|delete_lwp
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
comment|/* If there is at least one more LWP, then the exit signal 	         was not the end of the debugged application and should be 	         ignored.  */
if|if
condition|(
name|num_lwps
operator|>
literal|0
condition|)
block|{
comment|/* Make sure there is at least one thread running.  */
name|gdb_assert
argument_list|(
name|iterate_over_lwps
argument_list|(
name|running_callback
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Discard the event.  */
name|status
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Check if the current LWP has previously exited.  In the nptl 	     thread model, LWPs other than the main thread do not issue 	     signals when they exit so we must check whenever the thread 	     has stopped.  A similar check is made in stop_wait_callback().  */
if|if
condition|(
name|num_lwps
operator|>
literal|1
operator|&&
operator|!
name|lin_lwp_thread_alive
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
block|{
if|if
condition|(
name|in_thread_list
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
block|{
comment|/* Core GDB cannot deal with us deleting the current 		     thread.  */
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|lp
operator|->
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
name|delete_thread
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[%s exited]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: %s exited.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|delete_lwp
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
expr_stmt|;
comment|/* Make sure there is at least one thread running.  */
name|gdb_assert
argument_list|(
name|iterate_over_lwps
argument_list|(
name|running_callback
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Discard the event.  */
name|status
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure we don't report a SIGSTOP that we sent 	     ourselves in an attempt to stop an LWP.  */
if|if
condition|(
name|lp
operator|->
name|signalled
operator|&&
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGSTOP
condition|)
block|{
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: Delayed SIGSTOP caught for %s.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is a delayed SIGSTOP.  */
name|lp
operator|->
name|signalled
operator|=
literal|0
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|child_resume
argument_list|(
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
argument_list|,
name|lp
operator|->
name|step
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: %s %s, 0, 0 (discard SIGSTOP)\n"
argument_list|,
name|lp
operator|->
name|step
condition|?
literal|"PTRACE_SINGLESTEP"
else|:
literal|"PTRACE_CONT"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|gdb_assert
argument_list|(
name|lp
operator|->
name|resumed
argument_list|)
expr_stmt|;
comment|/* Discard the event.  */
name|status
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Alternate between checking cloned and uncloned processes.  */
name|options
operator|^=
name|__WCLONE
expr_stmt|;
comment|/* And suspend every time we have checked both.  */
if|if
condition|(
name|options
operator|&
name|__WCLONE
condition|)
name|sigsuspend
argument_list|(
operator|&
name|suspend_mask
argument_list|)
expr_stmt|;
block|}
comment|/* We shouldn't end up here unless we want to try again.  */
name|gdb_assert
argument_list|(
name|status
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|clear_sigio_trap
argument_list|()
expr_stmt|;
name|clear_sigint_trap
argument_list|()
expr_stmt|;
name|gdb_assert
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* Don't report signals that GDB isn't interested in, such as      signals that are neither printed nor stopped upon.  Stopping all      threads can be a bit time-consuming so if we want decent      performance with heavily multi-threaded programs, especially when      they're using a high frequency timer, we'd better avoid it if we      can.  */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|signo
init|=
name|target_signal_from_host
argument_list|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|signal_stop_state
argument_list|(
name|signo
argument_list|)
operator|==
literal|0
operator|&&
name|signal_print_state
argument_list|(
name|signo
argument_list|)
operator|==
literal|0
operator|&&
name|signal_pass_state
argument_list|(
name|signo
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* FIMXE: kettenis/2001-06-06: Should we resume all threads 	     here?  It is not clear we should.  GDB may not expect 	     other threads to run.  On the other hand, not resuming 	     newly attached threads may cause an unwanted delay in 	     getting them running.  */
name|registers_changed
argument_list|()
expr_stmt|;
name|child_resume
argument_list|(
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
argument_list|,
name|lp
operator|->
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: %s %s, %s (preempt 'handle')\n"
argument_list|,
name|lp
operator|->
name|step
condition|?
literal|"PTRACE_SINGLESTEP"
else|:
literal|"PTRACE_CONT"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|signo
condition|?
name|strsignal
argument_list|(
name|signo
argument_list|)
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|signo
operator|==
name|TARGET_SIGNAL_INT
operator|&&
name|signal_pass_state
argument_list|(
name|signo
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If ^C/BREAK is typed at the tty/console, SIGINT gets 	     forwarded to the entire process group, that is, all LWP's 	     will receive it.  Since we only want to report it once, 	     we try to flush it from all LWPs except this one.  */
name|sigaddset
argument_list|(
operator|&
name|flush_mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This LWP is stopped now.  */
name|lp
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: Candidate event %s in %s.\n"
argument_list|,
name|status_to_str
argument_list|(
name|status
argument_list|)
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now stop all other LWP's ...  */
name|iterate_over_lwps
argument_list|(
name|stop_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ... and wait until all of them have reported back that they're no      longer running.  */
name|iterate_over_lwps
argument_list|(
name|stop_wait_callback
argument_list|,
operator|&
name|flush_mask
argument_list|)
expr_stmt|;
name|iterate_over_lwps
argument_list|(
name|flush_callback
argument_list|,
operator|&
name|flush_mask
argument_list|)
expr_stmt|;
comment|/* If we're not waiting for a specific LWP, choose an event LWP from      among those that have had events.  Giving equal priority to all      LWPs that have had events helps prevent starvation.  */
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|select_event_lwp
argument_list|(
operator|&
name|lp
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* Now that we've selected our final event LWP, cancel any      breakpoints in other LWPs that have hit a GDB breakpoint.  See      the comment in cancel_breakpoints_callback to find out why.  */
name|iterate_over_lwps
argument_list|(
name|cancel_breakpoints_callback
argument_list|,
name|lp
argument_list|)
expr_stmt|;
comment|/* If we're not running in "threaded" mode, we'll report the bare      process id.  */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGTRAP
condition|)
block|{
name|trap_ptid
operator|=
operator|(
name|threaded
condition|?
name|lp
operator|->
name|ptid
else|:
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLW: trap_ptid is %s.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|trap_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|trap_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* Handle GNU/Linux's extended waitstatus for trace events.  */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGTRAP
operator|&&
name|status
operator|>>
literal|16
operator|!=
literal|0
condition|)
block|{
name|linux_handle_extended_wait
argument_list|(
name|ptid_get_pid
argument_list|(
name|trap_ptid
argument_list|)
argument_list|,
name|status
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
return|return
name|trap_ptid
return|;
block|}
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|threaded
condition|?
name|lp
operator|->
name|ptid
else|:
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kill_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_KILL
argument_list|,
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"KC:  PTRACE_KILL %s, 0, 0 (%s)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|errno
condition|?
name|safe_strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"OK"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kill_wait_callback
parameter_list|(
name|struct
name|lwp_info
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
comment|/* We must make sure that there are no pending events (delayed      SIGSTOPs, pending SIGTRAPs, etc.) to make sure the current      program doesn't interfere with any following debugging session.  */
comment|/* For cloned processes we must check both with __WCLONE and      without, since the exit status of a cloned process isn't reported      with __WCLONE.  */
if|if
condition|(
name|lp
operator|->
name|cloned
condition|)
block|{
do|do
block|{
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|__WCLONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|(
name|pid_t
operator|)
operator|-
literal|1
operator|&&
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"KWC: wait %s received unknown.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pid
operator|==
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
do|;
name|gdb_assert
argument_list|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|pid
operator|=
name|waitpid
argument_list|(
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|(
name|pid_t
operator|)
operator|-
literal|1
operator|&&
name|debug_lin_lwp
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"KWC: wait %s received unk.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pid
operator|==
name|GET_LWP
argument_list|(
name|lp
operator|->
name|ptid
argument_list|)
condition|)
do|;
name|gdb_assert
argument_list|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lin_lwp_kill
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Kill all LWP's ...  */
name|iterate_over_lwps
argument_list|(
name|kill_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ... and wait until we've flushed all events.  */
name|iterate_over_lwps
argument_list|(
name|kill_wait_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lin_lwp_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|child_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lin_lwp_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|trap_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* Destroy LWP info; it's no longer valid.  */
name|init_lwp_list
argument_list|()
expr_stmt|;
comment|/* Restore the original signal mask.  */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|normal_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|blocked_mask
argument_list|)
expr_stmt|;
name|child_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lin_lwp_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|save_inferior_ptid
argument_list|()
decl_stmt|;
name|int
name|xfer
decl_stmt|;
if|if
condition|(
name|is_lwp
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|GET_LWP
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|linux_proc_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
literal|0
condition|)
name|xfer
operator|=
name|child_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|xfer
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lin_lwp_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|is_lwp
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_PEEKUSER
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_lin_lwp
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"LLTA: PTRACE_PEEKUSER %s, 0, 0 (%s)\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|errno
condition|?
name|safe_strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"OK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|lin_lwp_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|is_lwp
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"LWP %ld"
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|normal_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_lin_lwp_ops
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|lin_lwp_ops.to_open = lin_lwp_open;
endif|#
directive|endif
name|lin_lwp_ops
operator|.
name|to_shortname
operator|=
literal|"lwp-layer"
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_longname
operator|=
literal|"lwp-layer"
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_doc
operator|=
literal|"Low level threads support (LWP layer)"
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_attach
operator|=
name|lin_lwp_attach
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_detach
operator|=
name|lin_lwp_detach
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_resume
operator|=
name|lin_lwp_resume
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_wait
operator|=
name|lin_lwp_wait
expr_stmt|;
comment|/* fetch_inferior_registers and store_inferior_registers will      honor the LWP id, so we can use them directly.  */
name|lin_lwp_ops
operator|.
name|to_fetch_registers
operator|=
name|fetch_inferior_registers
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_store_registers
operator|=
name|store_inferior_registers
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_xfer_memory
operator|=
name|lin_lwp_xfer_memory
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_kill
operator|=
name|lin_lwp_kill
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_create_inferior
operator|=
name|lin_lwp_create_inferior
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_mourn_inferior
operator|=
name|lin_lwp_mourn_inferior
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_thread_alive
operator|=
name|lin_lwp_thread_alive
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_pid_to_str
operator|=
name|lin_lwp_pid_to_str
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_post_startup_inferior
operator|=
name|child_post_startup_inferior
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_post_attach
operator|=
name|child_post_attach
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|child_insert_fork_catchpoint
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|child_insert_vfork_catchpoint
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|child_insert_exec_catchpoint
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_stratum
operator|=
name|thread_stratum
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_schedlock
expr_stmt|;
name|lin_lwp_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* Do nothing.  The only reason for this handler is that it allows      us to use sigsuspend in lin_lwp_wait above to wait for the      arrival of a SIGCHLD.  */
block|}
end_function

begin_function
name|void
name|_initialize_lin_lwp
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|action
decl_stmt|;
specifier|extern
name|void
name|thread_db_init
argument_list|(
expr|struct
name|target_ops
operator|*
argument_list|)
decl_stmt|;
name|init_lin_lwp_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|lin_lwp_ops
argument_list|)
expr_stmt|;
name|thread_db_init
argument_list|(
operator|&
name|lin_lwp_ops
argument_list|)
expr_stmt|;
comment|/* Save the original signal mask.  */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
name|NULL
argument_list|,
operator|&
name|normal_mask
argument_list|)
expr_stmt|;
name|action
operator|.
name|sa_handler
operator|=
name|sigchld_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|action
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|action
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|action
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure we don't block SIGCHLD during a sigsuspend.  */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
name|NULL
argument_list|,
operator|&
name|suspend_mask
argument_list|)
expr_stmt|;
name|sigdelset
argument_list|(
operator|&
name|suspend_mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|blocked_mask
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"lin-lwp"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_lin_lwp
argument_list|,
literal|"Set debugging of GNU/Linux lwp module.\n\ Enables printf debugging output.\n"
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME: kettenis/2000-08-26: The stuff on this page is specific to    the GNU/Linux Threads library and therefore doesn't really belong    here.  */
end_comment

begin_comment
comment|/* Read variable NAME in the target and return its value if found.    Otherwise return zero.  It is assumed that the type of the variable    is `int'.  */
end_comment

begin_function
specifier|static
name|int
name|get_signo
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|int
name|signo
decl_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|signo
argument_list|,
sizeof|sizeof
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|signo
return|;
block|}
end_function

begin_comment
comment|/* Return the set of signals used by the threads library in *SET.  */
end_comment

begin_function
name|void
name|lin_thread_get_thread_signals
parameter_list|(
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|sigaction
name|action
decl_stmt|;
name|int
name|restart
decl_stmt|,
name|cancel
decl_stmt|;
name|sigemptyset
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|restart
operator|=
name|get_signo
argument_list|(
literal|"__pthread_sig_restart"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restart
operator|==
literal|0
condition|)
return|return;
name|cancel
operator|=
name|get_signo
argument_list|(
literal|"__pthread_sig_cancel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel
operator|==
literal|0
condition|)
return|return;
name|sigaddset
argument_list|(
name|set
argument_list|,
name|restart
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
name|set
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
comment|/* The GNU/Linux Threads library makes terminating threads send a      special "cancel" signal instead of SIGCHLD.  Make sure we catch      those (to prevent them from terminating GDB itself, which is      likely to be their default action) and treat them the same way as      SIGCHLD.  */
name|action
operator|.
name|sa_handler
operator|=
name|sigchld_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|action
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|action
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|cancel
argument_list|,
operator|&
name|action
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We block the "cancel" signal throughout this code ...  */
name|sigaddset
argument_list|(
operator|&
name|blocked_mask
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|blocked_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ... except during a sigsuspend.  */
name|sigdelset
argument_list|(
operator|&
name|suspend_mask
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

