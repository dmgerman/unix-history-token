begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Densan DVE-R3900 ROM monitor for    GDB, the GNU debugger.    Copyright 1997, 1998, 2000, 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"mips-tdep.h"
end_include

begin_comment
comment|/* Type of function passed to bfd_map_over_sections.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|section_map_func
function_decl|)
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Packet escape character used by Densan monitor.  */
end_comment

begin_define
define|#
directive|define
name|PESC
value|0xdc
end_define

begin_comment
comment|/* Maximum packet size.  This is actually smaller than necessary    just to be safe.  */
end_comment

begin_define
define|#
directive|define
name|MAXPSIZE
value|1024
end_define

begin_comment
comment|/* External functions.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|report_transfer_performance
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|time_t
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Certain registers are "bitmapped", in that the monitor can only display    them or let the user modify them as a series of named bitfields.    This structure describes a field in a bitmapped register.  */
end_comment

begin_struct
struct|struct
name|bit_field
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* string appearing before the value */
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* string appearing after the value */
name|char
modifier|*
name|user_name
decl_stmt|;
comment|/* name used by human when entering field value */
name|int
name|length
decl_stmt|;
comment|/* number of bits in the field */
name|int
name|start
decl_stmt|;
comment|/* starting (least significant) bit number of field */
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions for register manipulation.  */
end_comment

begin_function_decl
specifier|static
name|void
name|r3900_supply_register
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|,
name|int
name|regnamelen
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|vallen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetch_bad_vaddr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|fetch_fields
parameter_list|(
name|struct
name|bit_field
modifier|*
name|bf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetch_bitmapped_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|bit_field
modifier|*
name|bf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r3900_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_bitmapped_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|bit_field
modifier|*
name|bf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r3900_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local functions for fast binary loading.  */
end_comment

begin_function_decl
specifier|static
name|void
name|write_long
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_long_le
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_readchar
parameter_list|(
name|int
name|hex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_write
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignore_packet
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_packet
parameter_list|(
name|char
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
name|seq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_read_request
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|count_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|section_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|data_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r3900_load
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Miscellaneous local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|r3900_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pointers to static functions in monitor.c for fetching and storing    registers.  We can't use these function in certain cases where the Densan    monitor acts perversely: for registers that it displays in bit-map    format, and those that can't be modified at all.  In those cases    we have to use our own functions to fetch and store their values.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|orig_monitor_fetch_registers
function_decl|)
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|orig_monitor_store_registers
function_decl|)
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to static function in monitor. for loading programs.    We use this function for loading S-records via the serial link.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|orig_monitor_load
function_decl|)
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This flag is set if a fast ethernet download should be used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ethernet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array of registers needs to match the indexes used by GDB. The    whole reason this exists is because the various ROM monitors use    different names than GDB does, and don't support all the registers    either.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|r3900_regnames
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"r30"
block|,
literal|"r31"
block|,
literal|"S"
block|,
comment|/* PS_REGNUM */
literal|"l"
block|,
comment|/* MIPS_EMBED_LO_REGNUM */
literal|"h"
block|,
comment|/* MIPS_EMBED_HI_REGNUM */
literal|"B"
block|,
comment|/* MIPS_EMBED_BADVADDR_REGNUM */
literal|"Pcause"
block|,
comment|/* MIPS_EMBED_CAUSE_REGNUM */
literal|"p"
comment|/* MIPS_EMBED_PC_REGNUM */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of register names produced by monitor's register dump command.  */
end_comment

begin_struct
specifier|static
struct|struct
name|reg_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|}
name|reg_table
index|[]
init|=
block|{
block|{
literal|"r0_zero"
block|,
literal|0
block|}
block|,
block|{
literal|"r1_at"
block|,
literal|1
block|}
block|,
block|{
literal|"r2_v0"
block|,
literal|2
block|}
block|,
block|{
literal|"r3_v1"
block|,
literal|3
block|}
block|,
block|{
literal|"r4_a0"
block|,
literal|4
block|}
block|,
block|{
literal|"r5_a1"
block|,
literal|5
block|}
block|,
block|{
literal|"r6_a2"
block|,
literal|6
block|}
block|,
block|{
literal|"r7_a3"
block|,
literal|7
block|}
block|,
block|{
literal|"r8_t0"
block|,
literal|8
block|}
block|,
block|{
literal|"r9_t1"
block|,
literal|9
block|}
block|,
block|{
literal|"r10_t2"
block|,
literal|10
block|}
block|,
block|{
literal|"r11_t3"
block|,
literal|11
block|}
block|,
block|{
literal|"r12_t4"
block|,
literal|12
block|}
block|,
block|{
literal|"r13_t5"
block|,
literal|13
block|}
block|,
block|{
literal|"r14_t6"
block|,
literal|14
block|}
block|,
block|{
literal|"r15_t7"
block|,
literal|15
block|}
block|,
block|{
literal|"r16_s0"
block|,
literal|16
block|}
block|,
block|{
literal|"r17_s1"
block|,
literal|17
block|}
block|,
block|{
literal|"r18_s2"
block|,
literal|18
block|}
block|,
block|{
literal|"r19_s3"
block|,
literal|19
block|}
block|,
block|{
literal|"r20_s4"
block|,
literal|20
block|}
block|,
block|{
literal|"r21_s5"
block|,
literal|21
block|}
block|,
block|{
literal|"r22_s6"
block|,
literal|22
block|}
block|,
block|{
literal|"r23_s7"
block|,
literal|23
block|}
block|,
block|{
literal|"r24_t8"
block|,
literal|24
block|}
block|,
block|{
literal|"r25_t9"
block|,
literal|25
block|}
block|,
block|{
literal|"r26_k0"
block|,
literal|26
block|}
block|,
block|{
literal|"r27_k1"
block|,
literal|27
block|}
block|,
block|{
literal|"r28_gp"
block|,
literal|28
block|}
block|,
block|{
literal|"r29_sp"
block|,
literal|29
block|}
block|,
block|{
literal|"r30_fp"
block|,
literal|30
block|}
block|,
block|{
literal|"r31_ra"
block|,
literal|31
block|}
block|,
block|{
literal|"HI"
block|,
name|MIPS_EMBED_HI_REGNUM
block|}
block|,
block|{
literal|"LO"
block|,
name|MIPS_EMBED_LO_REGNUM
block|}
block|,
block|{
literal|"PC"
block|,
name|MIPS_EMBED_PC_REGNUM
block|}
block|,
block|{
literal|"BadV"
block|,
name|MIPS_EMBED_BADVADDR_REGNUM
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* The monitor displays the cache register along with the status register,    as if they were a single register.  So when we want to fetch the    status register, parse but otherwise ignore the fields of the    cache register that the monitor displays.  Register fields that should    be ignored have a length of zero in the tables below.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bit_field
name|status_fields
index|[]
init|=
block|{
comment|/* Status register portion */
block|{
literal|"SR[<CU="
block|,
literal|" "
block|,
literal|"cu"
block|,
literal|4
block|,
literal|28
block|}
block|,
block|{
literal|"RE="
block|,
literal|" "
block|,
literal|"re"
block|,
literal|1
block|,
literal|25
block|}
block|,
block|{
literal|"BEV="
block|,
literal|" "
block|,
literal|"bev"
block|,
literal|1
block|,
literal|22
block|}
block|,
block|{
literal|"TS="
block|,
literal|" "
block|,
literal|"ts"
block|,
literal|1
block|,
literal|21
block|}
block|,
block|{
literal|"Nmi="
block|,
literal|" "
block|,
literal|"nmi"
block|,
literal|1
block|,
literal|20
block|}
block|,
block|{
literal|"INT="
block|,
literal|" "
block|,
literal|"int"
block|,
literal|6
block|,
literal|10
block|}
block|,
block|{
literal|"SW="
block|,
literal|">]"
block|,
literal|"sw"
block|,
literal|2
block|,
literal|8
block|}
block|,
block|{
literal|"[<KUO="
block|,
literal|" "
block|,
literal|"kuo"
block|,
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|"IEO="
block|,
literal|" "
block|,
literal|"ieo"
block|,
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|"KUP="
block|,
literal|" "
block|,
literal|"kup"
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|"IEP="
block|,
literal|" "
block|,
literal|"iep"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"KUC="
block|,
literal|" "
block|,
literal|"kuc"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"IEC="
block|,
literal|">]"
block|,
literal|"iec"
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* Cache register portion (dummy for parsing only) */
block|{
literal|"CR[<IalO="
block|,
literal|" "
block|,
literal|"ialo"
block|,
literal|0
block|,
literal|13
block|}
block|,
block|{
literal|"DalO="
block|,
literal|" "
block|,
literal|"dalo"
block|,
literal|0
block|,
literal|12
block|}
block|,
block|{
literal|"IalP="
block|,
literal|" "
block|,
literal|"ialp"
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|"DalP="
block|,
literal|" "
block|,
literal|"dalp"
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"IalC="
block|,
literal|" "
block|,
literal|"ialc"
block|,
literal|0
block|,
literal|9
block|}
block|,
block|{
literal|"DalC="
block|,
literal|">] "
block|,
literal|"dalc"
block|,
literal|0
block|,
literal|8
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
comment|/* end of table marker */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME: Enable when we add support for modifying cache register.  */
end_comment

begin_comment
unit|static struct bit_field cache_fields[] = {
comment|/* Status register portion (dummy for parsing only) */
end_comment

begin_comment
unit|{"SR[<CU=", " ", "cu", 0, 28},   {"RE=", " ", "re", 0, 25},   {"BEV=", " ", "bev", 0, 22},   {"TS=", " ", "ts", 0, 21},   {"Nmi=", " ", "nmi", 0, 20},   {"INT=", " ", "int", 0, 10},   {"SW=", ">]", "sw", 0, 8},   {"[<KUO=", " ", "kuo", 0, 5},   {"IEO=", " ", "ieo", 0, 4},   {"KUP=", " ", "kup", 0, 3},   {"IEP=", " ", "iep", 0, 2},   {"KUC=", " ", "kuc", 0, 1},   {"IEC=", ">]", "iec", 0, 0},
comment|/* Cache register portion  */
end_comment

begin_comment
unit|{"CR[<IalO=", " ", "ialo", 1, 13},   {"DalO=", " ", "dalo", 1, 12},   {"IalP=", " ", "ialp", 1, 11},   {"DalP=", " ", "dalp", 1, 10},   {"IalC=", " ", "ialc", 1, 9},   {"DalC=", ">] ", "dalc", 1, 8},    {NULL, NULL, NULL, 0, 0}
comment|/* end of table marker */
end_comment

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|bit_field
name|cause_fields
index|[]
init|=
block|{
block|{
literal|"<BD="
block|,
literal|" "
block|,
literal|"bd"
block|,
literal|1
block|,
literal|31
block|}
block|,
block|{
literal|"CE="
block|,
literal|" "
block|,
literal|"ce"
block|,
literal|2
block|,
literal|28
block|}
block|,
block|{
literal|"IP="
block|,
literal|" "
block|,
literal|"ip"
block|,
literal|6
block|,
literal|10
block|}
block|,
block|{
literal|"SW="
block|,
literal|" "
block|,
literal|"sw"
block|,
literal|2
block|,
literal|8
block|}
block|,
block|{
literal|"EC="
block|,
literal|">]"
block|,
literal|"ec"
block|,
literal|5
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
comment|/* end of table marker */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The monitor prints register values in the form     regname = xxxx xxxx     We look up the register name in a table, and remove the embedded space in    the hex value before passing it to monitor_supply_register.  */
end_comment

begin_function
specifier|static
name|void
name|r3900_supply_register
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|,
name|int
name|regnamelen
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|vallen
parameter_list|)
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|valbuf
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Perform some sanity checks on the register name and value.  */
if|if
condition|(
name|regnamelen
operator|<
literal|2
operator|||
name|regnamelen
operator|>
literal|7
operator|||
name|vallen
operator|!=
literal|9
condition|)
return|return;
comment|/* Look up the register name.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rlen
init|=
name|strlen
argument_list|(
name|reg_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|rlen
operator|==
name|regnamelen
operator|&&
name|strncmp
argument_list|(
name|regname
argument_list|,
name|reg_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|rlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|regno
operator|=
name|reg_table
index|[
name|i
index|]
operator|.
name|regno
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Copy the hex value to a buffer and eliminate the embedded space. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|valbuf
init|;
name|i
operator|<
name|vallen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|val
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
operator|*
name|p
operator|++
operator|=
name|val
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|monitor_supply_register
argument_list|(
name|regno
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch the BadVaddr register.  Unlike the other registers, this    one can't be modified, and the monitor won't even prompt to let    you modify it.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_bad_vaddr
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|monitor_printf
argument_list|(
literal|"xB\r"
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
literal|"BadV="
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|monitor_supply_register
argument_list|(
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|badvaddr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a series of bit fields from the monitor, and return their    combined binary value.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|fetch_fields
parameter_list|(
name|struct
name|bit_field
modifier|*
name|bf
parameter_list|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|long
name|val
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|bits
decl_stmt|;
for|for
control|(
init|;
name|bf
operator|->
name|prefix
operator|!=
name|NULL
condition|;
name|bf
operator|++
control|)
block|{
name|monitor_expect
argument_list|(
name|bf
operator|->
name|prefix
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get prefix */
name|monitor_expect
argument_list|(
name|bf
operator|->
name|suffix
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hex value, suffix */
if|if
condition|(
name|bf
operator|->
name|length
operator|!=
literal|0
condition|)
block|{
name|bits
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* get field value */
name|bits
operator|&=
operator|(
operator|(
literal|1
operator|<<
name|bf
operator|->
name|length
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* mask out useless bits */
name|val
operator||=
name|bits
operator|<<
name|bf
operator|->
name|start
expr_stmt|;
comment|/* insert into register */
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_bitmapped_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|bit_field
modifier|*
name|bf
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|char
name|regbuf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|regname
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
sizeof|sizeof
argument_list|(
name|r3900_regnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|r3900_regnames
index|[
literal|0
index|]
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"fetch_bitmapped_register: regno out of bounds"
argument_list|)
expr_stmt|;
else|else
name|regname
operator|=
name|r3900_regnames
index|[
name|regno
index|]
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"x%s\r"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
name|val
operator|=
name|fetch_fields
argument_list|(
name|bf
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|".\r"
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* supply register stores in target byte order, so swap here */
name|store_unsigned_integer
argument_list|(
name|regbuf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers (if regno is -1), or one register from the    monitor.  For most registers, we can use the generic monitor_    monitor_fetch_registers function.  But others are displayed in    a very unusual fashion by the monitor, and must be handled specially.  */
end_comment

begin_function
specifier|static
name|void
name|r3900_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|badvaddr
condition|)
name|fetch_bad_vaddr
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|PS_REGNUM
condition|)
name|fetch_bitmapped_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|status_fields
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|cause
condition|)
name|fetch_bitmapped_register
argument_list|(
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|cause
argument_list|,
name|cause_fields
argument_list|)
expr_stmt|;
else|else
name|orig_monitor_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the new value of the bitmapped register to the monitor.  */
end_comment

begin_function
specifier|static
name|void
name|store_bitmapped_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|bit_field
modifier|*
name|bf
parameter_list|)
block|{
name|unsigned
name|long
name|oldval
decl_stmt|,
name|newval
decl_stmt|;
name|char
modifier|*
name|regname
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
sizeof|sizeof
argument_list|(
name|r3900_regnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|r3900_regnames
index|[
literal|0
index|]
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"fetch_bitmapped_register: regno out of bounds"
argument_list|)
expr_stmt|;
else|else
name|regname
operator|=
name|r3900_regnames
index|[
name|regno
index|]
expr_stmt|;
comment|/* Fetch the current value of the register.  */
name|monitor_printf
argument_list|(
literal|"x%s\r"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|fetch_fields
argument_list|(
name|bf
argument_list|)
expr_stmt|;
name|newval
operator|=
name|read_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
comment|/* To save time, write just the fields that have changed.  */
for|for
control|(
init|;
name|bf
operator|->
name|prefix
operator|!=
name|NULL
condition|;
name|bf
operator|++
control|)
block|{
if|if
condition|(
name|bf
operator|->
name|length
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|long
name|oldbits
decl_stmt|,
name|newbits
decl_stmt|,
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|bf
operator|->
name|length
operator|)
operator|-
literal|1
expr_stmt|;
name|oldbits
operator|=
operator|(
name|oldval
operator|>>
name|bf
operator|->
name|start
operator|)
operator|&
name|mask
expr_stmt|;
name|newbits
operator|=
operator|(
name|newval
operator|>>
name|bf
operator|->
name|start
operator|)
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|oldbits
operator|!=
name|newbits
condition|)
name|monitor_printf
argument_list|(
literal|"%s %lx "
argument_list|,
name|bf
operator|->
name|user_name
argument_list|,
name|newbits
argument_list|)
expr_stmt|;
block|}
block|}
name|monitor_printf
argument_list|(
literal|".\r"
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|r3900_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
name|PS_REGNUM
condition|)
name|store_bitmapped_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|status_fields
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|cause
condition|)
name|store_bitmapped_register
argument_list|(
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|cause
argument_list|,
name|cause_fields
argument_list|)
expr_stmt|;
else|else
name|orig_monitor_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a 4-byte integer to the buffer in big-endian order.  */
end_comment

begin_function
specifier|static
name|void
name|write_long
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|n
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|n
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|n
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|n
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a 4-byte integer to the buffer in little-endian order.  */
end_comment

begin_function
specifier|static
name|void
name|write_long_le
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|n
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|n
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|n
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|n
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a character from the monitor.  If remote debugging is on,    print the received character.  If HEX is non-zero, print the    character in hexadecimal; otherwise, print it in ASCII.  */
end_comment

begin_function
specifier|static
name|int
name|debug_readchar
parameter_list|(
name|int
name|hex
parameter_list|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|c
init|=
name|monitor_readchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|hex
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%02x]"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|puts_debug
argument_list|(
literal|"Read -->"
argument_list|,
name|buf
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Send a buffer of characters to the monitor.  If remote debugging is on,    print the sent buffer in hex.  */
end_comment

begin_function
specifier|static
name|void
name|debug_write
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|char
name|s
index|[
literal|10
index|]
decl_stmt|;
name|monitor_write
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|buflen
operator|--
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"[%02x]"
argument_list|,
operator|*
name|buf
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|puts_debug
argument_list|(
literal|"Sent -->"
argument_list|,
name|s
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Ignore a packet sent to us by the monitor.  It send packets    when its console is in "communications interface" mode.   A packet    is of this form:     start of packet flag (one byte: 0xdc)    packet type (one byte)    length (low byte)    length (high byte)    data (length bytes)     The last two bytes of the data field are a checksum, but we don't    bother to verify it.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_packet
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Ignore lots of trash (messages about section addresses, for example)      until we see the start of a packet.  */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|256
condition|;
name|len
operator|++
control|)
block|{
name|c
operator|=
name|debug_readchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|PESC
condition|)
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|8
condition|)
name|error
argument_list|(
literal|"Packet header byte not found; %02x seen instead."
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Read the packet type and length.  */
name|c
operator|=
name|debug_readchar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* type */
name|c
operator|=
name|debug_readchar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* low byte of length */
name|len
operator|=
name|c
operator|&
literal|0xff
expr_stmt|;
name|c
operator|=
name|debug_readchar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* high byte of length */
name|len
operator|+=
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* Ignore the rest of the packet.  */
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|c
operator|=
name|debug_readchar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encapsulate some data into a packet and send it to the monitor.     The 'p' packet is a special case.  This is a packet we send    in response to a read ('r') packet from the monitor.  This function    appends a one-byte sequence number to the data field of such a packet.  */
end_comment

begin_function
specifier|static
name|void
name|send_packet
parameter_list|(
name|char
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|unsigned
name|char
name|hdr
index|[
literal|4
index|]
decl_stmt|;
name|int
name|len
init|=
name|buflen
decl_stmt|;
name|int
name|sum
decl_stmt|,
name|i
decl_stmt|;
comment|/* If this is a 'p' packet, add one byte for a sequence number.  */
if|if
condition|(
name|type
operator|==
literal|'p'
condition|)
name|len
operator|++
expr_stmt|;
comment|/* If the buffer has a non-zero length, add two bytes for a checksum.  */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
comment|/* Write the packet header.  */
name|hdr
index|[
literal|0
index|]
operator|=
name|PESC
expr_stmt|;
name|hdr
index|[
literal|1
index|]
operator|=
name|type
expr_stmt|;
name|hdr
index|[
literal|2
index|]
operator|=
name|len
operator|&
literal|0xff
expr_stmt|;
name|hdr
index|[
literal|3
index|]
operator|=
operator|(
name|len
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|debug_write
argument_list|(
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
comment|/* Write the packet data.  */
name|debug_write
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
comment|/* Write the sequence number if this is a 'p' packet.  */
if|if
condition|(
name|type
operator|==
literal|'p'
condition|)
block|{
name|hdr
index|[
literal|0
index|]
operator|=
name|seq
expr_stmt|;
name|debug_write
argument_list|(
name|hdr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Write the checksum.  */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buflen
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tmp
init|=
operator|(
name|buf
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|sum
operator|+=
name|tmp
expr_stmt|;
else|else
name|sum
operator|+=
name|tmp
operator|<<
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|buflen
operator|&
literal|1
condition|)
name|sum
operator|+=
operator|(
name|seq
operator|&
literal|0xff
operator|)
expr_stmt|;
else|else
name|sum
operator|+=
operator|(
name|seq
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
name|sum
operator|=
operator|(
name|sum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|&
literal|1
expr_stmt|;
name|sum
operator|=
operator|~
name|sum
expr_stmt|;
name|hdr
index|[
literal|0
index|]
operator|=
operator|(
name|sum
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|hdr
index|[
literal|1
index|]
operator|=
name|sum
operator|&
literal|0xff
expr_stmt|;
name|debug_write
argument_list|(
name|hdr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Respond to an expected read request from the monitor by sending    data in chunks.  Handle all acknowledgements and handshaking packets.     The monitor expects a response consisting of a one or more 'p' packets,    each followed by a portion of the data requested.  The 'p' packet    contains only a four-byte integer, the value of which is the number    of bytes of data we are about to send.  Following the 'p' packet,    the monitor expects the data bytes themselves in raw, unpacketized,    form, without even a checksum.  */
end_comment

begin_function
specifier|static
name|void
name|process_read_request
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|unsigned
name|char
name|len
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chunk
decl_stmt|;
name|unsigned
name|char
name|seq
decl_stmt|;
comment|/* Discard the read request.  FIXME: we have to hope it's for      the exact number of bytes we want to send; should check for this.  */
name|ignore_packet
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|chunk
operator|=
literal|0
operator|,
name|seq
operator|=
literal|0
init|;
name|i
operator|<
name|buflen
condition|;
name|i
operator|+=
name|chunk
operator|,
name|seq
operator|++
control|)
block|{
comment|/* Don't send more than MAXPSIZE bytes at a time.  */
name|chunk
operator|=
name|buflen
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|chunk
operator|>
name|MAXPSIZE
condition|)
name|chunk
operator|=
name|MAXPSIZE
expr_stmt|;
comment|/* Write a packet containing the number of bytes we are sending.  */
name|write_long_le
argument_list|(
name|len
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|send_packet
argument_list|(
literal|'p'
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
name|seq
argument_list|)
expr_stmt|;
comment|/* Write the data in raw form following the packet.  */
name|debug_write
argument_list|(
operator|&
name|buf
index|[
name|i
index|]
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
comment|/* Discard the ACK packet.  */
name|ignore_packet
argument_list|()
expr_stmt|;
block|}
comment|/* Send an "end of data" packet.  */
name|send_packet
argument_list|(
literal|'e'
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count loadable sections (helper function for r3900_load).  */
end_comment

begin_function
specifier|static
name|void
name|count_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|section_count
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|&&
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
operator|!=
literal|0
condition|)
operator|(
operator|*
name|section_count
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load a single BFD section (helper function for r3900_load).     WARNING: this code is filled with assumptions about how    the Densan monitor loads programs.  The monitor issues    packets containing read requests, but rather than respond    to them in an general way, we expect them to following    a certain pattern.     For example, we know that the monitor will start loading by    issuing an 8-byte read request for the binary file header.    We know this is coming and ignore the actual contents    of the read request packet.  */
end_comment

begin_function
specifier|static
name|void
name|load_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|data_count
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|section_size
init|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_vma
name|section_base
init|=
name|bfd_section_lma
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|char
name|header
index|[
literal|8
index|]
decl_stmt|;
comment|/* Don't output zero-length sections.  */
if|if
condition|(
name|section_size
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|data_count
condition|)
operator|*
name|data_count
operator|+=
name|section_size
expr_stmt|;
comment|/* Print some fluff about the section being loaded.  */
name|printf_filtered
argument_list|(
literal|"Loading section %s, size 0x%lx lma "
argument_list|,
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|section_size
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|section_base
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Write the section header (location and size).  */
name|write_long
argument_list|(
operator|&
name|header
index|[
literal|0
index|]
argument_list|,
operator|(
name|long
operator|)
name|section_base
argument_list|)
expr_stmt|;
name|write_long
argument_list|(
operator|&
name|header
index|[
literal|4
index|]
argument_list|,
operator|(
name|long
operator|)
name|section_size
argument_list|)
expr_stmt|;
name|process_read_request
argument_list|(
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the section contents into a buffer, write it out,          then free the buffer.  */
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|section_size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|process_read_request
argument_list|(
name|buffer
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* When the ethernet is used as the console port on the Densan board,    we can use the "Rm" command to do a fast binary load.  The format    of the download data is:     number of sections (4 bytes)    starting address (4 bytes)    repeat for each section:    location address (4 bytes)    section size (4 bytes)    binary data     The 4-byte fields are all in big-endian order.     Using this command is tricky because we have to put the monitor    into a special funky "communications interface" mode, in which    it sends and receives packets of data along with the normal prompt.  */
end_comment

begin_function
specifier|static
name|void
name|r3900_load
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|data_count
init|=
literal|0
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* for timing of download */
name|int
name|section_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
literal|8
index|]
decl_stmt|;
comment|/* If we are not using the ethernet, use the normal monitor load,      which sends S-records over the serial link.  */
if|if
condition|(
operator|!
name|ethernet
condition|)
block|{
name|orig_monitor_load
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Open the file.  */
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
name|filename
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|filename
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
name|error
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
comment|/* Output the "vconsi" command to get the monitor in the communication      state where it will accept a load command.  This will cause      the monitor to emit a packet before each prompt, so ignore the packet.  */
name|monitor_printf
argument_list|(
literal|"vconsi\r"
argument_list|)
expr_stmt|;
name|ignore_packet
argument_list|()
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the "Rm" (load) command and respond to the subsequent "open"      packet by sending an ACK packet.  */
name|monitor_printf
argument_list|(
literal|"Rm\r"
argument_list|)
expr_stmt|;
name|ignore_packet
argument_list|()
expr_stmt|;
name|send_packet
argument_list|(
literal|'a'
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the fast load header (number of sections and starting address).  */
name|bfd_map_over_sections
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|abfd
argument_list|,
operator|(
name|section_map_func
operator|)
name|count_section
argument_list|,
operator|&
name|section_count
argument_list|)
expr_stmt|;
name|write_long
argument_list|(
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
operator|(
name|long
operator|)
name|section_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
name|write_long
argument_list|(
operator|&
name|buffer
index|[
literal|4
index|]
argument_list|,
operator|(
name|long
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|write_long
argument_list|(
operator|&
name|buffer
index|[
literal|4
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|process_read_request
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the section data.  */
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
operator|(
name|section_map_func
operator|)
name|load_section
argument_list|,
operator|&
name|data_count
argument_list|)
expr_stmt|;
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Acknowledge the close packet and put the monitor back into      "normal" mode so it won't send packets any more.  */
name|ignore_packet
argument_list|()
expr_stmt|;
name|send_packet
argument_list|(
literal|'a'
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"vconsx\r"
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Print start address and download performance information.  */
name|printf_filtered
argument_list|(
literal|"Start address 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|report_transfer_performance
argument_list|(
name|data_count
argument_list|,
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the      time that we attached to the monitor, which is no longer valid      now that we have loaded new code (and just changed the PC).      Another way to do this might be to call normal_stop, except that      the stack may not be valid, and things would get horribly      confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commands to send to the monitor when first connecting:    * The bare carriage return forces a prompt from the monitor    (monitor doesn't prompt immediately after a reset).    * The "vconsx" switches the monitor back to interactive mode    in case an aborted download had left it in packet mode.    * The "Xtr" command causes subsequent "t" (trace) commands to display    the general registers only.    * The "Xxr" command does the same thing for the "x" (examine    registers) command.    * The "bx" command clears all breakpoints.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|r3900_inits
index|[]
init|=
block|{
literal|"\r"
block|,
literal|"vconsx\r"
block|,
literal|"Xtr\r"
block|,
literal|"Xxr\r"
block|,
literal|"bx\r"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dummy_inits
index|[]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|r3900_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
name|r3900_cmds
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|r3900_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|monitor_open
argument_list|(
name|args
argument_list|,
operator|&
name|r3900_cmds
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* We have to handle sending the init strings ourselves, because      the first two strings we send (carriage returns) may not be echoed      by the monitor, but the rest will be.  */
name|monitor_printf_noecho
argument_list|(
literal|"\r\r"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|r3900_inits
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|monitor_printf
argument_list|(
name|r3900_inits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Attempt to determine whether the console device is ethernet or serial.      This will tell us which kind of load to use (S-records over a serial      link, or the Densan fast binary multi-section format over the net).  */
name|ethernet
operator|=
literal|0
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"v\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_expect
argument_list|(
literal|"console device :"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|monitor_expect
argument_list|(
literal|"\n"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|strstr
argument_list|(
name|buf
argument_list|,
literal|"ethernet"
argument_list|)
operator|!=
name|NULL
condition|)
name|ethernet
operator|=
literal|1
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_r3900_rom
parameter_list|(
name|void
parameter_list|)
block|{
name|r3900_cmds
operator|.
name|flags
operator|=
name|MO_NO_ECHO_ON_OPEN
operator||
name|MO_ADDR_BITS_REMOVE
operator||
name|MO_CLR_BREAK_USES_ADDR
operator||
name|MO_GETMEM_READ_SINGLE
operator||
name|MO_PRINT_PROGRAM_OUTPUT
expr_stmt|;
name|r3900_cmds
operator|.
name|init
operator|=
name|dummy_inits
expr_stmt|;
name|r3900_cmds
operator|.
name|cont
operator|=
literal|"g\r"
expr_stmt|;
name|r3900_cmds
operator|.
name|step
operator|=
literal|"t\r"
expr_stmt|;
name|r3900_cmds
operator|.
name|set_break
operator|=
literal|"b %A\r"
expr_stmt|;
comment|/* COREADDR */
name|r3900_cmds
operator|.
name|clr_break
operator|=
literal|"b %A,0\r"
expr_stmt|;
comment|/* COREADDR */
name|r3900_cmds
operator|.
name|fill
operator|=
literal|"fx %A s %x %x\r"
expr_stmt|;
comment|/* COREADDR, len, val */
name|r3900_cmds
operator|.
name|setmem
operator|.
name|cmdb
operator|=
literal|"sx %A %x\r"
expr_stmt|;
comment|/* COREADDR, val */
name|r3900_cmds
operator|.
name|setmem
operator|.
name|cmdw
operator|=
literal|"sh %A %x\r"
expr_stmt|;
comment|/* COREADDR, val */
name|r3900_cmds
operator|.
name|setmem
operator|.
name|cmdl
operator|=
literal|"sw %A %x\r"
expr_stmt|;
comment|/* COREADDR, val */
name|r3900_cmds
operator|.
name|getmem
operator|.
name|cmdb
operator|=
literal|"sx %A\r"
expr_stmt|;
comment|/* COREADDR */
name|r3900_cmds
operator|.
name|getmem
operator|.
name|cmdw
operator|=
literal|"sh %A\r"
expr_stmt|;
comment|/* COREADDR */
name|r3900_cmds
operator|.
name|getmem
operator|.
name|cmdl
operator|=
literal|"sw %A\r"
expr_stmt|;
comment|/* COREADDR */
name|r3900_cmds
operator|.
name|getmem
operator|.
name|resp_delim
operator|=
literal|" : "
expr_stmt|;
name|r3900_cmds
operator|.
name|getmem
operator|.
name|term
operator|=
literal|" "
expr_stmt|;
name|r3900_cmds
operator|.
name|getmem
operator|.
name|term_cmd
operator|=
literal|".\r"
expr_stmt|;
name|r3900_cmds
operator|.
name|setreg
operator|.
name|cmd
operator|=
literal|"x%s %x\r"
expr_stmt|;
comment|/* regname, val */
name|r3900_cmds
operator|.
name|getreg
operator|.
name|cmd
operator|=
literal|"x%s\r"
expr_stmt|;
comment|/* regname */
name|r3900_cmds
operator|.
name|getreg
operator|.
name|resp_delim
operator|=
literal|"="
expr_stmt|;
name|r3900_cmds
operator|.
name|getreg
operator|.
name|term
operator|=
literal|" "
expr_stmt|;
name|r3900_cmds
operator|.
name|getreg
operator|.
name|term_cmd
operator|=
literal|".\r"
expr_stmt|;
name|r3900_cmds
operator|.
name|dump_registers
operator|=
literal|"x\r"
expr_stmt|;
name|r3900_cmds
operator|.
name|register_pattern
operator|=
literal|"\\([a-zA-Z0-9_]+\\) *=\\([0-9a-f]+ [0-9a-f]+\\b\\)"
expr_stmt|;
name|r3900_cmds
operator|.
name|supply_register
operator|=
name|r3900_supply_register
expr_stmt|;
comment|/* S-record download, via "keyboard port".  */
name|r3900_cmds
operator|.
name|load
operator|=
literal|"r0\r"
expr_stmt|;
name|r3900_cmds
operator|.
name|prompt
operator|=
literal|"#"
expr_stmt|;
name|r3900_cmds
operator|.
name|line_term
operator|=
literal|"\r"
expr_stmt|;
name|r3900_cmds
operator|.
name|target
operator|=
operator|&
name|r3900_ops
expr_stmt|;
name|r3900_cmds
operator|.
name|stopbits
operator|=
name|SERIAL_1_STOPBITS
expr_stmt|;
name|r3900_cmds
operator|.
name|regnames
operator|=
name|r3900_regnames
expr_stmt|;
name|r3900_cmds
operator|.
name|magic
operator|=
name|MONITOR_OPS_MAGIC
expr_stmt|;
name|init_monitor_ops
argument_list|(
operator|&
name|r3900_ops
argument_list|)
expr_stmt|;
name|r3900_ops
operator|.
name|to_shortname
operator|=
literal|"r3900"
expr_stmt|;
name|r3900_ops
operator|.
name|to_longname
operator|=
literal|"R3900 monitor"
expr_stmt|;
name|r3900_ops
operator|.
name|to_doc
operator|=
literal|"Debug using the DVE R3900 monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|r3900_ops
operator|.
name|to_open
operator|=
name|r3900_open
expr_stmt|;
comment|/* Override the functions to fetch and store registers.  But save the      addresses of the default functions, because we will use those functions      for "normal" registers.  */
name|orig_monitor_fetch_registers
operator|=
name|r3900_ops
operator|.
name|to_fetch_registers
expr_stmt|;
name|orig_monitor_store_registers
operator|=
name|r3900_ops
operator|.
name|to_store_registers
expr_stmt|;
name|r3900_ops
operator|.
name|to_fetch_registers
operator|=
name|r3900_fetch_registers
expr_stmt|;
name|r3900_ops
operator|.
name|to_store_registers
operator|=
name|r3900_store_registers
expr_stmt|;
comment|/* Override the load function, but save the address of the default      function to use when loading S-records over a serial link.  */
name|orig_monitor_load
operator|=
name|r3900_ops
operator|.
name|to_load
expr_stmt|;
name|r3900_ops
operator|.
name|to_load
operator|=
name|r3900_load
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|r3900_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

