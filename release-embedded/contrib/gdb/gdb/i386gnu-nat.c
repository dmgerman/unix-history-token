begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to i386 running the GNU Hurd.    Copyright 1992, 1995, 1996, 1998, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<mach.h>
end_include

begin_include
include|#
directive|include
file|<mach_error.h>
end_include

begin_include
include|#
directive|include
file|<mach/message.h>
end_include

begin_include
include|#
directive|include
file|<mach/exception.h>
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_include
include|#
directive|include
file|"gnu-nat.h"
end_include

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Offset to the thread_state_t location where REG is stored.  */
end_comment

begin_define
define|#
directive|define
name|REG_OFFSET
parameter_list|(
name|reg
parameter_list|)
value|offsetof (struct i386_thread_state, reg)
end_define

begin_comment
comment|/* At REG_OFFSET[N] is the offset to the thread_state_t location where    the GDB register N is stored.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_offset
index|[]
init|=
block|{
name|REG_OFFSET
argument_list|(
name|eax
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|ecx
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|edx
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|ebx
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|uesp
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|ebp
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|esi
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|edi
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|eip
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|efl
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|cs
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|ss
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|ds
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|es
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|fs
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
argument|gs
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_ADDR
parameter_list|(
name|state
parameter_list|,
name|regnum
parameter_list|)
value|((char *)(state) + reg_offset[regnum])
end_define

begin_escape
end_escape

begin_comment
comment|/* Get the whole floating-point state of THREAD and record the    values of the corresponding (pseudo) registers.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_fpregs
parameter_list|(
name|struct
name|proc
modifier|*
name|thread
parameter_list|)
block|{
name|mach_msg_type_number_t
name|count
init|=
name|i386_FLOAT_STATE_COUNT
decl_stmt|;
name|struct
name|i386_float_state
name|state
decl_stmt|;
name|error_t
name|err
decl_stmt|;
name|err
operator|=
name|thread_get_state
argument_list|(
name|thread
operator|->
name|port
argument_list|,
name|i386_FLOAT_STATE
argument_list|,
operator|(
name|thread_state_t
operator|)
operator|&
name|state
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't fetch floating-point state from %s"
argument_list|,
name|proc_string
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|state
operator|.
name|initialized
condition|)
comment|/* The floating-point state isn't initialized.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|FOP_REGNUM
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Supply the floating-point registers.  */
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|state
operator|.
name|hw_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
end_ifdef

begin_comment
comment|/* These two calls are used by the core-regset.c code for    reading ELF core files.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I386_NUM_GREGS
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|REG_ADDR
argument_list|(
name|gregs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregs
parameter_list|)
block|{
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fetch register REGNO, or all regs if REGNO is -1.  */
end_comment

begin_function
name|void
name|gnu_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
comment|/* Make sure we know about new threads.  */
name|inf_update_procs
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
name|thread
operator|=
name|inf_tid_to_thread
argument_list|(
name|current_inferior
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread
condition|)
name|error
argument_list|(
literal|"Can't fetch registers from thread %d: No such thread"
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|I386_NUM_GREGS
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|thread_state_t
name|state
decl_stmt|;
comment|/* This does the dirty work for us.  */
name|state
operator|=
name|proc_get_state
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't fetch registers from %s"
argument_list|,
name|proc_string
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"fetching all register"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I386_NUM_GREGS
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|REG_ADDR
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|fetched_regs
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"fetching register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|REG_ADDR
argument_list|(
name|state
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|fetched_regs
operator||=
operator|(
literal|1
operator|<<
name|regno
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regno
operator|>=
name|I386_NUM_GREGS
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"fetching floating-point registers"
argument_list|)
expr_stmt|;
name|fetch_fpregs
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the whole floating-point state into THREAD using information    from the corresponding (pseudo) registers.  */
end_comment

begin_function
specifier|static
name|void
name|store_fpregs
parameter_list|(
name|struct
name|proc
modifier|*
name|thread
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|mach_msg_type_number_t
name|count
init|=
name|i386_FLOAT_STATE_COUNT
decl_stmt|;
name|struct
name|i386_float_state
name|state
decl_stmt|;
name|error_t
name|err
decl_stmt|;
name|err
operator|=
name|thread_get_state
argument_list|(
name|thread
operator|->
name|port
argument_list|,
name|i386_FLOAT_STATE
argument_list|,
operator|(
name|thread_state_t
operator|)
operator|&
name|state
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't fetch floating-point state from %s"
argument_list|,
name|proc_string
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME: kettenis/2001-07-15: Is this right?  Should we somehow      take into account DEPRECATED_REGISTER_VALID like the old code did?  */
name|i387_fill_fsave
argument_list|(
name|state
operator|.
name|hw_state
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|err
operator|=
name|thread_set_state
argument_list|(
name|thread
operator|->
name|port
argument_list|,
name|i386_FLOAT_STATE
argument_list|,
operator|(
name|thread_state_t
operator|)
operator|&
name|state
argument_list|,
name|i386_FLOAT_STATE_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't store floating-point state into %s"
argument_list|,
name|proc_string
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Store at least register REGNO, or all regs if REGNO == -1.  */
end_comment

begin_function
name|void
name|gnu_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
comment|/* Make sure we know about new threads.  */
name|inf_update_procs
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
name|thread
operator|=
name|inf_tid_to_thread
argument_list|(
name|current_inferior
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread
condition|)
name|error
argument_list|(
literal|"Couldn't store registers into thread %d: No such thread"
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|I386_NUM_GREGS
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|thread_state_t
name|state
decl_stmt|;
name|thread_state_data_t
name|old_state
decl_stmt|;
name|int
name|was_aborted
init|=
name|thread
operator|->
name|aborted
decl_stmt|;
name|int
name|was_valid
init|=
name|thread
operator|->
name|state_valid
decl_stmt|;
name|int
name|trace
decl_stmt|;
if|if
condition|(
operator|!
name|was_aborted
operator|&&
name|was_valid
condition|)
name|memcpy
argument_list|(
operator|&
name|old_state
argument_list|,
operator|&
name|thread
operator|->
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|old_state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|proc_get_state
argument_list|(
name|thread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't store registers into %s"
argument_list|,
name|proc_string
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Save the T bit.  We might try to restore the %eflags register          below, but changing the T bit would seriously confuse GDB.  */
name|trace
operator|=
operator|(
operator|(
expr|struct
name|i386_thread_state
operator|*
operator|)
name|state
operator|)
operator|->
name|efl
operator|&
literal|0x100
expr_stmt|;
if|if
condition|(
operator|!
name|was_aborted
operator|&&
name|was_valid
condition|)
comment|/* See which registers have changed after aborting the thread.  */
block|{
name|int
name|check_regno
decl_stmt|;
for|for
control|(
name|check_regno
operator|=
literal|0
init|;
name|check_regno
operator|<
name|I386_NUM_GREGS
condition|;
name|check_regno
operator|++
control|)
if|if
condition|(
operator|(
name|thread
operator|->
name|fetched_regs
operator|&
operator|(
literal|1
operator|<<
name|check_regno
operator|)
operator|)
operator|&&
name|memcpy
argument_list|(
name|REG_ADDR
argument_list|(
operator|&
name|old_state
argument_list|,
name|check_regno
argument_list|)
argument_list|,
name|REG_ADDR
argument_list|(
name|state
argument_list|,
name|check_regno
argument_list|)
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|check_regno
argument_list|)
argument_list|)
condition|)
comment|/* Register CHECK_REGNO has changed!  Ack!  */
block|{
name|warning
argument_list|(
literal|"Register %s changed after the thread was aborted"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|check_regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|!=
name|check_regno
condition|)
comment|/* Update GDB's copy of the register.  */
name|supply_register
argument_list|(
name|check_regno
argument_list|,
name|REG_ADDR
argument_list|(
name|state
argument_list|,
name|check_regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"... also writing this register!  Suspicious..."
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|fill
parameter_list|(
name|state
parameter_list|,
name|regno
parameter_list|)
define|\
value|memcpy (REG_ADDR(state, regno),&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],     \           DEPRECATED_REGISTER_RAW_SIZE (regno))
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"storing all registers"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I386_NUM_GREGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|deprecated_register_valid
index|[
name|i
index|]
condition|)
name|fill
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"storing register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|deprecated_register_valid
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|fill
argument_list|(
name|state
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the T bit.  */
operator|(
operator|(
expr|struct
name|i386_thread_state
operator|*
operator|)
name|state
operator|)
operator|->
name|efl
operator|&=
operator|~
literal|0x100
expr_stmt|;
operator|(
operator|(
expr|struct
name|i386_thread_state
operator|*
operator|)
name|state
operator|)
operator|->
name|efl
operator||=
name|trace
expr_stmt|;
block|}
undef|#
directive|undef
name|fill
if|if
condition|(
name|regno
operator|>=
name|I386_NUM_GREGS
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"storing floating-point registers"
argument_list|)
expr_stmt|;
name|store_fpregs
argument_list|(
name|thread
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

