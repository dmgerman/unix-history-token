begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for PowerPC systems running FreeBSD.     Copyright 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Wasabi Systems, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"regset.h"
end_include

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_include
include|#
directive|include
file|"ppcfbsd-tdep.h"
end_include

begin_include
include|#
directive|include
file|"trad-frame.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_define
define|#
directive|define
name|REG_FIXREG_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((x) * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_LR_OFFSET
value|(32 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_CR_OFFSET
value|(33 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_XER_OFFSET
value|(34 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_CTR_OFFSET
value|(35 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_PC_OFFSET
value|(36 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|SIZEOF_STRUCT_REG
value|(37 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|FPREG_FPR_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((x) * 8)
end_define

begin_define
define|#
directive|define
name|FPREG_FPSCR_OFFSET
value|(32 * 8)
end_define

begin_define
define|#
directive|define
name|SIZEOF_STRUCT_FPREG
value|(33 * 8)
end_define

begin_function
name|void
name|ppcfbsd_supply_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tdep
operator|->
name|ppc_gp0_regnum
init|;
name|i
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|REG_FIXREG_OFFSET
argument_list|(
name|i
operator|-
name|tdep
operator|->
name|ppc_gp0_regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_lr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|regs
operator|+
name|REG_LR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_cr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
name|regs
operator|+
name|REG_CR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_xer_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
name|regs
operator|+
name|REG_XER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ctr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
name|regs
operator|+
name|REG_CTR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|PC_REGNUM
argument_list|,
name|regs
operator|+
name|REG_PC_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppcfbsd_supply_gregset
parameter_list|(
specifier|const
name|struct
name|regset
modifier|*
name|regset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|gregs
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|ppcfbsd_supply_reg
argument_list|(
name|gregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|regset
name|ppcfbsd_gregset
init|=
block|{
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
name|ppcfbsd_supply_gregset
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ppcfbsd_fill_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tdep
operator|->
name|ppc_gp0_regnum
init|;
name|i
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|REG_FIXREG_OFFSET
argument_list|(
name|i
operator|-
name|tdep
operator|->
name|ppc_gp0_regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_lr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|regs
operator|+
name|REG_LR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_cr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
name|regs
operator|+
name|REG_CR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_xer_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
name|regs
operator|+
name|REG_XER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ctr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
name|regs
operator|+
name|REG_CTR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|PC_REGNUM
argument_list|,
name|regs
operator|+
name|REG_PC_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ppcfbsd_supply_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* FIXME: jimb/2004-05-05: Some PPC variants don't have floating      point registers.  Traditionally, GDB's register set has still      listed the floating point registers for such machines, so this      code is harmless.  However, the new E500 port actually omits the      floating point registers entirely from the register set --- they      don't even have register numbers assigned to them.       It's not clear to me how best to update this code, so this assert      will alert the first person to encounter the NetBSD/E500      combination to the problem.  */
name|gdb_assert
argument_list|(
name|ppc_floating_point_unit_p
argument_list|(
name|current_gdbarch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|FPLAST_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|fpregs
operator|+
name|FPREG_FPR_OFFSET
argument_list|(
name|i
operator|-
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_fpscr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|,
name|fpregs
operator|+
name|FPREG_FPSCR_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppcfbsd_supply_fpregset
parameter_list|(
specifier|const
name|struct
name|regset
modifier|*
name|regset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|fpset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|ppcfbsd_supply_fpreg
argument_list|(
name|fpset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|regset
name|ppcfbsd_fpregset
init|=
block|{
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
name|ppcfbsd_supply_fpregset
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ppcfbsd_fill_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* FIXME: jimb/2004-05-05: Some PPC variants don't have floating      point registers.  Traditionally, GDB's register set has still      listed the floating point registers for such machines, so this      code is harmless.  However, the new E500 port actually omits the      floating point registers entirely from the register set --- they      don't even have register numbers assigned to them.       It's not clear to me how best to update this code, so this assert      will alert the first person to encounter the NetBSD/E500      combination to the problem.  */
name|gdb_assert
argument_list|(
name|ppc_floating_point_unit_p
argument_list|(
name|current_gdbarch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|FPLAST_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|fpregs
operator|+
name|FPREG_FPR_OFFSET
argument_list|(
name|i
operator|-
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_fpscr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|,
name|fpregs
operator|+
name|FPREG_FPSCR_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the appropriate register set for the core section identified    by SECT_NAME and SECT_SIZE.  */
end_comment

begin_function
specifier|const
name|struct
name|regset
modifier|*
name|ppcfbsd_regset_from_core_section
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|size_t
name|sect_size
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|>=
name|SIZEOF_STRUCT_REG
condition|)
return|return
operator|&
name|ppcfbsd_gregset
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg2"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|>=
name|SIZEOF_STRUCT_FPREG
condition|)
return|return
operator|&
name|ppcfbsd_fpregset
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Macros for matching instructions.  Note that, since all the    operands are masked off before they're or-ed into the instruction,    you can use -1 to make masks.  */
end_comment

begin_define
define|#
directive|define
name|insn_d
parameter_list|(
name|opcd
parameter_list|,
name|rts
parameter_list|,
name|ra
parameter_list|,
name|d
parameter_list|)
define|\
value|((((opcd)& 0x3f)<< 26)                      \    | (((rts)& 0x1f)<< 21)                     \    | (((ra)& 0x1f)<< 16)                      \    | ((d)& 0xffff))
end_define

begin_define
define|#
directive|define
name|insn_ds
parameter_list|(
name|opcd
parameter_list|,
name|rts
parameter_list|,
name|ra
parameter_list|,
name|d
parameter_list|,
name|xo
parameter_list|)
define|\
value|((((opcd)& 0x3f)<< 26)                      \    | (((rts)& 0x1f)<< 21)                     \    | (((ra)& 0x1f)<< 16)                      \    | ((d)& 0xfffc)                             \    | ((xo)& 0x3))
end_define

begin_define
define|#
directive|define
name|insn_xfx
parameter_list|(
name|opcd
parameter_list|,
name|rts
parameter_list|,
name|spr
parameter_list|,
name|xo
parameter_list|)
define|\
value|((((opcd)& 0x3f)<< 26)                      \    | (((rts)& 0x1f)<< 21)                     \    | (((spr)& 0x1f)<< 16)                     \    | (((spr)& 0x3e0)<< 6)                     \    | (((xo)& 0x3ff)<< 1))
end_define

begin_comment
comment|/* Read a PPC instruction from memory.  PPC instructions are always    big-endian, no matter what endianness the program is running in, so    we can't use read_memory_integer or one of its friends here.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_insn
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|3
index|]
return|;
block|}
end_function

begin_comment
comment|/* An instruction to match.  */
end_comment

begin_struct
struct|struct
name|insn_pattern
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/* mask the insn with this... */
name|unsigned
name|int
name|data
decl_stmt|;
comment|/* ...and see if it matches this. */
name|int
name|optional
decl_stmt|;
comment|/* If non-zero, this insn may be absent.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Return non-zero if the instructions at PC match the series    described in PATTERN, or zero otherwise.  PATTERN is an array of    'struct insn_pattern' objects, terminated by an entry whose mask is    zero.     When the match is successful, fill INSN[i] with what PATTERN[i]    matched.  If PATTERN[i] is optional, and the instruction wasn't    present, set INSN[i] to 0 (which is not a valid PPC instruction).    INSN should have as many elements as PATTERN.  Note that, if    PATTERN contains optional instructions which aren't present in    memory, then INSN will have holes, so INSN[i] isn't necessarily the    i'th instruction in memory.  */
end_comment

begin_function
specifier|static
name|int
name|insns_match_pattern
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|insn_pattern
modifier|*
name|pattern
parameter_list|,
name|unsigned
name|int
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pattern
index|[
name|i
index|]
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|insn
index|[
name|i
index|]
operator|=
name|read_insn
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
index|[
name|i
index|]
operator|&
name|pattern
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|==
name|pattern
index|[
name|i
index|]
operator|.
name|data
condition|)
name|pc
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|pattern
index|[
name|i
index|]
operator|.
name|optional
condition|)
name|insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the 'd' field of the d-form instruction INSN, properly    sign-extended.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|insn_d_field
parameter_list|(
name|unsigned
name|int
name|insn
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|CORE_ADDR
operator|)
name|insn
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the 'ds' field of the ds-form instruction INSN, with the two    zero bits concatenated at the right, and properly    sign-extended.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|insn_ds_field
parameter_list|(
name|unsigned
name|int
name|insn
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|CORE_ADDR
operator|)
name|insn
operator|&
literal|0xfffc
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If DESC is the address of a 64-bit PowerPC FreeBSD function    descriptor, return the descriptor's entry point.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|ppc64_desc_entry_point
parameter_list|(
name|CORE_ADDR
name|desc
parameter_list|)
block|{
comment|/* The first word of the descriptor is the entry point.  */
return|return
operator|(
name|CORE_ADDR
operator|)
name|read_memory_unsigned_integer
argument_list|(
name|desc
argument_list|,
literal|8
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pattern for the standard linkage function.  These are built by    build_plt_stub in elf64-ppc.c, whose GLINK argument is always    zero.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|insn_pattern
name|ppc64_standard_linkage
index|[]
init|=
block|{
comment|/* addis r12, r2,<any> */
block|{
name|insn_d
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|insn_d
argument_list|(
literal|15
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* std r2, 40(r1) */
block|{
operator|-
literal|1
block|,
name|insn_ds
argument_list|(
literal|62
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* ld r11,<any>(r12) */
block|{
name|insn_ds
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
block|,
name|insn_ds
argument_list|(
literal|58
argument_list|,
literal|11
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* addis r12, r12, 1<optional> */
block|{
name|insn_d
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
block|,
name|insn_d
argument_list|(
literal|15
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
block|,
literal|1
block|}
block|,
comment|/* ld r2,<any>(r12) */
block|{
name|insn_ds
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
block|,
name|insn_ds
argument_list|(
literal|58
argument_list|,
literal|2
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* addis r12, r12, 1<optional> */
block|{
name|insn_d
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
block|,
name|insn_d
argument_list|(
literal|15
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
block|,
literal|1
block|}
block|,
comment|/* mtctr r11 */
block|{
name|insn_xfx
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
block|,
name|insn_xfx
argument_list|(
literal|31
argument_list|,
literal|11
argument_list|,
literal|9
argument_list|,
literal|467
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* ld r11,<any>(r12) */
block|{
name|insn_ds
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
block|,
name|insn_ds
argument_list|(
literal|58
argument_list|,
literal|11
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* bctr */
block|{
operator|-
literal|1
block|,
literal|0x4e800420
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PPC64_STANDARD_LINKAGE_LEN
define|\
value|(sizeof (ppc64_standard_linkage) / sizeof (ppc64_standard_linkage[0]))
end_define

begin_comment
comment|/* When the dynamic linker is doing lazy symbol resolution, the first    call to a function in another object will go like this:     - The user's function calls the linkage function:       100007c4:	4b ff fc d5 	bl	10000498      100007c8:	e8 41 00 28 	ld	r2,40(r1)     - The linkage function loads the entry point (and other stuff) from      the function descriptor in the PLT, and jumps to it:       10000498:	3d 82 00 00 	addis	r12,r2,0      1000049c:	f8 41 00 28 	std	r2,40(r1)      100004a0:	e9 6c 80 98 	ld	r11,-32616(r12)      100004a4:	e8 4c 80 a0 	ld	r2,-32608(r12)      100004a8:	7d 69 03 a6 	mtctr	r11      100004ac:	e9 6c 80 a8 	ld	r11,-32600(r12)      100004b0:	4e 80 04 20 	bctr     - But since this is the first time that PLT entry has been used, it      sends control to its glink entry.  That loads the number of the      PLT entry and jumps to the common glink0 code:       10000c98:	38 00 00 00 	li	r0,0      10000c9c:	4b ff ff dc 	b	10000c78     - The common glink0 code then transfers control to the dynamic      linker's fixup code:       10000c78:	e8 41 00 28 	ld	r2,40(r1)      10000c7c:	3d 82 00 00 	addis	r12,r2,0      10000c80:	e9 6c 80 80 	ld	r11,-32640(r12)      10000c84:	e8 4c 80 88 	ld	r2,-32632(r12)      10000c88:	7d 69 03 a6 	mtctr	r11      10000c8c:	e9 6c 80 90 	ld	r11,-32624(r12)      10000c90:	4e 80 04 20 	bctr     Eventually, this code will figure out how to skip all of this,    including the dynamic linker.  At the moment, we just get through    the linkage function.  */
end_comment

begin_comment
comment|/* If the current thread is about to execute a series of instructions    at PC matching the ppc64_standard_linkage pattern, and INSN is the result    from that pattern match, return the code address to which the    standard linkage function will send them.  (This doesn't deal with    dynamic linker lazy symbol resolution stubs.)  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|ppc64_standard_linkage_target
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|unsigned
name|int
modifier|*
name|insn
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* The address of the function descriptor this linkage function      references.  */
name|CORE_ADDR
name|desc
init|=
operator|(
operator|(
name|CORE_ADDR
operator|)
name|read_register
argument_list|(
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|2
argument_list|)
operator|+
operator|(
name|insn_d_field
argument_list|(
name|insn
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator|+
name|insn_ds_field
argument_list|(
name|insn
index|[
literal|2
index|]
argument_list|)
operator|)
decl_stmt|;
comment|/* The first word of the descriptor is the entry point.  Return that.  */
return|return
name|ppc64_desc_entry_point
argument_list|(
name|desc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given that we've begun executing a call trampoline at PC, return    the entry point of the function the trampoline will go to.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|ppc64_skip_trampoline_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|int
name|ppc64_standard_linkage_insn
index|[
name|PPC64_STANDARD_LINKAGE_LEN
index|]
decl_stmt|;
if|if
condition|(
name|insns_match_pattern
argument_list|(
name|pc
argument_list|,
name|ppc64_standard_linkage
argument_list|,
name|ppc64_standard_linkage_insn
argument_list|)
condition|)
return|return
name|ppc64_standard_linkage_target
argument_list|(
name|pc
argument_list|,
name|ppc64_standard_linkage_insn
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG) on PPC64    GNU/Linux and FreeBSD.     Usually a function pointer's representation is simply the address    of the function. On GNU/Linux on the 64-bit PowerPC however, a    function pointer is represented by a pointer to a TOC entry. This    TOC entry contains three words, the first word is the address of    the function, the second word is the TOC pointer (r2), and the    third word is the static chain value.  Throughout GDB it is    currently assumed that a function pointer contains the address of    the function, which is not easy to fix.  In addition, the    conversion of a function address to a function pointer would    require allocation of a TOC entry in the inferior's memory space,    with all its drawbacks.  To be able to call C++ virtual methods in    the inferior (which are called via function pointers),    find_function_addr uses this function to get the function address    from a function pointer.  */
end_comment

begin_comment
comment|/* If ADDR points at what is clearly a function descriptor, transform    it into the address of the corresponding function.  Be    conservative, otherwize GDB will do the transformation on any    random addresses such as occures when there is no symbol table.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|ppc64_fbsd_convert_from_func_ptr_addr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|target_ops
modifier|*
name|targ
parameter_list|)
block|{
name|struct
name|section_table
modifier|*
name|s
init|=
name|target_section_by_addr
argument_list|(
name|targ
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* Check if ADDR points to a function descriptor.  */
if|if
condition|(
name|s
operator|&&
name|strcmp
argument_list|(
name|s
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|get_target_memory_unsigned
argument_list|(
name|targ
argument_list|,
name|addr
argument_list|,
literal|8
argument_list|)
return|;
return|return
name|addr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppcfbsd_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|func_name
parameter_list|)
block|{
return|return
operator|(
name|pc
operator|>=
literal|0x7fffef00U
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NetBSD is confused.  It appears that 1.5 was using the correct SVr4    convention but, 1.6 switched to the below broken convention.  For    the moment use the broken convention.  Ulgh!.  */
end_comment

begin_function
specifier|static
name|enum
name|return_value_convention
name|ppcfbsd_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
operator|!
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|16
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|8
operator|)
operator|)
operator|&&
operator|!
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|1
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|2
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|4
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|8
operator|)
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
else|else
return|return
name|ppc_sysv_abi_broken_return_value
argument_list|(
name|gdbarch
argument_list|,
name|valtype
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppcfbsd_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* FreeBSD doesn't support the 128-bit `long double' from the psABI. */
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|ppcfbsd_pc_in_sigtramp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|wordsize
operator|==
literal|4
condition|)
block|{
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ppcfbsd_return_value
argument_list|)
expr_stmt|;
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|svr4_ilp32_fetch_link_map_offsets
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tdep
operator|->
name|wordsize
operator|==
literal|8
condition|)
block|{
name|set_gdbarch_convert_from_func_ptr_addr
argument_list|(
name|gdbarch
argument_list|,
name|ppc64_fbsd_convert_from_func_ptr_addr
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_trampoline_code
argument_list|(
name|gdbarch
argument_list|,
name|ppc64_skip_trampoline_code
argument_list|)
expr_stmt|;
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|svr4_lp64_fetch_link_map_offsets
argument_list|)
expr_stmt|;
block|}
name|set_gdbarch_regset_from_core_section
argument_list|(
name|gdbarch
argument_list|,
name|ppcfbsd_regset_from_core_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_ppcfbsd_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_powerpc
argument_list|,
name|bfd_mach_ppc
argument_list|,
name|GDB_OSABI_FREEBSD_ELF
argument_list|,
name|ppcfbsd_init_abi
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_powerpc
argument_list|,
name|bfd_mach_ppc64
argument_list|,
name|GDB_OSABI_FREEBSD_ELF
argument_list|,
name|ppcfbsd_init_abi
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_rs6000
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_FREEBSD_ELF
argument_list|,
name|ppcfbsd_init_abi
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

