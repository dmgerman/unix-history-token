begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C and C++ types for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1998,    1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Flag indicating target was compiled by HP compiler */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cp_type_print_method_args
parameter_list|(
name|struct
name|type
modifier|*
name|mtype
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|varstring
parameter_list|,
name|int
name|staticp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_type_print_args
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_type_print_derivation_info
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_type_print_varspec_prefix
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print "const", "volatile", or address space modifiers. */
end_comment

begin_function_decl
specifier|static
name|void
name|c_type_print_modifier
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* LEVEL is the depth to indent lines by.  */
end_comment

begin_function
name|void
name|c_print_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|varstring
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
name|int
name|need_post_space
decl_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|c_type_print_base
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varstring
operator|!=
name|NULL
operator|&&
operator|*
name|varstring
operator|!=
literal|'\0'
operator|)
operator|||
comment|/* Need a space if going to print stars or brackets;      but not if we will print just a type name.  */
operator|(
operator|(
name|show
operator|>
literal|0
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|code
operator|==
name|TYPE_CODE_MEMBER
operator|||
name|code
operator|==
name|TYPE_CODE_REF
operator|)
operator|)
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_post_space
operator|=
operator|(
name|varstring
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|varstring
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
name|need_post_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|varstring
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* For demangled function names, we have the arglist as part of the name,          so don't print an additional pair of ()'s */
name|demangled_args
operator|=
name|strchr
argument_list|(
name|varstring
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
name|demangled_args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If TYPE is a derived type, then print out derivation information.    Print only the actual base classes of this type, not the base classes    of the base classes.  I.E.  for the derivation hierarchy:     class A { int a; };    class B : public A {int b; };    class C : public B {int c; };     Print the type of class C as:     class C : public B {    int c;    }     Not as the following (like gdb used to), which is not legal C++ syntax for    derived types and may be confused with the multiple inheritance form:     class C : public B : public A {    int c;    }     In general, gdb should try to print the types as closely as possible to    the form that they appear in the source code.     Note that in case of protected derivation gcc will not say 'protected'     but 'private'. The HP's aCC compiler emits specific information for     derivation via protected inheritance, so gdb can print it out */
end_comment

begin_function
specifier|static
name|void
name|cp_type_print_derivation_info
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fputs_filtered
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|": "
else|:
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s "
argument_list|,
name|BASETYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|"public"
else|:
operator|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|"protected"
else|:
literal|"private"
operator|)
argument_list|,
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|" virtual"
else|:
literal|""
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the C++ method arguments ARGS to the file STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|cp_type_print_method_args
parameter_list|(
name|struct
name|type
modifier|*
name|mtype
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|varstring
parameter_list|,
name|int
name|staticp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|args
init|=
name|TYPE_FIELDS
argument_list|(
name|mtype
argument_list|)
decl_stmt|;
name|int
name|nargs
init|=
name|TYPE_NFIELDS
argument_list|(
name|mtype
argument_list|)
decl_stmt|;
name|int
name|varargs
init|=
name|TYPE_VARARGS
argument_list|(
name|mtype
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|varstring
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Skip the class variable.  */
name|i
operator|=
name|staticp
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|i
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
name|type_print
argument_list|(
name|args
index|[
name|i
operator|++
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nargs
operator|&&
name|varargs
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", ..."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|varargs
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print any asterisks or open-parentheses needed before the    variable name (to describe its type).     On outermost call, pass 0 for PASSED_A_PTR.    On outermost call, SHOW> 0 means should ignore    any typename for TYPE and show its details.    SHOW is always zero on recursive calls.        NEED_POST_SPACE is non-zero when a space will be be needed    between a trailing qualifier and a field, variable, or function    name.  */
end_comment

begin_function
name|void
name|c_type_print_varspec_prefix
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|passed_a_ptr
parameter_list|,
name|int
name|need_post_space
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|,
name|need_post_space
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|c_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|c_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|,
name|need_post_space
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_TYPEDEF
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
case|case
name|TYPE_CODE_TEMPLATE
case|:
case|case
name|TYPE_CODE_NAMESPACE
case|:
comment|/* These types need no prefix.  They are listed here so that          gcc -Wall will reveal any types that haven't been handled.  */
break|break;
default|default:
name|error
argument_list|(
literal|"type not handled in c_type_print_varspec_prefix()"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out "const" and "volatile" attributes.    TYPE is a pointer to the type being printed out.    STREAM is the output destination.    NEED_SPACE = 1 indicates an initial white space is needed */
end_comment

begin_function
specifier|static
name|void
name|c_type_print_modifier
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|need_pre_space
parameter_list|,
name|int
name|need_post_space
parameter_list|)
block|{
name|int
name|did_print_modifier
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|address_space_id
decl_stmt|;
comment|/* We don't print `const' qualifiers for references --- since all      operators affect the thing referenced, not the reference itself,      every reference is `const'.  */
if|if
condition|(
name|TYPE_CONST
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_REF
condition|)
block|{
if|if
condition|(
name|need_pre_space
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
name|did_print_modifier
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|did_print_modifier
operator|||
name|need_pre_space
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
name|did_print_modifier
operator|=
literal|1
expr_stmt|;
block|}
name|address_space_id
operator|=
name|address_space_int_to_name
argument_list|(
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_space_id
condition|)
block|{
if|if
condition|(
name|did_print_modifier
operator|||
name|need_pre_space
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@%s"
argument_list|,
name|address_space_id
argument_list|)
expr_stmt|;
name|did_print_modifier
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|did_print_modifier
operator|&&
name|need_post_space
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|c_type_print_args
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|field
modifier|*
name|args
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|args
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* FIXME drow/2002-05-31: Always skips the first argument, 	 should we be checking for static members?  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|c_print_type
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_VARARGS
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true iff the j'th overloading of the i'th method of TYPE    is a type conversion operator, like `operator int () { ... }'.    When listing a class's methods, we don't print the return type of    such operators.  */
end_comment

begin_function
specifier|static
name|int
name|is_type_conversion_operator
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
comment|/* I think the whole idea of recognizing type conversion operators      by their name is pretty terrible.  But I don't think our present      data structure gives us any other way to tell.  If you know of      some other way, feel free to rewrite this function.  */
name|char
modifier|*
name|name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|name
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|" \t\f\n\r"
argument_list|,
operator|*
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|strchr
argument_list|(
literal|" \t\f\n\r"
argument_list|,
operator|*
name|name
argument_list|)
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|'a'
operator|<=
operator|*
name|name
operator|&&
operator|*
name|name
operator|<=
literal|'z'
operator|)
operator|&&
operator|!
operator|(
literal|'A'
operator|<=
operator|*
name|name
operator|&&
operator|*
name|name
operator|<=
literal|'Z'
operator|)
operator|&&
operator|*
name|name
operator|!=
literal|'_'
condition|)
comment|/* If this doesn't look like the start of an identifier, then it        isn't a type conversion operator.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"new"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"delete"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
literal|6
expr_stmt|;
else|else
comment|/* If it doesn't look like new or delete, it's a type conversion        operator.  */
return|return
literal|1
return|;
comment|/* Is that really the end of the name?  */
if|if
condition|(
operator|(
literal|'a'
operator|<=
operator|*
name|name
operator|&&
operator|*
name|name
operator|<=
literal|'z'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
operator|*
name|name
operator|&&
operator|*
name|name
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
literal|'0'
operator|<=
operator|*
name|name
operator|&&
operator|*
name|name
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|name
operator|==
literal|'_'
condition|)
comment|/* No, so the identifier following "operator" must be a type name,        and this is a type conversion operator.  */
return|return
literal|1
return|;
comment|/* That was indeed the end of the name, so it was `operator new' or      `operator delete', neither of which are type conversion operators.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a C++ qualified identifier QID, strip off the qualifiers,    yielding the unqualified name.  The return value is a pointer into    the original string.     It's a pity we don't have this information in some more structured    form.  Even the author of this function feels that writing little    parsers like this everywhere is stupid.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remove_qualifiers
parameter_list|(
name|char
modifier|*
name|qid
parameter_list|)
block|{
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* zero if we're not in quotes; 				   '"' if we're in a double-quoted string; 				   '\'' if we're in a single-quoted string.  */
name|int
name|depth
init|=
literal|0
decl_stmt|;
comment|/* number of unclosed parens we've seen */
name|char
modifier|*
name|parenstack
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|qid
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|last
init|=
literal|0
decl_stmt|;
comment|/* The character after the rightmost 				   `::' token we've seen so far.  */
for|for
control|(
name|scan
operator|=
name|qid
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
name|quoted
condition|)
name|quoted
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scan
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|scan
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* If we're inside parenthesis (i.e., an argument list) or 	     angle brackets (i.e., a list of template arguments), then 	     we don't record the position of this :: token, since it's 	     not relevant to the top-level structure we're trying 	     to operate on.  */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'"'
operator|||
operator|*
name|scan
operator|==
literal|'\''
condition|)
name|quoted
operator|=
operator|*
name|scan
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'('
condition|)
name|parenstack
index|[
name|depth
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'['
condition|)
name|parenstack
index|[
name|depth
operator|++
index|]
operator|=
literal|']'
expr_stmt|;
comment|/* We're going to treat<> as a pair of matching characters, 	 since we're more likely to see those in template id's than 	 real less-than characters.  What a crock.  */
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'<'
condition|)
name|parenstack
index|[
name|depth
operator|++
index|]
operator|=
literal|'>'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|')'
operator|||
operator|*
name|scan
operator|==
literal|']'
operator|||
operator|*
name|scan
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|parenstack
index|[
name|depth
operator|-
literal|1
index|]
operator|==
operator|*
name|scan
condition|)
name|depth
operator|--
expr_stmt|;
else|else
block|{
comment|/* We're going to do a little error recovery here.  If we 		 don't find a match for *scan on the paren stack, but 		 there is something lower on the stack that does match, we 		 pop the stack to that point.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|depth
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|parenstack
index|[
name|i
index|]
operator|==
operator|*
name|scan
condition|)
block|{
name|depth
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|last
condition|)
return|return
name|last
return|;
else|else
comment|/* We didn't find any :: tokens at the top level, so declare the        whole thing an unqualified identifier.  */
return|return
name|qid
return|;
block|}
end_function

begin_comment
comment|/* Print any array sizes, function arguments or close parentheses    needed after the variable name (to describe its type).    Args work like c_type_print_varspec_prefix.  */
end_comment

begin_function
name|void
name|c_type_print_varspec_suffix
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|passed_a_ptr
parameter_list|,
name|int
name|demangled_args
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOUND_CANNOT_BE_DETERMINED
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|c_type_print_args
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|demangled_args
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|(
name|TYPE_PROTOTYPED
argument_list|(
name|type
argument_list|)
operator|||
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
name|c_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|passed_a_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_TYPEDEF
case|:
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|passed_a_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
case|case
name|TYPE_CODE_TEMPLATE
case|:
case|case
name|TYPE_CODE_NAMESPACE
case|:
comment|/* These types do not need a suffix.  They are listed so that          gcc -Wall will report types that may not have been considered.  */
break|break;
default|default:
name|error
argument_list|(
literal|"type not handled in c_type_print_varspec_suffix()"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print the name of the type (or the ultimate pointer target,    function value or array element), or the description of a    structure or union.     SHOW positive means print details about the type (e.g. enum values),    and print structure elements passing SHOW - 1 for show.    SHOW negative means just print the type name or struct tag if there is one.    If there is no name, print something sensible but concise like    "struct {...}".    SHOW zero means just print the type name or struct tag if there is one.    If there is no name, print something sensible but not as concise like    "struct {int x; int y;}".     LEVEL is the number of spaces to indent by.    We increase it for some recursive calls.  */
end_comment

begin_function
name|void
name|c_type_print_base
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|,
name|real_len
decl_stmt|;
name|int
name|lastval
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|char
modifier|*
name|demangled_no_static
decl_stmt|;
enum|enum
block|{
name|s_none
block|,
name|s_public
block|,
name|s_private
block|,
name|s_protected
block|}
name|section_type
enum|;
name|int
name|need_access_label
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
decl_stmt|;
name|QUIT
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<type unknown>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* When SHOW is zero or less, and there is a valid type name, then always      just print the type name directly from the type.  */
comment|/* If we have "typedef struct foo {. . .} bar;" do we want to print it      as "struct foo" or as "bar"?  Pick the latter, because C++ folk tend      to expect things like "class5 *foo" rather than "struct class5 *foo".  */
if|if
condition|(
name|show
operator|<=
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_METHOD
case|:
name|c_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Note TYPE_CODE_STRUCT and TYPE_CODE_CLASS have the same value,        * so we use another means for distinguishing them.        */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|DECLARED_TYPE_CLASS
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECLARED_TYPE_UNION
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECLARED_TYPE_STRUCT
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* If there is a CPLUS_STRUCT, assume class if not 	       * otherwise specified in the declared_type field. 	       */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
else|else
block|{
comment|/* If not CPLUS_STRUCT, then assume it's a C struct */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
block|}
goto|goto
name|struct_union
goto|;
case|case
name|TYPE_CODE_UNION
case|:
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|struct_union
label|:
comment|/* Print the tag if it exists.         * The HP aCC compiler emits        * a spurious "{unnamed struct}"/"{unnamed union}"/"{unnamed enum}"        * tag  for unnamed struct/union/enum's, which we don't        * want to print.        */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"{unnamed"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|cp_type_print_derivation_info
argument_list|(
name|stream
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|type
argument_list|)
condition|)
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<incomplete type>\n"
argument_list|)
expr_stmt|;
else|else
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<no data fields>\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Start off with no specific section type, so we can print 	     one for the first field we find, and use that section type 	     thereafter until we find another type. */
name|section_type
operator|=
name|s_none
expr_stmt|;
comment|/* For a class, if all members are private, there's no need 	     for a "private:" label; similarly, for a struct or union 	     masquerading as a class, if all members are public, there's 	     no need for a "public:" label. */
if|if
condition|(
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_CLASS
operator|)
operator|||
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_TEMPLATE
operator|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|need_access_label
condition|)
block|{
name|len2
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|len
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|need_access_label
condition|)
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_UNION
operator|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|||
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|need_access_label
condition|)
block|{
name|len2
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|len
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
argument_list|,
name|i
argument_list|)
operator|||
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|need_access_label
condition|)
break|break;
block|}
block|}
block|}
comment|/* If there is a base class for this type, 	     do not print the field that it occupies.  */
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't print out virtual function table.  */
comment|/* HP ANSI C++ case */
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"__vfp"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* Other compilers */
if|if
condition|(
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|is_cplus_marker
argument_list|(
operator|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|)
index|[
literal|5
index|]
argument_list|)
condition|)
continue|continue;
comment|/* If this is a C++ class we can print the various C++ section 	         labels. */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
operator|&&
name|need_access_label
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
block|}
name|c_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* It is a bitfield.  This code does not attempt 		     to look at the bitpos and reconstruct filler, 		     unnamed fields.  This would lead to misleading 		     results if the compiler does not put out fields 		     for such things (I don't know what it does).  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : %d"
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If there are both fields and methods, put a blank line 	      between them.  Make sure to count only method that we will 	      display; artificial methods will be hidden.  */
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|real_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TYPE_FN_FIELD_ARTIFICIAL
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|real_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|real_len
operator|>
literal|0
operator|&&
name|section_type
operator|!=
name|s_none
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* C++: print out the methods */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_constructor
init|=
name|name
operator|&&
name|strcmp
argument_list|(
name|method_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|int
name|is_full_physname_constructor
init|=
name|is_constructor_name
argument_list|(
name|physname
argument_list|)
operator|||
name|is_destructor_name
argument_list|(
name|physname
argument_list|)
operator|||
name|method_name
index|[
literal|0
index|]
operator|==
literal|'~'
decl_stmt|;
comment|/* Do not print out artificial methods.  */
if|if
condition|(
name|TYPE_FN_FIELD_ARTIFICIAL
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"virtual "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Keep GDB from crashing here.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<undefined type> %s;\n"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_constructor
operator|&&
comment|/* constructors don't have declared types */
operator|!
name|is_full_physname_constructor
operator|&&
comment|/*    " "  */
operator|!
name|is_type_conversion_operator
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|type_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
comment|/* Build something we can demangle.  */
name|mangled_name
operator|=
name|gdb_mangle_name
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|mangled_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
block|{
comment|/* in some cases (for instance with the HP demangling), 		         if a function has more than 10 arguments,  		         the demangling will fail. 		         Let's try to reconstruct the function signature from  		         the symbol information */
if|if
condition|(
operator|!
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|int
name|staticp
init|=
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|mtype
init|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|cp_type_print_method_args
argument_list|(
name|mtype
argument_list|,
literal|""
argument_list|,
name|method_name
argument_list|,
name|staticp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<badly mangled name '%s'>"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|demangled_no_class
init|=
name|remove_qualifiers
argument_list|(
name|demangled_name
argument_list|)
decl_stmt|;
comment|/* get rid of the `static' appended by the demangler */
name|p
operator|=
name|strstr
argument_list|(
name|demangled_no_class
argument_list|,
literal|" static"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|int
name|length
init|=
name|p
operator|-
name|demangled_no_class
decl_stmt|;
name|demangled_no_static
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|demangled_no_static
argument_list|,
name|demangled_no_class
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
operator|(
name|demangled_no_static
operator|+
name|length
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|fputs_filtered
argument_list|(
name|demangled_no_static
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|demangled_no_static
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
name|demangled_no_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|xfree
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LOCALTYPE_PTR
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|>=
literal|0
condition|)
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|" (Local at %s:%d)\n"
argument_list|,
name|TYPE_LOCALTYPE_FILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_LOCALTYPE_LINE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TEMPLATE
condition|)
goto|goto
name|go_back
goto|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* HP C supports sized enums */
if|if
condition|(
name|hp_som_som_object_present
condition|)
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|fputs_filtered
argument_list|(
literal|"char "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fputs_filtered
argument_list|(
literal|"short "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
comment|/* Print the tag name if it exists.          The aCC compiler emits a spurious           "{unnamed struct}"/"{unnamed union}"/"{unnamed enum}"          tag for unnamed struct/union/enum's, which we don't          want to print. */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"{unnamed"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" = %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|++
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct<unknown>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* This should not occur */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<range type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_TEMPLATE
case|:
comment|/* Called on "ptype t" where "t" is a template.          Prints the template header (with args), e.g.:          template<class T1, class T2> class "          and then merges with the struct/union/class code to          print the rest of the definition. */
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"template<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NTEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|template_arg
name|templ_arg
decl_stmt|;
name|templ_arg
operator|=
name|TYPE_TEMPLATE_ARG
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class %s"
argument_list|,
name|templ_arg
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|TYPE_NTEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"> class "
argument_list|)
expr_stmt|;
comment|/* Yuck, factor this out to a subroutine so we can call          it and return to the point marked with the "goback:" label... - RT */
goto|goto
name|struct_union
goto|;
name|go_back
label|:
if|if
condition|(
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\ntemplate instantiations:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|c_type_print_base
argument_list|(
name|TYPE_INSTANTIATION
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_NAMESPACE
case|:
name|fputs_filtered
argument_list|(
literal|"namespace "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Handle types not explicitly handled by the other cases,          such as fundamental types.  For these, just print whatever          the type name is, as recorded in the type itself.  If there          is no type name, then complain. */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|c_type_print_modifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* At least for dump_symtab, it is important that this not be 	     an error ().  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid type code %d>"
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

end_unit

