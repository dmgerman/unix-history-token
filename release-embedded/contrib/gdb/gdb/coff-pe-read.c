begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read the export table symbols from a portable executable and    convert to internal format, for GDB. Used as a last resort if no    debugging symbols recognized.     Copyright 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.     Contributed by Raoul M. Gough (RaoulGough@yahoo.co.uk). */
end_comment

begin_include
include|#
directive|include
file|"coff-pe-read.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* Internal section information */
end_comment

begin_struct
struct|struct
name|read_pe_section_data
block|{
name|CORE_ADDR
name|vma_offset
decl_stmt|;
comment|/* Offset to loaded address of section. */
name|unsigned
name|long
name|rva_start
decl_stmt|;
comment|/* Start offset within the pe. */
name|unsigned
name|long
name|rva_end
decl_stmt|;
comment|/* End offset within the pe. */
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
comment|/* Type to assign symbols in section. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PE_SECTION_INDEX_TEXT
value|0
end_define

begin_define
define|#
directive|define
name|PE_SECTION_INDEX_DATA
value|1
end_define

begin_define
define|#
directive|define
name|PE_SECTION_INDEX_BSS
value|2
end_define

begin_define
define|#
directive|define
name|PE_SECTION_TABLE_SIZE
value|3
end_define

begin_define
define|#
directive|define
name|PE_SECTION_INDEX_INVALID
value|-1
end_define

begin_escape
end_escape

begin_comment
comment|/* Get the index of the named section in our own array, which contains    text, data and bss in that order. Return PE_SECTION_INDEX_INVALID    if passed an unrecognised section name. */
end_comment

begin_function
specifier|static
name|int
name|read_pe_section_index
parameter_list|(
specifier|const
name|char
modifier|*
name|section_name
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|section_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|PE_SECTION_INDEX_TEXT
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|PE_SECTION_INDEX_DATA
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section_name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|PE_SECTION_INDEX_BSS
return|;
block|}
else|else
block|{
return|return
name|PE_SECTION_INDEX_INVALID
return|;
block|}
block|}
end_function

begin_comment
comment|/* Record the virtual memory address of a section. */
end_comment

begin_function
specifier|static
name|void
name|get_section_vmas
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sectp
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|read_pe_section_data
modifier|*
name|sections
init|=
name|context
decl_stmt|;
name|int
name|sectix
init|=
name|read_pe_section_index
argument_list|(
name|sectp
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sectix
operator|!=
name|PE_SECTION_INDEX_INVALID
condition|)
block|{
comment|/* Data within the section start at rva_start in the pe and at          bfd_get_section_vma() within memory. Store the offset. */
name|sections
index|[
name|sectix
index|]
operator|.
name|vma_offset
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sectp
argument_list|)
operator|-
name|sections
index|[
name|sectix
index|]
operator|.
name|rva_start
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a minimal symbol entry for an exported symbol. */
end_comment

begin_function
specifier|static
name|void
name|add_pe_exported_sym
parameter_list|(
name|char
modifier|*
name|sym_name
parameter_list|,
name|unsigned
name|long
name|func_rva
parameter_list|,
specifier|const
name|struct
name|read_pe_section_data
modifier|*
name|section_data
parameter_list|,
specifier|const
name|char
modifier|*
name|dll_name
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* Add the stored offset to get the loaded address of the symbol. */
name|CORE_ADDR
name|vma
init|=
name|func_rva
operator|+
name|section_data
operator|->
name|vma_offset
decl_stmt|;
name|char
modifier|*
name|qualified_name
init|=
literal|0
decl_stmt|;
name|int
name|dll_name_len
init|=
name|strlen
argument_list|(
name|dll_name
argument_list|)
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* Generate a (hopefully unique) qualified name using the first part      of the dll name, e.g. KERNEL32!AddAtomA. This matches the style      used by windbg from the "Microsoft Debugging Tools for Windows". */
name|qualified_name
operator|=
name|xmalloc
argument_list|(
name|dll_name_len
operator|+
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|qualified_name
argument_list|,
name|dll_name
argument_list|,
name|dll_name_len
argument_list|)
expr_stmt|;
name|qualified_name
index|[
name|dll_name_len
index|]
operator|=
literal|'!'
expr_stmt|;
name|strcpy
argument_list|(
name|qualified_name
operator|+
name|dll_name_len
operator|+
literal|1
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|qualified_name
argument_list|,
name|vma
argument_list|,
name|section_data
operator|->
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|qualified_name
argument_list|)
expr_stmt|;
comment|/* Enter the plain name as well, which might not be unique. */
name|prim_record_minimal_symbol
argument_list|(
name|sym_name
argument_list|,
name|vma
argument_list|,
name|section_data
operator|->
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Truncate a dll_name at the first dot character. */
end_comment

begin_function
specifier|static
name|void
name|read_pe_truncate_name
parameter_list|(
name|char
modifier|*
name|dll_name
parameter_list|)
block|{
while|while
condition|(
operator|*
name|dll_name
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|dll_name
operator|)
operator|==
literal|'.'
condition|)
block|{
operator|*
name|dll_name
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncates and causes loop exit. */
block|}
else|else
block|{
operator|++
name|dll_name
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Low-level support functions, direct from the ld module pe-dll.c. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|pe_get16
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|where
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|pe_get32
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|where
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|pe_as32
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|b
init|=
name|ptr
decl_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the (non-debug) export symbol table from a portable    executable. Code originally lifted from the ld function    pe_implied_import_dll in pe-dll.c. */
end_comment

begin_function
name|void
name|read_pe_exported_syms
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|bfd
modifier|*
name|dll
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|unsigned
name|long
name|pe_header_offset
decl_stmt|,
name|opthdr_ofs
decl_stmt|,
name|num_entries
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|export_rva
decl_stmt|,
name|export_size
decl_stmt|,
name|nsections
decl_stmt|,
name|secptr
decl_stmt|,
name|expptr
decl_stmt|;
name|unsigned
name|long
name|exp_funcbase
decl_stmt|;
name|unsigned
name|char
modifier|*
name|expdata
decl_stmt|,
modifier|*
name|erva
decl_stmt|;
name|unsigned
name|long
name|name_rvas
decl_stmt|,
name|ordinals
decl_stmt|,
name|nexp
decl_stmt|,
name|ordbase
decl_stmt|;
name|char
modifier|*
name|dll_name
decl_stmt|;
comment|/* Array elements are for text, data and bss in that order      Initialization with start_rva> end_rva guarantees that      unused sections won't be matched. */
name|struct
name|read_pe_section_data
name|section_data
index|[
name|PE_SECTION_TABLE_SIZE
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|mst_text
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|mst_data
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|mst_bss
block|}
block|}
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|target
init|=
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|target
argument_list|,
literal|"pe-i386"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|target
argument_list|,
literal|"pei-i386"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* This is not an i386 format file. Abort now, because the code          is untested on anything else. *FIXME* test on further          architectures and loosen or remove this test. */
return|return;
block|}
comment|/* Get pe_header, optional header and numbers of export entries.  */
name|pe_header_offset
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|opthdr_ofs
operator|=
name|pe_header_offset
operator|+
literal|4
operator|+
literal|20
expr_stmt|;
name|num_entries
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|92
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_entries
operator|<
literal|1
condition|)
comment|/* No exports.  */
block|{
return|return;
block|}
name|export_rva
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|96
argument_list|)
expr_stmt|;
name|export_size
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|100
argument_list|)
expr_stmt|;
name|nsections
operator|=
name|pe_get16
argument_list|(
name|dll
argument_list|,
name|pe_header_offset
operator|+
literal|4
operator|+
literal|2
argument_list|)
expr_stmt|;
name|secptr
operator|=
operator|(
name|pe_header_offset
operator|+
literal|4
operator|+
literal|20
operator|+
name|pe_get16
argument_list|(
name|dll
argument_list|,
name|pe_header_offset
operator|+
literal|4
operator|+
literal|16
argument_list|)
operator|)
expr_stmt|;
name|expptr
operator|=
literal|0
expr_stmt|;
comment|/* Get the rva and size of the export section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsections
condition|;
name|i
operator|++
control|)
block|{
name|char
name|sname
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|secptr1
init|=
name|secptr
operator|+
literal|40
operator|*
name|i
decl_stmt|;
name|unsigned
name|long
name|vaddr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|12
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|vsize
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|16
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|fptr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|20
argument_list|)
decl_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
operator|(
name|file_ptr
operator|)
name|secptr1
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|sname
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|dll
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaddr
operator|<=
name|export_rva
operator|&&
name|vaddr
operator|+
name|vsize
operator|>
name|export_rva
condition|)
block|{
name|expptr
operator|=
name|fptr
operator|+
operator|(
name|export_rva
operator|-
name|vaddr
operator|)
expr_stmt|;
if|if
condition|(
name|export_rva
operator|+
name|export_size
operator|>
name|vaddr
operator|+
name|vsize
condition|)
name|export_size
operator|=
name|vsize
operator|-
operator|(
name|export_rva
operator|-
name|vaddr
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|export_size
operator|==
literal|0
condition|)
block|{
comment|/* Empty export table. */
return|return;
block|}
comment|/* Scan sections and store the base and size of the relevant sections. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsections
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|secptr1
init|=
name|secptr
operator|+
literal|40
operator|*
name|i
decl_stmt|;
name|unsigned
name|long
name|vsize
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|8
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|vaddr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|12
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|flags
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|36
argument_list|)
decl_stmt|;
name|char
name|sec_name
index|[
literal|9
index|]
decl_stmt|;
name|int
name|sectix
decl_stmt|;
name|sec_name
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
operator|(
name|file_ptr
operator|)
name|secptr1
operator|+
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|sec_name
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|dll
argument_list|)
expr_stmt|;
name|sectix
operator|=
name|read_pe_section_index
argument_list|(
name|sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectix
operator|!=
name|PE_SECTION_INDEX_INVALID
condition|)
block|{
name|section_data
index|[
name|sectix
index|]
operator|.
name|rva_start
operator|=
name|vaddr
expr_stmt|;
name|section_data
index|[
name|sectix
index|]
operator|.
name|rva_end
operator|=
name|vaddr
operator|+
name|vsize
expr_stmt|;
block|}
block|}
name|expdata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|export_size
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|expdata
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
operator|(
name|file_ptr
operator|)
name|expptr
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|expdata
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|export_size
argument_list|,
name|dll
argument_list|)
expr_stmt|;
name|erva
operator|=
name|expdata
operator|-
name|export_rva
expr_stmt|;
name|nexp
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|24
argument_list|)
expr_stmt|;
name|name_rvas
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|32
argument_list|)
expr_stmt|;
name|ordinals
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|36
argument_list|)
expr_stmt|;
name|ordbase
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|16
argument_list|)
expr_stmt|;
name|exp_funcbase
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|28
argument_list|)
expr_stmt|;
comment|/* Use internal dll name instead of full pathname. */
name|dll_name
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|12
argument_list|)
operator|+
name|erva
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|dll
argument_list|,
name|get_section_vmas
argument_list|,
name|section_data
argument_list|)
expr_stmt|;
comment|/* Adjust the vma_offsets in case this PE got relocated. This      assumes that *all* sections share the same relocation offset      as the text section. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PE_SECTION_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|section_data
index|[
name|i
index|]
operator|.
name|vma_offset
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Minimal symbols from %s..."
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Truncate name at first dot. Should maybe also convert to all      lower case for convenience on Windows. */
name|read_pe_truncate_name
argument_list|(
name|dll_name
argument_list|)
expr_stmt|;
comment|/* Iterate through the list of symbols.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexp
condition|;
name|i
operator|++
control|)
block|{
comment|/* Pointer to the names vector.  */
name|unsigned
name|long
name|name_rva
init|=
name|pe_as32
argument_list|(
name|erva
operator|+
name|name_rvas
operator|+
name|i
operator|*
literal|4
argument_list|)
decl_stmt|;
comment|/* Pointer to the function address vector.  */
name|unsigned
name|long
name|func_rva
init|=
name|pe_as32
argument_list|(
name|erva
operator|+
name|exp_funcbase
operator|+
name|i
operator|*
literal|4
argument_list|)
decl_stmt|;
comment|/* Find this symbol's section in our own array. */
name|int
name|sectix
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sectix
operator|=
literal|0
init|;
name|sectix
operator|<
name|PE_SECTION_TABLE_SIZE
condition|;
operator|++
name|sectix
control|)
block|{
if|if
condition|(
operator|(
name|func_rva
operator|>=
name|section_data
index|[
name|sectix
index|]
operator|.
name|rva_start
operator|)
operator|&&
operator|(
name|func_rva
operator|<
name|section_data
index|[
name|sectix
index|]
operator|.
name|rva_end
operator|)
condition|)
block|{
name|add_pe_exported_sym
argument_list|(
name|erva
operator|+
name|name_rva
argument_list|,
name|func_rva
argument_list|,
name|section_data
operator|+
name|sectix
argument_list|,
name|dll_name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* discard expdata. */
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

