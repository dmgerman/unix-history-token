begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* libthread_db assisted debugging support, generic parts.     Copyright 1999, 2000, 2001, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"gdb_proc_service.h"
end_include

begin_include
include|#
directive|include
file|"gdb_thread_db.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|LIBTHREAD_DB_SO
end_ifndef

begin_define
define|#
directive|define
name|LIBTHREAD_DB_SO
value|"libthread_db.so.1"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we're running on GNU/Linux, we must explicitly attach to any new    threads.  */
end_comment

begin_comment
comment|/* FIXME: There is certainly some room for improvements:    - Cache LWP ids.    - Bypass libthread_db when fetching or storing registers for    threads bound to a LWP.  */
end_comment

begin_comment
comment|/* This module's target vector.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|thread_db_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target vector that we call for things this module can't handle.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|target_beneath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the next function on the objfile event chain.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|target_new_objfile_chain
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero if we're using this module's target vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_thread_db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we have to keep this module's target vector active    across re-runs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_thread_db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we have determined the signals used by the threads    library.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_signals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigset_t
name|thread_stop_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigset_t
name|thread_print_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure that identifies the child process for the<proc_service.h> interface.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ps_prochandle
name|proc_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to the libthread_db library.  */
end_comment

begin_decl_stmt
specifier|static
name|td_thragent_t
modifier|*
name|thread_agent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to the libthread_db functions.  */
end_comment

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_init_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_new_p
function_decl|)
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ps
parameter_list|,
name|td_thragent_t
modifier|*
modifier|*
name|ta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_map_id2thr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|thread_t
name|pt
parameter_list|,
name|td_thrhandle_t
modifier|*
name|__th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_map_lwp2thr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_thr_iter_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_thr_iter_f
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|cbdata_p
parameter_list|,
name|td_thr_state_e
name|state
parameter_list|,
name|int
name|ti_pri
parameter_list|,
name|sigset_t
modifier|*
name|ti_sigmask_p
parameter_list|,
name|unsigned
name|int
name|ti_user_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_event_addr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_event_e
name|event
parameter_list|,
name|td_notify_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_set_event_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_thr_events_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_event_getmsg_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_event_msg_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_validate_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_get_info_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|td_thrinfo_t
modifier|*
name|infop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_getfpregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|gdb_prfpregset_t
modifier|*
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_getgregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prgregset_t
name|gregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_setfpregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
specifier|const
name|gdb_prfpregset_t
modifier|*
name|fpregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_setgregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prgregset_t
name|gregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_event_enable_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|int
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_tls_get_addr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|void
modifier|*
name|map_address
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|void
modifier|*
modifier|*
name|address
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Location of the thread creation event breakpoint.  The code at this    location in the child process will be called by the pthread library    whenever a new thread is created.  By setting a special breakpoint    at this location, GDB can detect when a new thread is created.  We    obtain this location via the td_ta_event_addr call.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|td_create_bp_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location of the thread death event breakpoint.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|td_death_bp_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|thread_db_find_new_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attach_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|td_thrinfo_t
modifier|*
name|ti_p
parameter_list|,
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Building process ids.  */
end_comment

begin_define
define|#
directive|define
name|GET_PID
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_pid (ptid)
end_define

begin_define
define|#
directive|define
name|GET_LWP
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_lwp (ptid)
end_define

begin_define
define|#
directive|define
name|GET_THREAD
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_tid (ptid)
end_define

begin_define
define|#
directive|define
name|is_lwp
parameter_list|(
name|ptid
parameter_list|)
value|(GET_LWP (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|is_thread
parameter_list|(
name|ptid
parameter_list|)
value|(GET_THREAD (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|BUILD_LWP
parameter_list|(
name|lwp
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, lwp, 0)
end_define

begin_define
define|#
directive|define
name|BUILD_THREAD
parameter_list|(
name|tid
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, 0, tid)
end_define

begin_escape
end_escape

begin_comment
comment|/* Use "struct private_thread_info" to cache thread state.  This is    a substantial optimization.  */
end_comment

begin_struct
struct|struct
name|private_thread_info
block|{
comment|/* Cached thread state.  */
name|unsigned
name|int
name|th_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|ti_valid
range|:
literal|1
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|thread_db_err_str
parameter_list|(
name|td_err_e
name|err
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|TD_OK
case|:
return|return
literal|"generic 'call succeeded'"
return|;
case|case
name|TD_ERR
case|:
return|return
literal|"generic error"
return|;
case|case
name|TD_NOTHR
case|:
return|return
literal|"no thread to satisfy query"
return|;
case|case
name|TD_NOSV
case|:
return|return
literal|"no sync handle to satisfy query"
return|;
case|case
name|TD_NOLWP
case|:
return|return
literal|"no LWP to satisfy query"
return|;
case|case
name|TD_BADPH
case|:
return|return
literal|"invalid process handle"
return|;
case|case
name|TD_BADTH
case|:
return|return
literal|"invalid thread handle"
return|;
case|case
name|TD_BADSH
case|:
return|return
literal|"invalid synchronization handle"
return|;
case|case
name|TD_BADTA
case|:
return|return
literal|"invalid thread agent"
return|;
case|case
name|TD_BADKEY
case|:
return|return
literal|"invalid key"
return|;
case|case
name|TD_NOMSG
case|:
return|return
literal|"no event message for getmsg"
return|;
case|case
name|TD_NOFPREGS
case|:
return|return
literal|"FPU register set not available"
return|;
case|case
name|TD_NOLIBTHREAD
case|:
return|return
literal|"application not linked with libthread"
return|;
case|case
name|TD_NOEVENT
case|:
return|return
literal|"requested event is not supported"
return|;
case|case
name|TD_NOCAPAB
case|:
return|return
literal|"capability not available"
return|;
case|case
name|TD_DBERR
case|:
return|return
literal|"debugger service failed"
return|;
case|case
name|TD_NOAPLIC
case|:
return|return
literal|"operation not applicable to"
return|;
case|case
name|TD_NOTSD
case|:
return|return
literal|"no thread-specific data for this thread"
return|;
case|case
name|TD_MALLOC
case|:
return|return
literal|"malloc failed"
return|;
case|case
name|TD_PARTIALREG
case|:
return|return
literal|"only part of register set was written/read"
return|;
case|case
name|TD_NOXREGS
case|:
return|return
literal|"X register set not available for this thread"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown thread_db error '%d'"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|thread_db_state_str
parameter_list|(
name|td_thr_state_e
name|state
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TD_THR_STOPPED
case|:
return|return
literal|"stopped by debugger"
return|;
case|case
name|TD_THR_RUN
case|:
return|return
literal|"runnable"
return|;
case|case
name|TD_THR_ACTIVE
case|:
return|return
literal|"active"
return|;
case|case
name|TD_THR_ZOMBIE
case|:
return|return
literal|"zombie"
return|;
case|case
name|TD_THR_SLEEP
case|:
return|return
literal|"sleeping"
return|;
case|case
name|TD_THR_STOPPED_ASLEEP
case|:
return|return
literal|"stopped by debugger AND blocked"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown thread_db state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A callback function for td_ta_thr_iter, which we use to map all    threads to LWPs.     THP is a handle to the current thread; if INFOP is not NULL, the    struct thread_info associated with this thread is returned in    *INFOP.  */
end_comment

begin_function
specifier|static
name|int
name|thread_get_info_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|thp
parameter_list|,
name|void
modifier|*
name|infop
parameter_list|)
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
name|ptid_t
name|thread_ptid
decl_stmt|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
name|thp
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"thread_get_info_callback: cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the cache.  */
name|thread_ptid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|thread_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_info
operator|==
name|NULL
condition|)
block|{
comment|/* New thread.  Attach to it now (why wait?).  */
name|attach_thread
argument_list|(
name|thread_ptid
argument_list|,
name|thp
argument_list|,
operator|&
name|ti
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|thread_ptid
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|thread_info
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
name|thp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|thp
argument_list|)
argument_list|)
expr_stmt|;
name|thread_info
operator|->
name|private
operator|->
name|th_valid
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|ti
argument_list|,
operator|&
name|ti
argument_list|,
sizeof|sizeof
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|thread_info
operator|->
name|private
operator|->
name|ti_valid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|infop
operator|!=
name|NULL
condition|)
operator|*
operator|(
expr|struct
name|thread_info
operator|*
operator|*
operator|)
name|infop
operator|=
name|thread_info
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Accessor functions for the thread_db information, with caching.  */
end_comment

begin_function
specifier|static
name|void
name|thread_db_map_id2thr
parameter_list|(
name|struct
name|thread_info
modifier|*
name|thread_info
parameter_list|,
name|int
name|fatal
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
name|thread_info
operator|->
name|private
operator|->
name|th_valid
condition|)
return|return;
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|thread_info
operator|->
name|ptid
argument_list|)
argument_list|,
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
if|if
condition|(
name|fatal
condition|)
name|error
argument_list|(
literal|"Cannot find thread %ld: %s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|thread_info
operator|->
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|thread_info
operator|->
name|private
operator|->
name|th_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|td_thrinfo_t
modifier|*
name|thread_db_get_info
parameter_list|(
name|struct
name|thread_info
modifier|*
name|thread_info
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
name|thread_info
operator|->
name|private
operator|->
name|ti_valid
condition|)
return|return
operator|&
name|thread_info
operator|->
name|private
operator|->
name|ti
return|;
if|if
condition|(
operator|!
name|thread_info
operator|->
name|private
operator|->
name|th_valid
condition|)
name|thread_db_map_id2thr
argument_list|(
name|thread_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
operator|&
name|thread_info
operator|->
name|private
operator|->
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"thread_db_get_info: cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|thread_info
operator|->
name|private
operator|->
name|ti_valid
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|thread_info
operator|->
name|private
operator|->
name|ti
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert between user-level thread ids and LWP ids.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|thread_from_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
name|ptid_t
name|thread_ptid
decl_stmt|;
if|if
condition|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
operator|==
literal|0
condition|)
name|ptid
operator|=
name|BUILD_LWP
argument_list|(
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|is_lwp
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_ta_map_lwp2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find user-level thread for LWP %ld: %s"
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|thread_info
operator|=
name|NULL
expr_stmt|;
name|thread_get_info_callback
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|thread_info
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|thread_info
operator|&&
name|thread_info
operator|->
name|private
operator|->
name|ti_valid
argument_list|)
expr_stmt|;
return|return
name|BUILD_THREAD
argument_list|(
name|thread_info
operator|->
name|private
operator|->
name|ti
operator|.
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|lwp_from_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
name|ptid_t
name|thread_ptid
decl_stmt|;
if|if
condition|(
operator|!
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
return|return
name|ptid
return|;
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|thread_db_get_info
argument_list|(
name|thread_info
argument_list|)
expr_stmt|;
return|return
name|BUILD_LWP
argument_list|(
name|thread_info
operator|->
name|private
operator|->
name|ti
operator|.
name|ti_lid
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|thread_db_init
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|target_beneath
operator|=
name|target
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|verbose_dlsym
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|sym
init|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"Symbol \"%s\" not found in libthread_db: %s"
argument_list|,
name|name
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|thread_db_load
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|handle
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|handle
operator|=
name|dlopen
argument_list|(
name|LIBTHREAD_DB_SO
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n\ndlopen failed on '%s' - %s\n"
argument_list|,
name|LIBTHREAD_DB_SO
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"GDB will not be able to debug pthreads.\n\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Initialize pointers to the dynamic library functions we will use.      Essential functions first.  */
name|td_init_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_init_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_new_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_new_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_map_id2thr_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_map_id2thr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_map_id2thr_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_map_lwp2thr_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_map_lwp2thr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_map_lwp2thr_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_thr_iter_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_thr_iter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_thr_iter_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_validate_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_validate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_validate_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_get_info_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_get_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_get_info_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_getfpregs_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_getfpregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_getfpregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_getgregs_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_getgregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_getgregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_setfpregs_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_setfpregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_setfpregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_setgregs_p
operator|=
name|verbose_dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_setgregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_setgregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Initialize the library.  */
name|err
operator|=
name|td_init_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot initialize libthread_db: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* These are not essential.  */
name|td_ta_event_addr_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_event_addr"
argument_list|)
expr_stmt|;
name|td_ta_set_event_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_set_event"
argument_list|)
expr_stmt|;
name|td_ta_event_getmsg_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_event_getmsg"
argument_list|)
expr_stmt|;
name|td_thr_event_enable_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_event_enable"
argument_list|)
expr_stmt|;
name|td_thr_tls_get_addr_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_tls_get_addr"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|td_err_e
name|enable_thread_event
parameter_list|(
name|td_thragent_t
modifier|*
name|thread_agent
parameter_list|,
name|int
name|event
parameter_list|,
name|CORE_ADDR
modifier|*
name|bp
parameter_list|)
block|{
name|td_notify_t
name|notify
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
comment|/* Get the breakpoint address for thread EVENT.  */
name|err
operator|=
name|td_ta_event_addr_p
argument_list|(
name|thread_agent
argument_list|,
name|event
argument_list|,
operator|&
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
name|err
return|;
comment|/* Set up the breakpoint.  */
operator|(
operator|*
name|bp
operator|)
operator|=
name|gdbarch_convert_from_func_ptr_addr
argument_list|(
name|current_gdbarch
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|notify
operator|.
name|u
operator|.
name|bptaddr
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
name|create_thread_event_breakpoint
argument_list|(
operator|(
operator|*
name|bp
operator|)
argument_list|)
expr_stmt|;
return|return
name|TD_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_thread_event_reporting
parameter_list|(
name|void
parameter_list|)
block|{
name|td_thr_events_t
name|events
decl_stmt|;
name|td_notify_t
name|notify
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
comment|/* We cannot use the thread event reporting facility if these      functions aren't available.  */
if|if
condition|(
name|td_ta_event_addr_p
operator|==
name|NULL
operator|||
name|td_ta_set_event_p
operator|==
name|NULL
operator|||
name|td_ta_event_getmsg_p
operator|==
name|NULL
operator|||
name|td_thr_event_enable_p
operator|==
name|NULL
condition|)
return|return;
comment|/* Set the process wide mask saying which events we're interested in.  */
name|td_event_emptyset
argument_list|(
operator|&
name|events
argument_list|)
expr_stmt|;
name|td_event_addset
argument_list|(
operator|&
name|events
argument_list|,
name|TD_CREATE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: kettenis/2000-04-23: The event reporting facility is      broken for TD_DEATH events in glibc 2.1.3, so don't enable it for      now.  */
block|td_event_addset (&events, TD_DEATH);
endif|#
directive|endif
name|err
operator|=
name|td_ta_set_event_p
argument_list|(
name|thread_agent
argument_list|,
operator|&
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to set global thread event mask: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Delete previous thread event breakpoints, if any.  */
name|remove_thread_event_breakpoints
argument_list|()
expr_stmt|;
name|td_create_bp_addr
operator|=
literal|0
expr_stmt|;
name|td_death_bp_addr
operator|=
literal|0
expr_stmt|;
comment|/* Set up the thread creation event.  */
name|err
operator|=
name|enable_thread_event
argument_list|(
name|thread_agent
argument_list|,
name|TD_CREATE
argument_list|,
operator|&
name|td_create_bp_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to get location for thread creation breakpoint: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set up the thread death event.  */
name|err
operator|=
name|enable_thread_event
argument_list|(
name|thread_agent
argument_list|,
name|TD_DEATH
argument_list|,
operator|&
name|td_death_bp_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to get location for thread death breakpoint: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disable_thread_event_reporting
parameter_list|(
name|void
parameter_list|)
block|{
name|td_thr_events_t
name|events
decl_stmt|;
comment|/* Set the process wide mask saying we aren't interested in any      events anymore.  */
name|td_event_emptyset
argument_list|(
operator|&
name|events
argument_list|)
expr_stmt|;
name|td_ta_set_event_p
argument_list|(
name|thread_agent
argument_list|,
operator|&
name|events
argument_list|)
expr_stmt|;
comment|/* Delete thread event breakpoints, if any.  */
name|remove_thread_event_breakpoints
argument_list|()
expr_stmt|;
name|td_create_bp_addr
operator|=
literal|0
expr_stmt|;
name|td_death_bp_addr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_thread_signals
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GET_THREAD_SIGNALS
if|if
condition|(
operator|!
name|thread_signals
condition|)
block|{
name|sigset_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GET_THREAD_SIGNALS
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|thread_stop_set
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|thread_print_set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sigismember
argument_list|(
operator|&
name|mask
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|signal_stop_update
argument_list|(
name|target_signal_from_host
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|sigaddset
argument_list|(
operator|&
name|thread_stop_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_print_update
argument_list|(
name|target_signal_from_host
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|sigaddset
argument_list|(
operator|&
name|thread_print_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|thread_signals
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_new_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
comment|/* First time through, report that libthread_db was successfuly      loaded.  Can't print this in in thread_db_load as, at that stage,      the interpreter and it's console haven't started.  The real      problem here is that libthread_db is loaded too early - it should      only be loaded when there is a program to debug.  */
block|{
specifier|static
name|int
name|dejavu
decl_stmt|;
if|if
condition|(
operator|!
name|dejavu
condition|)
block|{
name|Dl_info
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|library
init|=
name|NULL
decl_stmt|;
comment|/* Try dladdr.  */
if|if
condition|(
name|dladdr
argument_list|(
operator|(
operator|*
name|td_ta_new_p
operator|)
argument_list|,
operator|&
name|info
argument_list|)
operator|!=
literal|0
condition|)
name|library
operator|=
name|info
operator|.
name|dli_fname
expr_stmt|;
comment|/* Try dlinfo?  */
if|if
condition|(
name|library
operator|==
name|NULL
condition|)
comment|/* Paranoid - don't let a NULL path slip through.  */
name|library
operator|=
name|LIBTHREAD_DB_SO
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Using host libthread_db library \"%s\".\n"
argument_list|,
name|library
argument_list|)
expr_stmt|;
name|dejavu
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Don't attempt to use thread_db on targets which can not run      (core files).  */
if|if
condition|(
name|objfile
operator|==
name|NULL
operator|||
operator|!
name|target_has_execution
condition|)
block|{
comment|/* All symbols have been discarded.  If the thread_db target is          active, deactivate it now.  */
if|if
condition|(
name|using_thread_db
condition|)
block|{
name|gdb_assert
argument_list|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
name|using_thread_db
operator|=
literal|0
expr_stmt|;
block|}
name|keep_thread_db
operator|=
literal|0
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
if|if
condition|(
name|using_thread_db
condition|)
comment|/* Nothing to do.  The thread library was already detected and the        target vector was already activated.  */
goto|goto
name|quit
goto|;
comment|/* Initialize the structure that identifies the child process.  Note      that at this point there is no guarantee that we actually have a      child process.  */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Now attempt to open a connection to the thread library.  */
name|err
operator|=
name|td_ta_new_p
argument_list|(
operator|&
name|proc_handle
argument_list|,
operator|&
name|thread_agent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|TD_NOLIBTHREAD
case|:
comment|/* No thread library was detected.  */
break|break;
case|case
name|TD_OK
case|:
name|printf_unfiltered
argument_list|(
literal|"[Thread debugging using libthread_db enabled]\n"
argument_list|)
expr_stmt|;
comment|/* The thread library was detected.  Activate the thread_db target.  */
name|push_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
name|using_thread_db
operator|=
literal|1
expr_stmt|;
comment|/* If the thread library was detected in the main symbol file          itself, we assume that the program was statically linked          against the thread library and well have to keep this          module's target vector activated until forever...  Well, at          least until all symbols have been discarded anyway (see          above).  */
if|if
condition|(
name|objfile
operator|==
name|symfile_objfile
condition|)
block|{
name|gdb_assert
argument_list|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
argument_list|)
expr_stmt|;
name|keep_thread_db
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We can only poke around if there actually is a child process.          If there is no child process alive, postpone the steps below          until one has been created.  */
if|if
condition|(
name|proc_handle
operator|.
name|pid
operator|!=
literal|0
condition|)
block|{
name|enable_thread_event_reporting
argument_list|()
expr_stmt|;
name|thread_db_find_new_threads
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|warning
argument_list|(
literal|"Cannot initialize thread debugging library: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|quit
label|:
if|if
condition|(
name|target_new_objfile_chain
condition|)
name|target_new_objfile_chain
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|attach_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|td_thrinfo_t
modifier|*
name|ti_p
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|check_thread_signals
argument_list|()
expr_stmt|;
comment|/* Add the thread to GDB's thread list.  */
name|tp
operator|=
name|add_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|tp
operator|->
name|private
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|private_thread_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tp
operator|->
name|private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|private_thread_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti_p
operator|->
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|ti_p
operator|->
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return;
comment|/* A zombie thread -- do not attach.  */
comment|/* Under GNU/Linux, we have to attach to each and every thread.  */
ifdef|#
directive|ifdef
name|ATTACH_LWP
name|ATTACH_LWP
argument_list|(
name|BUILD_LWP
argument_list|(
name|ti_p
operator|->
name|ti_lid
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable thread event reporting for this thread.  */
name|err
operator|=
name|td_thr_event_enable_p
argument_list|(
name|th_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot enable thread event reporting for %s: %s"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|target_beneath
operator|->
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Destroy thread info; it's no longer valid.  */
name|init_thread_list
argument_list|()
expr_stmt|;
comment|/* The child process is now the actual multi-threaded      program.  Snatch its process ID...  */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* ...and perform the remaining initialization steps.  */
name|enable_thread_event_reporting
argument_list|()
expr_stmt|;
name|thread_db_find_new_threads
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detach_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[%s exited]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|disable_thread_event_reporting
argument_list|()
expr_stmt|;
comment|/* There's no need to save& restore inferior_ptid here, since the      inferior is supposed to be survive this function call.  */
name|inferior_ptid
operator|=
name|lwp_from_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Forget about the child's process ID.  We shouldn't need it      anymore.  */
name|proc_handle
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|target_beneath
operator|->
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|clear_lwpid_callback
parameter_list|(
name|struct
name|thread_info
modifier|*
name|thread
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* If we know that our thread implementation is 1-to-1, we could save      a certain amount of information; it's not clear how much, so we      are always conservative.  */
name|thread
operator|->
name|private
operator|->
name|th_valid
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|private
operator|->
name|ti_valid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|save_inferior_ptid
argument_list|()
decl_stmt|;
if|if
condition|(
name|GET_PID
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|inferior_ptid
operator|=
name|lwp_from_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
name|ptid
operator|=
name|lwp_from_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
comment|/* Clear cached data which may not be valid after the resume.  */
name|iterate_over_threads
argument_list|(
name|clear_lwpid_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|target_beneath
operator|->
name|to_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if PID is currently stopped at the location of a thread event    breakpoint location.  If it is, read the event message and act upon    the event.  */
end_comment

begin_function
specifier|static
name|void
name|check_event
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|td_event_msg_t
name|msg
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|CORE_ADDR
name|stop_pc
decl_stmt|;
name|int
name|loop
init|=
literal|0
decl_stmt|;
comment|/* Bail out early if we're not at a thread event breakpoint.  */
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|ptid
argument_list|)
operator|-
name|DECR_PC_AFTER_BREAK
expr_stmt|;
if|if
condition|(
name|stop_pc
operator|!=
name|td_create_bp_addr
operator|&&
name|stop_pc
operator|!=
name|td_death_bp_addr
condition|)
return|return;
comment|/* If we are at a create breakpoint, we do not know what new lwp      was created and cannot specifically locate the event message for it.      We have to call td_ta_event_getmsg() to get      the latest message.  Since we have no way of correlating whether      the event message we get back corresponds to our breakpoint, we must      loop and read all event messages, processing them appropriately.      This guarantees we will process the correct message before continuing      from the breakpoint.       Currently, death events are not enabled.  If they are enabled,      the death event can use the td_thr_event_getmsg() interface to      get the message specifically for that lwp and avoid looping      below.  */
name|loop
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|err
operator|=
name|td_ta_event_getmsg_p
argument_list|(
name|thread_agent
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|TD_NOMSG
condition|)
return|return;
name|error
argument_list|(
literal|"Cannot get thread event message: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
name|msg
operator|.
name|th_p
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ptid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|.
name|event
condition|)
block|{
case|case
name|TD_CREATE
case|:
comment|/* We may already know about this thread, for instance when the 	     user has issued the `info threads' command before the SIGTRAP 	     for hitting the thread creation breakpoint was reported.  */
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|attach_thread
argument_list|(
name|ptid
argument_list|,
name|msg
operator|.
name|th_p
argument_list|,
operator|&
name|ti
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_DEATH
case|:
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|error
argument_list|(
literal|"Spurious thread death event."
argument_list|)
expr_stmt|;
name|detach_thread
argument_list|(
name|ptid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Spurious thread event."
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|loop
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|thread_db_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
specifier|extern
name|ptid_t
name|trap_ptid
decl_stmt|;
if|if
condition|(
name|GET_PID
argument_list|(
name|ptid
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
name|ptid
operator|=
name|lwp_from_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|ptid
operator|=
name|target_beneath
operator|->
name|to_wait
argument_list|(
name|ptid
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
condition|)
comment|/* The current child process isn't the actual multi-threaded        program yet, so don't try to do any special thread-specific        post-processing and bail out early.  */
return|return
name|ptid
return|;
if|if
condition|(
name|ourstatus
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_EXITED
condition|)
return|return
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|ourstatus
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
operator|&&
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
comment|/* Check for a thread event.  */
name|check_event
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|trap_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
name|trap_ptid
operator|=
name|thread_from_lwp
argument_list|(
name|trap_ptid
argument_list|)
expr_stmt|;
return|return
name|thread_from_lwp
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|thread_db_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|save_inferior_ptid
argument_list|()
decl_stmt|;
name|int
name|xfer
decl_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
comment|/* FIXME: This seems to be necessary to make sure breakpoints          are removed.  */
if|if
condition|(
operator|!
name|target_thread_alive
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|inferior_ptid
operator|=
name|lwp_from_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|=
name|target_beneath
operator|->
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|xfer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
name|prgregset_t
name|gregset
decl_stmt|;
name|gdb_prfpregset_t
name|fpregset
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|is_thread
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
comment|/* Pass the request to the target beneath us.  */
name|target_beneath
operator|->
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|thread_db_map_id2thr
argument_list|(
name|thread_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getgregs_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot fetch general-purpose registers for thread %ld: %s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getfpregs_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get floating-point registers for thread %ld: %s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we must call supply_gregset after calling the thread_db      routines because the thread_db routines call ps_lgetgregs and      friends which clobber GDB's register cache.  */
name|supply_gregset
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|)
name|gregset
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|prgregset_t
name|gregset
decl_stmt|;
name|gdb_prfpregset_t
name|fpregset
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
if|if
condition|(
operator|!
name|is_thread
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
comment|/* Pass the request to the target beneath us.  */
name|target_beneath
operator|->
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|thread_db_map_id2thr
argument_list|(
name|thread_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|raw
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|deprecated_read_register_gen
argument_list|(
name|regno
argument_list|,
name|raw
argument_list|)
expr_stmt|;
name|thread_db_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|raw
argument_list|)
expr_stmt|;
block|}
name|fill_gregset
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|)
name|gregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_setgregs_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot store general-purpose registers for thread %ld: %s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_setfpregs_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot store floating-point registers  for thread %ld: %s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_kill
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* There's no need to save& restore inferior_ptid here, since the      inferior isn't supposed to survive this function call.  */
name|inferior_ptid
operator|=
name|lwp_from_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|target_beneath
operator|->
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
operator|!
name|keep_thread_db
condition|)
block|{
name|unpush_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
name|using_thread_db
operator|=
literal|0
expr_stmt|;
block|}
name|target_beneath
operator|->
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_post_startup_inferior
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* The child process is now the actual multi-threaded          program.  Snatch its process ID...  */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
comment|/* ...and perform the remaining initialization steps.  */
name|enable_thread_event_reporting
argument_list|()
expr_stmt|;
name|thread_db_find_new_threads
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|remove_thread_event_breakpoints
argument_list|()
expr_stmt|;
comment|/* Forget about the child's process ID.  We shouldn't need it      anymore.  */
name|proc_handle
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|target_beneath
operator|->
name|to_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Detach thread_db target ops if not dealing with a statically      linked threaded program.  This allows a corefile to be debugged      after finishing debugging of a threaded program.  At present,      debugging a statically-linked threaded program is broken, but      the check is added below in the event that it is fixed in the      future.  */
if|if
condition|(
operator|!
name|keep_thread_db
condition|)
block|{
name|unpush_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
name|using_thread_db
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|thread_db_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|thread_db_map_id2thr
argument_list|(
name|thread_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread_info
operator|->
name|private
operator|->
name|th_valid
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|td_thr_validate_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|thread_info
operator|->
name|private
operator|->
name|ti_valid
condition|)
block|{
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
operator|&
name|thread_info
operator|->
name|private
operator|->
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
name|thread_info
operator|->
name|private
operator|->
name|ti_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|thread_info
operator|->
name|private
operator|->
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|thread_info
operator|->
name|private
operator|->
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return
literal|0
return|;
comment|/* A zombie thread.  */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|target_beneath
operator|->
name|to_thread_alive
condition|)
return|return
name|target_beneath
operator|->
name|to_thread_alive
argument_list|(
name|ptid
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_new_threads_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|ptid_t
name|ptid
decl_stmt|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
name|th_p
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"find_new_threads_callback: cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return
literal|0
return|;
comment|/* A zombie -- ignore.  */
name|ptid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|attach_thread
argument_list|(
name|ptid
argument_list|,
name|th_p
argument_list|,
operator|&
name|ti
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_db_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
comment|/* Iterate over all user-space threads to discover new threads.  */
name|err
operator|=
name|td_ta_thr_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|find_new_threads_callback
argument_list|,
name|NULL
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find new threads: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|thread_db_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|td_thrinfo_t
modifier|*
name|ti_p
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|thread_db_map_id2thr
argument_list|(
name|thread_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread_info
operator|->
name|private
operator|->
name|th_valid
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Thread %ld (Missing)"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|ti_p
operator|=
name|thread_db_get_info
argument_list|(
name|thread_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti_p
operator|->
name|ti_state
operator|==
name|TD_THR_ACTIVE
operator|&&
name|ti_p
operator|->
name|ti_lid
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Thread %ld (LWP %d)"
argument_list|,
operator|(
name|long
operator|)
name|ti_p
operator|->
name|ti_tid
argument_list|,
name|ti_p
operator|->
name|ti_lid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Thread %ld (%s)"
argument_list|,
operator|(
name|long
operator|)
name|ti_p
operator|->
name|ti_tid
argument_list|,
name|thread_db_state_str
argument_list|(
name|ti_p
operator|->
name|ti_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
if|if
condition|(
name|target_beneath
operator|->
name|to_pid_to_str
argument_list|(
name|ptid
argument_list|)
condition|)
return|return
name|target_beneath
operator|->
name|to_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
return|return
name|normal_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the address of the thread local variable in OBJFILE which is    stored at OFFSET within the thread local storage for thread PTID.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|thread_db_get_thread_local_address
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|CORE_ADDR
name|offset
parameter_list|)
block|{
if|if
condition|(
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|int
name|objfile_is_library
init|=
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_SHARED
operator|)
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|void
modifier|*
name|address
decl_stmt|;
name|CORE_ADDR
name|lm
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread_info
decl_stmt|;
comment|/* glibc doesn't provide the needed interface.  */
if|if
condition|(
operator|!
name|td_thr_tls_get_addr_p
condition|)
name|error
argument_list|(
literal|"Cannot find thread-local variables in this thread library."
argument_list|)
expr_stmt|;
comment|/* Get the address of the link map for this objfile.  */
name|lm
operator|=
name|svr4_fetch_objfile_link_map
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Whoops, we couldn't find one. Bail out.  */
if|if
condition|(
operator|!
name|lm
condition|)
block|{
if|if
condition|(
name|objfile_is_library
condition|)
name|error
argument_list|(
literal|"Cannot find shared library `%s' link_map in dynamic"
literal|" linker's module list"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot find executable file `%s' link_map in dynamic"
literal|" linker's module list"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Get info about the thread.  */
name|thread_info
operator|=
name|find_thread_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|thread_db_map_id2thr
argument_list|(
name|thread_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Finally, get the address of the variable.  */
name|err
operator|=
name|td_thr_tls_get_addr_p
argument_list|(
operator|&
name|thread_info
operator|->
name|private
operator|->
name|th
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lm
argument_list|,
name|offset
argument_list|,
operator|&
name|address
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DB_HAS_TD_NOTALLOC
comment|/* The memory hasn't been allocated, yet.  */
if|if
condition|(
name|err
operator|==
name|TD_NOTALLOC
condition|)
block|{
comment|/* Now, if libthread_db provided the initialization image's 	     address, we *could* try to build a non-lvalue value from 	     the initialization image.  */
if|if
condition|(
name|objfile_is_library
condition|)
name|error
argument_list|(
literal|"The inferior has not yet allocated storage for"
literal|" thread-local variables in\n"
literal|"the shared library `%s'\n"
literal|"for the thread %ld"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"The inferior has not yet allocated storage for"
literal|" thread-local variables in\n"
literal|"the executable `%s'\n"
literal|"for the thread %ld"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Something else went wrong.  */
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
if|if
condition|(
name|objfile_is_library
condition|)
name|error
argument_list|(
literal|"Cannot find thread-local storage for thread %ld, "
literal|"shared library %s:\n%s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot find thread-local storage for thread %ld, "
literal|"executable file %s:\n%s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Cast assuming host == target.  Joy.  */
return|return
operator|(
name|CORE_ADDR
operator|)
name|address
return|;
block|}
if|if
condition|(
name|target_beneath
operator|->
name|to_get_thread_local_address
condition|)
return|return
name|target_beneath
operator|->
name|to_get_thread_local_address
argument_list|(
name|ptid
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
return|;
name|error
argument_list|(
literal|"Cannot find thread-local values on this target."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_thread_db_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_db_ops
operator|.
name|to_shortname
operator|=
literal|"multi-thread"
expr_stmt|;
name|thread_db_ops
operator|.
name|to_longname
operator|=
literal|"multi-threaded child process."
expr_stmt|;
name|thread_db_ops
operator|.
name|to_doc
operator|=
literal|"Threads and pthreads support."
expr_stmt|;
name|thread_db_ops
operator|.
name|to_attach
operator|=
name|thread_db_attach
expr_stmt|;
name|thread_db_ops
operator|.
name|to_detach
operator|=
name|thread_db_detach
expr_stmt|;
name|thread_db_ops
operator|.
name|to_resume
operator|=
name|thread_db_resume
expr_stmt|;
name|thread_db_ops
operator|.
name|to_wait
operator|=
name|thread_db_wait
expr_stmt|;
name|thread_db_ops
operator|.
name|to_fetch_registers
operator|=
name|thread_db_fetch_registers
expr_stmt|;
name|thread_db_ops
operator|.
name|to_store_registers
operator|=
name|thread_db_store_registers
expr_stmt|;
name|thread_db_ops
operator|.
name|to_xfer_memory
operator|=
name|thread_db_xfer_memory
expr_stmt|;
name|thread_db_ops
operator|.
name|to_kill
operator|=
name|thread_db_kill
expr_stmt|;
name|thread_db_ops
operator|.
name|to_create_inferior
operator|=
name|thread_db_create_inferior
expr_stmt|;
name|thread_db_ops
operator|.
name|to_post_startup_inferior
operator|=
name|thread_db_post_startup_inferior
expr_stmt|;
name|thread_db_ops
operator|.
name|to_mourn_inferior
operator|=
name|thread_db_mourn_inferior
expr_stmt|;
name|thread_db_ops
operator|.
name|to_thread_alive
operator|=
name|thread_db_thread_alive
expr_stmt|;
name|thread_db_ops
operator|.
name|to_find_new_threads
operator|=
name|thread_db_find_new_threads
expr_stmt|;
name|thread_db_ops
operator|.
name|to_pid_to_str
operator|=
name|thread_db_pid_to_str
expr_stmt|;
name|thread_db_ops
operator|.
name|to_stratum
operator|=
name|thread_stratum
expr_stmt|;
name|thread_db_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_schedlock
expr_stmt|;
name|thread_db_ops
operator|.
name|to_get_thread_local_address
operator|=
name|thread_db_get_thread_local_address
expr_stmt|;
name|thread_db_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_thread_db
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Only initialize the module if we can load libthread_db.  */
if|if
condition|(
name|thread_db_load
argument_list|()
condition|)
block|{
name|init_thread_db_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
comment|/* Add ourselves to objfile event chain.  */
name|target_new_objfile_chain
operator|=
name|target_new_objfile_hook
expr_stmt|;
name|target_new_objfile_hook
operator|=
name|thread_db_new_objfile
expr_stmt|;
block|}
block|}
end_function

end_unit

