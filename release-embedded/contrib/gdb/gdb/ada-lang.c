begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Ada language support routines for GDB, the GNU debugger.  Copyright    1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"ada-lang.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"infcall.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_decl_stmt
name|struct
name|cleanup
modifier|*
name|unresolved_names
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|extract_string
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|ada_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modify_general_field
parameter_list|(
name|char
modifier|*
parameter_list|,
name|LONGEST
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|desc_base_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|desc_bounds_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|desc_bounds
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fat_pntr_bounds_bitpos
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fat_pntr_bounds_bitsize
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|desc_data_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|desc_data
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fat_pntr_data_bitpos
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fat_pntr_data_bitsize
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|desc_one_bound
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|desc_bound_bitpos
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|desc_bound_bitsize
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|desc_index_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|desc_arity
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ada_type_match
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ada_args_match
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|place_on_stack
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|convert_actual
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|make_array_descriptor
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ada_add_block_symbols
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|domain_enum
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_in_ada_prototype
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_nonfunction
parameter_list|(
name|struct
name|symbol
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_defn_to_vec
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|,
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|partial_symbol
modifier|*
name|ada_lookup_partial_symbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|domain_enum
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtab
modifier|*
name|symtab_for_sym
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|ada_resolve_subexp
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_operator_with_call
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|,
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|possible_user_operator_p
parameter_list|(
name|enum
name|exp_opcode
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ada_op_name
parameter_list|(
name|enum
name|exp_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|numeric_type_p
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|integer_type_p
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scalar_type_p
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|discrete_type_p
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|extended_canonical_line_spec
parameter_list|(
name|struct
name|symtab_and_line
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|noside
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp_type
parameter_list|(
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|ada_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_dynamic_field
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|to_fixed_variant_branch_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|to_fixed_range_type
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|to_static_fixed_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|unwrap_value
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|packed_array_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|decode_packed_array_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|decode_packed_array
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|value_subscript_packed
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|coerce_unspec_val_to_type
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|long
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|get_var_value
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lesseq_defined_than
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|equiv_types
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_name_suffix
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wild_match
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|find_sal_from_funcs_and_line
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_line_in_linetable
parameter_list|(
name|struct
name|linetable
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_next_line_in_linetable
parameter_list|(
name|struct
name|linetable
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|all_sals_for_line
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_all_symtabs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_plausible_func_for_line
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|ada_coerce_ref
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|value_pos_atr
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|value_val_atr
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|standard_lookup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|domain_enum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|markTimeStart
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|markTimeStop
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Maximum-sized dynamic type. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|varsize_limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ada_completer_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\";:?/,-"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the symbol to use to get the name of the main subprogram */
end_comment

begin_define
define|#
directive|define
name|ADA_MAIN_PROGRAM_SYMBOL_NAME
value|"__gnat_ada_main_program_name"
end_define

begin_comment
comment|/* Utilities */
end_comment

begin_comment
comment|/* extract_string  *  * read the string located at ADDR from the inferior and store the  * result into BUF  */
end_comment

begin_function
name|void
name|extract_string
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|char_index
init|=
literal|0
decl_stmt|;
comment|/* Loop, reading one byte at a time, until we reach the '\000'       end-of-string marker */
do|do
block|{
name|target_read_memory
argument_list|(
name|addr
operator|+
name|char_index
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|buf
operator|+
name|char_index
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|char_index
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|buf
index|[
name|char_index
operator|-
literal|1
index|]
operator|!=
literal|'\000'
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Assuming *OLD_VECT points to an array of *SIZE objects of size    ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,    updating *OLD_VECT and *SIZE as necessary. */
end_comment

begin_function
name|void
name|grow_vect
parameter_list|(
name|void
modifier|*
modifier|*
name|old_vect
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|size_t
name|min_size
parameter_list|,
name|int
name|element_size
parameter_list|)
block|{
if|if
condition|(
operator|*
name|size
operator|<
name|min_size
condition|)
block|{
operator|*
name|size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
name|min_size
condition|)
operator|*
name|size
operator|=
name|min_size
expr_stmt|;
operator|*
name|old_vect
operator|=
name|xrealloc
argument_list|(
operator|*
name|old_vect
argument_list|,
operator|*
name|size
operator|*
name|element_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True (non-zero) iff TARGET matches FIELD_NAME up to any trailing    suffix of FIELD_NAME beginning "___" */
end_comment

begin_function
specifier|static
name|int
name|field_name_match
parameter_list|(
specifier|const
name|char
modifier|*
name|field_name
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|target
argument_list|)
decl_stmt|;
return|return
name|DEPRECATED_STREQN
argument_list|(
name|field_name
argument_list|,
name|target
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|field_name
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|DEPRECATED_STREQN
argument_list|(
name|field_name
operator|+
name|len
argument_list|,
literal|"___"
argument_list|,
literal|3
argument_list|)
operator|&&
operator|!
name|DEPRECATED_STREQ
argument_list|(
name|field_name
operator|+
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|-
literal|6
argument_list|,
literal|"___XVN"
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The length of the prefix of NAME prior to any "___" suffix. */
end_comment

begin_function
name|int
name|ada_name_prefix_len
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"___"
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|strlen
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
name|p
operator|-
name|name
return|;
block|}
block|}
end_function

begin_comment
comment|/* SUFFIX is a suffix of STR. False if STR is null. */
end_comment

begin_function
specifier|static
name|int
name|is_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len1
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
return|return
operator|(
name|len1
operator|>=
name|len2
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|str
operator|+
name|len1
operator|-
name|len2
argument_list|,
name|suffix
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a value of type TYPE whose contents come from VALADDR, if it  * is non-null, and whose memory address (in the inferior) is  * ADDRESS. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_from_contents_and_address
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|valaddr
operator|==
name|NULL
condition|)
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|!=
literal|0
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* The contents of value VAL, beginning at offset OFFSET, treated as a    value of type TYPE.  The result is an lval in memory if VAL is. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|coerce_unspec_val_to_type
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|long
name|offset
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|==
name|lval_memory
condition|)
return|return
name|value_at_lazy
argument_list|(
name|type
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|+
name|offset
argument_list|,
name|NULL
argument_list|)
return|;
else|else
block|{
name|struct
name|value
modifier|*
name|result
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|VALUE_LVAL
argument_list|(
name|result
argument_list|)
operator|=
name|not_lval
expr_stmt|;
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|result
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|?
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
else|:
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|VALUE_ADDRESS
argument_list|(
name|result
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|+
name|offset
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cond_offset_host
parameter_list|(
name|char
modifier|*
name|valaddr
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|valaddr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|valaddr
operator|+
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|cond_offset_target
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|address
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
name|address
operator|+
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Perform execute_command on the result of concatenating all    arguments up to NULL. */
end_comment

begin_function
specifier|static
name|void
name|do_command
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|arg
expr_stmt|;
name|cmd
operator|=
literal|""
expr_stmt|;
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
control|)
block|{
name|char
modifier|*
name|cmd1
decl_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cmd1
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmd1
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd1
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|cmd1
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Language Selection */
end_comment

begin_comment
comment|/* If the main program is in Ada, return language_ada, otherwise return LANG    (the main program is in Ada iif the adainit symbol is found).     MAIN_PST is not used. */
end_comment

begin_function
name|enum
name|language
name|ada_update_initial_language
parameter_list|(
name|enum
name|language
name|lang
parameter_list|,
name|struct
name|partial_symtab
modifier|*
name|main_pst
parameter_list|)
block|{
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"adainit"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
comment|/*    return language_ada; */
comment|/* FIXME: language_ada should be defined in defs.h */
return|return
name|language_unknown
return|;
return|return
name|lang
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbols */
end_comment

begin_comment
comment|/* Table of Ada operators and their GNAT-mangled names.  Last entry is pair     of NULLs. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|ada_opname_map
name|ada_opname_table
index|[]
init|=
block|{
block|{
literal|"Oadd"
block|,
literal|"\"+\""
block|,
name|BINOP_ADD
block|}
block|,
block|{
literal|"Osubtract"
block|,
literal|"\"-\""
block|,
name|BINOP_SUB
block|}
block|,
block|{
literal|"Omultiply"
block|,
literal|"\"*\""
block|,
name|BINOP_MUL
block|}
block|,
block|{
literal|"Odivide"
block|,
literal|"\"/\""
block|,
name|BINOP_DIV
block|}
block|,
block|{
literal|"Omod"
block|,
literal|"\"mod\""
block|,
name|BINOP_MOD
block|}
block|,
block|{
literal|"Orem"
block|,
literal|"\"rem\""
block|,
name|BINOP_REM
block|}
block|,
block|{
literal|"Oexpon"
block|,
literal|"\"**\""
block|,
name|BINOP_EXP
block|}
block|,
block|{
literal|"Olt"
block|,
literal|"\"<\""
block|,
name|BINOP_LESS
block|}
block|,
block|{
literal|"Ole"
block|,
literal|"\"<=\""
block|,
name|BINOP_LEQ
block|}
block|,
block|{
literal|"Ogt"
block|,
literal|"\">\""
block|,
name|BINOP_GTR
block|}
block|,
block|{
literal|"Oge"
block|,
literal|"\">=\""
block|,
name|BINOP_GEQ
block|}
block|,
block|{
literal|"Oeq"
block|,
literal|"\"=\""
block|,
name|BINOP_EQUAL
block|}
block|,
block|{
literal|"One"
block|,
literal|"\"/=\""
block|,
name|BINOP_NOTEQUAL
block|}
block|,
block|{
literal|"Oand"
block|,
literal|"\"and\""
block|,
name|BINOP_BITWISE_AND
block|}
block|,
block|{
literal|"Oor"
block|,
literal|"\"or\""
block|,
name|BINOP_BITWISE_IOR
block|}
block|,
block|{
literal|"Oxor"
block|,
literal|"\"xor\""
block|,
name|BINOP_BITWISE_XOR
block|}
block|,
block|{
literal|"Oconcat"
block|,
literal|"\"&\""
block|,
name|BINOP_CONCAT
block|}
block|,
block|{
literal|"Oabs"
block|,
literal|"\"abs\""
block|,
name|UNOP_ABS
block|}
block|,
block|{
literal|"Onot"
block|,
literal|"\"not\""
block|,
name|UNOP_LOGICAL_NOT
block|}
block|,
block|{
literal|"Oadd"
block|,
literal|"\"+\""
block|,
name|UNOP_PLUS
block|}
block|,
block|{
literal|"Osubtract"
block|,
literal|"\"-\""
block|,
name|UNOP_NEG
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if STR should be suppressed in info listings. */
end_comment

begin_function
specifier|static
name|int
name|is_suppressed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|DEPRECATED_STREQN
argument_list|(
name|str
argument_list|,
literal|"_ada_"
argument_list|,
literal|5
argument_list|)
condition|)
name|str
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'_'
operator|||
name|str
index|[
literal|0
index|]
operator|==
literal|'\000'
condition|)
return|return
literal|1
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
init|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"___"
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|!=
name|NULL
operator|&&
name|suffix
index|[
literal|3
index|]
operator|!=
literal|'X'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|suffix
operator|==
name|NULL
condition|)
name|suffix
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|suffix
operator|-
literal|1
init|;
name|p
operator|!=
name|str
condition|;
name|p
operator|-=
literal|1
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'X'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'_'
condition|)
goto|goto
name|OK
goto|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'O'
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ada_opname_table
index|[
name|i
index|]
operator|.
name|mangled
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|DEPRECATED_STREQN
argument_list|(
name|ada_opname_table
index|[
name|i
index|]
operator|.
name|mangled
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|ada_opname_table
index|[
name|i
index|]
operator|.
name|mangled
argument_list|)
argument_list|)
condition|)
goto|goto
name|OK
goto|;
return|return
literal|1
return|;
name|OK
label|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* The "mangled" form of DEMANGLED, according to GNAT conventions.  * The result is valid until the next call to ada_mangle. */
end_comment

begin_function
name|char
modifier|*
name|ada_mangle
parameter_list|(
specifier|const
name|char
modifier|*
name|demangled
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|mangling_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|mangling_buffer_size
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|demangled
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|GROW_VECT
argument_list|(
name|mangling_buffer
argument_list|,
name|mangling_buffer_size
argument_list|,
literal|2
operator|*
name|strlen
argument_list|(
name|demangled
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|demangled
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|+=
literal|1
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|mangling_buffer
index|[
name|k
index|]
operator|=
name|mangling_buffer
index|[
name|k
operator|+
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
name|k
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
specifier|const
name|struct
name|ada_opname_map
modifier|*
name|mapping
decl_stmt|;
for|for
control|(
name|mapping
operator|=
name|ada_opname_table
init|;
name|mapping
operator|->
name|mangled
operator|!=
name|NULL
operator|&&
operator|!
name|DEPRECATED_STREQN
argument_list|(
name|mapping
operator|->
name|demangled
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|mapping
operator|->
name|demangled
argument_list|)
argument_list|)
condition|;
name|p
operator|+=
literal|1
control|)
empty_stmt|;
if|if
condition|(
name|mapping
operator|->
name|mangled
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"invalid Ada operator name: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangling_buffer
operator|+
name|k
argument_list|,
name|mapping
operator|->
name|mangled
argument_list|)
expr_stmt|;
name|k
operator|+=
name|strlen
argument_list|(
name|mapping
operator|->
name|mangled
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|mangling_buffer
index|[
name|k
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|k
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|mangling_buffer
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|mangling_buffer
return|;
block|}
end_function

begin_comment
comment|/* Return NAME folded to lower case, or, if surrounded by single  * quotes, unfolded, but with the quotes stripped away.  Result good  * to next call. */
end_comment

begin_function
name|char
modifier|*
name|ada_fold_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|fold_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|fold_buffer_size
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|GROW_VECT
argument_list|(
name|fold_buffer
argument_list|,
name|fold_buffer_size
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
block|{
name|strncpy
argument_list|(
name|fold_buffer
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|fold_buffer
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|+=
literal|1
control|)
name|fold_buffer
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|fold_buffer
return|;
block|}
end_function

begin_comment
comment|/* Demangle:       1. Discard final __{DIGIT}+ or ${DIGIT}+      2. Convert other instances of embedded "__" to `.'.      3. Discard leading _ada_.      4. Convert operator names to the appropriate quoted symbols.      5. Remove everything after first ___ if it is followed by          'X'.      6. Replace TK__ with __, and a trailing B or TKB with nothing.      7. Put symbols that should be suppressed in<...> brackets.      8. Remove trailing X[bn]* suffix (indicating names in package bodies).    The resulting string is valid until the next call of ada_demangle.   */
end_comment

begin_function
name|char
modifier|*
name|ada_demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
name|int
name|at_start_name
decl_stmt|;
specifier|static
name|char
modifier|*
name|demangling_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|demangling_buffer_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DEPRECATED_STREQN
argument_list|(
name|mangled
argument_list|,
literal|"_ada_"
argument_list|,
literal|5
argument_list|)
condition|)
name|mangled
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
operator|||
name|mangled
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
goto|goto
name|Suppress
goto|;
name|p
operator|=
name|strstr
argument_list|(
name|mangled
argument_list|,
literal|"___"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|len0
operator|=
name|strlen
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
name|len0
operator|=
name|p
operator|-
name|mangled
expr_stmt|;
else|else
goto|goto
name|Suppress
goto|;
block|}
if|if
condition|(
name|len0
operator|>
literal|3
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|mangled
operator|+
name|len0
operator|-
literal|3
argument_list|,
literal|"TKB"
argument_list|)
condition|)
name|len0
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|len0
operator|>
literal|1
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|mangled
operator|+
name|len0
operator|-
literal|1
argument_list|,
literal|"B"
argument_list|)
condition|)
name|len0
operator|-=
literal|1
expr_stmt|;
comment|/* Make demangled big enough for possible expansion by operator name. */
name|GROW_VECT
argument_list|(
name|demangling_buffer
argument_list|,
name|demangling_buffer_size
argument_list|,
literal|2
operator|*
name|len0
operator|+
literal|1
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|demangling_buffer
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|mangled
index|[
name|len0
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|len0
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
operator|&&
name|isdigit
argument_list|(
name|mangled
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|-=
literal|1
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|mangled
index|[
name|i
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
name|len0
operator|=
name|i
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mangled
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
name|len0
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|len0
operator|&&
operator|!
name|isalpha
argument_list|(
name|mangled
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|+=
literal|1
operator|,
name|j
operator|+=
literal|1
control|)
name|demangled
index|[
name|j
index|]
operator|=
name|mangled
index|[
name|i
index|]
expr_stmt|;
name|at_start_name
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len0
condition|)
block|{
if|if
condition|(
name|at_start_name
operator|&&
name|mangled
index|[
name|i
index|]
operator|==
literal|'O'
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ada_opname_table
index|[
name|k
index|]
operator|.
name|mangled
operator|!=
name|NULL
condition|;
name|k
operator|+=
literal|1
control|)
block|{
name|int
name|op_len
init|=
name|strlen
argument_list|(
name|ada_opname_table
index|[
name|k
index|]
operator|.
name|mangled
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEPRECATED_STREQN
argument_list|(
name|ada_opname_table
index|[
name|k
index|]
operator|.
name|mangled
operator|+
literal|1
argument_list|,
name|mangled
operator|+
name|i
operator|+
literal|1
argument_list|,
name|op_len
operator|-
literal|1
argument_list|)
operator|&&
operator|!
name|isalnum
argument_list|(
name|mangled
index|[
name|i
operator|+
name|op_len
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|demangled
operator|+
name|j
argument_list|,
name|ada_opname_table
index|[
name|k
index|]
operator|.
name|demangled
argument_list|)
expr_stmt|;
name|at_start_name
operator|=
literal|0
expr_stmt|;
name|i
operator|+=
name|op_len
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|ada_opname_table
index|[
name|k
index|]
operator|.
name|demangled
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ada_opname_table
index|[
name|k
index|]
operator|.
name|mangled
operator|!=
name|NULL
condition|)
continue|continue;
block|}
name|at_start_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len0
operator|-
literal|4
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|mangled
operator|+
name|i
argument_list|,
literal|"TK__"
argument_list|,
literal|4
argument_list|)
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|mangled
index|[
name|i
index|]
operator|==
literal|'X'
operator|&&
name|i
operator|!=
literal|0
operator|&&
name|isalnum
argument_list|(
name|mangled
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
do|do
name|i
operator|+=
literal|1
expr_stmt|;
do|while
condition|(
name|i
operator|<
name|len0
operator|&&
operator|(
name|mangled
index|[
name|i
index|]
operator|==
literal|'b'
operator|||
name|mangled
index|[
name|i
index|]
operator|==
literal|'n'
operator|)
condition|)
do|;
if|if
condition|(
name|i
operator|<
name|len0
condition|)
goto|goto
name|Suppress
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|len0
operator|-
literal|2
operator|&&
name|mangled
index|[
name|i
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|demangled
index|[
name|j
index|]
operator|=
literal|'.'
expr_stmt|;
name|at_start_name
operator|=
literal|1
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|j
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|demangled
index|[
name|j
index|]
operator|=
name|mangled
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|j
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|demangled
index|[
name|j
index|]
operator|=
literal|'\000'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|demangled
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|isupper
argument_list|(
name|demangled
index|[
name|i
index|]
argument_list|)
operator|||
name|demangled
index|[
name|i
index|]
operator|==
literal|' '
condition|)
goto|goto
name|Suppress
goto|;
return|return
name|demangled
return|;
name|Suppress
label|:
name|GROW_VECT
argument_list|(
name|demangling_buffer
argument_list|,
name|demangling_buffer_size
argument_list|,
name|strlen
argument_list|(
name|mangled
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|demangling_buffer
expr_stmt|;
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
name|strcpy
argument_list|(
name|demangled
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|demangled
argument_list|,
literal|"<%s>"
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
return|return
name|demangled
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff SYM_NAME matches NAME, ignoring any trailing  * suffixes that encode debugging information or leading _ada_ on  * SYM_NAME (see is_name_suffix commentary for the debugging  * information that is ignored).  If WILD, then NAME need only match a  * suffix of SYM_NAME minus the same suffixes. Also returns 0 if  * either argument is NULL. */
end_comment

begin_function
name|int
name|ada_match_name
parameter_list|(
specifier|const
name|char
modifier|*
name|sym_name
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|wild
parameter_list|)
block|{
if|if
condition|(
name|sym_name
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|wild
condition|)
return|return
name|wild_match
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|sym_name
argument_list|)
return|;
else|else
block|{
name|int
name|len_name
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
operator|(
name|DEPRECATED_STREQN
argument_list|(
name|sym_name
argument_list|,
name|name
argument_list|,
name|len_name
argument_list|)
operator|&&
name|is_name_suffix
argument_list|(
name|sym_name
operator|+
name|len_name
argument_list|)
operator|)
operator|||
operator|(
name|DEPRECATED_STREQN
argument_list|(
name|sym_name
argument_list|,
literal|"_ada_"
argument_list|,
literal|5
argument_list|)
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|sym_name
operator|+
literal|5
argument_list|,
name|name
argument_list|,
name|len_name
argument_list|)
operator|&&
name|is_name_suffix
argument_list|(
name|sym_name
operator|+
name|len_name
operator|+
literal|5
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* True (non-zero) iff in Ada mode, the symbol SYM should be    suppressed in info listings. */
end_comment

begin_function
name|int
name|ada_suppress_symbol_printing
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_DOMAIN
condition|)
return|return
literal|1
return|;
else|else
return|return
name|is_suppressed_name
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Arrays */
end_comment

begin_comment
comment|/* Names of MAX_ADA_DIMENS bounds in P_BOUNDS fields of     array descriptors.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bound_name
index|[]
init|=
block|{
literal|"LB0"
block|,
literal|"UB0"
block|,
literal|"LB1"
block|,
literal|"UB1"
block|,
literal|"LB2"
block|,
literal|"UB2"
block|,
literal|"LB3"
block|,
literal|"UB3"
block|,
literal|"LB4"
block|,
literal|"UB4"
block|,
literal|"LB5"
block|,
literal|"UB5"
block|,
literal|"LB6"
block|,
literal|"UB6"
block|,
literal|"LB7"
block|,
literal|"UB7"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of array dimensions we are prepared to handle.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ADA_DIMENS
value|(sizeof(bound_name) / (2*sizeof(char*)))
end_define

begin_comment
comment|/* Like modify_field, but allows bitpos> wordlength. */
end_comment

begin_function
specifier|static
name|void
name|modify_general_field
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|LONGEST
name|fieldval
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|int
name|bitsize
parameter_list|)
block|{
name|modify_field
argument_list|(
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
name|bitpos
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|)
argument_list|,
name|fieldval
argument_list|,
name|bitpos
operator|%
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|)
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The desc_* routines return primitive portions of array descriptors     (fat pointers). */
end_comment

begin_comment
comment|/* The descriptor or array type, if any, indicated by TYPE; removes    level of indirection, if needed. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|desc_base_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* True iff TYPE indicates a "thin" array pointer type. */
end_comment

begin_function
specifier|static
name|int
name|is_thin_pntr
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|is_suffix
argument_list|(
name|ada_type_name
argument_list|(
name|desc_base_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|"___XUT"
argument_list|)
operator|||
name|is_suffix
argument_list|(
name|ada_type_name
argument_list|(
name|desc_base_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|"___XUT___XVE"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The descriptor type for thin pointer type TYPE. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|thin_descriptor_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|base_type
init|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|is_suffix
argument_list|(
name|ada_type_name
argument_list|(
name|base_type
argument_list|)
argument_list|,
literal|"___XVE"
argument_list|)
condition|)
return|return
name|base_type
return|;
else|else
block|{
name|struct
name|type
modifier|*
name|alt_type
init|=
name|ada_find_parallel_type
argument_list|(
name|base_type
argument_list|,
literal|"___XVE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|alt_type
operator|==
name|NULL
condition|)
return|return
name|base_type
return|;
else|else
return|return
name|alt_type
return|;
block|}
block|}
end_function

begin_comment
comment|/* A pointer to the array data for thin-pointer value VAL. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|thin_data_pntr
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|value_cast
argument_list|(
name|desc_data_type
argument_list|(
name|thin_descriptor_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|value_copy
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
else|else
return|return
name|value_from_longest
argument_list|(
name|desc_data_type
argument_list|(
name|thin_descriptor_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* True iff TYPE indicates a "thick" array pointer type. */
end_comment

begin_function
specifier|static
name|int
name|is_thick_pntr
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
literal|"P_BOUNDS"
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is the type of an array descriptor (fat or thin pointer) or a     pointer to one, the type of its bounds data; otherwise, NULL. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|desc_bounds_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|r
decl_stmt|;
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
name|is_thin_pntr
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|thin_descriptor_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|r
operator|=
name|lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
literal|"BOUNDS"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
return|return
name|check_typedef
argument_list|(
name|r
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|r
operator|=
name|lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
literal|"P_BOUNDS"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
return|return
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* If ARR is an array descriptor (fat or thin pointer), or pointer to    one, a pointer to its bounds data.   Otherwise NULL. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|desc_bounds
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_thin_pntr
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|bounds_type
init|=
name|desc_bounds_type
argument_list|(
name|thin_descriptor_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|LONGEST
name|addr
decl_stmt|;
if|if
condition|(
name|desc_bounds_type
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Bad GNAT array descriptor"
argument_list|)
expr_stmt|;
comment|/* NOTE: The following calculation is not really kosher, but          since desc_type is an XVE-encoded type (and shouldn't be),          the correct calculation is a real pain. FIXME (and fix GCC). */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|addr
operator|=
name|value_as_long
argument_list|(
name|arr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arr
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arr
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|bounds_type
argument_list|)
argument_list|,
name|addr
operator|-
name|TYPE_LENGTH
argument_list|(
name|bounds_type
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_thick_pntr
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|value_struct_elt
argument_list|(
operator|&
name|arr
argument_list|,
name|NULL
argument_list|,
literal|"P_BOUNDS"
argument_list|,
name|NULL
argument_list|,
literal|"Bad GNAT array descriptor"
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is the type of an array-descriptor (fat pointer), the bit    position of the field containing the address of the bounds data. */
end_comment

begin_function
specifier|static
name|int
name|fat_pntr_bounds_bitpos
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|TYPE_FIELD_BITPOS
argument_list|(
name|desc_base_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is the type of an array-descriptor (fat pointer), the bit    size of the field containing the address of the bounds data. */
end_comment

begin_function
specifier|static
name|int
name|fat_pntr_bounds_bitsize
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
return|return
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
literal|8
operator|*
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is the type of an array descriptor (fat or thin pointer) or a     pointer to one, the type of its array data (a    pointer-to-array-with-no-bounds type); otherwise,  NULL.  Use    ada_type_of_array to get an array type with bounds data. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|desc_data_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* NOTE: The following is bogus; see comment in desc_bounds. */
if|if
condition|(
name|is_thin_pntr
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|lookup_pointer_type
argument_list|(
name|desc_base_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|thin_descriptor_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|is_thick_pntr
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
literal|"P_ARRAY"
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* If ARR is an array descriptor (fat or thin pointer), a pointer to    its array data.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|desc_data
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_thin_pntr
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|thin_data_pntr
argument_list|(
name|arr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|is_thick_pntr
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|value_struct_elt
argument_list|(
operator|&
name|arr
argument_list|,
name|NULL
argument_list|,
literal|"P_ARRAY"
argument_list|,
name|NULL
argument_list|,
literal|"Bad GNAT array descriptor"
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is the type of an array-descriptor (fat pointer), the bit    position of the field containing the address of the data. */
end_comment

begin_function
specifier|static
name|int
name|fat_pntr_data_bitpos
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|TYPE_FIELD_BITPOS
argument_list|(
name|desc_base_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is the type of an array-descriptor (fat pointer), the bit    size of the field containing the address of the data. */
end_comment

begin_function
specifier|static
name|int
name|fat_pntr_data_bitsize
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
return|return
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|TARGET_CHAR_BIT
operator|*
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If BOUNDS is an array-bounds structure (or pointer to one), return     the Ith lower bound stored in it, if WHICH is 0, and the Ith upper    bound, if WHICH is 1.  The first bound is I=1. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|desc_one_bound
parameter_list|(
name|struct
name|value
modifier|*
name|bounds
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|which
parameter_list|)
block|{
return|return
name|value_struct_elt
argument_list|(
operator|&
name|bounds
argument_list|,
name|NULL
argument_list|,
name|bound_name
index|[
literal|2
operator|*
name|i
operator|+
name|which
operator|-
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|"Bad GNAT array descriptor bounds"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If BOUNDS is an array-bounds structure type, return the bit position    of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper    bound, if WHICH is 1.  The first bound is I=1. */
end_comment

begin_function
specifier|static
name|int
name|desc_bound_bitpos
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|which
parameter_list|)
block|{
return|return
name|TYPE_FIELD_BITPOS
argument_list|(
name|desc_base_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|2
operator|*
name|i
operator|+
name|which
operator|-
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If BOUNDS is an array-bounds structure type, return the bit field size    of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper    bound, if WHICH is 1.  The first bound is I=1. */
end_comment

begin_function
specifier|static
name|int
name|desc_bound_bitsize
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|2
operator|*
name|i
operator|+
name|which
operator|-
literal|2
argument_list|)
operator|>
literal|0
condition|)
return|return
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|2
operator|*
name|i
operator|+
name|which
operator|-
literal|2
argument_list|)
return|;
else|else
return|return
literal|8
operator|*
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|2
operator|*
name|i
operator|+
name|which
operator|-
literal|2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is the type of an array-bounds structure, the type of its    Ith bound (numbering from 1). Otherwise, NULL. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|desc_index_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
return|return
name|lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
name|bound_name
index|[
literal|2
operator|*
name|i
operator|-
literal|2
index|]
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The number of index positions in the array-bounds type TYPE.  0    if TYPE is NULL. */
end_comment

begin_function
specifier|static
name|int
name|desc_arity
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
return|return
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|/
literal|2
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Non-zero iff type is a simple array type (or pointer to one). */
end_comment

begin_function
name|int
name|ada_is_simple_array
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Non-zero iff type belongs to a GNAT array descriptor. */
end_comment

begin_function
name|int
name|ada_is_array_descriptor
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|data_type
init|=
name|desc_data_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|data_type
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|data_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_TARGET_TYPE
argument_list|(
name|data_type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|data_type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|)
operator|||
name|TYPE_CODE
argument_list|(
name|data_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|)
operator|&&
name|desc_arity
argument_list|(
name|desc_bounds_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Non-zero iff type is a partially mal-formed GNAT array    descriptor.  (FIXME: This is to compensate for some problems with     debugging output from GNAT.  Re-examine periodically to see if it    is still needed. */
end_comment

begin_function
name|int
name|ada_is_bogus_array_descriptor
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
operator|(
name|lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
literal|"P_BOUNDS"
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL
operator|||
name|lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
literal|"P_ARRAY"
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ada_is_array_descriptor
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If ARR has a record type in the form of a standard GNAT array descriptor,     (fat pointer) returns the type of the array data described---specifically,    a pointer-to-array type.  If BOUNDS is non-zero, the bounds data are filled     in from the descriptor; otherwise, they are left unspecified.  If    the ARR denotes a null array descriptor and BOUNDS is non-zero,     returns NULL.  The result is simply the type of ARR if ARR is not     a descriptor.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_type_of_array
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|,
name|int
name|bounds
parameter_list|)
block|{
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
condition|)
return|return
name|decode_packed_array_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|ada_is_array_descriptor
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
condition|)
return|return
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
return|;
if|if
condition|(
operator|!
name|bounds
condition|)
return|return
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|desc_data_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
block|{
name|struct
name|type
modifier|*
name|elt_type
decl_stmt|;
name|int
name|arity
decl_stmt|;
name|struct
name|value
modifier|*
name|descriptor
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objf
init|=
name|TYPE_OBJFILE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
decl_stmt|;
name|elt_type
operator|=
name|ada_array_element_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arity
operator|=
name|ada_array_arity
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt_type
operator|==
name|NULL
operator|||
name|arity
operator|==
literal|0
condition|)
return|return
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
return|;
name|descriptor
operator|=
name|desc_bounds
argument_list|(
name|arr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_as_long
argument_list|(
name|descriptor
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|arity
operator|>
literal|0
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|alloc_type
argument_list|(
name|objf
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|array_type
init|=
name|alloc_type
argument_list|(
name|objf
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|low
init|=
name|desc_one_bound
argument_list|(
name|descriptor
argument_list|,
name|arity
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|high
init|=
name|desc_one_bound
argument_list|(
name|descriptor
argument_list|,
name|arity
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|arity
operator|-=
literal|1
expr_stmt|;
name|create_range_type
argument_list|(
name|range_type
argument_list|,
name|VALUE_TYPE
argument_list|(
name|low
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|low
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|elt_type
operator|=
name|create_array_type
argument_list|(
name|array_type
argument_list|,
name|elt_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup_pointer_type
argument_list|(
name|elt_type
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* If ARR does not represent an array, returns ARR unchanged.    Otherwise, returns either a standard GDB array with bounds set     appropriately or, if ARR is a non-null fat pointer, a pointer to a standard     GDB array.  Returns NULL if ARR is a null fat pointer. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_coerce_to_simple_array_ptr
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|)
block|{
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|arrType
init|=
name|ada_type_of_array
argument_list|(
name|arr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|arrType
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|value_cast
argument_list|(
name|arrType
argument_list|,
name|value_copy
argument_list|(
name|desc_data
argument_list|(
name|arr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
condition|)
return|return
name|decode_packed_array
argument_list|(
name|arr
argument_list|)
return|;
else|else
return|return
name|arr
return|;
block|}
end_function

begin_comment
comment|/* If ARR does not represent an array, returns ARR unchanged.    Otherwise, returns a standard GDB array describing ARR (which may    be ARR itself if it already is in the proper form). */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_coerce_to_simple_array
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|)
block|{
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|arrVal
init|=
name|ada_coerce_to_simple_array_ptr
argument_list|(
name|arr
argument_list|)
decl_stmt|;
if|if
condition|(
name|arrVal
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Bounds unavailable for null array pointer."
argument_list|)
expr_stmt|;
return|return
name|value_ind
argument_list|(
name|arrVal
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
condition|)
return|return
name|decode_packed_array
argument_list|(
name|arr
argument_list|)
return|;
else|else
return|return
name|arr
return|;
block|}
end_function

begin_comment
comment|/* If TYPE represents a GNAT array type, return it translated to an    ordinary GDB array type (possibly with BITSIZE fields indicating    packing). For other types, is the identity. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_coerce_to_simple_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|struct
name|value
modifier|*
name|dummy
init|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|result
decl_stmt|;
name|VALUE_TYPE
argument_list|(
name|dummy
argument_list|)
operator|=
name|type
expr_stmt|;
name|result
operator|=
name|ada_type_of_array
argument_list|(
name|dummy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Non-zero iff TYPE represents a standard GNAT packed-array type. */
end_comment

begin_function
name|int
name|ada_is_packed_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|ada_type_name
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|strstr
argument_list|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"___XP"
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given that TYPE is a standard GDB array type with all bounds filled    in, and that the element size of its ultimate scalar constituents    (that is, either its elements, or, if it is an array of arrays, its    elements' elements, etc.) is *ELT_BITS, return an identical type,    but with the bit sizes of its elements (and those of any    constituent arrays) recorded in the BITSIZE components of its    TYPE_FIELD_BITSIZE values, and with *ELT_BITS set to its total size     in bits. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|packed_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|long
modifier|*
name|elt_bits
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|new_elt_type
decl_stmt|;
name|struct
name|type
modifier|*
name|new_type
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
condition|)
return|return
name|type
return|;
name|new_type
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|new_elt_type
operator|=
name|packed_array_type
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|elt_bits
argument_list|)
expr_stmt|;
name|create_array_type
argument_list|(
name|new_type
argument_list|,
name|new_elt_type
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|new_type
argument_list|,
literal|0
argument_list|)
operator|=
operator|*
name|elt_bits
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|new_type
argument_list|)
operator|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|low_bound
operator|=
name|high_bound
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|high_bound
operator|<
name|low_bound
condition|)
operator|*
name|elt_bits
operator|=
name|TYPE_LENGTH
argument_list|(
name|new_type
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|elt_bits
operator|*=
operator|(
name|high_bound
operator|-
name|low_bound
operator|+
literal|1
operator|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|new_type
argument_list|)
operator|=
operator|(
operator|*
name|elt_bits
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
block|}
comment|/*  TYPE_FLAGS (new_type) |= TYPE_FLAG_FIXED_INSTANCE; */
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
return|return
name|new_type
return|;
block|}
end_function

begin_comment
comment|/* The array type encoded by TYPE, where ada_is_packed_array_type (TYPE).  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_packed_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|blocks
decl_stmt|;
specifier|const
name|char
modifier|*
name|raw_name
init|=
name|ada_type_name
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|raw_name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|strstr
argument_list|(
name|raw_name
argument_list|,
literal|"___XP"
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|shadow_type
decl_stmt|;
name|long
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|raw_name
argument_list|,
name|tail
operator|-
name|raw_name
argument_list|)
expr_stmt|;
name|name
index|[
name|tail
operator|-
name|raw_name
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* NOTE: Use ada_lookup_symbol_list because of bug in some versions    * of gcc (Solaris, e.g.). FIXME when compiler is fixed. */
name|n
operator|=
name|ada_lookup_symbol_list
argument_list|(
name|name
argument_list|,
name|get_selected_block
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|&
name|syms
argument_list|,
operator|&
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|syms
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
name|ada_type_name
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|n
condition|)
block|{
name|warning
argument_list|(
literal|"could not find bounds information on packed array"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|shadow_type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|shadow_type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
condition|)
block|{
name|warning
argument_list|(
literal|"could not understand bounds information on packed array"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|tail
operator|+
sizeof|sizeof
argument_list|(
literal|"___XP"
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|bits
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"could not understand bit size information on packed array"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|packed_array_type
argument_list|(
name|shadow_type
argument_list|,
operator|&
name|bits
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given that ARR is a struct value* indicating a GNAT packed array,    returns a simple array that denotes that array.  Its type is a    standard GDB array type except that the BITSIZEs of the array    target types are set to the number of bits in each element, and the    type length is set appropriately. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|decode_packed_array
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|decode_packed_array_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"can't unpack array"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|coerce_unspec_val_to_type
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The value of the element of packed array ARR at the ARITY indices    given in IND.   ARR must be a simple array. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_subscript_packed
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|,
name|int
name|arity
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|ind
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|bits
decl_stmt|,
name|elt_off
decl_stmt|,
name|bit_off
decl_stmt|;
name|long
name|elt_total_bit_offset
decl_stmt|;
name|struct
name|type
modifier|*
name|elt_type
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
name|elt_total_bit_offset
operator|=
literal|0
expr_stmt|;
name|elt_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arity
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_FIELD_BITSIZE
argument_list|(
name|elt_type
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"attempt to do packed indexing of something other than a packed array"
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_INDEX_TYPE
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
name|LONGEST
name|lowerbound
decl_stmt|,
name|upperbound
decl_stmt|;
name|LONGEST
name|idx
decl_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|lowerbound
argument_list|,
operator|&
name|upperbound
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"don't know bounds of array"
argument_list|)
expr_stmt|;
name|lowerbound
operator|=
name|upperbound
operator|=
literal|0
expr_stmt|;
block|}
name|idx
operator|=
name|value_as_long
argument_list|(
name|value_pos_atr
argument_list|(
name|ind
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|lowerbound
operator|||
name|idx
operator|>
name|upperbound
condition|)
name|warning
argument_list|(
literal|"packed array index %ld out of bounds"
argument_list|,
operator|(
name|long
operator|)
name|idx
argument_list|)
expr_stmt|;
name|bits
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|elt_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elt_total_bit_offset
operator|+=
operator|(
name|idx
operator|-
name|lowerbound
operator|)
operator|*
name|bits
expr_stmt|;
name|elt_type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|elt_off
operator|=
name|elt_total_bit_offset
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|bit_off
operator|=
name|elt_total_bit_offset
operator|%
name|HOST_CHAR_BIT
expr_stmt|;
name|v
operator|=
name|ada_value_primitive_packed_val
argument_list|(
name|arr
argument_list|,
name|NULL
argument_list|,
name|elt_off
argument_list|,
name|bit_off
argument_list|,
name|bits
argument_list|,
name|elt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arr
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
else|else
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arr
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Non-zero iff TYPE includes negative integer values. */
end_comment

begin_function
specifier|static
name|int
name|has_negatives
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|TYPE_CODE_INT
case|:
return|return
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
return|;
case|case
name|TYPE_CODE_RANGE
case|:
return|return
name|TYPE_LOW_BOUND
argument_list|(
name|type
argument_list|)
operator|<
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new value of type TYPE from the contents of OBJ starting    at byte OFFSET, and bit offset BIT_OFFSET within that byte,    proceeding for BIT_SIZE bits.  If OBJ is an lval in memory, then    assigning through the result will set the field fetched from. OBJ    may also be NULL, in which case, VALADDR+OFFSET must address the    start of storage containing the packed value.  The value returned     in this case is never an lval.       Assumes 0<= BIT_OFFSET< HOST_CHAR_BIT. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_value_primitive_packed_val
parameter_list|(
name|struct
name|value
modifier|*
name|obj
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|bit_offset
parameter_list|,
name|int
name|bit_size
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|int
name|src
decl_stmt|,
comment|/* Index into the source area. */
name|targ
decl_stmt|,
comment|/* Index into the target area. */
name|i
decl_stmt|,
name|srcBitsLeft
decl_stmt|,
comment|/* Number of source bits left to move. */
name|nsrc
decl_stmt|,
name|ntarg
decl_stmt|,
comment|/* Number of source and target bytes. */
name|unusedLS
decl_stmt|,
comment|/* Number of bits in next significant 				 * byte of source that are unused. */
name|accumSize
decl_stmt|;
comment|/* Number of meaningful bits in accum */
name|unsigned
name|char
modifier|*
name|bytes
decl_stmt|;
comment|/* First byte containing data to unpack. */
name|unsigned
name|char
modifier|*
name|unpacked
decl_stmt|;
name|unsigned
name|long
name|accum
decl_stmt|;
comment|/* Staging area for bits being transferred */
name|unsigned
name|char
name|sign
decl_stmt|;
name|int
name|len
init|=
operator|(
name|bit_size
operator|+
name|bit_offset
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
literal|8
decl_stmt|;
comment|/* Transmit bytes from least to most significant; delta is the    * direction the indices move. */
name|int
name|delta
init|=
name|BITS_BIG_ENDIAN
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|valaddr
operator|+
name|offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|v
operator|=
name|value_at
argument_list|(
name|type
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|obj
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|obj
argument_list|)
operator|+
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
argument_list|,
name|bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|obj
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|obj
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|obj
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|obj
argument_list|)
operator|+
name|offset
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|=
name|bit_offset
operator|+
name|VALUE_BITPOS
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|bit_size
expr_stmt|;
if|if
condition|(
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|>=
name|HOST_CHAR_BIT
condition|)
block|{
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|-=
name|HOST_CHAR_BIT
expr_stmt|;
block|}
block|}
else|else
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|bit_size
expr_stmt|;
name|unpacked
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|srcBitsLeft
operator|=
name|bit_size
expr_stmt|;
name|nsrc
operator|=
name|len
expr_stmt|;
name|ntarg
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bit_size
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|unpacked
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
elseif|else
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
name|src
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|has_negatives
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|(
name|bytes
index|[
literal|0
index|]
operator|<<
name|bit_offset
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|sign
operator|=
operator|~
literal|0
expr_stmt|;
name|unusedLS
operator|=
operator|(
name|HOST_CHAR_BIT
operator|-
operator|(
name|bit_size
operator|+
name|bit_offset
operator|)
operator|%
name|HOST_CHAR_BIT
operator|)
operator|%
name|HOST_CHAR_BIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
comment|/* Non-scalar values must be aligned at a byte boundary. */
name|accumSize
operator|=
operator|(
name|HOST_CHAR_BIT
operator|-
name|bit_size
operator|%
name|HOST_CHAR_BIT
operator|)
operator|%
name|HOST_CHAR_BIT
expr_stmt|;
comment|/* And are placed at the beginning (most-significant) bytes 	   * of the target. */
name|targ
operator|=
name|src
expr_stmt|;
break|break;
default|default:
name|accumSize
operator|=
literal|0
expr_stmt|;
name|targ
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|int
name|sign_bit_offset
init|=
operator|(
name|bit_size
operator|+
name|bit_offset
operator|-
literal|1
operator|)
operator|%
literal|8
decl_stmt|;
name|src
operator|=
name|targ
operator|=
literal|0
expr_stmt|;
name|unusedLS
operator|=
name|bit_offset
expr_stmt|;
name|accumSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_negatives
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|bytes
index|[
name|len
operator|-
literal|1
index|]
operator|&
operator|(
literal|1
operator|<<
name|sign_bit_offset
operator|)
operator|)
condition|)
name|sign
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|accum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nsrc
operator|>
literal|0
condition|)
block|{
comment|/* Mask for removing bits of the next source byte that are not        * part of the value. */
name|unsigned
name|int
name|unusedMSMask
init|=
operator|(
literal|1
operator|<<
operator|(
name|srcBitsLeft
operator|>=
name|HOST_CHAR_BIT
condition|?
name|HOST_CHAR_BIT
else|:
name|srcBitsLeft
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* Sign-extend bits for this byte. */
name|unsigned
name|int
name|signMask
init|=
name|sign
operator|&
operator|~
name|unusedMSMask
decl_stmt|;
name|accum
operator||=
operator|(
operator|(
operator|(
name|bytes
index|[
name|src
index|]
operator|>>
name|unusedLS
operator|)
operator|&
name|unusedMSMask
operator|)
operator||
name|signMask
operator|)
operator|<<
name|accumSize
expr_stmt|;
name|accumSize
operator|+=
name|HOST_CHAR_BIT
operator|-
name|unusedLS
expr_stmt|;
if|if
condition|(
name|accumSize
operator|>=
name|HOST_CHAR_BIT
condition|)
block|{
name|unpacked
index|[
name|targ
index|]
operator|=
name|accum
operator|&
operator|~
operator|(
operator|~
literal|0L
operator|<<
name|HOST_CHAR_BIT
operator|)
expr_stmt|;
name|accumSize
operator|-=
name|HOST_CHAR_BIT
expr_stmt|;
name|accum
operator|>>=
name|HOST_CHAR_BIT
expr_stmt|;
name|ntarg
operator|-=
literal|1
expr_stmt|;
name|targ
operator|+=
name|delta
expr_stmt|;
block|}
name|srcBitsLeft
operator|-=
name|HOST_CHAR_BIT
operator|-
name|unusedLS
expr_stmt|;
name|unusedLS
operator|=
literal|0
expr_stmt|;
name|nsrc
operator|-=
literal|1
expr_stmt|;
name|src
operator|+=
name|delta
expr_stmt|;
block|}
while|while
condition|(
name|ntarg
operator|>
literal|0
condition|)
block|{
name|accum
operator||=
name|sign
operator|<<
name|accumSize
expr_stmt|;
name|unpacked
index|[
name|targ
index|]
operator|=
name|accum
operator|&
operator|~
operator|(
operator|~
literal|0L
operator|<<
name|HOST_CHAR_BIT
operator|)
expr_stmt|;
name|accumSize
operator|-=
name|HOST_CHAR_BIT
expr_stmt|;
name|accum
operator|>>=
name|HOST_CHAR_BIT
expr_stmt|;
name|ntarg
operator|-=
literal|1
expr_stmt|;
name|targ
operator|+=
name|delta
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Move N bits from SOURCE, starting at bit offset SRC_OFFSET to    TARGET, starting at bit offset TARG_OFFSET.  SOURCE and TARGET must    not overlap. */
end_comment

begin_function
specifier|static
name|void
name|move_bits
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
name|int
name|targ_offset
parameter_list|,
name|char
modifier|*
name|source
parameter_list|,
name|int
name|src_offset
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|accum
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|accum_bits
decl_stmt|,
name|chunk_size
decl_stmt|;
name|target
operator|+=
name|targ_offset
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|targ_offset
operator|%=
name|HOST_CHAR_BIT
expr_stmt|;
name|source
operator|+=
name|src_offset
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|src_offset
operator|%=
name|HOST_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
name|accum
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|source
expr_stmt|;
name|source
operator|+=
literal|1
expr_stmt|;
name|accum_bits
operator|=
name|HOST_CHAR_BIT
operator|-
name|src_offset
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|unused_right
decl_stmt|;
name|accum
operator|=
operator|(
name|accum
operator|<<
name|HOST_CHAR_BIT
operator|)
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|*
name|source
expr_stmt|;
name|accum_bits
operator|+=
name|HOST_CHAR_BIT
expr_stmt|;
name|source
operator|+=
literal|1
expr_stmt|;
name|chunk_size
operator|=
name|HOST_CHAR_BIT
operator|-
name|targ_offset
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|>
name|n
condition|)
name|chunk_size
operator|=
name|n
expr_stmt|;
name|unused_right
operator|=
name|HOST_CHAR_BIT
operator|-
operator|(
name|chunk_size
operator|+
name|targ_offset
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|chunk_size
operator|)
operator|-
literal|1
operator|)
operator|<<
name|unused_right
expr_stmt|;
operator|*
name|target
operator|=
operator|(
operator|*
name|target
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
operator|(
name|accum
operator|>>
operator|(
name|accum_bits
operator|-
name|chunk_size
operator|-
name|unused_right
operator|)
operator|)
operator|&
name|mask
operator|)
expr_stmt|;
name|n
operator|-=
name|chunk_size
expr_stmt|;
name|accum_bits
operator|-=
name|chunk_size
expr_stmt|;
name|target
operator|+=
literal|1
expr_stmt|;
name|targ_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|accum
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|source
operator|>>
name|src_offset
expr_stmt|;
name|source
operator|+=
literal|1
expr_stmt|;
name|accum_bits
operator|=
name|HOST_CHAR_BIT
operator|-
name|src_offset
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|accum
operator|=
name|accum
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|source
operator|<<
name|accum_bits
operator|)
expr_stmt|;
name|accum_bits
operator|+=
name|HOST_CHAR_BIT
expr_stmt|;
name|source
operator|+=
literal|1
expr_stmt|;
name|chunk_size
operator|=
name|HOST_CHAR_BIT
operator|-
name|targ_offset
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|>
name|n
condition|)
name|chunk_size
operator|=
name|n
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|chunk_size
operator|)
operator|-
literal|1
operator|)
operator|<<
name|targ_offset
expr_stmt|;
operator|*
name|target
operator|=
operator|(
operator|*
name|target
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
operator|(
name|accum
operator|<<
name|targ_offset
operator|)
operator|&
name|mask
operator|)
expr_stmt|;
name|n
operator|-=
name|chunk_size
expr_stmt|;
name|accum_bits
operator|-=
name|chunk_size
expr_stmt|;
name|accum
operator|>>=
name|chunk_size
expr_stmt|;
name|target
operator|+=
literal|1
expr_stmt|;
name|targ_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the contents of FROMVAL into the location of TOVAL.    Return a new value with the location of TOVAL and contents of    FROMVAL.   Handles assignment into packed fields that have    floating-point or non-scalar types. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|ada_value_assign
parameter_list|(
name|struct
name|value
modifier|*
name|toval
parameter_list|,
name|struct
name|value
modifier|*
name|fromval
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|toval
argument_list|)
decl_stmt|;
name|int
name|bits
init|=
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|toval
operator|->
name|modifiable
condition|)
name|error
argument_list|(
literal|"Left operand of assignment is not a modifiable lvalue."
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|toval
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|toval
argument_list|)
operator|==
name|lval_memory
operator|&&
name|bits
operator|>
literal|0
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
condition|)
block|{
name|int
name|len
init|=
operator|(
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
operator|+
name|bits
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
name|fromval
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|move_bits
argument_list|(
name|buffer
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|fromval
argument_list|)
argument_list|)
operator|*
name|TARGET_CHAR_BIT
operator|-
name|bits
argument_list|,
name|bits
argument_list|)
expr_stmt|;
else|else
name|move_bits
argument_list|(
name|buffer
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|value_copy
argument_list|(
name|toval
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|val
return|;
block|}
return|return
name|value_assign
argument_list|(
name|toval
argument_list|,
name|fromval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The value of the element of array ARR at the ARITY indices given in IND.     ARR may be either a simple array, GNAT array descriptor, or pointer     thereto.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_value_subscript
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|,
name|int
name|arity
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|ind
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|struct
name|value
modifier|*
name|elt
decl_stmt|;
name|struct
name|type
modifier|*
name|elt_type
decl_stmt|;
name|elt
operator|=
name|ada_coerce_to_simple_array
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|elt_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_FIELD_BITSIZE
argument_list|(
name|elt_type
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
return|return
name|value_subscript_packed
argument_list|(
name|elt
argument_list|,
name|arity
argument_list|,
name|ind
argument_list|)
return|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|arity
condition|;
name|k
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
condition|)
name|error
argument_list|(
literal|"too many subscripts (%d expected)"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|elt
operator|=
name|value_subscript
argument_list|(
name|elt
argument_list|,
name|value_pos_atr
argument_list|(
name|ind
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|elt
return|;
block|}
end_function

begin_comment
comment|/* Assuming ARR is a pointer to a standard GDB array of type TYPE, the    value of the element of *ARR at the ARITY indices given in    IND. Does not read the entire array into memory. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_value_ptr_subscript
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|arity
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|ind
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|arity
condition|;
name|k
operator|+=
literal|1
control|)
block|{
name|LONGEST
name|lwb
decl_stmt|,
name|upb
decl_stmt|;
name|struct
name|value
modifier|*
name|idx
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
condition|)
name|error
argument_list|(
literal|"too many subscripts (%d expected)"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|arr
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|value_copy
argument_list|(
name|arr
argument_list|)
argument_list|)
expr_stmt|;
name|get_discrete_bounds
argument_list|(
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|lwb
argument_list|,
operator|&
name|upb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
literal|0
condition|)
name|idx
operator|=
name|ind
index|[
name|k
index|]
expr_stmt|;
else|else
name|idx
operator|=
name|value_sub
argument_list|(
name|ind
index|[
name|k
index|]
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
name|lwb
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|=
name|value_add
argument_list|(
name|arr
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|value_ind
argument_list|(
name|arr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If type is a record type in the form of a standard GNAT array    descriptor, returns the number of dimensions for type.  If arr is a    simple array, returns the number of "array of"s that prefix its    type designation. Otherwise, returns 0. */
end_comment

begin_function
name|int
name|ada_array_arity
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|arity
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|arity
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
return|return
name|desc_arity
argument_list|(
name|desc_bounds_type
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|arity
operator|+=
literal|1
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arity
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is a record type in the form of a standard GNAT array    descriptor or a simple array type, returns the element type for    TYPE after indexing by NINDICES indices, or by all indices if    NINDICES is -1. Otherwise, returns NULL. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_array_element_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|nindices
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|int
name|k
decl_stmt|;
name|struct
name|type
modifier|*
name|p_array_type
decl_stmt|;
name|p_array_type
operator|=
name|desc_data_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|k
operator|=
name|ada_array_arity
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Initially p_array_type = elt_type(*)[]...(k times)...[] */
if|if
condition|(
name|nindices
operator|>=
literal|0
operator|&&
name|k
operator|>
name|nindices
condition|)
name|k
operator|=
name|nindices
expr_stmt|;
name|p_array_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|p_array_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
operator|&&
name|p_array_type
operator|!=
name|NULL
condition|)
block|{
name|p_array_type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|p_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|p_array_type
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
while|while
condition|(
name|nindices
operator|!=
literal|0
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|nindices
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The type of nth index in arrays of given type (n numbering from 1).  Does     not examine memory. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_index_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|type
operator|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|ada_array_arity
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ada_is_simple_array
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|1
control|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|desc_index_type
argument_list|(
name|desc_bounds_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given that arr is an array type, returns the lower bound of the    Nth index (numbering from 1) if WHICH is 0, and the upper bound if    WHICH is 1. This returns bounds 0 .. -1 if ARR_TYPE is an    array-descriptor type.  If TYPEP is non-null, *TYPEP is set to the     bounds type.  It works for other arrays with bounds supplied by     run-time quantities other than discriminants. */
end_comment

begin_function
name|LONGEST
name|ada_array_bound_from_type
parameter_list|(
name|struct
name|type
modifier|*
name|arr_type
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|which
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|typep
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type_desc
decl_stmt|;
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|arr_type
argument_list|)
condition|)
name|arr_type
operator|=
name|decode_packed_array_type
argument_list|(
name|arr_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arr_type
operator|==
name|NULL
operator|||
operator|!
name|ada_is_simple_array
argument_list|(
name|arr_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|typep
operator|!=
name|NULL
condition|)
operator|*
name|typep
operator|=
name|builtin_type_int
expr_stmt|;
return|return
operator|(
name|LONGEST
operator|)
operator|-
name|which
return|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|arr_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arr_type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|arr_type
expr_stmt|;
name|index_type_desc
operator|=
name|ada_find_parallel_type
argument_list|(
name|type
argument_list|,
literal|"___XA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type_desc
operator|==
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|1
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|1
expr_stmt|;
block|}
name|range_type
operator|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|index_type
argument_list|)
operator|==
name|TYPE_CODE_UNDEF
condition|)
name|index_type
operator|=
name|builtin_type_long
expr_stmt|;
if|if
condition|(
name|typep
operator|!=
name|NULL
condition|)
operator|*
name|typep
operator|=
name|index_type
expr_stmt|;
return|return
call|(
name|LONGEST
call|)
argument_list|(
name|which
operator|==
literal|0
condition|?
name|TYPE_LOW_BOUND
argument_list|(
name|range_type
argument_list|)
else|:
name|TYPE_HIGH_BOUND
argument_list|(
name|range_type
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|index_type
init|=
name|to_fixed_range_type
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|index_type_desc
argument_list|,
name|n
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|TYPE_OBJFILE
argument_list|(
name|arr_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|typep
operator|!=
name|NULL
condition|)
operator|*
name|typep
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
return|return
call|(
name|LONGEST
call|)
argument_list|(
name|which
operator|==
literal|0
condition|?
name|TYPE_LOW_BOUND
argument_list|(
name|index_type
argument_list|)
else|:
name|TYPE_HIGH_BOUND
argument_list|(
name|index_type
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given that arr is an array value, returns the lower bound of the    nth index (numbering from 1) if which is 0, and the upper bound if    which is 1. This routine will also work for arrays with bounds    supplied by run-time quantities other than discriminants. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_array_bound
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|arr_type
init|=
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|arr_type
argument_list|)
condition|)
return|return
name|ada_array_bound
argument_list|(
name|decode_packed_array
argument_list|(
name|arr
argument_list|)
argument_list|,
name|n
argument_list|,
name|which
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ada_is_simple_array
argument_list|(
name|arr_type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|v
init|=
name|ada_array_bound_from_type
argument_list|(
name|arr_type
argument_list|,
name|n
argument_list|,
name|which
argument_list|,
operator|&
name|type
argument_list|)
decl_stmt|;
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
return|;
block|}
else|else
return|return
name|desc_one_bound
argument_list|(
name|desc_bounds
argument_list|(
name|arr
argument_list|)
argument_list|,
name|n
argument_list|,
name|which
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given that arr is an array value, returns the length of the    nth index.  This routine will also work for arrays with bounds    supplied by run-time quantities other than discriminants. Does not    work for arrays indexed by enumeration types with representation    clauses at the moment. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_array_length
parameter_list|(
name|struct
name|value
modifier|*
name|arr
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|arr_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type_desc
decl_stmt|;
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|arr_type
argument_list|)
condition|)
return|return
name|ada_array_length
argument_list|(
name|decode_packed_array
argument_list|(
name|arr
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
if|if
condition|(
name|ada_is_simple_array
argument_list|(
name|arr_type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|v
init|=
name|ada_array_bound_from_type
argument_list|(
name|arr_type
argument_list|,
name|n
argument_list|,
literal|1
argument_list|,
operator|&
name|type
argument_list|)
operator|-
name|ada_array_bound_from_type
argument_list|(
name|arr_type
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|+
literal|1
decl_stmt|;
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
return|;
block|}
else|else
return|return
name|value_from_longest
argument_list|(
name|builtin_type_ada_int
argument_list|,
name|value_as_long
argument_list|(
name|desc_one_bound
argument_list|(
name|desc_bounds
argument_list|(
name|arr
argument_list|)
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|value_as_long
argument_list|(
name|desc_one_bound
argument_list|(
name|desc_bounds
argument_list|(
name|arr
argument_list|)
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Name resolution */
end_comment

begin_comment
comment|/* The "demangled" name for the user-definable Ada operator corresponding    to op. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ada_op_name
parameter_list|(
name|enum
name|exp_opcode
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ada_opname_table
index|[
name|i
index|]
operator|.
name|mangled
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|ada_opname_table
index|[
name|i
index|]
operator|.
name|op
operator|==
name|op
condition|)
return|return
name|ada_opname_table
index|[
name|i
index|]
operator|.
name|demangled
return|;
block|}
name|error
argument_list|(
literal|"Could not find operator name for opcode"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as evaluate_type (*EXP), but resolves ambiguous symbol     references (OP_UNRESOLVED_VALUES) and converts operators that are     user-defined into appropriate function calls.  If CONTEXT_TYPE is     non-null, it provides a preferred result type [at the moment, only    type void has any effect---causing procedures to be preferred over    functions in calls].  A null CONTEXT_TYPE indicates that a non-void    return type is preferred.  The variable unresolved_names contains a list    of character strings referenced by expout that should be freed.      May change (expand) *EXP.  */
end_comment

begin_function
name|void
name|ada_resolve
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|expp
parameter_list|,
name|struct
name|type
modifier|*
name|context_type
parameter_list|)
block|{
name|int
name|pc
decl_stmt|;
name|pc
operator|=
literal|0
expr_stmt|;
name|ada_resolve_subexp
argument_list|(
name|expp
argument_list|,
operator|&
name|pc
argument_list|,
literal|1
argument_list|,
name|context_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resolve the operator of the subexpression beginning at     position *POS of *EXPP. "Resolving" consists of replacing    OP_UNRESOLVED_VALUE with an appropriate OP_VAR_VALUE, replacing    built-in operators with function calls to user-defined operators,    where appropriate, and (when DEPROCEDURE_P is non-zero), converting    function-valued variables into parameterless calls.  May expand    EXP. The CONTEXT_TYPE functions as in ada_resolve, above. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|ada_resolve_subexp
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|expp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
name|deprocedure_p
parameter_list|,
name|struct
name|type
modifier|*
name|context_type
parameter_list|)
block|{
name|int
name|pc
init|=
operator|*
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
comment|/* Convenience: == *expp */
name|enum
name|exp_opcode
name|op
init|=
operator|(
operator|*
name|expp
operator|)
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
decl_stmt|;
name|struct
name|value
modifier|*
modifier|*
name|argvec
decl_stmt|;
comment|/* Vector of operand types (alloca'ed). */
name|int
name|nargs
decl_stmt|;
comment|/* Number of operands */
name|argvec
operator|=
name|NULL
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
operator|*
name|expp
expr_stmt|;
comment|/* Pass one: resolve operands, saving their types and updating *pos. */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_VAR_VALUE
case|:
comment|/*    case OP_UNRESOLVED_VALUE: */
comment|/* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
operator|*
name|pos
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
comment|/*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)                  {          *pos += 7;           argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 1));          for (i = 0; i< nargs-1; i += 1)          argvec[i] = ada_resolve_subexp (expp, pos, 1, NULL);          argvec[i] = NULL;          }          else          {          *pos += 3;          ada_resolve_subexp (expp, pos, 0, NULL);          for (i = 1; i< nargs; i += 1)          ada_resolve_subexp (expp, pos, 1, NULL);          }        */
name|exp
operator|=
operator|*
name|expp
expr_stmt|;
break|break;
comment|/* FIXME:  UNOP_QUAL should be defined in expression.h */
comment|/*    case UNOP_QUAL:          nargs = 1;          *pos += 3;          ada_resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);          exp = *expp;          break;        */
comment|/* FIXME:  OP_ATTRIBUTE should be defined in expression.h */
comment|/*    case OP_ATTRIBUTE:          nargs = longest_to_int (exp->elts[pc + 1].longconst) + 1;          *pos += 4;          for (i = 0; i< nargs; i += 1)          ada_resolve_subexp (expp, pos, 1, NULL);          exp = *expp;          break;        */
case|case
name|UNOP_ADDR
case|:
name|nargs
operator|=
literal|1
expr_stmt|;
operator|*
name|pos
operator|+=
literal|1
expr_stmt|;
name|ada_resolve_subexp
argument_list|(
name|expp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|*
name|expp
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN
case|:
block|{
name|struct
name|value
modifier|*
name|arg1
decl_stmt|;
name|nargs
operator|=
literal|2
expr_stmt|;
operator|*
name|pos
operator|+=
literal|1
expr_stmt|;
name|arg1
operator|=
name|ada_resolve_subexp
argument_list|(
name|expp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
name|ada_resolve_subexp
argument_list|(
name|expp
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ada_resolve_subexp
argument_list|(
name|expp
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Unexpected operator during name resolution"
argument_list|)
expr_stmt|;
case|case
name|UNOP_CAST
case|:
comment|/*    case UNOP_MBR: 	     nargs = 1; 	     *pos += 3; 	     break; 	   */
case|case
name|BINOP_ADD
case|:
case|case
name|BINOP_SUB
case|:
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_EXP
case|:
case|case
name|BINOP_CONCAT
case|:
case|case
name|BINOP_LOGICAL_AND
case|:
case|case
name|BINOP_LOGICAL_OR
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
case|case
name|BINOP_EQUAL
case|:
case|case
name|BINOP_NOTEQUAL
case|:
case|case
name|BINOP_LESS
case|:
case|case
name|BINOP_GTR
case|:
case|case
name|BINOP_LEQ
case|:
case|case
name|BINOP_GEQ
case|:
case|case
name|BINOP_REPEAT
case|:
case|case
name|BINOP_SUBSCRIPT
case|:
case|case
name|BINOP_COMMA
case|:
name|nargs
operator|=
literal|2
expr_stmt|;
operator|*
name|pos
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_NEG
case|:
case|case
name|UNOP_PLUS
case|:
case|case
name|UNOP_LOGICAL_NOT
case|:
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_IND
case|:
name|nargs
operator|=
literal|1
expr_stmt|;
operator|*
name|pos
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
case|case
name|OP_VAR_VALUE
case|:
operator|*
name|pos
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
operator|*
name|pos
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|UNOP_MEMVAL
case|:
operator|*
name|pos
operator|+=
literal|3
expr_stmt|;
name|nargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
name|nargs
operator|=
literal|1
expr_stmt|;
operator|*
name|pos
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ARRAY
case|:
operator|*
name|pos
operator|+=
literal|4
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nargs
operator|-=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
comment|/* A null array contains one dummy element to give the type. */
comment|/*      if (nargs == 0) 	     nargs = 1; 	     break; */
case|case
name|TERNOP_SLICE
case|:
comment|/* FIXME: TERNOP_MBR should be defined in expression.h */
comment|/*    case TERNOP_MBR: 	     *pos += 1; 	     nargs = 3; 	     break; 	   */
comment|/* FIXME: BINOP_MBR should be defined in expression.h */
comment|/*    case BINOP_MBR: 	     *pos += 3; 	     nargs = 2; 	     break; */
block|}
name|argvec
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|+=
literal|1
control|)
name|argvec
index|[
name|i
index|]
operator|=
name|ada_resolve_subexp
argument_list|(
name|expp
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argvec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|exp
operator|=
operator|*
name|expp
expr_stmt|;
break|break;
block|}
comment|/* Pass two: perform any resolution on principal operator. */
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
break|break;
comment|/* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
comment|/*    case OP_UNRESOLVED_VALUE:          {          struct symbol** candidate_syms;          struct block** candidate_blocks;          int n_candidates;           n_candidates = ada_lookup_symbol_list (exp->elts[pc + 2].name,          exp->elts[pc + 1].block,          VAR_DOMAIN,&candidate_syms,&candidate_blocks);           if (n_candidates> 1)           { */
comment|/* Types tend to get re-introduced locally, so if there          are any local symbols that are not types, first filter    out all types. */
comment|/*    int j;    for (j = 0; j< n_candidates; j += 1)     switch (SYMBOL_CLASS (candidate_syms[j]))     {    case LOC_REGISTER:    case LOC_ARG:    case LOC_REF_ARG:    case LOC_REGPARM:    case LOC_REGPARM_ADDR:    case LOC_LOCAL:    case LOC_LOCAL_ARG:    case LOC_BASEREG:    case LOC_BASEREG_ARG:    case LOC_COMPUTED:    case LOC_COMPUTED_ARG:    goto FoundNonType;    default:    break;    }    FoundNonType:    if (j< n_candidates)     {    j = 0;    while (j< n_candidates)     {    if (SYMBOL_CLASS (candidate_syms[j]) == LOC_TYPEDEF)    {    candidate_syms[j] = candidate_syms[n_candidates-1];    candidate_blocks[j] = candidate_blocks[n_candidates-1];    n_candidates -= 1;    }    else    j += 1;    }    }    }     if (n_candidates == 0)    error ("No definition found for %s",     ada_demangle (exp->elts[pc + 2].name));    else if (n_candidates == 1)    i = 0;    else if (deprocedure_p&& ! is_nonfunction (candidate_syms, n_candidates))    {    i = ada_resolve_function (candidate_syms, candidate_blocks,    n_candidates, NULL, 0,    exp->elts[pc + 2].name, context_type);    if (i< 0)     error ("Could not find a match for %s",     ada_demangle (exp->elts[pc + 2].name));    }    else     {    printf_filtered ("Multiple matches for %s\n",     ada_demangle (exp->elts[pc+2].name));    user_select_syms (candidate_syms, candidate_blocks,     n_candidates, 1);    i = 0;    }     exp->elts[pc].opcode = exp->elts[pc + 3].opcode = OP_VAR_VALUE;    exp->elts[pc + 1].block = candidate_blocks[i];    exp->elts[pc + 2].symbol = candidate_syms[i];    if (innermost_block == NULL ||    contained_in (candidate_blocks[i], innermost_block))    innermost_block = candidate_blocks[i];    } */
comment|/* FALL THROUGH */
case|case
name|OP_VAR_VALUE
case|:
if|if
condition|(
name|deprocedure_p
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|replace_operator_with_call
argument_list|(
name|expp
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|*
name|expp
expr_stmt|;
block|}
break|break;
case|case
name|OP_FUNCALL
case|:
block|{
comment|/* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
comment|/*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)       	   { 	   struct symbol** candidate_syms; 	   struct block** candidate_blocks; 	   int n_candidates;  	   n_candidates = ada_lookup_symbol_list (exp->elts[pc + 5].name, 	   exp->elts[pc + 4].block, 	   VAR_DOMAIN,&candidate_syms,&candidate_blocks); 	   if (n_candidates == 1) 	   i = 0; 	   else 	   { 	   i = ada_resolve_function (candidate_syms, candidate_blocks, 	   n_candidates, argvec, nargs-1, 	   exp->elts[pc + 5].name, context_type); 	   if (i< 0)  	   error ("Could not find a match for %s",  	   ada_demangle (exp->elts[pc + 5].name)); 	   }  	   exp->elts[pc + 3].opcode = exp->elts[pc + 6].opcode = OP_VAR_VALUE; 	   exp->elts[pc + 4].block = candidate_blocks[i]; 	   exp->elts[pc + 5].symbol = candidate_syms[i]; 	   if (innermost_block == NULL || 	   contained_in (candidate_blocks[i], innermost_block)) 	   innermost_block = candidate_blocks[i]; 	   } */
block|}
break|break;
case|case
name|BINOP_ADD
case|:
case|case
name|BINOP_SUB
case|:
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_CONCAT
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
case|case
name|BINOP_EQUAL
case|:
case|case
name|BINOP_NOTEQUAL
case|:
case|case
name|BINOP_LESS
case|:
case|case
name|BINOP_GTR
case|:
case|case
name|BINOP_LEQ
case|:
case|case
name|BINOP_GEQ
case|:
case|case
name|BINOP_EXP
case|:
case|case
name|UNOP_NEG
case|:
case|case
name|UNOP_PLUS
case|:
case|case
name|UNOP_LOGICAL_NOT
case|:
case|case
name|UNOP_ABS
case|:
if|if
condition|(
name|possible_user_operator_p
argument_list|(
name|op
argument_list|,
name|argvec
argument_list|)
condition|)
block|{
name|struct
name|symbol
modifier|*
modifier|*
name|candidate_syms
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|candidate_blocks
decl_stmt|;
name|int
name|n_candidates
decl_stmt|;
name|n_candidates
operator|=
name|ada_lookup_symbol_list
argument_list|(
name|ada_mangle
argument_list|(
name|ada_op_name
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|&
name|candidate_syms
argument_list|,
operator|&
name|candidate_blocks
argument_list|)
expr_stmt|;
name|i
operator|=
name|ada_resolve_function
argument_list|(
name|candidate_syms
argument_list|,
name|candidate_blocks
argument_list|,
name|n_candidates
argument_list|,
name|argvec
argument_list|,
name|nargs
argument_list|,
name|ada_op_name
argument_list|(
name|op
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
name|replace_operator_with_call
argument_list|(
name|expp
argument_list|,
name|pc
argument_list|,
name|nargs
argument_list|,
literal|1
argument_list|,
name|candidate_syms
index|[
name|i
index|]
argument_list|,
name|candidate_blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|*
name|expp
expr_stmt|;
block|}
break|break;
block|}
operator|*
name|pos
operator|=
name|pc
expr_stmt|;
return|return
name|evaluate_subexp_type
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if formal type FTYPE matches actual type ATYPE.  If    MAY_DEREF is non-zero, the formal may be a pointer and the actual     a non-pointer. */
end_comment

begin_comment
comment|/* The term "match" here is rather loose.  The match is heuristic and    liberal.  FIXME: TOO liberal, in fact. */
end_comment

begin_function
specifier|static
name|int
name|ada_type_match
parameter_list|(
name|struct
name|type
modifier|*
name|ftype
parameter_list|,
name|struct
name|type
modifier|*
name|atype
parameter_list|,
name|int
name|may_deref
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
name|ftype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
name|atype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_VOID
operator|||
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
condition|)
block|{
default|default:
return|return
literal|1
return|;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|ada_type_match
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|atype
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
operator|(
name|may_deref
operator|&&
name|ada_type_match
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|,
name|atype
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_RANGE
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_RANGE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|ada_is_array_descriptor
argument_list|(
name|atype
argument_list|)
operator|)
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|ftype
argument_list|)
condition|)
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|ada_is_array_descriptor
argument_list|(
name|atype
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
operator|!
name|ada_is_array_descriptor
argument_list|(
name|atype
argument_list|)
operator|)
return|;
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_FLT
case|:
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|atype
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the formals of FUNC "sufficiently match" the    vector of actual argument types ACTUALS of size N_ACTUALS.  FUNC    may also be an enumeral, in which case it is treated as a 0-    argument function. */
end_comment

begin_function
specifier|static
name|int
name|ada_args_match
parameter_list|(
name|struct
name|symbol
modifier|*
name|func
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|actuals
parameter_list|,
name|int
name|n_actuals
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|func_type
init|=
name|SYMBOL_TYPE
argument_list|(
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|func
argument_list|)
operator|==
name|LOC_CONST
operator|&&
name|TYPE_CODE
argument_list|(
name|func_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
return|return
operator|(
name|n_actuals
operator|==
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|func_type
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|func_type
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|func_type
argument_list|)
operator|!=
name|n_actuals
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_actuals
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|struct
name|type
modifier|*
name|ftype
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|func_type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|atype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|actuals
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ada_type_match
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|func_type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_TYPE
argument_list|(
name|actuals
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* False iff function type FUNC_TYPE definitely does not produce a value    compatible with type CONTEXT_TYPE.  Conservatively returns 1 if    FUNC_TYPE is not a valid function type with a non-null return type    or an enumerated type.  A null CONTEXT_TYPE indicates any non-void type.  */
end_comment

begin_function
specifier|static
name|int
name|return_match
parameter_list|(
name|struct
name|type
modifier|*
name|func_type
parameter_list|,
name|struct
name|type
modifier|*
name|context_type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
if|if
condition|(
name|func_type
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* FIXME: base_type should be declared in gdbtypes.h, implemented in valarith.c */
comment|/*  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)      return_type = base_type (TYPE_TARGET_TYPE (func_type));      else       return_type = base_type (func_type); */
if|if
condition|(
name|return_type
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* FIXME: base_type should be declared in gdbtypes.h, implemented in valarith.c */
comment|/*  context_type = base_type (context_type); */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
return|return
name|context_type
operator|==
name|NULL
operator|||
name|return_type
operator|==
name|context_type
return|;
elseif|else
if|if
condition|(
name|context_type
operator|==
name|NULL
condition|)
return|return
name|TYPE_CODE
argument_list|(
name|return_type
argument_list|)
operator|!=
name|TYPE_CODE_VOID
return|;
else|else
return|return
name|TYPE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
name|context_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the index in SYMS[0..NSYMS-1] of symbol for the     function (if any) that matches the types of the NARGS arguments in    ARGS.  If CONTEXT_TYPE is non-null, and there is at least one match    that returns type CONTEXT_TYPE, then eliminate other matches.  If    CONTEXT_TYPE is null, prefer a non-void-returning function.    Asks the user if there is more than one match remaining.  Returns -1    if there is no such symbol or none is selected.  NAME is used    solely for messages.   May re-arrange and modify SYMS in    the process; the index returned is for the modified vector.  BLOCKS    is modified in parallel to SYMS. */
end_comment

begin_function
name|int
name|ada_resolve_function
parameter_list|(
name|struct
name|symbol
modifier|*
name|syms
index|[]
parameter_list|,
name|struct
name|block
modifier|*
name|blocks
index|[]
parameter_list|,
name|int
name|nsyms
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|type
modifier|*
name|context_type
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|int
name|m
decl_stmt|;
comment|/* Number of hits */
name|struct
name|type
modifier|*
name|fallback
decl_stmt|;
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|return_type
operator|=
name|context_type
expr_stmt|;
if|if
condition|(
name|context_type
operator|==
name|NULL
condition|)
name|fallback
operator|=
name|builtin_type_void
expr_stmt|;
else|else
name|fallback
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nsyms
condition|;
name|k
operator|+=
literal|1
control|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|k
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ada_args_match
argument_list|(
name|syms
index|[
name|k
index|]
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|)
operator|&&
name|return_match
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|k
index|]
argument_list|)
argument_list|,
name|return_type
argument_list|)
condition|)
block|{
name|syms
index|[
name|m
index|]
operator|=
name|syms
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|blocks
operator|!=
name|NULL
condition|)
name|blocks
index|[
name|m
index|]
operator|=
name|blocks
index|[
name|k
index|]
expr_stmt|;
name|m
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|>
literal|0
operator|||
name|return_type
operator|==
name|fallback
condition|)
break|break;
else|else
name|return_type
operator|=
name|fallback
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|m
operator|>
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Multiple matches for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|user_select_syms
argument_list|(
name|syms
argument_list|,
name|blocks
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true (non-zero) iff demangled name N0 should appear before N1 */
end_comment

begin_comment
comment|/* in a listing of choices during disambiguation (see sort_choices, below). */
end_comment

begin_comment
comment|/* The idea is that overloadings of a subprogram name from the */
end_comment

begin_comment
comment|/* same package should sort in their source order.  We settle for ordering */
end_comment

begin_comment
comment|/* such symbols by their trailing number (__N  or $N). */
end_comment

begin_function
specifier|static
name|int
name|mangled_ordered_before
parameter_list|(
name|char
modifier|*
name|N0
parameter_list|,
name|char
modifier|*
name|N1
parameter_list|)
block|{
if|if
condition|(
name|N1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|N0
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
else|else
block|{
name|int
name|k0
decl_stmt|,
name|k1
decl_stmt|;
for|for
control|(
name|k0
operator|=
name|strlen
argument_list|(
name|N0
argument_list|)
operator|-
literal|1
init|;
name|k0
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|N0
index|[
name|k0
index|]
argument_list|)
condition|;
name|k0
operator|-=
literal|1
control|)
empty_stmt|;
for|for
control|(
name|k1
operator|=
name|strlen
argument_list|(
name|N1
argument_list|)
operator|-
literal|1
init|;
name|k1
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|N1
index|[
name|k1
index|]
argument_list|)
condition|;
name|k1
operator|-=
literal|1
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|N0
index|[
name|k0
index|]
operator|==
literal|'_'
operator|||
name|N0
index|[
name|k0
index|]
operator|==
literal|'$'
operator|)
operator|&&
name|N0
index|[
name|k0
operator|+
literal|1
index|]
operator|!=
literal|'\000'
operator|&&
operator|(
name|N1
index|[
name|k1
index|]
operator|==
literal|'_'
operator|||
name|N1
index|[
name|k1
index|]
operator|==
literal|'$'
operator|)
operator|&&
name|N1
index|[
name|k1
operator|+
literal|1
index|]
operator|!=
literal|'\000'
condition|)
block|{
name|int
name|n0
decl_stmt|,
name|n1
decl_stmt|;
name|n0
operator|=
name|k0
expr_stmt|;
while|while
condition|(
name|N0
index|[
name|n0
index|]
operator|==
literal|'_'
operator|&&
name|n0
operator|>
literal|0
operator|&&
name|N0
index|[
name|n0
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
name|n0
operator|-=
literal|1
expr_stmt|;
name|n1
operator|=
name|k1
expr_stmt|;
while|while
condition|(
name|N1
index|[
name|n1
index|]
operator|==
literal|'_'
operator|&&
name|n1
operator|>
literal|0
operator|&&
name|N1
index|[
name|n1
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
name|n1
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|n0
operator|==
name|n1
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|N0
argument_list|,
name|N1
argument_list|,
name|n0
argument_list|)
condition|)
return|return
operator|(
name|atoi
argument_list|(
name|N0
operator|+
name|k0
operator|+
literal|1
argument_list|)
operator|<
name|atoi
argument_list|(
name|N1
operator|+
name|k1
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|strcmp
argument_list|(
name|N0
argument_list|,
name|N1
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by their */
end_comment

begin_comment
comment|/* mangled names, rearranging BLOCKS[0..NSYMS-1] according to the same */
end_comment

begin_comment
comment|/* permutation. */
end_comment

begin_function
specifier|static
name|void
name|sort_choices
parameter_list|(
name|struct
name|symbol
modifier|*
name|syms
index|[]
parameter_list|,
name|struct
name|block
modifier|*
name|blocks
index|[]
parameter_list|,
name|int
name|nsyms
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|syms
index|[
name|i
index|]
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
name|blocks
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|1
control|)
block|{
if|if
condition|(
name|mangled_ordered_before
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|syms
index|[
name|j
index|]
argument_list|)
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
break|break;
name|syms
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|syms
index|[
name|j
index|]
expr_stmt|;
name|blocks
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|blocks
index|[
name|j
index|]
expr_stmt|;
block|}
name|syms
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|sym
expr_stmt|;
name|blocks
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|block
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a list of NSYMS symbols in SYMS and corresponding blocks in */
end_comment

begin_comment
comment|/* BLOCKS, select up to MAX_RESULTS>0 by asking the user (if */
end_comment

begin_comment
comment|/* necessary), returning the number selected, and setting the first */
end_comment

begin_comment
comment|/* elements of SYMS and BLOCKS to the selected symbols and */
end_comment

begin_comment
comment|/* corresponding blocks.  Error if no symbols selected.   BLOCKS may */
end_comment

begin_comment
comment|/* be NULL, in which case it is ignored. */
end_comment

begin_comment
comment|/* NOTE: Adapted from decode_line_2 in symtab.c, with which it ought    to be re-integrated one of these days. */
end_comment

begin_function
name|int
name|user_select_syms
parameter_list|(
name|struct
name|symbol
modifier|*
name|syms
index|[]
parameter_list|,
name|struct
name|block
modifier|*
name|blocks
index|[]
parameter_list|,
name|int
name|nsyms
parameter_list|,
name|int
name|max_results
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|chosen
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nsyms
argument_list|)
decl_stmt|;
name|int
name|n_chosen
decl_stmt|;
name|int
name|first_choice
init|=
operator|(
name|max_results
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|2
decl_stmt|;
if|if
condition|(
name|max_results
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"Request to select 0 symbols!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsyms
operator|<=
literal|1
condition|)
return|return
name|nsyms
return|;
name|printf_unfiltered
argument_list|(
literal|"[0] cancel\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_results
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"[1] all\n"
argument_list|)
expr_stmt|;
name|sort_choices
argument_list|(
name|syms
argument_list|,
name|blocks
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|syms
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
init|=
name|find_function_start_sal
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[%d] %s at %s:%d\n"
argument_list|,
name|i
operator|+
name|first_choice
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|,
name|sal
operator|.
name|symtab
operator|==
name|NULL
condition|?
literal|"<no source file available>"
else|:
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|int
name|is_enumeral
init|=
operator|(
name|SYMBOL_CLASS
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_CONST
operator|&&
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|)
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
init|=
name|symtab_for_sym
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
operator|&&
name|symtab
operator|!=
name|NULL
condition|)
name|printf_unfiltered
argument_list|(
literal|"[%d] %s at %s:%d\n"
argument_list|,
name|i
operator|+
name|first_choice
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|,
name|symtab
operator|->
name|filename
argument_list|,
name|SYMBOL_LINE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_enumeral
operator|&&
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"[%d] "
argument_list|,
name|i
operator|+
name|first_choice
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|gdb_stdout
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"'(%s) (enumeral)\n"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|printf_unfiltered
argument_list|(
name|is_enumeral
condition|?
literal|"[%d] %s in %s (enumeral)\n"
else|:
literal|"[%d] %s at %s:?\n"
argument_list|,
name|i
operator|+
name|first_choice
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|,
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
name|is_enumeral
condition|?
literal|"[%d] %s (enumeral)\n"
else|:
literal|"[%d] %s at ?\n"
argument_list|,
name|i
operator|+
name|first_choice
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|n_chosen
operator|=
name|get_selections
argument_list|(
name|chosen
argument_list|,
name|nsyms
argument_list|,
name|max_results
argument_list|,
name|max_results
operator|>
literal|1
argument_list|,
literal|"overload-choice"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_chosen
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|syms
index|[
name|i
index|]
operator|=
name|syms
index|[
name|chosen
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|blocks
operator|!=
name|NULL
condition|)
name|blocks
index|[
name|i
index|]
operator|=
name|blocks
index|[
name|chosen
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
return|return
name|n_chosen
return|;
block|}
end_function

begin_comment
comment|/* Read and validate a set of numeric choices from the user in the    range 0 .. N_CHOICES-1. Place the results in increasing    order in CHOICES[0 .. N-1], and return N.     The user types choices as a sequence of numbers on one line    separated by blanks, encoding them as follows:       + A choice of 0 means to cancel the selection, throwing an error.        + If IS_ALL_CHOICE, a choice of 1 selects the entire set 0 .. N_CHOICES-1.      + The user chooses k by typing k+IS_ALL_CHOICE+1.     The user is not allowed to choose more than MAX_RESULTS values.      ANNOTATION_SUFFIX, if present, is used to annotate the input    prompts (for use with the -f switch). */
end_comment

begin_function
name|int
name|get_selections
parameter_list|(
name|int
modifier|*
name|choices
parameter_list|,
name|int
name|n_choices
parameter_list|,
name|int
name|max_results
parameter_list|,
name|int
name|is_all_choice
parameter_list|,
name|char
modifier|*
name|annotation_suffix
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|n_chosen
decl_stmt|;
name|int
name|first_choice
init|=
name|is_all_choice
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|prompt
operator|=
name|getenv
argument_list|(
literal|"PS2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
operator|==
name|NULL
condition|)
name|prompt
operator|=
literal|">"
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s "
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|args
operator|=
name|command_line_input
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|annotation_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
name|n_chosen
operator|=
literal|0
expr_stmt|;
comment|/* Set choices[0 .. n_chosen-1] to the users' choices in ascending       order, as given in args.   Choices are validated. */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|args2
decl_stmt|;
name|int
name|choice
decl_stmt|,
name|j
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'\0'
operator|&&
name|n_chosen
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'\0'
condition|)
break|break;
name|choice
operator|=
name|strtol
argument_list|(
name|args
argument_list|,
operator|&
name|args2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|args2
operator|||
name|choice
operator|<
literal|0
operator|||
name|choice
operator|>
name|n_choices
operator|+
name|first_choice
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Argument must be choice number"
argument_list|)
expr_stmt|;
name|args
operator|=
name|args2
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cancelled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|choice
operator|<
name|first_choice
condition|)
block|{
name|n_chosen
operator|=
name|n_choices
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_choices
condition|;
name|j
operator|+=
literal|1
control|)
name|choices
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
break|break;
block|}
name|choice
operator|-=
name|first_choice
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n_chosen
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
operator|&&
name|choice
operator|<
name|choices
index|[
name|j
index|]
condition|;
name|j
operator|-=
literal|1
control|)
block|{ 	}
if|if
condition|(
name|j
operator|<
literal|0
operator|||
name|choice
operator|!=
name|choices
index|[
name|j
index|]
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|n_chosen
operator|-
literal|1
init|;
name|k
operator|>
name|j
condition|;
name|k
operator|-=
literal|1
control|)
name|choices
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|choices
index|[
name|k
index|]
expr_stmt|;
name|choices
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|choice
expr_stmt|;
name|n_chosen
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_chosen
operator|>
name|max_results
condition|)
name|error
argument_list|(
literal|"Select no more than %d of the above"
argument_list|,
name|max_results
argument_list|)
expr_stmt|;
return|return
name|n_chosen
return|;
block|}
end_function

begin_comment
comment|/* Replace the operator of length OPLEN at position PC in *EXPP with a call */
end_comment

begin_comment
comment|/* on the function identified by SYM and BLOCK, and taking NARGS */
end_comment

begin_comment
comment|/* arguments.  Update *EXPP as needed to hold more space. */
end_comment

begin_function
specifier|static
name|void
name|replace_operator_with_call
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|expp
parameter_list|,
name|int
name|pc
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|oplen
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
comment|/* A new expression, with 6 more elements (3 for funcall, 4 for function      symbol, -oplen for operator being replaced). */
name|struct
name|expression
modifier|*
name|newexp
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
operator|(
operator|*
name|expp
operator|)
operator|->
name|nelts
operator|+
literal|7
operator|-
name|oplen
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
init|=
operator|*
name|expp
decl_stmt|;
name|newexp
operator|->
name|nelts
operator|=
name|exp
operator|->
name|nelts
operator|+
literal|7
operator|-
name|oplen
expr_stmt|;
name|newexp
operator|->
name|language_defn
operator|=
name|exp
operator|->
name|language_defn
expr_stmt|;
name|memcpy
argument_list|(
name|newexp
operator|->
name|elts
argument_list|,
name|exp
operator|->
name|elts
argument_list|,
name|EXP_ELEM_TO_BYTES
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newexp
operator|->
name|elts
operator|+
name|pc
operator|+
literal|7
argument_list|,
name|exp
operator|->
name|elts
operator|+
name|pc
operator|+
name|oplen
argument_list|,
name|EXP_ELEM_TO_BYTES
argument_list|(
name|exp
operator|->
name|nelts
operator|-
name|pc
operator|-
name|oplen
argument_list|)
argument_list|)
expr_stmt|;
name|newexp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
operator|=
name|newexp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|opcode
operator|=
name|OP_FUNCALL
expr_stmt|;
name|newexp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
operator|=
operator|(
name|LONGEST
operator|)
name|nargs
expr_stmt|;
name|newexp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|opcode
operator|=
name|newexp
operator|->
name|elts
index|[
name|pc
operator|+
literal|6
index|]
operator|.
name|opcode
operator|=
name|OP_VAR_VALUE
expr_stmt|;
name|newexp
operator|->
name|elts
index|[
name|pc
operator|+
literal|4
index|]
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|newexp
operator|->
name|elts
index|[
name|pc
operator|+
literal|5
index|]
operator|.
name|symbol
operator|=
name|sym
expr_stmt|;
operator|*
name|expp
operator|=
name|newexp
expr_stmt|;
name|xfree
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type-class predicates */
end_comment

begin_comment
comment|/* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type), or */
end_comment

begin_comment
comment|/* FLOAT.) */
end_comment

begin_function
specifier|static
name|int
name|numeric_type_p
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
return|return
literal|1
return|;
case|case
name|TYPE_CODE_RANGE
case|:
return|return
operator|(
name|type
operator|==
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|numeric_type_p
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* True iff TYPE is integral (an INT or RANGE of INTs). */
end_comment

begin_function
specifier|static
name|int
name|integer_type_p
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
return|return
literal|1
return|;
case|case
name|TYPE_CODE_RANGE
case|:
return|return
operator|(
name|type
operator|==
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|integer_type_p
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* True iff TYPE is scalar (INT, RANGE, FLOAT, ENUM). */
end_comment

begin_function
specifier|static
name|int
name|scalar_type_p
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_FLT
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* True iff TYPE is discrete (INT, RANGE, ENUM). */
end_comment

begin_function
specifier|static
name|int
name|discrete_type_p
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_ENUM
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if OP with operatands in the vector ARGS could be    a user-defined function. Errs on the side of pre-defined operators    (i.e., result 0). */
end_comment

begin_function
specifier|static
name|int
name|possible_user_operator_p
parameter_list|(
name|enum
name|exp_opcode
name|op
parameter_list|,
name|struct
name|value
modifier|*
name|args
index|[]
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type0
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
init|=
operator|(
name|args
index|[
literal|1
index|]
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|BINOP_ADD
case|:
case|case
name|BINOP_SUB
case|:
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
return|return
operator|(
operator|!
operator|(
name|numeric_type_p
argument_list|(
name|type0
argument_list|)
operator|&&
name|numeric_type_p
argument_list|(
name|type1
argument_list|)
operator|)
operator|)
return|;
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
return|return
operator|(
operator|!
operator|(
name|integer_type_p
argument_list|(
name|type0
argument_list|)
operator|&&
name|integer_type_p
argument_list|(
name|type1
argument_list|)
operator|)
operator|)
return|;
case|case
name|BINOP_EQUAL
case|:
case|case
name|BINOP_NOTEQUAL
case|:
case|case
name|BINOP_LESS
case|:
case|case
name|BINOP_GTR
case|:
case|case
name|BINOP_LEQ
case|:
case|case
name|BINOP_GEQ
case|:
return|return
operator|(
operator|!
operator|(
name|scalar_type_p
argument_list|(
name|type0
argument_list|)
operator|&&
name|scalar_type_p
argument_list|(
name|type1
argument_list|)
operator|)
operator|)
return|;
case|case
name|BINOP_CONCAT
case|:
return|return
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
operator|)
operator|)
return|;
case|case
name|BINOP_EXP
case|:
return|return
operator|(
operator|!
operator|(
name|numeric_type_p
argument_list|(
name|type0
argument_list|)
operator|&&
name|integer_type_p
argument_list|(
name|type1
argument_list|)
operator|)
operator|)
return|;
case|case
name|UNOP_NEG
case|:
case|case
name|UNOP_PLUS
case|:
case|case
name|UNOP_LOGICAL_NOT
case|:
case|case
name|UNOP_ABS
case|:
return|return
operator|(
operator|!
name|numeric_type_p
argument_list|(
name|type0
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Renaming */
end_comment

begin_comment
comment|/** NOTE: In the following, we assume that a renaming type's name may  *  have an ___XD suffix.  It would be nice if this went away at some  *  point. */
end_comment

begin_comment
comment|/* If TYPE encodes a renaming, returns the renaming suffix, which  * is XR for an object renaming, XRP for a procedure renaming, XRE for  * an exception renaming, and XRS for a subprogram renaming.  Returns  * NULL if NAME encodes none of these. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ada_renaming_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
init|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|strstr
argument_list|(
name|name
argument_list|,
literal|"___XR"
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|==
name|NULL
operator|||
operator|(
name|suffix
index|[
literal|5
index|]
operator|!=
literal|'\000'
operator|&&
name|strchr
argument_list|(
literal|"PES_"
argument_list|,
name|suffix
index|[
literal|5
index|]
argument_list|)
operator|==
name|NULL
operator|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|suffix
operator|+
literal|3
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff SYM encodes an object renaming. */
end_comment

begin_function
name|int
name|ada_is_object_renaming
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|renaming_type
init|=
name|ada_renaming_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|renaming_type
operator|!=
name|NULL
operator|&&
operator|(
name|renaming_type
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
name|renaming_type
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming that SYM encodes a non-object renaming, returns the original  * name of the renamed entity.   The name is good until the end of  * parsing. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ada_simple_renamed_entity
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|raw_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"Improperly encoded renaming."
argument_list|)
expr_stmt|;
name|raw_name
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|raw_name
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|raw_name
argument_list|)
operator|)
operator|-
literal|5
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Improperly encoded renaming."
argument_list|)
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: add_name_string_cleanup should be defined in parse.c */
comment|/*  add_name_string_cleanup (result); */
name|strncpy
argument_list|(
name|result
argument_list|,
name|raw_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluation: Function Calls */
end_comment

begin_comment
comment|/* Copy VAL onto the stack, using and updating *SP as the stack     pointer. Return VAL as an lvalue. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|place_on_stack
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|CORE_ADDR
modifier|*
name|sp
parameter_list|)
block|{
name|CORE_ADDR
name|old_sp
init|=
operator|*
name|sp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEPRECATED_STACK_ALIGN
operator|*
name|sp
operator|=
name|push_bytes
argument_list|(
operator|*
name|sp
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|DEPRECATED_STACK_ALIGN
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|sp
operator|=
name|push_bytes
argument_list|(
operator|*
name|sp
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
operator|*
name|sp
expr_stmt|;
else|else
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|old_sp
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return the value ACTUAL, converted to be an appropriate value for a    formal of type FORMAL_TYPE.  Use *SP as a stack pointer for    allocating any necessary descriptors (fat pointers), or copies of    values not residing in memory, updating it as needed. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|convert_actual
parameter_list|(
name|struct
name|value
modifier|*
name|actual
parameter_list|,
name|struct
name|type
modifier|*
name|formal_type0
parameter_list|,
name|CORE_ADDR
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|actual_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|actual
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|formal_type
init|=
name|check_typedef
argument_list|(
name|formal_type0
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|formal_target
init|=
name|TYPE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|?
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
else|:
name|formal_type
decl_stmt|;
name|struct
name|type
modifier|*
name|actual_target
init|=
name|TYPE_CODE
argument_list|(
name|actual_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|?
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|actual_type
argument_list|)
argument_list|)
else|:
name|actual_type
decl_stmt|;
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|formal_target
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|actual_target
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|make_array_descriptor
argument_list|(
name|formal_type
argument_list|,
name|actual
argument_list|,
name|sp
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|formal_target
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|ada_is_array_descriptor
argument_list|(
name|actual_target
argument_list|)
condition|)
return|return
name|desc_data
argument_list|(
name|actual
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|actual_type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|actual
argument_list|)
operator|!=
name|lval_memory
condition|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|actual_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|actual_type
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|actual
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|actual_type
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|=
name|place_on_stack
argument_list|(
name|val
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
return|return
name|value_addr
argument_list|(
name|actual
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|actual_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|ada_value_ind
argument_list|(
name|actual
argument_list|)
return|;
return|return
name|actual
return|;
block|}
end_function

begin_comment
comment|/* Push a descriptor of type TYPE for array value ARR on the stack at     *SP, updating *SP to reflect the new descriptor.  Return either     an lvalue representing the new descriptor, or (if TYPE is a pointer-    to-descriptor type rather than a descriptor type), a struct value*    representing a pointer to this descriptor. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|make_array_descriptor
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|arr
parameter_list|,
name|CORE_ADDR
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|bounds_type
init|=
name|desc_bounds_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|desc_type
init|=
name|desc_base_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|descriptor
init|=
name|allocate_value
argument_list|(
name|desc_type
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|bounds
init|=
name|allocate_value
argument_list|(
name|bounds_type
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|bounds_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ada_array_arity
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arr
argument_list|)
argument_list|)
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|1
control|)
block|{
name|modify_general_field
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|bounds
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|ada_array_bound
argument_list|(
name|arr
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|desc_bound_bitpos
argument_list|(
name|bounds_type
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|,
name|desc_bound_bitsize
argument_list|(
name|bounds_type
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|modify_general_field
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|bounds
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|ada_array_bound
argument_list|(
name|arr
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|desc_bound_bitpos
argument_list|(
name|bounds_type
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
argument_list|,
name|desc_bound_bitsize
argument_list|(
name|bounds_type
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bounds
operator|=
name|place_on_stack
argument_list|(
name|bounds
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|modify_general_field
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|descriptor
argument_list|)
argument_list|,
name|arr
argument_list|,
name|fat_pntr_data_bitpos
argument_list|(
name|desc_type
argument_list|)
argument_list|,
name|fat_pntr_data_bitsize
argument_list|(
name|desc_type
argument_list|)
argument_list|)
expr_stmt|;
name|modify_general_field
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|descriptor
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|bounds
argument_list|)
argument_list|,
name|fat_pntr_bounds_bitpos
argument_list|(
name|desc_type
argument_list|)
argument_list|,
name|fat_pntr_bounds_bitsize
argument_list|(
name|desc_type
argument_list|)
argument_list|)
expr_stmt|;
name|descriptor
operator|=
name|place_on_stack
argument_list|(
name|descriptor
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|value_addr
argument_list|(
name|descriptor
argument_list|)
return|;
else|else
return|return
name|descriptor
return|;
block|}
end_function

begin_comment
comment|/* Assuming a dummy frame has been established on the target, perform any     conversions needed for calling function FUNC on the NARGS actual    parameters in ARGS, other than standard C conversions.   Does    nothing if FUNC does not have Ada-style prototype data, or if NARGS    does not match the number of arguments expected.   Use *SP as a    stack pointer for additional data that must be pushed, updating its    value as needed. */
end_comment

begin_function
name|void
name|ada_convert_actuals
parameter_list|(
name|struct
name|value
modifier|*
name|func
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
name|args
index|[]
parameter_list|,
name|CORE_ADDR
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|VALUE_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|nargs
operator|!=
name|TYPE_NFIELDS
argument_list|(
name|VALUE_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|+=
literal|1
control|)
name|args
index|[
name|i
index|]
operator|=
name|convert_actual
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|func
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbol Lookup */
end_comment

begin_comment
comment|/* The vectors of symbols and blocks ultimately returned from */
end_comment

begin_comment
comment|/* ada_lookup_symbol_list. */
end_comment

begin_comment
comment|/* Current size of defn_symbols and defn_blocks */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|defn_vector_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current number of symbols found. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ndefns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
modifier|*
name|defn_symbols
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block
modifier|*
modifier|*
name|defn_blocks
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the result of a standard (literal, C-like) lookup of NAME in   * given DOMAIN. */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|standard_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|domain_enum
name|domain
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|domain
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Non-zero iff there is at least one non-function/non-enumeral symbol */
end_comment

begin_comment
comment|/* in SYMS[0..N-1].  We treat enumerals as functions, since they */
end_comment

begin_comment
comment|/* contend in overloading in the same way. */
end_comment

begin_function
specifier|static
name|int
name|is_nonfunction
parameter_list|(
name|struct
name|symbol
modifier|*
name|syms
index|[]
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If true (non-zero), then TYPE0 and TYPE1 represent equivalent    struct types.  Otherwise, they may not. */
end_comment

begin_function
specifier|static
name|int
name|equiv_types
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|,
name|struct
name|type
modifier|*
name|type1
parameter_list|)
block|{
if|if
condition|(
name|type0
operator|==
name|type1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|type0
operator|==
name|NULL
operator|||
name|type1
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|!=
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|)
operator|&&
name|ada_type_name
argument_list|(
name|type0
argument_list|)
operator|!=
name|NULL
operator|&&
name|ada_type_name
argument_list|(
name|type1
argument_list|)
operator|!=
name|NULL
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|ada_type_name
argument_list|(
name|type0
argument_list|)
argument_list|,
name|ada_type_name
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* True iff SYM0 represents the same entity as SYM1, or one that is    no more defined than that of SYM1. */
end_comment

begin_function
specifier|static
name|int
name|lesseq_defined_than
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym0
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym1
parameter_list|)
block|{
if|if
condition|(
name|sym0
operator|==
name|sym1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|sym0
argument_list|)
operator|!=
name|SYMBOL_DOMAIN
argument_list|(
name|sym1
argument_list|)
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym0
argument_list|)
operator|!=
name|SYMBOL_CLASS
argument_list|(
name|sym1
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym0
argument_list|)
condition|)
block|{
case|case
name|LOC_UNDEF
case|:
return|return
literal|1
return|;
case|case
name|LOC_TYPEDEF
case|:
block|{
name|struct
name|type
modifier|*
name|type0
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym0
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name0
init|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name1
init|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym1
argument_list|)
decl_stmt|;
name|int
name|len0
init|=
name|strlen
argument_list|(
name|name0
argument_list|)
decl_stmt|;
return|return
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|&&
operator|(
name|equiv_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
operator|||
operator|(
name|len0
operator|<
name|strlen
argument_list|(
name|name1
argument_list|)
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|name0
argument_list|,
name|name1
argument_list|,
name|len0
argument_list|)
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|name1
operator|+
name|len0
argument_list|,
literal|"___XV"
argument_list|,
literal|5
argument_list|)
operator|)
operator|)
return|;
block|}
case|case
name|LOC_CONST
case|:
return|return
name|SYMBOL_VALUE
argument_list|(
name|sym0
argument_list|)
operator|==
name|SYMBOL_VALUE
argument_list|(
name|sym1
argument_list|)
operator|&&
name|equiv_types
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym0
argument_list|)
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym1
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Append SYM to the end of defn_symbols, and BLOCK to the end of    defn_blocks, updating ndefns, and expanding defn_symbols and    defn_blocks as needed.   Do not include SYM if it is a duplicate.  */
end_comment

begin_function
specifier|static
name|void
name|add_defn_to_vec
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|tmp
decl_stmt|;
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|!=
name|NULL
condition|)
name|CHECK_TYPEDEF
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndefns
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|lesseq_defined_than
argument_list|(
name|sym
argument_list|,
name|defn_symbols
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
elseif|else
if|if
condition|(
name|lesseq_defined_than
argument_list|(
name|defn_symbols
index|[
name|i
index|]
argument_list|,
name|sym
argument_list|)
condition|)
block|{
name|defn_symbols
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|defn_blocks
index|[
name|i
index|]
operator|=
name|block
expr_stmt|;
return|return;
block|}
block|}
name|tmp
operator|=
name|defn_vector_size
expr_stmt|;
name|GROW_VECT
argument_list|(
name|defn_symbols
argument_list|,
name|tmp
argument_list|,
name|ndefns
operator|+
literal|2
argument_list|)
expr_stmt|;
name|GROW_VECT
argument_list|(
name|defn_blocks
argument_list|,
name|defn_vector_size
argument_list|,
name|ndefns
operator|+
literal|2
argument_list|)
expr_stmt|;
name|defn_symbols
index|[
name|ndefns
index|]
operator|=
name|sym
expr_stmt|;
name|defn_blocks
index|[
name|ndefns
index|]
operator|=
name|block
expr_stmt|;
name|ndefns
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for symbol NAME in given domain.    Check the global symbols if GLOBAL, the static symbols if not.  Do    wild-card match if WILD. */
end_comment

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|ada_lookup_partial_symbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|global
parameter_list|,
name|domain_enum
name|domain
parameter_list|,
name|int
name|wild
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
modifier|*
name|start
decl_stmt|;
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|length
init|=
operator|(
name|global
condition|?
name|pst
operator|->
name|n_global_syms
else|:
name|pst
operator|->
name|n_static_syms
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
operator|(
name|global
condition|?
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
else|:
name|pst
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
if|if
condition|(
name|wild
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|struct
name|partial_symbol
modifier|*
name|psym
init|=
name|start
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|psym
argument_list|)
operator|==
name|domain
operator|&&
name|wild_match
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
condition|)
return|return
name|psym
return|;
block|}
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
name|global
condition|)
block|{
name|int
name|U
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|U
operator|=
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|U
operator|-
name|i
operator|>
literal|4
condition|)
block|{
name|int
name|M
init|=
operator|(
name|U
operator|+
name|i
operator|)
operator|>>
literal|1
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
init|=
name|start
index|[
name|M
index|]
decl_stmt|;
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
index|[
literal|0
index|]
operator|<
name|name
index|[
literal|0
index|]
condition|)
name|i
operator|=
name|M
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
name|U
operator|=
name|M
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
name|i
operator|=
name|M
operator|+
literal|1
expr_stmt|;
else|else
name|U
operator|=
name|M
expr_stmt|;
block|}
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|length
condition|)
block|{
name|struct
name|partial_symbol
modifier|*
name|psym
init|=
name|start
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|psym
argument_list|)
operator|==
name|domain
condition|)
block|{
name|int
name|cmp
init|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|name_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|global
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
name|is_name_suffix
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
operator|+
name|name_len
argument_list|)
condition|)
return|return
name|psym
return|;
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|global
condition|)
block|{
name|int
name|U
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|U
operator|=
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|U
operator|-
name|i
operator|>
literal|4
condition|)
block|{
name|int
name|M
init|=
operator|(
name|U
operator|+
name|i
operator|)
operator|>>
literal|1
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
init|=
name|start
index|[
name|M
index|]
decl_stmt|;
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
index|[
literal|0
index|]
operator|<
literal|'_'
condition|)
name|i
operator|=
name|M
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
index|[
literal|0
index|]
operator|>
literal|'_'
condition|)
name|U
operator|=
name|M
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
literal|"_ada_"
argument_list|)
operator|<
literal|0
condition|)
name|i
operator|=
name|M
operator|+
literal|1
expr_stmt|;
else|else
name|U
operator|=
name|M
expr_stmt|;
block|}
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|length
condition|)
block|{
name|struct
name|partial_symbol
modifier|*
name|psym
init|=
name|start
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|psym
argument_list|)
operator|==
name|domain
condition|)
block|{
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
operator|(
name|int
operator|)
literal|'_'
operator|-
operator|(
name|int
operator|)
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|strncmp
argument_list|(
literal|"_ada_"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|cmp
operator|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
operator|+
literal|5
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|global
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
name|is_name_suffix
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
operator|+
name|name_len
operator|+
literal|5
argument_list|)
condition|)
return|return
name|psym
return|;
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find a symbol table containing symbol SYM or NULL if none.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|symtab_for_sym
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symbol
modifier|*
name|tmp_sym
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_TYPEDEF
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_LABEL
case|:
case|case
name|LOC_BLOCK
case|:
case|case
name|LOC_CONST_BYTES
case|:
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|tmp_sym
argument_list|)
if|if
condition|(
name|sym
operator|==
name|tmp_sym
condition|)
return|return
name|s
return|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|tmp_sym
argument_list|)
if|if
condition|(
name|sym
operator|==
name|tmp_sym
condition|)
return|return
name|s
return|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_TYPEDEF
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_COMPUTED
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
for|for
control|(
name|j
operator|=
name|FIRST_LOCAL_BLOCK
init|;
name|j
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|)
condition|;
name|j
operator|+=
literal|1
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|tmp_sym
argument_list|)
if|if
condition|(
name|sym
operator|==
name|tmp_sym
condition|)
return|return
name|s
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a minimal symbol matching NAME according to Ada demangling     rules. Returns NULL if there is no such minimal symbol. */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|ada_lookup_minimal_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|int
name|wild_match
init|=
operator|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"__"
argument_list|)
operator|==
name|NULL
operator|)
decl_stmt|;
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|ada_match_name
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|name
argument_list|,
name|wild_match
argument_list|)
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_solib_trampoline
condition|)
return|return
name|msymbol
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* For all subprograms that statically enclose the subprogram of the  * selected frame, add symbols matching identifier NAME in DOMAIN  * and their blocks to vectors *defn_symbols and *defn_blocks, as for  * ada_add_block_symbols (q.v.).   If WILD, treat as NAME with a  * wildcard prefix.  At the moment, this function uses a heuristic to  * find the frames of enclosing subprograms: it treats the  * pointer-sized value at location 0 from the local-variable base of a  * frame as a static link, and then searches up the call stack for a  * frame with that same local-variable base. */
end_comment

begin_function
specifier|static
name|void
name|add_symbols_from_enclosing_procs
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|domain_enum
name|domain
parameter_list|,
name|int
name|wild_match
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|i386
specifier|static
name|struct
name|symbol
name|static_link_sym
decl_stmt|;
specifier|static
name|struct
name|symbol
modifier|*
name|static_link
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|target_frame
decl_stmt|;
if|if
condition|(
name|static_link
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the local variable symbol that stands for the        * static link (when it exists). */
name|static_link
operator|=
operator|&
name|static_link_sym
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|static_link
argument_list|)
operator|=
literal|""
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|static_link
argument_list|)
operator|=
name|language_unknown
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|static_link
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|static_link
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|static_link
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|static_link
argument_list|)
operator|=
operator|-
operator|(
name|long
operator|)
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|static_link
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|frame
operator|=
name|deprecated_selected_frame
expr_stmt|;
while|while
condition|(
name|frame
operator|!=
name|NULL
operator|&&
name|ndefns
operator|==
literal|0
condition|)
block|{
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|struct
name|value
modifier|*
name|target_link_val
init|=
name|read_var_value
argument_list|(
name|static_link
argument_list|,
name|frame
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|target_link
decl_stmt|;
if|if
condition|(
name|target_link_val
operator|==
name|NULL
condition|)
break|break;
name|QUIT
expr_stmt|;
name|target_link
operator|=
name|target_link_val
expr_stmt|;
do|do
block|{
name|QUIT
expr_stmt|;
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|frame
operator|!=
name|NULL
operator|&&
name|DEPRECATED_FRAME_LOCALS_ADDRESS
argument_list|(
name|frame
argument_list|)
operator|!=
name|target_link
condition|)
do|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
break|break;
name|block
operator|=
name|get_frame_block
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
name|NULL
operator|&&
name|block_function
argument_list|(
name|block
argument_list|)
operator|!=
name|NULL
operator|&&
name|ndefns
operator|==
literal|0
condition|)
block|{
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
name|NULL
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* True if TYPE is definitely an artificial type supplied to a symbol  * for which no debugging information was given in the symbol file. */
end_comment

begin_function
specifier|static
name|int
name|is_nondebugging_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|name
operator|!=
name|NULL
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
literal|"<variable, no debug info>"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely   * duplicate other symbols in the list.  (The only case I know of where  * this happens is when object files containing stabs-in-ecoff are  * linked with files containing ordinary ecoff debugging symbols (or no  * debugging symbols)). Modifies SYMS to squeeze out deleted symbols,  * and applies the same modification to BLOCKS to maintain the  * correspondence between SYMS[i] and BLOCKS[i].  Returns the number  * of symbols in the modified list. */
end_comment

begin_function
specifier|static
name|int
name|remove_extra_symbols
parameter_list|(
name|struct
name|symbol
modifier|*
modifier|*
name|syms
parameter_list|,
name|struct
name|block
modifier|*
modifier|*
name|blocks
parameter_list|,
name|int
name|nsyms
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nsyms
condition|)
block|{
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_STATIC
operator|&&
name|is_nondebugging_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsyms
condition|;
name|j
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|syms
index|[
name|j
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|syms
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|SYMBOL_CLASS
argument_list|(
name|syms
index|[
name|j
index|]
argument_list|)
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|syms
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|+
literal|1
init|;
name|k
operator|<
name|nsyms
condition|;
name|k
operator|+=
literal|1
control|)
block|{
name|syms
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|syms
index|[
name|k
index|]
expr_stmt|;
name|blocks
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|blocks
index|[
name|k
index|]
expr_stmt|;
block|}
name|nsyms
operator|-=
literal|1
expr_stmt|;
goto|goto
name|NextSymbol
goto|;
block|}
block|}
block|}
name|i
operator|+=
literal|1
expr_stmt|;
name|NextSymbol
label|:
empty_stmt|;
block|}
return|return
name|nsyms
return|;
block|}
end_function

begin_comment
comment|/* Find symbols in DOMAIN matching NAME, in BLOCK0 and enclosing     scope and in global scopes, returning the number of matches.  Sets     *SYMS to point to a vector of matching symbols, with *BLOCKS    pointing to the vector of corresponding blocks in which those    symbols reside.  These two vectors are transient---good only to the    next call of ada_lookup_symbol_list.  Any non-function/non-enumeral symbol    match within the nest of blocks whose innermost member is BLOCK0,    is the outermost match returned (no other matches in that or    enclosing blocks is returned).  If there are any matches in or    surrounding BLOCK0, then these alone are returned. */
end_comment

begin_function
name|int
name|ada_lookup_symbol_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block0
parameter_list|,
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
modifier|*
name|syms
parameter_list|,
name|struct
name|block
modifier|*
modifier|*
modifier|*
name|blocks
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|int
name|wild_match
init|=
operator|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"__"
argument_list|)
operator|==
name|NULL
operator|)
decl_stmt|;
name|int
name|cacheIfUnique
decl_stmt|;
ifdef|#
directive|ifdef
name|TIMING
name|markTimeStart
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ndefns
operator|=
literal|0
expr_stmt|;
name|cacheIfUnique
operator|=
literal|0
expr_stmt|;
comment|/* Search specified block and its superiors.  */
name|block
operator|=
name|block0
expr_stmt|;
while|while
condition|(
name|block
operator|!=
name|NULL
condition|)
block|{
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
name|NULL
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
comment|/* If we found a non-function match, assume that's the one. */
if|if
condition|(
name|is_nonfunction
argument_list|(
name|defn_symbols
argument_list|,
name|ndefns
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* If we found ANY matches in the specified BLOCK, we're done. */
if|if
condition|(
name|ndefns
operator|>
literal|0
condition|)
goto|goto
name|done
goto|;
name|cacheIfUnique
operator|=
literal|1
expr_stmt|;
comment|/* Now add symbols from all global blocks: symbol tables, minimal symbol      tables, and psymtab's */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|primary
condition|)
continue|continue;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
name|objfile
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|domain
operator|==
name|VAR_DOMAIN
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|ada_match_name
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|name
argument_list|,
name|wild_match
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
case|case
name|mst_solib_trampoline
case|:
break|break;
default|default:
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|int
name|old_ndefns
init|=
name|ndefns
decl_stmt|;
name|QUIT
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|domain
argument_list|,
name|objfile
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndefns
operator|==
name|old_ndefns
condition|)
block|{
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|domain
argument_list|,
name|objfile
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|ada_lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|domain
argument_list|,
name|wild_match
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|primary
condition|)
continue|continue;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
name|objfile
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add symbols from all per-file blocks if we've gotten no hits.        (Not strictly correct, but perhaps better than an error).      Do the symtabs first, then check the psymtabs */
if|if
condition|(
name|ndefns
operator|==
literal|0
condition|)
block|{
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|primary
condition|)
continue|continue;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
name|objfile
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|ada_lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|domain
argument_list|,
name|wild_match
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|primary
condition|)
continue|continue;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|ada_add_block_symbols
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
name|objfile
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Finally, we try to find NAME as a local symbol in some lexically      enclosing block.  We do this last, expecting this case to be      rare. */
if|if
condition|(
name|ndefns
operator|==
literal|0
condition|)
block|{
name|add_symbols_from_enclosing_procs
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|wild_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndefns
operator|>
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|done
label|:
name|ndefns
operator|=
name|remove_extra_symbols
argument_list|(
name|defn_symbols
argument_list|,
name|defn_blocks
argument_list|,
name|ndefns
argument_list|)
expr_stmt|;
operator|*
name|syms
operator|=
name|defn_symbols
expr_stmt|;
operator|*
name|blocks
operator|=
name|defn_blocks
expr_stmt|;
ifdef|#
directive|ifdef
name|TIMING
name|markTimeStop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ndefns
return|;
block|}
end_function

begin_comment
comment|/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing   * scope and in global scopes, or NULL if none.  NAME is folded to  * lower case first, unless it is surrounded in single quotes.   * Otherwise, the result is as for ada_lookup_symbol_list, but is   * disambiguated by user query if needed. */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|ada_lookup_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block0
parameter_list|,
name|domain_enum
name|domain
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
modifier|*
name|candidate_syms
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|candidate_blocks
decl_stmt|;
name|int
name|n_candidates
decl_stmt|;
name|n_candidates
operator|=
name|ada_lookup_symbol_list
argument_list|(
name|name
argument_list|,
name|block0
argument_list|,
name|domain
argument_list|,
operator|&
name|candidate_syms
argument_list|,
operator|&
name|candidate_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_candidates
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
name|n_candidates
operator|!=
literal|1
condition|)
name|user_select_syms
argument_list|(
name|candidate_syms
argument_list|,
name|candidate_blocks
argument_list|,
name|n_candidates
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|candidate_syms
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* True iff STR is a possible encoded suffix of a normal Ada name   * that is to be ignored for matching purposes.  Suffixes of parallel  * names (e.g., XVE) are not included here.  Currently, the possible suffixes   * are given by the regular expression:  *        (X[nb]*)?(__[0-9]+|\$[0-9]+|___(LJM|X([FDBUP].*|R[^T]?)))?$  *   */
end_comment

begin_function
specifier|static
name|int
name|is_name_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'X'
condition|)
block|{
name|str
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'n'
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'b'
condition|)
return|return
literal|0
return|;
name|str
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'\000'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
literal|'_'
operator|||
name|str
index|[
literal|2
index|]
operator|==
literal|'\000'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|str
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|str
operator|+
literal|3
argument_list|,
literal|"LJM"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|str
index|[
literal|3
index|]
operator|!=
literal|'X'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|str
index|[
literal|4
index|]
operator|==
literal|'F'
operator|||
name|str
index|[
literal|4
index|]
operator|==
literal|'D'
operator|||
name|str
index|[
literal|4
index|]
operator|==
literal|'B'
operator|||
name|str
index|[
literal|4
index|]
operator|==
literal|'U'
operator|||
name|str
index|[
literal|4
index|]
operator|==
literal|'P'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|str
index|[
literal|4
index|]
operator|==
literal|'R'
operator|&&
name|str
index|[
literal|5
index|]
operator|!=
literal|'T'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|k
operator|=
literal|2
init|;
name|str
index|[
name|k
index|]
operator|!=
literal|'\0'
condition|;
name|k
operator|+=
literal|1
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|str
index|[
name|k
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|str
index|[
literal|1
index|]
operator|!=
literal|'\000'
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|1
init|;
name|str
index|[
name|k
index|]
operator|!=
literal|'\0'
condition|;
name|k
operator|+=
literal|1
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|str
index|[
name|k
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* True if NAME represents a name of the form A1.A2....An, n>=1 and   * PATN[0..PATN_LEN-1] = Ak.Ak+1.....An for some k>= 1.  Ignores  * informational suffixes of NAME (i.e., for which is_name_suffix is  * true). */
end_comment

begin_function
specifier|static
name|int
name|wild_match
parameter_list|(
specifier|const
name|char
modifier|*
name|patn
parameter_list|,
name|int
name|patn_len
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|name_len
decl_stmt|;
name|int
name|s
decl_stmt|,
name|e
decl_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|>=
name|patn_len
operator|+
literal|5
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|name
argument_list|,
literal|"_ada_"
argument_list|,
literal|5
argument_list|)
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|patn
argument_list|,
name|name
operator|+
literal|5
argument_list|,
name|patn_len
argument_list|)
operator|&&
name|is_name_suffix
argument_list|(
name|name
operator|+
name|patn_len
operator|+
literal|5
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|name_len
operator|>=
name|patn_len
condition|)
block|{
if|if
condition|(
name|DEPRECATED_STREQN
argument_list|(
name|patn
argument_list|,
name|name
argument_list|,
name|patn_len
argument_list|)
operator|&&
name|is_name_suffix
argument_list|(
name|name
operator|+
name|patn_len
argument_list|)
condition|)
return|return
literal|1
return|;
do|do
block|{
name|name
operator|+=
literal|1
expr_stmt|;
name|name_len
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|name_len
operator|>
literal|0
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
operator|)
condition|)
do|;
if|if
condition|(
name|name_len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|!
name|islower
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|+=
literal|2
expr_stmt|;
name|name_len
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|islower
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|+=
literal|1
expr_stmt|;
name|name_len
operator|-=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from BLOCK matching identifier NAME in DOMAIN to     vector *defn_symbols, updating *defn_symbols (if necessary), *SZ (the size of    the vector *defn_symbols), and *ndefns (the number of symbols    currently stored in *defn_symbols).  If WILD, treat as NAME with a    wildcard prefix. OBJFILE is the section containing BLOCK. */
end_comment

begin_function
specifier|static
name|void
name|ada_add_block_symbols
parameter_list|(
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|domain_enum
name|domain
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|wild
parameter_list|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* A matching argument symbol, if any. */
name|struct
name|symbol
modifier|*
name|arg_sym
decl_stmt|;
comment|/* Set true when we find a matching non-argument symbol */
name|int
name|found_sym
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|arg_sym
operator|=
name|NULL
expr_stmt|;
name|found_sym
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wild
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|block
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|domain
operator|&&
name|wild_match
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
name|arg_sym
operator|=
name|sym
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
continue|continue;
default|default:
name|found_sym
operator|=
literal|1
expr_stmt|;
name|fill_in_ada_prototype
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|add_defn_to_vec
argument_list|(
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|block
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|domain
condition|)
block|{
name|int
name|cmp
init|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
name|is_name_suffix
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
name|name_len
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
name|arg_sym
operator|=
name|sym
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
break|break;
default|default:
name|found_sym
operator|=
literal|1
expr_stmt|;
name|fill_in_ada_prototype
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|add_defn_to_vec
argument_list|(
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_sym
operator|&&
name|arg_sym
operator|!=
name|NULL
condition|)
block|{
name|fill_in_ada_prototype
argument_list|(
name|arg_sym
argument_list|)
expr_stmt|;
name|add_defn_to_vec
argument_list|(
name|fixup_symbol_section
argument_list|(
name|arg_sym
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wild
condition|)
block|{
name|arg_sym
operator|=
name|NULL
expr_stmt|;
name|found_sym
operator|=
literal|0
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|block
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|domain
condition|)
block|{
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
operator|(
name|int
operator|)
literal|'_'
operator|-
operator|(
name|int
operator|)
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|strncmp
argument_list|(
literal|"_ada_"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|cmp
operator|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|5
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
name|is_name_suffix
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
name|name_len
operator|+
literal|5
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
name|arg_sym
operator|=
name|sym
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
break|break;
default|default:
name|found_sym
operator|=
literal|1
expr_stmt|;
name|fill_in_ada_prototype
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|add_defn_to_vec
argument_list|(
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* NOTE: This really shouldn't be needed for _ada_ symbols.          They aren't parameters, right? */
if|if
condition|(
operator|!
name|found_sym
operator|&&
name|arg_sym
operator|!=
name|NULL
condition|)
block|{
name|fill_in_ada_prototype
argument_list|(
name|arg_sym
argument_list|)
expr_stmt|;
name|add_defn_to_vec
argument_list|(
name|fixup_symbol_section
argument_list|(
name|arg_sym
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function Types */
end_comment

begin_comment
comment|/* Assuming that SYM is the symbol for a function, fill in its type     with prototype information, if it is not already there.  */
end_comment

begin_function
specifier|static
name|void
name|fill_in_ada_prototype
parameter_list|(
name|struct
name|symbol
modifier|*
name|func
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|nargs
decl_stmt|,
name|nsyms
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|type
modifier|*
name|ftype
decl_stmt|;
name|struct
name|type
modifier|*
name|rtype
decl_stmt|;
name|size_t
name|max_fields
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
operator|||
name|TYPE_FIELDS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* We make each function type unique, so that each may have its own */
comment|/* parameter types.  This particular way of doing so wastes space: */
comment|/* it would be nicer to build the argument types while the original */
comment|/* function type is being built (FIXME). */
name|rtype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|make_function_type
argument_list|(
name|rtype
argument_list|,
operator|&
name|ftype
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|func
argument_list|)
operator|=
name|ftype
expr_stmt|;
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
name|max_fields
operator|=
literal|8
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|max_fields
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|GROW_VECT
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
argument_list|,
name|max_fields
argument_list|,
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
name|TYPE_FIELD_BITPOS
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
name|nargs
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|nargs
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
name|TYPE_FIELD_BITPOS
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
name|nargs
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|ftype
argument_list|,
name|nargs
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|nargs
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Re-allocate fields vector; if there are no fields, make the */
comment|/* fields pointer non-null anyway, to mark that this function type */
comment|/* has been filled in. */
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
block|{
specifier|static
name|struct
name|field
name|dummy_field
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|xfree
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|&
name|dummy_field
expr_stmt|;
block|}
else|else
block|{
name|struct
name|field
modifier|*
name|fields
init|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|ftype
argument_list|,
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fields
argument_list|,
operator|(
name|char
operator|*
operator|)
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
argument_list|,
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|fields
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Breakpoint-related */
end_comment

begin_decl_stmt
name|char
name|no_symtab_msg
index|[]
init|=
literal|"No symbol table is loaded.  Use the \"file\" command."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assuming that LINE is pointing at the beginning of an argument to    'break', return a pointer to the delimiter for the initial segment    of that name.  This is the first ':', ' ', or end of LINE.  */
end_comment

begin_function
name|char
modifier|*
name|ada_start_decode_line_1
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* [NOTE: strpbrk would be more elegant, but I am reluctant to be      the first to use such a library function in GDB code.] */
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
operator|!=
literal|'\000'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|+=
literal|1
control|)
empty_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* *SPEC points to a function and line number spec (as in a break    command), following any initial file name specification.     Return all symbol table/line specfications (sals) consistent with the    information in *SPEC and FILE_TABLE in the    following sense:       + FILE_TABLE is null, or the sal refers to a line in the file        named by FILE_TABLE.      + If *SPEC points to an argument with a trailing ':LINENUM',        then the sal refers to that line (or one following it as closely as         possible).      + If *SPEC does not start with '*', the sal is in a function with         that name.     Returns with 0 elements if no matching non-minimal symbols found.     If *SPEC begins with a function name of the form<NAME>, then NAME    is taken as a literal name; otherwise the function name is subject    to the usual mangling.     *SPEC is updated to point after the function/line number specification.     FUNFIRSTLINE is non-zero if we desire the first line of real code    in each function (this is ignored in the presence of a LINENUM spec.).     If CANONICAL is non-NULL, and if any of the sals require a    'canonical line spec', then *CANONICAL is set to point to an array    of strings, corresponding to and equal in length to the returned    list of sals, such that (*CANONICAL)[i] is non-null and contains a     canonical line spec for the ith returned sal, if needed.  If no     canonical line specs are required and CANONICAL is non-null,     *CANONICAL is set to NULL.     A 'canonical line spec' is simply a name (in the format of the    breakpoint command) that uniquely identifies a breakpoint position,    with no further contextual information or user selection.  It is    needed whenever the file name, function name, and line number    information supplied is insufficient for this unique    identification.  Currently overloaded functions, the name '*',     or static functions without a filename yield a canonical line spec.    The array and the line spec strings are allocated on the heap; it    is the caller's responsibility to free them.   */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|ada_finish_decode_line_1
parameter_list|(
name|char
modifier|*
modifier|*
name|spec
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_table
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|blocks
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|n_matches
decl_stmt|,
name|i
decl_stmt|,
name|line_num
decl_stmt|;
name|struct
name|symtabs_and_lines
name|selected
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|lower_name
decl_stmt|;
name|char
modifier|*
name|unquoted_name
decl_stmt|;
if|if
condition|(
name|file_table
operator|==
name|NULL
condition|)
name|block
operator|=
name|get_selected_block
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|file_table
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
operator|!=
name|NULL
condition|)
operator|*
name|canonical
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|name
operator|=
operator|*
name|spec
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|spec
operator|==
literal|'*'
condition|)
operator|*
name|spec
operator|+=
literal|1
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|*
operator|*
name|spec
operator|!=
literal|'\000'
operator|&&
operator|!
name|strchr
argument_list|(
name|ada_completer_word_break_characters
argument_list|,
operator|*
operator|*
name|spec
argument_list|)
condition|)
operator|*
name|spec
operator|+=
literal|1
expr_stmt|;
block|}
name|len
operator|=
operator|*
name|spec
operator|-
name|name
expr_stmt|;
name|line_num
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|file_table
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|spec
operator|)
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|isdigit
argument_list|(
operator|(
operator|*
name|spec
operator|)
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|line_num
operator|=
name|strtol
argument_list|(
operator|*
name|spec
operator|+
literal|1
argument_list|,
name|spec
argument_list|,
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|spec
operator|==
literal|' '
operator|||
operator|*
operator|*
name|spec
operator|==
literal|'\t'
condition|)
operator|*
name|spec
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|line_num
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Wild-card function with no line number or file name."
argument_list|)
expr_stmt|;
return|return
name|all_sals_for_line
argument_list|(
name|file_table
operator|->
name|filename
argument_list|,
name|line_num
argument_list|,
name|canonical
argument_list|)
return|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
block|{
name|name
operator|+=
literal|1
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|unquoted_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|unquoted_name
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|unquoted_name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\000'
expr_stmt|;
name|lower_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|unquoted_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|unquoted_name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|unquoted_name
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|lower_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|1
control|)
name|lower_name
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lower_name
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
name|n_matches
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lower_name
operator|!=
name|NULL
condition|)
name|n_matches
operator|=
name|ada_lookup_symbol_list
argument_list|(
name|ada_mangle
argument_list|(
name|lower_name
argument_list|)
argument_list|,
name|block
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|&
name|symbols
argument_list|,
operator|&
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_matches
operator|==
literal|0
condition|)
name|n_matches
operator|=
name|ada_lookup_symbol_list
argument_list|(
name|unquoted_name
argument_list|,
name|block
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|&
name|symbols
argument_list|,
operator|&
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_matches
operator|==
literal|0
operator|&&
name|line_num
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"No line number information found for %s."
argument_list|,
name|unquoted_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n_matches
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HPPA_COMPILER_BUG
comment|/* FIXME: See comment in symtab.c::decode_line_1 */
undef|#
directive|undef
name|volatile
specifier|volatile
name|struct
name|symtab_and_line
name|val
decl_stmt|;
define|#
directive|define
name|volatile
comment|/*nothing */
else|#
directive|else
name|struct
name|symtab_and_line
name|val
decl_stmt|;
endif|#
directive|endif
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
name|msymbol
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lower_name
operator|!=
name|NULL
condition|)
name|msymbol
operator|=
name|ada_lookup_minimal_symbol
argument_list|(
name|ada_mangle
argument_list|(
name|lower_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
name|msymbol
operator|=
name|ada_lookup_minimal_symbol
argument_list|(
name|unquoted_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|val
operator|.
name|pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|val
operator|.
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
name|val
operator|.
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|SKIP_PROLOGUE
argument_list|(
name|val
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
name|selected
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|selected
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|selected
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|selected
return|;
block|}
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_minimal_symbols
argument_list|()
condition|)
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Function \"%s\" not defined."
argument_list|,
name|unquoted_name
argument_list|)
expr_stmt|;
return|return
name|selected
return|;
comment|/* for lint */
block|}
if|if
condition|(
name|line_num
operator|>=
literal|0
condition|)
block|{
return|return
name|find_sal_from_funcs_and_line
argument_list|(
name|file_table
operator|->
name|filename
argument_list|,
name|line_num
argument_list|,
name|symbols
argument_list|,
name|n_matches
argument_list|)
return|;
block|}
else|else
block|{
name|selected
operator|.
name|nelts
operator|=
name|user_select_syms
argument_list|(
name|symbols
argument_list|,
name|blocks
argument_list|,
name|n_matches
argument_list|,
name|n_matches
argument_list|)
expr_stmt|;
block|}
name|selected
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
operator|*
name|selected
operator|.
name|nelts
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|selected
operator|.
name|sals
argument_list|,
literal|0
argument_list|,
name|selected
operator|.
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|selected
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|selected
operator|.
name|sals
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|selected
operator|.
name|nelts
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|symbols
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
name|selected
operator|.
name|sals
index|[
name|i
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|symbols
index|[
name|i
index|]
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|symbols
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|selected
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|=
name|symtab_for_sym
argument_list|(
name|symbols
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|selected
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
operator|=
name|SYMBOL_LINE
argument_list|(
name|symbols
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_num
operator|>=
literal|0
condition|)
block|{
comment|/* Ignore this choice */
name|symbols
index|[
name|i
index|]
operator|=
name|symbols
index|[
name|selected
operator|.
name|nelts
operator|-
literal|1
index|]
expr_stmt|;
name|blocks
index|[
name|i
index|]
operator|=
name|blocks
index|[
name|selected
operator|.
name|nelts
operator|-
literal|1
index|]
expr_stmt|;
name|selected
operator|.
name|nelts
operator|-=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
name|error
argument_list|(
literal|"Line number not known for symbol \"%s\""
argument_list|,
name|unquoted_name
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|canonical
operator|!=
name|NULL
operator|&&
operator|(
name|line_num
operator|>=
literal|0
operator|||
name|n_matches
operator|>
literal|1
operator|)
condition|)
block|{
operator|*
name|canonical
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|selected
operator|.
name|nelts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|selected
operator|.
name|nelts
condition|;
name|i
operator|+=
literal|1
control|)
operator|(
operator|*
name|canonical
operator|)
index|[
name|i
index|]
operator|=
name|extended_canonical_line_spec
argument_list|(
name|selected
operator|.
name|sals
index|[
name|i
index|]
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|symbols
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|selected
return|;
block|}
end_function

begin_comment
comment|/* The (single) sal corresponding to line LINE_NUM in a symbol table    with file name FILENAME that occurs in one of the functions listed     in SYMBOLS[0 .. NSYMS-1]. */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|find_sal_from_funcs_and_line
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line_num
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|int
name|nsyms
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|int
name|best_index
decl_stmt|,
name|best
decl_stmt|;
name|struct
name|linetable
modifier|*
name|best_linetable
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
decl_stmt|;
name|read_all_symtabs
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|best_index
operator|=
literal|0
expr_stmt|;
name|best_linetable
operator|=
name|NULL
expr_stmt|;
name|best_symtab
operator|=
name|NULL
expr_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|,
name|exact
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|DEPRECATED_STREQ
argument_list|(
name|filename
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ind
operator|=
name|find_line_in_linetable
argument_list|(
name|l
argument_list|,
name|line_num
argument_list|,
name|symbols
argument_list|,
name|nsyms
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|exact
condition|)
block|{
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|best
operator|==
literal|0
operator|||
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
expr_stmt|;
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Line number not found in designated function."
argument_list|)
expr_stmt|;
name|done
label|:
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|init_sal
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|best_linetable
operator|->
name|item
index|[
name|best_index
index|]
operator|.
name|line
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|best_linetable
operator|->
name|item
index|[
name|best_index
index|]
operator|.
name|pc
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|symtab
operator|=
name|best_symtab
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Return the index in LINETABLE of the best match for LINE_NUM whose    pc falls within one of the functions denoted by SYMBOLS[0..NSYMS-1].      Set *EXACTP to the 1 if the match is exact, and 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|find_line_in_linetable
parameter_list|(
name|struct
name|linetable
modifier|*
name|linetable
parameter_list|,
name|int
name|line_num
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|int
name|nsyms
parameter_list|,
name|int
modifier|*
name|exactp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|best_index
decl_stmt|,
name|best
decl_stmt|;
if|if
condition|(
name|line_num
operator|<=
literal|0
operator|||
name|linetable
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|linetable
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|best_index
operator|=
operator|-
literal|1
operator|,
name|best
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|int
name|k
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nsyms
condition|;
name|k
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|symbols
index|[
name|k
index|]
operator|!=
name|NULL
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|symbols
index|[
name|k
index|]
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|item
operator|->
name|pc
operator|>=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbols
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|&&
name|item
operator|->
name|pc
operator|<
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbols
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
goto|goto
name|candidate
goto|;
block|}
continue|continue;
name|candidate
label|:
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|line_num
condition|)
block|{
operator|*
name|exactp
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|item
operator|->
name|line
operator|>
name|line_num
operator|&&
operator|(
name|best
operator|==
literal|0
operator|||
name|item
operator|->
name|line
operator|<
name|best
operator|)
condition|)
block|{
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
operator|*
name|exactp
operator|=
literal|0
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_comment
comment|/* Find the smallest k>= LINE_NUM such that k is a line number in    LINETABLE, and k falls strictly within a named function that begins at    or before LINE_NUM.  Return -1 if there is no such k. */
end_comment

begin_function
specifier|static
name|int
name|nearest_line_number_in_linetable
parameter_list|(
name|struct
name|linetable
modifier|*
name|linetable
parameter_list|,
name|int
name|line_num
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|best
decl_stmt|;
if|if
condition|(
name|line_num
operator|<=
literal|0
operator|||
name|linetable
operator|==
name|NULL
operator|||
name|linetable
operator|->
name|nitems
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|linetable
operator|->
name|nitems
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|best
operator|=
name|INT_MAX
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|int
name|k
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|>=
name|line_num
operator|&&
name|item
operator|->
name|line
operator|<
name|best
condition|)
block|{
name|char
modifier|*
name|func_name
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
name|func_name
operator|=
name|NULL
expr_stmt|;
name|find_pc_partial_function
argument_list|(
name|item
operator|->
name|pc
argument_list|,
operator|&
name|func_name
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_name
operator|!=
name|NULL
operator|&&
name|item
operator|->
name|pc
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|line_num
condition|)
return|return
name|line_num
return|;
else|else
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|standard_lookup
argument_list|(
name|func_name
argument_list|,
name|VAR_DOMAIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_plausible_func_for_line
argument_list|(
name|sym
argument_list|,
name|line_num
argument_list|)
condition|)
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
else|else
block|{
do|do
name|i
operator|+=
literal|1
expr_stmt|;
do|while
condition|(
name|i
operator|<
name|len
operator|&&
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|end
condition|)
do|;
continue|continue;
block|}
block|}
block|}
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|best
operator|==
name|INT_MAX
operator|)
condition|?
operator|-
literal|1
else|:
name|best
return|;
block|}
end_function

begin_comment
comment|/* Return the next higher index, k, into LINETABLE such that k> IND,     entry k in LINETABLE has a line number equal to LINE_NUM, k    corresponds to a PC that is in a function different from that     corresponding to IND, and falls strictly within a named function    that begins at a line at or preceding STARTING_LINE.      Return -1 if there is no such k.      IND == -1 corresponds to no function. */
end_comment

begin_function
specifier|static
name|int
name|find_next_line_in_linetable
parameter_list|(
name|struct
name|linetable
modifier|*
name|linetable
parameter_list|,
name|int
name|line_num
parameter_list|,
name|int
name|starting_line
parameter_list|,
name|int
name|ind
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|line_num
operator|<=
literal|0
operator|||
name|linetable
operator|==
name|NULL
operator|||
name|ind
operator|>=
name|linetable
operator|->
name|nitems
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|linetable
operator|->
name|nitems
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|linetable
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
condition|)
block|{
while|while
condition|(
name|ind
operator|<
name|len
operator|&&
name|linetable
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
operator|<
name|end
condition|)
name|ind
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|ind
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|ind
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|ind
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|int
name|k
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|>=
name|line_num
condition|)
block|{
name|char
modifier|*
name|func_name
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
name|func_name
operator|=
name|NULL
expr_stmt|;
name|find_pc_partial_function
argument_list|(
name|item
operator|->
name|pc
argument_list|,
operator|&
name|func_name
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_name
operator|!=
name|NULL
operator|&&
name|item
operator|->
name|pc
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|line_num
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|standard_lookup
argument_list|(
name|func_name
argument_list|,
name|VAR_DOMAIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_plausible_func_for_line
argument_list|(
name|sym
argument_list|,
name|starting_line
argument_list|)
condition|)
return|return
name|i
return|;
else|else
block|{
while|while
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|len
operator|&&
name|linetable
operator|->
name|item
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|pc
operator|<
name|end
condition|)
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* True iff function symbol SYM starts somewhere at or before line #    LINE_NUM. */
end_comment

begin_function
specifier|static
name|int
name|is_plausible_func_for_line
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|line_num
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|start_sal
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|start_sal
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|start_sal
operator|.
name|line
operator|!=
literal|0
operator|&&
name|line_num
operator|>=
name|start_sal
operator|.
name|line
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_print_lines
parameter_list|(
name|struct
name|linetable
modifier|*
name|lt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lt
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lt
operator|->
name|nitems
condition|;
name|i
operator|+=
literal|1
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%d->%p) "
argument_list|,
name|lt
operator|->
name|item
index|[
name|i
index|]
operator|.
name|line
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lt
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_print_block
parameter_list|(
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Block: %p; [0x%lx, 0x%lx]"
argument_list|,
name|b
argument_list|,
name|BLOCK_START
argument_list|(
name|b
argument_list|)
argument_list|,
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" Function: %s"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t    Superblock: %p\n"
argument_list|,
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t    Symbols:"
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_print_blocks
parameter_list|(
name|struct
name|blockvector
modifier|*
name|bv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bv
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6d. "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|debug_print_block
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|debug_print_symtab
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Symtab %p\n    File: %s; Dir: %s\n"
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|s
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    Blockvector: %p, Primary: %d\n"
argument_list|,
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|->
name|primary
argument_list|)
expr_stmt|;
name|debug_print_blocks
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    Line table: %p\n"
argument_list|,
name|LINETABLE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|debug_print_lines
argument_list|(
name|LINETABLE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all symbol tables corresponding to partial symbol tables    with file name FILENAME. */
end_comment

begin_function
specifier|static
name|void
name|read_all_symtabs
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|filename
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
condition|)
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All sals corresponding to line LINE_NUM in a symbol table from file    FILENAME, as filtered by the user.  If CANONICAL is not null, set    it to a corresponding array of canonical line specs. */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|all_sals_for_line
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line_num
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|result
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|read_all_symtabs
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|result
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|result
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|result
operator|.
name|sals
argument_list|)
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|int
name|ind
decl_stmt|,
name|target_line_num
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|DEPRECATED_STREQ
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
condition|)
continue|continue;
name|target_line_num
operator|=
name|nearest_line_number_in_linetable
argument_list|(
name|LINETABLE
argument_list|(
name|s
argument_list|)
argument_list|,
name|line_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_line_num
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|ind
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ind
operator|=
name|find_next_line_in_linetable
argument_list|(
name|LINETABLE
argument_list|(
name|s
argument_list|)
argument_list|,
name|target_line_num
argument_list|,
name|line_num
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
break|break;
name|GROW_VECT
argument_list|(
name|result
operator|.
name|sals
argument_list|,
name|len
argument_list|,
name|result
operator|.
name|nelts
operator|+
literal|1
argument_list|)
expr_stmt|;
name|init_sal
argument_list|(
operator|&
name|result
operator|.
name|sals
index|[
name|result
operator|.
name|nelts
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|sals
index|[
name|result
operator|.
name|nelts
index|]
operator|.
name|line
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
expr_stmt|;
name|result
operator|.
name|sals
index|[
name|result
operator|.
name|nelts
index|]
operator|.
name|pc
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
expr_stmt|;
name|result
operator|.
name|sals
index|[
name|result
operator|.
name|nelts
index|]
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|result
operator|.
name|nelts
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|canonical
operator|!=
name|NULL
operator|||
name|result
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|int
name|k
decl_stmt|;
name|char
modifier|*
modifier|*
name|func_names
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|result
operator|.
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|first_choice
init|=
operator|(
name|result
operator|.
name|nelts
operator|>
literal|1
operator|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
modifier|*
name|choices
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|result
operator|.
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|result
operator|.
name|nelts
condition|;
name|k
operator|+=
literal|1
control|)
block|{
name|find_pc_partial_function
argument_list|(
name|result
operator|.
name|sals
index|[
name|k
index|]
operator|.
name|pc
argument_list|,
operator|&
name|func_names
index|[
name|k
index|]
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_names
index|[
name|k
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Could not find function for one or more breakpoints."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"[0] cancel\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|nelts
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"[1] all\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|result
operator|.
name|nelts
condition|;
name|k
operator|+=
literal|1
control|)
name|printf_unfiltered
argument_list|(
literal|"[%d] %s\n"
argument_list|,
name|k
operator|+
name|first_choice
argument_list|,
name|ada_demangle
argument_list|(
name|func_names
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|get_selections
argument_list|(
name|choices
argument_list|,
name|result
operator|.
name|nelts
argument_list|,
name|result
operator|.
name|nelts
argument_list|,
name|result
operator|.
name|nelts
operator|>
literal|1
argument_list|,
literal|"instance-choice"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|+=
literal|1
control|)
block|{
name|result
operator|.
name|sals
index|[
name|k
index|]
operator|=
name|result
operator|.
name|sals
index|[
name|choices
index|[
name|k
index|]
index|]
expr_stmt|;
name|func_names
index|[
name|k
index|]
operator|=
name|func_names
index|[
name|choices
index|[
name|k
index|]
index|]
expr_stmt|;
block|}
name|result
operator|.
name|nelts
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|canonical
operator|!=
name|NULL
condition|)
block|{
operator|*
name|canonical
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|result
operator|.
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
operator|*
name|canonical
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|result
operator|.
name|nelts
condition|;
name|k
operator|+=
literal|1
control|)
block|{
operator|(
operator|*
name|canonical
operator|)
index|[
name|k
index|]
operator|=
name|extended_canonical_line_spec
argument_list|(
name|result
operator|.
name|sals
index|[
name|k
index|]
argument_list|,
name|func_names
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|canonical
operator|)
index|[
name|k
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Could not locate one or more breakpoints."
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
operator|(
operator|*
name|canonical
operator|)
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* A canonical line specification of the form FILE:NAME:LINENUM for    symbol table and line data SAL.  NULL if insufficient    information. The caller is responsible for releasing any space    allocated. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extended_canonical_line_spec
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
name|NULL
operator|||
name|sal
operator|.
name|symtab
operator|->
name|filename
operator|==
name|NULL
operator|||
name|sal
operator|.
name|line
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|r
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sal
operator|.
name|line
argument_list|)
operator|*
literal|3
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|r
argument_list|,
literal|"%s:'%s':%d"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int begin_bnum = -1;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|begin_annotate_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|begin_cleanup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|begin_annotate_level
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|begin_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|CORE_ADDR
name|main_program_name_addr
decl_stmt|;
name|char
name|main_program_name
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|begin_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|begin_annotate_level
operator|=
literal|2
expr_stmt|;
comment|/* Check that there is a program to debug */
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
comment|/* Check that we are debugging an Ada program */
comment|/*  if (ada_update_initial_language (language_unknown, NULL) != language_ada)      error ("Cannot find the Ada initialization procedure.  Is this an Ada main program?");    */
comment|/* FIXME: language_ada should be defined in defs.h */
comment|/* Get the address of the name of the main procedure */
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|ADA_MAIN_PROGRAM_SYMBOL_NAME
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
block|{
name|main_program_name_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_program_name_addr
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid address for Ada main program name."
argument_list|)
expr_stmt|;
comment|/* Read the name of the main procedure */
name|extract_string
argument_list|(
name|main_program_name_addr
argument_list|,
name|main_program_name
argument_list|)
expr_stmt|;
comment|/* Put a temporary breakpoint in the Ada main program and run */
name|do_command
argument_list|(
literal|"tbreak "
argument_list|,
name|main_program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_command
argument_list|(
literal|"run "
argument_list|,
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we could not find the symbol containing the name of the          main program, that means that the compiler that was used to build          was not recent enough. In that case, we fallback to the previous          mechanism, which is a little bit less reliable, but has proved to work          in most cases. The only cases where it will fail is when the user          has set some breakpoints which will be hit before the end of the          begin command processing (eg in the initialization code).           The begining of the main Ada subprogram is located by breaking          on the adainit procedure. Since we know that the binder generates          the call to this procedure exactly 2 calls before the call to the          Ada main subprogram, it is then easy to put a breakpoint on this          Ada main subprogram once we hit adainit.        */
name|do_command
argument_list|(
literal|"tbreak adainit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_command
argument_list|(
literal|"run "
argument_list|,
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_command
argument_list|(
literal|"up"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_command
argument_list|(
literal|"tbreak +2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_command
argument_list|(
literal|"continue"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_command
argument_list|(
literal|"step"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|is_ada_runtime_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
return|return
operator|(
name|DEPRECATED_STREQN
argument_list|(
name|filename
argument_list|,
literal|"s-"
argument_list|,
literal|2
argument_list|)
operator|||
name|DEPRECATED_STREQN
argument_list|(
name|filename
argument_list|,
literal|"a-"
argument_list|,
literal|2
argument_list|)
operator|||
name|DEPRECATED_STREQN
argument_list|(
name|filename
argument_list|,
literal|"g-"
argument_list|,
literal|2
argument_list|)
operator|||
name|DEPRECATED_STREQN
argument_list|(
name|filename
argument_list|,
literal|"i-"
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* find the first frame that contains debugging information and that is not    part of the Ada run-time, starting from fi and moving upward. */
end_comment

begin_function
name|int
name|find_printable_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
for|for
control|(
init|;
name|fi
operator|!=
name|NULL
condition|;
name|level
operator|+=
literal|1
operator|,
name|fi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
control|)
block|{
name|find_frame_sal
argument_list|(
name|fi
argument_list|,
operator|&
name|sal
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|&&
operator|!
name|is_ada_runtime_file
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VXWORKS_TARGET
argument_list|)
comment|/* libpthread.so contains some debugging information that prevents us 	     from finding the right frame */
if|if
condition|(
name|sal
operator|.
name|symtab
operator|->
name|objfile
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|objfile
operator|->
name|name
argument_list|,
literal|"/usr/shlib/libpthread.so"
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
name|deprecated_selected_frame
operator|=
name|fi
expr_stmt|;
break|break;
block|}
block|}
return|return
name|level
return|;
block|}
end_function

begin_function
name|void
name|ada_report_exception_break
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
comment|/* FIXME: break_on_exception should be defined in breakpoint.h */
comment|/*  if (b->break_on_exception == 1)      {      /* Assume that cond has 16 elements, the 15th    being the exception */
comment|/*    if (b->cond&& b->cond->nelts == 16)    {    ui_out_text (uiout, "on ");    ui_out_field_string (uiout, "exception",    SYMBOL_NAME (b->cond->elts[14].symbol));    }    else    ui_out_text (uiout, "on all exceptions");    }    else if (b->break_on_exception == 2)    ui_out_text (uiout, "on unhandled exception");    else if (b->break_on_exception == 3)    ui_out_text (uiout, "on assert failure");    #else    if (b->break_on_exception == 1)    { */
comment|/* Assume that cond has 16 elements, the 15th    being the exception */
comment|/*    if (b->cond&& b->cond->nelts == 16)    {    fputs_filtered ("on ", gdb_stdout);    fputs_filtered (SYMBOL_NAME    (b->cond->elts[14].symbol), gdb_stdout);    }    else    fputs_filtered ("on all exceptions", gdb_stdout);    }    else if (b->break_on_exception == 2)    fputs_filtered ("on unhandled exception", gdb_stdout);    else if (b->break_on_exception == 3)    fputs_filtered ("on assert failure", gdb_stdout);  */
block|}
end_function

begin_function
name|int
name|ada_is_exception_sym
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|char
modifier|*
name|type_name
init|=
name|type_name_no_tag
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
operator|&&
name|type_name
operator|!=
name|NULL
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|type_name
argument_list|,
literal|"exception"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ada_maybe_exception_partial_symbol
parameter_list|(
name|struct
name|partial_symbol
modifier|*
name|sym
parameter_list|)
block|{
return|return
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If ARG points to an Ada exception or assert breakpoint, rewrite    into equivalent form.  Return resulting argument string. Set    *BREAK_ON_EXCEPTIONP to 1 for ordinary break on exception, 2 for    break on unhandled, 3 for assert, 0 otherwise. */
end_comment

begin_function
name|char
modifier|*
name|ada_breakpoint_rewrite
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|break_on_exceptionp
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
name|arg
return|;
operator|*
name|break_on_exceptionp
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: language_ada should be defined in defs.h */
comment|/*  if (current_language->la_language == language_ada&& DEPRECATED_STREQN (arg, "exception", 9)&&      (arg[9] == ' ' || arg[9] == '\t' || arg[9] == '\0'))      {      char *tok, *end_tok;      int toklen;       *break_on_exceptionp = 1;       tok = arg+9;      while (*tok == ' ' || *tok == '\t')      tok += 1;       end_tok = tok;       while (*end_tok != ' '&& *end_tok != '\t'&& *end_tok != '\000')      end_tok += 1;       toklen = end_tok - tok;       arg = (char*) xmalloc (sizeof ("__gnat_raise_nodefer_with_msg if "      "long_integer(e) = long_integer(&)")      + toklen + 1);      make_cleanup (xfree, arg);      if (toklen == 0)      strcpy (arg, "__gnat_raise_nodefer_with_msg");      else if (DEPRECATED_STREQN (tok, "unhandled", toklen))      {      *break_on_exceptionp = 2;      strcpy (arg, "__gnat_unhandled_exception");      }      else      {      sprintf (arg, "__gnat_raise_nodefer_with_msg if "      "long_integer(e) = long_integer(&%.*s)",       toklen, tok);      }      }      else if (current_language->la_language == language_ada&& DEPRECATED_STREQN (arg, "assert", 6)&&      (arg[6] == ' ' || arg[6] == '\t' || arg[6] == '\0'))      {      char *tok = arg + 6;       *break_on_exceptionp = 3;       arg = (char*)       xmalloc (sizeof ("system__assertions__raise_assert_failure")      + strlen (tok) + 1);      make_cleanup (xfree, arg);      sprintf (arg, "system__assertions__raise_assert_failure%s", tok);      }    */
return|return
name|arg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Field Access */
end_comment

begin_comment
comment|/* True if field number FIELD_NUM in struct or union type TYPE is supposed    to be invisible to users. */
end_comment

begin_function
name|int
name|ada_is_ignored_field
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|)
block|{
if|if
condition|(
name|field_num
operator|<
literal|0
operator|||
name|field_num
operator|>
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
return|return
operator|(
name|name
operator|==
name|NULL
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|DEPRECATED_STREQN
argument_list|(
name|name
argument_list|,
literal|"_parent"
argument_list|,
literal|7
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* True iff structure type TYPE has a tag field. */
end_comment

begin_function
name|int
name|ada_is_tagged_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|ada_lookup_struct_elt_type
argument_list|(
name|type
argument_list|,
literal|"_tag"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The type of the tag on VAL. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_tag_type
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
return|return
name|ada_lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|"_tag"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The value of the tag on VAL. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_value_tag
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
return|return
name|ada_value_struct_elt
argument_list|(
name|val
argument_list|,
literal|"_tag"
argument_list|,
literal|"record"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The parent type of TYPE, or NULL if none. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_parent_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|ada_is_parent_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* True iff field number FIELD_NUM of structure type TYPE contains the     parent-type (inherited) fields of a derived type.  Assumes TYPE is     a structure type with at least FIELD_NUM+1 fields. */
end_comment

begin_function
name|int
name|ada_is_parent_field
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
return|return
operator|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|DEPRECATED_STREQN
argument_list|(
name|name
argument_list|,
literal|"PARENT"
argument_list|,
literal|6
argument_list|)
operator|||
name|DEPRECATED_STREQN
argument_list|(
name|name
argument_list|,
literal|"_parent"
argument_list|,
literal|7
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True iff field number FIELD_NUM of structure type TYPE is a     transparent wrapper field (which should be silently traversed when doing    field selection and flattened when printing).  Assumes TYPE is a     structure type with at least FIELD_NUM+1 fields.  Such fields are always    structures. */
end_comment

begin_function
name|int
name|ada_is_wrapper_field
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
return|return
operator|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|DEPRECATED_STREQN
argument_list|(
name|name
argument_list|,
literal|"PARENT"
argument_list|,
literal|6
argument_list|)
operator|||
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
literal|"REP"
argument_list|)
operator|||
name|DEPRECATED_STREQN
argument_list|(
name|name
argument_list|,
literal|"_parent"
argument_list|,
literal|7
argument_list|)
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'S'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'R'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'O'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True iff field number FIELD_NUM of structure or union type TYPE     is a variant wrapper.  Assumes TYPE is a structure type with at least     FIELD_NUM+1 fields. */
end_comment

begin_function
name|int
name|ada_is_variant_part
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|field_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
operator|(
name|is_dynamic_field
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|field_type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming that VAR_TYPE is a variant wrapper (type of the variant part)    whose discriminants are contained in the record type OUTER_TYPE,     returns the type of the controlling discriminant for the variant.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_variant_discrim_type
parameter_list|(
name|struct
name|type
modifier|*
name|var_type
parameter_list|,
name|struct
name|type
modifier|*
name|outer_type
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|ada_variant_discrim_name
argument_list|(
name|var_type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|ada_lookup_struct_elt_type
argument_list|(
name|outer_type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|builtin_type_int
return|;
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Assuming that TYPE is the type of a variant wrapper, and FIELD_NUM is a     valid field number within it, returns 1 iff field FIELD_NUM of TYPE    represents a 'when others' clause; otherwise 0. */
end_comment

begin_function
name|int
name|ada_is_others_clause
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
return|return
operator|(
name|name
operator|!=
name|NULL
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'O'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming that TYPE0 is the type of the variant part of a record,    returns the name of the discriminant controlling the variant.  The    value is valid until the next call to ada_variant_discrim_name. */
end_comment

begin_function
name|char
modifier|*
name|ada_variant_discrim_name
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|result_len
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|discrim_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|discrim_start
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|type0
expr_stmt|;
name|name
operator|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\000'
condition|)
return|return
literal|""
return|;
for|for
control|(
name|discrim_end
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|6
init|;
name|discrim_end
operator|!=
name|name
condition|;
name|discrim_end
operator|-=
literal|1
control|)
block|{
if|if
condition|(
name|DEPRECATED_STREQN
argument_list|(
name|discrim_end
argument_list|,
literal|"___XVN"
argument_list|,
literal|6
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|discrim_end
operator|==
name|name
condition|)
return|return
literal|""
return|;
for|for
control|(
name|discrim_start
operator|=
name|discrim_end
init|;
name|discrim_start
operator|!=
name|name
operator|+
literal|3
condition|;
name|discrim_start
operator|-=
literal|1
control|)
block|{
if|if
condition|(
name|discrim_start
operator|==
name|name
operator|+
literal|1
condition|)
return|return
literal|""
return|;
if|if
condition|(
operator|(
name|discrim_start
operator|>
name|name
operator|+
literal|3
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|discrim_start
operator|-
literal|3
argument_list|,
literal|"___"
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
name|discrim_start
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
break|break;
block|}
name|GROW_VECT
argument_list|(
name|result
argument_list|,
name|result_len
argument_list|,
name|discrim_end
operator|-
name|discrim_start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|discrim_start
argument_list|,
name|discrim_end
operator|-
name|discrim_start
argument_list|)
expr_stmt|;
name|result
index|[
name|discrim_end
operator|-
name|discrim_start
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Scan STR for a subtype-encoded number, beginning at position K. Put the     position of the character just past the number scanned in *NEW_K,     if NEW_K!=NULL. Put the scanned number in *R, if R!=NULL.  Return 1     if there was a valid number at the given position, and 0 otherwise.  A     "subtype-encoded" number consists of the absolute value in decimal,     followed by the letter 'm' to indicate a negative number.  Assumes 0m     does not occur. */
end_comment

begin_function
name|int
name|ada_scan_number
parameter_list|(
specifier|const
name|char
name|str
index|[]
parameter_list|,
name|int
name|k
parameter_list|,
name|LONGEST
modifier|*
name|R
parameter_list|,
name|int
modifier|*
name|new_k
parameter_list|)
block|{
name|ULONGEST
name|RU
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|str
index|[
name|k
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Do it the hard way so as not to make any assumption about       the relationship of unsigned long (%lu scan format code) and      LONGEST. */
name|RU
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|str
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|RU
operator|=
name|RU
operator|*
literal|10
operator|+
operator|(
name|str
index|[
name|k
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|k
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|str
index|[
name|k
index|]
operator|==
literal|'m'
condition|)
block|{
if|if
condition|(
name|R
operator|!=
name|NULL
condition|)
operator|*
name|R
operator|=
operator|(
operator|-
call|(
name|LONGEST
call|)
argument_list|(
name|RU
operator|-
literal|1
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|k
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|R
operator|!=
name|NULL
condition|)
operator|*
name|R
operator|=
operator|(
name|LONGEST
operator|)
name|RU
expr_stmt|;
comment|/* NOTE on the above: Technically, C does not say what the results of       - (LONGEST) RU or (LONGEST) -RU are for RU == largest positive      number representable as a LONGEST (although either would probably work      in most implementations).  When RU>0, the locution in the then branch      above is always equivalent to the negative of RU. */
if|if
condition|(
name|new_k
operator|!=
name|NULL
condition|)
operator|*
name|new_k
operator|=
name|k
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Assuming that TYPE is a variant part wrapper type (a VARIANTS field),     and FIELD_NUM is a valid field number within it, returns 1 iff VAL is     in the range encoded by field FIELD_NUM of TYPE; otherwise 0. */
end_comment

begin_function
name|int
name|ada_in_variant
parameter_list|(
name|LONGEST
name|val
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
name|int
name|p
decl_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|name
index|[
name|p
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
literal|0
return|;
case|case
literal|'S'
case|:
block|{
name|LONGEST
name|W
decl_stmt|;
if|if
condition|(
operator|!
name|ada_scan_number
argument_list|(
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|W
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|val
operator|==
name|W
condition|)
return|return
literal|1
return|;
break|break;
block|}
case|case
literal|'R'
case|:
block|{
name|LONGEST
name|L
decl_stmt|,
name|U
decl_stmt|;
if|if
condition|(
operator|!
name|ada_scan_number
argument_list|(
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|L
argument_list|,
operator|&
name|p
argument_list|)
operator|||
name|name
index|[
name|p
index|]
operator|!=
literal|'T'
operator|||
operator|!
name|ada_scan_number
argument_list|(
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|U
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|val
operator|>=
name|L
operator|&&
name|val
operator|<=
name|U
condition|)
return|return
literal|1
return|;
break|break;
block|}
case|case
literal|'O'
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a value ARG1 (offset by OFFSET bytes)    of a struct or union type ARG_TYPE,    extract and return the value of one of its (non-static) fields.    FIELDNO says which field.   Differs from value_primitive_field only    in that it can handle packed values of arbitrary type. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_value_primitive_field
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|fieldno
parameter_list|,
name|struct
name|type
modifier|*
name|arg_type
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
comment|/* Handle packed fields */
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|bit_pos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|bit_size
init|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
return|return
name|ada_value_primitive_packed_val
argument_list|(
name|arg1
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|offset
operator|+
name|bit_pos
operator|/
literal|8
argument_list|,
name|bit_pos
operator|%
literal|8
argument_list|,
name|bit_size
argument_list|,
name|type
argument_list|)
return|;
block|}
else|else
return|return
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
name|offset
argument_list|,
name|fieldno
argument_list|,
name|arg_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look for a field NAME in ARG. Adjust the address of ARG by OFFSET bytes,    and search in it assuming it has (class) type TYPE.    If found, return value, else return NULL.     Searches recursively through wrapper fields (e.g., '_parent'). */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_search_struct_field
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|value
modifier|*
name|arg
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|-=
literal|1
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|==
name|NULL
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|field_name_match
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|ada_value_primitive_field
argument_list|(
name|arg
argument_list|,
name|offset
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ada_is_wrapper_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|ada_search_struct_field
argument_list|(
name|name
argument_list|,
name|arg
argument_list|,
name|offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
return|return
name|v
return|;
block|}
elseif|else
if|if
condition|(
name|ada_is_variant_part
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|field_type
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|var_offset
init|=
name|offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
decl_stmt|;
for|for
control|(
name|j
operator|=
name|TYPE_NFIELDS
argument_list|(
name|field_type
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|1
control|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|ada_search_struct_field
argument_list|(
name|name
argument_list|,
name|arg
argument_list|,
name|var_offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|field_type
argument_list|,
name|j
argument_list|)
operator|/
literal|8
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|field_type
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
return|return
name|v
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given ARG, a value of type (pointer to a)* structure/union,    extract the component named NAME from the ultimate target structure/union    and return it as a value with its appropriate type.     The routine searches for NAME among all members of the structure itself     and (recursively) among all members of any wrapper members     (e.g., '_parent').     ERR is a name (for use in error messages) that identifies the class     of entity that ARG is supposed to be. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_value_struct_elt
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|arg
operator|=
name|ada_coerce_ref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|t
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Follow pointers until we get to a non-pointer.  */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
name|arg
operator|=
name|ada_value_ind
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|t
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Attempt to extract a component of a value that is not a %s."
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|v
operator|=
name|ada_search_struct_field
argument_list|(
name|name
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"There is no member named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given a type TYPE, look up the type of the component of type named NAME.    If DISPP is non-null, add its byte displacement from the beginning of a     structure (pointed to by a value) of type TYPE to *DISPP (does not     work for packed fields).     Matches any field whose name has NAME as a prefix, possibly    followed by "___".      TYPE can be either a struct or union, or a pointer or reference to     a struct or union.  If it is a pointer or reference, its target     type is automatically used.     Looks recursively into variant clauses and parent types.     If NOERR is nonzero, return NULL if NAME is not suitably defined. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_lookup_struct_elt_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|noerr
parameter_list|,
name|int
modifier|*
name|dispp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|BadName
goto|;
while|while
condition|(
literal|1
condition|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_REF
condition|)
break|break;
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Type "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|gdb_stderr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" is not a structure or union type"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|to_static_fixed_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|int
name|disp
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|==
name|NULL
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|field_name_match
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|dispp
operator|!=
name|NULL
condition|)
operator|*
name|dispp
operator|+=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
return|return
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ada_is_wrapper_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|disp
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|ada_lookup_struct_elt_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dispp
operator|!=
name|NULL
condition|)
operator|*
name|dispp
operator|+=
name|disp
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ada_is_variant_part
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|field_type
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|TYPE_NFIELDS
argument_list|(
name|field_type
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|1
control|)
block|{
name|disp
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|ada_lookup_struct_elt_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|field_type
argument_list|,
name|j
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dispp
operator|!=
name|NULL
condition|)
operator|*
name|dispp
operator|+=
name|disp
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
block|}
name|BadName
label|:
if|if
condition|(
operator|!
name|noerr
condition|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Type "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|gdb_stderr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|" has no component named "
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|name
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assuming that VAR_TYPE is the type of a variant part of a record (a union),    within a value of type OUTER_TYPE that is stored in GDB at    OUTER_VALADDR, determine which variant clause (field number in VAR_TYPE,     numbering from 0) is applicable.  Returns -1 if none are. */
end_comment

begin_function
name|int
name|ada_which_variant_applies
parameter_list|(
name|struct
name|type
modifier|*
name|var_type
parameter_list|,
name|struct
name|type
modifier|*
name|outer_type
parameter_list|,
name|char
modifier|*
name|outer_valaddr
parameter_list|)
block|{
name|int
name|others_clause
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|disp
decl_stmt|;
name|struct
name|type
modifier|*
name|discrim_type
decl_stmt|;
name|char
modifier|*
name|discrim_name
init|=
name|ada_variant_discrim_name
argument_list|(
name|var_type
argument_list|)
decl_stmt|;
name|LONGEST
name|discrim_val
decl_stmt|;
name|disp
operator|=
literal|0
expr_stmt|;
name|discrim_type
operator|=
name|ada_lookup_struct_elt_type
argument_list|(
name|outer_type
argument_list|,
name|discrim_name
argument_list|,
literal|1
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|discrim_type
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|discrim_val
operator|=
name|unpack_long
argument_list|(
name|discrim_type
argument_list|,
name|outer_valaddr
operator|+
name|disp
argument_list|)
expr_stmt|;
name|others_clause
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|var_type
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|ada_is_others_clause
argument_list|(
name|var_type
argument_list|,
name|i
argument_list|)
condition|)
name|others_clause
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_in_variant
argument_list|(
name|discrim_val
argument_list|,
name|var_type
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
name|others_clause
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dynamic-Sized Records */
end_comment

begin_comment
comment|/* Strategy: The type ostensibly attached to a value with dynamic size    (i.e., a size that is not statically recorded in the debugging    data) does not accurately reflect the size or layout of the value.    Our strategy is to convert these values to values with accurate,    conventional types that are constructed on the fly. */
end_comment

begin_comment
comment|/* There is a subtle and tricky problem here.  In general, we cannot    determine the size of dynamic records without its data.  However,    the 'struct value' data structure, which GDB uses to represent    quantities in the inferior process (the target), requires the size    of the type at the time of its allocation in order to reserve space    for GDB's internal copy of the data.  That's why the    'to_fixed_xxx_type' routines take (target) addresses as parameters,    rather than struct value*s.       However, GDB's internal history variables ($1, $2, etc.) are    struct value*s containing internal copies of the data that are not, in    general, the same as the data at their corresponding addresses in    the target.  Fortunately, the types we give to these values are all    conventional, fixed-size types (as per the strategy described    above), so that we don't usually have to perform the    'to_fixed_xxx_type' conversions to look at their values.    Unfortunately, there is one exception: if one of the internal    history variables is an array whose elements are unconstrained    records, then we will need to create distinct fixed types for each    element selected.  */
end_comment

begin_comment
comment|/* The upshot of all of this is that many routines take a (type, host    address, target address) triple as arguments to represent a value.    The host address, if non-null, is supposed to contain an internal    copy of the relevant data; otherwise, the program is to consult the    target at the target address. */
end_comment

begin_comment
comment|/* Assuming that VAL0 represents a pointer value, the result of    dereferencing it.  Differs from value_ind in its treatment of    dynamic-sized types. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_value_ind
parameter_list|(
name|struct
name|value
modifier|*
name|val0
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|unwrap_value
argument_list|(
name|value_ind
argument_list|(
name|val0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|ada_to_fixed_value
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The value resulting from dereferencing any "reference to"  * qualifiers on VAL0. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|ada_coerce_ref
parameter_list|(
name|struct
name|value
modifier|*
name|val0
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val0
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|val0
decl_stmt|;
name|COERCE_REF
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|unwrap_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|ada_to_fixed_value
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
else|else
return|return
name|val0
return|;
block|}
end_function

begin_comment
comment|/* Return OFF rounded upward if necessary to a multiple of    ALIGNMENT (a power of 2). */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|align_value
parameter_list|(
name|unsigned
name|int
name|off
parameter_list|,
name|unsigned
name|int
name|alignment
parameter_list|)
block|{
return|return
operator|(
name|off
operator|+
name|alignment
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the additional bit offset required by field F of template    type TYPE. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|field_offset
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|f
parameter_list|)
block|{
name|int
name|n
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
decl_stmt|;
comment|/* Kludge (temporary?) to fix problem with dwarf output. */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|unsigned
name|int
operator|)
name|n
operator|&
literal|0xffff
return|;
else|else
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Return the bit alignment required for field #F of template type TYPE. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|field_alignment
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|f
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|int
name|len
init|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|align_offset
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|8
operator|||
operator|!
name|isdigit
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
name|TARGET_CHAR_BIT
return|;
if|if
condition|(
name|isdigit
argument_list|(
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|)
condition|)
name|align_offset
operator|=
name|len
operator|-
literal|2
expr_stmt|;
else|else
name|align_offset
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|align_offset
operator|<
literal|7
operator|||
operator|!
name|DEPRECATED_STREQN
argument_list|(
literal|"___XV"
argument_list|,
name|name
operator|+
name|align_offset
operator|-
literal|6
argument_list|,
literal|5
argument_list|)
condition|)
return|return
name|TARGET_CHAR_BIT
return|;
return|return
name|atoi
argument_list|(
name|name
operator|+
name|align_offset
argument_list|)
operator|*
name|TARGET_CHAR_BIT
return|;
block|}
end_function

begin_comment
comment|/* Find a type named NAME.  Ignores ambiguity.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_find_any_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|standard_lookup
argument_list|(
name|name
argument_list|,
name|VAR_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
name|sym
operator|=
name|standard_lookup
argument_list|(
name|name
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Because of GNAT encoding conventions, several GDB symbols may match a    given type name. If the type denoted by TYPE0 is to be preferred to    that of TYPE1 for purposes of type printing, return non-zero;    otherwise return 0. */
end_comment

begin_function
name|int
name|ada_prefer_type
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|,
name|struct
name|type
modifier|*
name|type1
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|type0
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|type0
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|type0
argument_list|)
operator|&&
operator|!
name|ada_is_array_descriptor
argument_list|(
name|type1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ada_renaming_type
argument_list|(
name|type0
argument_list|)
operator|!=
name|NULL
operator|&&
name|ada_renaming_type
argument_list|(
name|type1
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The name of TYPE, which is either its TYPE_NAME, or, if that is    null, its TYPE_TAG_NAME.  Null if TYPE is null. */
end_comment

begin_function
name|char
modifier|*
name|ada_type_name
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a parallel type to TYPE whose name is formed by appending    SUFFIX to the name of TYPE. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_find_parallel_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|size_t
name|name_len
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|blocks
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|typename
init|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|typename
argument_list|)
expr_stmt|;
name|GROW_VECT
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|len
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
name|len
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
name|ada_find_any_type
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If TYPE is a variable-size record type, return the corresponding template    type describing its fields.  Otherwise, return NULL. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dynamic_template_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|||
name|ada_type_name
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|6
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
operator|+
name|len
operator|-
literal|6
argument_list|,
literal|"___XVE"
argument_list|)
condition|)
return|return
name|type
return|;
else|else
return|return
name|ada_find_parallel_type
argument_list|(
name|type
argument_list|,
literal|"___XVE"
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Assuming that TEMPL_TYPE is a union or struct type, returns    non-zero iff field FIELD_NUM of TEMPL_TYPE has dynamic size. */
end_comment

begin_function
specifier|static
name|int
name|is_dynamic_field
parameter_list|(
name|struct
name|type
modifier|*
name|templ_type
parameter_list|,
name|int
name|field_num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|templ_type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
return|return
name|name
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|templ_type
argument_list|,
name|field_num
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|strstr
argument_list|(
name|name
argument_list|,
literal|"___XVL"
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assuming that TYPE is a struct type, returns non-zero iff TYPE    contains a variant part. */
end_comment

begin_function
specifier|static
name|int
name|contains_variant_part
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|ada_is_variant_part
argument_list|(
name|type
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A record type with no fields, . */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|empty_record
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
decl_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
literal|"<empty>"
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* An ordinary record type (with fixed-length fields) that describes    the value of type TYPE at VALADDR or ADDRESS (see comments at     the beginning of this section) VAL according to GNAT conventions.      DVAL0 should describe the (portion of a) record that contains any     necessary discriminants.  It should be NULL if VALUE_TYPE (VAL) is    an outer-level type (i.e., as opposed to a branch of a variant.)  A    variant field (unless unchecked) is replaced by a particular branch    of the variant. */
end_comment

begin_comment
comment|/* NOTE: Limitations: For now, we assume that dynamic fields and  * variants occupy whole numbers of bytes.  However, they need not be  * byte-aligned.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|template_to_fixed_record_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|value
modifier|*
name|dval0
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|struct
name|value
modifier|*
name|dval
decl_stmt|;
name|struct
name|type
modifier|*
name|rtype
decl_stmt|;
name|int
name|nfields
decl_stmt|,
name|bit_len
decl_stmt|;
name|long
name|off
decl_stmt|;
name|int
name|f
decl_stmt|;
name|nfields
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|rtype
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|rtype
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|rtype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|rtype
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|rtype
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
operator|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|rtype
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME: TYPE_FLAG_FIXED_INSTANCE should be defined in      gdbtypes.h */
comment|/*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE; */
name|off
operator|=
literal|0
expr_stmt|;
name|bit_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|nfields
condition|;
name|f
operator|+=
literal|1
control|)
block|{
name|int
name|fld_bit_len
decl_stmt|,
name|bit_incr
decl_stmt|;
name|off
operator|=
name|align_value
argument_list|(
name|off
argument_list|,
name|field_alignment
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
argument_list|)
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* NOTE: used to use field_offset above, but that causes        * problems with really negative bit positions.  So, let's        * rediscover why we needed field_offset and fix it properly. */
name|TYPE_FIELD_BITPOS
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
name|off
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ada_is_variant_part
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|branch_type
decl_stmt|;
if|if
condition|(
name|dval0
operator|==
name|NULL
condition|)
name|dval
operator|=
name|value_from_contents_and_address
argument_list|(
name|rtype
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
name|dval
operator|=
name|dval0
expr_stmt|;
name|branch_type
operator|=
name|to_fixed_variant_branch_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
argument_list|,
name|cond_offset_host
argument_list|(
name|valaddr
argument_list|,
name|off
operator|/
name|TARGET_CHAR_BIT
argument_list|)
argument_list|,
name|cond_offset_target
argument_list|(
name|address
argument_list|,
name|off
operator|/
name|TARGET_CHAR_BIT
argument_list|)
argument_list|,
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_type
operator|==
name|NULL
condition|)
name|TYPE_NFIELDS
argument_list|(
name|rtype
argument_list|)
operator|-=
literal|1
expr_stmt|;
else|else
block|{
name|TYPE_FIELD_TYPE
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
name|branch_type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
literal|"S"
expr_stmt|;
block|}
name|bit_incr
operator|=
literal|0
expr_stmt|;
name|fld_bit_len
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
argument_list|)
operator|*
name|TARGET_CHAR_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_dynamic_field
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|dval0
operator|==
name|NULL
condition|)
name|dval
operator|=
name|value_from_contents_and_address
argument_list|(
name|rtype
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
name|dval
operator|=
name|dval0
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
name|ada_to_fixed_type
argument_list|(
name|ada_get_base_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|cond_offset_host
argument_list|(
name|valaddr
argument_list|,
name|off
operator|/
name|TARGET_CHAR_BIT
argument_list|)
argument_list|,
name|cond_offset_target
argument_list|(
name|address
argument_list|,
name|off
operator|/
name|TARGET_CHAR_BIT
argument_list|)
argument_list|,
name|dval
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|bit_incr
operator|=
name|fld_bit_len
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
argument_list|)
operator|*
name|TARGET_CHAR_BIT
expr_stmt|;
block|}
else|else
block|{
name|TYPE_FIELD_TYPE
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|>
literal|0
condition|)
name|bit_incr
operator|=
name|fld_bit_len
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|rtype
argument_list|,
name|f
argument_list|)
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
name|bit_incr
operator|=
name|fld_bit_len
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
argument_list|)
operator|*
name|TARGET_CHAR_BIT
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|+
name|fld_bit_len
operator|>
name|bit_len
condition|)
name|bit_len
operator|=
name|off
operator|+
name|fld_bit_len
expr_stmt|;
name|off
operator|+=
name|bit_incr
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
operator|=
name|bit_len
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
block|}
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
operator|=
name|align_value
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
operator|>
name|varsize_limit
condition|)
name|error
argument_list|(
literal|"record type with dynamic size is larger than varsize-limit"
argument_list|)
expr_stmt|;
return|return
name|rtype
return|;
block|}
end_function

begin_comment
comment|/* As for template_to_fixed_record_type, but uses no run-time values.    As a result, this type can only be approximate, but that's OK,    since it is used only for type determinations.   Works on both    structs and unions.    Representation note: to save space, we memoize the result of this    function in the TYPE_TARGET_TYPE of the template type. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|template_to_static_fixed_type
parameter_list|(
name|struct
name|type
modifier|*
name|templ_type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nfields
decl_stmt|;
name|int
name|f
decl_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|templ_type
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TYPE_TARGET_TYPE
argument_list|(
name|templ_type
argument_list|)
return|;
name|nfields
operator|=
name|TYPE_NFIELDS
argument_list|(
name|templ_type
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|templ_type
argument_list|)
operator|=
name|type
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|templ_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE
argument_list|(
name|templ_type
argument_list|)
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|ada_type_name
argument_list|(
name|templ_type
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
comment|/*  TYPE_FLAGS (type) |= TYPE_FLAG_FIXED_INSTANCE; */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|nfields
condition|;
name|f
operator|+=
literal|1
control|)
block|{
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_dynamic_field
argument_list|(
name|templ_type
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|=
name|to_static_fixed_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|templ_type
argument_list|,
name|f
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|templ_type
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|templ_type
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|templ_type
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* A revision of TYPE0 -- a non-dynamic-sized record with a variant    part -- in which the variant part is replaced with the appropriate    branch. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|to_record_with_fixed_variant_part
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|value
modifier|*
name|dval
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|struct
name|type
modifier|*
name|rtype
decl_stmt|;
name|struct
name|type
modifier|*
name|branch_type
decl_stmt|;
name|int
name|nfields
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|dval
operator|==
name|NULL
condition|)
return|return
name|type
return|;
name|rtype
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|rtype
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|rtype
argument_list|)
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|rtype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|rtype
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|rtype
argument_list|)
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
operator|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|rtype
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
comment|/*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE; */
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|branch_type
operator|=
name|to_fixed_variant_branch_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
argument_list|,
name|cond_offset_host
argument_list|(
name|valaddr
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
operator|/
name|TARGET_CHAR_BIT
argument_list|)
argument_list|,
name|cond_offset_target
argument_list|(
name|address
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
operator|/
name|TARGET_CHAR_BIT
argument_list|)
argument_list|,
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_type
operator|==
name|NULL
condition|)
block|{
name|TYPE_NFIELDS
argument_list|(
name|rtype
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
operator|-=
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_FIELD_TYPE
argument_list|(
name|rtype
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
operator|=
name|branch_type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|rtype
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
operator|=
literal|"S"
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|rtype
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|rtype
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|branch_type
argument_list|)
expr_stmt|;
operator|-
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|nfields
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rtype
return|;
block|}
end_function

begin_comment
comment|/* An ordinary record type (with fixed-length fields) that describes    the value at (TYPE0, VALADDR, ADDRESS) [see explanation at    beginning of this section].   Any necessary discriminants' values    should be in DVAL, a record value; it should be NULL if the object    at ADDR itself contains any necessary  discriminant values.  A    variant field (unless unchecked) is replaced by a particular branch    of the variant. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|to_fixed_record_type
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|value
modifier|*
name|dval
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|templ_type
decl_stmt|;
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
comment|/*  if (TYPE_FLAGS (type0)& TYPE_FLAG_FIXED_INSTANCE)      return type0;    */
name|templ_type
operator|=
name|dynamic_template_type
argument_list|(
name|type0
argument_list|)
expr_stmt|;
if|if
condition|(
name|templ_type
operator|!=
name|NULL
condition|)
return|return
name|template_to_fixed_record_type
argument_list|(
name|templ_type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|dval
argument_list|)
return|;
elseif|else
if|if
condition|(
name|contains_variant_part
argument_list|(
name|type0
argument_list|)
condition|)
return|return
name|to_record_with_fixed_variant_part
argument_list|(
name|type0
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|dval
argument_list|)
return|;
else|else
block|{
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
comment|/*      TYPE_FLAGS (type0) |= TYPE_FLAG_FIXED_INSTANCE; */
return|return
name|type0
return|;
block|}
block|}
end_function

begin_comment
comment|/* An ordinary record type (with fixed-length fields) that describes    the value at (VAR_TYPE0, VALADDR, ADDRESS), where VAR_TYPE0 is a    union type.  Any necessary discriminants' values should be in DVAL,    a record value.  That is, this routine selects the appropriate    branch of the union at ADDR according to the discriminant value    indicated in the union's type name. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|to_fixed_variant_branch_type
parameter_list|(
name|struct
name|type
modifier|*
name|var_type0
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|value
modifier|*
name|dval
parameter_list|)
block|{
name|int
name|which
decl_stmt|;
name|struct
name|type
modifier|*
name|templ_type
decl_stmt|;
name|struct
name|type
modifier|*
name|var_type
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|var_type0
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|var_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|var_type0
argument_list|)
expr_stmt|;
else|else
name|var_type
operator|=
name|var_type0
expr_stmt|;
name|templ_type
operator|=
name|ada_find_parallel_type
argument_list|(
name|var_type
argument_list|,
literal|"___XVU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|templ_type
operator|!=
name|NULL
condition|)
name|var_type
operator|=
name|templ_type
expr_stmt|;
name|which
operator|=
name|ada_which_variant_applies
argument_list|(
name|var_type
argument_list|,
name|VALUE_TYPE
argument_list|(
name|dval
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|dval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
name|empty_record
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|var_type
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|is_dynamic_field
argument_list|(
name|var_type
argument_list|,
name|which
argument_list|)
condition|)
return|return
name|to_fixed_record_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|var_type
argument_list|,
name|which
argument_list|)
argument_list|)
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|dval
argument_list|)
return|;
elseif|else
if|if
condition|(
name|contains_variant_part
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|var_type
argument_list|,
name|which
argument_list|)
argument_list|)
condition|)
return|return
name|to_fixed_record_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|var_type
argument_list|,
name|which
argument_list|)
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|dval
argument_list|)
return|;
else|else
return|return
name|TYPE_FIELD_TYPE
argument_list|(
name|var_type
argument_list|,
name|which
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming that TYPE0 is an array type describing the type of a value    at ADDR, and that DVAL describes a record containing any    discriminants used in TYPE0, returns a type for the value that    contains no dynamic components (that is, no components whose sizes    are determined by run-time quantities).  Unless IGNORE_TOO_BIG is    true, gives an error message if the resulting type's size is over    varsize_limit. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|to_fixed_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|,
name|struct
name|value
modifier|*
name|dval
parameter_list|,
name|int
name|ignore_too_big
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|index_type_desc
decl_stmt|;
name|struct
name|type
modifier|*
name|result
decl_stmt|;
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
comment|/*  if (ada_is_packed_array_type (type0)  /* revisit? */
comment|/*    || (TYPE_FLAGS (type0)& TYPE_FLAG_FIXED_INSTANCE))    return type0; */
name|index_type_desc
operator|=
name|ada_find_parallel_type
argument_list|(
name|type0
argument_list|,
literal|"___XA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type_desc
operator|==
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|elt_type0
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* NOTE: elt_type---the fixed version of elt_type0---should never        * depend on the contents of the array in properly constructed        * debugging data. */
name|struct
name|type
modifier|*
name|elt_type
init|=
name|ada_to_fixed_type
argument_list|(
name|elt_type0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dval
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt_type0
operator|==
name|elt_type
condition|)
name|result
operator|=
name|type0
expr_stmt|;
else|else
name|result
operator|=
name|create_array_type
argument_list|(
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type0
argument_list|)
argument_list|)
argument_list|,
name|elt_type
argument_list|,
name|TYPE_INDEX_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|elt_type0
decl_stmt|;
name|elt_type0
operator|=
name|type0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|index_type_desc
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|1
control|)
name|elt_type0
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|elt_type0
argument_list|)
expr_stmt|;
comment|/* NOTE: result---the fixed version of elt_type0---should never        * depend on the contents of the array in properly constructed        * debugging data. */
name|result
operator|=
name|ada_to_fixed_type
argument_list|(
name|check_typedef
argument_list|(
name|elt_type0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dval
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|index_type_desc
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|-=
literal|1
control|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|to_fixed_range_type
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|index_type_desc
argument_list|,
name|i
argument_list|)
argument_list|,
name|dval
argument_list|,
name|TYPE_OBJFILE
argument_list|(
name|type0
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|=
name|create_array_type
argument_list|(
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type0
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ignore_too_big
operator|&&
name|TYPE_LENGTH
argument_list|(
name|result
argument_list|)
operator|>
name|varsize_limit
condition|)
name|error
argument_list|(
literal|"array type with dynamic size is larger than varsize-limit"
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
comment|/*  TYPE_FLAGS (result) |= TYPE_FLAG_FIXED_INSTANCE; */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* A standard type (containing no dynamically sized components)    corresponding to TYPE for the value (TYPE, VALADDR, ADDRESS)    DVAL describes a record containing any discriminants used in TYPE0,    and may be NULL if there are none. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_to_fixed_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|value
modifier|*
name|dval
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
default|default:
return|return
name|type
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
return|return
name|to_fixed_record_type
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|to_fixed_array_type
argument_list|(
name|type
argument_list|,
name|dval
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|dval
operator|==
name|NULL
condition|)
return|return
name|type
return|;
else|else
return|return
name|to_fixed_variant_branch_type
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|dval
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* A standard (static-sized) type corresponding as well as possible to    TYPE0, but based on no runtime data. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|to_static_fixed_type
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|type0
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
comment|/*  if (TYPE_FLAGS (type0)& TYPE_FLAG_FIXED_INSTANCE)      return type0;    */
name|CHECK_TYPEDEF
argument_list|(
name|type0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type0
argument_list|)
condition|)
block|{
default|default:
return|return
name|type0
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
name|type
operator|=
name|dynamic_template_type
argument_list|(
name|type0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
return|return
name|template_to_static_fixed_type
argument_list|(
name|type
argument_list|)
return|;
return|return
name|type0
return|;
case|case
name|TYPE_CODE_UNION
case|:
name|type
operator|=
name|ada_find_parallel_type
argument_list|(
name|type0
argument_list|,
literal|"___XVU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
return|return
name|template_to_static_fixed_type
argument_list|(
name|type
argument_list|)
return|;
return|return
name|type0
return|;
block|}
block|}
end_function

begin_comment
comment|/* A static approximation of TYPE with all type wrappers removed. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|static_unwrap_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|ada_is_aligner_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|type1
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ada_type_name
argument_list|(
name|type1
argument_list|)
operator|==
name|NULL
condition|)
name|TYPE_NAME
argument_list|(
name|type1
argument_list|)
operator|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|static_unwrap_type
argument_list|(
name|type1
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|raw_real_type
init|=
name|ada_get_base_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|raw_real_type
operator|==
name|type
condition|)
return|return
name|type
return|;
else|else
return|return
name|to_static_fixed_type
argument_list|(
name|raw_real_type
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* In some cases, incomplete and private types require    cross-references that are not resolved as records (for example,        type Foo;       type FooP is access Foo;       V: FooP;       type Foo is array ...;    ). In these cases, since there is no mechanism for producing     cross-references to such types, we instead substitute for FooP a    stub enumeration type that is nowhere resolved, and whose tag is    the name of the actual type.  Call these types "non-record stubs". */
end_comment

begin_comment
comment|/* A type equivalent to TYPE that is not a non-record stub, if one    exists, otherwise TYPE. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_completed_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
operator|||
operator|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
operator|)
operator|==
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|type
return|;
else|else
block|{
name|char
modifier|*
name|name
init|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
init|=
name|ada_find_any_type
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
operator|(
name|type1
operator|==
name|NULL
operator|)
condition|?
name|type
else|:
name|type1
return|;
block|}
block|}
end_function

begin_comment
comment|/* A value representing the data at VALADDR/ADDRESS as described by    type TYPE0, but with a standard (static-sized) type that correctly    describes it.  If VAL0 is not NULL and TYPE0 already is a standard    type, then return VAL0 [this feature is simply to avoid redundant    creation of struct values]. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_to_fixed_value
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|value
modifier|*
name|val0
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|ada_to_fixed_type
argument_list|(
name|type0
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|type0
operator|&&
name|val0
operator|!=
name|NULL
condition|)
return|return
name|val0
return|;
else|else
return|return
name|value_from_contents_and_address
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A value representing VAL, but with a standard (static-sized) type     chosen to approximate the real type of VAL as well as possible, but    without consulting any runtime values.  For Ada dynamic-sized    types, therefore, the type of the result is likely to be inaccurate. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_to_static_fixed_value
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|to_static_fixed_type
argument_list|(
name|static_unwrap_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|val
return|;
else|else
return|return
name|coerce_unspec_val_to_type
argument_list|(
name|val
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attributes */
end_comment

begin_comment
comment|/* Table mapping attribute numbers to names */
end_comment

begin_comment
comment|/* NOTE: Keep up to date with enum ada_attribute definition in ada-lang.h */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|attribute_names
index|[]
init|=
block|{
literal|"<?>"
block|,
literal|"first"
block|,
literal|"last"
block|,
literal|"length"
block|,
literal|"image"
block|,
literal|"img"
block|,
literal|"max"
block|,
literal|"min"
block|,
literal|"pos"
literal|"tag"
block|,
literal|"val"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|ada_attribute_name
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
operator|(
name|int
operator|)
name|ATR_END
condition|)
return|return
name|attribute_names
index|[
name|n
index|]
return|;
else|else
return|return
name|attribute_names
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the 'POS attribute applied to ARG. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_pos_atr
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|discrete_type_p
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"'POS only defined on discrete types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
name|int
name|i
decl_stmt|;
name|LONGEST
name|v
init|=
name|value_as_long
argument_list|(
name|arg
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|v
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|value_from_longest
argument_list|(
name|builtin_type_ada_int
argument_list|,
name|i
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"enumeration value is invalid: can't find 'POS"
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|value_from_longest
argument_list|(
name|builtin_type_ada_int
argument_list|,
name|value_as_long
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the TYPE'VAL attribute applied to ARG. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_val_atr
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|discrete_type_p
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"'VAL only defined on discrete types"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_type_p
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"'VAL requires integral argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
name|long
name|pos
init|=
name|value_as_long
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"argument to 'VAL out of range"
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|pos
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|value_as_long
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluation */
end_comment

begin_comment
comment|/* True if TYPE appears to be an Ada character type.    * [At the moment, this is true only for Character and Wide_Character;  * It is a heuristic test that could stand improvement]. */
end_comment

begin_function
name|int
name|ada_is_character_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|)
operator|&&
operator|(
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
literal|"character"
argument_list|)
operator|||
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
literal|"wide_character"
argument_list|)
operator|||
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
literal|"unsigned char"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True if TYPE appears to be an Ada string type. */
end_comment

begin_function
name|int
name|ada_is_string_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
operator|(
name|ada_is_simple_array
argument_list|(
name|type
argument_list|)
operator|||
name|ada_is_array_descriptor
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|ada_array_arity
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|struct
name|type
modifier|*
name|elttype
init|=
name|ada_array_element_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|ada_is_character_type
argument_list|(
name|elttype
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* True if TYPE is a struct type introduced by the compiler to force the    alignment of a value.  Such types have a single field with a    distinctive name. */
end_comment

begin_function
name|int
name|ada_is_aligner_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"F"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If there is an ___XVS-convention type parallel to SUBTYPE, return    the parallel type. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_get_base_type
parameter_list|(
name|struct
name|type
modifier|*
name|raw_type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|real_type_namer
decl_stmt|;
name|struct
name|type
modifier|*
name|raw_real_type
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
if|if
condition|(
name|raw_type
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|raw_type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
return|return
name|raw_type
return|;
name|real_type_namer
operator|=
name|ada_find_parallel_type
argument_list|(
name|raw_type
argument_list|,
literal|"___XVS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_type_namer
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|real_type_namer
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_NFIELDS
argument_list|(
name|real_type_namer
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|raw_type
return|;
name|raw_real_type
operator|=
name|ada_find_any_type
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|real_type_namer
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_real_type
operator|==
name|NULL
condition|)
return|return
name|raw_type
return|;
else|else
return|return
name|raw_real_type
return|;
block|}
end_function

begin_comment
comment|/* The type of value designated by TYPE, with all aligners removed. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|ada_aligned_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|ada_is_aligner_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|ada_aligned_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|ada_get_base_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The address of the aligned value in an object at address VALADDR    having type TYPE.  Assumes ada_is_aligner_type (TYPE). */
end_comment

begin_function
name|char
modifier|*
name|ada_aligned_value_addr
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|)
block|{
if|if
condition|(
name|ada_is_aligner_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|ada_aligned_value_addr
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|/
name|TARGET_CHAR_BIT
argument_list|)
return|;
else|else
return|return
name|valaddr
return|;
block|}
end_function

begin_comment
comment|/* The printed representation of an enumeration literal with encoded    name NAME. The value is good to the next call of ada_enum_name. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ada_enum_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"__"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|tmp
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'Q'
condition|)
block|{
specifier|static
name|char
name|result
index|[
literal|16
index|]
decl_stmt|;
name|int
name|v
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'U'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'W'
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|name
operator|+
literal|2
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|name
return|;
block|}
else|else
return|return
name|name
return|;
if|if
condition|(
name|isascii
argument_list|(
name|v
argument_list|)
operator|&&
name|isprint
argument_list|(
name|v
argument_list|)
condition|)
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"'%c'"
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'U'
condition|)
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"[\"%02x\"]"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"[\"%04x\"]"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp
parameter_list|(
name|struct
name|type
modifier|*
name|expect_type
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|)
block|{
return|return
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the subexpression of EXP starting at *POS as for    evaluate_type, updating *POS to point just past the evaluated    expression. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp_type
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|)
block|{
return|return
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If VAL is wrapped in an aligner or subtype wrapper, return the    value it wraps. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|unwrap_value
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ada_is_aligner_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|value_struct_elt
argument_list|(
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
literal|"F"
argument_list|,
name|NULL
argument_list|,
literal|"internal structure"
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|val_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ada_type_name
argument_list|(
name|val_type
argument_list|)
operator|==
name|NULL
condition|)
name|TYPE_NAME
argument_list|(
name|val_type
argument_list|)
operator|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|unwrap_value
argument_list|(
name|v
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|raw_real_type
init|=
name|ada_completed_type
argument_list|(
name|ada_get_base_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|raw_real_type
condition|)
return|return
name|val
return|;
return|return
name|coerce_unspec_val_to_type
argument_list|(
name|val
argument_list|,
literal|0
argument_list|,
name|ada_to_fixed_type
argument_list|(
name|raw_real_type
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|cast_to_fixed
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|arg
parameter_list|)
block|{
name|LONGEST
name|val
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
elseif|else
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|ada_float_to_fixed
argument_list|(
name|type
argument_list|,
name|ada_fixed_to_float
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|DOUBLEST
name|argd
init|=
name|value_as_double
argument_list|(
name|value_cast
argument_list|(
name|builtin_type_double
argument_list|,
name|value_copy
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|val
operator|=
name|ada_float_to_fixed
argument_list|(
name|type
argument_list|,
name|argd
argument_list|)
expr_stmt|;
block|}
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|cast_from_fixed_to_double
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|)
block|{
name|DOUBLEST
name|val
init|=
name|ada_fixed_to_float
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|value_from_double
argument_list|(
name|builtin_type_double
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Coerce VAL as necessary for assignment to an lval of type TYPE, and   * return the converted value. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|coerce_for_assign
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type2
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|type2
condition|)
return|return
name|val
return|;
name|CHECK_TYPEDEF
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|val
operator|=
name|ada_value_ind
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|type2
operator|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Incompatible types in assignment"
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|ada_evaluate_subexp
parameter_list|(
name|struct
name|type
modifier|*
name|expect_type
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|enum
name|ada_attribute
name|atr
decl_stmt|;
name|int
name|tem
decl_stmt|,
name|tem2
decl_stmt|,
name|tem3
decl_stmt|;
name|int
name|pc
decl_stmt|;
name|struct
name|value
modifier|*
name|arg1
init|=
name|NULL
decl_stmt|,
modifier|*
name|arg2
init|=
name|NULL
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|struct
name|value
modifier|*
modifier|*
name|argvec
decl_stmt|;
name|pc
operator|=
operator|*
name|pos
expr_stmt|;
operator|*
name|pos
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
operator|*
name|pos
operator|-=
literal|1
expr_stmt|;
return|return
name|unwrap_value
argument_list|(
name|evaluate_subexp_standard
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|type
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|type
operator|!=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|type
argument_list|)
condition|)
name|arg1
operator|=
name|cast_to_fixed
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|cast_from_fixed_to_double
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|==
name|lval_memory
condition|)
block|{
comment|/* This is in case of the really obscure (and undocumented, 	         but apparently expected) case of (Foo) Bar.all, where Bar  	         is an integer constant and Foo is a dynamic-sized type. 	         If we don't do this, ARG1 will simply be relabeled with 	         TYPE. */
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|to_static_fixed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
name|arg1
operator|=
name|ada_to_fixed_value
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|arg1
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
return|return
name|arg1
return|;
comment|/* FIXME:  UNOP_QUAL should be defined in expression.h */
comment|/*    case UNOP_QUAL:          (*pos) += 2;          type = exp->elts[pc + 1].type;          return ada_evaluate_subexp (type, exp, pos, noside);        */
case|case
name|BINOP_ASSIGN
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg2
operator|=
name|cast_to_fixed
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Fixed-point values must be assigned to fixed-point variables"
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|coerce_for_assign
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|ada_value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|BINOP_ADD
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
else|else
block|{
if|if
condition|(
operator|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
operator|&&
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Operands of fixed-point addition must have the same type"
argument_list|)
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|value_add
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_SUB
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
else|else
block|{
if|if
condition|(
operator|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
operator|&&
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Operands of fixed-point subtraction must have the same type"
argument_list|)
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
operator|&&
operator|(
name|op
operator|==
name|BINOP_DIV
operator|||
name|op
operator|==
name|BINOP_REM
operator|||
name|op
operator|==
name|BINOP_MOD
operator|)
condition|)
return|return
name|value_zero
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|cast_from_fixed_to_double
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|)
name|arg2
operator|=
name|cast_from_fixed_to_double
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
return|;
block|}
case|case
name|UNOP_NEG
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
name|value_cast
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|value_neg
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|value_neg
argument_list|(
name|arg1
argument_list|)
return|;
comment|/* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
comment|/*    case OP_UNRESOLVED_VALUE:          /* Only encountered when an unresolved symbol occurs in a          context other than a function call, in which case, it is    illegal. */
comment|/*    (*pos) += 3;    if (noside == EVAL_SKIP)    goto nosideret;    else     error ("Unexpected unresolved symbol, %s, during evaluation",    ada_demangle (exp->elts[pc + 2].name));  */
case|case
name|OP_VAR_VALUE
case|:
operator|*
name|pos
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
operator|*
name|pos
operator|+=
literal|4
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
operator|*
name|pos
operator|+=
literal|4
expr_stmt|;
return|return
name|value_zero
argument_list|(
name|to_static_fixed_type
argument_list|(
name|static_unwrap_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
block|}
else|else
block|{
name|arg1
operator|=
name|unwrap_value
argument_list|(
name|evaluate_subexp_standard
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ada_to_fixed_value
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
block|}
case|case
name|OP_ARRAY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|tem2
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|tem3
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|tem3
operator|-
name|tem2
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|expect_type
condition|?
name|check_typedef
argument_list|(
name|expect_type
argument_list|)
else|:
name|NULL_TYPE
expr_stmt|;
name|argvec
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|==
literal|0
operator|||
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|+=
literal|1
control|)
comment|/* At least one element gets inserted for the type */
block|{
comment|/* Ensure that array expressions are coerced into pointer objects. */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_array
argument_list|(
name|tem2
argument_list|,
name|tem3
argument_list|,
name|argvec
argument_list|)
return|;
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
comment|/* Allocate arg vector, including space for the function to be          called in argvec[0] and a terminating NULL */
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|argvec
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* FIXME: OP_UNRESOLVED_VALUE should be defined in expression.h */
comment|/* FIXME: name should be defined in expresion.h */
comment|/*      if (exp->elts[*pos].opcode == OP_UNRESOLVED_VALUE)          error ("Unexpected unresolved symbol, %s, during evaluation",          ada_demangle (exp->elts[pc + 5].name));        */
if|if
condition|(
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"unexpected code path, FIXME"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<=
name|nargs
condition|;
name|tem
operator|+=
literal|1
control|)
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|argvec
index|[
name|tem
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
name|argvec
index|[
literal|0
index|]
operator|=
name|value_addr
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|argvec
index|[
literal|0
index|]
operator|=
name|ada_coerce_to_simple_array
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FUNC
case|:
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|noside
operator|!=
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
name|argvec
index|[
literal|0
index|]
operator|=
name|ada_value_ind
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"cannot subscript or call something of type `%s'"
argument_list|,
name|ada_type_name
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|allocate_value
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
block|{
name|int
name|arity
init|=
name|ada_array_arity
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|ada_array_element_type
argument_list|(
name|type
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"cannot subscript or call a record"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arity
operator|!=
name|nargs
condition|)
name|error
argument_list|(
literal|"wrong number of subscripts; expecting %d"
argument_list|,
name|arity
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|allocate_value
argument_list|(
name|ada_aligned_type
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|unwrap_value
argument_list|(
name|ada_value_subscript
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|type
operator|=
name|ada_array_element_type
argument_list|(
name|type
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"element type of array unknown"
argument_list|)
expr_stmt|;
else|else
return|return
name|allocate_value
argument_list|(
name|ada_aligned_type
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
return|return
name|unwrap_value
argument_list|(
name|ada_value_subscript
argument_list|(
name|ada_coerce_to_simple_array
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TYPE_CODE_PTR
case|:
comment|/* Pointer to array */
name|type
operator|=
name|to_fixed_array_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|type
operator|=
name|ada_array_element_type
argument_list|(
name|type
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"element type of array unknown"
argument_list|)
expr_stmt|;
else|else
return|return
name|allocate_value
argument_list|(
name|ada_aligned_type
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
return|return
name|unwrap_value
argument_list|(
name|ada_value_ptr_subscript
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"Internal error in evaluate_subexp"
argument_list|)
expr_stmt|;
block|}
case|case
name|TERNOP_SLICE
case|:
block|{
name|struct
name|value
modifier|*
name|array
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
name|int
name|lowbound
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|upper
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
comment|/* If this is a reference to an array, then dereference it */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
operator|!
name|ada_is_array_descriptor
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|array
operator|=
name|ada_coerce_ref
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
operator|&&
name|ada_is_array_descriptor
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Try to dereference the array, in case it is an access to array */
name|struct
name|type
modifier|*
name|arrType
init|=
name|ada_type_of_array
argument_list|(
name|array
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|arrType
operator|!=
name|NULL
condition|)
name|array
operator|=
name|value_at_lazy
argument_list|(
name|arrType
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
condition|)
name|array
operator|=
name|ada_coerce_to_simple_array
argument_list|(
name|array
argument_list|)
expr_stmt|;
comment|/* If at this point we have a pointer to an array, it means that 	   it is a pointer to a simple (non-ada) array. We just then 	   dereference it */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|array
operator|=
name|ada_value_ind
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
comment|/* The following will get the bounds wrong, but only in contexts 	     where the value is not being requested (FIXME?). */
return|return
name|array
return|;
else|else
return|return
name|value_slice
argument_list|(
name|array
argument_list|,
name|lowbound
argument_list|,
name|upper
operator|-
name|lowbound
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/* FIXME: UNOP_MBR should be defined in expression.h */
comment|/*    case UNOP_MBR:          (*pos) += 2;          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          type = exp->elts[pc + 1].type;           if (noside == EVAL_SKIP)          goto nosideret;           switch (TYPE_CODE (type))           {          default:          warning ("Membership test incompletely implemented; always returns true");          return value_from_longest (builtin_type_int, (LONGEST) 1);           case TYPE_CODE_RANGE:          arg2 = value_from_longest (builtin_type_int,           (LONGEST) TYPE_LOW_BOUND (type));          arg3 = value_from_longest (builtin_type_int,           (LONGEST) TYPE_HIGH_BOUND (type));          return           value_from_longest (builtin_type_int,          (value_less (arg1,arg3)           || value_equal (arg1,arg3))&& (value_less (arg2,arg1)          || value_equal (arg2,arg1)));          }        */
comment|/* FIXME: BINOP_MBR should be defined in expression.h */
comment|/*    case BINOP_MBR:          (*pos) += 2;          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);           if (noside == EVAL_SKIP)          goto nosideret;           if (noside == EVAL_AVOID_SIDE_EFFECTS)          return value_zero (builtin_type_int, not_lval);           tem = longest_to_int (exp->elts[pc + 1].longconst);           if (tem< 1 || tem> ada_array_arity (VALUE_TYPE (arg2)))          error ("invalid dimension number to '%s", "range");           arg3 = ada_array_bound (arg2, tem, 1);          arg2 = ada_array_bound (arg2, tem, 0);           return           value_from_longest (builtin_type_int,          (value_less (arg1,arg3)           || value_equal (arg1,arg3))&& (value_less (arg2,arg1)          || value_equal (arg2,arg1)));        */
comment|/* FIXME: TERNOP_MBR should be defined in expression.h */
comment|/*    case TERNOP_MBR:          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);           if (noside == EVAL_SKIP)          goto nosideret;           return           value_from_longest (builtin_type_int,          (value_less (arg1,arg3)           || value_equal (arg1,arg3))&& (value_less (arg2,arg1)          || value_equal (arg2,arg1)));        */
comment|/* FIXME: OP_ATTRIBUTE should be defined in expression.h */
comment|/*    case OP_ATTRIBUTE:          *pos += 3;          atr = (enum ada_attribute) longest_to_int (exp->elts[pc + 2].longconst);          switch (atr)           {          default:          error ("unexpected attribute encountered");           case ATR_FIRST:          case ATR_LAST:          case ATR_LENGTH:          {          struct type* type_arg;          if (exp->elts[*pos].opcode == OP_TYPE)          {          evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);          arg1 = NULL;          type_arg = exp->elts[pc + 5].type;          }          else          {          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          type_arg = NULL;          }           if (exp->elts[*pos].opcode != OP_LONG)           error ("illegal operand to '%s", ada_attribute_name (atr));          tem = longest_to_int (exp->elts[*pos+2].longconst);          *pos += 4;           if (noside == EVAL_SKIP)          goto nosideret;           if (type_arg == NULL)          {          arg1 = ada_coerce_ref (arg1);           if (ada_is_packed_array_type (VALUE_TYPE (arg1)))          arg1 = ada_coerce_to_simple_array (arg1);           if (tem< 1 || tem> ada_array_arity (VALUE_TYPE (arg1)))          error ("invalid dimension number to '%s",           ada_attribute_name (atr));           if (noside == EVAL_AVOID_SIDE_EFFECTS)          {          type = ada_index_type (VALUE_TYPE (arg1), tem);          if (type == NULL)           error ("attempt to take bound of something that is not an array");          return allocate_value (type);          }           switch (atr)           {          default:           error ("unexpected attribute encountered");          case ATR_FIRST:          return ada_array_bound (arg1, tem, 0);          case ATR_LAST:          return ada_array_bound (arg1, tem, 1);          case ATR_LENGTH:          return ada_array_length (arg1, tem);          }          }          else if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE          || TYPE_CODE (type_arg) == TYPE_CODE_INT)           {          struct type* range_type;          char* name = ada_type_name (type_arg);          if (name == NULL)          {          if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE)           range_type = type_arg;          else          error ("unimplemented type attribute");          }          else           range_type =           to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));          switch (atr)           {          default:           error ("unexpected attribute encountered");          case ATR_FIRST:          return value_from_longest (TYPE_TARGET_TYPE (range_type),          TYPE_LOW_BOUND (range_type));          case ATR_LAST:          return value_from_longest (TYPE_TARGET_TYPE (range_type),          TYPE_HIGH_BOUND (range_type));          }          }                        else if (TYPE_CODE (type_arg) == TYPE_CODE_ENUM)          {          switch (atr)           {          default:           error ("unexpected attribute encountered");          case ATR_FIRST:          return value_from_longest           (type_arg, TYPE_FIELD_BITPOS (type_arg, 0));          case ATR_LAST:          return value_from_longest           (type_arg,           TYPE_FIELD_BITPOS (type_arg,          TYPE_NFIELDS (type_arg) - 1));          }          }          else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)          error ("unimplemented type attribute");          else           {          LONGEST low, high;           if (ada_is_packed_array_type (type_arg))          type_arg = decode_packed_array_type (type_arg);           if (tem< 1 || tem> ada_array_arity (type_arg))          error ("invalid dimension number to '%s",           ada_attribute_name (atr));           if (noside == EVAL_AVOID_SIDE_EFFECTS)          {          type = ada_index_type (type_arg, tem);          if (type == NULL)           error ("attempt to take bound of something that is not an array");          return allocate_value (type);          }           switch (atr)           {          default:           error ("unexpected attribute encountered");          case ATR_FIRST:          low = ada_array_bound_from_type (type_arg, tem, 0,&type);          return value_from_longest (type, low);          case ATR_LAST:          high = ada_array_bound_from_type (type_arg, tem, 1,&type);          return value_from_longest (type, high);          case ATR_LENGTH:          low = ada_array_bound_from_type (type_arg, tem, 0,&type);          high = ada_array_bound_from_type (type_arg, tem, 1, NULL);          return value_from_longest (type, high-low+1);          }          }          }           case ATR_TAG:          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          if (noside == EVAL_SKIP)          goto nosideret;           if (noside == EVAL_AVOID_SIDE_EFFECTS)          return                   value_zero (ada_tag_type (arg1), not_lval);           return ada_value_tag (arg1);           case ATR_MIN:          case ATR_MAX:          evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          if (noside == EVAL_SKIP)          goto nosideret;          else if (noside == EVAL_AVOID_SIDE_EFFECTS)          return value_zero (VALUE_TYPE (arg1), not_lval);          else          return value_binop (arg1, arg2,           atr == ATR_MIN ? BINOP_MIN : BINOP_MAX);           case ATR_MODULUS:          {          struct type* type_arg = exp->elts[pc + 5].type;          evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);          *pos += 4;           if (noside == EVAL_SKIP)          goto nosideret;           if (! ada_is_modular_type (type_arg))          error ("'modulus must be applied to modular type");           return value_from_longest (TYPE_TARGET_TYPE (type_arg),          ada_modulus (type_arg));          }            case ATR_POS:          evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          if (noside == EVAL_SKIP)          goto nosideret;          else if (noside == EVAL_AVOID_SIDE_EFFECTS)          return value_zero (builtin_type_ada_int, not_lval);          else           return value_pos_atr (arg1);           case ATR_SIZE:          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          if (noside == EVAL_SKIP)          goto nosideret;          else if (noside == EVAL_AVOID_SIDE_EFFECTS)          return value_zero (builtin_type_ada_int, not_lval);          else          return value_from_longest (builtin_type_ada_int,          TARGET_CHAR_BIT           * TYPE_LENGTH (VALUE_TYPE (arg1)));           case ATR_VAL:          evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);          arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);          type = exp->elts[pc + 5].type;          if (noside == EVAL_SKIP)          goto nosideret;          else if (noside == EVAL_AVOID_SIDE_EFFECTS)          return value_zero (type, not_lval);          else           return value_val_atr (type, arg1);          } */
case|case
name|BINOP_EXP
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|unwrap_value
argument_list|(
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|EVAL_NORMAL
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
return|;
case|case
name|UNOP_PLUS
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|unwrap_value
argument_list|(
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|EVAL_NORMAL
argument_list|)
argument_list|)
return|;
else|else
return|return
name|arg1
return|;
case|case
name|UNOP_ABS
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|value_less
argument_list|(
name|arg1
argument_list|,
name|value_zero
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|not_lval
argument_list|)
argument_list|)
condition|)
return|return
name|value_neg
argument_list|(
name|arg1
argument_list|)
return|;
else|else
return|return
name|arg1
return|;
case|case
name|UNOP_IND
case|:
if|if
condition|(
name|expect_type
operator|&&
name|TYPE_CODE
argument_list|(
name|expect_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|expect_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|expect_type
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|type
argument_list|)
condition|)
comment|/* GDB allows dereferencing GNAT array descriptors. */
block|{
name|struct
name|type
modifier|*
name|arrType
init|=
name|ada_type_of_array
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|arrType
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Attempt to dereference null array pointer."
argument_list|)
expr_stmt|;
return|return
name|value_at_lazy
argument_list|(
name|arrType
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
comment|/* In C you can dereference an array to get the 1st elt.  */
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|value_zero
argument_list|(
name|to_static_fixed_type
argument_list|(
name|ada_aligned_type
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
comment|/* GDB allows dereferencing an int.  */
return|return
name|value_zero
argument_list|(
name|builtin_type_int
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
block|}
name|arg1
operator|=
name|ada_coerce_ref
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|type
argument_list|)
condition|)
comment|/* GDB allows dereferencing GNAT array descriptors. */
return|return
name|ada_coerce_to_simple_array
argument_list|(
name|arg1
argument_list|)
return|;
else|else
return|return
name|ada_value_ind
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|ada_aligned_type
argument_list|(
name|ada_lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
return|return
name|unwrap_value
argument_list|(
name|ada_value_struct_elt
argument_list|(
name|arg1
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|"record"
argument_list|)
argument_list|)
return|;
case|case
name|OP_TYPE
case|:
comment|/* The value is not supposed to be used. This is here to make it          easier to accommodate expressions that contain types. */
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|allocate_value
argument_list|(
name|builtin_type_void
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to use a type name as an expression"
argument_list|)
expr_stmt|;
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|ada_aligned_type
argument_list|(
name|ada_lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
return|return
name|unwrap_value
argument_list|(
name|ada_value_struct_elt
argument_list|(
name|arg1
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|"record access"
argument_list|)
argument_list|)
return|;
block|}
name|nosideret
label|:
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fixed point */
end_comment

begin_comment
comment|/* If TYPE encodes an Ada fixed-point type, return the suffix of the    type name that encodes the 'small and 'delta information.    Otherwise, return NULL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fixed_type_info
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|code
init|=
operator|(
name|type
operator|==
name|NULL
operator|)
condition|?
name|TYPE_CODE_UNDEF
else|:
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|TYPE_CODE_INT
operator|||
name|code
operator|==
name|TYPE_CODE_RANGE
operator|)
operator|&&
name|name
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|tail
init|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"___XF_"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|tail
operator|+
literal|5
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_RANGE
operator|&&
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|type
condition|)
return|return
name|fixed_type_info
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff TYPE represents an Ada fixed-point type. */
end_comment

begin_function
name|int
name|ada_is_fixed_point_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|fixed_type_info
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assuming that TYPE is the representation of an Ada fixed-point    type, return its delta, or -1 if the type is malformed and the    delta cannot be determined. */
end_comment

begin_function
name|DOUBLEST
name|ada_delta
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encoding
init|=
name|fixed_type_info
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|long
name|num
decl_stmt|,
name|den
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|encoding
argument_list|,
literal|"_%ld_%ld"
argument_list|,
operator|&
name|num
argument_list|,
operator|&
name|den
argument_list|)
operator|<
literal|2
condition|)
return|return
operator|-
literal|1.0
return|;
else|else
return|return
operator|(
name|DOUBLEST
operator|)
name|num
operator|/
operator|(
name|DOUBLEST
operator|)
name|den
return|;
block|}
end_function

begin_comment
comment|/* Assuming that ada_is_fixed_point_type (TYPE), return the scaling    factor ('SMALL value) associated with the type. */
end_comment

begin_function
specifier|static
name|DOUBLEST
name|scaling_factor
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encoding
init|=
name|fixed_type_info
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|num0
decl_stmt|,
name|den0
decl_stmt|,
name|num1
decl_stmt|,
name|den1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|encoding
argument_list|,
literal|"_%lu_%lu_%lu_%lu"
argument_list|,
operator|&
name|num0
argument_list|,
operator|&
name|den0
argument_list|,
operator|&
name|num1
argument_list|,
operator|&
name|den1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|2
condition|)
return|return
literal|1.0
return|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|4
condition|)
return|return
operator|(
name|DOUBLEST
operator|)
name|num1
operator|/
operator|(
name|DOUBLEST
operator|)
name|den1
return|;
else|else
return|return
operator|(
name|DOUBLEST
operator|)
name|num0
operator|/
operator|(
name|DOUBLEST
operator|)
name|den0
return|;
block|}
end_function

begin_comment
comment|/* Assuming that X is the representation of a value of fixed-point    type TYPE, return its floating-point equivalent. */
end_comment

begin_function
name|DOUBLEST
name|ada_fixed_to_float
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|LONGEST
name|x
parameter_list|)
block|{
return|return
operator|(
name|DOUBLEST
operator|)
name|x
operator|*
name|scaling_factor
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The representation of a fixed-point value of type TYPE     corresponding to the value X. */
end_comment

begin_function
name|LONGEST
name|ada_float_to_fixed
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|DOUBLEST
name|x
parameter_list|)
block|{
return|return
call|(
name|LONGEST
call|)
argument_list|(
name|x
operator|/
name|scaling_factor
argument_list|(
name|type
argument_list|)
operator|+
literal|0.5
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* VAX floating formats */
end_comment

begin_comment
comment|/* Non-zero iff TYPE represents one of the special VAX floating-point    types. */
end_comment

begin_function
name|int
name|ada_is_vax_floating_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|name_len
init|=
operator|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|name_len
operator|>
literal|6
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|)
operator|&&
name|DEPRECATED_STREQN
argument_list|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
operator|+
name|name_len
operator|-
literal|6
argument_list|,
literal|"___XF"
argument_list|,
literal|5
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The type of special VAX floating-point type this is, assuming    ada_is_vax_floating_point */
end_comment

begin_function
name|int
name|ada_vax_float_type_suffix
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|ada_type_name
argument_list|(
name|type
argument_list|)
index|[
name|strlen
argument_list|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
argument_list|)
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* A value representing the special debugging function that outputs     VAX floating-point values of the type represented by TYPE.  Assumes    ada_is_vax_floating_type (TYPE). */
end_comment

begin_function
name|struct
name|value
modifier|*
name|ada_vax_float_print_function
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|ada_vax_float_type_suffix
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|'F'
case|:
return|return
name|get_var_value
argument_list|(
literal|"DEBUG_STRING_F"
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'D'
case|:
return|return
name|get_var_value
argument_list|(
literal|"DEBUG_STRING_D"
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'G'
case|:
return|return
name|get_var_value
argument_list|(
literal|"DEBUG_STRING_G"
argument_list|,
literal|0
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"invalid VAX floating-point type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Range types */
end_comment

begin_comment
comment|/* Scan STR beginning at position K for a discriminant name, and    return the value of that discriminant field of DVAL in *PX.  If    PNEW_K is not null, put the position of the character beyond the    name scanned in *PNEW_K.  Return 1 if successful; return 0 and do    not alter *PX and *PNEW_K if unsuccessful. */
end_comment

begin_function
specifier|static
name|int
name|scan_discrim_bound
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|k
parameter_list|,
name|struct
name|value
modifier|*
name|dval
parameter_list|,
name|LONGEST
modifier|*
name|px
parameter_list|,
name|int
modifier|*
name|pnew_k
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|bound_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|bound_buffer_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bound
decl_stmt|;
name|char
modifier|*
name|pend
decl_stmt|;
name|struct
name|value
modifier|*
name|bound_val
decl_stmt|;
if|if
condition|(
name|dval
operator|==
name|NULL
operator|||
name|str
operator|==
name|NULL
operator|||
name|str
index|[
name|k
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|pend
operator|=
name|strstr
argument_list|(
name|str
operator|+
name|k
argument_list|,
literal|"__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|==
name|NULL
condition|)
block|{
name|bound
operator|=
name|str
operator|+
name|k
expr_stmt|;
name|k
operator|+=
name|strlen
argument_list|(
name|bound
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GROW_VECT
argument_list|(
name|bound_buffer
argument_list|,
name|bound_buffer_len
argument_list|,
name|pend
operator|-
operator|(
name|str
operator|+
name|k
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bound
operator|=
name|bound_buffer
expr_stmt|;
name|strncpy
argument_list|(
name|bound_buffer
argument_list|,
name|str
operator|+
name|k
argument_list|,
name|pend
operator|-
operator|(
name|str
operator|+
name|k
operator|)
argument_list|)
expr_stmt|;
name|bound
index|[
name|pend
operator|-
operator|(
name|str
operator|+
name|k
operator|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|k
operator|=
name|pend
operator|-
name|str
expr_stmt|;
block|}
name|bound_val
operator|=
name|ada_search_struct_field
argument_list|(
name|bound
argument_list|,
name|dval
argument_list|,
literal|0
argument_list|,
name|VALUE_TYPE
argument_list|(
name|dval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bound_val
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
operator|*
name|px
operator|=
name|value_as_long
argument_list|(
name|bound_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnew_k
operator|!=
name|NULL
condition|)
operator|*
name|pnew_k
operator|=
name|k
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Value of variable named NAME in the current environment.  If    no such variable found, then if ERR_MSG is null, returns 0, and    otherwise causes an error with message ERR_MSG. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|get_var_value
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|err_msg
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|blocks
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|nsyms
operator|=
name|ada_lookup_symbol_list
argument_list|(
name|name
argument_list|,
name|get_selected_block
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|&
name|syms
argument_list|,
operator|&
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsyms
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|err_msg
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
name|error
argument_list|(
literal|"%s"
argument_list|,
name|err_msg
argument_list|)
expr_stmt|;
block|}
return|return
name|value_of_variable
argument_list|(
name|syms
index|[
literal|0
index|]
argument_list|,
name|blocks
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Value of integer variable named NAME in the current environment.  If    no such variable found, then if ERR_MSG is null, returns 0, and sets    *FLAG to 0.  If successful, sets *FLAG to 1. */
end_comment

begin_function
name|LONGEST
name|get_int_var_value
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|err_msg
parameter_list|,
name|int
modifier|*
name|flag
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|var_val
init|=
name|get_var_value
argument_list|(
name|name
argument_list|,
name|err_msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|var_val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|!=
name|NULL
condition|)
operator|*
name|flag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|flag
operator|!=
name|NULL
condition|)
operator|*
name|flag
operator|=
literal|1
expr_stmt|;
return|return
name|value_as_long
argument_list|(
name|var_val
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a range type whose base type is that of the range type named    NAME in the current environment, and whose bounds are calculated    from NAME according to the GNAT range encoding conventions.     Extract discriminant values, if needed, from DVAL.  If a new type    must be created, allocate in OBJFILE's space.  The bounds    information, in general, is encoded in NAME, the base type given in    the named range type. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|to_fixed_range_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|value
modifier|*
name|dval
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|raw_type
init|=
name|ada_find_any_type
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
name|LONGEST
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|subtype_info
decl_stmt|;
if|if
condition|(
name|raw_type
operator|==
name|NULL
condition|)
name|base_type
operator|=
name|builtin_type_int
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|raw_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
name|base_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|raw_type
argument_list|)
expr_stmt|;
else|else
name|base_type
operator|=
name|raw_type
expr_stmt|;
name|subtype_info
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"___XD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype_info
operator|==
name|NULL
condition|)
return|return
name|raw_type
return|;
else|else
block|{
specifier|static
name|char
modifier|*
name|name_buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|name_len
init|=
literal|0
decl_stmt|;
name|int
name|prefix_len
init|=
name|subtype_info
operator|-
name|name
decl_stmt|;
name|LONGEST
name|L
decl_stmt|,
name|U
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|bounds_str
decl_stmt|;
name|int
name|n
decl_stmt|;
name|GROW_VECT
argument_list|(
name|name_buf
argument_list|,
name|name_len
argument_list|,
name|prefix_len
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name_buf
argument_list|,
name|name
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|name_buf
index|[
name|prefix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|subtype_info
operator|+=
literal|5
expr_stmt|;
name|bounds_str
operator|=
name|strchr
argument_list|(
name|subtype_info
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|subtype_info
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
operator|!
name|ada_scan_number
argument_list|(
name|bounds_str
argument_list|,
name|n
argument_list|,
operator|&
name|L
argument_list|,
operator|&
name|n
argument_list|)
operator|&&
operator|!
name|scan_discrim_bound
argument_list|(
name|bounds_str
argument_list|,
name|n
argument_list|,
name|dval
argument_list|,
operator|&
name|L
argument_list|,
operator|&
name|n
argument_list|)
condition|)
return|return
name|raw_type
return|;
if|if
condition|(
name|bounds_str
index|[
name|n
index|]
operator|==
literal|'_'
condition|)
name|n
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|bounds_str
index|[
name|n
index|]
operator|==
literal|'.'
condition|)
comment|/* FIXME? SGI Workshop kludge. */
name|n
operator|+=
literal|1
expr_stmt|;
name|subtype_info
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|name_buf
operator|+
name|prefix_len
argument_list|,
literal|"___L"
argument_list|)
expr_stmt|;
name|L
operator|=
name|get_int_var_value
argument_list|(
name|name_buf
argument_list|,
literal|"Index bound unknown."
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|subtype_info
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
operator|!
name|ada_scan_number
argument_list|(
name|bounds_str
argument_list|,
name|n
argument_list|,
operator|&
name|U
argument_list|,
operator|&
name|n
argument_list|)
operator|&&
operator|!
name|scan_discrim_bound
argument_list|(
name|bounds_str
argument_list|,
name|n
argument_list|,
name|dval
argument_list|,
operator|&
name|U
argument_list|,
operator|&
name|n
argument_list|)
condition|)
return|return
name|raw_type
return|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|name_buf
operator|+
name|prefix_len
argument_list|,
literal|"___U"
argument_list|)
expr_stmt|;
name|U
operator|=
name|get_int_var_value
argument_list|(
name|name_buf
argument_list|,
literal|"Index bound unknown."
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|==
name|NULL
condition|)
name|objfile
operator|=
name|TYPE_OBJFILE
argument_list|(
name|base_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_range_type
argument_list|(
name|alloc_type
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|base_type
argument_list|,
name|L
argument_list|,
name|U
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
end_function

begin_comment
comment|/* True iff NAME is the name of a range type. */
end_comment

begin_function
name|int
name|ada_is_range_type_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|name
operator|!=
name|NULL
operator|&&
name|strstr
argument_list|(
name|name
argument_list|,
literal|"___XD"
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Modular types */
end_comment

begin_comment
comment|/* True iff TYPE is an Ada modular type. */
end_comment

begin_function
name|int
name|ada_is_modular_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
comment|/* FIXME: base_type should be declared in gdbtypes.h, implemented in      valarith.c */
name|struct
name|type
modifier|*
name|subranged_type
decl_stmt|;
comment|/* = base_type (type); */
return|return
operator|(
name|subranged_type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|&&
name|TYPE_CODE
argument_list|(
name|subranged_type
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|subranged_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming ada_is_modular_type (TYPE), the modulus of TYPE. */
end_comment

begin_function
name|LONGEST
name|ada_modulus
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|TYPE_HIGH_BOUND
argument_list|(
name|type
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operators */
end_comment

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|ada_op_print_tab
index|[]
init|=
block|{
block|{
literal|":="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"or else"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"and then"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"or"
block|,
name|BINOP_BITWISE_IOR
block|,
name|PREC_BITWISE_IOR
block|,
literal|0
block|}
block|,
block|{
literal|"xor"
block|,
name|BINOP_BITWISE_XOR
block|,
name|PREC_BITWISE_XOR
block|,
literal|0
block|}
block|,
block|{
literal|"and"
block|,
name|BINOP_BITWISE_AND
block|,
name|PREC_BITWISE_AND
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"/="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">>"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"<<"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|BINOP_CONCAT
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"rem"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"mod"
block|,
name|BINOP_MOD
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"**"
block|,
name|BINOP_EXP
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|UNOP_PLUS
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"not "
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"not "
block|,
name|UNOP_COMPLEMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"abs "
block|,
name|UNOP_ABS
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|".all"
block|,
name|UNOP_IND
block|,
name|PREC_SUFFIX
block|,
literal|1
block|}
block|,
comment|/* FIXME: postfix .ALL */
block|{
literal|"'access"
block|,
name|UNOP_ADDR
block|,
name|PREC_SUFFIX
block|,
literal|1
block|}
block|,
comment|/* FIXME: postfix 'ACCESS */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Assorted Types and Interfaces */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_short
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_long_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_float
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_long_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_natural
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_positive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ada_system_address
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|ada_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_ada_int
block|,
operator|&
name|builtin_type_ada_long
block|,
operator|&
name|builtin_type_ada_short
block|,
operator|&
name|builtin_type_ada_char
block|,
operator|&
name|builtin_type_ada_float
block|,
operator|&
name|builtin_type_ada_double
block|,
operator|&
name|builtin_type_ada_long_long
block|,
operator|&
name|builtin_type_ada_long_double
block|,
operator|&
name|builtin_type_ada_natural
block|,
operator|&
name|builtin_type_ada_positive
block|,
comment|/* The following types are carried over from C for convenience. */
operator|&
name|builtin_type_int
block|,
operator|&
name|builtin_type_long
block|,
operator|&
name|builtin_type_short
block|,
operator|&
name|builtin_type_char
block|,
operator|&
name|builtin_type_float
block|,
operator|&
name|builtin_type_double
block|,
operator|&
name|builtin_type_long_long
block|,
operator|&
name|builtin_type_void
block|,
operator|&
name|builtin_type_signed_char
block|,
operator|&
name|builtin_type_unsigned_char
block|,
operator|&
name|builtin_type_unsigned_short
block|,
operator|&
name|builtin_type_unsigned_int
block|,
operator|&
name|builtin_type_unsigned_long
block|,
operator|&
name|builtin_type_unsigned_long_long
block|,
operator|&
name|builtin_type_long_double
block|,
operator|&
name|builtin_type_complex
block|,
operator|&
name|builtin_type_double_complex
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Not really used, but needed in the ada_language_defn. */
end_comment

begin_function
specifier|static
name|void
name|emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
name|ada_emit_char
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
name|quoter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|ada_language_defn
init|=
block|{
literal|"ada"
block|,
comment|/* Language name */
comment|/*  language_ada, */
name|language_unknown
block|,
comment|/* FIXME: language_ada should be defined in defs.h */
name|ada_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
comment|/* Yes, Ada is case-insensitive, but 				 * that's not quite what this means. */
name|ada_parse
block|,
name|ada_error
block|,
name|ada_evaluate_subexp
block|,
name|ada_printchar
block|,
comment|/* Print a character constant */
name|ada_printstr
block|,
comment|/* Function to print string constant */
name|emit_char
block|,
comment|/* Function to print single char (not used) */
name|ada_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|ada_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|ada_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|ada_value_print
block|,
comment|/* Print a top-level value */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal  */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|NULL
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
if|#
directive|if
literal|0
block|{"8#%lo#", "8#", "o", "#"},
comment|/* Octal format info */
block|{"%ld", "", "d", ""},
comment|/* Decimal format info */
block|{"16#%lx#", "16#", "x", "#"},
comment|/* Hex format info */
else|#
directive|else
comment|/* Copied from c-lang.c. */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
endif|#
directive|endif
name|ada_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays (FIXME?) */
literal|0
block|,
comment|/* String lower bound (FIXME?) */
operator|&
name|builtin_type_ada_char
block|,
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_ada_language
parameter_list|(
name|void
parameter_list|)
block|{
name|builtin_type_ada_int
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_integer"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_short
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short_integer"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_float
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_double
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_float"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_long_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_long_integer"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_long_double
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_long_float"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_natural
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"natural"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_positive
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"positive"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_ada_system_address
operator|=
name|lookup_pointer_type
argument_list|(
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|builtin_type_ada_system_address
argument_list|)
operator|=
literal|"system__address"
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|ada_language_defn
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"varsize-limit"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|varsize_limit
argument_list|,
literal|"Set maximum bytes in dynamic-sized object."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|varsize_limit
operator|=
literal|65536
expr_stmt|;
name|add_com
argument_list|(
literal|"begin"
argument_list|,
name|class_breakpoint
argument_list|,
name|begin_command
argument_list|,
literal|"Start the debugged program, stopping at the beginning of the\n\ main program.  You may specify command-line arguments to give it, as for\n\ the \"run\" command (q.v.)."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a fundamental Ada type using default reasonable for the current    target machine.     Some object/debugging file formats (DWARF version 1, COFF, etc) do not    define fundamental types such as "int" or "double".  Others (stabs or    DWARF version 2, etc) do define fundamental types.  For the formats which    don't provide fundamental types, gdb can create such types using this    function.     FIXME:  Some compilers distinguish explicitly signed integral types    (signed short, signed int, signed long) from "regular" integral types    (short, int, long) in the debugging information.  There is some dis-    agreement as to how useful this feature is.  In particular, gcc does    not support this.  Also, only some debugging formats allow the    distinction to be passed on to a debugger.  For now, we always just    use "short", "int", or "long" as the type name, for both the implicit    and explicitly signed types.  This also makes life easier for the    gdb test suite since we don't have to account for the differences    in output depending upon what the compiler and debugging format    support.  We will probably have to re-examine the issue when gdb    starts taking it's fundamental type information directly from the    debugging information supplied by the compiler.  fnf@cygnus.com */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|ada_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this          language, create the equivalent of a C integer type with the          name "<?type?>".  When all the dust settles from the type          reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no Ada fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short_integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short_integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_long_integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_long_integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long_long_float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ada_dump_symtab
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"New symtab: [\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Name: %s/%s;\n"
argument_list|,
name|s
operator|->
name|dirname
condition|?
name|s
operator|->
name|dirname
else|:
literal|"?"
argument_list|,
name|s
operator|->
name|filename
condition|?
name|s
operator|->
name|filename
else|:
literal|"?"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Format: %s;\n"
argument_list|,
name|s
operator|->
name|debugformat
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|linetable
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Line table (section %d):\n"
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|linetable
operator|->
name|nitems
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|struct
name|linetable_entry
modifier|*
name|e
init|=
name|s
operator|->
name|linetable
operator|->
name|item
operator|+
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    %4ld: %8lx\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|line
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

