begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* General utility routines for GDB, the GNU debugger.     Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUI
end_ifdef

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_comment
comment|/* For tui_get_command_dimension.   */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GO32__
end_ifdef

begin_include
include|#
directive|include
file|<pc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SunOS's curses.h has a '#define reg register' in it.  Thank you Sun. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|reg
end_ifdef

begin_undef
undef|#
directive|undef
name|reg
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"charset.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for signed_pointer_to_address */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* For MAXPATHLEN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CURSES_H
end_ifdef

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERM_H
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_MALLOC
end_ifdef

begin_function_decl
specifier|extern
name|PTR
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* OK: PTR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_REALLOC
end_ifdef

begin_function_decl
specifier|extern
name|PTR
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* OK: PTR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_FREE
end_ifdef

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Actually, we'll never have the decl, since we don't define _GNU_SOURCE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CANONICALIZE_FILE_NAME
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|NEED_DECLARATION_CANONICALIZE_FILE_NAME
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|canonicalize_file_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_function_decl
name|void
function_decl|(
modifier|*
name|error_begin_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Holds the last error message issued by gdb */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ui_file
modifier|*
name|gdb_lasterr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|vfprintf_maybe_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fputs_maybe_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prompt_for_continue
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_screen_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_width
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Chain of cleanup actions established with make_cleanup,    to be executed if an error happens.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cleaned up after a failed command */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|final_cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cleaned up when gdb exits */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|run_cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cleaned up on each 'run' */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|exec_cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cleaned up on each execution command */
end_comment

begin_comment
comment|/* cleaned up on each error from within an execution command */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|exec_error_cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to what is left to do for an execution command after the    target stops. Used only in asynchronous mode, by targets that    support async execution.  The finish and until commands use it. So    does the target extended-remote command. */
end_comment

begin_decl_stmt
name|struct
name|continuation
modifier|*
name|cmd_continuation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|continuation
modifier|*
name|intermediate_continuation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have job control. */
end_comment

begin_decl_stmt
name|int
name|job_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a quit has been requested.  */
end_comment

begin_decl_stmt
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means quit immediately if Control-C is typed now, rather    than waiting until QUIT is executed.  Be careful in setting this;    code which executes with immediate_quit set has to be very careful    about being able to deal with being interrupted at any time.  It is    almost always better to use QUIT; the only exception I can think of    is being able to quit out of a system call (using EINTR loses if    the SIGINT happens between the previous QUIT and the system call).    To immediately quit in the case in which a SIGINT happens between    the previous QUIT and setting immediate_quit (desirable anytime we    expect to block), call QUIT after setting immediate_quit.  */
end_comment

begin_decl_stmt
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++/ObjC names should be printed out in their    C++/ObjC form rather than raw.  */
end_comment

begin_decl_stmt
name|int
name|demangle
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++/ObjC names should be printed out in their    C++/ObjC form even in assembler language displays.  If this is set, but    DEMANGLE is zero, names are printed raw, i.e. DEMANGLE controls.  */
end_comment

begin_decl_stmt
name|int
name|asm_demangle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that strings with character values>0x7F should be printed    as octal escapes.  Zero means just print the value (e.g. it's an    international character, and the terminal or window can cope.)  */
end_comment

begin_decl_stmt
name|int
name|sevenbit_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before error messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before quit messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|quit_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before warning messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|warning_pre_print
init|=
literal|"\nwarning: "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pagination_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add a new cleanup to the cleanup_chain,    and return the previous chain pointer    to be passed later to do_cleanups or discard_cleanups.    Args are FUNCTION to clean up with, and ARG to pass to it.  */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_final_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_run_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|run_cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_exec_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|exec_cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_exec_error_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|exec_error_cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_freeargv
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|freeargv
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_freeargv
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|do_freeargv
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bfd_close_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bfd_close
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_bfd_close
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_bfd_close_cleanup
argument_list|,
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_close_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|fd
init|=
name|arg
decl_stmt|;
name|close
argument_list|(
operator|*
name|fd
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_close
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
modifier|*
name|saved_fd
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|saved_fd
operator|=
name|fd
expr_stmt|;
return|return
name|make_cleanup
argument_list|(
name|do_close_cleanup
argument_list|,
name|saved_fd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ui_file_delete
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ui_file_delete
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_file_delete
parameter_list|(
name|struct
name|ui_file
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|do_ui_file_delete
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_my_cleanup
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
parameter_list|,
name|make_cleanup_ftype
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|new
init|=
operator|(
expr|struct
name|cleanup
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cleanup
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
operator|*
name|pmy_chain
decl_stmt|;
name|new
operator|->
name|next
operator|=
operator|*
name|pmy_chain
expr_stmt|;
name|new
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|new
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
operator|*
name|pmy_chain
operator|=
name|new
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_function

begin_comment
comment|/* Discard cleanups and do the actions they describe    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|do_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_run_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|run_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_exec_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|exec_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_exec_error_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|exec_error_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
parameter_list|,
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
operator|*
name|pmy_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
operator|*
name|pmy_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
comment|/* Do this first incase recursion */
call|(
modifier|*
name|ptr
operator|->
name|function
call|)
argument_list|(
name|ptr
operator|->
name|arg
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Discard cleanups, not doing the actions they describe,    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|discard_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|discard_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|discard_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|discard_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|discard_exec_error_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|discard_my_cleanups
argument_list|(
operator|&
name|exec_error_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|discard_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
parameter_list|,
name|struct
name|cleanup
modifier|*
name|old_chain
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
operator|*
name|pmy_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
operator|*
name|pmy_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the cleanup_chain to 0, and return the old cleanup chain.  */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|save_cleanups
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|save_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|save_final_cleanups
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|save_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|save_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
operator|*
name|pmy_chain
decl_stmt|;
operator|*
name|pmy_chain
operator|=
literal|0
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_function

begin_comment
comment|/* Restore the cleanup chain from a previously saved chain.  */
end_comment

begin_function
name|void
name|restore_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|chain
parameter_list|)
block|{
name|restore_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
name|chain
parameter_list|)
block|{
name|restore_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
parameter_list|,
name|struct
name|cleanup
modifier|*
name|chain
parameter_list|)
block|{
operator|*
name|pmy_chain
operator|=
name|chain
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is useful for cleanups.    Do     foo = xmalloc (...);    old_chain = make_cleanup (free_current_contents,&foo);     to arrange to free the object thus allocated.  */
end_comment

begin_function
name|void
name|free_current_contents
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|location
init|=
name|ptr
decl_stmt|;
if|if
condition|(
name|location
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"free_current_contents: NULL pointer"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|location
operator|!=
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
operator|*
name|location
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Provide a known function that does nothing, to use as a base for    for a possibly long chain of cleanups.  This is useful where we    use the cleanup chain for handling normal cleanups as well as dealing    with cleanups that need to be done as a result of a call to error().    In such cases, we may not be certain where the first cleanup is, unless    we have a do-nothing one to always use as the base. */
end_comment

begin_function
name|void
name|null_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Add a continuation to the continuation list, the global list    cmd_continuation. The new continuation will be added at the front.*/
end_comment

begin_function
name|void
name|add_continuation
parameter_list|(
name|void
function_decl|(
modifier|*
name|continuation_hook
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|continuation_arg
modifier|*
name|arg_list
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|continuation_ptr
decl_stmt|;
name|continuation_ptr
operator|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation
argument_list|)
argument_list|)
expr_stmt|;
name|continuation_ptr
operator|->
name|continuation_hook
operator|=
name|continuation_hook
expr_stmt|;
name|continuation_ptr
operator|->
name|arg_list
operator|=
name|arg_list
expr_stmt|;
name|continuation_ptr
operator|->
name|next
operator|=
name|cmd_continuation
expr_stmt|;
name|cmd_continuation
operator|=
name|continuation_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk down the cmd_continuation list, and execute all the    continuations. There is a problem though. In some cases new    continuations may be added while we are in the middle of this    loop. If this happens they will be added in the front, and done    before we have a chance of exhausting those that were already    there. We need to then save the beginning of the list in a pointer    and do the continuations from there on, instead of using the    global beginning of list as our iteration pointer.*/
end_comment

begin_function
name|void
name|do_all_continuations
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|continuation_ptr
decl_stmt|;
name|struct
name|continuation
modifier|*
name|saved_continuation
decl_stmt|;
comment|/* Copy the list header into another pointer, and set the global      list header to null, so that the global list can change as a side      effect of invoking the continuations and the processing of      the preexisting continuations will not be affected. */
name|continuation_ptr
operator|=
name|cmd_continuation
expr_stmt|;
name|cmd_continuation
operator|=
name|NULL
expr_stmt|;
comment|/* Work now on the list we have set aside. */
while|while
condition|(
name|continuation_ptr
condition|)
block|{
call|(
name|continuation_ptr
operator|->
name|continuation_hook
call|)
argument_list|(
name|continuation_ptr
operator|->
name|arg_list
argument_list|)
expr_stmt|;
name|saved_continuation
operator|=
name|continuation_ptr
expr_stmt|;
name|continuation_ptr
operator|=
name|continuation_ptr
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|saved_continuation
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk down the cmd_continuation list, and get rid of all the    continuations. */
end_comment

begin_function
name|void
name|discard_all_continuations
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|continuation_ptr
decl_stmt|;
while|while
condition|(
name|cmd_continuation
condition|)
block|{
name|continuation_ptr
operator|=
name|cmd_continuation
expr_stmt|;
name|cmd_continuation
operator|=
name|continuation_ptr
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|continuation_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a continuation to the continuation list, the global list    intermediate_continuation. The new continuation will be added at the front.*/
end_comment

begin_function
name|void
name|add_intermediate_continuation
parameter_list|(
name|void
function_decl|(
modifier|*
name|continuation_hook
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|continuation_arg
modifier|*
name|arg_list
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|continuation_ptr
decl_stmt|;
name|continuation_ptr
operator|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation
argument_list|)
argument_list|)
expr_stmt|;
name|continuation_ptr
operator|->
name|continuation_hook
operator|=
name|continuation_hook
expr_stmt|;
name|continuation_ptr
operator|->
name|arg_list
operator|=
name|arg_list
expr_stmt|;
name|continuation_ptr
operator|->
name|next
operator|=
name|intermediate_continuation
expr_stmt|;
name|intermediate_continuation
operator|=
name|continuation_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk down the cmd_continuation list, and execute all the    continuations. There is a problem though. In some cases new    continuations may be added while we are in the middle of this    loop. If this happens they will be added in the front, and done    before we have a chance of exhausting those that were already    there. We need to then save the beginning of the list in a pointer    and do the continuations from there on, instead of using the    global beginning of list as our iteration pointer.*/
end_comment

begin_function
name|void
name|do_all_intermediate_continuations
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|continuation_ptr
decl_stmt|;
name|struct
name|continuation
modifier|*
name|saved_continuation
decl_stmt|;
comment|/* Copy the list header into another pointer, and set the global      list header to null, so that the global list can change as a side      effect of invoking the continuations and the processing of      the preexisting continuations will not be affected. */
name|continuation_ptr
operator|=
name|intermediate_continuation
expr_stmt|;
name|intermediate_continuation
operator|=
name|NULL
expr_stmt|;
comment|/* Work now on the list we have set aside. */
while|while
condition|(
name|continuation_ptr
condition|)
block|{
call|(
name|continuation_ptr
operator|->
name|continuation_hook
call|)
argument_list|(
name|continuation_ptr
operator|->
name|arg_list
argument_list|)
expr_stmt|;
name|saved_continuation
operator|=
name|continuation_ptr
expr_stmt|;
name|continuation_ptr
operator|=
name|continuation_ptr
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|saved_continuation
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk down the cmd_continuation list, and get rid of all the    continuations. */
end_comment

begin_function
name|void
name|discard_all_intermediate_continuations
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|continuation_ptr
decl_stmt|;
while|while
condition|(
name|intermediate_continuation
condition|)
block|{
name|continuation_ptr
operator|=
name|intermediate_continuation
expr_stmt|;
name|intermediate_continuation
operator|=
name|continuation_ptr
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|continuation_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a warning message.  The first argument STRING is the warning    message, used as an fprintf format string, the second is the    va_list of arguments for that string.  A warning is unfiltered (not    paginated) so that the user does not need to page through each    screen full of warnings when there are lots of them.  */
end_comment

begin_function
name|void
name|vwarning
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
if|if
condition|(
name|warning_hook
condition|)
call|(
modifier|*
name|warning_hook
call|)
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_pre_print
condition|)
name|fputs_unfiltered
argument_list|(
name|warning_pre_print
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a warning message.    The first argument STRING is the warning message, used as a fprintf string,    and the remaining args are passed as arguments to it.    The primary difference between warnings and errors is that a warning    does not force the return to command level.  */
end_comment

begin_function
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|vwarning
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and return to command level.    The first argument STRING is the error message, used as a fprintf string,    and the remaining args are passed as arguments to it.  */
end_comment

begin_function
name|NORETURN
name|void
name|verror
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|tmp_stream
init|=
name|mem_fileopen
argument_list|()
decl_stmt|;
name|make_cleanup_ui_file_delete
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|tmp_stream
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|error_stream
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NORETURN
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|verror
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_write
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|length_buffer
parameter_list|)
block|{
name|ui_file_write
argument_list|(
name|data
argument_list|,
name|buffer
argument_list|,
name|length_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cause a silent error to occur.  Any error message is recorded    though it is not issued.  */
end_comment

begin_function
name|NORETURN
name|void
name|error_silent
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|tmp_stream
init|=
name|mem_fileopen
argument_list|()
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|make_cleanup_ui_file_delete
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|tmp_stream
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Copy the stream into the GDB_LASTERR buffer.  */
name|ui_file_rewind
argument_list|(
name|gdb_lasterr
argument_list|)
expr_stmt|;
name|ui_file_put
argument_list|(
name|tmp_stream
argument_list|,
name|do_write
argument_list|,
name|gdb_lasterr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an error message including any pre-print text to gdb_stderr.  */
end_comment

begin_function
name|void
name|error_output_message
parameter_list|(
name|char
modifier|*
name|pre_print
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_error_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|pre_print
condition|)
name|fputs_filtered
argument_list|(
name|pre_print
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|msg
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NORETURN
name|void
name|error_stream
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|error_begin_hook
condition|)
name|error_begin_hook
argument_list|()
expr_stmt|;
comment|/* Copy the stream into the GDB_LASTERR buffer.  */
name|ui_file_rewind
argument_list|(
name|gdb_lasterr
argument_list|)
expr_stmt|;
name|ui_file_put
argument_list|(
name|stream
argument_list|,
name|do_write
argument_list|,
name|gdb_lasterr
argument_list|)
expr_stmt|;
comment|/* Write the message plus any error_pre_print to gdb_stderr.  */
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_error_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|error_pre_print
condition|)
name|fputs_filtered
argument_list|(
name|error_pre_print
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|ui_file_put
argument_list|(
name|stream
argument_list|,
name|do_write
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the last error message issued by gdb */
end_comment

begin_function
name|char
modifier|*
name|error_last_message
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|len
decl_stmt|;
return|return
name|ui_file_xstrdup
argument_list|(
name|gdb_lasterr
argument_list|,
operator|&
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is to be called by main() at the very beginning */
end_comment

begin_function
name|void
name|error_init
parameter_list|(
name|void
parameter_list|)
block|{
name|gdb_lasterr
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a message reporting an internal error/warning. Ask the user    if they want to continue, dump core, or just exit.  Return    something to indicate a quit.  */
end_comment

begin_struct
struct|struct
name|internal_problem
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* FIXME: cagney/2002-08-15: There should be ``maint set/show''      commands available for controlling these variables.  */
name|enum
name|auto_boolean
name|should_quit
decl_stmt|;
name|enum
name|auto_boolean
name|should_dump_core
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Report a problem, internal to GDB, to the user.  Once the problem    has been reported, and assuming GDB didn't quit, the caller can    either allow execution to resume or throw an error.  */
end_comment

begin_function
specifier|static
name|void
name|internal_vproblem
parameter_list|(
name|struct
name|internal_problem
modifier|*
name|problem
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|static
name|int
name|dejavu
decl_stmt|;
name|int
name|quit_p
decl_stmt|;
name|int
name|dump_core_p
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
comment|/* Don't allow infinite error/warning recursion.  */
block|{
specifier|static
name|char
name|msg
index|[]
init|=
literal|"Recursive internal problem.\n"
decl_stmt|;
switch|switch
condition|(
name|dejavu
condition|)
block|{
case|case
literal|0
case|:
name|dejavu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|dejavu
operator|=
literal|2
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|msg
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTE: GDB has only three calls to abort().  */
default|default:
name|dejavu
operator|=
literal|3
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Try to get the message out and at the start of a new line.  */
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|begin_line
argument_list|()
expr_stmt|;
comment|/* Create a string containing the full error/warning message.  Need      to call query with this full string, as otherwize the reason      (error/warning) and question become separated.  Format using a      style similar to a compiler error message.  Include extra detail      so that the user knows that they are living on the edge.  */
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|xvasprintf
argument_list|(
operator|&
name|msg
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|reason
argument_list|,
literal|"\ %s:%d: %s: %s\n\ A problem internal to GDB has been detected,\n\ further debugging may prove unreliable."
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|problem
operator|->
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|problem
operator|->
name|should_quit
condition|)
block|{
case|case
name|AUTO_BOOLEAN_AUTO
case|:
comment|/* Default (yes/batch case) is to quit GDB.  When in batch mode          this lessens the likelhood of GDB going into an infinate          loop.  */
name|quit_p
operator|=
name|query
argument_list|(
literal|"%s\nQuit this debugging session? "
argument_list|,
name|reason
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_TRUE
case|:
name|quit_p
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_FALSE
case|:
name|quit_p
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|problem
operator|->
name|should_dump_core
condition|)
block|{
case|case
name|AUTO_BOOLEAN_AUTO
case|:
comment|/* Default (yes/batch case) is to dump core.  This leaves a GDB          `dropping' so that it is easier to see that something went          wrong in GDB.  */
name|dump_core_p
operator|=
name|query
argument_list|(
literal|"%s\nCreate a core file of GDB? "
argument_list|,
name|reason
argument_list|)
expr_stmt|;
break|break;
break|break;
case|case
name|AUTO_BOOLEAN_TRUE
case|:
name|dump_core_p
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_FALSE
case|:
name|dump_core_p
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quit_p
condition|)
block|{
if|if
condition|(
name|dump_core_p
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTE: GDB has only three calls to abort().  */
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dump_core_p
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTE: GDB has only three calls to abort().  */
block|}
block|}
name|dejavu
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|internal_problem
name|internal_error_problem
init|=
block|{
literal|"internal-error"
block|,
name|AUTO_BOOLEAN_AUTO
block|,
name|AUTO_BOOLEAN_AUTO
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|NORETURN
name|void
name|internal_verror
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|internal_vproblem
argument_list|(
operator|&
name|internal_error_problem
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NORETURN
name|void
name|internal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|internal_verror
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|string
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|internal_problem
name|internal_warning_problem
init|=
block|{
literal|"internal-error"
block|,
name|AUTO_BOOLEAN_AUTO
block|,
name|AUTO_BOOLEAN_AUTO
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|internal_vwarning
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|internal_vproblem
argument_list|(
operator|&
name|internal_warning_problem
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|internal_warning
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|internal_vwarning
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|string
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The strerror() function can return NULL for errno values that are    out of range.  Provide a "safe" version that always returns a    printable string. */
end_comment

begin_function
name|char
modifier|*
name|safe_strerror
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|msg
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(undocumented errno %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the system error message for errno, and also mention STRING    as the file name for which the error was encountered.    Then return to command level.  */
end_comment

begin_function
name|NORETURN
name|void
name|perror_with_name
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* I understand setting these is a matter of taste.  Still, some people      may clear errno but not know about bfd_error.  Doing this here is not      unreasonable. */
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s."
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the system error message for ERRCODE, and also mention STRING    as the file name for which the error was encountered.  */
end_comment

begin_function
name|void
name|print_sys_errmsg
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|errcode
parameter_list|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* We want anything which was printed on stdout to come out first, before      this message.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s.\n"
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Control C eventually causes this to be called, at a convenient time.  */
end_comment

begin_function
name|void
name|quit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|serial
modifier|*
name|gdb_stdout_serial
init|=
name|serial_fdopen
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* We want all output to appear now, before we print "Quit".  We      have 3 levels of buffering we have to flush (it's possible that      some of these should be changed to flush the lower-level ones      too):  */
comment|/* 1.  The _filtered buffer.  */
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 2.  The stdio buffer.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* 3.  The system-level buffer.  */
name|serial_drain_output
argument_list|(
name|gdb_stdout_serial
argument_list|)
expr_stmt|;
name|serial_un_fdopen
argument_list|(
name|gdb_stdout_serial
argument_list|)
expr_stmt|;
name|annotate_error_begin
argument_list|()
expr_stmt|;
comment|/* Don't use *_filtered; we don't want to prompt the user to continue.  */
if|if
condition|(
name|quit_pre_print
condition|)
name|fputs_unfiltered
argument_list|(
name|quit_pre_print
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
comment|/* No steenking SIGINT will ever be coming our way when the      program is resumed.  Don't lie.  */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Quit\n"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|job_control
comment|/* If there is no terminal switching for this target, then we can't          possibly get screwed by the lack of job control.  */
operator|||
name|current_target
operator|.
name|to_terminal_ours
operator|==
name|NULL
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Quit\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Quit (expect signal SIGINT when the program is resumed)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Control C comes here */
end_comment

begin_function
name|void
name|request_quit
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|quit_flag
operator|=
literal|1
expr_stmt|;
comment|/* Restore the signal handler.  Harmless with BSD-style signals, needed      for System V-style signals.  So just always do it, rather than worrying      about USG defines and stuff like that.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediate_quit
condition|)
name|quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memory management stuff (malloc friends).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mmalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
comment|/* NOTE: GDB's only call to malloc() */
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|mrealloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
comment|/* Guard against old realloc's */
return|return
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
return|;
else|else
return|return
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
comment|/* NOTE: GDB's only call to ralloc() */
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|mcalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|calloc
argument_list|(
name|number
argument_list|,
name|size
argument_list|)
return|;
comment|/* NOTE: GDB's only call to calloc() */
block|}
end_function

begin_function
specifier|static
name|void
name|mfree
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* NOTE: GDB's only call to free() */
block|}
end_function

begin_comment
comment|/* This used to do something interesting with USE_MMALLOC.  * It can be retired any time.  -- chastain 2004-01-19.  */
end_comment

begin_function
name|void
name|init_malloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Called when a memory allocation fails, with the number of bytes of    memory requested in SIZE. */
end_comment

begin_function
name|NORETURN
name|void
name|nomem
parameter_list|(
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"virtual memory exhausted: can't allocate %ld bytes."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"virtual memory exhausted."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The xmmalloc() family of memory management routines.     These are are like the mmalloc() family except that they implement    consistent semantics and guard against typical memory management    problems: if a malloc fails, an internal error is thrown; if    free(NULL) is called, it is ignored; if *alloc(0) is called, NULL    is returned.     All these routines are implemented using the mmalloc() family. */
end_comment

begin_function
name|void
modifier|*
name|xmmalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|val
decl_stmt|;
comment|/* See libiberty/xmalloc.c.  This function need's to match that's      semantics.  It never returns NULL.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|xmrealloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|val
decl_stmt|;
comment|/* See libiberty/xmalloc.c.  This function need's to match that's      semantics.  It never returns NULL.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|val
operator|=
name|mrealloc
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|xmcalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
comment|/* See libiberty/xmalloc.c.  This function need's to match that's      semantics.  It never returns NULL.  */
if|if
condition|(
name|number
operator|==
literal|0
operator|||
name|size
operator|==
literal|0
condition|)
block|{
name|number
operator|=
literal|1
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
name|mem
operator|=
name|mcalloc
argument_list|(
name|md
argument_list|,
name|number
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
name|nomem
argument_list|(
name|number
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_function
name|void
name|xmfree
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|mfree
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The xmalloc() (libiberty.h) family of memory management routines.     These are like the ISO-C malloc() family except that they implement    consistent semantics and guard against typical memory management    problems.  See xmmalloc() above for further information.     All these routines are wrappers to the xmmalloc() family. */
end_comment

begin_comment
comment|/* NOTE: These are declared using PTR to ensure consistency with    "libiberty.h".  xfree() is GDB local.  */
end_comment

begin_function
name|PTR
comment|/* OK: PTR */
name|xmalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|xmmalloc
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|PTR
comment|/* OK: PTR */
name|xrealloc
parameter_list|(
name|PTR
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
comment|/* OK: PTR */
block|{
return|return
name|xmrealloc
argument_list|(
name|NULL
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|PTR
comment|/* OK: PTR */
name|xcalloc
parameter_list|(
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|xmcalloc
argument_list|(
name|NULL
argument_list|,
name|number
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|xfree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|xmfree
argument_list|(
name|NULL
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like asprintf/vasprintf but get an internal_error if the call    fails. */
end_comment

begin_function
name|char
modifier|*
name|xstrprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xvasprintf
argument_list|(
operator|&
name|ret
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|xasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xvasprintf
argument_list|(
name|ret
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xvasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|status
init|=
name|vasprintf
argument_list|(
name|ret
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
decl_stmt|;
comment|/* NULL could be returned due to a memory allocation problem; a      badly format string; or something else. */
if|if
condition|(
operator|(
operator|*
name|ret
operator|)
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"vasprintf returned NULL buffer (errno %d)"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* A negative status with a non-NULL buffer shouldn't never      happen. But to be sure. */
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"vasprintf call failed (errno %d)"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* My replacement for the read system call.    Used like `read' but keeps going if `read' returns too soon.  */
end_comment

begin_function
name|int
name|myread
parameter_list|(
name|int
name|desc
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|orglen
init|=
name|len
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
name|val
return|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
name|orglen
operator|-
name|len
return|;
name|len
operator|-=
name|val
expr_stmt|;
name|addr
operator|+=
name|val
expr_stmt|;
block|}
return|return
name|orglen
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of the string at PTR with SIZE characters    (and add a null character at the end in the copy).    Uses malloc to get the space.  Returns the address of the copy.  */
end_comment

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|msavestring
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmmalloc
argument_list|(
name|md
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|mstrsave
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
name|msavestring
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_spaces
parameter_list|(
name|int
name|n
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|fputs_unfiltered
argument_list|(
name|n_spaces
argument_list|(
name|n
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a host address.  */
end_comment

begin_function
name|void
name|gdb_print_host_address
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
comment|/* We could use the %p conversion specifier to fprintf if we had any      way of knowing whether this host supports it.  But the following      should work on the Alpha and on 32 bit machines.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask user a y-or-n question and return 1 iff answer is yes.    Takes three args which are given to printf to print the question.    The first, a control string, should end in "? ".    It should not say how to answer, because we do that.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|int
name|query
parameter_list|(
specifier|const
name|char
modifier|*
name|ctlstr
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|answer
decl_stmt|;
name|int
name|ans2
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|ctlstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_hook
condition|)
block|{
return|return
name|query_hook
argument_list|(
name|ctlstr
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/* Automatically answer "yes" if input is not from a terminal.  */
if|if
condition|(
operator|!
name|input_from_terminal_p
argument_list|()
condition|)
return|return
literal|1
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032pre-query\n"
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|ctlstr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(y or n) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032query\n"
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|answer
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* in case of C-d */
if|if
condition|(
name|answer
operator|==
name|EOF
condition|)
comment|/* C-d */
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Eat rest of input line, to EOF or newline */
if|if
condition|(
name|answer
operator|!=
literal|'\n'
condition|)
do|do
block|{
name|ans2
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ans2
operator|!=
name|EOF
operator|&&
name|ans2
operator|!=
literal|'\n'
operator|&&
name|ans2
operator|!=
literal|'\r'
condition|)
do|;
if|if
condition|(
name|answer
operator|>=
literal|'a'
condition|)
name|answer
operator|-=
literal|040
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|'Y'
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|answer
operator|==
literal|'N'
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"Please answer y or n.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032post-query\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function supports the nquery() and yquery() functions.    Ask user a y-or-n question and return 0 if answer is no, 1 if    answer is yes, or default the answer to the specified default.    DEFCHAR is either 'y' or 'n' and refers to the default answer.    CTLSTR is the control string and should end in "? ".  It should    not say how to answer, because we do that.    ARGS are the arguments passed along with the CTLSTR argument to    printf.  */
end_comment

begin_function
specifier|static
name|int
name|defaulted_query
parameter_list|(
specifier|const
name|char
modifier|*
name|ctlstr
parameter_list|,
specifier|const
name|char
name|defchar
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|int
name|answer
decl_stmt|;
name|int
name|ans2
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|def_value
decl_stmt|;
name|char
name|def_answer
decl_stmt|,
name|not_def_answer
decl_stmt|;
name|char
modifier|*
name|y_string
decl_stmt|,
modifier|*
name|n_string
decl_stmt|;
comment|/* Set up according to which answer is the default.  */
if|if
condition|(
name|defchar
operator|==
literal|'y'
condition|)
block|{
name|def_value
operator|=
literal|1
expr_stmt|;
name|def_answer
operator|=
literal|'Y'
expr_stmt|;
name|not_def_answer
operator|=
literal|'N'
expr_stmt|;
name|y_string
operator|=
literal|"[y]"
expr_stmt|;
name|n_string
operator|=
literal|"n"
expr_stmt|;
block|}
else|else
block|{
name|def_value
operator|=
literal|0
expr_stmt|;
name|def_answer
operator|=
literal|'N'
expr_stmt|;
name|not_def_answer
operator|=
literal|'Y'
expr_stmt|;
name|y_string
operator|=
literal|"y"
expr_stmt|;
name|n_string
operator|=
literal|"[n]"
expr_stmt|;
block|}
if|if
condition|(
name|query_hook
condition|)
block|{
return|return
name|query_hook
argument_list|(
name|ctlstr
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/* Automatically answer default value if input is not from a terminal.  */
if|if
condition|(
operator|!
name|input_from_terminal_p
argument_list|()
condition|)
return|return
name|def_value
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032pre-query\n"
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|ctlstr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(%s or %s) "
argument_list|,
name|y_string
argument_list|,
name|n_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032query\n"
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|answer
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* in case of C-d */
if|if
condition|(
name|answer
operator|==
name|EOF
condition|)
comment|/* C-d */
block|{
name|retval
operator|=
name|def_value
expr_stmt|;
break|break;
block|}
comment|/* Eat rest of input line, to EOF or newline */
if|if
condition|(
name|answer
operator|!=
literal|'\n'
condition|)
do|do
block|{
name|ans2
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ans2
operator|!=
name|EOF
operator|&&
name|ans2
operator|!=
literal|'\n'
operator|&&
name|ans2
operator|!=
literal|'\r'
condition|)
do|;
if|if
condition|(
name|answer
operator|>=
literal|'a'
condition|)
name|answer
operator|-=
literal|040
expr_stmt|;
comment|/* Check answer.  For the non-default, the user must specify          the non-default explicitly.  */
if|if
condition|(
name|answer
operator|==
name|not_def_answer
condition|)
block|{
name|retval
operator|=
operator|!
name|def_value
expr_stmt|;
break|break;
block|}
comment|/* Otherwise, for the default, the user may either specify          the required input or have it default by entering nothing.  */
if|if
condition|(
name|answer
operator|==
name|def_answer
operator|||
name|answer
operator|==
literal|'\n'
operator|||
name|answer
operator|==
literal|'\r'
operator|||
name|answer
operator|==
name|EOF
condition|)
block|{
name|retval
operator|=
name|def_value
expr_stmt|;
break|break;
block|}
comment|/* Invalid entries are not defaulted and require another selection.  */
name|printf_filtered
argument_list|(
literal|"Please answer %s or %s.\n"
argument_list|,
name|y_string
argument_list|,
name|n_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032post-query\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ask user a y-or-n question and return 0 if answer is no, 1 if    answer is yes, or 0 if answer is defaulted.    Takes three args which are given to printf to print the question.    The first, a control string, should end in "? ".    It should not say how to answer, because we do that.  */
end_comment

begin_function
name|int
name|nquery
parameter_list|(
specifier|const
name|char
modifier|*
name|ctlstr
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|ctlstr
argument_list|)
expr_stmt|;
return|return
name|defaulted_query
argument_list|(
name|ctlstr
argument_list|,
literal|'n'
argument_list|,
name|args
argument_list|)
return|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask user a y-or-n question and return 0 if answer is no, 1 if    answer is yes, or 1 if answer is defaulted.    Takes three args which are given to printf to print the question.    The first, a control string, should end in "? ".    It should not say how to answer, because we do that.  */
end_comment

begin_function
name|int
name|yquery
parameter_list|(
specifier|const
name|char
modifier|*
name|ctlstr
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|ctlstr
argument_list|)
expr_stmt|;
return|return
name|defaulted_query
argument_list|(
name|ctlstr
argument_list|,
literal|'y'
argument_list|,
name|args
argument_list|)
return|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message saying that we couldn't make sense of a    \^mumble sequence in a string or character constant.  START and END    indicate a substring of some larger string that contains the    erroneous backslash sequence, missing the initial backslash.  */
end_comment

begin_function
specifier|static
name|NORETURN
name|int
name|no_control_char_error
parameter_list|(
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|int
name|len
init|=
name|end
operator|-
name|start
decl_stmt|;
name|char
modifier|*
name|copy
init|=
name|alloca
argument_list|(
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copy
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"There is no control character `\\%s' in the `%s' character set."
argument_list|,
name|copy
argument_list|,
name|target_charset
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a C escape sequence.  STRING_PTR points to a variable    containing a pointer to the string to parse.  That pointer    should point to the character after the \.  That pointer    is updated past the characters we use.  The value of the    escape sequence is returned.     A negative value means the sequence \ newline was seen,    which is supposed to be equivalent to nothing at all.     If \ is followed by a null character, we return a negative    value and leave the string pointer pointing at the null character.     If \ is followed by 000, we return 0 and leave the string pointer    after the zeros.  A value of 0 does not mean end of string.  */
end_comment

begin_function
name|int
name|parse_escape
parameter_list|(
name|char
modifier|*
modifier|*
name|string_ptr
parameter_list|)
block|{
name|int
name|target_char
decl_stmt|;
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
if|if
condition|(
name|c_parse_backslash
argument_list|(
name|c
argument_list|,
operator|&
name|target_char
argument_list|)
condition|)
return|return
name|target_char
return|;
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'^'
case|:
block|{
comment|/* Remember where this escape sequence started, for reporting 	     errors.  */
name|char
modifier|*
name|sequence_start_pos
init|=
operator|*
name|string_ptr
operator|-
literal|1
decl_stmt|;
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
comment|/* XXXCHARSET: What is `delete' in the host character set?  */
name|c
operator|=
literal|0177
expr_stmt|;
if|if
condition|(
operator|!
name|host_char_to_target
argument_list|(
name|c
argument_list|,
operator|&
name|target_char
argument_list|)
condition|)
name|error
argument_list|(
literal|"There is no character corresponding to `Delete' "
literal|"in the target character set `%s'."
argument_list|,
name|host_charset
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|target_char
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|target_char
operator|=
name|parse_escape
argument_list|(
name|string_ptr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|host_char_to_target
argument_list|(
name|c
argument_list|,
operator|&
name|target_char
argument_list|)
condition|)
name|no_control_char_error
argument_list|(
name|sequence_start_pos
argument_list|,
operator|*
name|string_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* Now target_char is something like `c', and we want to find 	     its control-character equivalent.  */
if|if
condition|(
operator|!
name|target_char_to_control_char
argument_list|(
name|target_char
argument_list|,
operator|&
name|target_char
argument_list|)
condition|)
name|no_control_char_error
argument_list|(
name|sequence_start_pos
argument_list|,
operator|*
name|string_ptr
argument_list|)
expr_stmt|;
return|return
name|target_char
return|;
block|}
comment|/* XXXCHARSET: we need to use isdigit and value-of-digit 	   methods of the host character set here.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
name|c
operator|=
operator|(
operator|*
operator|*
name|string_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
name|i
operator|*=
literal|8
expr_stmt|;
name|i
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
default|default:
if|if
condition|(
operator|!
name|host_char_to_target
argument_list|(
name|c
argument_list|,
operator|&
name|target_char
argument_list|)
condition|)
name|error
argument_list|(
literal|"The escape sequence `\%c' is equivalent to plain `%c', which"
literal|" has no equivalent\n"
literal|"in the `%s' character set."
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
name|target_charset
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|target_char
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that this routine should only    be call for printing things which are independent of the language    of the program being debugged. */
end_comment

begin_function
specifier|static
name|void
name|printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|void
function_decl|(
modifier|*
name|do_fputs
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|do_fprintf
function_decl|)
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|c
operator|<
literal|0x20
operator|||
comment|/* Low control chars */
operator|(
name|c
operator|>=
literal|0x7F
operator|&&
name|c
operator|<
literal|0xA0
operator|)
operator|||
comment|/* DEL, High controls */
operator|(
name|sevenbit_strings
operator|&&
name|c
operator|>=
literal|0x80
operator|)
condition|)
block|{
comment|/* high order bit set */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|do_fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|do_fputs
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|do_fputs
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|do_fputs
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|do_fputs
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|do_fputs
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|do_fputs
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|do_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
name|do_fputs
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|do_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a    literal string whose delimiter is QUOTER.  Note that these routines    should only be call for printing things which are independent of    the language of the program being debugged. */
end_comment

begin_function
name|void
name|fputstr_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quoter
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
condition|)
name|printchar
argument_list|(
operator|*
name|str
operator|++
argument_list|,
name|fputs_filtered
argument_list|,
name|fprintf_filtered
argument_list|,
name|stream
argument_list|,
name|quoter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fputstr_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quoter
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
condition|)
name|printchar
argument_list|(
operator|*
name|str
operator|++
argument_list|,
name|fputs_unfiltered
argument_list|,
name|fprintf_unfiltered
argument_list|,
name|stream
argument_list|,
name|quoter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fputstrn_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|quoter
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printchar
argument_list|(
name|str
index|[
name|i
index|]
argument_list|,
name|fputs_unfiltered
argument_list|,
name|fprintf_unfiltered
argument_list|,
name|stream
argument_list|,
name|quoter
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Number of lines per page or UINT_MAX if paging is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_per_page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars per line or UINT_MAX if line folding is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|chars_per_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current count of lines printed on this page, chars on this line.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_printed
decl_stmt|,
name|chars_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer and start column of buffered text, for doing smarter word-    wrapping.  When someone calls wrap_here(), we start buffering output    that comes through fputs_filtered().  If we see a newline, we just    spit it out and forget about the wrap_here().  If we see another    wrap_here(), we spit it out and remember the newer one.  If we see    the end of the line, we spit out a newline, the indent, and then    the buffered output.  */
end_comment

begin_comment
comment|/* Malloc'd buffer with chars_per_line+2 bytes.  Contains characters which    are waiting to be output (they have already been counted in chars_printed).    When wrap_buffer[0] is null, the buffer is empty.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer in wrap_buffer to the next character to fill.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to indent by if the wrap occurs.  Must not be NULL if wrap_column    is non-zero.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column number on the screen where wrap_buffer begins, or 0 if wrapping    is not in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wrap_column
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Inialize the number of lines per page and chars per line.  */
end_comment

begin_function
name|void
name|init_page_info
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
operator|!
name|tui_get_command_dimension
argument_list|(
operator|&
name|chars_per_line
argument_list|,
operator|&
name|lines_per_page
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|rows
operator|=
name|ScreenRows
argument_list|()
expr_stmt|;
name|cols
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
name|lines_per_page
operator|=
name|rows
expr_stmt|;
name|chars_per_line
operator|=
name|cols
expr_stmt|;
else|#
directive|else
comment|/* Make sure Readline has initialized its terminal settings.  */
name|rl_reset_terminal
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the screen size from Readline.  */
name|rl_get_screen_size
argument_list|(
operator|&
name|rows
argument_list|,
operator|&
name|cols
argument_list|)
expr_stmt|;
name|lines_per_page
operator|=
name|rows
expr_stmt|;
name|chars_per_line
operator|=
name|cols
expr_stmt|;
comment|/* Readline should have fetched the termcap entry for us.  */
if|if
condition|(
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|<
literal|0
operator|||
name|getenv
argument_list|(
literal|"EMACS"
argument_list|)
condition|)
block|{
comment|/* The number of lines per page is not mentioned in the 	     terminal description.  This probably means that paging is 	     not useful (e.g. emacs shell window), so disable paging.  */
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
block|}
comment|/* FIXME: Get rid of this junk.  */
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
name|SIGWINCH_HANDLER
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the output is not a terminal, don't paginate it.  */
if|if
condition|(
operator|!
name|ui_file_isatty
argument_list|(
name|gdb_stdout
argument_list|)
condition|)
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
endif|#
directive|endif
block|}
name|set_screen_size
argument_list|()
expr_stmt|;
name|set_width
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the screen size based on LINES_PER_PAGE and CHARS_PER_LINE.  */
end_comment

begin_function
specifier|static
name|void
name|set_screen_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rows
init|=
name|lines_per_page
decl_stmt|;
name|int
name|cols
init|=
name|chars_per_line
decl_stmt|;
if|if
condition|(
name|rows
operator|<=
literal|0
condition|)
name|rows
operator|=
name|INT_MAX
expr_stmt|;
if|if
condition|(
name|cols
operator|<=
literal|0
condition|)
name|rl_get_screen_size
argument_list|(
name|NULL
argument_list|,
operator|&
name|cols
argument_list|)
expr_stmt|;
comment|/* Update Readline's idea of the terminal size.  */
name|rl_set_screen_size
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reinitialize WRAP_BUFFER according to the current value of    CHARS_PER_LINE.  */
end_comment

begin_function
specifier|static
name|void
name|set_width
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|chars_per_line
operator|==
literal|0
condition|)
name|init_page_info
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|wrap_buffer
condition|)
block|{
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|wrap_buffer
argument_list|,
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Start it at the beginning.  */
block|}
end_function

begin_function
specifier|static
name|void
name|set_width_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|set_screen_size
argument_list|()
expr_stmt|;
name|set_width
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_height_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|set_screen_size
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait, so the user can read what's on the screen.  Prompt the user    to continue by pressing RETURN.  */
end_comment

begin_function
specifier|static
name|void
name|prompt_for_continue
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|ignore
decl_stmt|;
name|char
name|cont_prompt
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n\032\032pre-prompt-for-continue\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cont_prompt
argument_list|,
literal|"---Type<return> to continue, or q<return> to quit---"
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|strcat
argument_list|(
name|cont_prompt
argument_list|,
literal|"\n\032\032prompt-for-continue\n"
argument_list|)
expr_stmt|;
comment|/* We must do this *before* we call gdb_readline, else it will eventually      call us -- thinking that we're trying to print beyond the end of the       screen.  */
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
comment|/* On a real operating system, the user can quit with SIGINT.      But not on GO32.       'q' is provided on all systems so users don't have to change habits      from system to system, and because telling them what to do in      the prompt is more user-friendly than expecting them to think of      SIGINT.  */
comment|/* Call readline, not gdb_readline, because GO32 readline handles control-C      whereas control-C to gdb_readline will cause the user to get dumped      out to DOS.  */
name|ignore
operator|=
name|gdb_readline_wrapper
argument_list|(
name|cont_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n\032\032post-prompt-for-continue\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|ignore
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'q'
condition|)
block|{
if|if
condition|(
operator|!
name|event_loop_p
condition|)
name|request_quit
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
else|else
name|async_request_quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|--
expr_stmt|;
comment|/* Now we have to do this again, so that GDB will know that it doesn't      need to save the ---Type<return>--- line at the top of the screen.  */
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Forget prev cmd -- CR won't repeat it. */
block|}
end_function

begin_comment
comment|/* Reinitialize filter; ie. tell it to reset to original values.  */
end_comment

begin_function
name|void
name|reinitialize_more_filter
parameter_list|(
name|void
parameter_list|)
block|{
name|lines_printed
operator|=
literal|0
expr_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that if the next sequence of characters overflows the line,    a newline should be inserted here rather than when it hits the end.     If INDENT is non-null, it is a string to be printed to indent the    wrapped part on the next line.  INDENT must remain accessible until    the next call to wrap_here() or until a newline is printed through    fputs_filtered().     If the line is already overfull, we immediately print a newline and    the indentation, and disable further wrapping.     If we don't know the width of lines, but we know the page height,    we must not wrap words, but should still keep track of newlines    that were explicitly printed.     INDENT should not contain tabs, as that will mess up the char count    on the next line.  FIXME.     This routine is guaranteed to force out any output which has been    squirreled away in the wrap_buffer, so wrap_here ((char *)0) can be    used to force out output from the wrap_buffer.  */
end_comment

begin_function
name|void
name|wrap_here
parameter_list|(
name|char
modifier|*
name|indent
parameter_list|)
block|{
comment|/* This should have been allocated, but be paranoid anyway. */
if|if
condition|(
operator|!
name|wrap_buffer
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap_buffer
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|wrap_buffer
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chars_per_line
operator|==
name|UINT_MAX
condition|)
comment|/* No line overflow checking */
block|{
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|!=
name|NULL
condition|)
name|puts_filtered
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wrap_column
operator|=
name|chars_printed
expr_stmt|;
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
name|wrap_indent
operator|=
literal|""
expr_stmt|;
else|else
name|wrap_indent
operator|=
name|indent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print input string to gdb_stdout, filtered, with wrap,     arranging strings in columns of n chars. String can be    right or left justified in the column.  Never prints     trailing spaces.  String should never be longer than    width.  FIXME: this could be useful for the EXAMINE     command, which currently doesn't tabulate very well */
end_comment

begin_function
name|void
name|puts_filtered_tabular
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|right
parameter_list|)
block|{
name|int
name|spaces
init|=
literal|0
decl_stmt|;
name|int
name|stringlen
decl_stmt|;
name|char
modifier|*
name|spacebuf
decl_stmt|;
name|gdb_assert
argument_list|(
name|chars_per_line
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_per_line
operator|==
name|UINT_MAX
condition|)
block|{
name|fputs_filtered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|chars_printed
operator|-
literal|1
operator|)
operator|/
name|width
operator|+
literal|2
operator|)
operator|*
name|width
operator|>=
name|chars_per_line
condition|)
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>=
name|chars_per_line
condition|)
name|width
operator|=
name|chars_per_line
operator|-
literal|1
expr_stmt|;
name|stringlen
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_printed
operator|>
literal|0
condition|)
name|spaces
operator|=
name|width
operator|-
operator|(
name|chars_printed
operator|-
literal|1
operator|)
operator|%
name|width
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|right
condition|)
name|spaces
operator|+=
name|width
operator|-
name|stringlen
expr_stmt|;
name|spacebuf
operator|=
name|alloca
argument_list|(
name|spaces
operator|+
literal|1
argument_list|)
expr_stmt|;
name|spacebuf
index|[
name|spaces
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
name|spacebuf
index|[
name|spaces
index|]
operator|=
literal|' '
expr_stmt|;
name|fputs_filtered
argument_list|(
name|spacebuf
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure that whatever gets printed next, using the filtered output    commands, starts at the beginning of the line.  I.E. if there is    any pending output for the current line, flush it and start a new    line.  Otherwise do nothing. */
end_comment

begin_function
name|void
name|begin_line
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|chars_printed
operator|>
literal|0
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like fputs but if FILTER is true, pause after every screenful.     Regardless of FILTER can wrap at points other than the final    character of a line.     Unlike fputs, fputs_maybe_filtered does not return a value.    It is OK for LINEBUFFER to be NULL, in which case just don't print    anything.     Note that a longjmp to top level may occur in this routine (only if    FILTER is true) (since prompt_for_continue may do so) so this    routine should not be called when cleanups are not in place.  */
end_comment

begin_function
specifier|static
name|void
name|fputs_maybe_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|linebuffer
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|filter
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lineptr
decl_stmt|;
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
return|return;
comment|/* Don't do any filtering if it is disabled.  */
if|if
condition|(
operator|(
name|stream
operator|!=
name|gdb_stdout
operator|)
operator|||
operator|!
name|pagination_enabled
operator|||
operator|(
name|lines_per_page
operator|==
name|UINT_MAX
operator|&&
name|chars_per_line
operator|==
name|UINT_MAX
operator|)
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Go through and output each character.  Show line extension      when this is necessary; prompt user for new page when this is      necessary.  */
name|lineptr
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
condition|)
block|{
comment|/* Possible new page.  */
if|if
condition|(
name|filter
operator|&&
operator|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
operator|)
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
operator|&&
operator|*
name|lineptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Print a single line.  */
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
literal|'\t'
expr_stmt|;
else|else
name|fputc_unfiltered
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Shifting right by 3 produces the number of tab stops 	         we have already passed, and then adding one and 	         shifting left 3 advances to the next tab stop.  */
name|chars_printed
operator|=
operator|(
operator|(
name|chars_printed
operator|>>
literal|3
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
operator|*
name|lineptr
expr_stmt|;
else|else
name|fputc_unfiltered
argument_list|(
operator|*
name|lineptr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chars_printed
operator|++
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|unsigned
name|int
name|save_chars
init|=
name|chars_printed
decl_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|lines_printed
operator|++
expr_stmt|;
comment|/* If we aren't actually wrapping, don't output newline -- 	         if chars_per_line is right, we probably just overflowed 	         anyway; if it's wrong, let us keep going.  */
if|if
condition|(
name|wrap_column
condition|)
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Possible new page.  */
if|if
condition|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
comment|/* Now output indentation and wrapped string */
if|if
condition|(
name|wrap_column
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|wrap_indent
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate saved stuff */
name|fputs_unfiltered
argument_list|(
name|wrap_buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* and eject it */
comment|/* FIXME, this strlen is what prevents wrap_indent from 		     containing tabs.  However, if we recurse to print it 		     and count its chars, we risk trouble if wrap_indent is 		     longer than (the user settable) chars_per_line.  		     Note also that this can set chars_printed> chars_per_line 		     if we are printing a long string.  */
name|chars_printed
operator|=
name|strlen
argument_list|(
name|wrap_indent
argument_list|)
operator|+
operator|(
name|save_chars
operator|-
name|wrap_column
operator|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Reset buffer */
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
comment|/* And disable fancy wrap */
block|}
block|}
block|}
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\n'
condition|)
block|{
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Spit out chars, cancel further wraps */
name|lines_printed
operator|++
expr_stmt|;
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|fputs_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|linebuffer
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fputs_maybe_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|putchar_unfiltered
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|char
name|buf
init|=
name|c
decl_stmt|;
name|ui_file_write
argument_list|(
name|gdb_stdout
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Write character C to gdb_stdout using GDB's paging mechanism and return C.    May return nonlocally.  */
end_comment

begin_function
name|int
name|putchar_filtered
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|fputc_filtered
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|fputc_unfiltered
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|char
name|buf
init|=
name|c
decl_stmt|;
name|ui_file_write
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|fputc_filtered
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* puts_debug is like fputs_unfiltered, except it prints special    characters in printable fashion.  */
end_comment

begin_function
name|void
name|puts_debug
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
comment|/* Print prefix and suffix after each line.  */
specifier|static
name|int
name|new_line
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|return_p
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|prev_prefix
init|=
literal|""
decl_stmt|;
specifier|static
name|char
modifier|*
name|prev_suffix
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\n'
condition|)
name|return_p
operator|=
literal|0
expr_stmt|;
comment|/* If the prefix is changing, print the previous suffix, a new line,      and the new prefix.  */
if|if
condition|(
operator|(
name|return_p
operator|||
operator|(
name|strcmp
argument_list|(
name|prev_prefix
argument_list|,
name|prefix
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|!
name|new_line
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|prev_suffix
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|prefix
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
comment|/* Print prefix if we printed a newline during the previous call.  */
if|if
condition|(
name|new_line
condition|)
block|{
name|new_line
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|prefix
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
name|prev_prefix
operator|=
name|prefix
expr_stmt|;
name|prev_suffix
operator|=
name|suffix
expr_stmt|;
comment|/* Output characters in a printable format.  */
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc_unfiltered
argument_list|(
name|ch
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\\x%02x"
argument_list|,
name|ch
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\\\"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\b"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\f"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|new_line
operator|=
literal|1
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\r"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\t"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\v"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
break|break;
block|}
name|return_p
operator|=
name|ch
operator|==
literal|'\r'
expr_stmt|;
block|}
comment|/* Print suffix if we printed a newline.  */
if|if
condition|(
name|new_line
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|suffix
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a variable number of ARGS using format FORMAT.  If this    information is going to put the amount written (since the last call    to REINITIALIZE_MORE_FILTER or the last page break) over the page size,    call prompt_for_continue to get the users permision to continue.     Unlike fprintf, this function does not return a value.     We implement three variants, vfprintf (takes a vararg list and stream),    fprintf (takes a stream to write on), and printf (the usual).     Note also that a longjmp to top level may occur in this routine    (since prompt_for_continue may do so) so this routine should not be    called when cleanups are not in place.  */
end_comment

begin_function
specifier|static
name|void
name|vfprintf_maybe_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|,
name|int
name|filter
parameter_list|)
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|xvasprintf
argument_list|(
operator|&
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|fputs_maybe_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vfprintf_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|vfprintf_maybe_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vfprintf_unfiltered
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|xvasprintf
argument_list|(
operator|&
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vprintf_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|vfprintf_maybe_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vprintf_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|vfprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fprintf_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fprintf_unfiltered
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like fprintf_filtered, but prints its result indented.    Called as fprintfi_filtered (spaces, stream, format, ...);  */
end_comment

begin_function
name|void
name|fprintfi_filtered
parameter_list|(
name|int
name|spaces
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printf_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printf_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like printf_filtered, but prints it's result indented.    Called as printfi_filtered (spaces, format, ...);  */
end_comment

begin_function
name|void
name|printfi_filtered
parameter_list|(
name|int
name|spaces
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Easy -- but watch out!     This routine is *not* a replacement for puts()!  puts() appends a newline.    This one doesn't, and had better not!  */
end_comment

begin_function
name|void
name|puts_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|fputs_filtered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|puts_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|fputs_unfiltered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to N spaces and a null.  The pointer is good    until the next call to here.  */
end_comment

begin_function
name|char
modifier|*
name|n_spaces
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
modifier|*
name|spaces
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|max_spaces
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|max_spaces
condition|)
block|{
if|if
condition|(
name|spaces
condition|)
name|xfree
argument_list|(
name|spaces
argument_list|)
expr_stmt|;
name|spaces
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|spaces
operator|+
name|n
init|;
name|t
operator|!=
name|spaces
condition|;
control|)
operator|*
operator|--
name|t
operator|=
literal|' '
expr_stmt|;
name|spaces
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|max_spaces
operator|=
name|n
expr_stmt|;
block|}
return|return
name|spaces
operator|+
name|max_spaces
operator|-
name|n
return|;
block|}
end_function

begin_comment
comment|/* Print N spaces.  */
end_comment

begin_function
name|void
name|print_spaces_filtered
parameter_list|(
name|int
name|n
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fputs_filtered
argument_list|(
name|n_spaces
argument_list|(
name|n
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* C++/ObjC demangler stuff.  */
end_comment

begin_comment
comment|/* fprintf_symbol_filtered attempts to demangle NAME, a symbol in language    LANG, using demangling args ARG_MODE, and print it filtered to STREAM.    If the name is not mangled, or the language for the name is unknown, or    demangling is off, the name is printed in its "raw" form. */
end_comment

begin_function
name|void
name|fprintf_symbol_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|language
name|lang
parameter_list|,
name|int
name|arg_mode
parameter_list|)
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* If user wants to see raw output, no problem.  */
if|if
condition|(
operator|!
name|demangle
condition|)
block|{
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|demangled
operator|=
name|language_demangle
argument_list|(
name|language_def
argument_list|(
name|lang
argument_list|)
argument_list|,
name|name
argument_list|,
name|arg_mode
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|demangled
condition|?
name|demangled
else|:
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|xfree
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do a strcmp() type operation on STRING1 and STRING2, ignoring any    differences in whitespace.  Returns 0 if they match, non-zero if they    don't (slightly different than strcmp()'s range of return values).     As an extra hack, string1=="FOO(ARGS)" matches string2=="FOO".    This "feature" is useful when searching for matching C++ function names    (such as if the user types 'break FOO', where FOO is a mangled C++    function). */
end_comment

begin_function
name|int
name|strcmp_iw
parameter_list|(
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string1
argument_list|)
condition|)
block|{
name|string1
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string2
argument_list|)
condition|)
block|{
name|string2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
operator|*
name|string2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
literal|'\0'
condition|)
block|{
name|string1
operator|++
expr_stmt|;
name|string2
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|&&
operator|*
name|string1
operator|!=
literal|'('
operator|)
operator|||
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is like strcmp except that it ignores whitespace and treats    '(' as the first non-NULL character in terms of ordering.  Like    strcmp (and unlike strcmp_iw), it returns negative if STRING1<    STRING2, 0 if STRING2 = STRING2, and positive if STRING1> STRING2    according to that ordering.     If a list is sorted according to this function and if you want to    find names in the list that match some fixed NAME according to    strcmp_iw(LIST_ELT, NAME), then the place to start looking is right    where this function would put NAME.     Here are some examples of why using strcmp to sort is a bad idea:     Whitespace example:     Say your partial symtab contains: "foo<char *>", "goo".  Then, if    we try to do a search for "foo<char*>", strcmp will locate this    after "foo<char *>" and before "goo".  Then lookup_partial_symbol    will start looking at strings beginning with "goo", and will never    see the correct match of "foo<char *>".     Parenthesis example:     In practice, this is less like to be an issue, but I'll give it a    shot.  Let's assume that '$' is a legitimate character to occur in    symbols.  (Which may well even be the case on some systems.)  Then    say that the partial symbol table contains "foo$" and "foo(int)".    strcmp will put them in this order, since '$'< '('.  Now, if the    user searches for "foo", then strcmp will sort "foo" before "foo$".    Then lookup_partial_symbol will notice that strcmp_iw("foo$",    "foo") is false, so it won't proceed to the actual match of    "foo(int)" with "foo".  */
end_comment

begin_function
name|int
name|strcmp_iw_ordered
parameter_list|(
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string1
argument_list|)
condition|)
block|{
name|string1
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string2
argument_list|)
condition|)
block|{
name|string2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
operator|*
name|string2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
literal|'\0'
condition|)
block|{
name|string1
operator|++
expr_stmt|;
name|string2
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
operator|*
name|string1
condition|)
block|{
comment|/* Characters are non-equal unless they're both '\0'; we want to 	 make sure we get the comparison right according to our 	 comparison in the cases where one of them is '\0' or '('.  */
case|case
literal|'\0'
case|:
if|if
condition|(
operator|*
name|string2
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
literal|'('
case|:
if|if
condition|(
operator|*
name|string2
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
default|default:
if|if
condition|(
operator|*
name|string2
operator|==
literal|'('
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|*
name|string1
operator|-
operator|*
name|string2
return|;
block|}
block|}
end_function

begin_comment
comment|/* A simple comparison function with opposite semantics to strcmp.  */
end_comment

begin_function
name|int
name|streq
parameter_list|(
specifier|const
name|char
modifier|*
name|lhs
parameter_list|,
specifier|const
name|char
modifier|*
name|rhs
parameter_list|)
block|{
return|return
operator|!
name|strcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    ** subset_compare()    **    Answer whether string_to_compare is a full or partial match to    **    template_string.  The partial match must be in sequence starting    **    at index 0.  */
end_comment

begin_function
name|int
name|subset_compare
parameter_list|(
name|char
modifier|*
name|string_to_compare
parameter_list|,
name|char
modifier|*
name|template_string
parameter_list|)
block|{
name|int
name|match
decl_stmt|;
if|if
condition|(
name|template_string
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|string_to_compare
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strlen
argument_list|(
name|string_to_compare
argument_list|)
operator|<=
name|strlen
argument_list|(
name|template_string
argument_list|)
condition|)
name|match
operator|=
operator|(
name|strncmp
argument_list|(
name|template_string
argument_list|,
name|string_to_compare
argument_list|,
name|strlen
argument_list|(
name|string_to_compare
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|match
operator|=
literal|0
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|pagination_on_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|pagination_on_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|pagination_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|pagination_on_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|pagination_off_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|pagination_enabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|initialize_utils
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"width"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|&
name|chars_per_line
argument_list|,
literal|"Set number of characters gdb thinks are in a line."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_width_command
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"height"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|&
name|lines_per_page
argument_list|,
literal|"Set number of lines gdb thinks are in a page."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_height_command
argument_list|)
expr_stmt|;
name|init_page_info
argument_list|()
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|demangle
argument_list|,
literal|"Set demangling of encoded C++/ObjC names when displaying symbols."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"pagination"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pagination_enabled
argument_list|,
literal|"Set state of pagination."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"am"
argument_list|,
name|class_support
argument_list|,
name|pagination_on_command
argument_list|,
literal|"Enable pagination"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sm"
argument_list|,
name|class_support
argument_list|,
name|pagination_off_command
argument_list|,
literal|"Disable pagination"
argument_list|)
expr_stmt|;
block|}
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"sevenbit-strings"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sevenbit_strings
argument_list|,
literal|"Set printing of 8-bit characters in strings as \\nnn."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"asm-demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|asm_demangle
argument_list|,
literal|"Set demangling of C++/ObjC names in disassembly listings."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Machine specific function to handle SIGWINCH signal. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH_HANDLER_BODY
end_ifdef

begin_function
name|SIGWINCH_HANDLER_BODY
endif|#
directive|endif
comment|/* print routines to handle variable size regs, etc. */
comment|/* temporary storage using circular buffer */
define|#
directive|define
name|NUMCELLS
value|16
define|#
directive|define
name|CELLSIZE
value|32
specifier|static
name|char
modifier|*
name|get_cell
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
name|NUMCELLS
index|]
index|[
name|CELLSIZE
index|]
decl_stmt|;
specifier|static
name|int
name|cell
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|++
name|cell
operator|>=
name|NUMCELLS
condition|)
name|cell
operator|=
literal|0
expr_stmt|;
return|return
name|buf
index|[
name|cell
index|]
return|;
block|}
end_function

begin_function
name|int
name|strlen_paddr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|TARGET_ADDR_BIT
operator|/
literal|8
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|paddr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
name|phex
argument_list|(
name|addr
argument_list|,
name|TARGET_ADDR_BIT
operator|/
literal|8
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|paddr_nz
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
name|phex_nz
argument_list|(
name|addr
argument_list|,
name|TARGET_ADDR_BIT
operator|/
literal|8
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|decimal2str
parameter_list|(
name|char
modifier|*
name|paddr_str
parameter_list|,
name|char
modifier|*
name|sign
parameter_list|,
name|ULONGEST
name|addr
parameter_list|)
block|{
comment|/* steal code from valprint.c:print_decimal().  Should this worry      about the real size of addr as the above does? */
name|unsigned
name|long
name|temp
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|temp
index|[
name|i
index|]
operator|=
name|addr
operator|%
operator|(
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
name|addr
operator|/=
operator|(
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|addr
operator|!=
literal|0
operator|&&
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
do|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%s%lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%s%lu%09lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%s%lu%09lu%09lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|2
index|]
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|paddr_u
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|paddr_str
init|=
name|get_cell
argument_list|()
decl_stmt|;
name|decimal2str
argument_list|(
name|paddr_str
argument_list|,
literal|""
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|paddr_str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|paddr_d
parameter_list|(
name|LONGEST
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|paddr_str
init|=
name|get_cell
argument_list|()
decl_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
name|decimal2str
argument_list|(
name|paddr_str
argument_list|,
literal|"-"
argument_list|,
operator|-
name|addr
argument_list|)
expr_stmt|;
else|else
name|decimal2str
argument_list|(
name|paddr_str
argument_list|,
literal|""
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|paddr_str
return|;
block|}
end_function

begin_comment
comment|/* eliminate warning from compiler on 32-bit systems */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thirty_two
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|phex
parameter_list|(
name|ULONGEST
name|l
parameter_list|,
name|int
name|sizeof_l
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|sizeof_l
condition|)
block|{
case|case
literal|8
case|:
name|str
operator|=
name|get_cell
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%08lx%08lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|l
operator|>>
name|thirty_two
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|l
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|str
operator|=
name|get_cell
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|str
operator|=
name|get_cell
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%04x"
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|l
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|str
operator|=
name|phex
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|phex_nz
parameter_list|(
name|ULONGEST
name|l
parameter_list|,
name|int
name|sizeof_l
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|sizeof_l
condition|)
block|{
case|case
literal|8
case|:
block|{
name|unsigned
name|long
name|high
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|l
operator|>>
name|thirty_two
argument_list|)
decl_stmt|;
name|str
operator|=
name|get_cell
argument_list|()
expr_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|l
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%lx%08lx"
argument_list|,
name|high
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|l
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|4
case|:
name|str
operator|=
name|get_cell
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|str
operator|=
name|get_cell
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%x"
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|l
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|str
operator|=
name|phex_nz
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Convert a CORE_ADDR into a string.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|core_addr_to_string
parameter_list|(
specifier|const
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|get_cell
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|phex
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|core_addr_to_string_nz
parameter_list|(
specifier|const
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|get_cell
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|phex_nz
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Convert a string back into a CORE_ADDR.  */
end_comment

begin_function
name|CORE_ADDR
name|string_to_core_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|my_string
parameter_list|)
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|my_string
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|tolower
argument_list|(
name|my_string
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'x'
condition|)
block|{
comment|/* Assume that it is in decimal.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|my_string
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|my_string
index|[
name|i
index|]
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|my_string
index|[
name|i
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|addr
operator|*
literal|16
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
name|my_string
index|[
name|i
index|]
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|tolower
argument_list|(
name|my_string
index|[
name|i
index|]
argument_list|)
operator|-
literal|'a'
operator|+
literal|0xa
operator|)
operator|+
operator|(
name|addr
operator|*
literal|16
operator|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid hex"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Assume that it is in decimal.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|my_string
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|my_string
index|[
name|i
index|]
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|my_string
index|[
name|i
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|addr
operator|*
literal|10
operator|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid decimal"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|addr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gdb_realpath
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
comment|/* Method 1: The system has a compile time upper bound on a filename      path.  Use that and realpath() to canonicalize the name.  This is      the most common case.  Note that, if there isn't a compile time      upper bound, you want to avoid realpath() at all costs.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_REALPATH
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
define|#
directive|define
name|USE_REALPATH
elif|#
directive|elif
name|defined
argument_list|(
name|MAXPATHLEN
argument_list|)
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
define|#
directive|define
name|USE_REALPATH
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_REALPATH
argument_list|)
specifier|const
name|char
modifier|*
name|rp
init|=
name|realpath
argument_list|(
name|filename
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
name|rp
operator|=
name|filename
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|rp
argument_list|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* HAVE_REALPATH */
comment|/* Method 2: The host system (i.e., GNU) has the function      canonicalize_file_name() which malloc's a chunk of memory and      returns that, use that.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CANONICALIZE_FILE_NAME
argument_list|)
block|{
name|char
modifier|*
name|rp
init|=
name|canonicalize_file_name
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
name|xstrdup
argument_list|(
name|filename
argument_list|)
return|;
else|else
return|return
name|rp
return|;
block|}
endif|#
directive|endif
comment|/* FIXME: cagney/2002-11-13:       Method 2a: Use realpath() with a NULL buffer.  Some systems, due      to the problems described in in method 3, have modified their      realpath() implementation so that it will allocate a buffer when      NULL is passed in.  Before this can be used, though, some sort of      configure time test would need to be added.  Otherwize the code      will likely core dump.  */
comment|/* Method 3: Now we're getting desperate!  The system doesn't have a      compile time buffer size and no alternative function.  Query the      OS, using pathconf(), for the buffer limit.  Care is needed      though, some systems do not limit PATH_MAX (return -1 for      pathconf()) making it impossible to pass a correctly sized buffer      to realpath() (it could always overflow).  On those systems, we      skip this.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_REALPATH
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_ALLOCA
argument_list|)
block|{
comment|/* Find out the max path size.  */
name|long
name|path_max
init|=
name|pathconf
argument_list|(
literal|"/"
argument_list|,
name|_PC_PATH_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
name|path_max
operator|>
literal|0
condition|)
block|{
comment|/* PATH_MAX is bounded.  */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|path_max
argument_list|)
decl_stmt|;
name|char
modifier|*
name|rp
init|=
name|realpath
argument_list|(
name|filename
argument_list|,
name|buf
argument_list|)
decl_stmt|;
return|return
name|xstrdup
argument_list|(
name|rp
condition|?
name|rp
else|:
name|filename
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* This system is a lost cause, just dup the buffer.  */
return|return
name|xstrdup
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of FILENAME, with its directory prefix canonicalized    by gdb_realpath.  */
end_comment

begin_function
name|char
modifier|*
name|xfullpath
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_name
init|=
name|lbasename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dir_name
decl_stmt|;
name|char
modifier|*
name|real_path
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Extract the basename of filename, and return immediately       a copy of filename if it does not contain any directory prefix. */
if|if
condition|(
name|base_name
operator|==
name|filename
condition|)
return|return
name|xstrdup
argument_list|(
name|filename
argument_list|)
return|;
name|dir_name
operator|=
name|alloca
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|base_name
operator|-
name|filename
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate enough space to store the dir_name + plus one extra      character sometimes needed under Windows (see below), and      then the closing \000 character */
name|strncpy
argument_list|(
name|dir_name
argument_list|,
name|filename
argument_list|,
name|base_name
operator|-
name|filename
argument_list|)
expr_stmt|;
name|dir_name
index|[
name|base_name
operator|-
name|filename
index|]
operator|=
literal|'\000'
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* We need to be careful when filename is of the form 'd:foo', which      is equivalent of d:./foo, which is totally different from d:/foo.  */
if|if
condition|(
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|==
literal|2
operator|&&
name|isalpha
argument_list|(
name|dir_name
index|[
literal|0
index|]
argument_list|)
operator|&&
name|dir_name
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|dir_name
index|[
literal|2
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir_name
index|[
literal|3
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Canonicalize the directory prefix, and build the resulting      filename. If the dirname realpath already contains an ending      directory separator, avoid doubling it.  */
name|real_path
operator|=
name|gdb_realpath
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|real_path
index|[
name|strlen
argument_list|(
name|real_path
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|result
operator|=
name|concat
argument_list|(
name|real_path
argument_list|,
name|base_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|concat
argument_list|(
name|real_path
argument_list|,
name|SLASH_STRING
argument_list|,
name|base_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|real_path
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This is the 32-bit CRC function used by the GNU separate debug    facility.  An executable may contain a section named    .gnu_debuglink, which holds the name of a separate executable file    containing its debug info, and a checksum of that file's contents,    computed using this function.  */
end_comment

begin_function
name|unsigned
name|long
name|gnu_debuglink_crc32
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|long
name|crc32_table
index|[
literal|256
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x77073096
block|,
literal|0xee0e612c
block|,
literal|0x990951ba
block|,
literal|0x076dc419
block|,
literal|0x706af48f
block|,
literal|0xe963a535
block|,
literal|0x9e6495a3
block|,
literal|0x0edb8832
block|,
literal|0x79dcb8a4
block|,
literal|0xe0d5e91e
block|,
literal|0x97d2d988
block|,
literal|0x09b64c2b
block|,
literal|0x7eb17cbd
block|,
literal|0xe7b82d07
block|,
literal|0x90bf1d91
block|,
literal|0x1db71064
block|,
literal|0x6ab020f2
block|,
literal|0xf3b97148
block|,
literal|0x84be41de
block|,
literal|0x1adad47d
block|,
literal|0x6ddde4eb
block|,
literal|0xf4d4b551
block|,
literal|0x83d385c7
block|,
literal|0x136c9856
block|,
literal|0x646ba8c0
block|,
literal|0xfd62f97a
block|,
literal|0x8a65c9ec
block|,
literal|0x14015c4f
block|,
literal|0x63066cd9
block|,
literal|0xfa0f3d63
block|,
literal|0x8d080df5
block|,
literal|0x3b6e20c8
block|,
literal|0x4c69105e
block|,
literal|0xd56041e4
block|,
literal|0xa2677172
block|,
literal|0x3c03e4d1
block|,
literal|0x4b04d447
block|,
literal|0xd20d85fd
block|,
literal|0xa50ab56b
block|,
literal|0x35b5a8fa
block|,
literal|0x42b2986c
block|,
literal|0xdbbbc9d6
block|,
literal|0xacbcf940
block|,
literal|0x32d86ce3
block|,
literal|0x45df5c75
block|,
literal|0xdcd60dcf
block|,
literal|0xabd13d59
block|,
literal|0x26d930ac
block|,
literal|0x51de003a
block|,
literal|0xc8d75180
block|,
literal|0xbfd06116
block|,
literal|0x21b4f4b5
block|,
literal|0x56b3c423
block|,
literal|0xcfba9599
block|,
literal|0xb8bda50f
block|,
literal|0x2802b89e
block|,
literal|0x5f058808
block|,
literal|0xc60cd9b2
block|,
literal|0xb10be924
block|,
literal|0x2f6f7c87
block|,
literal|0x58684c11
block|,
literal|0xc1611dab
block|,
literal|0xb6662d3d
block|,
literal|0x76dc4190
block|,
literal|0x01db7106
block|,
literal|0x98d220bc
block|,
literal|0xefd5102a
block|,
literal|0x71b18589
block|,
literal|0x06b6b51f
block|,
literal|0x9fbfe4a5
block|,
literal|0xe8b8d433
block|,
literal|0x7807c9a2
block|,
literal|0x0f00f934
block|,
literal|0x9609a88e
block|,
literal|0xe10e9818
block|,
literal|0x7f6a0dbb
block|,
literal|0x086d3d2d
block|,
literal|0x91646c97
block|,
literal|0xe6635c01
block|,
literal|0x6b6b51f4
block|,
literal|0x1c6c6162
block|,
literal|0x856530d8
block|,
literal|0xf262004e
block|,
literal|0x6c0695ed
block|,
literal|0x1b01a57b
block|,
literal|0x8208f4c1
block|,
literal|0xf50fc457
block|,
literal|0x65b0d9c6
block|,
literal|0x12b7e950
block|,
literal|0x8bbeb8ea
block|,
literal|0xfcb9887c
block|,
literal|0x62dd1ddf
block|,
literal|0x15da2d49
block|,
literal|0x8cd37cf3
block|,
literal|0xfbd44c65
block|,
literal|0x4db26158
block|,
literal|0x3ab551ce
block|,
literal|0xa3bc0074
block|,
literal|0xd4bb30e2
block|,
literal|0x4adfa541
block|,
literal|0x3dd895d7
block|,
literal|0xa4d1c46d
block|,
literal|0xd3d6f4fb
block|,
literal|0x4369e96a
block|,
literal|0x346ed9fc
block|,
literal|0xad678846
block|,
literal|0xda60b8d0
block|,
literal|0x44042d73
block|,
literal|0x33031de5
block|,
literal|0xaa0a4c5f
block|,
literal|0xdd0d7cc9
block|,
literal|0x5005713c
block|,
literal|0x270241aa
block|,
literal|0xbe0b1010
block|,
literal|0xc90c2086
block|,
literal|0x5768b525
block|,
literal|0x206f85b3
block|,
literal|0xb966d409
block|,
literal|0xce61e49f
block|,
literal|0x5edef90e
block|,
literal|0x29d9c998
block|,
literal|0xb0d09822
block|,
literal|0xc7d7a8b4
block|,
literal|0x59b33d17
block|,
literal|0x2eb40d81
block|,
literal|0xb7bd5c3b
block|,
literal|0xc0ba6cad
block|,
literal|0xedb88320
block|,
literal|0x9abfb3b6
block|,
literal|0x03b6e20c
block|,
literal|0x74b1d29a
block|,
literal|0xead54739
block|,
literal|0x9dd277af
block|,
literal|0x04db2615
block|,
literal|0x73dc1683
block|,
literal|0xe3630b12
block|,
literal|0x94643b84
block|,
literal|0x0d6d6a3e
block|,
literal|0x7a6a5aa8
block|,
literal|0xe40ecf0b
block|,
literal|0x9309ff9d
block|,
literal|0x0a00ae27
block|,
literal|0x7d079eb1
block|,
literal|0xf00f9344
block|,
literal|0x8708a3d2
block|,
literal|0x1e01f268
block|,
literal|0x6906c2fe
block|,
literal|0xf762575d
block|,
literal|0x806567cb
block|,
literal|0x196c3671
block|,
literal|0x6e6b06e7
block|,
literal|0xfed41b76
block|,
literal|0x89d32be0
block|,
literal|0x10da7a5a
block|,
literal|0x67dd4acc
block|,
literal|0xf9b9df6f
block|,
literal|0x8ebeeff9
block|,
literal|0x17b7be43
block|,
literal|0x60b08ed5
block|,
literal|0xd6d6a3e8
block|,
literal|0xa1d1937e
block|,
literal|0x38d8c2c4
block|,
literal|0x4fdff252
block|,
literal|0xd1bb67f1
block|,
literal|0xa6bc5767
block|,
literal|0x3fb506dd
block|,
literal|0x48b2364b
block|,
literal|0xd80d2bda
block|,
literal|0xaf0a1b4c
block|,
literal|0x36034af6
block|,
literal|0x41047a60
block|,
literal|0xdf60efc3
block|,
literal|0xa867df55
block|,
literal|0x316e8eef
block|,
literal|0x4669be79
block|,
literal|0xcb61b38c
block|,
literal|0xbc66831a
block|,
literal|0x256fd2a0
block|,
literal|0x5268e236
block|,
literal|0xcc0c7795
block|,
literal|0xbb0b4703
block|,
literal|0x220216b9
block|,
literal|0x5505262f
block|,
literal|0xc5ba3bbe
block|,
literal|0xb2bd0b28
block|,
literal|0x2bb45a92
block|,
literal|0x5cb36a04
block|,
literal|0xc2d7ffa7
block|,
literal|0xb5d0cf31
block|,
literal|0x2cd99e8b
block|,
literal|0x5bdeae1d
block|,
literal|0x9b64c2b0
block|,
literal|0xec63f226
block|,
literal|0x756aa39c
block|,
literal|0x026d930a
block|,
literal|0x9c0906a9
block|,
literal|0xeb0e363f
block|,
literal|0x72076785
block|,
literal|0x05005713
block|,
literal|0x95bf4a82
block|,
literal|0xe2b87a14
block|,
literal|0x7bb12bae
block|,
literal|0x0cb61b38
block|,
literal|0x92d28e9b
block|,
literal|0xe5d5be0d
block|,
literal|0x7cdcefb7
block|,
literal|0x0bdbdf21
block|,
literal|0x86d3d2d4
block|,
literal|0xf1d4e242
block|,
literal|0x68ddb3f8
block|,
literal|0x1fda836e
block|,
literal|0x81be16cd
block|,
literal|0xf6b9265b
block|,
literal|0x6fb077e1
block|,
literal|0x18b74777
block|,
literal|0x88085ae6
block|,
literal|0xff0f6a70
block|,
literal|0x66063bca
block|,
literal|0x11010b5c
block|,
literal|0x8f659eff
block|,
literal|0xf862ae69
block|,
literal|0x616bffd3
block|,
literal|0x166ccf45
block|,
literal|0xa00ae278
block|,
literal|0xd70dd2ee
block|,
literal|0x4e048354
block|,
literal|0x3903b3c2
block|,
literal|0xa7672661
block|,
literal|0xd06016f7
block|,
literal|0x4969474d
block|,
literal|0x3e6e77db
block|,
literal|0xaed16a4a
block|,
literal|0xd9d65adc
block|,
literal|0x40df0b66
block|,
literal|0x37d83bf0
block|,
literal|0xa9bcae53
block|,
literal|0xdebb9ec5
block|,
literal|0x47b2cf7f
block|,
literal|0x30b5ffe9
block|,
literal|0xbdbdf21c
block|,
literal|0xcabac28a
block|,
literal|0x53b39330
block|,
literal|0x24b4a3a6
block|,
literal|0xbad03605
block|,
literal|0xcdd70693
block|,
literal|0x54de5729
block|,
literal|0x23d967bf
block|,
literal|0xb3667a2e
block|,
literal|0xc4614ab8
block|,
literal|0x5d681b02
block|,
literal|0x2a6f2b94
block|,
literal|0xb40bbe37
block|,
literal|0xc30c8ea1
block|,
literal|0x5a05df1b
block|,
literal|0x2d02ef8d
block|}
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|crc
operator|=
operator|~
name|crc
operator|&
literal|0xffffffff
expr_stmt|;
for|for
control|(
name|end
operator|=
name|buf
operator|+
name|len
init|;
name|buf
operator|<
name|end
condition|;
operator|++
name|buf
control|)
name|crc
operator|=
name|crc32_table
index|[
operator|(
name|crc
operator|^
operator|*
name|buf
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
return|return
operator|~
name|crc
operator|&
literal|0xffffffff
return|;
empty_stmt|;
block|}
end_function

begin_function
name|ULONGEST
name|align_up
parameter_list|(
name|ULONGEST
name|v
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Check that N is really a power of two.  */
name|gdb_assert
argument_list|(
name|n
operator|&&
operator|(
name|n
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|+
name|n
operator|-
literal|1
operator|)
operator|&
operator|-
name|n
return|;
block|}
end_function

begin_function
name|ULONGEST
name|align_down
parameter_list|(
name|ULONGEST
name|v
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Check that N is really a power of two.  */
name|gdb_assert
argument_list|(
name|n
operator|&&
operator|(
name|n
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|&
operator|-
name|n
operator|)
return|;
block|}
end_function

end_unit

