begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for MIPS systems running NetBSD.    Copyright 2002, 2003 Free Software Foundation, Inc.    Contributed by Wasabi Systems, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"nbsd-tdep.h"
end_include

begin_include
include|#
directive|include
file|"mipsnbsd-tdep.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_comment
comment|/* Conveniently, GDB uses the same register numbering as the    ptrace register structure used by NetBSD/mips.  */
end_comment

begin_function
name|void
name|mipsnbsd_supply_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PC_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|mipsnbsd_fill_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PC_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|!
name|CANNOT_STORE_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mipsnbsd_supply_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_implementation_revision
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|i
argument_list|,
name|fpregs
operator|+
operator|(
operator|(
name|i
operator|-
name|FP0_REGNUM
operator|)
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|mipsnbsd_fill_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_control_status
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|!
name|CANNOT_STORE_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|fpregs
operator|+
operator|(
operator|(
name|i
operator|-
name|FP0_REGNUM
operator|)
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|ignore
parameter_list|)
block|{
name|char
modifier|*
name|regs
decl_stmt|,
modifier|*
name|fpregs
decl_stmt|;
comment|/* We get everything from one section.  */
if|if
condition|(
name|which
operator|!=
literal|0
condition|)
return|return;
name|regs
operator|=
name|core_reg_sect
expr_stmt|;
name|fpregs
operator|=
name|core_reg_sect
operator|+
name|SIZEOF_STRUCT_REG
expr_stmt|;
comment|/* Integer registers.  */
name|mipsnbsd_supply_reg
argument_list|(
name|regs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Floating point registers.  */
name|mipsnbsd_supply_fpreg
argument_list|(
name|fpregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_elfcore_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|ignore
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
comment|/* Integer registers.  */
if|if
condition|(
name|core_reg_size
operator|!=
name|SIZEOF_STRUCT_REG
condition|)
name|warning
argument_list|(
literal|"Wrong size register set in core file."
argument_list|)
expr_stmt|;
else|else
name|mipsnbsd_supply_reg
argument_list|(
name|core_reg_sect
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Floating point registers.  */
if|if
condition|(
name|core_reg_size
operator|!=
name|SIZEOF_STRUCT_FPREG
condition|)
name|warning
argument_list|(
literal|"Wrong size register set in core file."
argument_list|)
expr_stmt|;
else|else
name|mipsnbsd_supply_fpreg
argument_list|(
name|core_reg_sect
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Don't know what kind of register request this is; just ignore it.  */
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|mipsnbsd_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|mipsnbsd_elfcore_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_elfcore_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Under NetBSD/mips, signal handler invocations can be identified by the    designated code sequence that is used to return from a signal handler.    In particular, the return address of a signal handler points to the    following code sequence:  	addu	a0, sp, 16 	li	v0, 295			# __sigreturn14 	syscall        Each instruction has a unique encoding, so we simply attempt to match    the instruction the PC is pointing to with any of the above instructions.    If there is a hit, we know the offset to the start of the designated    sequence and can then check whether we really are executing in the    signal trampoline.  If not, -1 is returned, otherwise the offset from the    start of the return sequence is returned.  */
end_comment

begin_define
define|#
directive|define
name|RETCODE_NWORDS
value|3
end_define

begin_define
define|#
directive|define
name|RETCODE_SIZE
value|(RETCODE_NWORDS * 4)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|sigtramp_retcode_mipsel
index|[
name|RETCODE_SIZE
index|]
init|=
block|{
literal|0x10
block|,
literal|0x00
block|,
literal|0xa4
block|,
literal|0x27
block|,
comment|/* addu a0, sp, 16 */
literal|0x27
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x24
block|,
comment|/* li v0, 295 */
literal|0x0c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* syscall */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|sigtramp_retcode_mipseb
index|[
name|RETCODE_SIZE
index|]
init|=
block|{
literal|0x27
block|,
literal|0xa4
block|,
literal|0x00
block|,
literal|0x10
block|,
comment|/* addu a0, sp, 16 */
literal|0x24
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x27
block|,
comment|/* li v0, 295 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0c
block|,
comment|/* syscall */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|LONGEST
name|mipsnbsd_sigtramp_offset
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|retcode
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|sigtramp_retcode_mipseb
else|:
name|sigtramp_retcode_mipsel
decl_stmt|;
name|unsigned
name|char
name|ret
index|[
name|RETCODE_SIZE
index|]
decl_stmt|,
name|w
index|[
literal|4
index|]
decl_stmt|;
name|LONGEST
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RETCODE_NWORDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|w
argument_list|,
name|retcode
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|RETCODE_NWORDS
condition|)
return|return
operator|-
literal|1
return|;
name|off
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|pc
operator|-=
name|off
expr_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|ret
argument_list|,
name|retcode
argument_list|,
name|RETCODE_SIZE
argument_list|)
operator|==
literal|0
condition|)
return|return
name|off
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mipsnbsd_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|func_name
parameter_list|)
block|{
return|return
operator|(
name|nbsd_pc_in_sigtramp
argument_list|(
name|pc
argument_list|,
name|func_name
argument_list|)
operator|||
name|mipsnbsd_sigtramp_offset
argument_list|(
name|pc
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Figure out where the longjmp will land.  We expect that we have    just entered longjmp and haven't yet setup the stack frame, so    the args are still in the argument regs.  A0_REGNUM points at the    jmp_buf structure from which we extract the PC that we will land    at.  The PC is copied into *pc.  This routine returns true on    success.  */
end_comment

begin_define
define|#
directive|define
name|NBSD_MIPS_JB_PC
value|(2 * 4)
end_define

begin_define
define|#
directive|define
name|NBSD_MIPS_JB_ELEMENT_SIZE
value|mips_regsize (current_gdbarch)
end_define

begin_define
define|#
directive|define
name|NBSD_MIPS_JB_OFFSET
value|(NBSD_MIPS_JB_PC * \ 					 NBSD_MIPS_JB_ELEMENT_SIZE)
end_define

begin_function
specifier|static
name|int
name|mipsnbsd_get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|NBSD_MIPS_JB_ELEMENT_SIZE
argument_list|)
expr_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|NBSD_MIPS_JB_OFFSET
argument_list|,
name|buf
argument_list|,
name|NBSD_MIPS_JB_ELEMENT_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|NBSD_MIPS_JB_ELEMENT_SIZE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mipsnbsd_cannot_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|==
name|ZERO_REGNUM
operator|||
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_implementation_revision
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mipsnbsd_cannot_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|==
name|ZERO_REGNUM
operator|||
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_implementation_revision
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NetBSD/mips uses a slightly different link_map structure from the    other NetBSD platforms.  */
end_comment

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|mipsnbsd_ilp32_solib_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|r_map_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|24
expr_stmt|;
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|20
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|mipsnbsd_lp64_solib_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|32
expr_stmt|;
name|lmo
operator|.
name|r_map_offset
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|48
expr_stmt|;
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|32
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|40
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|8
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipsnbsd_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|mipsnbsd_pc_in_sigtramp
argument_list|)
expr_stmt|;
name|set_gdbarch_get_longjmp_target
argument_list|(
name|gdbarch
argument_list|,
name|mipsnbsd_get_longjmp_target
argument_list|)
expr_stmt|;
name|set_gdbarch_cannot_fetch_register
argument_list|(
name|gdbarch
argument_list|,
name|mipsnbsd_cannot_fetch_register
argument_list|)
expr_stmt|;
name|set_gdbarch_cannot_store_register
argument_list|(
name|gdbarch
argument_list|,
name|mipsnbsd_cannot_store_register
argument_list|)
expr_stmt|;
name|set_gdbarch_software_single_step
argument_list|(
name|gdbarch
argument_list|,
name|mips_software_single_step
argument_list|)
expr_stmt|;
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|==
literal|32
condition|?
name|mipsnbsd_ilp32_solib_svr4_fetch_link_map_offsets
else|:
name|mipsnbsd_lp64_solib_svr4_fetch_link_map_offsets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_mipsnbsd_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_mips
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_NETBSD_ELF
argument_list|,
name|mipsnbsd_init_abi
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|mipsnbsd_core_fns
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|mipsnbsd_elfcore_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

