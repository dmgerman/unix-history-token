begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* TUI display locator.     Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     Contributed by Hewlett-Packard Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-stack.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-wingeneral.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-source.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-winsource.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-file.h"
end_include

begin_include
include|#
directive|include
file|"gdb_curses.h"
end_include

begin_comment
comment|/* Get a printable name for the function at the address.    The symbol name is demangled if demangling is turned on.    Returns a pointer to a static area holding the result.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|tui_get_function_from_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set the filename portion of the locator.  */
end_comment

begin_function_decl
specifier|static
name|void
name|tui_set_locator_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Update the locator, with the provided arguments.  */
end_comment

begin_function_decl
specifier|static
name|void
name|tui_set_locator_info
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|procname
parameter_list|,
name|int
name|lineno
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tui_update_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Create the status line to display as much information as we    can on this single line: target name, process number, current    function, current line, current PC, SingleKey mode.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tui_make_status_line
parameter_list|(
name|struct
name|tui_locator_element
modifier|*
name|loc
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|char
name|line_buf
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|pname
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|status_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|proc_width
decl_stmt|;
specifier|const
name|char
modifier|*
name|pid_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|pc_buf
decl_stmt|;
name|int
name|target_width
decl_stmt|;
name|int
name|pid_width
decl_stmt|;
name|int
name|line_width
decl_stmt|;
name|int
name|pc_width
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|pc_out
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
name|pid_name
operator|=
literal|"No process"
expr_stmt|;
else|else
name|pid_name
operator|=
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|target_width
operator|=
name|strlen
argument_list|(
name|target_shortname
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_width
operator|>
name|MAX_TARGET_WIDTH
condition|)
name|target_width
operator|=
name|MAX_TARGET_WIDTH
expr_stmt|;
name|pid_width
operator|=
name|strlen
argument_list|(
name|pid_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid_width
operator|>
name|MAX_PID_WIDTH
condition|)
name|pid_width
operator|=
name|MAX_PID_WIDTH
expr_stmt|;
name|status_size
operator|=
name|tui_term_width
argument_list|()
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|status_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|status_size
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Translate line number and obtain its size.  */
if|if
condition|(
name|loc
operator|->
name|line_no
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|line_buf
argument_list|,
literal|"%d"
argument_list|,
name|loc
operator|->
name|line_no
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|line_buf
argument_list|,
literal|"??"
argument_list|)
expr_stmt|;
name|line_width
operator|=
name|strlen
argument_list|(
name|line_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_width
operator|<
name|MIN_LINE_WIDTH
condition|)
name|line_width
operator|=
name|MIN_LINE_WIDTH
expr_stmt|;
comment|/* Translate PC address.  */
name|pc_out
operator|=
name|tui_sfileopen
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|loc
operator|->
name|addr
argument_list|,
literal|1
argument_list|,
name|pc_out
argument_list|)
expr_stmt|;
name|pc_buf
operator|=
name|tui_file_get_strbuf
argument_list|(
name|pc_out
argument_list|)
expr_stmt|;
name|pc_width
operator|=
name|strlen
argument_list|(
name|pc_buf
argument_list|)
expr_stmt|;
comment|/* First determine the amount of proc name width we have available.      The +1 are for a space separator between fields.      The -1 are to take into account the \0 counted by sizeof.  */
name|proc_width
operator|=
operator|(
name|status_size
operator|-
operator|(
name|target_width
operator|+
literal|1
operator|)
operator|-
operator|(
name|pid_width
operator|+
literal|1
operator|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|PROC_PREFIX
argument_list|)
operator|-
literal|1
operator|+
literal|1
operator|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|LINE_PREFIX
argument_list|)
operator|-
literal|1
operator|+
name|line_width
operator|+
literal|1
operator|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|PC_PREFIX
argument_list|)
operator|-
literal|1
operator|+
name|pc_width
operator|+
literal|1
operator|)
operator|-
operator|(
name|tui_current_key_mode
operator|==
name|TUI_SINGLE_KEY_MODE
condition|?
operator|(
sizeof|sizeof
argument_list|(
name|SINGLE_KEY
argument_list|)
operator|-
literal|1
operator|+
literal|1
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* If there is no room to print the function name, try by removing      some fields.  */
if|if
condition|(
name|proc_width
operator|<
name|MIN_PROC_WIDTH
condition|)
block|{
name|proc_width
operator|+=
name|target_width
operator|+
literal|1
expr_stmt|;
name|target_width
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc_width
operator|<
name|MIN_PROC_WIDTH
condition|)
block|{
name|proc_width
operator|+=
name|pid_width
operator|+
literal|1
expr_stmt|;
name|pid_width
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc_width
operator|<=
name|MIN_PROC_WIDTH
condition|)
block|{
name|proc_width
operator|+=
name|pc_width
operator|+
sizeof|sizeof
argument_list|(
name|PC_PREFIX
argument_list|)
operator|-
literal|1
operator|+
literal|1
expr_stmt|;
name|pc_width
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc_width
operator|<
literal|0
condition|)
block|{
name|proc_width
operator|+=
name|line_width
operator|+
sizeof|sizeof
argument_list|(
name|LINE_PREFIX
argument_list|)
operator|-
literal|1
operator|+
literal|1
expr_stmt|;
name|line_width
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc_width
operator|<
literal|0
condition|)
name|proc_width
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now convert elements to string form */
name|pname
operator|=
name|loc
operator|->
name|proc_name
expr_stmt|;
comment|/* Now create the locator line from the string version      of the elements.  We could use sprintf() here but      that wouldn't ensure that we don't overrun the size      of the allocated buffer.  strcat_to_buf() will.  */
operator|*
name|string
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|target_width
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%*.*s "
argument_list|,
operator|-
name|target_width
argument_list|,
name|target_width
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid_width
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%*.*s "
argument_list|,
operator|-
name|pid_width
argument_list|,
name|pid_width
argument_list|,
name|pid_name
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Show whether we are in SingleKey mode.  */
if|if
condition|(
name|tui_current_key_mode
operator|==
name|TUI_SINGLE_KEY_MODE
condition|)
block|{
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
name|SINGLE_KEY
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/* procedure/class name */
if|if
condition|(
name|proc_width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|pname
argument_list|)
operator|>
name|proc_width
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%*.*s* "
argument_list|,
name|PROC_PREFIX
argument_list|,
literal|1
operator|-
name|proc_width
argument_list|,
name|proc_width
operator|-
literal|1
argument_list|,
name|pname
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%*.*s "
argument_list|,
name|PROC_PREFIX
argument_list|,
operator|-
name|proc_width
argument_list|,
name|proc_width
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line_width
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%*.*s "
argument_list|,
name|LINE_PREFIX
argument_list|,
operator|-
name|line_width
argument_list|,
name|line_width
argument_list|,
name|line_buf
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pc_width
operator|>
literal|0
condition|)
block|{
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
name|PC_PREFIX
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|status_size
argument_list|,
name|pc_buf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
init|;
name|i
operator|<
name|status_size
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|string
index|[
name|status_size
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|ui_file_delete
argument_list|(
name|pc_out
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Get a printable name for the function at the address.    The symbol name is demangled if demangling is turned on.    Returns a pointer to a static area holding the result.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tui_get_function_from_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|stream
init|=
name|tui_sfileopen
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|print_address_symbolic
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|tui_file_get_strbuf
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* Use simple heuristics to isolate the function name.  The symbol can      be demangled and we can have function parameters.  Remove them because      the status line is too short to display them.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
name|p
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ui_file_delete
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|void
name|tui_show_locator_content
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|tui_gen_win_info
modifier|*
name|locator
decl_stmt|;
name|locator
operator|=
name|tui_locator_win_info_ptr
argument_list|()
expr_stmt|;
if|if
condition|(
name|locator
operator|!=
name|NULL
operator|&&
name|locator
operator|->
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|tui_win_element
modifier|*
name|element
decl_stmt|;
name|element
operator|=
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|tui_make_status_line
argument_list|(
operator|&
name|element
operator|->
name|which_element
operator|.
name|locator
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|locator
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wstandout
argument_list|(
name|locator
operator|->
name|handle
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|locator
operator|->
name|handle
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|locator
operator|->
name|handle
argument_list|)
expr_stmt|;
name|wstandend
argument_list|(
name|locator
operator|->
name|handle
argument_list|)
expr_stmt|;
name|tui_refresh_win
argument_list|(
name|locator
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|locator
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|locator
operator|->
name|content_in_use
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the filename portion of the locator.  */
end_comment

begin_function
specifier|static
name|void
name|tui_set_locator_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|locator
init|=
name|tui_locator_win_info_ptr
argument_list|()
decl_stmt|;
name|struct
name|tui_locator_element
modifier|*
name|element
decl_stmt|;
if|if
condition|(
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|tui_set_locator_info
argument_list|(
name|filename
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|element
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|locator
expr_stmt|;
name|element
operator|->
name|file_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|element
operator|->
name|file_name
argument_list|,
name|MAX_LOCATOR_ELEMENT_LEN
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the locator, with the provided arguments.  */
end_comment

begin_function
specifier|static
name|void
name|tui_set_locator_info
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|procname
parameter_list|,
name|int
name|lineno
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|locator
init|=
name|tui_locator_win_info_ptr
argument_list|()
decl_stmt|;
name|struct
name|tui_locator_element
modifier|*
name|element
decl_stmt|;
comment|/* Allocate the locator content if necessary.  */
if|if
condition|(
name|locator
operator|->
name|content_size
operator|<=
literal|0
condition|)
block|{
name|locator
operator|->
name|content
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|tui_alloc_content
argument_list|(
literal|1
argument_list|,
name|locator
operator|->
name|type
argument_list|)
expr_stmt|;
name|locator
operator|->
name|content_size
operator|=
literal|1
expr_stmt|;
block|}
name|element
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|locator
expr_stmt|;
name|element
operator|->
name|proc_name
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|element
operator|->
name|proc_name
argument_list|,
name|MAX_LOCATOR_ELEMENT_LEN
argument_list|,
name|procname
argument_list|)
expr_stmt|;
name|element
operator|->
name|line_no
operator|=
name|lineno
expr_stmt|;
name|element
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|tui_set_locator_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update only the filename portion of the locator.  */
end_comment

begin_function
name|void
name|tui_update_locator_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|tui_set_locator_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|tui_show_locator_content
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to print the frame information for the TUI.  */
end_comment

begin_function
name|void
name|tui_show_frame_info
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|tui_win_info
modifier|*
name|win_info
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fi
condition|)
block|{
name|int
name|start_line
decl_stmt|,
name|i
decl_stmt|;
name|CORE_ADDR
name|low
decl_stmt|;
name|struct
name|tui_gen_win_info
modifier|*
name|locator
init|=
name|tui_locator_win_info_ptr
argument_list|()
decl_stmt|;
name|int
name|source_already_displayed
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|find_frame_sal
argument_list|(
name|fi
argument_list|,
operator|&
name|sal
argument_list|)
expr_stmt|;
name|source_already_displayed
operator|=
name|sal
operator|.
name|symtab
operator|!=
literal|0
operator|&&
name|tui_source_is_displayed
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|tui_set_locator_info
argument_list|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|?
literal|"??"
else|:
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|tui_get_function_from_frame
argument_list|(
name|fi
argument_list|)
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
name|tui_show_locator_content
argument_list|()
expr_stmt|;
name|start_line
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tui_source_windows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|union
name|tui_which_element
modifier|*
name|item
decl_stmt|;
name|win_info
operator|=
operator|(
expr|struct
name|tui_win_info
operator|*
operator|)
operator|(
name|tui_source_windows
argument_list|()
operator|)
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
name|item
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
expr_stmt|;
if|if
condition|(
name|win_info
operator|==
name|TUI_SRC_WIN
condition|)
block|{
name|start_line
operator|=
operator|(
name|item
operator|->
name|locator
operator|.
name|line_no
operator|-
operator|(
name|win_info
operator|->
name|generic
operator|.
name|viewport_height
operator|/
literal|2
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|start_line
operator|<=
literal|0
condition|)
name|start_line
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|low
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No function contains program counter for selected frame.\n"
argument_list|)
expr_stmt|;
else|else
name|low
operator|=
name|tui_get_low_disassembly_address
argument_list|(
name|low
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|win_info
operator|==
name|TUI_SRC_WIN
condition|)
block|{
name|union
name|tui_line_or_address
name|l
decl_stmt|;
name|l
operator|.
name|line_no
operator|=
name|start_line
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|source_already_displayed
operator|&&
name|tui_line_is_displayed
argument_list|(
name|item
operator|->
name|locator
operator|.
name|line_no
argument_list|,
name|win_info
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
name|tui_update_source_window
argument_list|(
name|win_info
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|l
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
name|l
operator|.
name|line_no
operator|=
name|item
operator|->
name|locator
operator|.
name|line_no
expr_stmt|;
name|tui_set_is_exec_point_at
argument_list|(
name|l
argument_list|,
name|win_info
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|win_info
operator|==
name|TUI_DISASM_WIN
condition|)
block|{
name|union
name|tui_line_or_address
name|a
decl_stmt|;
name|a
operator|.
name|addr
operator|=
name|low
expr_stmt|;
if|if
condition|(
operator|!
name|tui_addr_is_displayed
argument_list|(
name|item
operator|->
name|locator
operator|.
name|addr
argument_list|,
name|win_info
argument_list|,
name|TRUE
argument_list|)
condition|)
name|tui_update_source_window
argument_list|(
name|win_info
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|a
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
name|a
operator|.
name|addr
operator|=
name|item
operator|->
name|locator
operator|.
name|addr
expr_stmt|;
name|tui_set_is_exec_point_at
argument_list|(
name|a
argument_list|,
name|win_info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|tui_update_exec_info
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tui_set_locator_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tui_show_locator_content
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tui_source_windows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|win_info
operator|=
operator|(
expr|struct
name|tui_win_info
operator|*
operator|)
operator|(
name|tui_source_windows
argument_list|()
operator|)
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
name|tui_clear_source_content
argument_list|(
name|win_info
argument_list|,
name|EMPTY_SOURCE_PROMPT
argument_list|)
expr_stmt|;
name|tui_update_exec_info
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Function to initialize gdb commands, for tui window stack    manipulation.  */
end_comment

begin_function
name|void
name|_initialize_tui_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|add_com
argument_list|(
literal|"update"
argument_list|,
name|class_tui
argument_list|,
name|tui_update_command
argument_list|,
literal|"Update the source window and locator to display the current "
literal|"execution point.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command to update the display with the current execution point.  */
end_comment

begin_function
specifier|static
name|void
name|tui_update_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
name|cmd
index|[
sizeof|sizeof
argument_list|(
literal|"frame 0"
argument_list|)
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
literal|"frame 0"
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

