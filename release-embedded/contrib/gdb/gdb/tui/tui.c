begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* General functions for the WDB TUI.     Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     Contributed by Hewlett-Packard Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-hooks.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-layout.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-io.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-regs.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-stack.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-win.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-winsource.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-windata.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERM_H
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"gdb_curses.h"
end_include

begin_comment
comment|/* This redefines CTRL if it is not already defined, so it must come    after terminal state releated include files like<term.h> and    "gdb_ncurses.h".  */
end_comment

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_comment
comment|/* Tells whether the TUI is active or not.  */
end_comment

begin_decl_stmt
name|int
name|tui_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tui_finish_init
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tui_key_mode
name|tui_current_key_mode
init|=
name|TUI_COMMAND_MODE
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tui_char_command
block|{
name|unsigned
name|char
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Key mapping to gdb commands when the TUI is using the single key mode.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tui_char_command
name|tui_commands
index|[]
init|=
block|{
block|{
literal|'c'
block|,
literal|"continue"
block|}
block|,
block|{
literal|'d'
block|,
literal|"down"
block|}
block|,
block|{
literal|'f'
block|,
literal|"finish"
block|}
block|,
block|{
literal|'n'
block|,
literal|"next"
block|}
block|,
block|{
literal|'r'
block|,
literal|"run"
block|}
block|,
block|{
literal|'s'
block|,
literal|"step"
block|}
block|,
block|{
literal|'u'
block|,
literal|"up"
block|}
block|,
block|{
literal|'v'
block|,
literal|"info locals"
block|}
block|,
block|{
literal|'w'
block|,
literal|"where"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Keymap
name|tui_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Keymap
name|tui_readline_standard_keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TUI readline command.    Switch the output mode between TUI/standard gdb.  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_switch_mode
parameter_list|(
name|int
name|notused1
parameter_list|,
name|int
name|notused2
parameter_list|)
block|{
if|if
condition|(
name|tui_active
condition|)
block|{
name|tui_disable
argument_list|()
expr_stmt|;
name|rl_prep_terminal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rl_deprep_terminal
argument_list|()
expr_stmt|;
name|tui_enable
argument_list|()
expr_stmt|;
block|}
comment|/* Clear the readline in case switching occurred in middle of something.  */
if|if
condition|(
name|rl_end
condition|)
name|rl_kill_text
argument_list|(
literal|0
argument_list|,
name|rl_end
argument_list|)
expr_stmt|;
comment|/* Since we left the curses mode, the terminal mode is restored to      some previous state.  That state may not be suitable for readline      to work correctly (it may be restored in line mode).  We force an      exit of the current readline so that readline is re-entered and it      will be able to setup the terminal for its needs.  By re-entering      in readline, we also redisplay its prompt in the non-curses mode.  */
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Make sure the \n we are returning does not repeat the last command.  */
name|dont_repeat
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TUI readline command.    Change the TUI layout to show a next layout.    This function is bound to CTRL-X 2.  It is intended to provide    a functionality close to the Emacs split-window command.  We always    show two windows (src+asm), (src+regs) or (asm+regs).  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_change_windows
parameter_list|(
name|int
name|notused1
parameter_list|,
name|int
name|notused2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tui_active
condition|)
name|tui_rl_switch_mode
argument_list|(
literal|0
comment|/*notused*/
argument_list|,
literal|0
comment|/*notused*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_active
condition|)
block|{
name|enum
name|tui_layout_type
name|new_layout
decl_stmt|;
name|enum
name|tui_register_display_type
name|regs_type
init|=
name|TUI_UNDEFINED_REGS
decl_stmt|;
name|new_layout
operator|=
name|tui_current_layout
argument_list|()
expr_stmt|;
comment|/* Select a new layout to have a rolling layout behavior 	 with always two windows (except when undefined).  */
switch|switch
condition|(
name|new_layout
condition|)
block|{
case|case
name|SRC_COMMAND
case|:
name|new_layout
operator|=
name|SRC_DISASSEM_COMMAND
expr_stmt|;
break|break;
case|case
name|DISASSEM_COMMAND
case|:
name|new_layout
operator|=
name|SRC_DISASSEM_COMMAND
expr_stmt|;
break|break;
case|case
name|SRC_DATA_COMMAND
case|:
name|new_layout
operator|=
name|SRC_DISASSEM_COMMAND
expr_stmt|;
break|break;
case|case
name|SRC_DISASSEM_COMMAND
case|:
name|new_layout
operator|=
name|DISASSEM_DATA_COMMAND
expr_stmt|;
break|break;
case|case
name|DISASSEM_DATA_COMMAND
case|:
name|new_layout
operator|=
name|SRC_DATA_COMMAND
expr_stmt|;
break|break;
default|default:
name|new_layout
operator|=
name|SRC_COMMAND
expr_stmt|;
break|break;
block|}
name|tui_set_layout
argument_list|(
name|new_layout
argument_list|,
name|regs_type
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TUI readline command.    Delete the second TUI window to only show one.  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_delete_other_windows
parameter_list|(
name|int
name|notused1
parameter_list|,
name|int
name|notused2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tui_active
condition|)
name|tui_rl_switch_mode
argument_list|(
literal|0
comment|/*notused*/
argument_list|,
literal|0
comment|/*notused*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_active
condition|)
block|{
name|enum
name|tui_layout_type
name|new_layout
decl_stmt|;
name|enum
name|tui_register_display_type
name|regs_type
init|=
name|TUI_UNDEFINED_REGS
decl_stmt|;
name|new_layout
operator|=
name|tui_current_layout
argument_list|()
expr_stmt|;
comment|/* Kill one window.  */
switch|switch
condition|(
name|new_layout
condition|)
block|{
case|case
name|SRC_COMMAND
case|:
case|case
name|SRC_DATA_COMMAND
case|:
case|case
name|SRC_DISASSEM_COMMAND
case|:
default|default:
name|new_layout
operator|=
name|SRC_COMMAND
expr_stmt|;
break|break;
case|case
name|DISASSEM_COMMAND
case|:
case|case
name|DISASSEM_DATA_COMMAND
case|:
name|new_layout
operator|=
name|DISASSEM_COMMAND
expr_stmt|;
break|break;
block|}
name|tui_set_layout
argument_list|(
name|new_layout
argument_list|,
name|regs_type
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TUI readline command.    Switch the active window to give the focus to a next window.  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_other_window
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|struct
name|tui_win_info
modifier|*
name|win_info
decl_stmt|;
if|if
condition|(
operator|!
name|tui_active
condition|)
name|tui_rl_switch_mode
argument_list|(
literal|0
comment|/*notused*/
argument_list|,
literal|0
comment|/*notused*/
argument_list|)
expr_stmt|;
name|win_info
operator|=
name|tui_next_win
argument_list|(
name|tui_win_with_focus
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|win_info
condition|)
block|{
name|tui_set_win_focus_to
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|TUI_DATA_WIN
operator|&&
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|is_visible
condition|)
name|tui_refresh_data_win
argument_list|()
expr_stmt|;
name|keypad
argument_list|(
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
argument_list|,
operator|(
name|win_info
operator|!=
name|TUI_CMD_WIN
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TUI readline command.    Execute the gdb command bound to the specified key.  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_command_key
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tui_commands
index|[
name|i
index|]
operator|.
name|cmd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tui_commands
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
condition|)
block|{
comment|/* Must save the command because it can be modified              by execute_command.  */
name|char
modifier|*
name|cmd
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tui_commands
index|[
name|i
index|]
operator|.
name|cmd
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|tui_commands
index|[
name|i
index|]
operator|.
name|cmd
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|cmd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TUI readline command.    Temporarily leave the TUI SingleKey mode to allow editing    a gdb command with the normal readline.  Once the command    is executed, the TUI SingleKey mode is installed back.  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_command_mode
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|tui_set_key_mode
argument_list|(
name|TUI_ONE_COMMAND_MODE
argument_list|)
expr_stmt|;
return|return
name|rl_insert
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* TUI readline command.    Switch between TUI SingleKey mode and gdb readline editing.  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_next_keymap
parameter_list|(
name|int
name|notused1
parameter_list|,
name|int
name|notused2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tui_active
condition|)
name|tui_rl_switch_mode
argument_list|(
literal|0
comment|/*notused*/
argument_list|,
literal|0
comment|/*notused*/
argument_list|)
expr_stmt|;
name|tui_set_key_mode
argument_list|(
name|tui_current_key_mode
operator|==
name|TUI_COMMAND_MODE
condition|?
name|TUI_SINGLE_KEY_MODE
else|:
name|TUI_COMMAND_MODE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Readline hook to redisplay ourself the gdb prompt.    In the SingleKey mode, the prompt is not printed so that    the command window is cleaner.  It will be displayed if    we temporarily leave the SingleKey mode.  */
end_comment

begin_function
specifier|static
name|int
name|tui_rl_startup_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|rl_already_prompted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tui_current_key_mode
operator|!=
name|TUI_COMMAND_MODE
condition|)
name|tui_set_key_mode
argument_list|(
name|TUI_SINGLE_KEY_MODE
argument_list|)
expr_stmt|;
name|tui_redisplay_readline
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Change the TUI key mode by installing the appropriate readline keymap.  */
end_comment

begin_function
name|void
name|tui_set_key_mode
parameter_list|(
name|enum
name|tui_key_mode
name|mode
parameter_list|)
block|{
name|tui_current_key_mode
operator|=
name|mode
expr_stmt|;
name|rl_set_keymap
argument_list|(
name|mode
operator|==
name|TUI_SINGLE_KEY_MODE
condition|?
name|tui_keymap
else|:
name|tui_readline_standard_keymap
argument_list|)
expr_stmt|;
name|tui_show_locator_content
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize readline and configure the keymap for the switching    key shortcut.  */
end_comment

begin_function
name|void
name|tui_initialize_readline
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Keymap
name|tui_ctlx_keymap
decl_stmt|;
name|rl_initialize
argument_list|()
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"tui-switch-mode"
argument_list|,
name|tui_rl_switch_mode
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"gdb-command"
argument_list|,
name|tui_rl_command_key
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"next-keymap"
argument_list|,
name|tui_rl_next_keymap
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tui_keymap
operator|=
name|rl_make_bare_keymap
argument_list|()
expr_stmt|;
name|tui_ctlx_keymap
operator|=
name|rl_make_bare_keymap
argument_list|()
expr_stmt|;
name|tui_readline_standard_keymap
operator|=
name|rl_get_keymap
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tui_commands
index|[
name|i
index|]
operator|.
name|cmd
condition|;
name|i
operator|++
control|)
name|rl_bind_key_in_map
argument_list|(
name|tui_commands
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|tui_rl_command_key
argument_list|,
name|tui_keymap
argument_list|)
expr_stmt|;
name|rl_generic_bind
argument_list|(
name|ISKMAP
argument_list|,
literal|"\\C-x"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tui_ctlx_keymap
argument_list|,
name|tui_keymap
argument_list|)
expr_stmt|;
comment|/* Bind all other keys to tui_rl_command_mode so that we switch      temporarily from SingleKey mode and can enter a gdb command.  */
for|for
control|(
name|i
operator|=
literal|' '
init|;
name|i
operator|<
literal|0x7f
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|tui_commands
index|[
name|j
index|]
operator|.
name|cmd
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|tui_commands
index|[
name|j
index|]
operator|.
name|key
operator|==
name|i
condition|)
break|break;
if|if
condition|(
name|tui_commands
index|[
name|j
index|]
operator|.
name|cmd
condition|)
continue|continue;
name|rl_bind_key_in_map
argument_list|(
name|i
argument_list|,
name|tui_rl_command_mode
argument_list|,
name|tui_keymap
argument_list|)
expr_stmt|;
block|}
name|rl_bind_key_in_map
argument_list|(
literal|'a'
argument_list|,
name|tui_rl_switch_mode
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'a'
argument_list|,
name|tui_rl_switch_mode
argument_list|,
name|tui_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'A'
argument_list|,
name|tui_rl_switch_mode
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'A'
argument_list|,
name|tui_rl_switch_mode
argument_list|,
name|tui_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
name|CTRL
argument_list|(
literal|'A'
argument_list|)
argument_list|,
name|tui_rl_switch_mode
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
name|CTRL
argument_list|(
literal|'A'
argument_list|)
argument_list|,
name|tui_rl_switch_mode
argument_list|,
name|tui_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'1'
argument_list|,
name|tui_rl_delete_other_windows
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'1'
argument_list|,
name|tui_rl_delete_other_windows
argument_list|,
name|tui_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'2'
argument_list|,
name|tui_rl_change_windows
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'2'
argument_list|,
name|tui_rl_change_windows
argument_list|,
name|tui_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'o'
argument_list|,
name|tui_rl_other_window
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'o'
argument_list|,
name|tui_rl_other_window
argument_list|,
name|tui_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'q'
argument_list|,
name|tui_rl_next_keymap
argument_list|,
name|tui_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'s'
argument_list|,
name|tui_rl_next_keymap
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'s'
argument_list|,
name|tui_rl_next_keymap
argument_list|,
name|tui_ctlx_keymap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter in the tui mode (curses).    When in normal mode, it installs the tui hooks in gdb, redirects    the gdb output, configures the readline to work in tui mode.    When in curses mode, it does nothing.  */
end_comment

begin_function
name|void
name|tui_enable
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|tui_active
condition|)
return|return;
comment|/* To avoid to initialize curses when gdb starts, there is a defered      curses initialization.  This initialization is made only once      and the first time the curses mode is entered.  */
if|if
condition|(
name|tui_finish_init
condition|)
block|{
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|w
operator|=
name|initscr
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
comment|/*timeout (1);*/
name|nodelay
argument_list|(
name|w
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
name|keypad
argument_list|(
name|w
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rl_initialize
argument_list|()
expr_stmt|;
name|tui_set_term_height_to
argument_list|(
name|LINES
argument_list|)
expr_stmt|;
name|tui_set_term_width_to
argument_list|(
name|COLS
argument_list|)
expr_stmt|;
name|def_prog_mode
argument_list|()
expr_stmt|;
name|tui_show_frame_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tui_set_layout
argument_list|(
name|SRC_COMMAND
argument_list|,
name|TUI_UNDEFINED_REGS
argument_list|)
expr_stmt|;
name|tui_set_win_focus_to
argument_list|(
name|TUI_SRC_WIN
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|tui_finish_init
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Save the current gdb setting of the terminal.         Curses will restore this state when endwin() is called.  */
name|def_shell_mode
argument_list|()
expr_stmt|;
name|clearok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Install the TUI specific hooks.  */
name|tui_install_hooks
argument_list|()
expr_stmt|;
name|rl_startup_hook
operator|=
name|tui_rl_startup_hook
expr_stmt|;
name|tui_update_variables
argument_list|()
expr_stmt|;
name|tui_setup_io
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tui_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|deprecated_selected_frame
condition|)
name|tui_show_frame_info
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
comment|/* Restore TUI keymap.  */
name|tui_set_key_mode
argument_list|(
name|tui_current_key_mode
argument_list|)
expr_stmt|;
name|tui_refresh_all_win
argument_list|()
expr_stmt|;
comment|/* Update gdb's knowledge of its terminal.  */
name|target_terminal_save_ours
argument_list|()
expr_stmt|;
name|tui_update_gdb_sizes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Leave the tui mode.    Remove the tui hooks and configure the gdb output and readline    back to their original state.  The curses mode is left so that    the terminal setting is restored to the point when we entered.  */
end_comment

begin_function
name|void
name|tui_disable
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tui_active
condition|)
return|return;
comment|/* Restore initial readline keymap.  */
name|rl_set_keymap
argument_list|(
name|tui_readline_standard_keymap
argument_list|)
expr_stmt|;
comment|/* Remove TUI hooks.  */
name|tui_remove_hooks
argument_list|()
expr_stmt|;
name|rl_startup_hook
operator|=
literal|0
expr_stmt|;
name|rl_already_prompted
operator|=
literal|0
expr_stmt|;
comment|/* Leave curses and restore previous gdb terminal setting.  */
name|endwin
argument_list|()
expr_stmt|;
comment|/* gdb terminal has changed, update gdb internal copy of it      so that terminal management with the inferior works.  */
name|tui_setup_io
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Update gdb's knowledge of its terminal.  */
name|target_terminal_save_ours
argument_list|()
expr_stmt|;
name|tui_active
operator|=
literal|0
expr_stmt|;
name|tui_update_gdb_sizes
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|strcat_to_buf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
specifier|const
name|char
modifier|*
name|item_to_add
parameter_list|)
block|{
if|if
condition|(
name|item_to_add
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|buf
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|item_to_add
argument_list|)
operator|)
operator|<=
name|buflen
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|item_to_add
argument_list|)
expr_stmt|;
else|else
name|strncat
argument_list|(
name|buf
argument_list|,
name|item_to_add
argument_list|,
operator|(
name|buflen
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Solaris<sys/termios.h> defines CTRL. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTRL
end_ifndef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|(x& ~0140)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FILEDES
value|2
end_define

begin_define
define|#
directive|define
name|CHK
parameter_list|(
name|val
parameter_list|,
name|dft
parameter_list|)
value|(val<=0 ? dft : val)
end_define

begin_comment
unit|static void tui_reset (void) {   struct termio mode;
comment|/*      ** reset the teletype mode bits to a sensible state.      ** Copied tset.c    */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
end_if

begin_endif
unit|struct tchars tbuf;
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USG&& TIOCGETC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UCB_NTTY
end_ifdef

begin_endif
unit|struct ltchars ltc;    if (ldisc == NTTYDISC)     {       ioctl (FILEDES, TIOCGLTC,&ltc);       ltc.t_suspc = CHK (ltc.t_suspc, CTRL ('Z'));       ltc.t_dsuspc = CHK (ltc.t_dsuspc, CTRL ('Y'));       ltc.t_rprntc = CHK (ltc.t_rprntc, CTRL ('R'));       ltc.t_flushc = CHK (ltc.t_flushc, CTRL ('O'));       ltc.t_werasc = CHK (ltc.t_werasc, CTRL ('W'));       ltc.t_lnextc = CHK (ltc.t_lnextc, CTRL ('V'));       ioctl (FILEDES, TIOCSLTC,&ltc);     }
endif|#
directive|endif
end_endif

begin_comment
comment|/* UCB_NTTY */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGETC
end_ifdef

begin_comment
unit|ioctl (FILEDES, TIOCGETC,&tbuf);   tbuf.t_intrc = CHK (tbuf.t_intrc, CTRL ('?'));   tbuf.t_quitc = CHK (tbuf.t_quitc, CTRL ('\\'));   tbuf.t_startc = CHK (tbuf.t_startc, CTRL ('Q'));   tbuf.t_stopc = CHK (tbuf.t_stopc, CTRL ('S'));   tbuf.t_eofc = CHK (tbuf.t_eofc, CTRL ('D'));
comment|/* brkc is left alone */
end_comment

begin_endif
unit|ioctl (FILEDES, TIOCSETC,&tbuf);
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGETC */
end_comment

begin_ifdef
unit|mode.sg_flags&= ~(RAW
ifdef|#
directive|ifdef
name|CBREAK
end_ifdef

begin_endif
unit|| CBREAK
endif|#
directive|endif
end_endif

begin_comment
comment|/* CBREAK */
end_comment

begin_else
unit|| VTDELAY | ALLDELAY);   mode.sg_flags |= XTABS | ECHO | CRMOD | ANYP;
else|#
directive|else
end_else

begin_comment
comment|/*USG */
end_comment

begin_ifndef
unit|ioctl (FILEDES, TCGETA,&mode);   mode.c_cc[VINTR] = CHK (mode.c_cc[VINTR], CTRL ('?'));   mode.c_cc[VQUIT] = CHK (mode.c_cc[VQUIT], CTRL ('\\'));   mode.c_cc[VEOF] = CHK (mode.c_cc[VEOF], CTRL ('D'));    mode.c_iflag&= ~(IGNBRK | PARMRK | INPCK | INLCR | IGNCR | IUCLC | IXOFF);   mode.c_iflag |= (BRKINT | ISTRIP | ICRNL | IXON);   mode.c_oflag&= ~(OLCUC | OCRNL | ONOCR | ONLRET | OFILL | OFDEL | 		    NLDLY | CRDLY | TABDLY | BSDLY | VTDLY | FFDLY);   mode.c_oflag |= (OPOST | ONLCR);   mode.c_cflag&= ~(CSIZE | PARODD | CLOCAL);
ifndef|#
directive|ifndef
name|hp9000s800
end_ifndef

begin_else
unit|mode.c_cflag |= (CS8 | CREAD);
else|#
directive|else
end_else

begin_comment
comment|/*hp9000s800 */
end_comment

begin_endif
unit|mode.c_cflag |= (CS8 | CSTOPB | CREAD);
endif|#
directive|endif
end_endif

begin_comment
comment|/* hp9000s800 */
end_comment

begin_endif
unit|mode.c_lflag&= ~(XCASE | ECHONL | NOFLSH);   mode.c_lflag |= (ISIG | ICANON | ECHO | ECHOK);   ioctl (FILEDES, TCSETAW,&mode);
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_endif
unit|return; }
endif|#
directive|endif
end_endif

begin_function
name|void
name|tui_show_source
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|cursal
init|=
name|get_current_source_symtab_and_line
argument_list|()
decl_stmt|;
comment|/* make sure that the source window is displayed */
name|tui_add_win_to_layout
argument_list|(
name|SRC_WIN
argument_list|)
expr_stmt|;
name|tui_update_source_windows_with_line
argument_list|(
name|cursal
operator|.
name|symtab
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|tui_update_locator_filename
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tui_show_assembly
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|tui_add_win_to_layout
argument_list|(
name|DISASSEM_WIN
argument_list|)
expr_stmt|;
name|tui_update_source_windows_with_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tui_is_window_visible
parameter_list|(
name|enum
name|tui_win_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|tui_active
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tui_win_list
index|[
name|type
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|tui_win_list
index|[
name|type
index|]
operator|->
name|generic
operator|.
name|is_visible
return|;
block|}
end_function

begin_function
name|int
name|tui_get_command_dimension
parameter_list|(
name|int
modifier|*
name|width
parameter_list|,
name|int
modifier|*
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tui_active
operator|||
operator|(
name|TUI_CMD_WIN
operator|==
name|NULL
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
operator|*
name|width
operator|=
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|width
expr_stmt|;
operator|*
name|height
operator|=
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|height
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

