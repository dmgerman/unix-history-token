begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing Fortran values for GDB, the GNU debugger.    Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2003    Free Software Foundation, Inc.    Contributed by Motorola.  Adapted from the C definitions by Farooq Butt    (fmbutt@engage.sps.mot.com), additionally worked over by Stan Shebs.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"f-lang.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int there_is_a_visible_common_named (char *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|_initialize_f_valprint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|info_common_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|list_all_visible_commons
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f77_print_array
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f77_print_array_1
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|,
name|int
modifier|*
name|elts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f77_create_arrayprint_offset_tbl
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f77_get_dynamic_length_of_aggregate
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|f77_array_offset_tbl
index|[
name|MAX_FORTRAN_DIMS
operator|+
literal|1
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array which holds offsets to be applied to get a row's elements    for a given array. Array also holds the size of each subarray.  */
end_comment

begin_comment
comment|/* The following macro gives us the size of the nth dimension, Where     n is 1 based. */
end_comment

begin_define
define|#
directive|define
name|F77_DIM_SIZE
parameter_list|(
name|n
parameter_list|)
value|(f77_array_offset_tbl[n][1])
end_define

begin_comment
comment|/* The following gives us the offset for row n where n is 1-based. */
end_comment

begin_define
define|#
directive|define
name|F77_DIM_OFFSET
parameter_list|(
name|n
parameter_list|)
value|(f77_array_offset_tbl[n][0])
end_define

begin_function
name|int
name|f77_get_dynamic_lowerbound
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|lower_bound
parameter_list|)
block|{
name|CORE_ADDR
name|current_frame_addr
decl_stmt|;
name|CORE_ADDR
name|ptr_to_lower_bound
decl_stmt|;
switch|switch
condition|(
name|TYPE_ARRAY_LOWER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|BOUND_BY_VALUE_ON_STACK
case|:
name|current_frame_addr
operator|=
name|get_frame_base
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_addr
operator|>
literal|0
condition|)
block|{
operator|*
name|lower_bound
operator|=
name|read_memory_integer
argument_list|(
name|current_frame_addr
operator|+
name|TYPE_ARRAY_LOWER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|lower_bound
operator|=
name|DEFAULT_LOWER_BOUND
expr_stmt|;
return|return
name|BOUND_FETCH_ERROR
return|;
block|}
break|break;
case|case
name|BOUND_SIMPLE
case|:
operator|*
name|lower_bound
operator|=
name|TYPE_ARRAY_LOWER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_CANNOT_BE_DETERMINED
case|:
name|error
argument_list|(
literal|"Lower bound may not be '*' in F77"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_BY_REF_ON_STACK
case|:
name|current_frame_addr
operator|=
name|get_frame_base
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_addr
operator|>
literal|0
condition|)
block|{
name|ptr_to_lower_bound
operator|=
name|read_memory_typed_address
argument_list|(
name|current_frame_addr
operator|+
name|TYPE_ARRAY_LOWER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
operator|*
name|lower_bound
operator|=
name|read_memory_integer
argument_list|(
name|ptr_to_lower_bound
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|lower_bound
operator|=
name|DEFAULT_LOWER_BOUND
expr_stmt|;
return|return
name|BOUND_FETCH_ERROR
return|;
block|}
break|break;
case|case
name|BOUND_BY_REF_IN_REG
case|:
case|case
name|BOUND_BY_VALUE_IN_REG
case|:
default|default:
name|error
argument_list|(
literal|"??? unhandled dynamic array bound type ???"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|BOUND_FETCH_OK
return|;
block|}
end_function

begin_function
name|int
name|f77_get_dynamic_upperbound
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|upper_bound
parameter_list|)
block|{
name|CORE_ADDR
name|current_frame_addr
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|ptr_to_upper_bound
decl_stmt|;
switch|switch
condition|(
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|BOUND_BY_VALUE_ON_STACK
case|:
name|current_frame_addr
operator|=
name|get_frame_base
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_addr
operator|>
literal|0
condition|)
block|{
operator|*
name|upper_bound
operator|=
name|read_memory_integer
argument_list|(
name|current_frame_addr
operator|+
name|TYPE_ARRAY_UPPER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|upper_bound
operator|=
name|DEFAULT_UPPER_BOUND
expr_stmt|;
return|return
name|BOUND_FETCH_ERROR
return|;
block|}
break|break;
case|case
name|BOUND_SIMPLE
case|:
operator|*
name|upper_bound
operator|=
name|TYPE_ARRAY_UPPER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_CANNOT_BE_DETERMINED
case|:
comment|/* we have an assumed size array on our hands. Assume that           upper_bound == lower_bound so that we show at least           1 element.If the user wants to see more elements, let           him manually ask for 'em and we'll subscript the           array and show him */
name|f77_get_dynamic_lowerbound
argument_list|(
name|type
argument_list|,
name|upper_bound
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_BY_REF_ON_STACK
case|:
name|current_frame_addr
operator|=
name|get_frame_base
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_addr
operator|>
literal|0
condition|)
block|{
name|ptr_to_upper_bound
operator|=
name|read_memory_typed_address
argument_list|(
name|current_frame_addr
operator|+
name|TYPE_ARRAY_UPPER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
operator|*
name|upper_bound
operator|=
name|read_memory_integer
argument_list|(
name|ptr_to_upper_bound
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|upper_bound
operator|=
name|DEFAULT_UPPER_BOUND
expr_stmt|;
return|return
name|BOUND_FETCH_ERROR
return|;
block|}
break|break;
case|case
name|BOUND_BY_REF_IN_REG
case|:
case|case
name|BOUND_BY_VALUE_IN_REG
case|:
default|default:
name|error
argument_list|(
literal|"??? unhandled dynamic array bound type ???"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|BOUND_FETCH_OK
return|;
block|}
end_function

begin_comment
comment|/* Obtain F77 adjustable array dimensions */
end_comment

begin_function
specifier|static
name|void
name|f77_get_dynamic_length_of_aggregate
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|upper_bound
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lower_bound
init|=
literal|1
decl_stmt|;
name|int
name|retcode
decl_stmt|;
comment|/* Recursively go all the way down into a possibly multi-dimensional      F77 array and get the bounds.  For simple arrays, this is pretty      easy but when the bounds are dynamic, we must be very careful       to add up all the lengths correctly.  Not doing this right       will lead to horrendous-looking arrays in parameter lists.       This function also works for strings which behave very       similarly to arrays.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRING
condition|)
name|f77_get_dynamic_length_of_aggregate
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recursion ends here, start setting up lengths.  */
name|retcode
operator|=
name|f77_get_dynamic_lowerbound
argument_list|(
name|type
argument_list|,
operator|&
name|lower_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain valid array lower bound"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|f77_get_dynamic_upperbound
argument_list|(
name|type
argument_list|,
operator|&
name|upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain valid array upper bound"
argument_list|)
expr_stmt|;
comment|/* Patch in a valid length value. */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|upper_bound
operator|-
name|lower_bound
operator|+
literal|1
operator|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function that sets up the array offset,size table for the array     type "type".  */
end_comment

begin_function
specifier|static
name|void
name|f77_create_arrayprint_offset_tbl
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
name|int
name|eltlen
decl_stmt|;
name|int
name|ndimen
init|=
literal|1
decl_stmt|;
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|,
name|retcode
decl_stmt|;
name|tmp_type
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|tmp_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|tmp_type
argument_list|)
operator|==
name|BOUND_CANNOT_BE_DETERMINED
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<assumed size array> "
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|f77_get_dynamic_upperbound
argument_list|(
name|tmp_type
argument_list|,
operator|&
name|upper
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain dynamic upper bound"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|f77_get_dynamic_lowerbound
argument_list|(
name|tmp_type
argument_list|,
operator|&
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain dynamic lower bound"
argument_list|)
expr_stmt|;
name|F77_DIM_SIZE
argument_list|(
name|ndimen
argument_list|)
operator|=
name|upper
operator|-
name|lower
operator|+
literal|1
expr_stmt|;
name|tmp_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|tmp_type
argument_list|)
expr_stmt|;
name|ndimen
operator|++
expr_stmt|;
block|}
comment|/* Now we multiply eltlen by all the offsets, so that later we       can print out array elements correctly.  Up till now we       know an offset to apply to get the item but we also       have to know how much to add to get to the next item */
name|ndimen
operator|--
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|tmp_type
argument_list|)
expr_stmt|;
name|F77_DIM_OFFSET
argument_list|(
name|ndimen
argument_list|)
operator|=
name|eltlen
expr_stmt|;
while|while
condition|(
operator|--
name|ndimen
operator|>
literal|0
condition|)
block|{
name|eltlen
operator|*=
name|F77_DIM_SIZE
argument_list|(
name|ndimen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|F77_DIM_OFFSET
argument_list|(
name|ndimen
argument_list|)
operator|=
name|eltlen
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Actual function which prints out F77 arrays, Valaddr == address in     the superior.  Address == the address in the inferior.  */
end_comment

begin_function
specifier|static
name|void
name|f77_print_array_1
parameter_list|(
name|int
name|nss
parameter_list|,
name|int
name|ndimensions
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|,
name|int
modifier|*
name|elts
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nss
operator|!=
name|ndimensions
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|F77_DIM_SIZE
argument_list|(
name|nss
argument_list|)
operator|&&
operator|(
operator|*
name|elts
operator|)
operator|<
name|print_max
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"( "
argument_list|)
expr_stmt|;
name|f77_print_array_1
argument_list|(
name|nss
operator|+
literal|1
argument_list|,
name|ndimensions
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|F77_DIM_OFFSET
argument_list|(
name|nss
argument_list|)
argument_list|,
name|address
operator|+
name|i
operator|*
name|F77_DIM_OFFSET
argument_list|(
name|nss
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|elts
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|elts
operator|>=
name|print_max
operator|&&
name|i
operator|<
name|F77_DIM_SIZE
argument_list|(
name|nss
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|F77_DIM_SIZE
argument_list|(
name|nss
argument_list|)
operator|&&
operator|(
operator|*
name|elts
operator|)
operator|<
name|print_max
condition|;
name|i
operator|++
operator|,
operator|(
operator|*
name|elts
operator|)
operator|++
control|)
block|{
name|val_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|F77_DIM_OFFSET
argument_list|(
name|ndimensions
argument_list|)
argument_list|,
literal|0
argument_list|,
name|address
operator|+
name|i
operator|*
name|F77_DIM_OFFSET
argument_list|(
name|ndimensions
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|F77_DIM_SIZE
argument_list|(
name|nss
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|elts
operator|==
name|print_max
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i
operator|!=
operator|(
name|F77_DIM_SIZE
argument_list|(
name|nss
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function gets called to print an F77 array, we set up some     stuff and then immediately call f77_print_array_1() */
end_comment

begin_function
specifier|static
name|void
name|f77_print_array
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|int
name|ndimensions
decl_stmt|;
name|int
name|elts
init|=
literal|0
decl_stmt|;
name|ndimensions
operator|=
name|calc_f77_array_dims
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndimensions
operator|>
name|MAX_FORTRAN_DIMS
operator|||
name|ndimensions
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Type node corrupt! F77 arrays cannot have %d subscripts (%d Max)"
argument_list|,
name|ndimensions
argument_list|,
name|MAX_FORTRAN_DIMS
argument_list|)
expr_stmt|;
comment|/* Since F77 arrays are stored column-major, we set up an       offset table to get at the various row's elements. The       offset table contains entries for both offset and subarray size. */
name|f77_create_arrayprint_offset_tbl
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|f77_print_array_1
argument_list|(
literal|1
argument_list|,
name|ndimensions
argument_list|,
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
operator|&
name|elts
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in    target byte order.     If the data are a string pointer, returns the number of string characters    printed.     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|f_val_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Number of characters printed */
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRING
case|:
name|f77_get_dynamic_length_of_aggregate
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|f77_print_array
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* Try to print what function it points to.  */
name|print_address_demangle
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addressprint
operator|&&
name|format
operator|!=
literal|'s'
condition|)
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* For a pointer to char or unsigned char, also print the string 	     pointed to, unless pointer is null.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
operator|&&
name|addr
operator|!=
literal|0
condition|)
name|i
operator|=
name|val_print_string
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Return number of characters printed, including the terminating 	     '\0' if we reached the end.  val_print_string takes care including 	     the terminating '\0' if necessary.  */
return|return
name|i
return|;
block|}
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|extract_typed_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|struct
name|value
modifier|*
name|deref_val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|common_val_print
argument_list|(
name|deref_val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FIXME, we should consider, at least for ANSI C language, eliminating          the distinction made between FUNCs and POINTERs to FUNCs.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
comment|/* Try to print what function it points to, and its address.  */
name|print_address_demangle
argument_list|(
name|address
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_INT
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* C and C++ has no single byte int type, char is used instead. 	     Since we don't know whether the value is really intended to 	     be used as an integer or a character, print the character 	     equivalent as well. */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"VOID"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<error type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* FIXME, we should not ever have to print one of these yet.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<range type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_f_logical_s1
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_f_logical_s2
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_f_logical
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Logicals of length %d bytes not supported"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|".FALSE."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|".TRUE."
argument_list|)
expr_stmt|;
else|else
comment|/* Not a legitimate logical type, print as an integer.  */
block|{
comment|/* Bash the type code temporarily.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_INT
expr_stmt|;
name|f_val_print
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
comment|/* Restore the type code so later uses work as intended. */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_BOOL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_COMPLEX
case|:
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|type
operator|=
name|builtin_type_f_real
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|type
operator|=
name|builtin_type_f_real_s8
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|type
operator|=
name|builtin_type_f_real_s16
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Cannot print out complex*%d variables"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_floating
argument_list|(
name|valaddr
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* This happens (without TYPE_FLAG_STUB set) on systems which don't use          dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"          and no complete type for struct foo in that file.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid F77 type code %d in symbol table."
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_all_visible_commons
parameter_list|(
name|char
modifier|*
name|funname
parameter_list|)
block|{
name|SAVED_F77_COMMON_PTR
name|tmp
decl_stmt|;
name|tmp
operator|=
name|head_common_list
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"All COMMON blocks visible at this level:\n\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
operator|->
name|owning_function
argument_list|,
name|funname
argument_list|)
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is used to print out the values in a given COMMON     block. It will always use the most local common block of the     given name */
end_comment

begin_function
specifier|static
name|void
name|info_common_command
parameter_list|(
name|char
modifier|*
name|comname
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|SAVED_F77_COMMON_PTR
name|the_common
decl_stmt|;
name|COMMON_ENTRY_PTR
name|entry
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
comment|/* We have been told to display the contents of F77 COMMON       block supposedly visible in this function.  Let us       first make sure that it is visible and if so, let       us display its contents */
name|fi
operator|=
name|deprecated_selected_frame
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No frame selected"
argument_list|)
expr_stmt|;
comment|/* The following is generally ripped off from stack.c's routine       print_frame_info() */
name|func
operator|=
name|find_pc_function
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
comment|/* In certain pathological cases, the symtabs give the wrong          function (when we are in the first function in a file which          is compiled without debugging symbols, the previous function          is compiled with debugging symbols, and the "foo.o" symbol          that is supposed to tell us where the file with debugging symbols          ends has been truncated by ar because it is longer than 15          characters).           So look in the minimal symbol tables as well, and if it comes          up with a larger address for the function use that instead.          I don't think this can ever cause any problems; there shouldn't          be any minimal symbols in the middle of a function.          FIXME:  (Not necessarily true.  What about text labels) */
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|)
condition|)
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
else|else
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
comment|/* If comname is NULL, we assume the user wishes to see the       which COMMON blocks are visible here and then return */
if|if
condition|(
name|comname
operator|==
literal|0
condition|)
block|{
name|list_all_visible_commons
argument_list|(
name|funname
argument_list|)
expr_stmt|;
return|return;
block|}
name|the_common
operator|=
name|find_common_for_function
argument_list|(
name|comname
argument_list|,
name|funname
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_common
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|comname
argument_list|,
name|BLANK_COMMON_NAME_LOCAL
argument_list|)
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Contents of blank COMMON block:\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Contents of F77 COMMON block '%s':\n"
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|entry
operator|=
name|the_common
operator|->
name|entries
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s = "
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|entry
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|entry
operator|->
name|symbol
argument_list|,
name|fi
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
name|printf_filtered
argument_list|(
literal|"Cannot locate the common block %s in function '%s'\n"
argument_list|,
name|comname
argument_list|,
name|funname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is used to determine whether there is a    F77 common block visible at the current scope called 'comname'. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int there_is_a_visible_common_named (char *comname) {   SAVED_F77_COMMON_PTR the_common;   struct frame_info *fi;   char *funname = 0;   struct symbol *func;    if (comname == NULL)     error ("Cannot deal with NULL common name!");    fi = deprecated_selected_frame;    if (fi == NULL)     error ("No frame selected");
comment|/* The following is generally ripped off from stack.c's routine       print_frame_info() */
end_comment

begin_comment
unit|func = find_pc_function (fi->pc);   if (func)     {
comment|/* In certain pathological cases, the symtabs give the wrong          function (when we are in the first function in a file which          is compiled without debugging symbols, the previous function          is compiled with debugging symbols, and the "foo.o" symbol          that is supposed to tell us where the file with debugging symbols          ends has been truncated by ar because it is longer than 15          characters).           So look in the minimal symbol tables as well, and if it comes          up with a larger address for the function use that instead.          I don't think this can ever cause any problems; there shouldn't          be any minimal symbols in the middle of a function.          FIXME:  (Not necessarily true.  What about text labels) */
end_comment

begin_endif
unit|struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (fi->pc);        if (msymbol != NULL&& (SYMBOL_VALUE_ADDRESS (msymbol)> BLOCK_START (SYMBOL_BLOCK_VALUE (func)))) 	funname = DEPRECATED_SYMBOL_NAME (msymbol);       else 	funname = DEPRECATED_SYMBOL_NAME (func);     }   else     {       struct minimal_symbol *msymbol =       lookup_minimal_symbol_by_pc (fi->pc);        if (msymbol != NULL) 	funname = DEPRECATED_SYMBOL_NAME (msymbol);     }    the_common = find_common_for_function (comname, funname);    return (the_common ? 1 : 0); }
endif|#
directive|endif
end_endif

begin_function
name|void
name|_initialize_f_valprint
parameter_list|(
name|void
parameter_list|)
block|{
name|add_info
argument_list|(
literal|"common"
argument_list|,
name|info_common_command
argument_list|,
literal|"Print out the values contained in a Fortran COMMON block."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"lc"
argument_list|,
name|class_info
argument_list|,
name|info_common_command
argument_list|,
literal|"Print out the values contained in a Fortran COMMON block."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

