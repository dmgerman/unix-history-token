begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  * Copyright (c) 2011, 2012  *	Zhihao Yuan.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: conv.c,v 2.39 2013/07/01 23:28:13 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_comment
comment|/*  * codeset --  *	Get the locale encoding.  *  * PUBLIC: char * codeset __P((void));  */
end_comment

begin_function
name|char
modifier|*
name|codeset
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|cs
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
name|cs
operator|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
expr_stmt|;
return|return
name|cs
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WIDECHAR
end_ifdef

begin_function
specifier|static
name|int
name|raw2int
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CHAR_T
modifier|*
modifier|*
name|tostr
init|=
operator|&
name|cw
operator|->
name|bp1
operator|.
name|wc
decl_stmt|;
name|size_t
modifier|*
name|blen
init|=
operator|&
name|cw
operator|->
name|blen1
decl_stmt|;
name|BINC_RETW
argument_list|(
name|NULL
argument_list|,
operator|*
name|tostr
argument_list|,
operator|*
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|tolen
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|tostr
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
operator|*
name|dst
operator|=
name|cw
operator|->
name|bp1
operator|.
name|wc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CONV_BUFFER_SIZE
value|512
end_define

begin_comment
comment|/* fill the buffer with codeset encoding of string pointed to by str  * left has the number of bytes left in str and is adjusted  * len contains the number of bytes put in the buffer  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ICONV
end_ifdef

begin_define
define|#
directive|define
name|CONVERT
parameter_list|(
name|str
parameter_list|,
name|left
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
define|\
value|do {								\ 	size_t outleft;							\ 	char *bp = buffer;						\ 	outleft = CONV_BUFFER_SIZE;					\ 	errno = 0;							\ 	if (iconv(id, (iconv_src_t)&str,&left,&bp,&outleft) == -1&&	\ 		errno != E2BIG)						\ 	    goto err;							\ 	if ((len = CONV_BUFFER_SIZE - outleft) == 0) {			\ 	    error = -left;						\ 	    goto err;							\ 	}				    				\ 	src = buffer;							\     } while (0)
end_define

begin_define
define|#
directive|define
name|IC_RESET
parameter_list|()
define|\
value|do {								\ 	if (id != (iconv_t)-1)						\ 	    iconv(id, NULL, NULL, NULL, NULL);				\     } while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONVERT
parameter_list|(
name|str
parameter_list|,
name|left
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
end_define

begin_define
define|#
directive|define
name|IC_RESET
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|default_char2int
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|dst
parameter_list|,
name|iconv_t
name|id
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|CHAR_T
modifier|*
modifier|*
name|tostr
init|=
operator|&
name|cw
operator|->
name|bp1
operator|.
name|wc
decl_stmt|;
name|size_t
modifier|*
name|blen
init|=
operator|&
name|cw
operator|->
name|blen1
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|ssize_t
name|nlen
init|=
name|len
decl_stmt|;
name|char
modifier|*
name|src
init|=
operator|(
name|char
operator|*
operator|)
name|str
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_ICONV
name|char
name|buffer
index|[
name|CONV_BUFFER_SIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|size_t
name|left
init|=
name|len
decl_stmt|;
name|int
name|error
init|=
literal|1
decl_stmt|;
name|BZERO
argument_list|(
operator|&
name|mbs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BINC_RETW
argument_list|(
name|NULL
argument_list|,
operator|*
name|tostr
argument_list|,
operator|*
name|blen
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ICONV
if|if
condition|(
name|id
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|CONVERT
argument_list|(
name|str
argument_list|,
name|left
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
control|)
block|{
name|n
operator|=
name|mbrtowc
argument_list|(
operator|(
operator|*
name|tostr
operator|)
operator|+
name|i
argument_list|,
name|src
operator|+
name|j
argument_list|,
name|len
operator|-
name|j
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
comment|/* NULL character converted */
if|if
condition|(
name|n
operator|==
operator|-
literal|2
condition|)
name|error
operator|=
operator|-
operator|(
name|len
operator|-
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|||
name|n
operator|==
operator|-
literal|2
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|j
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
operator|*
name|blen
condition|)
block|{
name|nlen
operator|+=
literal|256
expr_stmt|;
name|BINC_RETW
argument_list|(
name|NULL
argument_list|,
operator|*
name|tostr
argument_list|,
operator|*
name|blen
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
operator|&&
name|j
operator|==
name|len
operator|&&
name|left
condition|)
block|{
name|CONVERT
argument_list|(
name|str
argument_list|,
name|left
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|err
label|:
operator|*
name|tolen
operator|=
name|i
expr_stmt|;
operator|*
name|dst
operator|=
name|cw
operator|->
name|bp1
operator|.
name|wc
expr_stmt|;
name|IC_RESET
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_char2int
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|default_char2int
argument_list|(
name|sp
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|cw
argument_list|,
name|tolen
argument_list|,
name|dst
argument_list|,
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|IC_FE_CHAR2INT
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ie_char2int
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|default_char2int
argument_list|(
name|sp
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|cw
argument_list|,
name|tolen
argument_list|,
name|dst
argument_list|,
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|IC_IE_CHAR2INT
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs_char2int
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|default_char2int
argument_list|(
name|sp
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|cw
argument_list|,
name|tolen
argument_list|,
name|dst
argument_list|,
operator|(
name|iconv_t
operator|)
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|int2raw
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|char
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|tostr
init|=
operator|&
name|cw
operator|->
name|bp1
operator|.
name|c
decl_stmt|;
name|size_t
modifier|*
name|blen
init|=
operator|&
name|cw
operator|->
name|blen1
decl_stmt|;
name|BINC_RETC
argument_list|(
name|NULL
argument_list|,
operator|*
name|tostr
argument_list|,
operator|*
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|tolen
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|tostr
operator|)
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
operator|*
name|dst
operator|=
name|cw
operator|->
name|bp1
operator|.
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|default_int2char
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|char
modifier|*
modifier|*
name|pdst
parameter_list|,
name|iconv_t
name|id
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|tostr
init|=
operator|&
name|cw
operator|->
name|bp1
operator|.
name|c
decl_stmt|;
name|size_t
modifier|*
name|blen
init|=
operator|&
name|cw
operator|->
name|blen1
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|ssize_t
name|nlen
init|=
name|len
operator|+
name|MB_CUR_MAX
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_ICONV
name|char
name|buffer
index|[
name|CONV_BUFFER_SIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|1
decl_stmt|;
comment|/* convert first len bytes of buffer and append it to cw->bp  * len is adjusted => 0  * offset contains the offset in cw->bp and is adjusted  * cw->bp is grown as required  */
ifdef|#
directive|ifdef
name|USE_ICONV
define|#
directive|define
name|CONVERT2
parameter_list|(
name|_buffer
parameter_list|,
name|lenp
parameter_list|,
name|cw
parameter_list|,
name|offset
parameter_list|)
define|\
value|do {								\ 	char *bp = _buffer;						\ 	int ret;							\ 	do {								\ 	    size_t outleft = cw->blen1 - offset;			\ 	    char *obp = cw->bp1.c + offset;				\ 	    if (cw->blen1< offset + MB_CUR_MAX) {		    	\ 		nlen += 256;						\ 		BINC_RETC(NULL, cw->bp1.c, cw->blen1, nlen);		\ 	    }						    		\ 	    errno = 0;						    	\ 	    ret = iconv(id, (iconv_src_t)&bp, lenp,&obp,&outleft);	\ 	    if (ret == -1&& errno != E2BIG)				\ 		goto err;						\ 	    offset = cw->blen1 - outleft;			        \ 	} while (ret != 0); 					        \     } while (0)
else|#
directive|else
define|#
directive|define
name|CONVERT2
parameter_list|(
name|_buffer
parameter_list|,
name|lenp
parameter_list|,
name|cw
parameter_list|,
name|offset
parameter_list|)
endif|#
directive|endif
name|BZERO
argument_list|(
operator|&
name|mbs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BINC_RETC
argument_list|(
name|NULL
argument_list|,
operator|*
name|tostr
argument_list|,
operator|*
name|blen
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|*
name|tostr
expr_stmt|;
name|buflen
operator|=
operator|*
name|blen
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ICONV
if|if
condition|(
name|id
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
name|dst
operator|=
name|buffer
expr_stmt|;
name|buflen
operator|=
name|CONV_BUFFER_SIZE
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|n
operator|=
name|wcrtomb
argument_list|(
name|dst
operator|+
name|j
argument_list|,
name|str
index|[
name|i
index|]
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
name|j
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
name|j
operator|+
name|MB_CUR_MAX
condition|)
block|{
if|if
condition|(
name|id
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
name|CONVERT2
argument_list|(
name|buffer
argument_list|,
operator|&
name|j
argument_list|,
name|cw
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nlen
operator|+=
literal|256
expr_stmt|;
name|BINC_RETC
argument_list|(
name|NULL
argument_list|,
operator|*
name|tostr
argument_list|,
operator|*
name|blen
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|*
name|tostr
expr_stmt|;
name|buflen
operator|=
operator|*
name|blen
expr_stmt|;
block|}
block|}
block|}
name|n
operator|=
name|wcrtomb
argument_list|(
name|dst
operator|+
name|j
argument_list|,
literal|L'
expr|\0'
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
name|j
operator|+=
name|n
operator|-
literal|1
expr_stmt|;
comment|/* don't count NUL at the end */
operator|*
name|tolen
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|id
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
name|CONVERT2
argument_list|(
name|buffer
argument_list|,
operator|&
name|j
argument_list|,
name|cw
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|CONVERT2
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cw
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* back to the initial state */
operator|*
name|tolen
operator|=
name|offset
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|err
label|:
if|if
condition|(
name|error
condition|)
operator|*
name|tolen
operator|=
name|j
expr_stmt|;
operator|*
name|pdst
operator|=
name|cw
operator|->
name|bp1
operator|.
name|c
expr_stmt|;
name|IC_RESET
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_int2char
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|char
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|default_int2char
argument_list|(
name|sp
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|cw
argument_list|,
name|tolen
argument_list|,
name|dst
argument_list|,
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|IC_FE_INT2CHAR
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs_int2char
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|CONVWIN
modifier|*
name|cw
parameter_list|,
name|size_t
modifier|*
name|tolen
parameter_list|,
name|char
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|default_int2char
argument_list|(
name|sp
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|cw
argument_list|,
name|tolen
argument_list|,
name|dst
argument_list|,
operator|(
name|iconv_t
operator|)
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * conv_init --  *	Initialize the iconv environment.  *  * PUBLIC: void conv_init __P((SCR *, SCR *));  */
end_comment

begin_function
name|void
name|conv_init
parameter_list|(
name|SCR
modifier|*
name|orig
parameter_list|,
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|orig
operator|==
name|NULL
condition|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
operator|!=
name|NULL
condition|)
name|BCOPY
argument_list|(
operator|&
name|orig
operator|->
name|conv
argument_list|,
operator|&
name|sp
operator|->
name|conv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDECHAR
else|else
block|{
name|char
modifier|*
name|ctype
init|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* 	 * XXX 	 * This hack fixes the libncursesw issue on FreeBSD. 	 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"ko_KR.CP949"
argument_list|)
condition|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|"ko_KR.eucKR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"zh_CN.GB2312"
argument_list|)
condition|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|"zh_CN.eucCN"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"zh_CN.GBK"
argument_list|)
condition|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|"zh_CN.GB18030"
argument_list|)
expr_stmt|;
comment|/* 	 * Switch to 8bit mode if locale is C; 	 * LC_CTYPE should be reseted to C if unmatched. 	 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"C"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"POSIX"
argument_list|)
condition|)
block|{
name|sp
operator|->
name|conv
operator|.
name|sys2int
operator|=
name|sp
operator|->
name|conv
operator|.
name|file2int
operator|=
name|raw2int
expr_stmt|;
name|sp
operator|->
name|conv
operator|.
name|int2sys
operator|=
name|sp
operator|->
name|conv
operator|.
name|int2file
operator|=
name|int2raw
expr_stmt|;
name|sp
operator|->
name|conv
operator|.
name|input2int
operator|=
name|raw2int
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|conv
operator|.
name|sys2int
operator|=
name|cs_char2int
expr_stmt|;
name|sp
operator|->
name|conv
operator|.
name|int2sys
operator|=
name|cs_int2char
expr_stmt|;
name|sp
operator|->
name|conv
operator|.
name|file2int
operator|=
name|fe_char2int
expr_stmt|;
name|sp
operator|->
name|conv
operator|.
name|int2file
operator|=
name|fe_int2char
expr_stmt|;
name|sp
operator|->
name|conv
operator|.
name|input2int
operator|=
name|ie_char2int
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_ICONV
name|o_set
argument_list|(
name|sp
argument_list|,
name|O_INPUTENCODING
argument_list|,
name|OS_STRDUP
argument_list|,
name|codeset
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* iconv descriptors must be distinct to screens. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IC_IE_TO_UTF16
condition|;
operator|++
name|i
control|)
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|i
index|]
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ICONV
name|conv_enc
argument_list|(
name|sp
argument_list|,
name|O_INPUTENCODING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * conv_enc --  *	Convert file/input encoding.  *  * PUBLIC: int conv_enc __P((SCR *, int, char *));  */
end_comment

begin_function
name|int
name|conv_enc
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|option
parameter_list|,
name|char
modifier|*
name|enc
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_WIDECHAR
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_ICONV
argument_list|)
name|iconv_t
modifier|*
name|c2w
decl_stmt|,
modifier|*
name|w2c
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|O_FILEENCODING
case|:
name|c2w
operator|=
name|sp
operator|->
name|conv
operator|.
name|id
operator|+
name|IC_FE_CHAR2INT
expr_stmt|;
name|w2c
operator|=
name|sp
operator|->
name|conv
operator|.
name|id
operator|+
name|IC_FE_INT2CHAR
expr_stmt|;
if|if
condition|(
operator|!
name|enc
condition|)
name|enc
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_FILEENCODING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c2w
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
operator|*
name|c2w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|w2c
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
operator|*
name|w2c
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|codeset
argument_list|()
argument_list|,
name|enc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c2w
operator|=
name|iconv_open
argument_list|(
name|codeset
argument_list|()
argument_list|,
name|enc
argument_list|)
operator|)
operator|==
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
operator|*
name|w2c
operator|=
name|iconv_open
argument_list|(
name|enc
argument_list|,
name|codeset
argument_list|()
argument_list|)
operator|)
operator|==
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
block|}
else|else
operator|*
name|c2w
operator|=
operator|*
name|w2c
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|O_INPUTENCODING
case|:
name|c2w
operator|=
name|sp
operator|->
name|conv
operator|.
name|id
operator|+
name|IC_IE_CHAR2INT
expr_stmt|;
name|w2c
operator|=
name|sp
operator|->
name|conv
operator|.
name|id
operator|+
name|IC_IE_TO_UTF16
expr_stmt|;
if|if
condition|(
operator|!
name|enc
condition|)
name|enc
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_INPUTENCODING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c2w
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
operator|*
name|c2w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|w2c
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
operator|*
name|w2c
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|codeset
argument_list|()
argument_list|,
name|enc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c2w
operator|=
name|iconv_open
argument_list|(
name|codeset
argument_list|()
argument_list|,
name|enc
argument_list|)
operator|)
operator|==
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
block|}
else|else
operator|*
name|c2w
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* UTF-16 can not be locale and can not be inputed. */
if|if
condition|(
operator|(
operator|*
name|w2c
operator|=
name|iconv_open
argument_list|(
literal|"utf-16be"
argument_list|,
name|enc
argument_list|)
operator|)
operator|==
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
break|break;
block|}
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_CONV_ERROR
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REFORMAT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
endif|#
directive|endif
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|O_FILEENCODING
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"321|File encoding conversion not supported"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_INPUTENCODING
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"322|Input encoding conversion not supported"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * conv_end --  *	Close the iconv descriptors, release the buffer.  *  * PUBLIC: void conv_end __P((SCR *));  */
end_comment

begin_function
name|void
name|conv_end
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_WIDECHAR
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_ICONV
argument_list|)
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IC_IE_TO_UTF16
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|i
index|]
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cw
operator|.
name|bp1
operator|.
name|c
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sp
operator|->
name|cw
operator|.
name|bp1
operator|.
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

