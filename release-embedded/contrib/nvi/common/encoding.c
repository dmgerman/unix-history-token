begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011, 2012  *	Zhihao Yuan.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: encoding.c,v 1.4 2011/12/13 19:40:52 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
name|int
name|looks_utf8
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|looks_utf16
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|decode_utf8
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|decode_utf16
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|F
value|0
end_define

begin_comment
comment|/* character never appears in text */
end_comment

begin_define
define|#
directive|define
name|T
value|1
end_define

begin_comment
comment|/* character appears in plain ASCII text */
end_comment

begin_define
define|#
directive|define
name|I
value|2
end_define

begin_comment
comment|/* character appears in ISO-8859 text */
end_comment

begin_define
define|#
directive|define
name|X
value|3
end_define

begin_comment
comment|/* character appears in non-ISO extended ASCII (Mac, IBM PC) */
end_comment

begin_decl_stmt
specifier|static
name|char
name|text_chars
index|[
literal|256
index|]
init|=
block|{
comment|/*                  BEL BS HT LF    FF CR    */
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|F
block|,
name|T
block|,
name|T
block|,
name|F
block|,
name|F
block|,
comment|/* 0x0X */
comment|/*                              ESC          */
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|T
block|,
name|F
block|,
name|F
block|,
name|F
block|,
name|F
block|,
comment|/* 0x1X */
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
comment|/* 0x2X */
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
comment|/* 0x3X */
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
comment|/* 0x4X */
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
comment|/* 0x5X */
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
comment|/* 0x6X */
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|T
block|,
name|F
block|,
comment|/* 0x7X */
comment|/*            NEL                            */
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|T
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
comment|/* 0x8X */
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
comment|/* 0x9X */
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
comment|/* 0xaX */
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
comment|/* 0xbX */
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
comment|/* 0xcX */
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
comment|/* 0xdX */
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
comment|/* 0xeX */
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
comment|/* 0xfX */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * looks_utf8 --  *  Decide whether some text looks like UTF-8. Returns:  *  *     -1: invalid UTF-8  *      0: uses odd control characters, so doesn't look like text  *      1: 7-bit text  *      2: definitely UTF-8 text (valid high-bit set bytes)  *  *  Based on RFC 3629. UTF-8 with BOM is not accepted.  *  * PUBLIC: int looks_utf8 __P((const char *, size_t));  */
end_comment

begin_function
name|int
name|looks_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|ibuf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
name|ibuf
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|gotone
init|=
literal|0
decl_stmt|,
name|ctrl
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 0xxxxxxx is plain ASCII */
comment|/* 			 * Even if the whole file is valid UTF-8 sequences, 			 * still reject it if it uses weird control characters. 			 */
if|if
condition|(
name|text_chars
index|[
name|buf
index|[
name|i
index|]
index|]
operator|!=
name|T
condition|)
name|ctrl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 10xxxxxx never 1st byte */
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* 11xxxxxx begins UTF-8 */
name|int
name|following
decl_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
comment|/* 110xxxxx */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|>
literal|0xC1
condition|)
comment|/* C0, C1 */
name|following
operator|=
literal|1
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
comment|/* 1110xxxx */
name|following
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|&
literal|0x08
operator|)
operator|==
literal|0
condition|)
comment|/* 11110xxx */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|<
literal|0xF5
condition|)
name|following
operator|=
literal|3
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
comment|/* F5, F6, F7 */
else|else
return|return
operator|-
literal|1
return|;
comment|/* F8~FF */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|following
condition|;
name|n
operator|++
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|nbytes
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|&
literal|0x40
condition|)
comment|/* 10xxxxxx */
return|return
operator|-
literal|1
return|;
block|}
name|gotone
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|done
label|:
return|return
name|ctrl
condition|?
literal|0
else|:
operator|(
name|gotone
condition|?
literal|2
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * looks_utf16 --  *  Decide whether some text looks like UTF-16. Returns:  *  *      0: invalid UTF-16  *      1: Little-endian UTF-16  *      2: Big-endian UTF-16  *  * PUBLIC: int looks_utf16 __P((const char *, size_t));  */
end_comment

begin_function
name|int
name|looks_utf16
parameter_list|(
specifier|const
name|char
modifier|*
name|ibuf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
name|ibuf
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|bom
decl_stmt|;
name|int
name|following
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|bom
operator|=
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|^
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|bom
operator|==
literal|0xFFFE
condition|)
name|bigend
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|bom
operator|==
literal|0xFEFF
condition|)
name|bigend
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|+
literal|1
operator|<
name|nbytes
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|bigend
condition|)
name|c
operator|=
name|buf
index|[
name|i
index|]
operator|<<
literal|8
operator|^
name|buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|c
operator|=
name|buf
index|[
name|i
index|]
operator|^
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|following
condition|)
if|if
condition|(
name|c
operator|<
literal|0xD800
operator|||
name|c
operator|>
literal|0xDFFF
condition|)
if|if
condition|(
name|c
operator|<
literal|128
operator|&&
name|text_chars
index|[
name|c
index|]
operator|!=
name|T
condition|)
return|return
literal|0
return|;
else|else
name|following
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>
literal|0xDBFF
condition|)
return|return
literal|0
return|;
else|else
block|{
name|following
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xDC00
operator|||
name|c
operator|>
literal|0xDFFF
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
operator|+
name|bigend
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|F
end_undef

begin_undef
undef|#
directive|undef
name|T
end_undef

begin_undef
undef|#
directive|undef
name|I
end_undef

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_comment
comment|/*  * decode_utf8 --  *  Decode a UTF-8 character from byte string to Unicode.  *  Returns -1 if the first byte is a not UTF-8 leader.  *  *  Based on RFC 3629, but without error detection.  *  * PUBLIC: int decode_utf8 __P((const char *));  */
end_comment

begin_function
name|int
name|decode_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|ibuf
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
name|ibuf
decl_stmt|;
name|int
name|u
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|u
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
name|u
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|^
literal|0xC0
operator|)
operator|<<
literal|6
operator|^
operator|(
name|buf
index|[
literal|1
index|]
operator|^
literal|0x80
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
name|u
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|^
literal|0xE0
operator|)
operator|<<
literal|12
operator|^
operator|(
name|buf
index|[
literal|1
index|]
operator|^
literal|0x80
operator|)
operator|<<
literal|6
operator|^
operator|(
name|buf
index|[
literal|2
index|]
operator|^
literal|0x80
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x08
operator|)
operator|==
literal|0
operator|)
condition|)
name|u
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|^
literal|0xF0
operator|)
operator|<<
literal|18
operator|^
operator|(
name|buf
index|[
literal|1
index|]
operator|^
literal|0x80
operator|)
operator|<<
literal|12
operator|^
operator|(
name|buf
index|[
literal|2
index|]
operator|^
literal|0x80
operator|)
operator|<<
literal|6
operator|^
operator|(
name|buf
index|[
literal|3
index|]
operator|^
literal|0x80
operator|)
expr_stmt|;
block|}
return|return
name|u
return|;
block|}
end_function

begin_comment
comment|/*  * decode_utf16 --  *  Decode a UTF-16 character from byte string to Unicode.  *  Returns -1 if the first unsigned integer is invalid.  *  *  No error detection on supplementary bytes.  *  * PUBLIC: int decode_utf16 __P((const char *, int));  */
end_comment

begin_function
name|int
name|decode_utf16
parameter_list|(
specifier|const
name|char
modifier|*
name|ibuf
parameter_list|,
name|int
name|bigend
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
name|ibuf
decl_stmt|;
name|int
name|u
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|w1
decl_stmt|,
name|w2
decl_stmt|;
if|if
condition|(
name|bigend
condition|)
name|w1
operator|=
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|^
name|buf
index|[
literal|1
index|]
expr_stmt|;
else|else
name|w1
operator|=
name|buf
index|[
literal|0
index|]
operator|^
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|w1
operator|<
literal|0xD800
operator|||
name|w1
operator|>
literal|0xDFFF
condition|)
name|u
operator|=
name|w1
expr_stmt|;
elseif|else
if|if
condition|(
name|w1
operator|>
literal|0xDBFF
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|bigend
condition|)
name|w2
operator|=
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|^
name|buf
index|[
literal|3
index|]
expr_stmt|;
else|else
name|w2
operator|=
name|buf
index|[
literal|2
index|]
operator|^
name|buf
index|[
literal|3
index|]
operator|<<
literal|8
expr_stmt|;
name|u
operator|=
operator|(
operator|(
name|w1
operator|^
literal|0xD800
operator|)
operator|<<
literal|10
operator|^
operator|(
name|w2
operator|^
literal|0xDC00
operator|)
operator|)
operator|+
literal|0x10000
expr_stmt|;
block|}
return|return
name|u
return|;
block|}
end_function

end_unit

