begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: ex_init.c,v 10.33 2012/04/11 19:12:34 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"tag.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_enum
enum|enum
name|rc
block|{
name|NOEXIST
block|,
name|NOPERM
block|,
name|RCOK
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|rc
name|exrc_isok
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_run_file
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ex_screen_copy --  *	Copy ex screen.  *  * PUBLIC: int ex_screen_copy __P((SCR *, SCR *));  */
end_comment

begin_function
name|int
name|ex_screen_copy
parameter_list|(
name|SCR
modifier|*
name|orig
parameter_list|,
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|EX_PRIVATE
modifier|*
name|oexp
decl_stmt|,
modifier|*
name|nexp
decl_stmt|;
comment|/* Create the private ex structure. */
name|CALLOC_RET
argument_list|(
name|orig
argument_list|,
name|nexp
argument_list|,
name|EX_PRIVATE
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EX_PRIVATE
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ex_private
operator|=
name|nexp
expr_stmt|;
comment|/* Initialize queues. */
name|TAILQ_INIT
argument_list|(
name|nexp
operator|->
name|tq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|nexp
operator|->
name|tagfq
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
name|nexp
operator|->
name|cscq
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
operator|==
name|NULL
condition|)
block|{ 	}
else|else
block|{
name|oexp
operator|=
name|EXP
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|oexp
operator|->
name|lastbcomm
operator|!=
name|NULL
operator|&&
operator|(
name|nexp
operator|->
name|lastbcomm
operator|=
name|v_wstrdup
argument_list|(
name|sp
argument_list|,
name|oexp
operator|->
name|lastbcomm
argument_list|,
name|STRLEN
argument_list|(
name|oexp
operator|->
name|lastbcomm
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ex_tag_copy
argument_list|(
name|orig
argument_list|,
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_screen_end --  *	End a vi screen.  *  * PUBLIC: int ex_screen_end __P((SCR *));  */
end_comment

begin_function
name|int
name|ex_screen_end
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rval
operator|=
literal|0
expr_stmt|;
comment|/* Close down script connections. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCRIPT
argument_list|)
operator|&&
name|sscr_end
argument_list|(
name|sp
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argv_free
argument_list|(
name|sp
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|ibp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|exp
operator|->
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|lastbcomm
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|exp
operator|->
name|lastbcomm
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|ibcw
operator|.
name|bp1
operator|.
name|c
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|exp
operator|->
name|ibcw
operator|.
name|bp1
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_tag_free
argument_list|(
name|sp
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cscope_end
argument_list|(
name|sp
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
comment|/* Free private memory. */
name|free
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ex_private
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_optchange --  *	Handle change of options for ex.  *  * PUBLIC: int ex_optchange __P((SCR *, int, char *, u_long *));  */
end_comment

begin_function
name|int
name|ex_optchange
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|offset
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|u_long
modifier|*
name|valp
parameter_list|)
block|{
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|O_TAGS
case|:
return|return
operator|(
name|ex_tagf_alloc
argument_list|(
name|sp
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_exrc --  *	Read the EXINIT environment variable and the startup exrc files,  *	and execute their commands.  *  * PUBLIC: int ex_exrc __P((SCR *));  */
end_comment

begin_function
name|int
name|ex_exrc
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|stat
name|hsb
decl_stmt|,
name|lsb
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|CHAR_T
modifier|*
name|wp
decl_stmt|;
name|size_t
name|wlen
decl_stmt|;
comment|/* 	 * Source the system, environment, $HOME and local .exrc values. 	 * Vi historically didn't check $HOME/.exrc if the environment 	 * variable EXINIT was set.  This is all done before the file is 	 * read in, because things in the .exrc information can set, for 	 * example, the recovery directory. 	 * 	 * !!! 	 * While nvi can handle any of the options settings of historic vi, 	 * the converse is not true.  Since users are going to have to have 	 * files and environmental variables that work with both, we use nvi 	 * versions of both the $HOME and local startup files if they exist, 	 * otherwise the historic ones. 	 * 	 * !!! 	 * For a discussion of permissions and when what .exrc files are 	 * read, see the comment above the exrc_isok() function below. 	 * 	 * !!! 	 * If the user started the historic of vi in $HOME, vi read the user's 	 * .exrc file twice, as $HOME/.exrc and as ./.exrc.  We avoid this, as 	 * it's going to make some commands behave oddly, and I can't imagine 	 * anyone depending on it. 	 */
switch|switch
condition|(
name|exrc_isok
argument_list|(
name|sp
argument_list|,
operator|&
name|hsb
argument_list|,
name|_PATH_SYSEXRC
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NOEXIST
case|:
case|case
name|NOPERM
case|:
break|break;
case|case
name|RCOK
case|:
if|if
condition|(
name|ex_run_file
argument_list|(
name|sp
argument_list|,
name|_PATH_SYSEXRC
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
comment|/* Run the commands. */
if|if
condition|(
name|EXCMD_RUNNING
argument_list|(
name|sp
operator|->
name|gp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ex_cmd
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"NEXINIT"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_run_str
argument_list|(
name|sp
argument_list|,
literal|"NEXINIT"
argument_list|,
name|wp
argument_list|,
name|wlen
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"EXINIT"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_run_str
argument_list|(
name|sp
argument_list|,
literal|"EXINIT"
argument_list|,
name|wp
argument_list|,
name|wlen
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|p
condition|)
block|{
name|int
name|st
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|join
argument_list|(
name|p
argument_list|,
name|_PATH_NEXRC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|exrc_isok
argument_list|(
name|sp
argument_list|,
operator|&
name|hsb
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|NOEXIST
case|:
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|join
argument_list|(
name|p
argument_list|,
name|_PATH_EXRC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|exrc_isok
argument_list|(
name|sp
argument_list|,
operator|&
name|hsb
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
name|RCOK
operator|&&
name|ex_run_file
argument_list|(
name|sp
argument_list|,
name|path
argument_list|)
condition|)
name|st
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NOPERM
case|:
break|break;
case|case
name|RCOK
case|:
if|if
condition|(
name|ex_run_file
argument_list|(
name|sp
argument_list|,
name|path
argument_list|)
condition|)
name|st
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
condition|)
return|return
name|st
return|;
block|}
comment|/* Run the commands. */
if|if
condition|(
name|EXCMD_RUNNING
argument_list|(
name|sp
operator|->
name|gp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ex_cmd
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Previous commands may have set the exrc option. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_EXRC
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|exrc_isok
argument_list|(
name|sp
argument_list|,
operator|&
name|lsb
argument_list|,
name|_PATH_NEXRC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NOEXIST
case|:
if|if
condition|(
name|exrc_isok
argument_list|(
name|sp
argument_list|,
operator|&
name|lsb
argument_list|,
name|_PATH_EXRC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|RCOK
operator|&&
operator|(
name|lsb
operator|.
name|st_dev
operator|!=
name|hsb
operator|.
name|st_dev
operator|||
name|lsb
operator|.
name|st_ino
operator|!=
name|hsb
operator|.
name|st_ino
operator|)
operator|&&
name|ex_run_file
argument_list|(
name|sp
argument_list|,
name|_PATH_EXRC
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|NOPERM
case|:
break|break;
case|case
name|RCOK
case|:
if|if
condition|(
operator|(
name|lsb
operator|.
name|st_dev
operator|!=
name|hsb
operator|.
name|st_dev
operator|||
name|lsb
operator|.
name|st_ino
operator|!=
name|hsb
operator|.
name|st_ino
operator|)
operator|&&
name|ex_run_file
argument_list|(
name|sp
argument_list|,
name|_PATH_NEXRC
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
comment|/* Run the commands. */
if|if
condition|(
name|EXCMD_RUNNING
argument_list|(
name|sp
operator|->
name|gp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ex_cmd
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_run_file --  *	Set up a file of ex commands to run.  */
end_comment

begin_function
specifier|static
name|int
name|ex_run_file
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|CHAR_T
modifier|*
name|wp
decl_stmt|;
name|size_t
name|wlen
decl_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_SOURCE
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
name|argv_exp0
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|wp
argument_list|,
name|wlen
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ex_source
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_run_str --  *	Set up a string of ex commands to run.  *  * PUBLIC: int ex_run_str __P((SCR *, char *, CHAR_T *, size_t, int, int));  */
end_comment

begin_function
name|int
name|ex_run_str
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|CHAR_T
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|ex_flags
parameter_list|,
name|int
name|nocopy
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|EXCMD
modifier|*
name|ecp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|EXCMD_RUNNING
argument_list|(
name|gp
argument_list|)
condition|)
block|{
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|EXCMD
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMD
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|gp
operator|->
name|ecq
argument_list|,
name|ecp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|ecp
operator|=
operator|&
name|gp
operator|->
name|excmd
expr_stmt|;
name|F_INIT
argument_list|(
name|ecp
argument_list|,
name|ex_flags
condition|?
name|E_BLIGNORE
operator||
name|E_NOAUTO
operator||
name|E_NOPRDEF
operator||
name|E_VLITONLY
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nocopy
condition|)
name|ecp
operator|->
name|cp
operator|=
name|str
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ecp
operator|->
name|cp
operator|=
name|v_wstrdup
argument_list|(
name|sp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ecp
operator|->
name|clen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|ecp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ecp
operator|->
name|if_name
operator|=
name|v_strdup
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ecp
operator|->
name|if_lno
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_NAMEDISCARD
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * exrc_isok --  *	Check a .exrc file for source-ability.  *  * !!!  * Historically, vi read the $HOME and local .exrc files if they were owned  * by the user's real ID, or the "sourceany" option was set, regardless of  * any other considerations.  We no longer support the sourceany option as  * it's a security problem of mammoth proportions.  We require the system  * .exrc file to be owned by root, the $HOME .exrc file to be owned by the  * user's effective ID (or that the user's effective ID be root) and the  * local .exrc files to be owned by the user's effective ID.  In all cases,  * the file cannot be writeable by anyone other than its owner.  *  * In O'Reilly ("Learning the VI Editor", Fifth Ed., May 1992, page 106),  * it notes that System V release 3.2 and later has an option "[no]exrc".  * The behavior is that local .exrc files are read only if the exrc option  * is set.  The default for the exrc option was off, so, by default, local  * .exrc files were not read.  The problem this was intended to solve was  * that System V permitted users to give away files, so there's no possible  * ownership or writeability test to ensure that the file is safe.  *  * POSIX 1003.2-1992 standardized exrc as an option.  It required the exrc  * option to be off by default, thus local .exrc files are not to be read  * by default.  The Rationale noted (incorrectly) that this was a change  * to historic practice, but correctly noted that a default of off improves  * system security.  POSIX also required that vi check the effective user  * ID instead of the real user ID, which is why we've switched from historic  * practice.  *  * We initialize the exrc variable to off.  If it's turned on by the system  * or $HOME .exrc files, and the local .exrc file passes the ownership and  * writeability tests, then we read it.  This breaks historic 4BSD practice,  * but it gives us a measure of security on systems where users can give away  * files.  */
end_comment

begin_function
specifier|static
name|enum
name|rc
name|exrc_isok
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|struct
name|stat
modifier|*
name|sbp
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|rootown
parameter_list|,
name|int
name|rootid
parameter_list|)
block|{
enum|enum
block|{
name|ROOTOWN
block|,
name|OWN
block|,
name|WRITER
block|}
name|etype
enum|;
name|uid_t
name|euid
decl_stmt|;
name|int
name|nf1
decl_stmt|,
name|nf2
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
comment|/* Check for the file's existence. */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
name|sbp
argument_list|)
condition|)
return|return
operator|(
name|NOEXIST
operator|)
return|;
comment|/* Check ownership permissions. */
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rootown
operator|&&
name|sbp
operator|->
name|st_uid
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|rootid
operator|&&
name|euid
operator|==
literal|0
operator|)
operator|&&
name|sbp
operator|->
name|st_uid
operator|!=
name|euid
condition|)
block|{
name|etype
operator|=
name|rootown
condition|?
name|ROOTOWN
else|:
name|OWN
expr_stmt|;
goto|goto
name|denied
goto|;
block|}
comment|/* Check writeability. */
if|if
condition|(
name|sbp
operator|->
name|st_mode
operator|&
operator|(
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
condition|)
block|{
name|etype
operator|=
name|WRITER
expr_stmt|;
goto|goto
name|denied
goto|;
block|}
return|return
operator|(
name|RCOK
operator|)
return|;
name|denied
label|:
name|a
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|path
argument_list|,
operator|&
name|nf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|buf
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|b
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
operator|&
name|nf2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|join
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ROOTOWN
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"128|%s: not sourced: not owned by you or root"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OWN
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"129|%s: not sourced: not owned by you"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|WRITER
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"130|%s: not sourced: writeable by a user other than the owner"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|err
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf2
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ROOTOWN
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"128|%s: not sourced: not owned by you or root"
argument_list|,
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|OWN
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"129|%s: not sourced: not owned by you"
argument_list|,
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|WRITER
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"130|%s: not sourced: writeable by a user other than the owner"
argument_list|,
name|a
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nf1
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOPERM
operator|)
return|;
block|}
end_function

end_unit

