begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  * outline.c  *  * Copyright 1999, Clark Cooper  * All rights reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the license contained in the  * COPYING file that comes with the expat distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Read an XML document from standard input and print an element  * outline on standard output.  * Must be used with Expat compiled for UTF-8 output.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amigaos__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__USE_INLINE__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<proto/expat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XML_LARGE_SIZE
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XML_USE_MSC_EXTENSIONS
argument_list|)
operator|&&
name|_MSC_VER
operator|<
literal|1400
end_if

begin_define
define|#
directive|define
name|XML_FMT_INT_MOD
value|"I64"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XML_FMT_INT_MOD
value|"ll"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XML_FMT_INT_MOD
value|"l"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BUFFSIZE
value|8192
end_define

begin_decl_stmt
name|char
name|Buff
index|[
name|BUFFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Depth
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|XMLCALL
name|start
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|el
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Depth
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|el
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|attr
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|printf
argument_list|(
literal|" %s='%s'"
argument_list|,
name|attr
index|[
name|i
index|]
argument_list|,
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|Depth
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|end
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|el
parameter_list|)
block|{
name|Depth
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|XML_Parser
name|p
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't allocate memory for parser\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|XML_SetElementHandler
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|done
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|Buff
argument_list|,
literal|1
argument_list|,
name|BUFFSIZE
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Read error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|done
operator|=
name|feof
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|p
argument_list|,
name|Buff
argument_list|,
name|len
argument_list|,
name|done
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Parse error at line %"
name|XML_FMT_INT_MOD
literal|"u:\n%s\n"
argument_list|,
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
break|break;
block|}
name|XML_ParserFree
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

