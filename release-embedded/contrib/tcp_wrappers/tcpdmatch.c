begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tcpdmatch - explain what tcpd would do in a specific case   *    * usage: tcpdmatch [-d] [-i inet_conf] daemon[@host] [user@]host   *    * -d: use the access control tables in the current directory.   *    * -i: location of inetd.conf file.   *    * All errors are reported to the standard error stream, including the errors   * that would normally be reported via the syslog daemon.   *    * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.   *   * $FreeBSD$   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) tcpdmatch.c 1.5 96/02/11 17:01:36"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* System libraries. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INADDR_NONE
end_ifndef

begin_define
define|#
directive|define
name|INADDR_NONE
value|(-1)
end_define

begin_comment
comment|/* XXX should be 0xffffffff */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Application-specific. */
end_comment

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_include
include|#
directive|include
file|"inetcf.h"
end_include

begin_include
include|#
directive|include
file|"scaffold.h"
end_include

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tcpdmatch
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The main program */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|hp
decl_stmt|,
modifier|*
name|res
decl_stmt|;
else|#
directive|else
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|myname
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|client
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|daemon
decl_stmt|;
name|struct
name|request_info
name|request
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|inetcf
init|=
literal|0
decl_stmt|;
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_storage
name|server_sin
decl_stmt|;
name|struct
name|sockaddr_storage
name|client_sin
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr_in
name|server_sin
decl_stmt|;
name|struct
name|sockaddr_in
name|client_sin
decl_stmt|;
endif|#
directive|endif
name|struct
name|stat
name|st
decl_stmt|;
comment|/*      * Show what rule actually matched.      */
name|hosts_access_verbose
operator|=
literal|2
expr_stmt|;
comment|/*      * Parse the JCL.      */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"di:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|hosts_allow_table
operator|=
literal|"hosts.allow"
expr_stmt|;
name|hosts_deny_table
operator|=
literal|"hosts.deny"
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|inetcf
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|argc
operator|!=
name|optind
operator|+
literal|2
condition|)
name|usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
comment|/*      * When confusion really strikes...      */
if|if
condition|(
name|check_path
argument_list|(
name|REAL_DAEMON_DIR
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"REAL_DAEMON_DIR %s: %m"
argument_list|,
name|REAL_DAEMON_DIR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"REAL_DAEMON_DIR %s is not a directory"
argument_list|,
name|REAL_DAEMON_DIR
argument_list|)
expr_stmt|;
block|}
comment|/*      * Default is to specify a daemon process name. When daemon@host is      * specified, separate the two parts.      */
if|if
condition|(
operator|(
name|server
operator|=
name|split_at
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|server
operator|=
name|unknown
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|daemon
operator|=
name|strrchr
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|tcpd_warn
argument_list|(
literal|"%s: daemon name normalized to: %s"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|daemon
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|daemon
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
comment|/*      * Default is to specify a client hostname or address. When user@host is      * specified, separate the two parts.      */
if|if
condition|(
operator|(
name|client
operator|=
name|split_at
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|user
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|client
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
name|user
operator|=
name|unknown
expr_stmt|;
block|}
comment|/*      * Analyze the inetd (or tlid) configuration file, so that we can warn      * the user about services that may not be wrapped, services that are not      * configured, or services that are wrapped in an incorrect manner. Allow      * for services that are not run from inetd, or that have tcpd access      * control built into them.      */
name|inetcf
operator|=
name|inet_cfg
argument_list|(
name|inetcf
argument_list|)
expr_stmt|;
name|inet_set
argument_list|(
literal|"portmap"
argument_list|,
name|WR_NOT
argument_list|)
expr_stmt|;
name|inet_set
argument_list|(
literal|"rpcbind"
argument_list|,
name|WR_NOT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inet_get
argument_list|(
name|daemon
argument_list|)
condition|)
block|{
case|case
name|WR_UNKNOWN
case|:
name|tcpd_warn
argument_list|(
literal|"%s: no such process name in %s"
argument_list|,
name|daemon
argument_list|,
name|inetcf
argument_list|)
expr_stmt|;
break|break;
case|case
name|WR_NOT
case|:
name|tcpd_warn
argument_list|(
literal|"%s: service possibly not wrapped"
argument_list|,
name|daemon
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      * Check accessibility of access control files.      */
operator|(
name|void
operator|)
name|check_path
argument_list|(
name|hosts_allow_table
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|check_path
argument_list|(
name|hosts_deny_table
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
comment|/*      * Fill in what we have figured out sofar. Use socket and DNS routines      * for address and name conversions. We attach stdout to the request so      * that banner messages will become visible.      */
name|request_init
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_DAEMON
argument_list|,
name|daemon
argument_list|,
name|RQ_USER
argument_list|,
name|user
argument_list|,
name|RQ_FILE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sock_methods
argument_list|(
operator|&
name|request
argument_list|)
expr_stmt|;
comment|/*      * If a server hostname is specified, insist that the name maps to at      * most one address. eval_hostname() warns the user about name server      * problems, while using the request.server structure as a cache for host      * address and name conversion results.      */
if|if
condition|(
name|NOT_INADDR
argument_list|(
name|server
argument_list|)
operator|==
literal|0
operator|||
name|HOSTNAME_KNOWN
argument_list|(
name|server
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|find_inet_addr
argument_list|(
name|server
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INET6
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|server_sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server_sin
argument_list|)
argument_list|)
expr_stmt|;
name|server_sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
endif|#
directive|endif
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_SERVER_SIN
argument_list|,
operator|&
name|server_sin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
for|for
control|(
name|res
operator|=
name|hp
operator|,
name|count
operator|=
literal|0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
operator|,
name|count
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|server_sin
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|(
name|addr
operator|=
name|hp
operator|->
name|h_addr_list
index|[
name|count
index|]
operator|)
operator|!=
literal|0
condition|;
name|count
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|server_sin
operator|.
name|sin_addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|server_sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	     * Force evaluation of server host name and address. Host name 	     * conflicts will be reported while eval_hostname() does its job. 	     */
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_SERVER_NAME
argument_list|,
literal|""
argument_list|,
name|RQ_SERVER_ADDR
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|STR_EQ
argument_list|(
name|eval_hostname
argument_list|(
name|request
operator|.
name|server
argument_list|)
argument_list|,
name|unknown
argument_list|)
condition|)
name|tcpd_warn
argument_list|(
literal|"host address %s->name lookup failed"
argument_list|,
name|eval_hostaddr
argument_list|(
name|request
operator|.
name|server
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s has more than one address\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Please specify an address instead\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
name|freeaddrinfo
argument_list|(
name|hp
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_SERVER_NAME
argument_list|,
name|server
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * If a client address is specified, we simulate the effect of client      * hostname lookup failure.      */
if|if
condition|(
name|dot_quad_addr
argument_list|(
name|client
argument_list|)
operator|!=
name|INADDR_NONE
condition|)
block|{
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_ADDR
argument_list|,
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcpdmatch
argument_list|(
operator|&
name|request
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
operator||
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|==
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_ADDR
argument_list|,
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcpdmatch
argument_list|(
operator|&
name|request
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Perhaps they are testing special client hostname patterns that aren't      * really host names at all.      */
if|if
condition|(
name|NOT_INADDR
argument_list|(
name|client
argument_list|)
operator|&&
name|HOSTNAME_KNOWN
argument_list|(
name|client
argument_list|)
operator|==
literal|0
condition|)
block|{
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_NAME
argument_list|,
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcpdmatch
argument_list|(
operator|&
name|request
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Otherwise, assume that a client hostname is specified, and insist that      * the address can be looked up. The reason for this requirement is that      * in real life the client address is available (at least with IP). Let      * eval_hostname() figure out if this host is properly registered, while      * using the request.client structure as a cache for host name and      * address conversion results.      */
if|if
condition|(
operator|(
name|hp
operator|=
name|find_inet_addr
argument_list|(
name|client
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_SIN
argument_list|,
operator|&
name|client_sin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|res
operator|=
name|hp
operator|,
name|count
operator|=
literal|0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
operator|,
name|count
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|client_sin
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
comment|/* 	 * getnameinfo() doesn't do reverse lookup against link-local 	 * address.  So, we pass through host name evaluation against 	 * such addresses. 	 */
if|if
condition|(
name|res
operator|->
name|ai_family
operator|!=
name|AF_INET6
operator|||
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|res
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 	     * Force evaluation of client host name and address. Host name 	     * conflicts will be reported while eval_hostname() does its job. 	     */
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_NAME
argument_list|,
literal|""
argument_list|,
name|RQ_CLIENT_ADDR
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|STR_EQ
argument_list|(
name|eval_hostname
argument_list|(
name|request
operator|.
name|client
argument_list|)
argument_list|,
name|unknown
argument_list|)
condition|)
name|tcpd_warn
argument_list|(
literal|"host address %s->name lookup failed"
argument_list|,
name|eval_hostaddr
argument_list|(
name|request
operator|.
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tcpdmatch
argument_list|(
operator|&
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|ai_next
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|hp
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|client_sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client_sin
argument_list|)
argument_list|)
expr_stmt|;
name|client_sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_SIN
argument_list|,
operator|&
name|client_sin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|(
name|addr
operator|=
name|hp
operator|->
name|h_addr_list
index|[
name|count
index|]
operator|)
operator|!=
literal|0
condition|;
name|count
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|client_sin
operator|.
name|sin_addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|client_sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Force evaluation of client host name and address. Host name 	 * conflicts will be reported while eval_hostname() does its job. 	 */
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_NAME
argument_list|,
literal|""
argument_list|,
name|RQ_CLIENT_ADDR
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|STR_EQ
argument_list|(
name|eval_hostname
argument_list|(
name|request
operator|.
name|client
argument_list|)
argument_list|,
name|unknown
argument_list|)
condition|)
name|tcpd_warn
argument_list|(
literal|"host address %s->name lookup failed"
argument_list|,
name|eval_hostaddr
argument_list|(
name|request
operator|.
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|tcpdmatch
argument_list|(
operator|&
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_addr_list
index|[
name|count
operator|+
literal|1
index|]
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Explain how to use this program */
specifier|static
name|void
name|usage
parameter_list|(
name|myname
parameter_list|)
name|char
modifier|*
name|myname
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-d] [-i inet_conf] daemon[@host] [user@]host\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	-d: use allow/deny files in current directory\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	-i: location of inetd.conf file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Print interesting expansions */
specifier|static
name|void
name|expand
parameter_list|(
name|text
parameter_list|,
name|pattern
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|STR_NE
argument_list|(
name|percent_x
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|pattern
argument_list|,
name|request
argument_list|)
argument_list|,
name|unknown
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|text
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Try out a (server,client) pair */
specifier|static
name|void
name|tcpdmatch
parameter_list|(
name|request
parameter_list|)
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|int
name|verdict
decl_stmt|;
comment|/*      * Show what we really know. Suppress uninteresting noise.      */
name|expand
argument_list|(
literal|"client:   hostname"
argument_list|,
literal|"%n"
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"client:   address "
argument_list|,
literal|"%a"
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"client:   username"
argument_list|,
literal|"%u"
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"server:   hostname"
argument_list|,
literal|"%N"
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"server:   address "
argument_list|,
literal|"%A"
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"server:   process "
argument_list|,
literal|"%d"
argument_list|,
name|request
argument_list|)
expr_stmt|;
comment|/*      * Reset stuff that might be changed by options handlers. In dry-run      * mode, extension language routines that would not return should inform      * us of their plan, by clearing the dry_run flag. This is a bit clumsy      * but we must be able to verify hosts with more than one network      * address.      */
name|rfc931_timeout
operator|=
name|RFC931_TIMEOUT
expr_stmt|;
name|allow_severity
operator|=
name|SEVERITY
expr_stmt|;
name|deny_severity
operator|=
name|LOG_WARNING
expr_stmt|;
name|dry_run
operator|=
literal|1
expr_stmt|;
comment|/*      * When paranoid mode is enabled, access is rejected no matter what the      * access control rules say.      */
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|STR_EQ
argument_list|(
name|eval_hostname
argument_list|(
name|request
operator|->
name|client
argument_list|)
argument_list|,
name|paranoid
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"access:   denied (PARANOID mode)\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/*      * Report the access control verdict.      */
name|verdict
operator|=
name|hosts_access
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"access:   %s\n"
argument_list|,
name|dry_run
operator|==
literal|0
condition|?
literal|"delegated"
else|:
name|verdict
condition|?
literal|"granted"
else|:
literal|"denied"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

