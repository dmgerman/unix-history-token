begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_define
define|#
directive|define
name|MAXMATCH
value|256
end_define

begin_comment
comment|/* Maximum match length. */
end_comment

begin_define
define|#
directive|define
name|MINMATCH
value|3
end_define

begin_comment
comment|/* Minimum match length. */
end_comment

begin_comment
comment|/*  * Literal table format:  * +0              +256                      +510  * +---------------+-------------------------+  * | literal code  |       match length      |  * |   0 ... 255   |  MINMATCH ... MAXMATCH  |  * +---------------+-------------------------+  *<---          LT_BITLEN_SIZE         --->  */
end_comment

begin_comment
comment|/* Literal table size. */
end_comment

begin_define
define|#
directive|define
name|LT_BITLEN_SIZE
value|(UCHAR_MAX + 1 + MAXMATCH - MINMATCH + 1)
end_define

begin_comment
comment|/* Position table size.  * Note: this used for both position table and pre literal table.*/
end_comment

begin_define
define|#
directive|define
name|PT_BITLEN_SIZE
value|(3 + 16)
end_define

begin_struct
struct|struct
name|lzh_dec
block|{
comment|/* Decoding status. */
name|int
name|state
decl_stmt|;
comment|/* 	 * Window to see last 8Ki(lh5),32Ki(lh6),64Ki(lh7) bytes of decoded 	 * data. 	 */
name|int
name|w_size
decl_stmt|;
name|int
name|w_mask
decl_stmt|;
comment|/* Window buffer, which is a loop buffer. */
name|unsigned
name|char
modifier|*
name|w_buff
decl_stmt|;
comment|/* The insert position to the window. */
name|int
name|w_pos
decl_stmt|;
comment|/* The position where we can copy decoded code from the window. */
name|int
name|copy_pos
decl_stmt|;
comment|/* The length how many bytes we can copy decoded code from 	 * the window. */
name|int
name|copy_len
decl_stmt|;
comment|/* The remaining bytes that we have not copied decoded data from 	 * the window to an output buffer. */
name|int
name|w_remaining
decl_stmt|;
comment|/* 	 * Bit stream reader. 	 */
struct|struct
name|lzh_br
block|{
define|#
directive|define
name|CACHE_TYPE
value|uint64_t
define|#
directive|define
name|CACHE_BITS
value|(8 * sizeof(CACHE_TYPE))
comment|/* Cache buffer. */
name|CACHE_TYPE
name|cache_buffer
decl_stmt|;
comment|/* Indicates how many bits avail in cache_buffer. */
name|int
name|cache_avail
decl_stmt|;
block|}
name|br
struct|;
comment|/* 	 * Huffman coding. 	 */
struct|struct
name|huffman
block|{
name|int
name|len_size
decl_stmt|;
name|int
name|len_avail
decl_stmt|;
name|int
name|len_bits
decl_stmt|;
name|int
name|freq
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bitlen
decl_stmt|;
comment|/* 		 * Use a index table. It's faster than searching a huffman 		 * coding tree, which is a binary tree. But a use of a large 		 * index table causes L1 cache read miss many times. 		 */
define|#
directive|define
name|HTBL_BITS
value|10
name|int
name|max_bits
decl_stmt|;
name|int
name|shift_bits
decl_stmt|;
name|int
name|tbl_bits
decl_stmt|;
name|int
name|tree_used
decl_stmt|;
name|int
name|tree_avail
decl_stmt|;
comment|/* Direct access table. */
name|uint16_t
modifier|*
name|tbl
decl_stmt|;
comment|/* Binary tree table for extra bits over the direct access. */
struct|struct
name|htree_t
block|{
name|uint16_t
name|left
decl_stmt|;
name|uint16_t
name|right
decl_stmt|;
block|}
modifier|*
name|tree
struct|;
block|}
name|lt
struct|,
name|pt
struct|;
name|int
name|blocks_avail
decl_stmt|;
name|int
name|pos_pt_len_size
decl_stmt|;
name|int
name|pos_pt_len_bits
decl_stmt|;
name|int
name|literal_pt_len_size
decl_stmt|;
name|int
name|literal_pt_len_bits
decl_stmt|;
name|int
name|reading_position
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lzh_stream
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|next_in
decl_stmt|;
name|int64_t
name|avail_in
decl_stmt|;
name|int64_t
name|total_in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|next_out
decl_stmt|;
name|int64_t
name|avail_out
decl_stmt|;
name|int64_t
name|total_out
decl_stmt|;
name|struct
name|lzh_dec
modifier|*
name|ds
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lha
block|{
comment|/* entry_bytes_remaining is the number of bytes we expect.	    */
name|int64_t
name|entry_offset
decl_stmt|;
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
name|int64_t
name|entry_unconsumed
decl_stmt|;
name|uint16_t
name|entry_crc_calculated
decl_stmt|;
name|size_t
name|header_size
decl_stmt|;
comment|/* header size		    */
name|unsigned
name|char
name|level
decl_stmt|;
comment|/* header level		    */
name|char
name|method
index|[
literal|3
index|]
decl_stmt|;
comment|/* compress type	    */
name|int64_t
name|compsize
decl_stmt|;
comment|/* compressed data size	    */
name|int64_t
name|origsize
decl_stmt|;
comment|/* original file size	    */
name|int
name|setflag
decl_stmt|;
define|#
directive|define
name|BIRTHTIME_IS_SET
value|1
define|#
directive|define
name|ATIME_IS_SET
value|2
define|#
directive|define
name|UNIX_MODE_IS_SET
value|4
define|#
directive|define
name|CRC_IS_SET
value|8
name|time_t
name|birthtime
decl_stmt|;
name|long
name|birthtime_tv_nsec
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|long
name|mtime_tv_nsec
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|long
name|atime_tv_nsec
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|int64_t
name|uid
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
name|struct
name|archive_string
name|uname
decl_stmt|;
name|struct
name|archive_string
name|gname
decl_stmt|;
name|uint16_t
name|header_crc
decl_stmt|;
name|uint16_t
name|crc
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|opt_sconv
decl_stmt|;
name|struct
name|archive_string
name|dirname
decl_stmt|;
name|struct
name|archive_string
name|filename
decl_stmt|;
name|struct
name|archive_wstring
name|ws
decl_stmt|;
name|unsigned
name|char
name|dos_attr
decl_stmt|;
comment|/* Flag to mark progress that an archive was read their first header.*/
name|char
name|found_first_header
decl_stmt|;
comment|/* Flag to mark that indicates an empty directory. */
name|char
name|directory
decl_stmt|;
comment|/* Flags to mark progress of decompression. */
name|char
name|decompress_init
decl_stmt|;
name|char
name|end_of_entry
decl_stmt|;
name|char
name|end_of_entry_cleanup
decl_stmt|;
name|char
name|entry_is_compressed
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
name|char
name|format_name
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|lzh_stream
name|strm
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * LHA header common member offset.  */
end_comment

begin_define
define|#
directive|define
name|H_METHOD_OFFSET
value|2
end_define

begin_comment
comment|/* Compress type. */
end_comment

begin_define
define|#
directive|define
name|H_ATTR_OFFSET
value|19
end_define

begin_comment
comment|/* DOS attribute. */
end_comment

begin_define
define|#
directive|define
name|H_LEVEL_OFFSET
value|20
end_define

begin_comment
comment|/* Header Level.  */
end_comment

begin_define
define|#
directive|define
name|H_SIZE
value|22
end_define

begin_comment
comment|/* Minimum header size. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|crc16tbl
index|[
literal|256
index|]
init|=
block|{
literal|0x0000
block|,
literal|0xC0C1
block|,
literal|0xC181
block|,
literal|0x0140
block|,
literal|0xC301
block|,
literal|0x03C0
block|,
literal|0x0280
block|,
literal|0xC241
block|,
literal|0xC601
block|,
literal|0x06C0
block|,
literal|0x0780
block|,
literal|0xC741
block|,
literal|0x0500
block|,
literal|0xC5C1
block|,
literal|0xC481
block|,
literal|0x0440
block|,
literal|0xCC01
block|,
literal|0x0CC0
block|,
literal|0x0D80
block|,
literal|0xCD41
block|,
literal|0x0F00
block|,
literal|0xCFC1
block|,
literal|0xCE81
block|,
literal|0x0E40
block|,
literal|0x0A00
block|,
literal|0xCAC1
block|,
literal|0xCB81
block|,
literal|0x0B40
block|,
literal|0xC901
block|,
literal|0x09C0
block|,
literal|0x0880
block|,
literal|0xC841
block|,
literal|0xD801
block|,
literal|0x18C0
block|,
literal|0x1980
block|,
literal|0xD941
block|,
literal|0x1B00
block|,
literal|0xDBC1
block|,
literal|0xDA81
block|,
literal|0x1A40
block|,
literal|0x1E00
block|,
literal|0xDEC1
block|,
literal|0xDF81
block|,
literal|0x1F40
block|,
literal|0xDD01
block|,
literal|0x1DC0
block|,
literal|0x1C80
block|,
literal|0xDC41
block|,
literal|0x1400
block|,
literal|0xD4C1
block|,
literal|0xD581
block|,
literal|0x1540
block|,
literal|0xD701
block|,
literal|0x17C0
block|,
literal|0x1680
block|,
literal|0xD641
block|,
literal|0xD201
block|,
literal|0x12C0
block|,
literal|0x1380
block|,
literal|0xD341
block|,
literal|0x1100
block|,
literal|0xD1C1
block|,
literal|0xD081
block|,
literal|0x1040
block|,
literal|0xF001
block|,
literal|0x30C0
block|,
literal|0x3180
block|,
literal|0xF141
block|,
literal|0x3300
block|,
literal|0xF3C1
block|,
literal|0xF281
block|,
literal|0x3240
block|,
literal|0x3600
block|,
literal|0xF6C1
block|,
literal|0xF781
block|,
literal|0x3740
block|,
literal|0xF501
block|,
literal|0x35C0
block|,
literal|0x3480
block|,
literal|0xF441
block|,
literal|0x3C00
block|,
literal|0xFCC1
block|,
literal|0xFD81
block|,
literal|0x3D40
block|,
literal|0xFF01
block|,
literal|0x3FC0
block|,
literal|0x3E80
block|,
literal|0xFE41
block|,
literal|0xFA01
block|,
literal|0x3AC0
block|,
literal|0x3B80
block|,
literal|0xFB41
block|,
literal|0x3900
block|,
literal|0xF9C1
block|,
literal|0xF881
block|,
literal|0x3840
block|,
literal|0x2800
block|,
literal|0xE8C1
block|,
literal|0xE981
block|,
literal|0x2940
block|,
literal|0xEB01
block|,
literal|0x2BC0
block|,
literal|0x2A80
block|,
literal|0xEA41
block|,
literal|0xEE01
block|,
literal|0x2EC0
block|,
literal|0x2F80
block|,
literal|0xEF41
block|,
literal|0x2D00
block|,
literal|0xEDC1
block|,
literal|0xEC81
block|,
literal|0x2C40
block|,
literal|0xE401
block|,
literal|0x24C0
block|,
literal|0x2580
block|,
literal|0xE541
block|,
literal|0x2700
block|,
literal|0xE7C1
block|,
literal|0xE681
block|,
literal|0x2640
block|,
literal|0x2200
block|,
literal|0xE2C1
block|,
literal|0xE381
block|,
literal|0x2340
block|,
literal|0xE101
block|,
literal|0x21C0
block|,
literal|0x2080
block|,
literal|0xE041
block|,
literal|0xA001
block|,
literal|0x60C0
block|,
literal|0x6180
block|,
literal|0xA141
block|,
literal|0x6300
block|,
literal|0xA3C1
block|,
literal|0xA281
block|,
literal|0x6240
block|,
literal|0x6600
block|,
literal|0xA6C1
block|,
literal|0xA781
block|,
literal|0x6740
block|,
literal|0xA501
block|,
literal|0x65C0
block|,
literal|0x6480
block|,
literal|0xA441
block|,
literal|0x6C00
block|,
literal|0xACC1
block|,
literal|0xAD81
block|,
literal|0x6D40
block|,
literal|0xAF01
block|,
literal|0x6FC0
block|,
literal|0x6E80
block|,
literal|0xAE41
block|,
literal|0xAA01
block|,
literal|0x6AC0
block|,
literal|0x6B80
block|,
literal|0xAB41
block|,
literal|0x6900
block|,
literal|0xA9C1
block|,
literal|0xA881
block|,
literal|0x6840
block|,
literal|0x7800
block|,
literal|0xB8C1
block|,
literal|0xB981
block|,
literal|0x7940
block|,
literal|0xBB01
block|,
literal|0x7BC0
block|,
literal|0x7A80
block|,
literal|0xBA41
block|,
literal|0xBE01
block|,
literal|0x7EC0
block|,
literal|0x7F80
block|,
literal|0xBF41
block|,
literal|0x7D00
block|,
literal|0xBDC1
block|,
literal|0xBC81
block|,
literal|0x7C40
block|,
literal|0xB401
block|,
literal|0x74C0
block|,
literal|0x7580
block|,
literal|0xB541
block|,
literal|0x7700
block|,
literal|0xB7C1
block|,
literal|0xB681
block|,
literal|0x7640
block|,
literal|0x7200
block|,
literal|0xB2C1
block|,
literal|0xB381
block|,
literal|0x7340
block|,
literal|0xB101
block|,
literal|0x71C0
block|,
literal|0x7080
block|,
literal|0xB041
block|,
literal|0x5000
block|,
literal|0x90C1
block|,
literal|0x9181
block|,
literal|0x5140
block|,
literal|0x9301
block|,
literal|0x53C0
block|,
literal|0x5280
block|,
literal|0x9241
block|,
literal|0x9601
block|,
literal|0x56C0
block|,
literal|0x5780
block|,
literal|0x9741
block|,
literal|0x5500
block|,
literal|0x95C1
block|,
literal|0x9481
block|,
literal|0x5440
block|,
literal|0x9C01
block|,
literal|0x5CC0
block|,
literal|0x5D80
block|,
literal|0x9D41
block|,
literal|0x5F00
block|,
literal|0x9FC1
block|,
literal|0x9E81
block|,
literal|0x5E40
block|,
literal|0x5A00
block|,
literal|0x9AC1
block|,
literal|0x9B81
block|,
literal|0x5B40
block|,
literal|0x9901
block|,
literal|0x59C0
block|,
literal|0x5880
block|,
literal|0x9841
block|,
literal|0x8801
block|,
literal|0x48C0
block|,
literal|0x4980
block|,
literal|0x8941
block|,
literal|0x4B00
block|,
literal|0x8BC1
block|,
literal|0x8A81
block|,
literal|0x4A40
block|,
literal|0x4E00
block|,
literal|0x8EC1
block|,
literal|0x8F81
block|,
literal|0x4F40
block|,
literal|0x8D01
block|,
literal|0x4DC0
block|,
literal|0x4C80
block|,
literal|0x8C41
block|,
literal|0x4400
block|,
literal|0x84C1
block|,
literal|0x8581
block|,
literal|0x4540
block|,
literal|0x8701
block|,
literal|0x47C0
block|,
literal|0x4680
block|,
literal|0x8641
block|,
literal|0x8201
block|,
literal|0x42C0
block|,
literal|0x4380
block|,
literal|0x8341
block|,
literal|0x4100
block|,
literal|0x81C1
block|,
literal|0x8081
block|,
literal|0x4040
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|archive_read_format_lha_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_lha_options
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_lha_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_lha_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_lha_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_lha_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lha_replace_path_separator
parameter_list|(
name|struct
name|lha
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_read_file_header_0
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|lha
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_read_file_header_1
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|lha
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_read_file_header_2
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|lha
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_read_file_header_3
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|lha
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_read_file_extended_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|lha
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|lha_check_header_format
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|lha_dos_time
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|lha_win_time
parameter_list|(
name|uint64_t
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
name|lha_calcsum
parameter_list|(
name|unsigned
name|char
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_parse_linkname
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
name|struct
name|archive_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_read_data_none
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lha_read_data_lzh
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|lha_crc16
parameter_list|(
name|uint16_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_decode_init
parameter_list|(
name|struct
name|lzh_stream
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lzh_decode_free
parameter_list|(
name|struct
name|lzh_stream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_decode
parameter_list|(
name|struct
name|lzh_stream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_br_fillup
parameter_list|(
name|struct
name|lzh_stream
modifier|*
parameter_list|,
name|struct
name|lzh_br
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_huffman_init
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lzh_huffman_free
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_read_pt_bitlen
parameter_list|(
name|struct
name|lzh_stream
modifier|*
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_make_fake_table
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_make_huffman_table
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|lzh_decode_huffman
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_decode_huffman_tree
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_lha
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|lha
modifier|*
name|lha
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_lha"
argument_list|)
expr_stmt|;
name|lha
operator|=
operator|(
expr|struct
name|lha
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lha
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lha
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate lha data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_string_init
argument_list|(
operator|&
name|lha
operator|->
name|ws
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|lha
argument_list|,
literal|"lha"
argument_list|,
name|archive_read_format_lha_bid
argument_list|,
name|archive_read_format_lha_options
argument_list|,
name|archive_read_format_lha_read_header
argument_list|,
name|archive_read_format_lha_read_data
argument_list|,
name|archive_read_format_lha_read_data_skip
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_lha_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|lha
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|lha_check_header_format
parameter_list|(
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|h
decl_stmt|;
name|size_t
name|next_skip_bytes
decl_stmt|;
switch|switch
condition|(
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|3
index|]
condition|)
block|{
comment|/* 	 * "-lh0-" ... "-lh7-" "-lhd-" 	 * "-lzs-" "-lz5-" 	 */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'d'
case|:
case|case
literal|'s'
case|:
name|next_skip_bytes
operator|=
literal|4
expr_stmt|;
comment|/* b0 == 0 means the end of an LHa archive file.	*/
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
index|[
name|H_METHOD_OFFSET
index|]
operator|!=
literal|'-'
operator|||
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|1
index|]
operator|!=
literal|'l'
operator|||
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|4
index|]
operator|!=
literal|'-'
condition|)
break|break;
if|if
condition|(
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|2
index|]
operator|==
literal|'h'
condition|)
block|{
comment|/* "-lh?-" */
if|if
condition|(
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|3
index|]
operator|==
literal|'s'
condition|)
break|break;
if|if
condition|(
name|p
index|[
name|H_LEVEL_OFFSET
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
index|[
name|H_LEVEL_OFFSET
index|]
operator|<=
literal|3
operator|&&
name|p
index|[
name|H_ATTR_OFFSET
index|]
operator|==
literal|0x20
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|2
index|]
operator|==
literal|'z'
condition|)
block|{
comment|/* LArc extensions: -lzs-,-lz4- and -lz5- */
if|if
condition|(
name|p
index|[
name|H_LEVEL_OFFSET
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|3
index|]
operator|==
literal|'s'
operator|||
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|3
index|]
operator|==
literal|'4'
operator|||
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|3
index|]
operator|==
literal|'5'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
literal|'h'
case|:
name|next_skip_bytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|next_skip_bytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|next_skip_bytes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|next_skip_bytes
operator|=
literal|3
expr_stmt|;
break|break;
default|default :
name|next_skip_bytes
operator|=
literal|4
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|next_skip_bytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_lha_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|,
name|offset
decl_stmt|,
name|window
decl_stmt|;
name|size_t
name|next
decl_stmt|;
comment|/* If there's already a better bid than we can ever 	   make, don't bother testing. */
if|if
condition|(
name|best_bid
operator|>
literal|30
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|H_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|lha_check_header_format
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|30
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
comment|/* PE file */
name|offset
operator|=
literal|0
expr_stmt|;
name|window
operator|=
literal|4096
expr_stmt|;
while|while
condition|(
name|offset
operator|<
operator|(
literal|1024
operator|*
literal|20
operator|)
condition|)
block|{
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|window
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining bytes are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
operator|(
name|H_SIZE
operator|+
literal|3
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
operator|+
name|offset
expr_stmt|;
while|while
condition|(
name|p
operator|+
name|H_SIZE
operator|<
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
operator|+
name|bytes_avail
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|lha_check_header_format
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|30
operator|)
return|;
name|p
operator|+=
name|next
expr_stmt|;
block|}
name|offset
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_lha_options
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|lha
modifier|*
name|lha
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
name|lha
operator|=
operator|(
expr|struct
name|lha
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"lha: hdrcharset option needs a character-set name"
argument_list|)
expr_stmt|;
else|else
block|{
name|lha
operator|->
name|opt_sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|opt_sconv
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
else|else
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lha_skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|next
decl_stmt|,
name|skip
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|,
name|window
decl_stmt|;
name|window
operator|=
literal|4096
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|window
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining bytes are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
operator|(
name|H_SIZE
operator|+
literal|3
operator|)
condition|)
goto|goto
name|fatal
goto|;
continue|continue;
block|}
if|if
condition|(
name|bytes
operator|<
name|H_SIZE
condition|)
goto|goto
name|fatal
goto|;
name|p
operator|=
name|h
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|bytes
expr_stmt|;
comment|/* 		 * Scan ahead until we find something that looks 		 * like the lha header. 		 */
while|while
condition|(
name|p
operator|+
name|H_SIZE
operator|<
name|q
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|lha_check_header_format
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|p
operator|+=
name|next
expr_stmt|;
block|}
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
block|}
name|fatal
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Couldn't find out LHa header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|truncated_error
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated LHa header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_lha_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|archive_string
name|linkname
decl_stmt|;
name|struct
name|archive_string
name|pathname
decl_stmt|;
name|struct
name|lha
modifier|*
name|lha
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|signature
decl_stmt|;
name|int
name|err
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_LHA
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"lha"
expr_stmt|;
name|lha
operator|=
operator|(
expr|struct
name|lha
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|lha
operator|->
name|decompress_init
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|end_of_entry
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|end_of_entry_cleanup
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|H_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * LHa archiver added 0 to the tail of its archive file as 		 * the mark of the end of the archive. 		 */
name|signature
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|signature
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|==
name|NULL
operator|||
name|signature
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
block|}
name|signature
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|found_first_header
operator|==
literal|0
operator|&&
name|signature
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|signature
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
comment|/* This is an executable?  Must be self-extracting... 	*/
name|err
operator|=
name|lha_skip_sfx
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|signature
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
block|}
comment|/* signature[0] == 0 means the end of an LHa archive file. */
if|if
condition|(
name|signature
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
comment|/* 	 * Check the header format and method type. 	 */
if|if
condition|(
name|lha_check_header_format
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Bad LHa file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* We've found the first header. */
name|lha
operator|->
name|found_first_header
operator|=
literal|1
expr_stmt|;
comment|/* Set a default value and common data */
name|lha
operator|->
name|header_size
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|level
operator|=
name|p
index|[
name|H_LEVEL_OFFSET
index|]
expr_stmt|;
name|lha
operator|->
name|method
index|[
literal|0
index|]
operator|=
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|1
index|]
expr_stmt|;
name|lha
operator|->
name|method
index|[
literal|1
index|]
operator|=
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|2
index|]
expr_stmt|;
name|lha
operator|->
name|method
index|[
literal|2
index|]
operator|=
name|p
index|[
name|H_METHOD_OFFSET
operator|+
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lha
operator|->
name|method
argument_list|,
literal|"lhd"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|lha
operator|->
name|directory
operator|=
literal|1
expr_stmt|;
else|else
name|lha
operator|->
name|directory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lha
operator|->
name|method
argument_list|,
literal|"lh0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|lha
operator|->
name|method
argument_list|,
literal|"lz4"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|lha
operator|->
name|entry_is_compressed
operator|=
literal|0
expr_stmt|;
else|else
name|lha
operator|->
name|entry_is_compressed
operator|=
literal|1
expr_stmt|;
name|lha
operator|->
name|compsize
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|origsize
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|setflag
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|birthtime
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|birthtime_tv_nsec
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|mtime_tv_nsec
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|atime
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|atime_tv_nsec
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|mode
operator|=
operator|(
name|lha
operator|->
name|directory
operator|)
condition|?
literal|0777
else|:
literal|0666
expr_stmt|;
name|lha
operator|->
name|uid
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|gid
operator|=
literal|0
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|lha
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|lha
operator|->
name|filename
argument_list|)
expr_stmt|;
name|lha
operator|->
name|dos_attr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|opt_sconv
operator|!=
name|NULL
condition|)
name|lha
operator|->
name|sconv
operator|=
name|lha
operator|->
name|opt_sconv
expr_stmt|;
else|else
name|lha
operator|->
name|sconv
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|p
index|[
name|H_LEVEL_OFFSET
index|]
condition|)
block|{
case|case
literal|0
case|:
name|err
operator|=
name|lha_read_file_header_0
argument_list|(
name|a
argument_list|,
name|lha
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|err
operator|=
name|lha_read_file_header_1
argument_list|(
name|a
argument_list|,
name|lha
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|err
operator|=
name|lha_read_file_header_2
argument_list|(
name|a
argument_list|,
name|lha
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|err
operator|=
name|lha_read_file_header_3
argument_list|(
name|a
argument_list|,
name|lha
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported LHa header level %d"
argument_list|,
name|p
index|[
name|H_LEVEL_OFFSET
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
name|lha
operator|->
name|directory
operator|&&
name|archive_strlen
argument_list|(
operator|&
name|lha
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
comment|/* The filename has not been set */
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
comment|/* 	 * Make a pathname from a dirname and a filename. 	 */
name|archive_string_concat
argument_list|(
operator|&
name|lha
operator|->
name|dirname
argument_list|,
operator|&
name|lha
operator|->
name|filename
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|pathname
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|linkname
argument_list|)
expr_stmt|;
name|archive_string_copy
argument_list|(
operator|&
name|pathname
argument_list|,
operator|&
name|lha
operator|->
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lha
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFLNK
condition|)
block|{
comment|/* 	 	 * Extract the symlink-name if it's included in the pathname. 	 	 */
if|if
condition|(
operator|!
name|lha_parse_linkname
argument_list|(
operator|&
name|linkname
argument_list|,
operator|&
name|pathname
argument_list|)
condition|)
block|{
comment|/* We couldn't get the symlink-name. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unknown symlink-name"
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|pathname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|linkname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Make sure a file-type is set. 		 * The mode has been overridden if it is in the extended data. 		 */
name|lha
operator|->
name|mode
operator|=
operator|(
name|lha
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
operator|(
operator|(
name|lha
operator|->
name|directory
operator|)
condition|?
name|AE_IFDIR
else|:
name|AE_IFREG
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lha
operator|->
name|setflag
operator|&
name|UNIX_MODE_IS_SET
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lha
operator|->
name|dos_attr
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|lha
operator|->
name|mode
operator|&=
operator|~
operator|(
literal|0222
operator|)
expr_stmt|;
comment|/* read only. */
comment|/* 	 * Set basic file parameters. 	 */
if|if
condition|(
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
name|pathname
operator|.
name|s
argument_list|,
name|pathname
operator|.
name|length
argument_list|,
name|lha
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|lha
operator|->
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
name|linkname
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|archive_entry_copy_symlink_l
argument_list|(
name|entry
argument_list|,
name|linkname
operator|.
name|s
argument_list|,
name|linkname
operator|.
name|length
argument_list|,
name|lha
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Linkname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Linkname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|lha
operator|->
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
else|else
name|archive_entry_set_symlink
argument_list|(
name|entry
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|linkname
argument_list|)
expr_stmt|;
comment|/* 	 * When a header level is 0, there is a possibility that 	 * a pathname and a symlink has '\' character, a directory 	 * separator in DOS/Windows. So we should convert it to '/'. 	 */
if|if
condition|(
name|p
index|[
name|H_LEVEL_OFFSET
index|]
operator|==
literal|0
condition|)
name|lha_replace_path_separator
argument_list|(
name|lha
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|mode
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|uid
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
name|lha
operator|->
name|uname
argument_list|)
operator|>
literal|0
condition|)
name|archive_entry_set_uname
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|uname
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
name|lha
operator|->
name|gname
argument_list|)
operator|>
literal|0
condition|)
name|archive_entry_set_gname
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|gname
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|setflag
operator|&
name|BIRTHTIME_IS_SET
condition|)
block|{
name|archive_entry_set_birthtime
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|birthtime
argument_list|,
name|lha
operator|->
name|birthtime_tv_nsec
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|birthtime
argument_list|,
name|lha
operator|->
name|birthtime_tv_nsec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|archive_entry_unset_birthtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_unset_ctime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|mtime
argument_list|,
name|lha
operator|->
name|mtime_tv_nsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|setflag
operator|&
name|ATIME_IS_SET
condition|)
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|atime
argument_list|,
name|lha
operator|->
name|atime_tv_nsec
argument_list|)
expr_stmt|;
else|else
name|archive_entry_unset_atime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|directory
operator|||
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
operator|!=
name|NULL
condition|)
name|archive_entry_unset_size
argument_list|(
name|entry
argument_list|)
expr_stmt|;
else|else
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|origsize
argument_list|)
expr_stmt|;
comment|/* 	 * Prepare variables used to read a file content. 	 */
name|lha
operator|->
name|entry_bytes_remaining
operator|=
name|lha
operator|->
name|compsize
expr_stmt|;
name|lha
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|entry_crc_calculated
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This file does not have a content. 	 */
if|if
condition|(
name|lha
operator|->
name|directory
operator|||
name|lha
operator|->
name|compsize
operator|==
literal|0
condition|)
name|lha
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|lha
operator|->
name|format_name
argument_list|,
literal|"lha -%c%c%c-"
argument_list|,
name|lha
operator|->
name|method
index|[
literal|0
index|]
argument_list|,
name|lha
operator|->
name|method
index|[
literal|1
index|]
argument_list|,
name|lha
operator|->
name|method
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
name|lha
operator|->
name|format_name
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replace a DOS path separator '\' by a character '/'.  * Some multi-byte character set have  a character '\' in its second byte.  */
end_comment

begin_function
specifier|static
name|void
name|lha_replace_path_separator
parameter_list|(
name|struct
name|lha
modifier|*
name|lha
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_wstrcpy
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|ws
operator|)
argument_list|,
name|wp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|archive_strlen
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|ws
operator|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lha
operator|->
name|ws
operator|.
name|s
index|[
name|i
index|]
operator|==
literal|L'
expr|\\'
condition|)
name|lha
operator|->
name|ws
operator|.
name|s
index|[
name|i
index|]
operator|=
literal|L'
expr|/'
expr_stmt|;
block|}
name|archive_entry_copy_pathname_w
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wp
operator|=
name|archive_entry_symlink_w
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_wstrcpy
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|ws
operator|)
argument_list|,
name|wp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|archive_strlen
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|ws
operator|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lha
operator|->
name|ws
operator|.
name|s
index|[
name|i
index|]
operator|==
literal|L'
expr|\\'
condition|)
name|lha
operator|->
name|ws
operator|.
name|s
index|[
name|i
index|]
operator|=
literal|L'
expr|/'
expr_stmt|;
block|}
name|archive_entry_copy_symlink_w
argument_list|(
name|entry
argument_list|,
name|lha
operator|->
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Header 0 format  *  * +0              +1         +2               +7                  +11  * +---------------+----------+----------------+-------------------+  * |header size(*1)|header sum|compression type|compressed size(*2)|  * +---------------+----------+----------------+-------------------+  *<---------------------(*1)----------*  *  * +11               +15       +17       +19            +20              +21  * +-----------------+---------+---------+--------------+----------------+  * |uncompressed size|time(DOS)|date(DOS)|attribute(DOS)|header level(=0)|  * +-----------------+---------+---------+--------------+----------------+  * *--------------------------------(*1)---------------------------------*  *  * +21             +22       +22+(*3)   +22+(*3)+2       +22+(*3)+2+(*4)  * +---------------+---------+----------+----------------+------------------+  * |name length(*3)|file name|file CRC16|extra header(*4)|  compressed data |  * +---------------+---------+----------+----------------+------------------+  *<--(*3)-><------(*2)------>  * *----------------------(*1)-------------------------->  *  */
end_comment

begin_define
define|#
directive|define
name|H0_HEADER_SIZE_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|H0_HEADER_SUM_OFFSET
value|1
end_define

begin_define
define|#
directive|define
name|H0_COMP_SIZE_OFFSET
value|7
end_define

begin_define
define|#
directive|define
name|H0_ORIG_SIZE_OFFSET
value|11
end_define

begin_define
define|#
directive|define
name|H0_DOS_TIME_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|H0_NAME_LEN_OFFSET
value|21
end_define

begin_define
define|#
directive|define
name|H0_FILE_NAME_OFFSET
value|22
end_define

begin_define
define|#
directive|define
name|H0_FIXED_SIZE
value|24
end_define

begin_function
specifier|static
name|int
name|lha_read_file_header_0
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|lha
modifier|*
name|lha
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|extdsize
decl_stmt|,
name|namelen
decl_stmt|;
name|unsigned
name|char
name|headersum
decl_stmt|,
name|sum_calculated
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|H0_FIXED_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|lha
operator|->
name|header_size
operator|=
name|p
index|[
name|H0_HEADER_SIZE_OFFSET
index|]
operator|+
literal|2
expr_stmt|;
name|headersum
operator|=
name|p
index|[
name|H0_HEADER_SUM_OFFSET
index|]
expr_stmt|;
name|lha
operator|->
name|compsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H0_COMP_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|origsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H0_ORIG_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|mtime
operator|=
name|lha_dos_time
argument_list|(
name|p
operator|+
name|H0_DOS_TIME_OFFSET
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|p
index|[
name|H0_NAME_LEN_OFFSET
index|]
expr_stmt|;
name|extdsize
operator|=
operator|(
name|int
operator|)
name|lha
operator|->
name|header_size
operator|-
name|H0_FIXED_SIZE
operator|-
name|namelen
expr_stmt|;
if|if
condition|(
operator|(
name|namelen
operator|>
literal|221
operator|||
name|extdsize
operator|<
literal|0
operator|)
operator|&&
name|extdsize
operator|!=
operator|-
literal|2
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid LHa header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|lha
operator|->
name|header_size
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|archive_strncpy
argument_list|(
operator|&
name|lha
operator|->
name|filename
argument_list|,
name|p
operator|+
name|H0_FILE_NAME_OFFSET
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
comment|/* When extdsize == -2, A CRC16 value is not present in the header. */
if|if
condition|(
name|extdsize
operator|>=
literal|0
condition|)
block|{
name|lha
operator|->
name|crc
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|H0_FILE_NAME_OFFSET
operator|+
name|namelen
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|CRC_IS_SET
expr_stmt|;
block|}
name|sum_calculated
operator|=
name|lha_calcsum
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|lha
operator|->
name|header_size
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Read an extended header */
if|if
condition|(
name|extdsize
operator|>
literal|0
condition|)
block|{
comment|/* This extended data is set by 'LHa for UNIX' only. 		 * Maybe fixed size. 		 */
name|p
operator|+=
name|H0_FILE_NAME_OFFSET
operator|+
name|namelen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'U'
operator|&&
name|extdsize
operator|==
literal|12
condition|)
block|{
comment|/* p[1] is a minor version. */
name|lha
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|lha
operator|->
name|mode
operator|=
name|archive_le16dec
argument_list|(
operator|&
name|p
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|lha
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
operator|&
name|p
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|lha
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
operator|&
name|p
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|UNIX_MODE_IS_SET
expr_stmt|;
block|}
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|lha
operator|->
name|header_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum_calculated
operator|!=
name|headersum
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"LHa header sum error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Header 1 format  *  * +0              +1         +2               +7            +11  * +---------------+----------+----------------+-------------+  * |header size(*1)|header sum|compression type|skip size(*2)|  * +---------------+----------+----------------+-------------+  *<---------------(*1)----------*  *  * +11               +15       +17       +19            +20              +21  * +-----------------+---------+---------+--------------+----------------+  * |uncompressed size|time(DOS)|date(DOS)|attribute(DOS)|header level(=1)|  * +-----------------+---------+---------+--------------+----------------+  * *-------------------------------(*1)----------------------------------*  *  * +21             +22       +22+(*3)   +22+(*3)+2  +22+(*3)+3  +22+(*3)+3+(*4)  * +---------------+---------+----------+-----------+-----------+  * |name length(*3)|file name|file CRC16|  creator  |padding(*4)|  * +---------------+---------+----------+-----------+-----------+  *<--(*3)->  * *----------------------------(*1)----------------------------*  *  * +22+(*3)+3+(*4)  +22+(*3)+3+(*4)+2     +22+(*3)+3+(*4)+2+(*5)  * +----------------+---------------------+------------------------+  * |next header size| extended header(*5) |     compressed data    |  * +----------------+---------------------+------------------------+  * *------(*1)-----><--------------------(*2)-------------------->  */
end_comment

begin_define
define|#
directive|define
name|H1_HEADER_SIZE_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|H1_HEADER_SUM_OFFSET
value|1
end_define

begin_define
define|#
directive|define
name|H1_COMP_SIZE_OFFSET
value|7
end_define

begin_define
define|#
directive|define
name|H1_ORIG_SIZE_OFFSET
value|11
end_define

begin_define
define|#
directive|define
name|H1_DOS_TIME_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|H1_NAME_LEN_OFFSET
value|21
end_define

begin_define
define|#
directive|define
name|H1_FILE_NAME_OFFSET
value|22
end_define

begin_define
define|#
directive|define
name|H1_FIXED_SIZE
value|27
end_define

begin_function
specifier|static
name|int
name|lha_read_file_header_1
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|lha
modifier|*
name|lha
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|extdsize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|err2
decl_stmt|;
name|int
name|namelen
decl_stmt|,
name|padding
decl_stmt|;
name|unsigned
name|char
name|headersum
decl_stmt|,
name|sum_calculated
decl_stmt|;
name|err
operator|=
name|ARCHIVE_OK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|H1_FIXED_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|lha
operator|->
name|header_size
operator|=
name|p
index|[
name|H1_HEADER_SIZE_OFFSET
index|]
operator|+
literal|2
expr_stmt|;
name|headersum
operator|=
name|p
index|[
name|H1_HEADER_SUM_OFFSET
index|]
expr_stmt|;
comment|/* Note: An extended header size is included in a compsize. */
name|lha
operator|->
name|compsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H1_COMP_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|origsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H1_ORIG_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|mtime
operator|=
name|lha_dos_time
argument_list|(
name|p
operator|+
name|H1_DOS_TIME_OFFSET
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|p
index|[
name|H1_NAME_LEN_OFFSET
index|]
expr_stmt|;
comment|/* Calculate a padding size. The result will be normally 0 only(?) */
name|padding
operator|=
operator|(
operator|(
name|int
operator|)
name|lha
operator|->
name|header_size
operator|)
operator|-
name|H1_FIXED_SIZE
operator|-
name|namelen
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
literal|230
operator|||
name|padding
operator|<
literal|0
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|lha
operator|->
name|header_size
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namelen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
operator|+
name|H1_FILE_NAME_OFFSET
index|]
operator|==
literal|0xff
condition|)
goto|goto
name|invalid
goto|;
comment|/* Invalid filename. */
block|}
name|archive_strncpy
argument_list|(
operator|&
name|lha
operator|->
name|filename
argument_list|,
name|p
operator|+
name|H1_FILE_NAME_OFFSET
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|lha
operator|->
name|crc
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|H1_FILE_NAME_OFFSET
operator|+
name|namelen
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|CRC_IS_SET
expr_stmt|;
name|sum_calculated
operator|=
name|lha_calcsum
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|lha
operator|->
name|header_size
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Consume used bytes but not include `next header size' data 	 * since it will be consumed in lha_read_file_extended_header(). */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|lha
operator|->
name|header_size
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Read extended headers */
name|err2
operator|=
name|lha_read_file_extended_header
argument_list|(
name|a
argument_list|,
name|lha
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|lha
operator|->
name|compsize
operator|+
literal|2
argument_list|)
argument_list|,
operator|&
name|extdsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|err2
operator|)
return|;
if|if
condition|(
name|err2
operator|<
name|err
condition|)
name|err
operator|=
name|err2
expr_stmt|;
comment|/* Get a real compressed file size. */
name|lha
operator|->
name|compsize
operator|-=
name|extdsize
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|sum_calculated
operator|!=
name|headersum
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"LHa header sum error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|err
operator|)
return|;
name|invalid
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid LHa header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Header 2 format  *  * +0              +2               +7                  +11               +15  * +---------------+----------------+-------------------+-----------------+  * |header size(*1)|compression type|compressed size(*2)|uncompressed size|  * +---------------+----------------+-------------------+-----------------+  *<--------------------------------(*1)---------------------------------*  *  * +15               +19          +20              +21        +23         +24  * +-----------------+------------+----------------+----------+-----------+  * |data/time(time_t)| 0x20 fixed |header level(=2)|file CRC16|  creator  |  * +-----------------+------------+----------------+----------+-----------+  * *---------------------------------(*1)---------------------------------*  *  * +24              +26                 +26+(*3)      +26+(*3)+(*4)  * +----------------+-------------------+-------------+-------------------+  * |next header size|extended header(*3)| padding(*4) |  compressed data  |  * +----------------+-------------------+-------------+-------------------+  * *--------------------------(*1)-------------------><------(*2)------->  *  */
end_comment

begin_define
define|#
directive|define
name|H2_HEADER_SIZE_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|H2_COMP_SIZE_OFFSET
value|7
end_define

begin_define
define|#
directive|define
name|H2_ORIG_SIZE_OFFSET
value|11
end_define

begin_define
define|#
directive|define
name|H2_TIME_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|H2_CRC_OFFSET
value|21
end_define

begin_define
define|#
directive|define
name|H2_FIXED_SIZE
value|24
end_define

begin_function
specifier|static
name|int
name|lha_read_file_header_2
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|lha
modifier|*
name|lha
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|extdsize
decl_stmt|;
name|int
name|err
decl_stmt|,
name|padding
decl_stmt|;
name|uint16_t
name|header_crc
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|H2_FIXED_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|lha
operator|->
name|header_size
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|H2_HEADER_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|compsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H2_COMP_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|origsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H2_ORIG_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H2_TIME_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|crc
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|H2_CRC_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|CRC_IS_SET
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|header_size
operator|<
name|H2_FIXED_SIZE
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid LHa header size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|header_crc
operator|=
name|lha_crc16
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|H2_FIXED_SIZE
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|H2_FIXED_SIZE
argument_list|)
expr_stmt|;
comment|/* Read extended headers */
name|err
operator|=
name|lha_read_file_extended_header
argument_list|(
name|a
argument_list|,
name|lha
argument_list|,
operator|&
name|header_crc
argument_list|,
literal|2
argument_list|,
name|lha
operator|->
name|header_size
operator|-
name|H2_FIXED_SIZE
argument_list|,
operator|&
name|extdsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Calculate a padding size. The result will be normally 0 or 1. */
name|padding
operator|=
operator|(
name|int
operator|)
name|lha
operator|->
name|header_size
operator|-
call|(
name|int
call|)
argument_list|(
name|H2_FIXED_SIZE
operator|+
name|extdsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|padding
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|padding
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|header_crc
operator|=
name|lha_crc16
argument_list|(
name|header_crc
argument_list|,
name|p
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|padding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|header_crc
operator|!=
name|lha
operator|->
name|header_crc
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"LHa header CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Header 3 format  *  * +0           +2               +7                  +11               +15  * +------------+----------------+-------------------+-----------------+  * | 0x04 fixed |compression type|compressed size(*2)|uncompressed size|  * +------------+----------------+-------------------+-----------------+  *<-------------------------------(*1)-------------------------------*  *  * +15               +19          +20              +21        +23         +24  * +-----------------+------------+----------------+----------+-----------+  * |date/time(time_t)| 0x20 fixed |header level(=3)|file CRC16|  creator  |  * +-----------------+------------+----------------+----------+-----------+  * *--------------------------------(*1)----------------------------------*  *  * +24             +28              +32                 +32+(*3)  * +---------------+----------------+-------------------+-----------------+  * |header size(*1)|next header size|extended header(*3)| compressed data |  * +---------------+----------------+-------------------+-----------------+  * *------------------------(*1)-----------------------><------(*2)----->  *  */
end_comment

begin_define
define|#
directive|define
name|H3_FIELD_LEN_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|H3_COMP_SIZE_OFFSET
value|7
end_define

begin_define
define|#
directive|define
name|H3_ORIG_SIZE_OFFSET
value|11
end_define

begin_define
define|#
directive|define
name|H3_TIME_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|H3_CRC_OFFSET
value|21
end_define

begin_define
define|#
directive|define
name|H3_HEADER_SIZE_OFFSET
value|24
end_define

begin_define
define|#
directive|define
name|H3_FIXED_SIZE
value|28
end_define

begin_function
specifier|static
name|int
name|lha_read_file_header_3
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|lha
modifier|*
name|lha
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|extdsize
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint16_t
name|header_crc
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|H3_FIXED_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
if|if
condition|(
name|archive_le16dec
argument_list|(
name|p
operator|+
name|H3_FIELD_LEN_OFFSET
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|invalid
goto|;
name|lha
operator|->
name|header_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H3_HEADER_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|compsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H3_COMP_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|origsize
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H3_ORIG_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|H3_TIME_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|crc
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|H3_CRC_OFFSET
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|CRC_IS_SET
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|header_size
operator|<
name|H3_FIXED_SIZE
operator|+
literal|4
condition|)
goto|goto
name|invalid
goto|;
name|header_crc
operator|=
name|lha_crc16
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|H3_FIXED_SIZE
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|H3_FIXED_SIZE
argument_list|)
expr_stmt|;
comment|/* Read extended headers */
name|err
operator|=
name|lha_read_file_extended_header
argument_list|(
name|a
argument_list|,
name|lha
argument_list|,
operator|&
name|header_crc
argument_list|,
literal|4
argument_list|,
name|lha
operator|->
name|header_size
operator|-
name|H3_FIXED_SIZE
argument_list|,
operator|&
name|extdsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|header_crc
operator|!=
name|lha
operator|->
name|header_crc
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"LHa header CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|err
operator|)
return|;
name|invalid
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid LHa header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extended header format  *  * +0             +2        +3  -- used in header 1 and 2  * +0             +4        +5  -- used in header 3  * +--------------+---------+-------------------+--------------+--  * |ex-header size|header id|        data       |ex-header size| .......  * +--------------+---------+-------------------+--------------+--  *<-------------( ex-header size)------------><-- next extended header --*  *  * If the ex-header size is zero, it is the make of the end of extended  * headers.  *  */
end_comment

begin_function
specifier|static
name|int
name|lha_read_file_extended_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|lha
modifier|*
name|lha
parameter_list|,
name|uint16_t
modifier|*
name|crc
parameter_list|,
name|int
name|sizefield_length
parameter_list|,
name|size_t
name|limitsize
parameter_list|,
name|size_t
modifier|*
name|total_size
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extdheader
decl_stmt|;
name|size_t
name|extdsize
decl_stmt|;
name|size_t
name|datasize
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|extdtype
decl_stmt|;
define|#
directive|define
name|EXT_HEADER_CRC
value|0x00
comment|/* Header CRC and information*/
define|#
directive|define
name|EXT_FILENAME
value|0x01
comment|/* Filename 		    */
define|#
directive|define
name|EXT_DIRECTORY
value|0x02
comment|/* Directory name	    */
define|#
directive|define
name|EXT_DOS_ATTR
value|0x40
comment|/* MS-DOS attribute	    */
define|#
directive|define
name|EXT_TIMESTAMP
value|0x41
comment|/* Windows time stamp	    */
define|#
directive|define
name|EXT_FILESIZE
value|0x42
comment|/* Large file size	    */
define|#
directive|define
name|EXT_TIMEZONE
value|0x43
comment|/* Time zone		    */
define|#
directive|define
name|EXT_UTF16_FILENAME
value|0x44
comment|/* UTF-16 filename 	    */
define|#
directive|define
name|EXT_UTF16_DIRECTORY
value|0x45
comment|/* UTF-16 directory name    */
define|#
directive|define
name|EXT_CODEPAGE
value|0x46
comment|/* Codepage		    */
define|#
directive|define
name|EXT_UNIX_MODE
value|0x50
comment|/* File permission	    */
define|#
directive|define
name|EXT_UNIX_GID_UID
value|0x51
comment|/* gid,uid		    */
define|#
directive|define
name|EXT_UNIX_GNAME
value|0x52
comment|/* Group name		    */
define|#
directive|define
name|EXT_UNIX_UNAME
value|0x53
comment|/* User name		    */
define|#
directive|define
name|EXT_UNIX_MTIME
value|0x54
comment|/* Modified time	    */
define|#
directive|define
name|EXT_OS2_NEW_ATTR
value|0x7f
comment|/* new attribute(OS/2 only) */
define|#
directive|define
name|EXT_NEW_ATTR
value|0xff
comment|/* new attribute	    */
operator|*
name|total_size
operator|=
name|sizefield_length
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Read an extended header size. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|sizefield_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
comment|/* Check if the size is the zero indicates the end of the 		 * extended header. */
if|if
condition|(
name|sizefield_length
operator|==
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
name|extdsize
operator|=
name|archive_le16dec
argument_list|(
name|h
argument_list|)
expr_stmt|;
else|else
name|extdsize
operator|=
name|archive_le32dec
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|extdsize
operator|==
literal|0
condition|)
block|{
comment|/* End of extended header */
if|if
condition|(
name|crc
operator|!=
name|NULL
condition|)
operator|*
name|crc
operator|=
name|lha_crc16
argument_list|(
operator|*
name|crc
argument_list|,
name|h
argument_list|,
name|sizefield_length
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|sizefield_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Sanity check to the extended header size. */
if|if
condition|(
operator|(
operator|(
name|uint64_t
operator|)
operator|*
name|total_size
operator|+
name|extdsize
operator|)
operator|>
operator|(
name|uint64_t
operator|)
name|limitsize
operator|||
name|extdsize
operator|<=
operator|(
name|size_t
operator|)
name|sizefield_length
condition|)
goto|goto
name|invalid
goto|;
comment|/* Read the extended header. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|extdsize
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
operator|*
name|total_size
operator|+=
name|extdsize
expr_stmt|;
name|extdheader
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Get the extended header type. */
name|extdtype
operator|=
name|extdheader
index|[
name|sizefield_length
index|]
expr_stmt|;
comment|/* Calculate an extended data size. */
name|datasize
operator|=
name|extdsize
operator|-
operator|(
literal|1
operator|+
name|sizefield_length
operator|)
expr_stmt|;
comment|/* Skip an extended header size field and type field. */
name|extdheader
operator|+=
name|sizefield_length
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|NULL
operator|&&
name|extdtype
operator|!=
name|EXT_HEADER_CRC
condition|)
operator|*
name|crc
operator|=
name|lha_crc16
argument_list|(
operator|*
name|crc
argument_list|,
name|h
argument_list|,
name|extdsize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|extdtype
condition|)
block|{
case|case
name|EXT_HEADER_CRC
case|:
comment|/* We only use a header CRC. Following data will not 			 * be used. */
if|if
condition|(
name|datasize
operator|>=
literal|2
condition|)
block|{
name|lha
operator|->
name|header_crc
operator|=
name|archive_le16dec
argument_list|(
name|extdheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|NULL
condition|)
block|{
specifier|static
specifier|const
name|char
name|zeros
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
operator|*
name|crc
operator|=
name|lha_crc16
argument_list|(
operator|*
name|crc
argument_list|,
name|h
argument_list|,
name|extdsize
operator|-
name|datasize
argument_list|)
expr_stmt|;
comment|/* CRC value itself as zero */
operator|*
name|crc
operator|=
name|lha_crc16
argument_list|(
operator|*
name|crc
argument_list|,
name|zeros
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|crc
operator|=
name|lha_crc16
argument_list|(
operator|*
name|crc
argument_list|,
name|extdheader
operator|+
literal|2
argument_list|,
name|datasize
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EXT_FILENAME
case|:
if|if
condition|(
name|datasize
operator|==
literal|0
condition|)
block|{
comment|/* maybe directory header */
name|archive_string_empty
argument_list|(
operator|&
name|lha
operator|->
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
name|archive_strncpy
argument_list|(
operator|&
name|lha
operator|->
name|filename
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|extdheader
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_DIRECTORY
case|:
if|if
condition|(
name|datasize
operator|==
literal|0
condition|)
comment|/* no directory name data. exit this case. */
break|break;
name|archive_strncpy
argument_list|(
operator|&
name|lha
operator|->
name|dirname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|extdheader
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
comment|/* 			 * Convert directory delimiter from 0xFF 			 * to '/' for local system. 	 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lha
operator|->
name|dirname
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|lha
operator|->
name|dirname
operator|.
name|s
index|[
name|i
index|]
operator|==
literal|0xFF
condition|)
name|lha
operator|->
name|dirname
operator|.
name|s
index|[
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* Is last character directory separator? */
if|if
condition|(
name|lha
operator|->
name|dirname
operator|.
name|s
index|[
name|lha
operator|->
name|dirname
operator|.
name|length
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
comment|/* invalid directory data */
goto|goto
name|invalid
goto|;
break|break;
case|case
name|EXT_DOS_ATTR
case|:
if|if
condition|(
name|datasize
operator|==
literal|2
condition|)
name|lha
operator|->
name|dos_attr
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|archive_le16dec
argument_list|(
name|extdheader
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_TIMESTAMP
case|:
if|if
condition|(
name|datasize
operator|==
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|3
operator|)
condition|)
block|{
name|lha
operator|->
name|birthtime
operator|=
name|lha_win_time
argument_list|(
name|archive_le64dec
argument_list|(
name|extdheader
argument_list|)
argument_list|,
operator|&
name|lha
operator|->
name|birthtime_tv_nsec
argument_list|)
expr_stmt|;
name|extdheader
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|lha
operator|->
name|mtime
operator|=
name|lha_win_time
argument_list|(
name|archive_le64dec
argument_list|(
name|extdheader
argument_list|)
argument_list|,
operator|&
name|lha
operator|->
name|mtime_tv_nsec
argument_list|)
expr_stmt|;
name|extdheader
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|lha
operator|->
name|atime
operator|=
name|lha_win_time
argument_list|(
name|archive_le64dec
argument_list|(
name|extdheader
argument_list|)
argument_list|,
operator|&
name|lha
operator|->
name|atime_tv_nsec
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|BIRTHTIME_IS_SET
operator||
name|ATIME_IS_SET
expr_stmt|;
block|}
break|break;
case|case
name|EXT_FILESIZE
case|:
if|if
condition|(
name|datasize
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
condition|)
block|{
name|lha
operator|->
name|compsize
operator|=
name|archive_le64dec
argument_list|(
name|extdheader
argument_list|)
expr_stmt|;
name|extdheader
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|lha
operator|->
name|origsize
operator|=
name|archive_le64dec
argument_list|(
name|extdheader
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXT_CODEPAGE
case|:
comment|/* Get an archived filename charset from codepage. 			 * This overwrites the charset specified by 			 * hdrcharset option. */
if|if
condition|(
name|datasize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|struct
name|archive_string
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|charset
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|archive_le32dec
argument_list|(
name|extdheader
argument_list|)
condition|)
block|{
case|case
literal|65001
case|:
comment|/* UTF-8 */
name|charset
operator|=
literal|"UTF-8"
expr_stmt|;
break|break;
default|default:
name|archive_string_sprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"CP%d"
argument_list|,
operator|(
name|int
operator|)
name|archive_le32dec
argument_list|(
name|extdheader
argument_list|)
argument_list|)
expr_stmt|;
name|charset
operator|=
name|cp
operator|.
name|s
expr_stmt|;
break|break;
block|}
name|lha
operator|->
name|sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|charset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|sconv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
case|case
name|EXT_UNIX_MODE
case|:
if|if
condition|(
name|datasize
operator|==
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
block|{
name|lha
operator|->
name|mode
operator|=
name|archive_le16dec
argument_list|(
name|extdheader
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|UNIX_MODE_IS_SET
expr_stmt|;
block|}
break|break;
case|case
name|EXT_UNIX_GID_UID
case|:
if|if
condition|(
name|datasize
operator|==
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
literal|2
operator|)
condition|)
block|{
name|lha
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|extdheader
argument_list|)
expr_stmt|;
name|lha
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|extdheader
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXT_UNIX_GNAME
case|:
if|if
condition|(
name|datasize
operator|>
literal|0
condition|)
name|archive_strncpy
argument_list|(
operator|&
name|lha
operator|->
name|gname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|extdheader
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_UNIX_UNAME
case|:
if|if
condition|(
name|datasize
operator|>
literal|0
condition|)
name|archive_strncpy
argument_list|(
operator|&
name|lha
operator|->
name|uname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|extdheader
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_UNIX_MTIME
case|:
if|if
condition|(
name|datasize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|lha
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|extdheader
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_OS2_NEW_ATTR
case|:
comment|/* This extended header is OS/2 depend. */
if|if
condition|(
name|datasize
operator|==
literal|16
condition|)
block|{
name|lha
operator|->
name|dos_attr
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|archive_le16dec
argument_list|(
name|extdheader
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|lha
operator|->
name|mode
operator|=
name|archive_le16dec
argument_list|(
name|extdheader
operator|+
literal|2
argument_list|)
expr_stmt|;
name|lha
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|extdheader
operator|+
literal|4
argument_list|)
expr_stmt|;
name|lha
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|extdheader
operator|+
literal|6
argument_list|)
expr_stmt|;
name|lha
operator|->
name|birthtime
operator|=
name|archive_le32dec
argument_list|(
name|extdheader
operator|+
literal|8
argument_list|)
expr_stmt|;
name|lha
operator|->
name|atime
operator|=
name|archive_le32dec
argument_list|(
name|extdheader
operator|+
literal|12
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|UNIX_MODE_IS_SET
operator||
name|BIRTHTIME_IS_SET
operator||
name|ATIME_IS_SET
expr_stmt|;
block|}
break|break;
case|case
name|EXT_NEW_ATTR
case|:
if|if
condition|(
name|datasize
operator|==
literal|20
condition|)
block|{
name|lha
operator|->
name|mode
operator|=
operator|(
name|mode_t
operator|)
name|archive_le32dec
argument_list|(
name|extdheader
argument_list|)
expr_stmt|;
name|lha
operator|->
name|gid
operator|=
name|archive_le32dec
argument_list|(
name|extdheader
operator|+
literal|4
argument_list|)
expr_stmt|;
name|lha
operator|->
name|uid
operator|=
name|archive_le32dec
argument_list|(
name|extdheader
operator|+
literal|8
argument_list|)
expr_stmt|;
name|lha
operator|->
name|birthtime
operator|=
name|archive_le32dec
argument_list|(
name|extdheader
operator|+
literal|12
argument_list|)
expr_stmt|;
name|lha
operator|->
name|atime
operator|=
name|archive_le32dec
argument_list|(
name|extdheader
operator|+
literal|16
argument_list|)
expr_stmt|;
name|lha
operator|->
name|setflag
operator||=
name|UNIX_MODE_IS_SET
operator||
name|BIRTHTIME_IS_SET
operator||
name|ATIME_IS_SET
expr_stmt|;
block|}
break|break;
case|case
name|EXT_TIMEZONE
case|:
comment|/* Not supported */
case|case
name|EXT_UTF16_FILENAME
case|:
comment|/* Not supported */
case|case
name|EXT_UTF16_DIRECTORY
case|:
comment|/* Not supported */
default|default:
break|break;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|extdsize
argument_list|)
expr_stmt|;
block|}
name|invalid
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid extended LHa header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_lha_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|lha
modifier|*
name|lha
init|=
operator|(
expr|struct
name|lha
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|lha
operator|->
name|entry_unconsumed
condition|)
block|{
comment|/* Consume as much as the decompressor actually used. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|lha
operator|->
name|entry_unconsumed
argument_list|)
expr_stmt|;
name|lha
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lha
operator|->
name|end_of_entry
condition|)
block|{
if|if
condition|(
operator|!
name|lha
operator|->
name|end_of_entry_cleanup
condition|)
block|{
if|if
condition|(
operator|(
name|lha
operator|->
name|setflag
operator|&
name|CRC_IS_SET
operator|)
operator|&&
name|lha
operator|->
name|crc
operator|!=
name|lha
operator|->
name|entry_crc_calculated
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"LHa data CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* End-of-entry cleanup done. */
name|lha
operator|->
name|end_of_entry_cleanup
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|lha
operator|->
name|entry_offset
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
if|if
condition|(
name|lha
operator|->
name|entry_is_compressed
condition|)
name|r
operator|=
name|lha_read_data_lzh
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
comment|/* No compression. */
name|r
operator|=
name|lha_read_data_none
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a file content in no compression.  *  * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets  * lha->end_of_entry if it consumes all of the data.  */
end_comment

begin_function
specifier|static
name|int
name|lha_read_data_none
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|lha
modifier|*
name|lha
init|=
operator|(
expr|struct
name|lha
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
if|if
condition|(
name|lha
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|lha
operator|->
name|entry_offset
expr_stmt|;
name|lha
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* 	 * Note: '1' here is a performance optimization. 	 * Recall that the decompression layer returns a count of 	 * available bytes; asking for more than that forces the 	 * decompressor to combine reads by copying data. 	 */
operator|*
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated LHa file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|lha
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|lha
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|lha
operator|->
name|entry_crc_calculated
operator|=
name|lha_crc16
argument_list|(
name|lha
operator|->
name|entry_crc_calculated
argument_list|,
operator|*
name|buff
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_avail
expr_stmt|;
operator|*
name|offset
operator|=
name|lha
operator|->
name|entry_offset
expr_stmt|;
name|lha
operator|->
name|entry_offset
operator|+=
name|bytes_avail
expr_stmt|;
name|lha
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
name|lha
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
name|lha
operator|->
name|entry_unconsumed
operator|=
name|bytes_avail
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a file content in LZHUFF encoding.  *  * Returns ARCHIVE_OK if successful, returns ARCHIVE_WARN if compression is  * unsupported, ARCHIVE_FATAL otherwise, sets lha->end_of_entry if it consumes  * all of the data.  */
end_comment

begin_function
specifier|static
name|int
name|lha_read_data_lzh
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|lha
modifier|*
name|lha
init|=
operator|(
expr|struct
name|lha
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* If the buffer hasn't been allocated, allocate it now. */
if|if
condition|(
name|lha
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|lha
operator|->
name|uncompressed_buffer_size
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|lha
operator|->
name|uncompressed_buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|lha
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for lzh decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* If we haven't yet read any data, initialize the decompressor. */
if|if
condition|(
operator|!
name|lha
operator|->
name|decompress_init
condition|)
block|{
name|r
operator|=
name|lzh_decode_init
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|strm
operator|)
argument_list|,
name|lha
operator|->
name|method
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|ARCHIVE_OK
case|:
break|break;
case|case
name|ARCHIVE_FAILED
case|:
comment|/* Unsupported compression. */
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported lzh compression method -%c%c%c-"
argument_list|,
name|lha
operator|->
name|method
index|[
literal|0
index|]
argument_list|,
name|lha
operator|->
name|method
index|[
literal|1
index|]
argument_list|,
name|lha
operator|->
name|method
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* We know compressed size; just skip it. */
name|archive_read_format_lha_read_data_skip
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Couldn't allocate memory "
literal|"for lzh decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* We've initialized decompression for this stream. */
name|lha
operator|->
name|decompress_init
operator|=
literal|1
expr_stmt|;
name|lha
operator|->
name|strm
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|lha
operator|->
name|strm
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Note: '1' here is a performance optimization. 	 * Recall that the decompression layer returns a count of 	 * available bytes; asking for more than that forces the 	 * decompressor to combine reads by copying data. 	 */
name|lha
operator|->
name|strm
operator|.
name|next_in
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated LHa file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|lha
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|lha
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|lha
operator|->
name|strm
operator|.
name|avail_in
operator|=
name|bytes_avail
expr_stmt|;
name|lha
operator|->
name|strm
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|strm
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|lha
operator|->
name|strm
operator|.
name|next_out
operator|=
name|lha
operator|->
name|uncompressed_buffer
expr_stmt|;
name|lha
operator|->
name|strm
operator|.
name|avail_out
operator|=
name|lha
operator|->
name|uncompressed_buffer_size
expr_stmt|;
block|}
name|r
operator|=
name|lzh_decode
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|strm
operator|)
argument_list|,
name|bytes_avail
operator|==
name|lha
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|ARCHIVE_OK
case|:
break|break;
case|case
name|ARCHIVE_EOF
case|:
name|lha
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Bad lzh data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|lha
operator|->
name|entry_unconsumed
operator|=
name|lha
operator|->
name|strm
operator|.
name|total_in
expr_stmt|;
name|lha
operator|->
name|entry_bytes_remaining
operator|-=
name|lha
operator|->
name|strm
operator|.
name|total_in
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|strm
operator|.
name|avail_out
operator|==
literal|0
operator|||
name|lha
operator|->
name|end_of_entry
condition|)
block|{
operator|*
name|offset
operator|=
name|lha
operator|->
name|entry_offset
expr_stmt|;
operator|*
name|size
operator|=
name|lha
operator|->
name|strm
operator|.
name|next_out
operator|-
name|lha
operator|->
name|uncompressed_buffer
expr_stmt|;
operator|*
name|buff
operator|=
name|lha
operator|->
name|uncompressed_buffer
expr_stmt|;
name|lha
operator|->
name|entry_crc_calculated
operator|=
name|lha_crc16
argument_list|(
name|lha
operator|->
name|entry_crc_calculated
argument_list|,
operator|*
name|buff
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
name|lha
operator|->
name|entry_offset
operator|+=
operator|*
name|size
expr_stmt|;
block|}
else|else
block|{
operator|*
name|offset
operator|=
name|lha
operator|->
name|entry_offset
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip a file content.  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_format_lha_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|lha
modifier|*
name|lha
decl_stmt|;
name|int64_t
name|bytes_skipped
decl_stmt|;
name|lha
operator|=
operator|(
expr|struct
name|lha
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|lha
operator|->
name|entry_unconsumed
condition|)
block|{
comment|/* Consume as much as the decompressor actually used. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|lha
operator|->
name|entry_unconsumed
argument_list|)
expr_stmt|;
name|lha
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if we've already read to end of data, we're done. */
if|if
condition|(
name|lha
operator|->
name|end_of_entry_cleanup
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * If the length is at the beginning, we can skip the 	 * compressed data much more quickly. 	 */
name|bytes_skipped
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|lha
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* This entry is finished and done. */
name|lha
operator|->
name|end_of_entry_cleanup
operator|=
name|lha
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_lha_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|lha
modifier|*
name|lha
init|=
operator|(
expr|struct
name|lha
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|lzh_decode_free
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|strm
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lha
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|dirname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|uname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|gname
operator|)
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
operator|(
name|lha
operator|->
name|ws
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lha
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'LHa for UNIX' utility has archived a symbolic-link name after  * a pathname with '|' character.  * This function extracts the symbolic-link name from the pathname.  *  * example.  *   1. a symbolic-name is 'aaa/bb/cc'  *   2. a filename is 'xxx/bbb'  *  then a archived pathname is 'xxx/bbb|aaa/bb/cc'  */
end_comment

begin_function
specifier|static
name|int
name|lha_parse_linkname
parameter_list|(
name|struct
name|archive_string
modifier|*
name|linkname
parameter_list|,
name|struct
name|archive_string
modifier|*
name|pathname
parameter_list|)
block|{
name|char
modifier|*
name|linkptr
decl_stmt|;
name|size_t
name|symlen
decl_stmt|;
name|linkptr
operator|=
name|strchr
argument_list|(
name|pathname
operator|->
name|s
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkptr
operator|!=
name|NULL
condition|)
block|{
name|symlen
operator|=
name|strlen
argument_list|(
name|linkptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
name|linkname
argument_list|,
name|linkptr
operator|+
literal|1
argument_list|,
name|symlen
argument_list|)
expr_stmt|;
operator|*
name|linkptr
operator|=
literal|0
expr_stmt|;
name|pathname
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|pathname
operator|->
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert an MSDOS-style date/time into Unix-style time. */
end_comment

begin_function
specifier|static
name|time_t
name|lha_dos_time
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|msTime
decl_stmt|,
name|msDate
decl_stmt|;
name|struct
name|tm
name|ts
decl_stmt|;
name|msTime
operator|=
name|archive_le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|msDate
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|80
expr_stmt|;
comment|/* Years since 1900. */
name|ts
operator|.
name|tm_mon
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|5
operator|)
operator|&
literal|0x0f
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Month number.     */
name|ts
operator|.
name|tm_mday
operator|=
name|msDate
operator|&
literal|0x1f
expr_stmt|;
comment|/* Day of month.     */
name|ts
operator|.
name|tm_hour
operator|=
operator|(
name|msTime
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|ts
operator|.
name|tm_min
operator|=
operator|(
name|msTime
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|ts
operator|.
name|tm_sec
operator|=
operator|(
name|msTime
operator|<<
literal|1
operator|)
operator|&
literal|0x3e
expr_stmt|;
name|ts
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|mktime
argument_list|(
operator|&
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert an MS-Windows-style date/time into Unix-style time. */
end_comment

begin_function
specifier|static
name|time_t
name|lha_win_time
parameter_list|(
name|uint64_t
name|wintime
parameter_list|,
name|long
modifier|*
name|ns
parameter_list|)
block|{
define|#
directive|define
name|EPOC_TIME
value|ARCHIVE_LITERAL_ULL(116444736000000000)
if|if
condition|(
name|wintime
operator|>=
name|EPOC_TIME
condition|)
block|{
name|wintime
operator|-=
name|EPOC_TIME
expr_stmt|;
comment|/* 1970-01-01 00:00:00 (UTC) */
if|if
condition|(
name|ns
operator|!=
name|NULL
condition|)
operator|*
name|ns
operator|=
call|(
name|long
call|)
argument_list|(
name|wintime
operator|%
literal|10000000
argument_list|)
operator|*
literal|100
expr_stmt|;
return|return
operator|(
name|wintime
operator|/
literal|10000000
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ns
operator|!=
name|NULL
condition|)
operator|*
name|ns
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
name|lha_calcsum
parameter_list|(
name|unsigned
name|char
name|sum
parameter_list|,
specifier|const
name|void
modifier|*
name|pp
parameter_list|,
name|int
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|pp
decl_stmt|;
name|p
operator|+=
name|offset
expr_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
operator|--
name|size
control|)
name|sum
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CRC16
parameter_list|(
name|crc
parameter_list|,
name|v
parameter_list|)
value|do {	\ 	(crc) = crc16tbl[((crc) ^ v)& 0xFF] ^ ((crc)>> 8);	\ } while (0)
end_define

begin_function
specifier|static
name|uint16_t
name|lha_crc16
parameter_list|(
name|uint16_t
name|crc
parameter_list|,
specifier|const
name|void
modifier|*
name|pp
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|buff
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|pp
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|7
case|:
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|6
case|:
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|5
case|:
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|4
case|:
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|3
case|:
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|1
case|:
name|CRC16
argument_list|(
name|crc
argument_list|,
operator|*
name|buff
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|0
case|:
break|break;
block|}
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize LZHUF decoder.  *  * Returns ARCHIVE_OK if initialization was successful.  * Returns ARCHIVE_FAILED if method is unsupported.  * Returns ARCHIVE_FATAL if initialization failed; memory allocation  * error occurred.  */
end_comment

begin_function
specifier|static
name|int
name|lzh_decode_init
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
name|struct
name|lzh_dec
modifier|*
name|ds
decl_stmt|;
name|int
name|w_bits
decl_stmt|,
name|w_size
decl_stmt|;
if|if
condition|(
name|strm
operator|->
name|ds
operator|==
name|NULL
condition|)
block|{
name|strm
operator|->
name|ds
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|strm
operator|->
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|ds
operator|=
name|strm
operator|->
name|ds
expr_stmt|;
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
if|if
condition|(
name|method
operator|==
name|NULL
operator|||
name|method
index|[
literal|0
index|]
operator|!=
literal|'l'
operator|||
name|method
index|[
literal|1
index|]
operator|!=
literal|'h'
condition|)
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
switch|switch
condition|(
name|method
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'5'
case|:
name|w_bits
operator|=
literal|13
expr_stmt|;
comment|/* 8KiB for window */
break|break;
case|case
literal|'6'
case|:
name|w_bits
operator|=
literal|15
expr_stmt|;
comment|/* 32KiB for window */
break|break;
case|case
literal|'7'
case|:
name|w_bits
operator|=
literal|16
expr_stmt|;
comment|/* 64KiB for window */
break|break;
default|default:
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
comment|/* Not supported. */
block|}
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
name|w_size
operator|=
name|ds
operator|->
name|w_size
expr_stmt|;
name|ds
operator|->
name|w_size
operator|=
literal|1U
operator|<<
name|w_bits
expr_stmt|;
name|ds
operator|->
name|w_mask
operator|=
name|ds
operator|->
name|w_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|w_buff
operator|==
name|NULL
operator|||
name|w_size
operator|!=
name|ds
operator|->
name|w_size
condition|)
block|{
name|free
argument_list|(
name|ds
operator|->
name|w_buff
argument_list|)
expr_stmt|;
name|ds
operator|->
name|w_buff
operator|=
name|malloc
argument_list|(
name|ds
operator|->
name|w_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|w_buff
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|ds
operator|->
name|w_buff
argument_list|,
literal|0x20
argument_list|,
name|ds
operator|->
name|w_size
argument_list|)
expr_stmt|;
name|ds
operator|->
name|w_pos
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|w_remaining
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|pos_pt_len_size
operator|=
name|w_bits
operator|+
literal|1
expr_stmt|;
name|ds
operator|->
name|pos_pt_len_bits
operator|=
operator|(
name|w_bits
operator|==
literal|15
operator|||
name|w_bits
operator|==
literal|16
operator|)
condition|?
literal|5
else|:
literal|4
expr_stmt|;
name|ds
operator|->
name|literal_pt_len_size
operator|=
name|PT_BITLEN_SIZE
expr_stmt|;
name|ds
operator|->
name|literal_pt_len_bits
operator|=
literal|5
expr_stmt|;
name|ds
operator|->
name|br
operator|.
name|cache_buffer
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|br
operator|.
name|cache_avail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lzh_huffman_init
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|lt
operator|)
argument_list|,
name|LT_BITLEN_SIZE
argument_list|,
literal|16
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|ds
operator|->
name|lt
operator|.
name|len_bits
operator|=
literal|9
expr_stmt|;
if|if
condition|(
name|lzh_huffman_init
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
argument_list|,
name|PT_BITLEN_SIZE
argument_list|,
literal|16
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|ds
operator|->
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release LZHUF decoder.  */
end_comment

begin_function
specifier|static
name|void
name|lzh_decode_free
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|)
block|{
if|if
condition|(
name|strm
operator|->
name|ds
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|strm
operator|->
name|ds
operator|->
name|w_buff
argument_list|)
expr_stmt|;
name|lzh_huffman_free
argument_list|(
operator|&
operator|(
name|strm
operator|->
name|ds
operator|->
name|lt
operator|)
argument_list|)
expr_stmt|;
name|lzh_huffman_free
argument_list|(
operator|&
operator|(
name|strm
operator|->
name|ds
operator|->
name|pt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strm
operator|->
name|ds
argument_list|)
expr_stmt|;
name|strm
operator|->
name|ds
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bit stream reader.  */
end_comment

begin_comment
comment|/* Check that the cache buffer has enough bits. */
end_comment

begin_define
define|#
directive|define
name|lzh_br_has
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
value|((br)->cache_avail>= n)
end_define

begin_comment
comment|/* Get compressed data by bit. */
end_comment

begin_define
define|#
directive|define
name|lzh_br_bits
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(((uint16_t)((br)->cache_buffer>>		\ 		((br)->cache_avail - (n))))& cache_masks[n])
end_define

begin_define
define|#
directive|define
name|lzh_br_bits_forced
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(((uint16_t)((br)->cache_buffer<<		\ 		((n) - (br)->cache_avail)))& cache_masks[n])
end_define

begin_comment
comment|/* Read ahead to make sure the cache buffer has enough compressed data we  * will use.  *  True  : completed, there is enough data in the cache buffer.  *  False : we met that strm->next_in is empty, we have to get following  *          bytes. */
end_comment

begin_define
define|#
directive|define
name|lzh_br_read_ahead_0
parameter_list|(
name|strm
parameter_list|,
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(lzh_br_has(br, (n)) || lzh_br_fillup(strm, br))
end_define

begin_comment
comment|/*  True  : the cache buffer has some bits as much as we need.  *  False : there are no enough bits in the cache buffer to be used,  *          we have to get following bytes if we could. */
end_comment

begin_define
define|#
directive|define
name|lzh_br_read_ahead
parameter_list|(
name|strm
parameter_list|,
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(lzh_br_read_ahead_0((strm), (br), (n)) || lzh_br_has((br), (n)))
end_define

begin_comment
comment|/* Notify how many bits we consumed. */
end_comment

begin_define
define|#
directive|define
name|lzh_br_consume
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
value|((br)->cache_avail -= (n))
end_define

begin_define
define|#
directive|define
name|lzh_br_unconsume
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
value|((br)->cache_avail += (n))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|cache_masks
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000F
block|,
literal|0x001F
block|,
literal|0x003F
block|,
literal|0x007F
block|,
literal|0x00FF
block|,
literal|0x01FF
block|,
literal|0x03FF
block|,
literal|0x07FF
block|,
literal|0x0FFF
block|,
literal|0x1FFF
block|,
literal|0x3FFF
block|,
literal|0x7FFF
block|,
literal|0xFFFF
block|,
literal|0xFFFF
block|,
literal|0xFFFF
block|,
literal|0xFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Shift away used bits in the cache data and fill it up with following bits.  * Call this when cache buffer does not have enough bits you need.  *  * Returns 1 if the cache buffer is full.  * Returns 0 if the cache buffer is not full; input buffer is empty.  */
end_comment

begin_function
specifier|static
name|int
name|lzh_br_fillup
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|,
name|struct
name|lzh_br
modifier|*
name|br
parameter_list|)
block|{
name|int
name|n
init|=
name|CACHE_BITS
operator|-
name|br
operator|->
name|cache_avail
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|n
operator|>>
literal|3
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>=
literal|8
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|7
index|]
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
literal|8
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
literal|8
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|8
operator|*
literal|8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>=
literal|7
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|4
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|6
index|]
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
literal|7
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
literal|7
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|7
operator|*
literal|8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>=
literal|6
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|5
index|]
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
literal|6
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
literal|6
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|6
operator|*
literal|8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* We have enough compressed data in 			 * the cache buffer.*/
return|return
operator|(
literal|1
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
comment|/* There is not enough compressed data to fill up the 			 * cache buffer. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|8
operator|)
operator||
operator|*
name|strm
operator|->
name|next_in
operator|++
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|--
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|8
expr_stmt|;
name|n
operator|-=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode LZHUF.  *  * 1. Returns ARCHIVE_OK if output buffer or input buffer are empty.  *    Please set available buffer and call this function again.  * 2. Returns ARCHIVE_EOF if decompression has been completed.  * 3. Returns ARCHIVE_FAILED if an error occurred; compressed data  *    is broken or you do not set 'last' flag properly.  * 4. 'last' flag is very important, you must set 1 to the flag if there  *    is no input data. The lha compressed data format does not provide how  *    to know the compressed data is really finished.  *    Note: lha command utility check if the total size of output bytes is  *    reached the uncompressed size recorded in its header. it does not mind  *    that the decoding process is properly finished.  *    GNU ZIP can decompress another compressed file made by SCO LZH compress.  *    it handles EOF as null to fill read buffer with zero until the decoding  *    process meet 2 bytes of zeros at reading a size of a next chunk, so the  *    zeros are treated as the mark of the end of the data although the zeros  *    is dummy, not the file data.  */
end_comment

begin_function_decl
specifier|static
name|int
name|lzh_read_blocks
parameter_list|(
name|struct
name|lzh_stream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzh_decode_blocks
parameter_list|(
name|struct
name|lzh_stream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ST_RD_BLOCK
value|0
end_define

begin_define
define|#
directive|define
name|ST_RD_PT_1
value|1
end_define

begin_define
define|#
directive|define
name|ST_RD_PT_2
value|2
end_define

begin_define
define|#
directive|define
name|ST_RD_PT_3
value|3
end_define

begin_define
define|#
directive|define
name|ST_RD_PT_4
value|4
end_define

begin_define
define|#
directive|define
name|ST_RD_LITERAL_1
value|5
end_define

begin_define
define|#
directive|define
name|ST_RD_LITERAL_2
value|6
end_define

begin_define
define|#
directive|define
name|ST_RD_LITERAL_3
value|7
end_define

begin_define
define|#
directive|define
name|ST_RD_POS_DATA_1
value|8
end_define

begin_define
define|#
directive|define
name|ST_GET_LITERAL
value|9
end_define

begin_define
define|#
directive|define
name|ST_GET_POS_1
value|10
end_define

begin_define
define|#
directive|define
name|ST_GET_POS_2
value|11
end_define

begin_define
define|#
directive|define
name|ST_COPY_DATA
value|12
end_define

begin_function
specifier|static
name|int
name|lzh_decode
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|lzh_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|int64_t
name|avail_in
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|error
condition|)
return|return
operator|(
name|ds
operator|->
name|error
operator|)
return|;
name|avail_in
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ds
operator|->
name|state
operator|<
name|ST_GET_LITERAL
condition|)
name|r
operator|=
name|lzh_read_blocks
argument_list|(
name|strm
argument_list|,
name|last
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|lzh_decode_blocks
argument_list|(
name|strm
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|==
literal|100
condition|)
do|;
name|strm
operator|->
name|total_in
operator|+=
name|avail_in
operator|-
name|strm
operator|->
name|avail_in
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzh_copy_from_window
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|,
name|struct
name|lzh_dec
modifier|*
name|ds
parameter_list|)
block|{
name|size_t
name|copy_bytes
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|w_remaining
operator|==
literal|0
operator|&&
name|ds
operator|->
name|w_pos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|w_pos
operator|-
name|ds
operator|->
name|copy_pos
operator|<=
name|strm
operator|->
name|avail_out
condition|)
name|copy_bytes
operator|=
name|ds
operator|->
name|w_pos
operator|-
name|ds
operator|->
name|copy_pos
expr_stmt|;
else|else
name|copy_bytes
operator|=
operator|(
name|size_t
operator|)
name|strm
operator|->
name|avail_out
expr_stmt|;
name|memcpy
argument_list|(
name|strm
operator|->
name|next_out
argument_list|,
name|ds
operator|->
name|w_buff
operator|+
name|ds
operator|->
name|copy_pos
argument_list|,
name|copy_bytes
argument_list|)
expr_stmt|;
name|ds
operator|->
name|copy_pos
operator|+=
operator|(
name|int
operator|)
name|copy_bytes
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ds
operator|->
name|w_remaining
operator|<=
name|strm
operator|->
name|avail_out
condition|)
name|copy_bytes
operator|=
name|ds
operator|->
name|w_remaining
expr_stmt|;
else|else
name|copy_bytes
operator|=
operator|(
name|size_t
operator|)
name|strm
operator|->
name|avail_out
expr_stmt|;
name|memcpy
argument_list|(
name|strm
operator|->
name|next_out
argument_list|,
name|ds
operator|->
name|w_buff
operator|+
name|ds
operator|->
name|w_size
operator|-
name|ds
operator|->
name|w_remaining
argument_list|,
name|copy_bytes
argument_list|)
expr_stmt|;
name|ds
operator|->
name|w_remaining
operator|-=
operator|(
name|int
operator|)
name|copy_bytes
expr_stmt|;
block|}
name|strm
operator|->
name|next_out
operator|+=
name|copy_bytes
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|-=
name|copy_bytes
expr_stmt|;
name|strm
operator|->
name|total_out
operator|+=
name|copy_bytes
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzh_read_blocks
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|lzh_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|struct
name|lzh_br
modifier|*
name|br
init|=
operator|&
operator|(
name|ds
operator|->
name|br
operator|)
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|rbits
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ds
operator|->
name|state
condition|)
block|{
case|case
name|ST_RD_BLOCK
case|:
comment|/* 			 * Read a block number indicates how many blocks 			 * we will handle. The block is composed of a 			 * literal and a match, sometimes a literal only 			 * in particular, there are no reference data at 			 * the beginning of the decompression. 			 */
if|if
condition|(
operator|!
name|lzh_br_read_ahead_0
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|16
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last
condition|)
comment|/* We need following data. */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|lzh_br_has
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
condition|)
block|{
comment|/* 					 * It seems there are extra bits. 					 *  1. Compressed data is broken. 					 *  2. `last' flag does not properly 					 *     set. 					 */
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|ds
operator|->
name|w_pos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lzh_copy_from_window
argument_list|(
name|strm
argument_list|,
name|ds
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* End of compressed data; we have completely 				 * handled all compressed data. */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
name|ds
operator|->
name|blocks_avail
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|blocks_avail
operator|==
literal|0
condition|)
goto|goto
name|failed
goto|;
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* 			 * Read a literal table compressed in huffman 			 * coding. 			 */
name|ds
operator|->
name|pt
operator|.
name|len_size
operator|=
name|ds
operator|->
name|literal_pt_len_size
expr_stmt|;
name|ds
operator|->
name|pt
operator|.
name|len_bits
operator|=
name|ds
operator|->
name|literal_pt_len_bits
expr_stmt|;
name|ds
operator|->
name|reading_position
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_PT_1
case|:
comment|/* Note: ST_RD_PT_1, ST_RD_PT_2 and ST_RD_PT_4 are 			 * used in reading both a literal table and a 			 * position table. */
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|len_bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Truncated data. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_PT_1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|pt
operator|.
name|len_avail
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|len_bits
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|len_bits
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_PT_2
case|:
if|if
condition|(
name|ds
operator|->
name|pt
operator|.
name|len_avail
operator|==
literal|0
condition|)
block|{
comment|/* There is no bitlen. */
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|len_bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Truncated data.*/
name|ds
operator|->
name|state
operator|=
name|ST_RD_PT_2
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzh_make_fake_table
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
argument_list|,
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|len_bits
argument_list|)
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data. */
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|len_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|reading_position
condition|)
name|ds
operator|->
name|state
operator|=
name|ST_GET_LITERAL
expr_stmt|;
else|else
name|ds
operator|->
name|state
operator|=
name|ST_RD_LITERAL_1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ds
operator|->
name|pt
operator|.
name|len_avail
operator|>
name|ds
operator|->
name|pt
operator|.
name|len_size
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data. */
name|ds
operator|->
name|loop
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|ds
operator|->
name|pt
operator|.
name|freq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|pt
operator|.
name|freq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|pt
operator|.
name|len_avail
operator|<
literal|3
operator|||
name|ds
operator|->
name|pt
operator|.
name|len_size
operator|==
name|ds
operator|->
name|pos_pt_len_size
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_PT_4
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|ST_RD_PT_3
case|:
name|ds
operator|->
name|loop
operator|=
name|lzh_read_pt_bitlen
argument_list|(
name|strm
argument_list|,
name|ds
operator|->
name|loop
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|loop
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|loop
operator|<
literal|0
operator|||
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data. */
comment|/* Not completed, get following data. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_PT_3
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* There are some null in bitlen of the literal. */
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Truncated data. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_PT_3
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|c
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
name|ds
operator|->
name|pt
operator|.
name|len_avail
operator|-
literal|3
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data. */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|c
operator|--
operator|>
literal|0
condition|;
control|)
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|loop
operator|=
name|i
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_PT_4
case|:
name|ds
operator|->
name|loop
operator|=
name|lzh_read_pt_bitlen
argument_list|(
name|strm
argument_list|,
name|ds
operator|->
name|loop
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|len_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|loop
operator|<
name|ds
operator|->
name|pt
operator|.
name|len_avail
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|loop
operator|<
literal|0
operator|||
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data. */
comment|/* Not completed, get following data. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_PT_4
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzh_make_huffman_table
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data */
if|if
condition|(
name|ds
operator|->
name|reading_position
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_GET_LITERAL
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|ST_RD_LITERAL_1
case|:
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|lt
operator|.
name|len_bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Truncated data. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_LITERAL_1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|lt
operator|.
name|len_avail
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|lt
operator|.
name|len_bits
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|lt
operator|.
name|len_bits
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_LITERAL_2
case|:
if|if
condition|(
name|ds
operator|->
name|lt
operator|.
name|len_avail
operator|==
literal|0
condition|)
block|{
comment|/* There is no bitlen. */
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|lt
operator|.
name|len_bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Truncated data.*/
name|ds
operator|->
name|state
operator|=
name|ST_RD_LITERAL_2
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzh_make_fake_table
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|lt
operator|)
argument_list|,
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|lt
operator|.
name|len_bits
argument_list|)
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data */
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|lt
operator|.
name|len_bits
argument_list|)
expr_stmt|;
name|ds
operator|->
name|state
operator|=
name|ST_RD_POS_DATA_1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ds
operator|->
name|lt
operator|.
name|len_avail
operator|>
name|ds
operator|->
name|lt
operator|.
name|len_size
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data */
name|ds
operator|->
name|loop
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|ds
operator|->
name|lt
operator|.
name|freq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|lt
operator|.
name|freq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_LITERAL_3
case|:
name|i
operator|=
name|ds
operator|->
name|loop
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|ds
operator|->
name|lt
operator|.
name|len_avail
condition|)
block|{
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|max_bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Truncated data.*/
name|ds
operator|->
name|loop
operator|=
name|i
expr_stmt|;
name|ds
operator|->
name|state
operator|=
name|ST_RD_LITERAL_3
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|rbits
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|max_bits
argument_list|)
expr_stmt|;
name|c
operator|=
name|lzh_decode_huffman
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
argument_list|,
name|rbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|2
condition|)
block|{
comment|/* Note: 'c' will never be more than 					 * eighteen since it's limited by 					 * PT_BITLEN_SIZE, which is being set 					 * to ds->pt.len_size through 					 * ds->literal_pt_len_size. */
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|2
expr_stmt|;
name|ds
operator|->
name|lt
operator|.
name|freq
index|[
name|c
index|]
operator|++
expr_stmt|;
name|ds
operator|->
name|lt
operator|.
name|bitlen
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|ds
operator|->
name|lt
operator|.
name|bitlen
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* c == 1 or c == 2 */
name|int
name|n
init|=
operator|(
name|c
operator|==
literal|1
operator|)
condition|?
literal|4
else|:
literal|9
decl_stmt|;
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
operator|+
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
comment|/* Truncated data. */
goto|goto
name|failed
goto|;
name|ds
operator|->
name|loop
operator|=
name|i
expr_stmt|;
name|ds
operator|->
name|state
operator|=
name|ST_RD_LITERAL_3
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|c
operator|+=
operator|(
name|n
operator|==
literal|4
operator|)
condition|?
literal|3
else|:
literal|20
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|c
operator|>
name|ds
operator|->
name|lt
operator|.
name|len_avail
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data */
name|memset
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|lt
operator|.
name|bitlen
index|[
name|i
index|]
operator|)
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|i
operator|+=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
name|ds
operator|->
name|lt
operator|.
name|len_avail
operator|||
operator|!
name|lzh_make_huffman_table
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|lt
operator|)
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Invalid data */
comment|/* FALL THROUGH */
case|case
name|ST_RD_POS_DATA_1
case|:
comment|/* 			 * Read a position table compressed in huffman 			 * coding. 			 */
name|ds
operator|->
name|pt
operator|.
name|len_size
operator|=
name|ds
operator|->
name|pos_pt_len_size
expr_stmt|;
name|ds
operator|->
name|pt
operator|.
name|len_bits
operator|=
name|ds
operator|->
name|pos_pt_len_bits
expr_stmt|;
name|ds
operator|->
name|reading_position
operator|=
literal|1
expr_stmt|;
name|ds
operator|->
name|state
operator|=
name|ST_RD_PT_1
expr_stmt|;
break|break;
case|case
name|ST_GET_LITERAL
case|:
return|return
operator|(
literal|100
operator|)
return|;
block|}
block|}
name|failed
label|:
return|return
operator|(
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FAILED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzh_decode_blocks
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|lzh_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|struct
name|lzh_br
name|bre
init|=
name|ds
operator|->
name|br
decl_stmt|;
name|struct
name|huffman
modifier|*
name|lt
init|=
operator|&
operator|(
name|ds
operator|->
name|lt
operator|)
decl_stmt|;
name|struct
name|huffman
modifier|*
name|pt
init|=
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|w_buff
init|=
name|ds
operator|->
name|w_buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|lt_bitlen
init|=
name|lt
operator|->
name|bitlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pt_bitlen
init|=
name|pt
operator|->
name|bitlen
decl_stmt|;
name|int
name|blocks_avail
init|=
name|ds
operator|->
name|blocks_avail
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
name|int
name|copy_len
init|=
name|ds
operator|->
name|copy_len
decl_stmt|,
name|copy_pos
init|=
name|ds
operator|->
name|copy_pos
decl_stmt|;
name|int
name|w_pos
init|=
name|ds
operator|->
name|w_pos
decl_stmt|,
name|w_mask
init|=
name|ds
operator|->
name|w_mask
decl_stmt|,
name|w_size
init|=
name|ds
operator|->
name|w_size
decl_stmt|;
name|int
name|lt_max_bits
init|=
name|lt
operator|->
name|max_bits
decl_stmt|,
name|pt_max_bits
init|=
name|pt
operator|->
name|max_bits
decl_stmt|;
name|int
name|state
init|=
name|ds
operator|->
name|state
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|w_remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lzh_copy_from_window
argument_list|(
name|strm
argument_list|,
name|ds
argument_list|)
condition|)
goto|goto
name|next_data
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ST_GET_LITERAL
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|blocks_avail
operator|==
literal|0
condition|)
block|{
comment|/* We have decoded all blocks. 					 * Let's handle next blocks. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_BLOCK
expr_stmt|;
name|ds
operator|->
name|br
operator|=
name|bre
expr_stmt|;
name|ds
operator|->
name|blocks_avail
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|w_pos
operator|=
name|w_pos
expr_stmt|;
name|ds
operator|->
name|copy_pos
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|100
operator|)
return|;
block|}
comment|/* lzh_br_read_ahead() always try to fill the 				 * cache buffer up. In specific situation we 				 * are close to the end of the data, the cache 				 * buffer will not be full and thus we have to 				 * determine if the cache buffer has some bits 				 * as much as we need after lzh_br_read_ahead() 				 * failed. */
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|lt_max_bits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last
condition|)
goto|goto
name|next_data
goto|;
comment|/* Remaining bits are less than 					 * maximum bits(lt.max_bits) but maybe 					 * it still remains as much as we need, 					 * so we should try to use it with 					 * dummy bits. */
name|c
operator|=
name|lzh_decode_huffman
argument_list|(
name|lt
argument_list|,
name|lzh_br_bits_forced
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lzh_br_has
argument_list|(
operator|&
name|bre
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Over read. */
block|}
else|else
block|{
name|c
operator|=
name|lzh_decode_huffman
argument_list|(
name|lt
argument_list|,
name|lzh_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|blocks_avail
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|>
name|UCHAR_MAX
condition|)
comment|/* Current block is a match data. */
break|break;
comment|/* 				 * 'c' is exactly a literal code. 				 */
comment|/* Save a decoded code to reference it 				 * afterward. */
name|w_buff
index|[
name|w_pos
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
name|w_pos
operator|>=
name|w_size
condition|)
block|{
name|w_pos
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|w_remaining
operator|=
name|w_size
expr_stmt|;
if|if
condition|(
operator|!
name|lzh_copy_from_window
argument_list|(
name|strm
argument_list|,
name|ds
argument_list|)
condition|)
goto|goto
name|next_data
goto|;
block|}
block|}
comment|/* 'c' is the length of a match pattern we have 			 * already extracted, which has be stored in 			 * window(ds->w_buff). */
name|copy_len
operator|=
name|c
operator|-
operator|(
name|UCHAR_MAX
operator|+
literal|1
operator|)
operator|+
name|MINMATCH
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_GET_POS_1
case|:
comment|/* 			 * Get a reference position.  			 */
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|pt_max_bits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|state
operator|=
name|ST_GET_POS_1
expr_stmt|;
name|ds
operator|->
name|copy_len
operator|=
name|copy_len
expr_stmt|;
goto|goto
name|next_data
goto|;
block|}
name|copy_pos
operator|=
name|lzh_decode_huffman
argument_list|(
name|pt
argument_list|,
name|lzh_br_bits_forced
argument_list|(
operator|&
name|bre
argument_list|,
name|pt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|pt_bitlen
index|[
name|copy_pos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lzh_br_has
argument_list|(
operator|&
name|bre
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Over read. */
block|}
else|else
block|{
name|copy_pos
operator|=
name|lzh_decode_huffman
argument_list|(
name|pt
argument_list|,
name|lzh_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|pt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|pt_bitlen
index|[
name|copy_pos
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|ST_GET_POS_2
case|:
if|if
condition|(
name|copy_pos
operator|>
literal|1
condition|)
block|{
comment|/* We need an additional adjustment number to 				 * the position. */
name|int
name|p
init|=
name|copy_pos
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
comment|/* Truncated data.*/
name|state
operator|=
name|ST_GET_POS_2
expr_stmt|;
name|ds
operator|->
name|copy_len
operator|=
name|copy_len
expr_stmt|;
name|ds
operator|->
name|copy_pos
operator|=
name|copy_pos
expr_stmt|;
goto|goto
name|next_data
goto|;
block|}
name|copy_pos
operator|=
operator|(
literal|1
operator|<<
name|p
operator|)
operator|+
name|lzh_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lzh_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* The position is actually a distance from the last 			 * code we had extracted and thus we have to convert 			 * it to a position of the window. */
name|copy_pos
operator|=
operator|(
name|w_pos
operator|-
name|copy_pos
operator|-
literal|1
operator|)
operator|&
name|w_mask
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_COPY_DATA
case|:
comment|/* 			 * Copy `copy_len' bytes as extracted data from 			 * the window into the output buffer. 			 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|copy_len
expr_stmt|;
if|if
condition|(
name|copy_pos
operator|>
name|w_pos
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|w_size
operator|-
name|copy_pos
condition|)
name|l
operator|=
name|w_size
operator|-
name|copy_pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l
operator|>
name|w_size
operator|-
name|w_pos
condition|)
name|l
operator|=
name|w_size
operator|-
name|w_pos
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|copy_pos
operator|+
name|l
operator|<
name|w_pos
operator|)
operator|||
operator|(
name|w_pos
operator|+
name|l
operator|<
name|copy_pos
operator|)
condition|)
block|{
comment|/* No overlap. */
name|memcpy
argument_list|(
name|w_buff
operator|+
name|w_pos
argument_list|,
name|w_buff
operator|+
name|copy_pos
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|li
decl_stmt|;
name|d
operator|=
name|w_buff
operator|+
name|w_pos
expr_stmt|;
name|s
operator|=
name|w_buff
operator|+
name|copy_pos
expr_stmt|;
for|for
control|(
name|li
operator|=
literal|0
init|;
name|li
operator|<
name|l
condition|;
name|li
operator|++
control|)
name|d
index|[
name|li
index|]
operator|=
name|s
index|[
name|li
index|]
expr_stmt|;
block|}
name|w_pos
operator|=
operator|(
name|w_pos
operator|+
name|l
operator|)
operator|&
name|w_mask
expr_stmt|;
if|if
condition|(
name|w_pos
operator|==
literal|0
condition|)
block|{
name|ds
operator|->
name|w_remaining
operator|=
name|w_size
expr_stmt|;
if|if
condition|(
operator|!
name|lzh_copy_from_window
argument_list|(
name|strm
argument_list|,
name|ds
argument_list|)
condition|)
block|{
if|if
condition|(
name|copy_len
operator|<=
name|l
condition|)
name|state
operator|=
name|ST_GET_LITERAL
expr_stmt|;
else|else
block|{
name|state
operator|=
name|ST_COPY_DATA
expr_stmt|;
name|ds
operator|->
name|copy_len
operator|=
name|copy_len
operator|-
name|l
expr_stmt|;
name|ds
operator|->
name|copy_pos
operator|=
operator|(
name|copy_pos
operator|+
name|l
operator|)
operator|&
name|w_mask
expr_stmt|;
block|}
goto|goto
name|next_data
goto|;
block|}
block|}
if|if
condition|(
name|copy_len
operator|<=
name|l
condition|)
comment|/* A copy of current pattern ended. */
break|break;
name|copy_len
operator|-=
name|l
expr_stmt|;
name|copy_pos
operator|=
operator|(
name|copy_pos
operator|+
name|l
operator|)
operator|&
name|w_mask
expr_stmt|;
block|}
name|state
operator|=
name|ST_GET_LITERAL
expr_stmt|;
break|break;
block|}
block|}
name|failed
label|:
return|return
operator|(
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FAILED
operator|)
return|;
name|next_data
label|:
name|ds
operator|->
name|br
operator|=
name|bre
expr_stmt|;
name|ds
operator|->
name|blocks_avail
operator|=
name|blocks_avail
expr_stmt|;
name|ds
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|ds
operator|->
name|w_pos
operator|=
name|w_pos
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzh_huffman_init
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|,
name|size_t
name|len_size
parameter_list|,
name|int
name|tbl_bits
parameter_list|)
block|{
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|hf
operator|->
name|bitlen
operator|==
name|NULL
condition|)
block|{
name|hf
operator|->
name|bitlen
operator|=
name|malloc
argument_list|(
name|len_size
operator|*
sizeof|sizeof
argument_list|(
name|hf
operator|->
name|bitlen
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|bitlen
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|hf
operator|->
name|tbl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tbl_bits
operator|<
name|HTBL_BITS
condition|)
name|bits
operator|=
name|tbl_bits
expr_stmt|;
else|else
name|bits
operator|=
name|HTBL_BITS
expr_stmt|;
name|hf
operator|->
name|tbl
operator|=
name|malloc
argument_list|(
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hf
operator|->
name|tbl
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tbl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|hf
operator|->
name|tree
operator|==
name|NULL
operator|&&
name|tbl_bits
operator|>
name|HTBL_BITS
condition|)
block|{
name|hf
operator|->
name|tree_avail
operator|=
literal|1
operator|<<
operator|(
name|tbl_bits
operator|-
name|HTBL_BITS
operator|+
literal|4
operator|)
expr_stmt|;
name|hf
operator|->
name|tree
operator|=
name|malloc
argument_list|(
name|hf
operator|->
name|tree_avail
operator|*
sizeof|sizeof
argument_list|(
name|hf
operator|->
name|tree
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|hf
operator|->
name|len_size
operator|=
operator|(
name|int
operator|)
name|len_size
expr_stmt|;
name|hf
operator|->
name|tbl_bits
operator|=
name|tbl_bits
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lzh_huffman_free
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|)
block|{
name|free
argument_list|(
name|hf
operator|->
name|bitlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hf
operator|->
name|tbl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hf
operator|->
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzh_read_pt_bitlen
parameter_list|(
name|struct
name|lzh_stream
modifier|*
name|strm
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|struct
name|lzh_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|struct
name|lzh_br
modifier|*
name|br
init|=
operator|&
operator|(
name|ds
operator|->
name|br
operator|)
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
control|)
block|{
comment|/* 		 *  bit pattern     the number we need 		 *     000           ->  0 		 *     001           ->  1 		 *     010           ->  2 		 *     ... 		 *     110           ->  6 		 *     1110          ->  7 		 *     11110         ->  8 		 *     ... 		 *     1111111111110 ->  16 		 */
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|3
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
operator|)
operator|==
literal|7
condition|)
block|{
name|int
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|lzh_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|13
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|d
operator|=
name|lzh_br_bits
argument_list|(
name|br
argument_list|,
literal|13
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
operator|&
literal|0x200
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|d
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|16
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid data. */
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
name|c
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|lzh_br_consume
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|ds
operator|->
name|pt
operator|.
name|freq
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzh_make_fake_table
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|,
name|uint16_t
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
name|hf
operator|->
name|len_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hf
operator|->
name|tbl
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|hf
operator|->
name|max_bits
operator|=
literal|0
expr_stmt|;
name|hf
operator|->
name|shift_bits
operator|=
literal|0
expr_stmt|;
name|hf
operator|->
name|bitlen
index|[
name|hf
operator|->
name|tbl
index|[
literal|0
index|]
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a huffman coding table.  */
end_comment

begin_function
specifier|static
name|int
name|lzh_make_huffman_table
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|)
block|{
name|uint16_t
modifier|*
name|tbl
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|bitlen
decl_stmt|;
name|int
name|bitptn
index|[
literal|17
index|]
decl_stmt|,
name|weight
index|[
literal|17
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxbits
init|=
literal|0
decl_stmt|,
name|ptn
decl_stmt|,
name|tbl_size
decl_stmt|,
name|w
decl_stmt|;
name|int
name|diffbits
decl_stmt|,
name|len_avail
decl_stmt|;
comment|/* 	 * Initialize bit patterns. 	 */
name|ptn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|w
operator|=
literal|1
operator|<<
literal|15
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
operator|,
name|w
operator|>>=
literal|1
control|)
block|{
name|bitptn
index|[
name|i
index|]
operator|=
name|ptn
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|freq
index|[
name|i
index|]
condition|)
block|{
name|ptn
operator|+=
name|hf
operator|->
name|freq
index|[
name|i
index|]
operator|*
name|w
expr_stmt|;
name|maxbits
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ptn
operator|!=
literal|0x10000
operator|||
name|maxbits
operator|>
name|hf
operator|->
name|tbl_bits
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|hf
operator|->
name|max_bits
operator|=
name|maxbits
expr_stmt|;
comment|/* 	 * Cut out extra bits which we won't house in the table. 	 * This preparation reduces the same calculation in the for-loop 	 * making the table. 	 */
if|if
condition|(
name|maxbits
operator|<
literal|16
condition|)
block|{
name|int
name|ebits
init|=
literal|16
operator|-
name|maxbits
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxbits
condition|;
name|i
operator|++
control|)
block|{
name|bitptn
index|[
name|i
index|]
operator|>>=
name|ebits
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|>>=
name|ebits
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxbits
operator|>
name|HTBL_BITS
condition|)
block|{
name|int
name|htbl_max
decl_stmt|;
name|uint16_t
modifier|*
name|p
decl_stmt|;
name|diffbits
operator|=
name|maxbits
operator|-
name|HTBL_BITS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|HTBL_BITS
condition|;
name|i
operator|++
control|)
block|{
name|bitptn
index|[
name|i
index|]
operator|>>=
name|diffbits
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|>>=
name|diffbits
expr_stmt|;
block|}
name|htbl_max
operator|=
name|bitptn
index|[
name|HTBL_BITS
index|]
operator|+
name|weight
index|[
name|HTBL_BITS
index|]
operator|*
name|hf
operator|->
name|freq
index|[
name|HTBL_BITS
index|]
expr_stmt|;
name|p
operator|=
operator|&
operator|(
name|hf
operator|->
name|tbl
index|[
name|htbl_max
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
operator|&
name|hf
operator|->
name|tbl
index|[
literal|1U
operator|<<
name|HTBL_BITS
index|]
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|diffbits
operator|=
literal|0
expr_stmt|;
name|hf
operator|->
name|shift_bits
operator|=
name|diffbits
expr_stmt|;
comment|/* 	 * Make the table. 	 */
name|tbl_size
operator|=
literal|1
operator|<<
name|HTBL_BITS
expr_stmt|;
name|tbl
operator|=
name|hf
operator|->
name|tbl
expr_stmt|;
name|bitlen
operator|=
name|hf
operator|->
name|bitlen
expr_stmt|;
name|len_avail
operator|=
name|hf
operator|->
name|len_avail
expr_stmt|;
name|hf
operator|->
name|tree_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len_avail
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cnt
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|struct
name|htree_t
modifier|*
name|ht
decl_stmt|;
if|if
condition|(
name|bitlen
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Get a bit pattern */
name|len
operator|=
name|bitlen
index|[
name|i
index|]
expr_stmt|;
name|ptn
operator|=
name|bitptn
index|[
name|len
index|]
expr_stmt|;
name|cnt
operator|=
name|weight
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|HTBL_BITS
condition|)
block|{
comment|/* Calculate next bit pattern */
if|if
condition|(
operator|(
name|bitptn
index|[
name|len
index|]
operator|=
name|ptn
operator|+
name|cnt
operator|)
operator|>
name|tbl_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
comment|/* Update the table */
name|p
operator|=
operator|&
operator|(
name|tbl
index|[
name|ptn
index|]
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
name|p
index|[
name|cnt
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * A bit length is too big to be housed to a direct table, 		 * so we use a tree model for its extra bits. 		 */
name|bitptn
index|[
name|len
index|]
operator|=
name|ptn
operator|+
name|cnt
expr_stmt|;
name|bit
operator|=
literal|1U
operator|<<
operator|(
name|diffbits
operator|-
literal|1
operator|)
expr_stmt|;
name|extlen
operator|=
name|len
operator|-
name|HTBL_BITS
expr_stmt|;
name|p
operator|=
operator|&
operator|(
name|tbl
index|[
name|ptn
operator|>>
name|diffbits
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
expr_stmt|;
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|hf
operator|->
name|tree_used
operator|++
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree_used
operator|>
name|hf
operator|->
name|tree_avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ht
operator|->
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|<
name|len_avail
operator|||
operator|*
name|p
operator|>=
operator|(
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
operator|*
name|p
operator|-
name|len_avail
index|]
operator|)
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|extlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ptn
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|ht
operator|->
name|left
operator|<
name|len_avail
condition|)
block|{
name|ht
operator|->
name|left
operator|=
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
expr_stmt|;
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|hf
operator|->
name|tree_used
operator|++
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree_used
operator|>
name|hf
operator|->
name|tree_avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ht
operator|->
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|ht
operator|->
name|left
operator|-
name|len_avail
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ht
operator|->
name|right
operator|<
name|len_avail
condition|)
block|{
name|ht
operator|->
name|right
operator|=
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
expr_stmt|;
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|hf
operator|->
name|tree_used
operator|++
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree_used
operator|>
name|hf
operator|->
name|tree_avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ht
operator|->
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|ht
operator|->
name|right
operator|-
name|len_avail
index|]
operator|)
expr_stmt|;
block|}
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ptn
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|ht
operator|->
name|left
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
operator|(
name|uint16_t
operator|)
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ht
operator|->
name|right
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|right
operator|=
operator|(
name|uint16_t
operator|)
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzh_decode_huffman_tree
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|,
name|unsigned
name|rbits
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|struct
name|htree_t
modifier|*
name|ht
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|ht
operator|=
name|hf
operator|->
name|tree
expr_stmt|;
name|extlen
operator|=
name|hf
operator|->
name|shift_bits
expr_stmt|;
while|while
condition|(
name|c
operator|>=
name|hf
operator|->
name|len_avail
condition|)
block|{
name|c
operator|-=
name|hf
operator|->
name|len_avail
expr_stmt|;
if|if
condition|(
name|extlen
operator|--
operator|<=
literal|0
operator|||
name|c
operator|>=
name|hf
operator|->
name|tree_used
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rbits
operator|&
operator|(
literal|1U
operator|<<
name|extlen
operator|)
condition|)
name|c
operator|=
name|ht
index|[
name|c
index|]
operator|.
name|left
expr_stmt|;
else|else
name|c
operator|=
name|ht
index|[
name|c
index|]
operator|.
name|right
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lzh_decode_huffman
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|,
name|unsigned
name|rbits
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
comment|/* 	 * At first search an index table for a bit pattern. 	 * If it fails, search a huffman tree for. 	 */
name|c
operator|=
name|hf
operator|->
name|tbl
index|[
name|rbits
operator|>>
name|hf
operator|->
name|shift_bits
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|hf
operator|->
name|len_avail
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* This bit pattern needs to be found out at a huffman tree. */
return|return
operator|(
name|lzh_decode_huffman_tree
argument_list|(
name|hf
argument_list|,
name|rbits
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

