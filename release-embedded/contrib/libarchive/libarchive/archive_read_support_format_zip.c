begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Tim Kientzle  * Copyright (c) 2011-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_rb.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ZLIB_H
end_ifndef

begin_include
include|#
directive|include
file|"archive_crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|zip_entry
block|{
name|struct
name|archive_rb_node
name|node
decl_stmt|;
name|int64_t
name|local_header_offset
decl_stmt|;
name|int64_t
name|compressed_size
decl_stmt|;
name|int64_t
name|uncompressed_size
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
name|int64_t
name|uid
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|archive_string
name|rsrcname
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|time_t
name|ctime
decl_stmt|;
name|uint32_t
name|crc32
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|char
name|compression
decl_stmt|;
name|char
name|system
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|zip
block|{
comment|/* Structural information about the archive. */
name|int64_t
name|end_of_central_directory_offset
decl_stmt|;
name|int64_t
name|central_directory_offset
decl_stmt|;
name|size_t
name|central_directory_size
decl_stmt|;
name|size_t
name|central_directory_entries
decl_stmt|;
name|char
name|have_central_directory
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
comment|/* List of entries (seekable Zip only) */
name|size_t
name|entries_remaining
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|zip_entries
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|archive_rb_tree
name|tree
decl_stmt|;
name|struct
name|archive_rb_tree
name|tree_rsrc
decl_stmt|;
name|size_t
name|unconsumed
decl_stmt|;
comment|/* entry_bytes_remaining is the number of bytes we expect. */
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
comment|/* These count the number of bytes actually read for the entry. */
name|int64_t
name|entry_compressed_bytes_read
decl_stmt|;
name|int64_t
name|entry_uncompressed_bytes_read
decl_stmt|;
comment|/* Running CRC32 of the decompressed data */
name|unsigned
name|long
name|entry_crc32
decl_stmt|;
comment|/* Flags to mark progress of decompression. */
name|char
name|decompress_init
decl_stmt|;
name|char
name|end_of_entry
decl_stmt|;
name|ssize_t
name|filename_length
decl_stmt|;
name|ssize_t
name|extra_length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|z_stream
name|stream
decl_stmt|;
name|char
name|stream_valid
decl_stmt|;
endif|#
directive|endif
name|struct
name|archive_string
name|extra
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_default
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_utf8
decl_stmt|;
name|int
name|init_default_conversion
decl_stmt|;
name|char
name|format_name
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ZIP_LENGTH_AT_END
value|8
end_define

begin_define
define|#
directive|define
name|ZIP_ENCRYPTED
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ZIP_STRONG_ENCRYPTED
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|ZIP_UTF8_NAME
value|(1<<11)
end_define

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_streamable_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_seekable_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_options
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_seekable_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_streamable_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|zip_get_local_file_header_size
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function_decl
specifier|static
name|int
name|zip_deflate_init
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|zip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zip_read_data_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|zip_read_data_none
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zip_read_local_file_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|zip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|zip_time
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|compression_name
parameter_list|(
name|int
name|compression
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_extra
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|zip_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|archive_read_support_format_zip_streamable
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|archive_read_support_format_zip_seekable
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_zip_streamable
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_zip"
argument_list|)
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|zip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
literal|"zip"
argument_list|,
name|archive_read_format_zip_streamable_bid
argument_list|,
name|archive_read_format_zip_options
argument_list|,
name|archive_read_format_zip_streamable_read_header
argument_list|,
name|archive_read_format_zip_read_data
argument_list|,
name|archive_read_format_zip_read_data_skip
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_zip_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_support_format_zip_seekable
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_zip_seekable"
argument_list|)
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|zip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
literal|"zip"
argument_list|,
name|archive_read_format_zip_seekable_bid
argument_list|,
name|archive_read_format_zip_options
argument_list|,
name|archive_read_format_zip_seekable_read_header
argument_list|,
name|archive_read_format_zip_read_data
argument_list|,
name|archive_read_format_zip_read_data_skip
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_zip_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_support_format_zip
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_read_support_format_zip_streamable
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
return|return
operator|(
name|archive_read_support_format_zip_seekable
argument_list|(
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: This is a performance sink because it forces the read core to  * drop buffered data from the start of file, which will then have to  * be re-read again if this bidder loses.  *  * We workaround this a little by passing in the best bid so far so  * that later bidders can do nothing if they know they'll never  * outbid.  But we can certainly do better...  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_format_zip_seekable_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|int64_t
name|filesize
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If someone has already bid more than 32, then avoid 	   trashing the look-ahead buffers with a seek. */
if|if
condition|(
name|best_bid
operator|>
literal|32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|filesize
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
operator|-
literal|22
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
comment|/* If we can't seek, then we can't bid. */
if|if
condition|(
name|filesize
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* TODO: More robust search for end of central directory record. */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|22
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* First four bytes are signature for end of central directory 	   record.  Four zero bytes ensure this isn't a multi-volume 	   Zip file (which we don't yet support). */
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\005\006\000\000\000\000"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int64_t
name|i
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* 		 * If there is a comment in end of central directory 		 * record, 22 bytes are too short. we have to read more 		 * to properly detect the record. Hopefully, a length 		 * of the comment is not longer than 16362 bytes(16K-22). 		 */
if|if
condition|(
name|filesize
operator|+
literal|22
operator|>
literal|1024
operator|*
literal|16
condition|)
block|{
name|tail
operator|=
literal|1024
operator|*
literal|16
expr_stmt|;
name|filesize
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|tail
operator|*
operator|-
literal|1
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|=
name|filesize
operator|+
literal|22
expr_stmt|;
name|filesize
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filesize
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|tail
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|tail
operator|-
literal|22
condition|;
control|)
block|{
switch|switch
condition|(
name|p
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'P'
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|p
operator|+
name|i
argument_list|,
literal|"PK\005\006\000\000\000\000"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
name|i
expr_stmt|;
name|filesize
operator|+=
name|tail
operator|-
operator|(
literal|22
operator|+
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|20
argument_list|)
operator|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|i
operator|+=
literal|7
expr_stmt|;
break|break;
case|case
literal|005
case|:
name|i
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
literal|006
case|:
name|i
operator|+=
literal|5
expr_stmt|;
break|break;
default|default:
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
literal|0
return|;
block|}
comment|/* Since we've already done the hard work of finding the 	   end of central directory record, let's save the important 	   information. */
name|zip
operator|->
name|central_directory_entries
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|10
argument_list|)
expr_stmt|;
name|zip
operator|->
name|central_directory_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|zip
operator|->
name|central_directory_offset
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
expr_stmt|;
name|zip
operator|->
name|end_of_central_directory_offset
operator|=
name|filesize
expr_stmt|;
comment|/* Just one volume, so central dir must all be on this volume. */
if|if
condition|(
name|zip
operator|->
name|central_directory_entries
operator|!=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Central directory can't extend beyond end of this file. */
if|if
condition|(
name|zip
operator|->
name|central_directory_offset
operator|+
operator|(
name|int64_t
operator|)
name|zip
operator|->
name|central_directory_size
operator|>
name|filesize
condition|)
return|return
literal|0
return|;
comment|/* This is just a tiny bit higher than the maximum returned by 	   the streaming Zip bidder.  This ensures that the more accurate 	   seeking Zip parser wins whenever seek is available. */
return|return
literal|32
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|zip_entry
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|zip_entry
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|e2
operator|->
name|local_header_offset
operator|-
name|e1
operator|->
name|local_header_offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
comment|/* This function won't be called */
operator|(
name|void
operator|)
name|n
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|key
expr_stmt|;
comment|/* UNUSED */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rsrc_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|zip_entry
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|zip_entry
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|e2
operator|->
name|rsrcname
operator|.
name|s
argument_list|,
name|e1
operator|->
name|rsrcname
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rsrc_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|zip_entry
modifier|*
name|e
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|e
operator|->
name|rsrcname
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rsrc_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|name_length
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|s
operator|=
name|name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|memchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|,
name|name_length
operator|-
operator|(
name|s
operator|-
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
name|r
operator|=
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expose_parent_dirs
parameter_list|(
name|struct
name|zip
modifier|*
name|zip
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|name_length
parameter_list|)
block|{
name|struct
name|archive_string
name|str
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
name|str
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|strrchr
argument_list|(
name|str
operator|.
name|s
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* Transfer the parent directory from zip->tree_rsrc RB 		 * tree to zip->tree RB tree to expose. */
name|dir
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
name|str
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
break|break;
name|__archive_rb_tree_remove_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
operator|&
name|dir
operator|->
name|node
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|dir
operator|->
name|rsrcname
argument_list|)
expr_stmt|;
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|dir
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_central_directory
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int64_t
name|correction
decl_stmt|;
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
operator|&
name|cmp_node
block|,
operator|&
name|cmp_key
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_rsrc_ops
init|=
block|{
operator|&
name|rsrc_cmp_node
block|,
operator|&
name|rsrc_cmp_key
block|}
decl_stmt|;
comment|/* 	 * Consider the archive file we are reading may be SFX. 	 * So we have to calculate a SFX header size to revise 	 * ZIP header offsets. 	 */
name|correction
operator|=
name|zip
operator|->
name|end_of_central_directory_offset
operator|-
operator|(
name|zip
operator|->
name|central_directory_offset
operator|+
name|zip
operator|->
name|central_directory_size
operator|)
expr_stmt|;
comment|/* The central directory offset is relative value, and so 	 * we revise this offset for SFX. */
name|zip
operator|->
name|central_directory_offset
operator|+=
name|correction
expr_stmt|;
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|central_directory_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|zip
operator|->
name|offset
operator|=
name|zip
operator|->
name|central_directory_offset
expr_stmt|;
name|__archive_rb_tree_init
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
name|__archive_rb_tree_init
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
operator|&
name|rb_rsrc_ops
argument_list|)
expr_stmt|;
name|zip
operator|->
name|zip_entries
operator|=
name|calloc
argument_list|(
name|zip
operator|->
name|central_directory_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zip_entry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zip
operator|->
name|central_directory_entries
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|zip_entry
modifier|*
name|zip_entry
init|=
operator|&
name|zip
operator|->
name|zip_entries
index|[
name|i
index|]
decl_stmt|;
name|size_t
name|filename_length
decl_stmt|,
name|extra_length
decl_stmt|,
name|comment_length
decl_stmt|;
name|uint32_t
name|external_attributes
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|46
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ARCHIVE_FATAL
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\001\002"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Invalid central directory signature"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|zip
operator|->
name|have_central_directory
operator|=
literal|1
expr_stmt|;
comment|/* version = p[4]; */
name|zip_entry
operator|->
name|system
operator|=
name|p
index|[
literal|5
index|]
expr_stmt|;
comment|/* version_required = archive_le16dec(p + 6); */
name|zip_entry
operator|->
name|flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|compression
operator|=
operator|(
name|char
operator|)
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|10
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|mtime
operator|=
name|zip_time
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|20
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|24
argument_list|)
expr_stmt|;
name|filename_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|28
argument_list|)
expr_stmt|;
name|extra_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|30
argument_list|)
expr_stmt|;
name|comment_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* disk_start = archive_le16dec(p + 34); */
comment|/* Better be zero. */
comment|/* internal_attributes = archive_le16dec(p + 36); */
comment|/* text bit */
name|external_attributes
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|38
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|local_header_offset
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|42
argument_list|)
operator|+
name|correction
expr_stmt|;
comment|/* If we can't guess the mode, leave it zero here; 		   when we read the local file header we might get 		   more information. */
name|zip_entry
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|system
operator|==
literal|3
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator|=
name|external_attributes
operator|>>
literal|16
expr_stmt|;
block|}
comment|/* 		 * Mac resource fork files are stored under the 		 * "__MACOSX/" directory, so we should check if 		 * it is. 		 */
comment|/* Make sure we have the file name. */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|46
operator|+
name|filename_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ARCHIVE_FATAL
return|;
name|name
operator|=
name|p
operator|+
literal|46
expr_stmt|;
name|r
operator|=
name|rsrc_basename
argument_list|(
name|name
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename_length
operator|>=
literal|9
operator|&&
name|strncmp
argument_list|(
literal|"__MACOSX/"
argument_list|,
name|name
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this file is not a resource fork nor 			 * a directory. We should treat it as a non 			 * resource fork file to expose it. */
if|if
condition|(
name|name
index|[
name|filename_length
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
operator|(
name|r
operator|-
name|name
operator|<
literal|3
operator|||
name|r
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|r
index|[
literal|1
index|]
operator|!=
literal|'_'
operator|)
condition|)
block|{
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|zip_entry
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* Expose its parent directories. */
name|expose_parent_dirs
argument_list|(
name|zip
argument_list|,
name|name
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This file is a resource fork file or 				 * a directory. */
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
name|name
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
operator|&
name|zip_entry
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Generate resource fork name to find its resource 			 * file at zip->tree_rsrc. */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
literal|"__MACOSX/"
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
name|name
argument_list|,
name|r
operator|-
name|name
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
literal|"._"
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
name|name
operator|+
operator|(
name|r
operator|-
name|name
operator|)
argument_list|,
name|filename_length
operator|-
operator|(
name|r
operator|-
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* Register an entry to RB tree to sort it by 			 * file offset. */
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|zip_entry
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* We don't read the filename until we get to the 		   local file header.  Reading it here would speed up 		   table-of-contents operations (removing the need to 		   find and read local file header to get the 		   filename) at the cost of requiring a lot of extra 		   space. */
comment|/* We don't read the extra block here.  We assume it 		   will be duplicated at the local file header. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|46
operator|+
name|filename_length
operator|+
name|extra_length
operator|+
name|comment_length
argument_list|)
expr_stmt|;
block|}
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|zip_read_consume
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int64_t
name|bytes
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|int64_t
name|skip
decl_stmt|;
name|skip
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
name|zip
operator|->
name|offset
operator|+=
name|skip
expr_stmt|;
return|return
operator|(
name|skip
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zip_read_mac_metadata
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|zip_entry
modifier|*
name|rsrc
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|metadata
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|int64_t
name|offset
init|=
name|zip
operator|->
name|offset
decl_stmt|;
name|size_t
name|remaining_bytes
decl_stmt|,
name|metadata_bytes
decl_stmt|;
name|ssize_t
name|hsize
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|,
name|eof
decl_stmt|;
switch|switch
condition|(
name|rsrc
operator|->
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* No compression. */
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
endif|#
directive|endif
break|break;
default|default:
comment|/* Unsupported compression. */
comment|/* Return a warning. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported ZIP compression method (%s)"
argument_list|,
name|compression_name
argument_list|(
name|rsrc
operator|->
name|compression
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't decompress this entry, but we will 		 * be able to skip() it and try the next entry. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|rsrc
operator|->
name|uncompressed_size
operator|>
operator|(
literal|128
operator|*
literal|1024
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Mac metadata is too large: %jd> 128K bytes"
argument_list|,
operator|(
name|intmax_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|metadata
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Mac metadata"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|offset
operator|<
name|rsrc
operator|->
name|local_header_offset
condition|)
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|rsrc
operator|->
name|local_header_offset
operator|-
name|zip
operator|->
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zip
operator|->
name|offset
operator|!=
name|rsrc
operator|->
name|local_header_offset
condition|)
block|{
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|rsrc
operator|->
name|local_header_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|zip
operator|->
name|offset
operator|=
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
expr_stmt|;
block|}
name|hsize
operator|=
name|zip_get_local_file_header_size
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|remaining_bytes
operator|=
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|compressed_size
expr_stmt|;
name|metadata_bytes
operator|=
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
expr_stmt|;
name|mp
operator|=
name|metadata
expr_stmt|;
name|eof
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|eof
operator|&&
name|remaining_bytes
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|size_t
name|bytes_used
decl_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_mac_metadata
goto|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|bytes_avail
operator|>
name|remaining_bytes
condition|)
name|bytes_avail
operator|=
name|remaining_bytes
expr_stmt|;
switch|switch
condition|(
name|rsrc
operator|->
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* No compression. */
name|memcpy
argument_list|(
name|mp
argument_list|,
name|p
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
operator|(
name|size_t
operator|)
name|bytes_avail
expr_stmt|;
name|metadata_bytes
operator|-=
name|bytes_used
expr_stmt|;
name|mp
operator|+=
name|bytes_used
expr_stmt|;
if|if
condition|(
name|metadata_bytes
operator|==
literal|0
condition|)
name|eof
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
block|{
name|int
name|r
decl_stmt|;
name|ret
operator|=
name|zip_deflate_init
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|exit_mac_metadata
goto|;
name|zip
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|p
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|mp
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|metadata_bytes
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
case|case
name|Z_STREAM_END
case|:
name|eof
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory for ZIP decompression"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
goto|goto
name|exit_mac_metadata
goto|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
goto|goto
name|exit_mac_metadata
goto|;
block|}
name|bytes_used
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_in
expr_stmt|;
name|metadata_bytes
operator|-=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|mp
operator|+=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|bytes_used
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|remaining_bytes
operator|-=
name|bytes_used
expr_stmt|;
block|}
name|archive_entry_copy_mac_metadata
argument_list|(
name|entry
argument_list|,
name|metadata
argument_list|,
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
operator|-
name|metadata_bytes
argument_list|)
expr_stmt|;
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|zip
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|exit_mac_metadata
label|:
name|zip
operator|->
name|decompress_init
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_seekable_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|rsrc
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ZIP
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ZIP"
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|zip_entries
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|slurp_central_directory
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entries_remaining
operator|=
name|zip
operator|->
name|central_directory_entries
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
comment|/* Get first entry whose local header offset is lower than 		 * other entries in the archive file. */
name|zip
operator|->
name|entry
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|ARCHIVE_RB_TREE_MIN
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* Get next entry in local header offset order. */
name|zip
operator|->
name|entry
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|__archive_rb_tree_iterate
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|zip
operator|->
name|entry
operator|->
name|node
argument_list|,
name|ARCHIVE_RB_DIR_RIGHT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entries_remaining
operator|<=
literal|0
operator|||
name|zip
operator|->
name|entry
operator|==
name|NULL
condition|)
return|return
name|ARCHIVE_EOF
return|;
operator|--
name|zip
operator|->
name|entries_remaining
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|rsrcname
operator|.
name|s
condition|)
name|rsrc
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
name|zip
operator|->
name|entry
operator|->
name|rsrcname
operator|.
name|s
argument_list|)
expr_stmt|;
else|else
name|rsrc
operator|=
name|NULL
expr_stmt|;
comment|/* File entries are sorted by the header offset, we should mostly 	 * use zip_read_consume to advance a read point to avoid redundant 	 * data reading.  */
if|if
condition|(
name|zip
operator|->
name|offset
operator|<
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
condition|)
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
operator|-
name|zip
operator|->
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zip
operator|->
name|offset
operator|!=
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
condition|)
block|{
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|zip
operator|->
name|offset
operator|=
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
expr_stmt|;
block|}
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|zip_read_local_file_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
if|if
condition|(
operator|(
name|zip
operator|->
name|entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFLNK
condition|)
block|{
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|size_t
name|linkname_length
init|=
operator|(
name|size_t
operator|)
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|linkname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated Zip file"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|sconv
operator|=
name|zip
operator|->
name|sconv
expr_stmt|;
if|if
condition|(
name|sconv
operator|==
name|NULL
operator|&&
operator|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|ZIP_UTF8_NAME
operator|)
condition|)
name|sconv
operator|=
name|zip
operator|->
name|sconv_utf8
expr_stmt|;
if|if
condition|(
name|sconv
operator|==
name|NULL
condition|)
name|sconv
operator|=
name|zip
operator|->
name|sconv_default
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_symlink_l
argument_list|(
name|entry
argument_list|,
name|p
argument_list|,
name|linkname_length
argument_list|,
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOMEM
operator|&&
name|sconv
operator|==
name|zip
operator|->
name|sconv_utf8
operator|&&
operator|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|ZIP_UTF8_NAME
operator|)
condition|)
name|archive_entry_copy_symlink_l
argument_list|(
name|entry
argument_list|,
name|p
argument_list|,
name|linkname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Symlink"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 			 * Since there is no character-set regulation for 			 * symlink name, do not report the conversion error 			 * in an automatic conversion. 			 */
if|if
condition|(
name|sconv
operator|!=
name|zip
operator|->
name|sconv_utf8
operator|||
operator|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|ZIP_UTF8_NAME
operator|)
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Symlink cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rsrc
condition|)
block|{
name|int
name|ret2
init|=
name|zip_read_mac_metadata
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|rsrc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret2
operator|<
name|ret
condition|)
name|ret
operator|=
name|ret2
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_streamable_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
operator|(
name|void
operator|)
name|best_bid
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Bid of 30 here is: 16 bits for "PK", 	 * next 16-bit field has four options (-2 bits). 	 * 16 + 16-2 = 30. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\001'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\002'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\003'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\004'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\005'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\006'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'0'
operator|)
condition|)
return|return
operator|(
literal|30
operator|)
return|;
block|}
comment|/* TODO: It's worth looking ahead a little bit for a valid 	 * PK signature.  In particular, that would make it possible 	 * to read some UUEncoded SFX files or SFX files coming from 	 * a network socket. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_options
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"compat-2x"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Handle filnames as libarchive 2.x */
name|zip
operator|->
name|init_default_conversion
operator|=
operator|(
name|val
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"zip: hdrcharset option needs a character-set name"
argument_list|)
expr_stmt|;
else|else
block|{
name|zip
operator|->
name|sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|sconv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|zip
operator|->
name|sconv_utf8
operator|=
name|zip
operator|->
name|sconv
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_streamable_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ZIP
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ZIP"
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* Make sure we have a zip_entry structure to use. */
if|if
condition|(
name|zip
operator|->
name|zip_entries
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|zip_entries
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zip_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|zip_entries
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out  of memory"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
block|}
name|zip
operator|->
name|entry
operator|=
name|zip
operator|->
name|zip_entries
expr_stmt|;
name|memset
argument_list|(
name|zip
operator|->
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zip_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search ahead for the next local file header. */
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|unconsumed
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int64_t
name|skipped
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|end
operator|=
name|p
operator|+
name|bytes
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|4
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\001'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\002'
condition|)
comment|/* Beginning of central directory. */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\003'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\004'
condition|)
block|{
comment|/* Regular file entry. */
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
return|return
name|zip_read_local_file_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|zip
argument_list|)
return|;
block|}
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\005'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\006'
condition|)
comment|/* End of central directory. */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
operator|++
name|p
expr_stmt|;
operator|++
name|skipped
expr_stmt|;
block|}
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|zip_get_local_file_header_size
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|extra
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|filename_length
decl_stmt|,
name|extra_length
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|extra
operator|+
literal|30
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|p
operator|+=
name|extra
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\003\004"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Damaged Zip archive"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_WARN
return|;
block|}
name|filename_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|26
argument_list|)
expr_stmt|;
name|extra_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|28
argument_list|)
expr_stmt|;
return|return
operator|(
literal|30
operator|+
name|filename_length
operator|+
name|extra_length
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assumes file pointer is at beginning of local file header.  */
end_comment

begin_function
specifier|static
name|int
name|zip_read_local_file_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|filename_length
decl_stmt|,
name|extra_length
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|zip_entry
init|=
name|zip
operator|->
name|entry
decl_stmt|;
name|uint32_t
name|local_crc32
decl_stmt|;
name|int64_t
name|compressed_size
decl_stmt|,
name|uncompressed_size
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|char
name|version
decl_stmt|;
name|zip
operator|->
name|decompress_init
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|end_of_entry
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_crc32
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup default conversion. */
if|if
condition|(
name|zip
operator|->
name|sconv
operator|==
name|NULL
operator|&&
operator|!
name|zip
operator|->
name|init_default_conversion
condition|)
block|{
name|zip
operator|->
name|sconv_default
operator|=
name|archive_string_default_conversion_for_read
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|)
expr_stmt|;
name|zip
operator|->
name|init_default_conversion
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|30
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\003\004"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Damaged Zip archive"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|version
operator|=
name|p
index|[
literal|4
index|]
expr_stmt|;
name|zip_entry
operator|->
name|system
operator|=
name|p
index|[
literal|5
index|]
expr_stmt|;
name|zip_entry
operator|->
name|flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|compression
operator|=
operator|(
name|char
operator|)
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|mtime
operator|=
name|zip_time
argument_list|(
name|p
operator|+
literal|10
argument_list|)
expr_stmt|;
name|local_crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|14
argument_list|)
expr_stmt|;
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|18
argument_list|)
expr_stmt|;
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|22
argument_list|)
expr_stmt|;
name|filename_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|26
argument_list|)
expr_stmt|;
name|extra_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|28
argument_list|)
expr_stmt|;
name|zip_read_consume
argument_list|(
name|a
argument_list|,
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|have_central_directory
condition|)
block|{
comment|/* If we read the central dir entry, we must have size 		 * information as well, so ignore the length-at-end flag. */
name|zip_entry
operator|->
name|flags
operator|&=
operator|~
name|ZIP_LENGTH_AT_END
expr_stmt|;
comment|/* If we have values from both the local file header 		   and the central directory, warn about mismatches 		   which might indicate a damaged file.  But some 		   writers always put zero in the local header; don't 		   bother warning about that. */
if|if
condition|(
name|local_crc32
operator|!=
literal|0
operator|&&
name|local_crc32
operator|!=
name|zip_entry
operator|->
name|crc32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Inconsistent CRC32 values"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|compressed_size
operator|!=
literal|0
operator|&&
name|compressed_size
operator|!=
name|zip_entry
operator|->
name|compressed_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Inconsistent compressed size"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|uncompressed_size
operator|!=
literal|0
operator|&&
name|uncompressed_size
operator|!=
name|zip_entry
operator|->
name|uncompressed_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Inconsistent uncompressed size"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we don't have the CD info, use whatever we do have. */
name|zip_entry
operator|->
name|crc32
operator|=
name|local_crc32
expr_stmt|;
name|zip_entry
operator|->
name|compressed_size
operator|=
name|compressed_size
expr_stmt|;
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|uncompressed_size
expr_stmt|;
block|}
comment|/* Read the filename. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|filename_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|zip_entry
operator|->
name|flags
operator|&
name|ZIP_UTF8_NAME
condition|)
block|{
comment|/* The filename is stored to be UTF-8. */
if|if
condition|(
name|zip
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|sconv_utf8
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|sconv
operator|=
name|zip
operator|->
name|sconv_utf8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|sconv
operator|!=
name|NULL
condition|)
name|sconv
operator|=
name|zip
operator|->
name|sconv
expr_stmt|;
else|else
name|sconv
operator|=
name|zip
operator|->
name|sconv_default
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
name|h
argument_list|,
name|filename_length
argument_list|,
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|mode
operator|==
literal|0
condition|)
block|{
comment|/* Especially in streaming mode, we can end up 		   here without having seen any mode information. 		   Guess from the filename. */
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|wcslen
argument_list|(
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|wp
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|L'
expr|/'
condition|)
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFDIR
operator||
literal|0777
expr_stmt|;
else|else
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFREG
operator||
literal|0666
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|cp
operator|!=
name|NULL
operator|)
condition|?
name|strlen
argument_list|(
name|cp
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|cp
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFDIR
operator||
literal|0777
expr_stmt|;
else|else
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFREG
operator||
literal|0666
expr_stmt|;
block|}
block|}
comment|/* Read the extra data. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|extra_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|process_extra
argument_list|(
name|h
argument_list|,
name|extra_length
argument_list|,
name|zip_entry
argument_list|)
expr_stmt|;
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|extra_length
argument_list|)
expr_stmt|;
comment|/* Populate some additional entry fields: */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|mode
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|uid
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|gid
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|mtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|ctime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the size only if it's meaningful. */
if|if
condition|(
literal|0
operator|==
operator|(
name|zip_entry
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
condition|)
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|=
name|zip_entry
operator|->
name|compressed_size
expr_stmt|;
comment|/* If there's no body, force read_data() to return EOF immediately. */
if|if
condition|(
literal|0
operator|==
operator|(
name|zip_entry
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|zip
operator|->
name|entry_bytes_remaining
operator|<
literal|1
condition|)
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
comment|/* Set up a more descriptive format name. */
name|sprintf
argument_list|(
name|zip
operator|->
name|format_name
argument_list|,
literal|"ZIP %d.%d (%s)"
argument_list|,
name|version
operator|/
literal|10
argument_list|,
name|version
operator|%
literal|10
argument_list|,
name|compression_name
argument_list|(
name|zip
operator|->
name|entry
operator|->
name|compression
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
name|zip
operator|->
name|format_name
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|compression_name
parameter_list|(
name|int
name|compression
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|compression_names
index|[]
init|=
block|{
literal|"uncompressed"
block|,
literal|"shrinking"
block|,
literal|"reduced-1"
block|,
literal|"reduced-2"
block|,
literal|"reduced-3"
block|,
literal|"reduced-4"
block|,
literal|"imploded"
block|,
literal|"reserved"
block|,
literal|"deflation"
block|}
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|compression
operator|&&
name|compression
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|compression_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|compression_names
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|compression_names
index|[
name|compression
index|]
return|;
else|else
return|return
literal|"??"
return|;
block|}
end_function

begin_comment
comment|/* Convert an MSDOS-style date/time into Unix-style time. */
end_comment

begin_function
specifier|static
name|time_t
name|zip_time
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|msTime
decl_stmt|,
name|msDate
decl_stmt|;
name|struct
name|tm
name|ts
decl_stmt|;
name|msTime
operator|=
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|0
index|]
operator|)
operator|+
literal|256
operator|*
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|msDate
operator|=
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|2
index|]
operator|)
operator|+
literal|256
operator|*
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|80
expr_stmt|;
comment|/* Years since 1900. */
name|ts
operator|.
name|tm_mon
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|5
operator|)
operator|&
literal|0x0f
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Month number. */
name|ts
operator|.
name|tm_mday
operator|=
name|msDate
operator|&
literal|0x1f
expr_stmt|;
comment|/* Day of month. */
name|ts
operator|.
name|tm_hour
operator|=
operator|(
name|msTime
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|ts
operator|.
name|tm_min
operator|=
operator|(
name|msTime
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|ts
operator|.
name|tm_sec
operator|=
operator|(
name|msTime
operator|<<
literal|1
operator|)
operator|&
literal|0x3e
expr_stmt|;
name|ts
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|mktime
argument_list|(
operator|&
name|ts
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_uncompressed_bytes_read
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
comment|/* If we hit end-of-entry last time, return ARCHIVE_EOF. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
comment|/* Return EOF immediately if this is a non-regular file. */
if|if
condition|(
name|AE_IFREG
operator|!=
operator|(
name|zip
operator|->
name|entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
operator|(
name|ZIP_ENCRYPTED
operator||
name|ZIP_STRONG_ENCRYPTED
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Encrypted file is unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|unconsumed
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|zip
operator|->
name|entry
operator|->
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* No compression. */
name|r
operator|=
name|zip_read_data_none
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
name|r
operator|=
name|zip_read_data_deflate
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unsupported compression. */
comment|/* Return a warning. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported ZIP compression method (%s)"
argument_list|,
name|compression_name
argument_list|(
name|zip
operator|->
name|entry
operator|->
name|compression
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't decompress this entry, but we will 		 * be able to skip() it and try the next entry. */
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Update checksum */
if|if
condition|(
operator|*
name|size
condition|)
name|zip
operator|->
name|entry_crc32
operator|=
name|crc32
argument_list|(
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|*
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
operator|*
name|size
argument_list|)
expr_stmt|;
comment|/* If we hit the end, swallow any end-of-data marker. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
block|{
comment|/* Check file size, CRC against these values. */
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|!=
name|zip
operator|->
name|entry_compressed_bytes_read
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP compressed data is wrong size "
literal|"(read %jd, expected %jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry_compressed_bytes_read
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry
operator|->
name|compressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Size field only stores the lower 32 bits of the actual 		 * size. */
if|if
condition|(
operator|(
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|&
name|UINT32_MAX
operator|)
operator|!=
operator|(
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|&
name|UINT32_MAX
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP uncompressed data is wrong size "
literal|"(read %jd, expected %jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry_uncompressed_bytes_read
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Check computed CRC against header */
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|!=
name|zip
operator|->
name|entry_crc32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP bad CRC: 0x%lx should be 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zip
operator|->
name|entry
operator|->
name|crc32
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read "uncompressed" data.  There are three cases:  *  1) We know the size of the data.  This is always true for the  * seeking reader (we've examined the Central Directory already).  *  2) ZIP_LENGTH_AT_END was set, but only the CRC was deferred.  * Info-ZIP seems to do this; we know the size but have to grab  * the CRC from the data descriptor afterwards.  *  3) We're streaming and ZIP_LENGTH_AT_END was specified and  * we have no size information.  In this case, we can do pretty  * well by watching for the data descriptor record.  The data  * descriptor is 16 bytes and includes a computed CRC that should  * provide a strong check.  *  * TODO: Technically, the PK\007\010 signature is optional.  * In the original spec, the data descriptor contained CRC  * and size fields but had no leading signature.  In practice,  * newer writers seem to provide the signature pretty consistently,  * but we might need to do something more complex here if  * we want to handle older archives that lack that signature.  *  * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets  * zip->end_of_entry if it consumes all of the data.  */
end_comment

begin_function
specifier|static
name|int
name|zip_read_data_none
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|_buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
specifier|const
name|char
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
operator|(
name|void
operator|)
name|offset
expr_stmt|;
comment|/* UNUSED */
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Grab at least 16 bytes. */
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|16
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<
literal|16
condition|)
block|{
comment|/* Zip archives have end-of-archive markers 			   that are longer than this, so a failure to get at 			   least 16 bytes really does indicate a truncated 			   file. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Check for a complete PK\007\010 signature. */
name|p
operator|=
name|buff
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|&&
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|==
name|zip
operator|->
name|entry_crc32
operator|&&
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
operator|==
name|zip
operator|->
name|entry_compressed_bytes_read
operator|&&
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
operator|==
name|zip
operator|->
name|entry_uncompressed_bytes_read
condition|)
block|{
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|16
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* If not at EOF, ensure we consume at least one byte. */
operator|++
name|p
expr_stmt|;
comment|/* Scan forward until we see where a PK\007\010 signature 		 * might be. */
comment|/* Return bytes up until that point.  On the next call, 		 * the code above will verify the data descriptor. */
while|while
condition|(
name|p
operator|<
name|buff
operator|+
name|bytes_avail
operator|-
literal|4
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'P'
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'K'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\007'
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
break|break;
block|}
else|else
block|{
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|bytes_avail
operator|=
name|p
operator|-
name|buff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zip
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Grab a bunch of bytes. */
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|zip
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
expr_stmt|;
block|}
operator|*
name|size
operator|=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|+=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|+=
name|bytes_avail
expr_stmt|;
operator|*
name|_buff
operator|=
name|buff
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function
specifier|static
name|int
name|zip_deflate_init
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* If we haven't yet read any data, initialize the decompressor. */
if|if
condition|(
operator|!
name|zip
operator|->
name|decompress_init
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit2
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
operator|-
literal|15
comment|/* Don't check for zlib header */
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't initialize ZIP decompression."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Stream structure has been set up. */
name|zip
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
comment|/* We've initialized decompression for this stream. */
name|zip
operator|->
name|decompress_init
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zip_read_data_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
specifier|const
name|void
modifier|*
name|compressed_buff
decl_stmt|;
name|int
name|r
decl_stmt|;
operator|(
name|void
operator|)
name|offset
expr_stmt|;
comment|/* UNUSED */
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* If the buffer hasn't been allocated, allocate it now. */
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|uncompressed_buffer_size
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|zip
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for ZIP decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|r
operator|=
name|zip_deflate_init
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * Note: '1' here is a performance optimization. 	 * Recall that the decompression layer returns a count of 	 * available bytes; asking for more than that forces the 	 * decompressor to combine reads by copying data. 	 */
name|compressed_buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|bytes_avail
operator|>
name|zip
operator|->
name|entry_bytes_remaining
condition|)
block|{
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
expr_stmt|;
block|}
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * A bug in zlib.h: stream.next_in should be marked 'const' 	 * but isn't (the library never alters data through the 	 * next_in pointer, only reads it).  The result: this ugly 	 * cast to remove 'const'. 	 */
name|zip
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|compressed_buff
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|zip
operator|->
name|uncompressed_buffer_size
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
case|case
name|Z_STREAM_END
case|:
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory for ZIP decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Consume as much as the compressor actually used. */
name|bytes_avail
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_in
expr_stmt|;
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
name|bytes_avail
expr_stmt|;
operator|*
name|size
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|+=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
operator|*
name|buff
operator|=
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|end_of_entry
operator|&&
operator|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP end-of-file record"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Consume the optional PK\007\010 marker. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
condition|)
block|{
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|16
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* If we've already read to end of data, we're done. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* So we know we're streaming... */
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
condition|)
block|{
comment|/* We know the compressed length, so we can just skip. */
name|int64_t
name|bytes_skipped
init|=
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|entry_bytes_remaining
operator|+
name|zip
operator|->
name|unconsumed
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* We're streaming and we don't know the length. */
comment|/* If the body is compressed and we know the format, we can 	 * find an exact end-of-entry by decompressing it. */
switch|switch
condition|(
name|zip
operator|->
name|entry
operator|->
name|compression
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
while|while
condition|(
operator|!
name|zip
operator|->
name|end_of_entry
condition|)
block|{
name|int64_t
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|zip_read_data_deflate
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
name|ARCHIVE_OK
return|;
endif|#
directive|endif
default|default:
comment|/* Uncompressed or unknown. */
comment|/* Scan for a PK\007\010 signature. */
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|unconsumed
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|16
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<
literal|16
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|=
name|buff
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|buff
operator|+
name|bytes_avail
operator|-
literal|16
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'P'
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'K'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\007'
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|p
operator|-
name|buff
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
else|else
block|{
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|zip_read_consume
argument_list|(
name|a
argument_list|,
name|p
operator|-
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
name|inflateEnd
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zip
operator|->
name|zip_entries
operator|&&
name|zip
operator|->
name|central_directory_entries
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zip
operator|->
name|central_directory_entries
condition|;
name|i
operator|++
control|)
name|archive_string_free
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|zip_entries
index|[
name|i
index|]
operator|.
name|rsrcname
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zip
operator|->
name|zip_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|extra
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The extra data is stored as a list of  *	id1+size1+data1 + id2+size2+data2 ...  *  triplets.  id and size are 2 bytes each.  */
end_comment

begin_function
specifier|static
name|void
name|process_extra
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|extra_length
parameter_list|,
name|struct
name|zip_entry
modifier|*
name|zip_entry
parameter_list|)
block|{
name|unsigned
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|extra_length
operator|-
literal|4
condition|)
block|{
name|unsigned
name|short
name|headerid
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|datasize
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
decl_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|datasize
operator|>
name|extra_length
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Header id 0x%x, length %d\n"
argument_list|,
name|headerid
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|headerid
condition|)
block|{
case|case
literal|0x0001
case|:
comment|/* Zip64 extended information extra field. */
if|if
condition|(
name|datasize
operator|>=
literal|8
condition|)
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>=
literal|16
condition|)
name|zip_entry
operator|->
name|compressed_size
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5455
case|:
block|{
comment|/* Extended time field "UT". */
name|int
name|flags
init|=
name|p
index|[
name|offset
index|]
decl_stmt|;
name|offset
operator|++
expr_stmt|;
name|datasize
operator|--
expr_stmt|;
comment|/* Flag bits indicate which dates are present. */
if|if
condition|(
name|flags
operator|&
literal|0x01
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtime: %lld -> %d\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|zip_entry
operator|->
name|mtime
argument_list|,
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip_entry
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip_entry
operator|->
name|atime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x04
condition|)
block|{
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip_entry
operator|->
name|ctime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0x5855
case|:
block|{
comment|/* Info-ZIP Unix Extra Field (old version) "UX". */
if|if
condition|(
name|datasize
operator|>=
literal|8
condition|)
block|{
name|zip_entry
operator|->
name|atime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datasize
operator|>=
literal|12
condition|)
block|{
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0x7855
case|:
comment|/* Info-ZIP Unix Extra Field (type 2) "Ux". */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uid %d gid %d\n"
argument_list|,
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
argument_list|,
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|datasize
operator|>=
literal|2
condition|)
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>=
literal|4
condition|)
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7875
case|:
block|{
comment|/* Info-Zip Unix Extra Field (type 3) "ux". */
name|int
name|uidsize
init|=
literal|0
decl_stmt|,
name|gidsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|datasize
operator|>=
literal|1
operator|&&
name|p
index|[
name|offset
index|]
operator|==
literal|1
condition|)
block|{
comment|/* version=1 */
if|if
condition|(
name|datasize
operator|>=
literal|4
condition|)
block|{
comment|/* get a uid size. */
name|uidsize
operator|=
name|p
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|uidsize
operator|==
literal|2
condition|)
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uidsize
operator|==
literal|4
operator|&&
name|datasize
operator|>=
literal|6
condition|)
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datasize
operator|>=
operator|(
literal|2
operator|+
name|uidsize
operator|+
literal|3
operator|)
condition|)
block|{
comment|/* get a gid size. */
name|gidsize
operator|=
name|p
index|[
name|offset
operator|+
literal|2
operator|+
name|uidsize
index|]
expr_stmt|;
if|if
condition|(
name|gidsize
operator|==
literal|2
condition|)
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
operator|+
name|uidsize
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gidsize
operator|==
literal|4
operator|&&
name|datasize
operator|>=
operator|(
literal|2
operator|+
name|uidsize
operator|+
literal|5
operator|)
condition|)
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
operator|+
name|uidsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
name|offset
operator|+=
name|datasize
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|offset
operator|!=
name|extra_length
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Extra data field contents do not match reported size!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

