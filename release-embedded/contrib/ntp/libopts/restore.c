begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  restore.c  $Id: restore.c,v 4.10 2007/02/04 17:44:12 bkorb Exp $  * Time-stamp:      "2007-01-13 14:13:17 bkorb"  *  *  This module's routines will save the current option state to memory  *  and restore it.  If saved prior to the initial optionProcess call,  *  then the initial state will be restored.  */
end_comment

begin_comment
comment|/*  *  Automated Options copyright 1992-2007 Bruce Korb  *  *  Automated Options is free software.  *  You may redistribute it and/or modify it under the terms of the  *  GNU General Public License, as published by the Free Software  *  Foundation; either version 2, or (at your option) any later version.  *  *  Automated Options is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with Automated Options.  See the file "COPYING".  If not,  *  write to:  The Free Software Foundation, Inc.,  *             51 Franklin Street, Fifth Floor,  *             Boston, MA  02110-1301, USA.  *  * As a special exception, Bruce Korb gives permission for additional  * uses of the text contained in his release of AutoOpts.  *  * The exception is that, if you link the AutoOpts library with other  * files to produce an executable, this does not by itself cause the  * resulting executable to be covered by the GNU General Public License.  * Your use of that executable is in no way restricted on account of  * linking the AutoOpts library code into it.  *  * This exception does not however invalidate any other reasons why  * the executable file might be covered by the GNU General Public License.  *  * This exception applies only to the code released by Bruce Korb under  * the name AutoOpts.  If you copy code from other sources under the  * General Public License into a copy of AutoOpts, as the General Public  * License permits, the exception does not apply to the code that you add  * in this way.  To avoid misleading anyone as to the status of such  * modified files, you must delete this exception notice from them.  *  * If you write modifications of your own for AutoOpts, it is your choice  * whether to permit this exception to apply to your modifications.  * If you do not wish that, delete this exception notice.  */
end_comment

begin_comment
comment|/*  *  optionFixupSavedOpts  Really, it just wipes out option state for  *  options that are troublesome to copy.  viz., stacked strings and  *  hierarcicaly valued option args.  We do duplicate string args that  *  have been marked as allocated though.  */
end_comment

begin_function
specifier|static
name|void
name|fixupSavedOptionArgs
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptions
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
comment|/*      *  Make sure that allocated stuff is only referenced in the      *  archived copy of the data.      */
for|for
control|(
init|;
name|ct
operator|--
operator|>
literal|0
condition|;
name|pOD
operator|++
control|)
block|{
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_STRING
case|:
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_STACKED
condition|)
block|{
name|tOptDesc
modifier|*
name|q
init|=
name|p
operator|->
name|pOptDesc
operator|+
operator|(
name|pOD
operator|-
name|pOpts
operator|->
name|pOptDesc
operator|)
decl_stmt|;
name|q
operator|->
name|optCookie
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|tOptDesc
modifier|*
name|q
init|=
name|p
operator|->
name|pOptDesc
operator|+
operator|(
name|pOD
operator|-
name|pOpts
operator|->
name|pOptDesc
operator|)
decl_stmt|;
name|AGDUPSTR
argument_list|(
name|q
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
literal|"arg"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
block|{
name|tOptDesc
modifier|*
name|q
init|=
name|p
operator|->
name|pOptDesc
operator|+
operator|(
name|pOD
operator|-
name|pOpts
operator|->
name|pOptDesc
operator|)
decl_stmt|;
name|q
operator|->
name|optCookie
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*=export_func optionSaveState  *  * what:  saves the option state to memory  * arg:   tOptions*, pOpts, program options descriptor  *  * doc:  *  *  This routine will allocate enough memory to save the current option  *  processing state.  If this routine has been called before, that memory  *  will be reused.  You may only save one copy of the option state.  This  *  routine may be called before optionProcess(3AO).  If you do call it  *  before the first call to optionProcess, then you may also change the  *  contents of argc/argv after you call optionRestore(3AO)  *  *  In fact, more strongly put: it is safest to only use this function  *  before having processed any options.  In particular, the saving and  *  restoring of stacked string arguments and hierarchical values is  *  disabled.  The values are not saved.  *  * err:   If it fails to allocate the memory,  *        it will print a message to stderr and exit.  *        Otherwise, it will always succeed. =*/
end_comment

begin_function
name|void
name|optionSaveState
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptions
modifier|*
name|p
init|=
operator|(
name|tOptions
operator|*
operator|)
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|size_t
name|sz
init|=
sizeof|sizeof
argument_list|(
operator|*
name|pOpts
argument_list|)
operator|+
operator|(
name|pOpts
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
operator|)
decl_stmt|;
name|p
operator|=
name|AGALOC
argument_list|(
name|sz
argument_list|,
literal|"saved option state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|tCC
modifier|*
name|pzName
init|=
name|pOpts
operator|->
name|pzProgName
decl_stmt|;
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
block|{
name|pzName
operator|=
name|pOpts
operator|->
name|pzPROGNAME
expr_stmt|;
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
name|pzName
operator|=
name|zNil
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zCantSave
argument_list|,
name|pzName
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|pOpts
operator|->
name|pSavedState
operator|=
name|p
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|pOpts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|pOpts
operator|->
name|pOptDesc
argument_list|,
name|p
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
argument_list|)
expr_stmt|;
name|fixupSavedOptionArgs
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func optionRestore  *  * what:  restore option state from memory copy  * arg:   tOptions*, pOpts, program options descriptor  *  * doc:  Copy back the option state from saved memory.  *       The allocated memory is left intact, so this routine can be  *       called repeatedly without having to call optionSaveState again.  *       If you are restoring a state that was saved before the first call  *       to optionProcess(3AO), then you may change the contents of the  *       argc/argv parameters to optionProcess.  *  * err:  If you have not called @code{optionSaveState} before, a diagnostic is  *       printed to @code{stderr} and exit is called. =*/
end_comment

begin_function
name|void
name|optionRestore
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptions
modifier|*
name|p
init|=
operator|(
name|tOptions
operator|*
operator|)
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|tCC
modifier|*
name|pzName
init|=
name|pOpts
operator|->
name|pzProgName
decl_stmt|;
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
block|{
name|pzName
operator|=
name|pOpts
operator|->
name|pzPROGNAME
expr_stmt|;
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
name|pzName
operator|=
name|zNil
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNoState
argument_list|,
name|pzName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|pOpts
operator|->
name|pSavedState
operator|=
name|NULL
expr_stmt|;
name|optionFree
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pOpts
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pOpts
operator|->
name|pOptDesc
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|p
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pSavedState
operator|=
name|p
expr_stmt|;
name|fixupSavedOptionArgs
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
end_comment

begin_comment
comment|/*=export_func optionFree  *  * what:  free allocated option processing memory  * arg:   tOptions*, pOpts, program options descriptor  *  * doc:   AutoOpts sometimes allocates memory and puts pointers to it in the  *        option state structures.  This routine deallocates all such memory.  *  * err:   As long as memory has not been corrupted,  *        this routine is always successful. =*/
end_comment

begin_function
name|void
name|optionFree
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|free_saved_state
label|:
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|AGFREE
argument_list|(
name|p
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|p
operator|->
name|optArg
operator|.
name|argString
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|p
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_STRING
case|:
ifdef|#
directive|ifdef
name|WITH_LIBREGEX
if|if
condition|(
operator|(
name|p
operator|->
name|fOptState
operator|&
name|OPTST_STACKED
operator|)
operator|&&
operator|(
name|p
operator|->
name|optCookie
operator|!=
name|NULL
operator|)
condition|)
block|{
name|p
operator|->
name|optArg
operator|.
name|argString
operator|=
literal|".*"
expr_stmt|;
name|optionUnstackArg
argument_list|(
name|pOpts
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* leak memory */
empty_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
if|if
condition|(
name|p
operator|->
name|optCookie
operator|!=
name|NULL
condition|)
name|unloadNestedArglist
argument_list|(
name|p
operator|->
name|optCookie
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|optCookie
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|++
operator|,
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|pOpts
operator|->
name|pSavedState
operator|!=
name|NULL
condition|)
block|{
name|tOptions
modifier|*
name|p
init|=
operator|(
name|tOptions
operator|*
operator|)
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
name|memcpy
argument_list|(
name|pOpts
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pOpts
operator|->
name|pOptDesc
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|p
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|pOpts
operator|->
name|pSavedState
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pSavedState
operator|=
name|NULL
expr_stmt|;
goto|goto
name|free_saved_state
goto|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/restore.c */
end_comment

end_unit

