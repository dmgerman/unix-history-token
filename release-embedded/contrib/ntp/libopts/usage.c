begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  usage.c  $Id: usage.c,v 4.15 2007/04/28 22:19:23 bkorb Exp $  * Time-stamp:      "2007-04-15 11:02:46 bkorb"  *  *  This module implements the default usage procedure for  *  Automated Options.  It may be overridden, of course.  *  *  Sort options:     --start=END-[S]TATIC-FORWARD --patt='^/\*($|[^:])' \     --out=xx.c key='^[a-zA-Z0-9_]+\(' --trail='^/\*:' \     --spac=2 --input=usage.c  */
end_comment

begin_comment
comment|/*  *  Automated Options copyright 1992-2007 Bruce Korb  *  *  Automated Options is free software.  *  You may redistribute it and/or modify it under the terms of the  *  GNU General Public License, as published by the Free Software  *  Foundation; either version 2, or (at your option) any later version.  *  *  Automated Options is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with Automated Options.  See the file "COPYING".  If not,  *  write to:  The Free Software Foundation, Inc.,  *             51 Franklin Street, Fifth Floor,  *             Boston, MA  02110-1301, USA.  *  * As a special exception, Bruce Korb gives permission for additional  * uses of the text contained in his release of AutoOpts.  *  * The exception is that, if you link the AutoOpts library with other  * files to produce an executable, this does not by itself cause the  * resulting executable to be covered by the GNU General Public License.  * Your use of that executable is in no way restricted on account of  * linking the AutoOpts library code into it.  *  * This exception does not however invalidate any other reasons why  * the executable file might be covered by the GNU General Public License.  *  * This exception applies only to the code released by Bruce Korb under  * the name AutoOpts.  If you copy code from other sources under the  * General Public License into a copy of AutoOpts, as the General Public  * License permits, the exception does not apply to the code that you add  * in this way.  To avoid misleading anyone as to the status of such  * modified files, you must delete this exception notice from them.  *  * If you write modifications of your own for AutoOpts, it is your choice  * whether to permit this exception to apply to your modifications.  * If you do not wish that, delete this exception notice.  */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_L_N_S
value|(OPTPROC_LONGOPT | OPTPROC_SHORTOPT)
end_define

begin_decl_stmt
specifier|static
name|arg_types_t
name|argTypes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|option_usage_fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|zOptFmtLine
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ag_bool
name|displayEnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/* static forward declarations maintained by :mkfwd */
end_comment

begin_function_decl
specifier|static
name|ag_bool
name|checkGNUUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printExtendedUsage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printInitList
parameter_list|(
name|tCC
modifier|*
specifier|const
modifier|*
name|papz
parameter_list|,
name|ag_bool
modifier|*
name|pInitIntro
parameter_list|,
name|tCC
modifier|*
name|pzRc
parameter_list|,
name|tCC
modifier|*
name|pzPN
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printOneUsage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printOptionUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|ex_code
parameter_list|,
name|tCC
modifier|*
name|pOptTitle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printProgramDetails
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setGnuOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setStdOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*  *  Figure out if we should try to format usage text sort-of like  *  the way many GNU programs do.  */
end_comment

begin_function
specifier|static
name|ag_bool
name|checkGNUUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|char
modifier|*
name|pz
init|=
name|getenv
argument_list|(
literal|"AUTOOPTS_USAGE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|streqvcmp
argument_list|(
name|pz
argument_list|,
literal|"gnu"
argument_list|)
operator|==
literal|0
condition|)
name|pOpts
operator|->
name|fOptSet
operator||=
name|OPTPROC_GNUUSAGE
expr_stmt|;
elseif|else
if|if
condition|(
name|streqvcmp
argument_list|(
name|pz
argument_list|,
literal|"autoopts"
argument_list|)
operator|==
literal|0
condition|)
name|pOpts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_GNUUSAGE
expr_stmt|;
return|return
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_GNUUSAGE
operator|)
condition|?
name|AG_TRUE
else|:
name|AG_FALSE
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionOnlyUsage  *  * what:  Print usage text for just the options  * arg:   + tOptions*   + pOpts    + program options descriptor +  * arg:   + int         + ex_code  + exit code for calling exit(3) +  *  * doc:  *  This routine will print only the usage for each option.  *  This function may be used when the emitted usage must incorporate  *  information not available to AutoOpts. =*/
end_comment

begin_function
name|void
name|optionOnlyUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|ex_code
parameter_list|)
block|{
name|tCC
modifier|*
name|pOptTitle
init|=
name|NULL
decl_stmt|;
comment|/*      *  Determine which header and which option formatting strings to use      */
if|if
condition|(
name|checkGNUUsage
argument_list|(
name|pOpts
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|setGnuOptFmts
argument_list|(
name|pOpts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setStdOptFmts
argument_list|(
name|pOpts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
name|printOptionUsage
argument_list|(
name|pOpts
argument_list|,
name|ex_code
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func  optionUsage  * private:  *  * what:  Print usage text  * arg:   + tOptions* + pOptions + program options descriptor +  * arg:   + int       + exitCode + exit code for calling exit(3) +  *  * doc:  *  This routine will print usage in both GNU-standard and AutoOpts-expanded  *  formats.  The descriptor specifies the default, but AUTOOPTS_USAGE will  *  over-ride this, providing the value of it is set to either "gnu" or  *  "autoopts".  This routine will @strong{not} return.  *  *  If "exitCode" is "EX_USAGE" (normally 64), then output will to to stdout  *  and the actual exit code will be "EXIT_SUCCESS". =*/
end_comment

begin_function
name|void
name|optionUsage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|int
name|usage_exit_code
parameter_list|)
block|{
name|int
name|actual_exit_code
init|=
operator|(
name|usage_exit_code
operator|==
name|EX_USAGE
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|usage_exit_code
decl_stmt|;
name|displayEnum
operator|=
name|AG_FALSE
expr_stmt|;
comment|/*      *  Paged usage will preset option_usage_fp to an output file.      *  If it hasn't already been set, then set it to standard output      *  on successful exit (help was requested), otherwise error out.      */
if|if
condition|(
name|option_usage_fp
operator|==
name|NULL
condition|)
name|option_usage_fp
operator|=
operator|(
name|actual_exit_code
operator|!=
name|EXIT_SUCCESS
operator|)
condition|?
name|stderr
else|:
name|stdout
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|pOptions
operator|->
name|pzUsageTitle
argument_list|,
name|pOptions
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
block|{
name|tCC
modifier|*
name|pOptTitle
init|=
name|NULL
decl_stmt|;
comment|/*          *  Determine which header and which option formatting strings to use          */
if|if
condition|(
name|checkGNUUsage
argument_list|(
name|pOptions
argument_list|)
condition|)
block|{
name|int
name|flen
init|=
name|setGnuOptFmts
argument_list|(
name|pOptions
argument_list|,
operator|&
name|pOptTitle
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|zOptFmtLine
argument_list|,
name|zFmtFmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|flen
init|=
name|setStdOptFmts
argument_list|(
name|pOptions
argument_list|,
operator|&
name|pOptTitle
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|zOptFmtLine
argument_list|,
name|zFmtFmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
comment|/*              *  When we exit with EXIT_SUCCESS and the first option is a doc              *  option, we do *NOT* want to emit the column headers.              *  Otherwise, we do.              */
if|if
condition|(
operator|(
name|usage_exit_code
operator|!=
name|EXIT_SUCCESS
operator|)
operator|||
operator|(
operator|(
name|pOptions
operator|->
name|pOptDesc
operator|->
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|==
literal|0
operator|)
condition|)
name|fputs
argument_list|(
name|pOptTitle
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
name|printOptionUsage
argument_list|(
name|pOptions
argument_list|,
name|usage_exit_code
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Describe the mechanics of denoting the options      */
switch|switch
condition|(
name|pOptions
operator|->
name|fOptSet
operator|&
name|OPTPROC_L_N_S
condition|)
block|{
case|case
name|OPTPROC_L_N_S
case|:
name|fputs
argument_list|(
name|zFlagOkay
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
name|fputs
argument_list|(
name|zNoFlags
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fputs
argument_list|(
name|zOptsOnly
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
name|OPTPROC_NUM_OPT
operator|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|zNumberOpt
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|zReorder
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pOptions
operator|->
name|pzExplain
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|pOptions
operator|->
name|pzExplain
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  IF the user is asking for help (thus exiting with SUCCESS),      *  THEN see what additional information we can provide.      */
if|if
condition|(
name|usage_exit_code
operator|==
name|EXIT_SUCCESS
condition|)
name|printProgramDetails
argument_list|(
name|pOptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOptions
operator|->
name|pzBugAddr
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zPlsSendBugs
argument_list|,
name|pOptions
operator|->
name|pzBugAddr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|actual_exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   PER OPTION TYPE USAGE INFORMATION  */
end_comment

begin_function
specifier|static
name|void
name|printExtendedUsage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
block|{
comment|/*      *  IF there are option conflicts or dependencies,      *  THEN print them here.      */
if|if
condition|(
operator|(
name|pOD
operator|->
name|pOptMust
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|pOD
operator|->
name|pOptCant
operator|!=
name|NULL
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|zTabHyp
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*          *  DEPENDENCIES:          */
if|if
condition|(
name|pOD
operator|->
name|pOptMust
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|int
modifier|*
name|pOptNo
init|=
name|pOD
operator|->
name|pOptMust
decl_stmt|;
name|fputs
argument_list|(
name|zReqThese
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zTabout
argument_list|,
name|pOptions
operator|->
name|pOptDesc
index|[
operator|*
name|pOptNo
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|pOptNo
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
if|if
condition|(
name|pOD
operator|->
name|pOptCant
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|zTabHypAnd
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
comment|/*          *  CONFLICTS:          */
if|if
condition|(
name|pOD
operator|->
name|pOptCant
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|int
modifier|*
name|pOptNo
init|=
name|pOD
operator|->
name|pOptCant
decl_stmt|;
name|fputs
argument_list|(
name|zProhib
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zTabout
argument_list|,
name|pOptions
operator|->
name|pOptDesc
index|[
operator|*
name|pOptNo
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|pOptNo
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
block|}
block|}
comment|/*      *  IF there is a disablement string      *  THEN print the disablement info      */
if|if
condition|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zDis
argument_list|,
name|pOD
operator|->
name|pz_DisableName
argument_list|)
expr_stmt|;
comment|/*      *  IF the numeric option has a special callback,      *  THEN call it, requesting the range or other special info      */
if|if
condition|(
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NUMERIC
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|optionNumericVal
operator|)
condition|)
block|{
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|pOptions
operator|,
name|NULL
operator|)
expr_stmt|;
block|}
comment|/*      *  IF the option defaults to being enabled,      *  THEN print that out      */
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_INITENABLED
condition|)
name|fputs
argument_list|(
name|zEnab
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  IF  the option is in an equivalence class      *        AND not the designated lead      *  THEN print equivalence and leave it at that.      */
if|if
condition|(
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|pOD
operator|->
name|optActualIndex
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zAlt
argument_list|,
name|pOptions
operator|->
name|pOptDesc
index|[
name|pOD
operator|->
name|optEquivIndex
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      *  IF this particular option can NOT be preset      *    AND some form of presetting IS allowed,      *    AND it is not an auto-managed option (e.g. --help, et al.)      *  THEN advise that this option may not be preset.      */
if|if
condition|(
operator|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_INIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pOptions
operator|->
name|papzHomeList
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|pOptions
operator|->
name|pzPROGNAME
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|optIndex
operator|<
name|pOptions
operator|->
name|presetOptCt
operator|)
condition|)
name|fputs
argument_list|(
name|zNoPreset
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  Print the appearance requirements.      */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
name|fputs
argument_list|(
name|zMembers
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|pOD
operator|->
name|optMinCt
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|0
case|:
switch|switch
condition|(
name|pOD
operator|->
name|optMaxCt
condition|)
block|{
case|case
literal|0
case|:
name|fputs
argument_list|(
name|zPreset
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOLIMIT
case|:
name|fputs
argument_list|(
name|zNoLim
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
comment|/*              * IF the max is more than one but limited, print "UP TO" message              */
default|default:
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zUpTo
argument_list|,
name|pOD
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
comment|/*          *  More than one is required.  Print the range.          */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zMust
argument_list|,
name|pOD
operator|->
name|optMinCt
argument_list|,
name|pOD
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NAMED_OPTS
argument_list|(
name|pOptions
argument_list|)
operator|&&
operator|(
name|pOptions
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|==
name|pOD
operator|->
name|optIndex
operator|)
condition|)
name|fputs
argument_list|(
name|zDefaultOpt
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   Figure out where all the initialization files might live.  *   This requires translating some environment variables and  *   testing to see if a name is a directory or a file.  It's  *   squishy, but important to tell users how to find these files.  */
end_comment

begin_function
specifier|static
name|void
name|printInitList
parameter_list|(
name|tCC
modifier|*
specifier|const
modifier|*
name|papz
parameter_list|,
name|ag_bool
modifier|*
name|pInitIntro
parameter_list|,
name|tCC
modifier|*
name|pzRc
parameter_list|,
name|tCC
modifier|*
name|pzPN
parameter_list|)
block|{
name|char
name|zPath
index|[
name|AG_PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|papz
operator|==
name|NULL
condition|)
return|return;
name|fputs
argument_list|(
name|zPresetIntro
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
operator|*
name|pInitIntro
operator|=
name|AG_FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
specifier|const
modifier|*
name|pzPath
init|=
operator|*
operator|(
name|papz
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|pzPath
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|optionMakePath
argument_list|(
name|zPath
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|zPath
argument_list|)
argument_list|,
name|pzPath
argument_list|,
name|pzPN
argument_list|)
condition|)
name|pzPath
operator|=
name|zPath
expr_stmt|;
comment|/*          *  Print the name of the "homerc" file.  If the "rcfile" name is          *  not empty, we may or may not print that, too...          */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zPathFmt
argument_list|,
name|pzPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pzRc
operator|!=
name|NUL
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/*              *  IF the "homerc" file is a directory,              *  then append the "rcfile" name.              */
if|if
condition|(
operator|(
name|stat
argument_list|(
name|pzPath
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fputc
argument_list|(
name|DIRCH
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|pzRc
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Print the usage information for a single option.  */
end_comment

begin_function
specifier|static
name|void
name|printOneUsage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
block|{
comment|/*      *  Flag prefix: IF no flags at all, then omit it.  If not printable      *  (not allowed for this option), then blank, else print it.      *  Follow it with a comma if we are doing GNU usage and long      *  opts are to be printed too.      */
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
name|pAT
operator|->
name|pzSpc
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isgraph
argument_list|(
name|pOD
operator|->
name|optValue
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
operator|)
operator|==
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|pAT
operator|->
name|pzNoF
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"   -%c"
argument_list|,
name|pOD
operator|->
name|optValue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
operator|)
operator|==
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|{
name|char
name|z
index|[
literal|80
index|]
decl_stmt|;
name|tCC
modifier|*
name|pzArgType
decl_stmt|;
comment|/*          *  Determine the argument type string first on its usage, then,          *  when the option argument is required, base the type string on the          *  argument type.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
name|pzArgType
operator|=
name|pAT
operator|->
name|pzNo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
name|pzArgType
operator|=
name|pAT
operator|->
name|pzOpt
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzKey
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzKeyL
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_BOOLEAN
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzBool
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_NUMERIC
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzNum
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzNest
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_STRING
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzStr
expr_stmt|;
break|break;
default|default:
goto|goto
name|bogus_desc
goto|;
break|break;
block|}
name|snprintf
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
name|pAT
operator|->
name|pzOptFmt
argument_list|,
name|pzArgType
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
operator|(
name|pOD
operator|->
name|optMinCt
operator|!=
literal|0
operator|)
condition|?
name|pAT
operator|->
name|pzReq
else|:
name|pAT
operator|->
name|pzOpt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zOptFmtLine
argument_list|,
name|z
argument_list|,
name|pOD
operator|->
name|pzText
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|displayEnum
operator|=
operator|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|NULL
operator|)
condition|?
name|AG_TRUE
else|:
name|displayEnum
expr_stmt|;
block|}
block|}
return|return;
name|bogus_desc
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zInvalOptDesc
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Print out the usage information for just the options.  */
end_comment

begin_function
specifier|static
name|void
name|printOptionUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|ex_code
parameter_list|,
name|tCC
modifier|*
name|pOptTitle
parameter_list|)
block|{
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
name|int
name|optNo
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|docCt
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_OMITTED
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ex_code
operator|==
name|EXIT_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|argTypes
operator|.
name|pzBrk
argument_list|,
name|pOD
operator|->
name|pzText
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
name|docCt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|/*          *  IF       this is the first auto-opt maintained option          *    *AND*  we are doing a full help          *    *AND*  there are documentation options          *    *AND*  the last one was not a doc option,          *  THEN document that the remaining options are not user opts          */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|presetOptCt
operator|==
name|optNo
operator|)
operator|&&
operator|(
name|ex_code
operator|==
name|EXIT_SUCCESS
operator|)
operator|&&
operator|(
name|docCt
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pOD
index|[
operator|-
literal|1
index|]
operator|.
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|==
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|argTypes
operator|.
name|pzBrk
argument_list|,
name|zAuto
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
name|printOneUsage
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
operator|&
name|argTypes
argument_list|)
expr_stmt|;
comment|/*          *  IF we were invoked because of the --help option,          *  THEN print all the extra info          */
if|if
condition|(
name|ex_code
operator|==
name|EXIT_SUCCESS
condition|)
name|printExtendedUsage
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
operator|&
name|argTypes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
name|optNo
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   PROGRAM DETAILS  */
end_comment

begin_function
specifier|static
name|void
name|printProgramDetails
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|)
block|{
name|ag_bool
name|initIntro
init|=
name|AG_TRUE
decl_stmt|;
comment|/*      *  Display all the places we look for config files      */
name|printInitList
argument_list|(
name|pOptions
operator|->
name|papzHomeList
argument_list|,
operator|&
name|initIntro
argument_list|,
name|pOptions
operator|->
name|pzRcName
argument_list|,
name|pOptions
operator|->
name|pzProgPath
argument_list|)
expr_stmt|;
comment|/*      *  Let the user know about environment variable settings      */
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
name|OPTPROC_ENVIRON
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|initIntro
condition|)
name|fputs
argument_list|(
name|zPresetIntro
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zExamineFmt
argument_list|,
name|pOptions
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
block|}
comment|/*      *  IF we found an enumeration,      *  THEN hunt for it again.  Call the handler proc with a NULL      *       option struct pointer.  That tells it to display the keywords.      */
if|if
condition|(
name|displayEnum
condition|)
block|{
name|int
name|ct
init|=
name|pOptions
operator|->
name|optCt
decl_stmt|;
name|int
name|optNo
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOptions
operator|->
name|pOptDesc
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|NULL
operator|,
name|pOD
operator|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
name|optNo
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
block|}
comment|/*      *  If there is a detail string, now is the time for that.      */
if|if
condition|(
name|pOptions
operator|->
name|pzDetail
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|pOptions
operator|->
name|pzDetail
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   OPTION LINE FORMATTING SETUP  *  *  The "OptFmt" formats receive three arguments:  *  1.  the type of the option's argument  *  2.  the long name of the option  *  3.  "YES" or "no ", depending on whether or not the option must appear  *      on the command line.  *  These formats are used immediately after the option flag (if used) has  *  been printed.  *  *  Set up the formatting for GNU-style output  */
end_comment

begin_function
specifier|static
name|int
name|setGnuOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
block|{
name|int
name|flen
init|=
literal|22
decl_stmt|;
operator|*
name|ppT
operator|=
name|zNoRq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzStr
operator|=
name|zGnuStrArg
expr_stmt|;
name|argTypes
operator|.
name|pzReq
operator|=
name|zOneSpace
expr_stmt|;
name|argTypes
operator|.
name|pzNum
operator|=
name|zGnuNumArg
expr_stmt|;
name|argTypes
operator|.
name|pzKey
operator|=
name|zGnuKeyArg
expr_stmt|;
name|argTypes
operator|.
name|pzKeyL
operator|=
name|zGnuKeyLArg
expr_stmt|;
name|argTypes
operator|.
name|pzBool
operator|=
name|zGnuBoolArg
expr_stmt|;
name|argTypes
operator|.
name|pzNest
operator|=
name|zGnuNestArg
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
name|zGnuOptArg
expr_stmt|;
name|argTypes
operator|.
name|pzNo
operator|=
name|zOneSpace
expr_stmt|;
name|argTypes
operator|.
name|pzBrk
operator|=
name|zGnuBreak
expr_stmt|;
name|argTypes
operator|.
name|pzNoF
operator|=
name|zSixSpaces
expr_stmt|;
name|argTypes
operator|.
name|pzSpc
operator|=
name|zThreeSpaces
expr_stmt|;
switch|switch
condition|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_L_N_S
condition|)
block|{
case|case
name|OPTPROC_L_N_S
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
expr_stmt|;
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zShrtGnuOptFmt
expr_stmt|;
name|zGnuStrArg
index|[
literal|0
index|]
operator|=
name|zGnuNumArg
index|[
literal|0
index|]
operator|=
name|zGnuKeyArg
index|[
literal|0
index|]
operator|=
name|zGnuBoolArg
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
literal|" [arg]"
expr_stmt|;
name|flen
operator|=
literal|8
expr_stmt|;
break|break;
block|}
return|return
name|flen
return|;
block|}
end_function

begin_comment
comment|/*  *  Standard (AutoOpts normal) option line formatting  */
end_comment

begin_function
specifier|static
name|int
name|setStdOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
block|{
name|int
name|flen
init|=
literal|0
decl_stmt|;
name|argTypes
operator|.
name|pzStr
operator|=
name|zStdStrArg
expr_stmt|;
name|argTypes
operator|.
name|pzReq
operator|=
name|zStdReqArg
expr_stmt|;
name|argTypes
operator|.
name|pzNum
operator|=
name|zStdNumArg
expr_stmt|;
name|argTypes
operator|.
name|pzKey
operator|=
name|zStdKeyArg
expr_stmt|;
name|argTypes
operator|.
name|pzKeyL
operator|=
name|zStdKeyLArg
expr_stmt|;
name|argTypes
operator|.
name|pzBool
operator|=
name|zStdBoolArg
expr_stmt|;
name|argTypes
operator|.
name|pzNest
operator|=
name|zStdNestArg
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
name|zStdOptArg
expr_stmt|;
name|argTypes
operator|.
name|pzNo
operator|=
name|zStdNoArg
expr_stmt|;
name|argTypes
operator|.
name|pzBrk
operator|=
name|zStdBreak
expr_stmt|;
name|argTypes
operator|.
name|pzNoF
operator|=
name|zFiveSpaces
expr_stmt|;
name|argTypes
operator|.
name|pzSpc
operator|=
name|zTwoSpaces
expr_stmt|;
switch|switch
condition|(
name|pOpts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_NO_REQ_OPT
operator||
name|OPTPROC_SHORTOPT
operator|)
condition|)
block|{
case|case
operator|(
name|OPTPROC_NO_REQ_OPT
operator||
name|OPTPROC_SHORTOPT
operator|)
case|:
operator|*
name|ppT
operator|=
name|zNoRq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zNrmOptFmt
expr_stmt|;
name|flen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|OPTPROC_NO_REQ_OPT
case|:
operator|*
name|ppT
operator|=
name|zNoRq_NoShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zNrmOptFmt
expr_stmt|;
name|flen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
operator|*
name|ppT
operator|=
name|zReq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zReqOptFmt
expr_stmt|;
name|flen
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|0
case|:
operator|*
name|ppT
operator|=
name|zReq_NoShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zReqOptFmt
expr_stmt|;
name|flen
operator|=
literal|24
expr_stmt|;
block|}
return|return
name|flen
return|;
block|}
end_function

begin_comment
comment|/*:  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/usage.c */
end_comment

end_unit

