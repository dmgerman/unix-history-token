begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_config.c - read and apply configuration information  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_include
include|#
directive|include
file|<netinfo/ni.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<ntp_random.h>
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCHLD
end_ifndef

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_decl_stmt
specifier|static
name|HANDLE
name|ResolverThreadHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|ResolverEventHandle
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|resolver_pipe_fd
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to let the resolver process alert the parent process */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * [Bug 467]: Some linux headers collide with CONFIG_PHONE and CONFIG_KEYS  * so #include these later.  */
end_comment

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_cmdargs.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|priority_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These routines are used to read the configuration file at  * startup time.  An entry in the file must fit on a single line.  * Entries are processed as multiple tokens separated by white space  * Lines are considered terminated when a '#' is encountered.  Blank  * lines are ignored.  */
end_comment

begin_comment
comment|/*  * Translation table - keywords to function index  */
end_comment

begin_struct
struct|struct
name|keyword
block|{
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|keytype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Command keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|keywords
index|[]
init|=
block|{
block|{
literal|"automax"
block|,
name|CONFIG_AUTOMAX
block|}
block|,
block|{
literal|"broadcast"
block|,
name|CONFIG_BROADCAST
block|}
block|,
block|{
literal|"broadcastclient"
block|,
name|CONFIG_BROADCASTCLIENT
block|}
block|,
block|{
literal|"broadcastdelay"
block|,
name|CONFIG_BDELAY
block|}
block|,
block|{
literal|"calldelay"
block|,
name|CONFIG_CDELAY
block|}
block|,
ifdef|#
directive|ifdef
name|OPENSSL
block|{
literal|"crypto"
block|,
name|CONFIG_CRYPTO
block|}
block|,
endif|#
directive|endif
comment|/* OPENSSL */
block|{
literal|"controlkey"
block|,
name|CONFIG_CONTROLKEY
block|}
block|,
block|{
literal|"disable"
block|,
name|CONFIG_DISABLE
block|}
block|,
block|{
literal|"driftfile"
block|,
name|CONFIG_DRIFTFILE
block|}
block|,
block|{
literal|"enable"
block|,
name|CONFIG_ENABLE
block|}
block|,
block|{
literal|"end"
block|,
name|CONFIG_END
block|}
block|,
block|{
literal|"filegen"
block|,
name|CONFIG_FILEGEN
block|}
block|,
block|{
literal|"fudge"
block|,
name|CONFIG_FUDGE
block|}
block|,
block|{
literal|"includefile"
block|,
name|CONFIG_INCLUDEFILE
block|}
block|,
block|{
literal|"keys"
block|,
name|CONFIG_KEYS
block|}
block|,
block|{
literal|"keysdir"
block|,
name|CONFIG_KEYSDIR
block|}
block|,
block|{
literal|"logconfig"
block|,
name|CONFIG_LOGCONFIG
block|}
block|,
block|{
literal|"logfile"
block|,
name|CONFIG_LOGFILE
block|}
block|,
block|{
literal|"manycastclient"
block|,
name|CONFIG_MANYCASTCLIENT
block|}
block|,
block|{
literal|"manycastserver"
block|,
name|CONFIG_MANYCASTSERVER
block|}
block|,
block|{
literal|"multicastclient"
block|,
name|CONFIG_MULTICASTCLIENT
block|}
block|,
block|{
literal|"peer"
block|,
name|CONFIG_PEER
block|}
block|,
block|{
literal|"phone"
block|,
name|CONFIG_PHONE
block|}
block|,
block|{
literal|"pidfile"
block|,
name|CONFIG_PIDFILE
block|}
block|,
block|{
literal|"discard"
block|,
name|CONFIG_DISCARD
block|}
block|,
block|{
literal|"requestkey"
block|,
name|CONFIG_REQUESTKEY
block|}
block|,
block|{
literal|"restrict"
block|,
name|CONFIG_RESTRICT
block|}
block|,
block|{
literal|"revoke"
block|,
name|CONFIG_REVOKE
block|}
block|,
block|{
literal|"server"
block|,
name|CONFIG_SERVER
block|}
block|,
block|{
literal|"setvar"
block|,
name|CONFIG_SETVAR
block|}
block|,
block|{
literal|"statistics"
block|,
name|CONFIG_STATISTICS
block|}
block|,
block|{
literal|"statsdir"
block|,
name|CONFIG_STATSDIR
block|}
block|,
block|{
literal|"tick"
block|,
name|CONFIG_ADJ
block|}
block|,
block|{
literal|"tinker"
block|,
name|CONFIG_TINKER
block|}
block|,
block|{
literal|"tos"
block|,
name|CONFIG_TOS
block|}
block|,
block|{
literal|"trap"
block|,
name|CONFIG_TRAP
block|}
block|,
block|{
literal|"trustedkey"
block|,
name|CONFIG_TRUSTEDKEY
block|}
block|,
block|{
literal|"ttl"
block|,
name|CONFIG_TTL
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "peer", "server", "broadcast" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|mod_keywords
index|[]
init|=
block|{
block|{
literal|"autokey"
block|,
name|CONF_MOD_SKEY
block|}
block|,
block|{
literal|"burst"
block|,
name|CONF_MOD_BURST
block|}
block|,
block|{
literal|"iburst"
block|,
name|CONF_MOD_IBURST
block|}
block|,
block|{
literal|"key"
block|,
name|CONF_MOD_KEY
block|}
block|,
block|{
literal|"maxpoll"
block|,
name|CONF_MOD_MAXPOLL
block|}
block|,
block|{
literal|"minpoll"
block|,
name|CONF_MOD_MINPOLL
block|}
block|,
block|{
literal|"mode"
block|,
name|CONF_MOD_MODE
block|}
block|,
comment|/* refclocks */
block|{
literal|"noselect"
block|,
name|CONF_MOD_NOSELECT
block|}
block|,
block|{
literal|"preempt"
block|,
name|CONF_MOD_PREEMPT
block|}
block|,
block|{
literal|"true"
block|,
name|CONF_MOD_TRUE
block|}
block|,
block|{
literal|"prefer"
block|,
name|CONF_MOD_PREFER
block|}
block|,
block|{
literal|"ttl"
block|,
name|CONF_MOD_TTL
block|}
block|,
comment|/* NTP peers */
block|{
literal|"version"
block|,
name|CONF_MOD_VERSION
block|}
block|,
block|{
literal|"dynamic"
block|,
name|CONF_MOD_DYNAMIC
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "restrict" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|res_keywords
index|[]
init|=
block|{
block|{
literal|"ignore"
block|,
name|CONF_RES_IGNORE
block|}
block|,
block|{
literal|"limited"
block|,
name|CONF_RES_LIMITED
block|}
block|,
block|{
literal|"kod"
block|,
name|CONF_RES_DEMOBILIZE
block|}
block|,
block|{
literal|"lowpriotrap"
block|,
name|CONF_RES_LPTRAP
block|}
block|,
block|{
literal|"mask"
block|,
name|CONF_RES_MASK
block|}
block|,
block|{
literal|"nomodify"
block|,
name|CONF_RES_NOMODIFY
block|}
block|,
block|{
literal|"nopeer"
block|,
name|CONF_RES_NOPEER
block|}
block|,
block|{
literal|"noquery"
block|,
name|CONF_RES_NOQUERY
block|}
block|,
block|{
literal|"noserve"
block|,
name|CONF_RES_NOSERVE
block|}
block|,
block|{
literal|"notrap"
block|,
name|CONF_RES_NOTRAP
block|}
block|,
block|{
literal|"notrust"
block|,
name|CONF_RES_NOTRUST
block|}
block|,
block|{
literal|"ntpport"
block|,
name|CONF_RES_NTPPORT
block|}
block|,
block|{
literal|"version"
block|,
name|CONF_RES_VERSION
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "trap" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|trap_keywords
index|[]
init|=
block|{
block|{
literal|"port"
block|,
name|CONF_TRAP_PORT
block|}
block|,
block|{
literal|"interface"
block|,
name|CONF_TRAP_INTERFACE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "fudge" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|fudge_keywords
index|[]
init|=
block|{
block|{
literal|"flag1"
block|,
name|CONF_FDG_FLAG1
block|}
block|,
block|{
literal|"flag2"
block|,
name|CONF_FDG_FLAG2
block|}
block|,
block|{
literal|"flag3"
block|,
name|CONF_FDG_FLAG3
block|}
block|,
block|{
literal|"flag4"
block|,
name|CONF_FDG_FLAG4
block|}
block|,
block|{
literal|"refid"
block|,
name|CONF_FDG_REFID
block|}
block|,
comment|/* this mapping should be cleaned up (endianness, \0) - kd 20041031 */
block|{
literal|"stratum"
block|,
name|CONF_FDG_STRATUM
block|}
block|,
block|{
literal|"time1"
block|,
name|CONF_FDG_TIME1
block|}
block|,
block|{
literal|"time2"
block|,
name|CONF_FDG_TIME2
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "filegen" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|filegen_keywords
index|[]
init|=
block|{
block|{
literal|"disable"
block|,
name|CONF_FGEN_FLAG_DISABLE
block|}
block|,
block|{
literal|"enable"
block|,
name|CONF_FGEN_FLAG_ENABLE
block|}
block|,
block|{
literal|"file"
block|,
name|CONF_FGEN_FILE
block|}
block|,
block|{
literal|"link"
block|,
name|CONF_FGEN_FLAG_LINK
block|}
block|,
block|{
literal|"nolink"
block|,
name|CONF_FGEN_FLAG_NOLINK
block|}
block|,
block|{
literal|"type"
block|,
name|CONF_FGEN_TYPE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "type" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|fgen_types
index|[]
init|=
block|{
block|{
literal|"age"
block|,
name|FILEGEN_AGE
block|}
block|,
block|{
literal|"day"
block|,
name|FILEGEN_DAY
block|}
block|,
block|{
literal|"month"
block|,
name|FILEGEN_MONTH
block|}
block|,
block|{
literal|"none"
block|,
name|FILEGEN_NONE
block|}
block|,
block|{
literal|"pid"
block|,
name|FILEGEN_PID
block|}
block|,
block|{
literal|"week"
block|,
name|FILEGEN_WEEK
block|}
block|,
block|{
literal|"year"
block|,
name|FILEGEN_YEAR
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "enable", "disable" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|flags_keywords
index|[]
init|=
block|{
block|{
literal|"auth"
block|,
name|PROTO_AUTHENTICATE
block|}
block|,
block|{
literal|"bclient"
block|,
name|PROTO_BROADCLIENT
block|}
block|,
block|{
literal|"calibrate"
block|,
name|PROTO_CAL
block|}
block|,
block|{
literal|"kernel"
block|,
name|PROTO_KERNEL
block|}
block|,
block|{
literal|"monitor"
block|,
name|PROTO_MONITOR
block|}
block|,
block|{
literal|"ntp"
block|,
name|PROTO_NTP
block|}
block|,
block|{
literal|"stats"
block|,
name|PROTO_FILEGEN
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "discard" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|discard_keywords
index|[]
init|=
block|{
block|{
literal|"average"
block|,
name|CONF_DISCARD_AVERAGE
block|}
block|,
block|{
literal|"minimum"
block|,
name|CONF_DISCARD_MINIMUM
block|}
block|,
block|{
literal|"monitor"
block|,
name|CONF_DISCARD_MONITOR
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "tinker" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|tinker_keywords
index|[]
init|=
block|{
block|{
literal|"step"
block|,
name|CONF_CLOCK_MAX
block|}
block|,
block|{
literal|"panic"
block|,
name|CONF_CLOCK_PANIC
block|}
block|,
block|{
literal|"dispersion"
block|,
name|CONF_CLOCK_PHI
block|}
block|,
block|{
literal|"stepout"
block|,
name|CONF_CLOCK_MINSTEP
block|}
block|,
block|{
literal|"allan"
block|,
name|CONF_CLOCK_ALLAN
block|}
block|,
block|{
literal|"huffpuff"
block|,
name|CONF_CLOCK_HUFFPUFF
block|}
block|,
block|{
literal|"freq"
block|,
name|CONF_CLOCK_FREQ
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "tos" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|tos_keywords
index|[]
init|=
block|{
block|{
literal|"minclock"
block|,
name|CONF_TOS_MINCLOCK
block|}
block|,
block|{
literal|"maxclock"
block|,
name|CONF_TOS_MAXCLOCK
block|}
block|,
block|{
literal|"minsane"
block|,
name|CONF_TOS_MINSANE
block|}
block|,
block|{
literal|"floor"
block|,
name|CONF_TOS_FLOOR
block|}
block|,
block|{
literal|"ceiling"
block|,
name|CONF_TOS_CEILING
block|}
block|,
block|{
literal|"cohort"
block|,
name|CONF_TOS_COHORT
block|}
block|,
block|{
literal|"mindist"
block|,
name|CONF_TOS_MINDISP
block|}
block|,
block|{
literal|"maxdist"
block|,
name|CONF_TOS_MAXDIST
block|}
block|,
block|{
literal|"maxhop"
block|,
name|CONF_TOS_MAXHOP
block|}
block|,
block|{
literal|"beacon"
block|,
name|CONF_TOS_BEACON
block|}
block|,
block|{
literal|"orphan"
block|,
name|CONF_TOS_ORPHAN
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_comment
comment|/*  * "crypto" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|crypto_keywords
index|[]
init|=
block|{
block|{
literal|"cert"
block|,
name|CONF_CRYPTO_CERT
block|}
block|,
block|{
literal|"gqpar"
block|,
name|CONF_CRYPTO_GQPAR
block|}
block|,
block|{
literal|"host"
block|,
name|CONF_CRYPTO_RSA
block|}
block|,
block|{
literal|"ident"
block|,
name|CONF_CRYPTO_IDENT
block|}
block|,
block|{
literal|"iffpar"
block|,
name|CONF_CRYPTO_IFFPAR
block|}
block|,
block|{
literal|"leap"
block|,
name|CONF_CRYPTO_LEAP
block|}
block|,
block|{
literal|"mvpar"
block|,
name|CONF_CRYPTO_MVPAR
block|}
block|,
block|{
literal|"pw"
block|,
name|CONF_CRYPTO_PW
block|}
block|,
block|{
literal|"randfile"
block|,
name|CONF_CRYPTO_RAND
block|}
block|,
block|{
literal|"sign"
block|,
name|CONF_CRYPTO_SIGN
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Address type selection, IPv4 or IPv4.  * Used on various lines.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|addr_type
index|[]
init|=
block|{
block|{
literal|"-4"
block|,
name|CONF_ADDR_IPV4
block|}
block|,
block|{
literal|"-6"
block|,
name|CONF_ADDR_IPV6
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "logconfig" building blocks  */
end_comment

begin_struct
struct|struct
name|masks
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_class
index|[]
init|=
block|{
block|{
literal|"clock"
block|,
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"peer"
block|,
name|NLOG_OPEER
block|}
block|,
block|{
literal|"sync"
block|,
name|NLOG_OSYNC
block|}
block|,
block|{
literal|"sys"
block|,
name|NLOG_OSYS
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_item
index|[]
init|=
block|{
block|{
literal|"info"
block|,
name|NLOG_INFO
block|}
block|,
block|{
literal|"allinfo"
block|,
name|NLOG_SYSINFO
operator||
name|NLOG_PEERINFO
operator||
name|NLOG_CLOCKINFO
operator||
name|NLOG_SYNCINFO
block|}
block|,
block|{
literal|"events"
block|,
name|NLOG_EVENT
block|}
block|,
block|{
literal|"allevents"
block|,
name|NLOG_SYSEVENT
operator||
name|NLOG_PEEREVENT
operator||
name|NLOG_CLOCKEVENT
operator||
name|NLOG_SYNCEVENT
block|}
block|,
block|{
literal|"status"
block|,
name|NLOG_STATUS
block|}
block|,
block|{
literal|"allstatus"
block|,
name|NLOG_SYSSTATUS
operator||
name|NLOG_PEERSTATUS
operator||
name|NLOG_CLOCKSTATUS
operator||
name|NLOG_SYNCSTATUS
block|}
block|,
block|{
literal|"statistics"
block|,
name|NLOG_STATIST
block|}
block|,
block|{
literal|"allstatistics"
block|,
name|NLOG_SYSSTATIST
operator||
name|NLOG_PEERSTATIST
operator||
name|NLOG_CLOCKSTATIST
operator||
name|NLOG_SYNCSTATIST
block|}
block|,
block|{
literal|"allclock"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"allpeer"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OPEER
block|}
block|,
block|{
literal|"allsys"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYS
block|}
block|,
block|{
literal|"allsync"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYNC
block|}
block|,
block|{
literal|"all"
block|,
name|NLOG_SYSMASK
operator||
name|NLOG_PEERMASK
operator||
name|NLOG_CLOCKMASK
operator||
name|NLOG_SYNCMASK
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Limits on things  */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|20
end_define

begin_comment
comment|/* 20 tokens on line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|1024
end_define

begin_comment
comment|/* maximum length of line */
end_comment

begin_define
define|#
directive|define
name|MAXPHONE
value|10
end_define

begin_comment
comment|/* maximum number of phone strings */
end_comment

begin_define
define|#
directive|define
name|MAXPPS
value|20
end_define

begin_comment
comment|/* maximum length of PPS device string */
end_comment

begin_define
define|#
directive|define
name|MAXINCLUDELEVEL
value|5
end_define

begin_comment
comment|/* maximum include file levels */
end_comment

begin_comment
comment|/*  * Miscellaneous macros  */
end_comment

begin_define
define|#
directive|define
name|STRSAME
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(*(s1) == *(s2)&& strcmp((s1), (s2)) == 0)
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '#' || (c) == '\n' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_define
define|#
directive|define
name|KEY_TYPE_MD5
value|4
end_define

begin_comment
comment|/*  * File descriptor used by the resolver save routines, and temporary file  * name.  */
end_comment

begin_decl_stmt
name|int
name|call_resolver
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ntp-genkeys sets this to 0, for example */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|res_fp
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|res_file
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enough for /tmp/ntpXXXXXX\0 */
end_comment

begin_define
define|#
directive|define
name|RES_TEMPFILE
value|"/tmp/ntpXXXXXX"
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|res_file
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Definitions of things either imported from or exported to outside  */
end_comment

begin_decl_stmt
name|short
name|default_ai_family
init|=
name|AF_UNSPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default either IPv4 or IPv6 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sys_phone
index|[
name|MAXPHONE
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ACTS phone numbers */
end_comment

begin_decl_stmt
name|char
modifier|*
name|keysdir
init|=
name|NTP_KEYSDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crypto keys directory */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SCHED_SETSCHEDULER
argument_list|)
end_if

begin_decl_stmt
name|int
name|config_priority_override
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|config_priority
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|config_file
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_decl_stmt
name|struct
name|netinfo_config_state
modifier|*
name|config_netinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_netinfo
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|alt_config_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LPTSTR
name|temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|config_file_storage
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|alt_config_file_storage
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*  * NetInfo configuration state  */
end_comment

begin_struct
struct|struct
name|netinfo_config_state
block|{
name|void
modifier|*
name|domain
decl_stmt|;
comment|/* domain with config */
name|ni_id
name|config_dir
decl_stmt|;
comment|/* ID config dir      */
name|int
name|prop_index
decl_stmt|;
comment|/* current property   */
name|int
name|val_index
decl_stmt|;
comment|/* current value      */
name|char
modifier|*
modifier|*
name|val_list
decl_stmt|;
comment|/* value list         */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_pfxmatch
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|masks
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_match
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|masks
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_logmask
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|netinfo_config_state
modifier|*
name|get_netinfo_config
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_netinfo_config
name|P
argument_list|(
operator|(
expr|struct
name|netinfo_config_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettokens_netinfo
name|P
argument_list|(
operator|(
expr|struct
name|netinfo_config_state
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|gettokens
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|matchkey
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|keyword
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|gnn_type
block|{
name|t_UNK
block|,
comment|/* Unknown */
name|t_REF
block|,
comment|/* Refclock */
name|t_MSK
comment|/* Network Mask */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|getnetnum
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|,
expr|enum
name|gnn_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_resolve
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|u_int
operator|,
name|int
operator|,
name|keyid_t
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_resolve_internal
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|abort_resolve
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|catchchild
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * get_pfxmatch - find value for prefixmatch  * and update char * accordingly  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_pfxmatch
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|s
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|s
operator|+=
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|m
operator|->
name|mask
return|;
block|}
else|else
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_match - find logmask value  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_match
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|m
operator|->
name|mask
return|;
block|}
else|else
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_logmask - build bitmask for ntp_syslogmask  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_logmask
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|t
operator|=
name|s
expr_stmt|;
name|offset
operator|=
name|get_pfxmatch
argument_list|(
operator|&
name|t
argument_list|,
name|logcfg_class
argument_list|)
expr_stmt|;
name|mask
operator|=
name|get_match
argument_list|(
name|t
argument_list|,
name|logcfg_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
return|return
name|mask
operator|<<
name|offset
return|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logconfig: illegal argument %s - ignored"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * getconfig - get command line options and read the configuration file  */
end_comment

begin_function
name|void
name|getconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|errflg
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|istart
decl_stmt|;
name|int
name|peerversion
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
name|int
name|ttl
decl_stmt|;
name|long
name|stratum
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|keyid_t
name|peerkey
decl_stmt|;
name|u_char
modifier|*
name|peerkeystr
decl_stmt|;
name|u_long
name|fudgeflag
decl_stmt|;
name|u_int
name|peerflags
decl_stmt|;
name|int
name|hmode
decl_stmt|;
name|struct
name|sockaddr_storage
name|peeraddr
decl_stmt|;
name|struct
name|sockaddr_storage
name|maskaddr
decl_stmt|;
name|FILE
modifier|*
name|fp
index|[
name|MAXINCLUDELEVEL
operator|+
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|includefile
decl_stmt|;
name|int
name|includelevel
init|=
literal|0
decl_stmt|;
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
argument_list|*
operator|(
name|tokens
index|[
name|MAXTOKENS
index|]
operator|)
argument_list|;
name|int
name|ntokens
operator|=
literal|0
argument_list|;
name|int
name|tok
operator|=
name|CONFIG_UNKNOWN
argument_list|;
expr|struct
name|interface
operator|*
name|localaddr
argument_list|;
expr|struct
name|refclockstat
name|clock_stat
argument_list|;
name|FILEGEN
operator|*
name|filegen
argument_list|;
comment|/* 	 * Initialize, initialize 	 */
name|errflg
operator|=
literal|0
argument_list|;
ifndef|#
directive|ifndef
name|SYS_WINNT
name|config_file
operator|=
name|CONFIG_FILE
argument_list|;
else|#
directive|else
name|temp
operator|=
name|CONFIG_FILE
argument_list|; 	if
operator|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|config_file_storage
argument_list|)
argument_list|)
operator|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings CONFIG_FILE failed: %m\n"
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; 	}
name|config_file
operator|=
name|config_file_storage
argument_list|;
name|temp
operator|=
name|ALT_CONFIG_FILE
argument_list|; 	if
operator|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|alt_config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|alt_config_file_storage
argument_list|)
argument_list|)
operator|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings ALT_CONFIG_FILE failed: %m\n"
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; 	}
name|alt_config_file
operator|=
name|alt_config_file_storage
argument_list|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|res_fp
operator|=
name|NULL
argument_list|;
name|ntp_syslogmask
operator|=
name|NLOG_SYNCMASK
argument_list|;
comment|/* set more via logconfig */
comment|/* 	 * install a non default variable with this daemon version 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"daemon_version=\"%s\""
argument_list|,
name|Version
argument_list|)
argument_list|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
argument_list|;
comment|/* 	 * Say how we're setting the time of day 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"settimeofday=\"%s\""
argument_list|,
name|set_tod_using
argument_list|)
argument_list|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
argument_list|;
comment|/* 	 * Initialize the loop. 	 */
name|loop_config
argument_list|(
name|LOOP_DRIFTINIT
argument_list|,
literal|0.
argument_list|)
argument_list|;
name|getCmdOpts
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
argument_list|;  	if
operator|(
operator|(
name|fp
index|[
literal|0
index|]
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
ifdef|#
directive|ifdef
name|HAVE_NETINFO
comment|/* If there is no config_file, try NetInfo. */
operator|&&
name|check_netinfo
operator|&&
operator|!
operator|(
name|config_netinfo
operator|=
name|get_netinfo_config
argument_list|()
operator|)
endif|#
directive|endif
comment|/* HAVE_NETINFO */
operator|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Couldn't open<%s>\n"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
block|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
block|;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* Under WinNT try alternate_config_file name, first NTP.CONF, then NTP.INI */
if|if
condition|(
operator|(
name|fp
index|[
literal|0
index|]
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Broadcast clients can sometimes run without 			 * a configuration file. 			 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Couldn't open<%s>\n"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|/* not SYS_WINNT */
return|return;
endif|#
directive|endif
comment|/* not SYS_WINNT */
block|}
end_function

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|tok
operator|==
name|CONFIG_END
condition|)
break|break;
if|if
condition|(
name|fp
index|[
name|includelevel
index|]
condition|)
name|tok
operator|=
name|gettokens
argument_list|(
name|fp
index|[
name|includelevel
index|]
argument_list|,
name|line
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntokens
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
else|else
name|tok
operator|=
name|gettokens_netinfo
argument_list|(
name|config_netinfo
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntokens
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NETINFO */
if|if
condition|(
name|tok
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
if|if
condition|(
name|includelevel
operator|>
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|fp
index|[
name|includelevel
operator|--
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|CONFIG_PEER
case|:
case|case
name|CONFIG_SERVER
case|:
case|case
name|CONFIG_MANYCASTCLIENT
case|:
case|case
name|CONFIG_BROADCAST
case|:
if|if
condition|(
name|tok
operator|==
name|CONFIG_PEER
condition|)
name|hmode
operator|=
name|MODE_ACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|CONFIG_SERVER
condition|)
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|CONFIG_MANYCASTCLIENT
condition|)
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
else|else
name|hmode
operator|=
name|MODE_BROADCAST
expr_stmt|;
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No address for %s, line ignored"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|istart
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peeraddr
operator|.
name|ss_family
operator|=
name|default_ai_family
expr_stmt|;
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
name|addr_type
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|CONF_ADDR_IPV4
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
case|case
name|CONF_ADDR_IPV6
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|getnetnum
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
name|t_UNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Found IPv6 address */
if|if
condition|(
name|status
operator|!=
literal|1
condition|)
block|{
name|errflg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|REFCLOCK
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|&&
endif|#
directive|endif
name|ISBADADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				 * Shouldn't be able to specify multicast 				 * address for server/peer! 				 * and unicast address for manycastclient! 				 */
if|if
condition|(
name|peeraddr
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|tok
operator|==
name|CONFIG_SERVER
operator|)
operator|||
operator|(
name|tok
operator|==
name|CONFIG_PEER
operator|)
operator|)
operator|&&
ifdef|#
directive|ifdef
name|REFCLOCK
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|&&
endif|#
directive|endif
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|peeraddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|tok
operator|==
name|CONFIG_MANYCASTCLIENT
operator|)
operator|&&
operator|!
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|peeraddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|peeraddr
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|tok
operator|==
name|CONFIG_SERVER
operator|)
operator|||
operator|(
name|tok
operator|==
name|CONFIG_PEER
operator|)
operator|)
operator|&&
ifdef|#
directive|ifdef
name|REFCLOCK
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|&&
endif|#
directive|endif
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|peeraddr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure in valid address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|tok
operator|==
name|CONFIG_MANYCASTCLIENT
operator|)
operator|&&
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|peeraddr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure in valid address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|peeraddr
operator|.
name|ss_family
operator|==
name|AF_INET6
operator|&&
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|peerversion
operator|=
name|NTP_VERSION
expr_stmt|;
name|minpoll
operator|=
name|NTP_MINDPOLL
expr_stmt|;
name|maxpoll
operator|=
name|NTP_MAXDPOLL
expr_stmt|;
name|peerkey
operator|=
literal|0
expr_stmt|;
name|peerkeystr
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"*"
expr_stmt|;
name|peerflags
operator|=
literal|0
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
name|istart
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|istart
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|mod_keywords
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|CONF_MOD_VERSION
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"peer/server version requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_char
operator|)
name|peerversion
operator|>
name|NTP_VERSION
operator|||
operator|(
name|u_char
operator|)
name|peerversion
operator|<
name|NTP_OLDVERSION
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inappropriate version number %s, line ignored"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_MOD_KEY
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"key: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerkey
operator|=
operator|(
name|int
operator|)
name|atol
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|peerflags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MINPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"minpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|minpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|minpoll
operator|<
name|NTP_MINPOLL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"minpoll: provided value (%d) is below minimum (%d)"
argument_list|,
name|minpoll
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
name|minpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
break|break;
case|case
name|CONF_MOD_MAXPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"maxpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|maxpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxpoll
operator|>
name|NTP_MAXPOLL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"maxpoll: provided value (%d) is above maximum (%d)"
argument_list|,
name|maxpoll
argument_list|,
name|NTP_MAXPOLL
argument_list|)
expr_stmt|;
name|maxpoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
block|}
break|break;
case|case
name|CONF_MOD_PREFER
case|:
name|peerflags
operator||=
name|FLAG_PREFER
expr_stmt|;
break|break;
case|case
name|CONF_MOD_PREEMPT
case|:
name|peerflags
operator||=
name|FLAG_PREEMPT
expr_stmt|;
break|break;
case|case
name|CONF_MOD_NOSELECT
case|:
name|peerflags
operator||=
name|FLAG_NOSELECT
expr_stmt|;
break|break;
case|case
name|CONF_MOD_TRUE
case|:
name|peerflags
operator||=
name|FLAG_TRUE
expr_stmt|;
case|case
name|CONF_MOD_BURST
case|:
name|peerflags
operator||=
name|FLAG_BURST
expr_stmt|;
break|break;
case|case
name|CONF_MOD_IBURST
case|:
name|peerflags
operator||=
name|FLAG_IBURST
expr_stmt|;
break|break;
case|case
name|CONF_MOD_DYNAMIC
case|:
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Warning: the \"dynamic\" keyword has been obsoleted"
literal|" and will be removed in the next release\n"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL
case|case
name|CONF_MOD_SKEY
case|:
name|peerflags
operator||=
name|FLAG_SKEY
operator||
name|FLAG_AUTHENABLE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OPENSSL */
case|case
name|CONF_MOD_TTL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ttl: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|>=
name|MAX_TTL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ttl: invalid argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_MOD_MODE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mode: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|minpoll
operator|>
name|maxpoll
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config error: minpoll> maxpoll"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|errflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|ANY_INTERFACE_CHOOSE
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|,
name|hmode
argument_list|,
name|peerversion
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|peerflags
argument_list|,
name|ttl
argument_list|,
name|peerkey
argument_list|,
name|peerkeystr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configuration of %s failed"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|errflg
operator|==
operator|-
literal|1
condition|)
block|{
name|save_resolve
argument_list|(
name|tokens
index|[
name|istart
operator|-
literal|1
index|]
argument_list|,
name|hmode
argument_list|,
name|peerversion
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|peerflags
argument_list|,
name|ttl
argument_list|,
name|peerkey
argument_list|,
name|peerkeystr
argument_list|,
name|peeraddr
operator|.
name|ss_family
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_DRIFTFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|stats_write_period
operator|=
name|stats_write_tolerance
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntokens
operator|>=
literal|3
condition|)
name|stats_write_period
operator|=
literal|60
operator|*
name|atol
argument_list|(
name|tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats_write_period
operator|<=
literal|0
condition|)
name|stats_write_period
operator|=
literal|3600
expr_stmt|;
if|if
condition|(
name|ntokens
operator|>=
literal|4
condition|)
block|{
name|double
name|ftemp
decl_stmt|;
name|sscanf
argument_list|(
name|tokens
index|[
literal|3
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|ftemp
argument_list|)
expr_stmt|;
name|stats_write_tolerance
operator|=
name|ftemp
operator|/
literal|100
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_PIDFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_END
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|includelevel
condition|;
name|i
operator|++
control|)
block|{
name|fclose
argument_list|(
name|fp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_INCLUDEFILE
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"includefile needs one argument"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|includelevel
operator|>=
name|MAXINCLUDELEVEL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Maximum include file level exceeded.\n"
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Maximum include file level exceeded."
argument_list|)
expr_stmt|;
break|break;
block|}
name|includefile
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|includefile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Couldn't open<%s>\n"
argument_list|,
name|FindConfig
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fp
index|[
operator|++
name|includelevel
index|]
operator|=
name|includefile
expr_stmt|;
break|break;
case|case
name|CONFIG_LOGFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
name|new_file
operator|=
name|fopen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"logging to file %s"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
operator|&&
name|fileno
argument_list|(
name|syslog_file
argument_list|)
operator|!=
name|fileno
argument_list|(
name|new_file
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|syslog_file
operator|=
name|new_file
expr_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot open log file %s"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logfile needs one argument"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_LOGCONFIG
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|add
init|=
literal|1
decl_stmt|;
name|int
name|equals
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|&
name|tokens
index|[
name|i
index|]
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'='
case|:
name|add
operator|=
operator|*
name|s
operator|==
literal|'+'
expr_stmt|;
name|equals
operator|=
operator|*
name|s
operator|==
literal|'='
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|equals
condition|)
block|{
name|ntp_syslogmask
operator|=
name|get_logmask
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|add
condition|)
block|{
name|ntp_syslogmask
operator||=
name|get_logmask
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntp_syslogmask
operator|&=
operator|~
name|get_logmask
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ntp_syslogmask = 0x%08lx (%s)\n"
argument_list|,
name|ntp_syslogmask
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|CONFIG_BROADCASTCLIENT
case|:
if|if
condition|(
name|ntokens
operator|==
literal|1
condition|)
block|{
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
literal|2
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_MULTICASTCLIENT
case|:
case|case
name|CONFIG_MANYCASTSERVER
case|:
if|if
condition|(
name|ntokens
operator|>
literal|1
condition|)
block|{
name|istart
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peeraddr
operator|.
name|ss_family
operator|=
name|default_ai_family
expr_stmt|;
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
name|addr_type
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|CONF_ADDR_IPV4
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
case|case
name|CONF_ADDR_IPV6
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 				 * Abuse maskaddr to store the prefered ip 				 * version. 				 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|maskaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|maskaddr
argument_list|)
argument_list|)
expr_stmt|;
name|maskaddr
operator|.
name|ss_family
operator|=
name|peeraddr
operator|.
name|ss_family
expr_stmt|;
for|for
control|(
name|i
operator|=
name|istart
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peeraddr
operator|.
name|ss_family
operator|=
name|maskaddr
operator|.
name|ss_family
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|==
literal|1
condition|)
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|,
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|CONFIG_MULTICASTCLIENT
condition|)
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|CONFIG_MANYCASTSERVER
condition|)
name|sys_manycastserver
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CONFIG_KEYS
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|getauthkeys
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_KEYSDIR
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Keys directory name required"
argument_list|)
expr_stmt|;
break|break;
block|}
name|keysdir
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|keysdir
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_TINKER
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|temp
decl_stmt|;
name|double
name|ftemp
decl_stmt|;
name|temp
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
operator|++
index|]
argument_list|,
name|tinker_keywords
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tinker: missing argument"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
name|sscanf
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|ftemp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|CONF_CLOCK_MAX
case|:
name|loop_config
argument_list|(
name|LOOP_MAX
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CLOCK_PANIC
case|:
name|loop_config
argument_list|(
name|LOOP_PANIC
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CLOCK_PHI
case|:
name|loop_config
argument_list|(
name|LOOP_PHI
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CLOCK_MINSTEP
case|:
name|loop_config
argument_list|(
name|LOOP_MINSTEP
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CLOCK_ALLAN
case|:
name|loop_config
argument_list|(
name|LOOP_ALLAN
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CLOCK_HUFFPUFF
case|:
name|loop_config
argument_list|(
name|LOOP_HUFFPUFF
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CLOCK_FREQ
case|:
name|loop_config
argument_list|(
name|LOOP_FREQ
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|CONFIG_TOS
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|temp
decl_stmt|;
name|double
name|ftemp
decl_stmt|;
name|temp
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
operator|++
index|]
argument_list|,
name|tos_keywords
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tos: missing argument"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
name|sscanf
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|ftemp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|CONF_TOS_MINCLOCK
case|:
name|proto_config
argument_list|(
name|PROTO_MINCLOCK
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_MAXCLOCK
case|:
name|proto_config
argument_list|(
name|PROTO_MAXCLOCK
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_MINSANE
case|:
name|proto_config
argument_list|(
name|PROTO_MINSANE
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_FLOOR
case|:
name|proto_config
argument_list|(
name|PROTO_FLOOR
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_CEILING
case|:
name|proto_config
argument_list|(
name|PROTO_CEILING
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_COHORT
case|:
name|proto_config
argument_list|(
name|PROTO_COHORT
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_MINDISP
case|:
name|proto_config
argument_list|(
name|PROTO_MINDISP
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_MAXDIST
case|:
name|proto_config
argument_list|(
name|PROTO_MAXDIST
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_MAXHOP
case|:
name|proto_config
argument_list|(
name|PROTO_MAXHOP
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_ORPHAN
case|:
name|proto_config
argument_list|(
name|PROTO_ORPHAN
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_TOS_BEACON
case|:
name|proto_config
argument_list|(
name|PROTO_BEACON
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|CONFIG_TTL
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
operator|&&
name|i
operator|<
name|MAX_TTL
condition|;
name|i
operator|++
control|)
block|{
name|sys_ttl
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
name|atoi
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sys_ttlmax
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_DISCARD
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
operator|++
index|]
argument_list|,
name|discard_keywords
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"discard: missing argument"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|CONF_DISCARD_AVERAGE
case|:
name|res_avg_interval
operator|=
name|atoi
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_DISCARD_MINIMUM
case|:
name|res_min_interval
operator|=
name|atoi
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_DISCARD_MONITOR
case|:
name|mon_age
operator|=
name|atoi
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"discard: unknown keyword"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|OPENSSL
case|case
name|CONFIG_REVOKE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|sys_revoke
operator|=
operator|(
name|u_char
operator|)
name|max
argument_list|(
name|atoi
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|KEY_REVOKE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_AUTOMAX
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|sys_automax
operator|=
literal|1
operator|<<
name|max
argument_list|(
name|atoi
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_CRYPTO
case|:
if|if
condition|(
name|ntokens
operator|==
literal|1
condition|)
block|{
name|crypto_config
argument_list|(
name|CRYPTO_CONF_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
operator|++
index|]
argument_list|,
name|crypto_keywords
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto: missing argument"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|CONF_CRYPTO_CERT
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_CERT
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_RSA
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_PRIV
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_IDENT
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_IDENT
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_IFFPAR
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_IFFPAR
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_GQPAR
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_GQPAR
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_MVPAR
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_MVPAR
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_LEAP
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_LEAP
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_PW
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_PW
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_RAND
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_RAND
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_CRYPTO_SIGN
case|:
name|crypto_config
argument_list|(
name|CRYPTO_CONF_SIGN
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto: unknown keyword"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* OPENSSL */
case|case
name|CONFIG_RESTRICT
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"restrict requires an address"
argument_list|)
expr_stmt|;
break|break;
block|}
name|istart
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peeraddr
operator|.
name|ss_family
operator|=
name|default_ai_family
expr_stmt|;
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
name|addr_type
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|CONF_ADDR_IPV4
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
case|case
name|CONF_ADDR_IPV6
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 			 * Assume default means an IPv4 address, except 			 * if forced by a -4 or -6. 			 */
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
name|peeraddr
operator|.
name|ss_family
operator|==
literal|0
condition|)
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getnetnum
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|!=
literal|1
condition|)
break|break;
comment|/* 			 * Use peerversion as flags, peerkey as mflags.  Ick. 			 */
name|peerversion
operator|=
literal|0
expr_stmt|;
name|peerkey
operator|=
literal|0
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|SET_HOSTMASK
argument_list|(
operator|&
name|maskaddr
argument_list|,
name|peeraddr
operator|.
name|ss_family
argument_list|)
expr_stmt|;
name|istart
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|istart
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|res_keywords
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|CONF_RES_MASK
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mask keyword needs argument"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
operator|&
name|maskaddr
argument_list|,
literal|1
argument_list|,
name|t_MSK
argument_list|)
operator|!=
literal|1
condition|)
name|errflg
operator|++
expr_stmt|;
break|break;
case|case
name|CONF_RES_IGNORE
case|:
name|peerversion
operator||=
name|RES_IGNORE
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOSERVE
case|:
name|peerversion
operator||=
name|RES_DONTSERVE
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOTRUST
case|:
name|peerversion
operator||=
name|RES_DONTTRUST
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOQUERY
case|:
name|peerversion
operator||=
name|RES_NOQUERY
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOMODIFY
case|:
name|peerversion
operator||=
name|RES_NOMODIFY
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOPEER
case|:
name|peerversion
operator||=
name|RES_NOPEER
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOTRAP
case|:
name|peerversion
operator||=
name|RES_NOTRAP
expr_stmt|;
break|break;
case|case
name|CONF_RES_LPTRAP
case|:
name|peerversion
operator||=
name|RES_LPTRAP
expr_stmt|;
break|break;
case|case
name|CONF_RES_NTPPORT
case|:
name|peerkey
operator||=
name|RESM_NTPONLY
expr_stmt|;
break|break;
case|case
name|CONF_RES_VERSION
case|:
name|peerversion
operator||=
name|RES_VERSION
expr_stmt|;
break|break;
case|case
name|CONF_RES_DEMOBILIZE
case|:
name|peerversion
operator||=
name|RES_DEMOBILIZE
expr_stmt|;
break|break;
case|case
name|CONF_RES_LIMITED
case|:
name|peerversion
operator||=
name|RES_LIMITED
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|SOCKNUL
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
name|ANYSOCK
argument_list|(
operator|&
name|maskaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errflg
condition|)
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|peeraddr
argument_list|,
operator|&
name|maskaddr
argument_list|,
operator|(
name|int
operator|)
name|peerkey
argument_list|,
name|peerversion
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_BDELAY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|double
name|tmp
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|tmp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"broadcastdelay value %s undecodable"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto_config
argument_list|(
name|PROTO_BROADDELAY
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_CDELAY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|u_long
name|ui
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|ui
argument_list|)
operator|!=
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"illegal value - line ignored"
argument_list|)
expr_stmt|;
else|else
name|proto_config
argument_list|(
name|PROTO_CALLDELAY
argument_list|,
name|ui
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_TRUSTEDKEY
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|keyid_t
name|tkey
decl_stmt|;
name|tkey
operator|=
name|atol
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkey
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trusted key %s unlikely"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authtrust
argument_list|(
name|tkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_REQUESTKEY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|ul
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is undecodable as request key"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ul
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s makes a poor request keyid"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"set info_auth_key to %08lx\n"
argument_list|,
name|ul
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info_auth_keyid
operator|=
operator|(
name|keyid_t
operator|)
name|ul
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_CONTROLKEY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|keyid_t
name|ckey
decl_stmt|;
name|ckey
operator|=
name|atol
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckey
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s makes a poor control keyid"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_auth_keyid
operator|=
name|ckey
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_TRAP
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no address for trap command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
name|istart
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peeraddr
operator|.
name|ss_family
operator|=
name|default_ai_family
expr_stmt|;
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
name|addr_type
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|CONF_ADDR_IPV4
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
case|case
name|CONF_ADDR_IPV6
case|:
name|peeraddr
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
name|istart
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|getnetnum
argument_list|(
name|tokens
index|[
name|istart
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|!=
literal|1
condition|)
break|break;
comment|/* 			 * Use peerversion for port number.  Barf. 			 */
name|errflg
operator|=
literal|0
expr_stmt|;
name|peerversion
operator|=
literal|0
expr_stmt|;
name|localaddr
operator|=
literal|0
expr_stmt|;
name|istart
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|istart
init|;
name|i
operator|<
name|ntokens
operator|-
literal|1
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|trap_keywords
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|CONF_TRAP_PORT
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trap port requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|peerversion
operator|<=
literal|0
operator|||
name|peerversion
operator|>
literal|32767
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid port number %s, trap ignored"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_TRAP_INTERFACE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trap interface requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|maskaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|maskaddr
argument_list|)
argument_list|)
expr_stmt|;
name|maskaddr
operator|.
name|ss_family
operator|=
name|peeraddr
operator|.
name|ss_family
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|maskaddr
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|localaddr
operator|=
name|findinterface
argument_list|(
operator|&
name|maskaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localaddr
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find interface with address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|maskaddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
if|if
condition|(
name|peerversion
operator|!=
literal|0
condition|)
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|peeraddr
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|peerversion
argument_list|)
expr_stmt|;
else|else
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|peeraddr
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|TRAPPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|localaddr
operator|==
name|NULL
condition|)
name|localaddr
operator|=
name|ANY_INTERFACE_CHOOSE
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
name|NTP_VERSION
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't set trap for %s, no resources"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_FUDGE
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no address for fudge command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|,
name|t_REF
argument_list|)
operator|!=
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is inappropriate address for the fudge command, line ignored"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|clock_stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|clock_stat
argument_list|)
expr_stmt|;
name|fudgeflag
operator|=
literal|0
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|fudge_keywords
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|CONF_FDG_TIME1
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|clock_stat
operator|.
name|fudgetime1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s time1 value in error"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_TIME2
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|clock_stat
operator|.
name|fudgetime2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s time2 value in error"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_STRATUM
case|:
if|if
condition|(
operator|!
name|atoint
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|stratum
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s stratum value in error"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock_stat
operator|.
name|fudgeval1
operator|=
name|stratum
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_REFID
case|:
name|i
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|clock_stat
operator|.
name|fudgeval2
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|,
name|min
argument_list|(
name|strlen
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG1
case|:
case|case
name|CONF_FDG_FLAG2
case|:
case|case
name|CONF_FDG_FLAG3
case|:
case|case
name|CONF_FDG_FLAG4
case|:
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|fudgeflag
argument_list|)
operator|||
name|fudgeflag
operator|>
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s flag value in error"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CONF_FDG_FLAG1
case|:
name|c
operator|=
name|CLK_FLAG1
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG2
case|:
name|c
operator|=
name|CLK_FLAG2
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG3
case|:
name|c
operator|=
name|CLK_FLAG3
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG3
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG4
case|:
name|c
operator|=
name|CLK_FLAG4
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fudgeflag
operator|==
literal|0
condition|)
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|c
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator||=
name|c
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 			 * If reference clock support isn't defined the 			 * fudge line will still be accepted and syntax 			 * checked, but will essentially do nothing. 			 */
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
name|refclock_control
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|&
name|clock_stat
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|CONFIG_STATSDIR
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|stats_config
argument_list|(
name|STATS_STATSDIR
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_STATISTICS
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|filegen
operator|=
name|filegen_get
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filegen
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no statistics named %s available"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"enabling filegen for %s statistics \"%s%s\"\n"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|,
name|filegen
operator|->
name|prefix
argument_list|,
name|filegen
operator|->
name|basename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filegen
operator|->
name|flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_FILEGEN
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no id for filegen command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
name|filegen
operator|=
name|filegen_get
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filegen
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown filegen \"%s\" ignored"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * peerversion is (ab)used for filegen file (index) 			 * peerkey	   is (ab)used for filegen type 			 * peerflags   is (ab)used for filegen flags 			 */
name|peerversion
operator|=
literal|0
expr_stmt|;
name|peerkey
operator|=
name|filegen
operator|->
name|type
expr_stmt|;
name|peerflags
operator|=
name|filegen
operator|->
name|flag
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|filegen_keywords
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|CONF_FGEN_FILE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s file requires argument"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
operator|++
name|i
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_TYPE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s type requires argument"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|peerkey
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
name|fgen_types
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|peerkey
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s unknown type \"%s\""
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONF_FGEN_FLAG_LINK
case|:
name|peerflags
operator||=
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_NOLINK
case|:
name|peerflags
operator|&=
operator|~
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_ENABLE
case|:
name|peerflags
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_DISABLE
case|:
name|peerflags
operator|&=
operator|~
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|errflg
condition|)
name|filegen_config
argument_list|(
name|filegen
argument_list|,
name|tokens
index|[
name|peerversion
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|peerkey
argument_list|,
operator|(
name|u_char
operator|)
name|peerflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_SETVAR
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no value for setvar command - line ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_sys_var
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
name|strlen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|,
call|(
name|u_short
call|)
argument_list|(
name|RW
operator||
operator|(
operator|(
operator|(
operator|(
name|ntokens
operator|>
literal|2
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|tokens
index|[
literal|2
index|]
argument_list|,
literal|"default"
argument_list|)
operator|)
operator|)
condition|?
name|DEF
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_ENABLE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flag
decl_stmt|;
name|flag
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|flags_keywords
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"enable unknown flag %s"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|proto_config
argument_list|(
name|flag
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_DISABLE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flag
decl_stmt|;
name|flag
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|flags_keywords
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"disable unknown flag %s"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|proto_config
argument_list|(
name|flag
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_PHONE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
operator|&&
name|i
operator|<
name|MAXPHONE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|sys_phone
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sys_phone
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sys_phone
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CONFIG_ADJ
case|:
block|{
name|double
name|ftemp
decl_stmt|;
name|sscanf
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|ftemp
argument_list|)
expr_stmt|;
name|proto_config
argument_list|(
name|PROTO_ADJ
argument_list|,
literal|0
argument_list|,
name|ftemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|fp
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_if
if|if
condition|(
name|config_netinfo
condition|)
name|free_netinfo_config
argument_list|(
name|config_netinfo
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
end_if

begin_comment
comment|/* find a keyid */
end_comment

begin_if
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
name|req_keyid
operator|=
literal|65535
expr_stmt|;
else|else
name|req_keyid
operator|=
name|info_auth_keyid
expr_stmt|;
end_if

begin_comment
comment|/* if doesn't exist, make up one at random */
end_comment

begin_if
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|char
name|rankey
index|[
literal|9
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|100
condition|;
operator|++
name|j
control|)
block|{
name|rankey
index|[
name|i
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|ntp_random
argument_list|()
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rankey
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
name|rankey
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|authusekey
argument_list|(
name|req_keyid
argument_list|,
name|KEY_TYPE_MD5
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|rankey
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|req_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getconfig: Couldn't generate a valid random key!"
argument_list|)
expr_stmt|;
comment|/* HMS: Should this be fatal? */
block|}
block|}
end_if

begin_comment
comment|/* save keyid so we will accept config requests with it */
end_comment

begin_expr_stmt
name|info_auth_keyid
operator|=
name|req_keyid
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(VMS)&& !defined(SYS_VXWORKS) */
end_comment

begin_if
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|call_resolver
condition|)
block|{
comment|/* 			 * Need name resolution 			 */
name|do_resolve_internal
argument_list|()
expr_stmt|;
block|}
block|}
end_if

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*   * get_netinfo_config - find the nearest NetInfo domain with an ntp  * configuration and initialize the configuration state.  */
end_comment

begin_function
unit|static
name|struct
name|netinfo_config_state
modifier|*
name|get_netinfo_config
parameter_list|()
block|{
name|ni_status
name|status
decl_stmt|;
name|void
modifier|*
name|domain
decl_stmt|;
name|ni_id
name|config_dir
decl_stmt|;
name|struct
name|netinfo_config_state
modifier|*
name|config
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|,
operator|&
name|domain
argument_list|)
operator|!=
name|NI_OK
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|status
operator|=
name|ni_pathsearch
argument_list|(
name|domain
argument_list|,
operator|&
name|config_dir
argument_list|,
name|NETINFO_CONFIG_DIR
argument_list|)
operator|)
operator|==
name|NI_NODIR
condition|)
block|{
name|void
modifier|*
name|next_domain
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|domain
argument_list|,
literal|".."
argument_list|,
operator|&
name|next_domain
argument_list|)
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|next_domain
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|domain
operator|=
name|next_domain
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|config
operator|=
operator|(
expr|struct
name|netinfo_config_state
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo_config_state
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|config
operator|->
name|config_dir
operator|=
name|config_dir
expr_stmt|;
name|config
operator|->
name|prop_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
return|return
name|config
return|;
block|}
end_function

begin_comment
comment|/*  * free_netinfo_config - release NetInfo configuration state  */
end_comment

begin_function
specifier|static
name|void
name|free_netinfo_config
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|)
block|{
name|ni_free
argument_list|(
name|config
operator|->
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gettokens_netinfo - return tokens from NetInfo  */
end_comment

begin_function
specifier|static
name|int
name|gettokens_netinfo
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|,
name|char
modifier|*
modifier|*
name|tokenlist
parameter_list|,
name|int
modifier|*
name|ntokens
parameter_list|)
block|{
name|int
name|prop_index
init|=
name|config
operator|->
name|prop_index
decl_stmt|;
name|int
name|val_index
init|=
name|config
operator|->
name|val_index
decl_stmt|;
name|char
modifier|*
modifier|*
name|val_list
init|=
name|config
operator|->
name|val_list
decl_stmt|;
comment|/* 	 * Iterate through each keyword and look for a property that matches it. 	 */
name|again
label|:
if|if
condition|(
operator|!
name|val_list
condition|)
block|{
for|for
control|(
init|;
name|prop_index
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|keywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|keywords
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|prop_index
operator|++
control|)
block|{
name|ni_namelist
name|namelist
decl_stmt|;
name|struct
name|keyword
name|current_prop
init|=
name|keywords
index|[
name|prop_index
index|]
decl_stmt|;
comment|/* 			 * For each value associated in the property, we're going to return 			 * a separate line. We squirrel away the values in the config state 			 * so the next time through, we don't need to do this lookup. 			 */
name|NI_INIT
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni_lookupprop
argument_list|(
name|config
operator|->
name|domain
argument_list|,
operator|&
name|config
operator|->
name|config_dir
argument_list|,
name|current_prop
operator|.
name|text
argument_list|,
operator|&
name|namelist
argument_list|)
operator|==
name|NI_OK
condition|)
block|{
name|ni_index
name|index
decl_stmt|;
comment|/* Found the property, but it has no values */
if|if
condition|(
name|namelist
operator|.
name|ni_namelist_len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|val_list
operator|=
name|config
operator|->
name|val_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|namelist
operator|.
name|ni_namelist_len
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"out of memory while configuring"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|namelist
operator|.
name|ni_namelist_len
condition|;
name|index
operator|++
control|)
block|{
name|char
modifier|*
name|value
init|=
name|namelist
operator|.
name|ni_namelist_val
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|val_list
index|[
name|index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"out of memory while configuring"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|val_list
index|[
name|index
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|val_list
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ni_namelist_free
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
block|}
name|config
operator|->
name|prop_index
operator|=
name|prop_index
expr_stmt|;
block|}
comment|/* No list; we're done here. */
if|if
condition|(
operator|!
name|val_list
condition|)
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* 	 * We have a list of values for the current property. 	 * Iterate through them and return each in order. 	 */
if|if
condition|(
name|val_list
index|[
name|val_index
index|]
condition|)
block|{
name|int
name|ntok
init|=
literal|1
decl_stmt|;
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tokens
init|=
name|val_list
index|[
name|val_index
index|]
decl_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s"
argument_list|,
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
argument_list|,
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
operator|(
specifier|const
name|char
operator|*
operator|)
name|tokenlist
index|[
literal|0
index|]
operator|=
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
expr_stmt|;
for|for
control|(
name|ntok
operator|=
literal|1
init|;
name|ntok
operator|<
name|MAXTOKENS
condition|;
name|ntok
operator|++
control|)
block|{
name|tokenlist
index|[
name|ntok
index|]
operator|=
name|tokens
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|tokens
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
block|{
operator|*
name|tokens
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|tokens
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
name|tokens
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ntok
operator|==
name|MAXTOKENS
condition|)
block|{
comment|/* HMS: chomp it to lose the EOL? */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettokens_netinfo: too many tokens.  Ignoring: %s"
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ntokens
operator|=
name|ntok
operator|+
literal|1
expr_stmt|;
block|}
name|config
operator|->
name|val_index
operator|++
expr_stmt|;
comment|/* HMS: Should this be in the 'else'? */
return|return
name|keywords
index|[
name|prop_index
index|]
operator|.
name|keytype
return|;
block|}
comment|/* We're done with the current property. */
name|prop_index
operator|=
operator|++
name|config
operator|->
name|prop_index
expr_stmt|;
comment|/* Free val_list and reset counters. */
for|for
control|(
name|val_index
operator|=
literal|0
init|;
name|val_list
index|[
name|val_index
index|]
condition|;
name|val_index
operator|++
control|)
name|free
argument_list|(
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val_list
argument_list|)
expr_stmt|;
name|val_list
operator|=
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
name|val_index
operator|=
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_comment
comment|/*  * gettokens - read a line and return tokens  */
end_comment

begin_function
specifier|static
name|int
name|gettokens
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|tokenlist
parameter_list|,
name|int
modifier|*
name|ntokens
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|ntok
decl_stmt|;
specifier|register
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* 	 * Find start of first token 	 */
name|again
label|:
while|while
condition|(
operator|(
name|cp
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|MAXLINE
argument_list|,
name|fp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|*
name|ntokens
operator|=
literal|0
expr_stmt|;
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* hack.  Is recognized as EOF */
block|}
comment|/* 	 * Now separate out the tokens 	 */
for|for
control|(
name|ntok
operator|=
literal|0
init|;
name|ntok
operator|<
name|MAXTOKENS
condition|;
name|ntok
operator|++
control|)
block|{
name|tokenlist
index|[
name|ntok
index|]
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|cp
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Heiko: Remove leading and trailing quotes around tokens */
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntok
condition|;
name|i
operator|++
control|)
block|{
comment|/* Now check if the first char is a quote and remove that */
if|if
condition|(
name|tokenlist
index|[
name|ntok
index|]
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
name|tokenlist
index|[
name|ntok
index|]
operator|++
expr_stmt|;
comment|/* Now check the last char ... */
name|j
operator|=
name|strlen
argument_list|(
name|tokenlist
index|[
name|ntok
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tokenlist
index|[
name|ntok
index|]
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
name|tokenlist
index|[
name|ntok
index|]
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntok
operator|==
name|MAXTOKENS
condition|)
block|{
operator|--
name|ntok
expr_stmt|;
comment|/* HMS: chomp it to lose the EOL? */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettokens: too many tokens on the line. Ignoring %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Return the match 		 */
operator|*
name|ntokens
operator|=
name|ntok
operator|+
literal|1
expr_stmt|;
name|ntok
operator|=
name|matchkey
argument_list|(
name|tokenlist
index|[
literal|0
index|]
argument_list|,
name|keywords
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|CONFIG_UNKNOWN
condition|)
goto|goto
name|again
goto|;
block|}
return|return
name|ntok
return|;
block|}
end_function

begin_comment
comment|/*  * matchkey - match a keyword to a list  */
end_comment

begin_function
specifier|static
name|int
name|matchkey
parameter_list|(
specifier|register
name|char
modifier|*
name|word
parameter_list|,
specifier|register
name|struct
name|keyword
modifier|*
name|keys
parameter_list|,
name|int
name|complain
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|keys
operator|->
name|keytype
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configure: keyword \"%s\" unknown, line ignored"
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|CONFIG_UNKNOWN
return|;
block|}
if|if
condition|(
name|STRSAME
argument_list|(
name|word
argument_list|,
name|keys
operator|->
name|text
argument_list|)
condition|)
return|return
name|keys
operator|->
name|keytype
return|;
name|keys
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * getnetnum - return a net number (this is crude, but careful)  */
end_comment

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|complain
parameter_list|,
name|enum
name|gnn_type
name|a_type
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ptr
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|#
directive|if
literal|0
block|printf("getnetnum:<%s> is a %s (%d)\n", 		num, 		(a_type == t_UNK) 		? "t_UNK" 		: (a_type == t_REF) 		  ? "t_REF" 		  : (a_type == t_MSK) 		    ? "t_MSK" 		    : "???", 		a_type);
endif|#
directive|endif
comment|/* Get host address. Looking for UDP datagram connection */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
operator|||
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
name|hints
operator|.
name|ai_family
operator|=
name|addr
operator|->
name|ss_family
expr_stmt|;
else|else
name|hints
operator|.
name|ai_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* 	 * If we don't have an IPv6 stack, just look up IPv4 addresses 	 */
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
condition|)
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
if|if
condition|(
name|a_type
operator|!=
name|t_UNK
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"getnetnum: calling getaddrinfo(%s,...)\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|num
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
operator|||
operator|(
name|ptr
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|&&
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getaddrinfo: \"%s\" invalid host address, ignored"
argument_list|,
name|num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"getaddrinfo: \"%s\" invalid host address%s.\n"
argument_list|,
name|num
argument_list|,
operator|(
name|complain
operator|)
condition|?
literal|", ignored"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|ptr
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|&&
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
name|memcpy
argument_list|(
name|addr
argument_list|,
name|ptr
operator|->
name|ai_addr
argument_list|,
name|ptr
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"getnetnum given %s, got %s (%s/%d)\n"
argument_list|,
name|num
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|a_type
operator|==
name|t_UNK
operator|)
condition|?
literal|"t_UNK"
else|:
operator|(
name|a_type
operator|==
name|t_REF
operator|)
condition|?
literal|"t_REF"
else|:
operator|(
name|a_type
operator|==
name|t_MSK
operator|)
condition|?
literal|"t_MSK"
else|:
literal|"???"
argument_list|,
name|a_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freeaddrinfo
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_comment
comment|/*  * catchchild - receive the resolver's exit status  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|catchchild
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
comment|/* 	 * We only start up one child, and if we're here 	 * it should have already exited.  Hence the following 	 * shouldn't hang.  If it does, please tell me. 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|(
name|void
operator|)
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT&& VXWORKS*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * save_resolve - save configuration info into a file for later name resolution  */
end_comment

begin_function
specifier|static
name|void
name|save_resolve
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|minpoll
parameter_list|,
name|int
name|maxpoll
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|ttl
parameter_list|,
name|keyid_t
name|keyid
parameter_list|,
name|u_char
modifier|*
name|keystr
parameter_list|,
name|u_char
name|peeraf
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SYS_VXWORKS
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|res_file
argument_list|,
name|RES_TEMPFILE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no /tmp directory under NT */
block|{
if|if
condition|(
operator|!
operator|(
name|GetTempPath
argument_list|(
operator|(
name|DWORD
operator|)
name|MAX_PATH
argument_list|,
operator|(
name|LPTSTR
operator|)
name|res_file
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot get pathname for temporary directory: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|res_file
argument_list|,
literal|"ntpdXXXXXX"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
ifdef|#
directive|ifdef
name|HAVE_MKSTEMP
block|{
name|int
name|fd
decl_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|res_file
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|res_fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|fopen
argument_list|(
name|res_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open failed for %s: %m"
argument_list|,
name|res_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"resolving %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|res_fp
argument_list|,
literal|"%s %u %d %d %d %d %d %d %u %s\n"
argument_list|,
name|name
argument_list|,
name|peeraf
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|flags
argument_list|,
name|ttl
argument_list|,
name|keyid
argument_list|,
name|keystr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"config: %s %u %d %d %d %d %x %d %u %s\n"
argument_list|,
name|name
argument_list|,
name|peeraf
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|flags
argument_list|,
name|ttl
argument_list|,
name|keyid
argument_list|,
name|keystr
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* SYS_VXWORKS */
comment|/* save resolve info to a struct */
endif|#
directive|endif
comment|/* SYS_VXWORKS */
block|}
end_function

begin_comment
comment|/*  * abort_resolve - terminate the resolver stuff and delete the file  */
end_comment

begin_function
specifier|static
name|void
name|abort_resolve
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * In an ideal world we would might reread the file and 	 * log the hosts which aren't getting configured.  Since 	 * this is too much work, however, just close and delete 	 * the temp file. 	 */
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_VXWORKS
comment|/* we don't open the file to begin with */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|delete
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* SYS_VXWORKS */
block|}
end_function

begin_comment
comment|/*  * do_resolve_internal - start up the resolver function (not program)  */
end_comment

begin_comment
comment|/*  * On VMS, this routine will simply refuse to resolve anything.  *  * Possible implementation: keep `res_file' in memory, do async  * name resolution via QIO, update from within completion AST.  * I'm unlikely to find the time for doing this, though. -wjm  */
end_comment

begin_function
specifier|static
name|void
name|do_resolve_internal
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
comment|/* belch */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"do_resolve_internal: Fatal: res_fp == NULL"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* we are done with this now */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
name|req_file
operator|=
name|res_file
expr_stmt|;
comment|/* set up pointer to res file */
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|catchchild
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_VXWORKS
comment|/* the parent process will write to the pipe 	 * in order to wake up to child process 	 * which may be waiting in a select() call 	 * on the read fd */
if|if
condition|(
name|pipe
argument_list|(
name|resolver_pipe_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to open resolver pipe"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
comment|/* Shouldn't the code below be re-ordered? 	 * I.e. first check if the fork() returned an error, then 	 * check whether we're parent or child. 	 *     Martin Burnicki 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		 * this used to close everything 		 * I don't think this is necessary 		 */
comment|/* 		 * To the unknown commenter above: 		 * Well, I think it's better to clean up 		 * after oneself. I have had problems with 		 * refclock-io when intres was running - things 		 * where fine again when ntpintres was gone. 		 * So some systems react erratic at least. 		 * 		 *			Frank Kardel 		 * 		 * 94-11-16: 		 * Further debugging has proven that the above is 		 * absolutely harmful. The internal resolver 		 * is still in the SIGIO process group and the lingering 		 * async io information causes it to process requests from 		 * all file decriptor causing a race between the NTP daemon 		 * and the resolver. which then eats data when it wins 8-(. 		 * It is absolutly necessary to kill any IO associations 		 * shared with the NTP daemon. 		 * 		 * We also block SIGIO (currently no ports means to 		 * disable the signal handle for IO). 		 * 		 * Thanks to wgstuken@informatik.uni-erlangen.de to notice 		 * that it is the ntp-resolver child running into trouble. 		 * 		 * THUS: 		 */
comment|/* This is the child process who will read the pipe, 		 * so we close the write fd */
name|close
argument_list|(
name|resolver_pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
name|kill_asyncio
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
literal|0
condition|)
name|debug
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"ntpd_initres"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_DAEMON */
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
literal|"ntpd_initres"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_CYGWIN32
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEBUG */
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* @@@ was INFO */
endif|#
directive|endif
comment|/* LOG_DAEMON */
endif|#
directive|endif
name|ntp_intres
argument_list|()
expr_stmt|;
comment|/* 		 * If we got here, the intres code screwed up. 		 * Print something so we don't die without complaint 		 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"call to ntp_intres lost"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* vxWorks spawns a thread... -casey */
name|i
operator|=
name|sp
argument_list|(
name|ntp_intres
argument_list|)
expr_stmt|;
comment|/*i = taskSpawn("ntp_intres",100,VX_FP_TASK,20000,ntp_intres);*/
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork() failed, can't start ntp_intres: %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the parent process who will write to the pipe, 		 * so we close the read fd */
name|close
argument_list|(
name|resolver_pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* SYS_WINNT */
block|{
comment|/* NT's equivalent of fork() is _spawn(), but the start point 		 * of the new process is an executable filename rather than 		 * a function name as desired here. 		 */
name|DWORD
name|dwThreadId
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ResolverEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResolverEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to create resolver event object, can't start ntp_intres"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
name|ResolverThreadHandle
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
comment|/* no security attributes	*/
literal|0
argument_list|,
comment|/* use default stack size	*/
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|ntp_intres
argument_list|,
comment|/* thread function		*/
name|NULL
argument_list|,
comment|/* argument to thread function   */
literal|0
argument_list|,
comment|/* use default creation flags	  */
operator|&
name|dwThreadId
argument_list|)
expr_stmt|;
comment|/* returns the thread identifier */
if|if
condition|(
name|ResolverThreadHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CreateThread() failed, can't start ntp_intres"
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|ResolverEventHandle
argument_list|)
expr_stmt|;
name|ResolverEventHandle
operator|=
name|NULL
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
else|#
directive|else
comment|/* VMS  VX_WORKS */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Name resolution not implemented for VMS - use numeric addresses"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS VX_WORKS */
block|}
end_function

end_unit

