begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 Paolo Abeni (Italy)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in the  * documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote   * products derived from this software without specific prior written   * permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * USB sniffing API implementation for Linux platform  * By Paolo Abeni<paolo.abeni@email.it>  * Modifications: Kris Katterjohn<katterjohn@gmail.com>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap-usb-linux.c,v 1.33 2008-12-23 21:38:50 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap-usb-linux.h"
end_include

begin_include
include|#
directive|include
file|"pcap/usb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_STRERROR_H
end_ifdef

begin_include
include|#
directive|include
file|"strerror.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<byteswap.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_USBDEVICE_FS_H
end_ifdef

begin_comment
comment|/*  * We might need<linux/compiler.h> to define __user for  *<linux/usbdevice_fs.h>.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_COMPILER_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/compiler.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_COMPILER_H */
end_comment

begin_include
include|#
directive|include
file|<linux/usbdevice_fs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_USBDEVICE_FS_H */
end_comment

begin_define
define|#
directive|define
name|USB_IFACE
value|"usbmon"
end_define

begin_define
define|#
directive|define
name|USB_TEXT_DIR_OLD
value|"/sys/kernel/debug/usbmon"
end_define

begin_define
define|#
directive|define
name|USB_TEXT_DIR
value|"/sys/kernel/debug/usb/usbmon"
end_define

begin_define
define|#
directive|define
name|SYS_USB_BUS_DIR
value|"/sys/bus/usb/devices"
end_define

begin_define
define|#
directive|define
name|PROC_USB_BUS_DIR
value|"/proc/bus/usb"
end_define

begin_define
define|#
directive|define
name|USB_LINE_LEN
value|4096
end_define

begin_if
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|htols
parameter_list|(
name|s
parameter_list|)
value|s
end_define

begin_define
define|#
directive|define
name|htoll
parameter_list|(
name|l
parameter_list|)
value|l
end_define

begin_define
define|#
directive|define
name|htol64
parameter_list|(
name|ll
parameter_list|)
value|ll
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|htols
parameter_list|(
name|s
parameter_list|)
value|bswap_16(s)
end_define

begin_define
define|#
directive|define
name|htoll
parameter_list|(
name|l
parameter_list|)
value|bswap_32(l)
end_define

begin_define
define|#
directive|define
name|htol64
parameter_list|(
name|ll
parameter_list|)
value|bswap_64(ll)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|mon_bin_stats
block|{
name|u_int32_t
name|queued
decl_stmt|;
name|u_int32_t
name|dropped
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mon_bin_get
block|{
name|pcap_usb_header
modifier|*
name|hdr
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|size_t
name|data_len
decl_stmt|;
comment|/* Length of data (can be zero) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mon_bin_mfetch
block|{
name|int32_t
modifier|*
name|offvec
decl_stmt|;
comment|/* Vector of events fetched */
name|int32_t
name|nfetch
decl_stmt|;
comment|/* Number of events to fetch (out: fetched) */
name|int32_t
name|nflush
decl_stmt|;
comment|/* Number of events to flush */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MON_IOC_MAGIC
value|0x92
end_define

begin_define
define|#
directive|define
name|MON_IOCQ_URB_LEN
value|_IO(MON_IOC_MAGIC, 1)
end_define

begin_define
define|#
directive|define
name|MON_IOCX_URB
value|_IOWR(MON_IOC_MAGIC, 2, struct mon_bin_hdr)
end_define

begin_define
define|#
directive|define
name|MON_IOCG_STATS
value|_IOR(MON_IOC_MAGIC, 3, struct mon_bin_stats)
end_define

begin_define
define|#
directive|define
name|MON_IOCT_RING_SIZE
value|_IO(MON_IOC_MAGIC, 4)
end_define

begin_define
define|#
directive|define
name|MON_IOCQ_RING_SIZE
value|_IO(MON_IOC_MAGIC, 5)
end_define

begin_define
define|#
directive|define
name|MON_IOCX_GET
value|_IOW(MON_IOC_MAGIC, 6, struct mon_bin_get)
end_define

begin_define
define|#
directive|define
name|MON_IOCX_MFETCH
value|_IOWR(MON_IOC_MAGIC, 7, struct mon_bin_mfetch)
end_define

begin_define
define|#
directive|define
name|MON_IOCH_MFLUSH
value|_IO(MON_IOC_MAGIC, 8)
end_define

begin_define
define|#
directive|define
name|MON_BIN_SETUP
value|0x1
end_define

begin_comment
comment|/* setup hdr is present*/
end_comment

begin_define
define|#
directive|define
name|MON_BIN_SETUP_ZERO
value|0x2
end_define

begin_comment
comment|/* setup buffer is not available */
end_comment

begin_define
define|#
directive|define
name|MON_BIN_DATA_ZERO
value|0x4
end_define

begin_comment
comment|/* data buffer is not available */
end_comment

begin_define
define|#
directive|define
name|MON_BIN_ERROR
value|0x8
end_define

begin_comment
comment|/* forward declaration */
end_comment

begin_function_decl
specifier|static
name|int
name|usb_activate
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_stats_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_stats_linux_bin
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_read_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_read_linux_bin
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_read_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_inject_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_setdirection_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_direction_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_cleanup_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* facility to add an USB device to the device list*/
end_comment

begin_function
specifier|static
name|int
name|usb_dev_add
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|int
name|n
parameter_list|,
name|char
modifier|*
name|err_str
parameter_list|)
block|{
name|char
name|dev_name
index|[
literal|10
index|]
decl_stmt|;
name|char
name|dev_descr
index|[
literal|30
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|dev_name
argument_list|,
literal|10
argument_list|,
name|USB_IFACE
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|dev_descr
argument_list|,
literal|30
argument_list|,
literal|"USB bus number %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_add_if
argument_list|(
name|alldevsp
argument_list|,
name|dev_name
argument_list|,
literal|0
argument_list|,
name|dev_descr
argument_list|,
name|err_str
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|usb_findalldevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|err_str
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* try scanning sysfs usb bus directory */
name|dir
operator|=
name|opendir
argument_list|(
name|SYS_USB_BUS_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|data
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|name
operator|=
name|data
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"usb"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
operator|&
name|name
index|[
literal|3
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ret
operator|=
name|usb_dev_add
argument_list|(
name|alldevsp
argument_list|,
name|n
argument_list|,
name|err_str
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* that didn't work; try scanning procfs usb bus directory */
name|dir
operator|=
name|opendir
argument_list|(
name|PROC_USB_BUS_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|data
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|name
operator|=
name|data
operator|->
name|d_name
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* if this file name does not end with a number it's not of our interest */
if|if
condition|(
operator|(
name|len
operator|<
literal|1
operator|)
operator|||
operator|!
name|isdigit
argument_list|(
name|name
index|[
operator|--
name|len
index|]
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|isdigit
argument_list|(
name|name
index|[
operator|--
name|len
index|]
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|&
name|name
index|[
name|len
operator|+
literal|1
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
condition|)
continue|continue;
name|ret
operator|=
name|usb_dev_add
argument_list|(
name|alldevsp
argument_list|,
name|n
argument_list|,
name|err_str
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* neither of them worked */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|int
name|len
init|=
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|MON_IOCQ_RING_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|handle
operator|->
name|md
operator|.
name|mmapbuflen
operator|=
name|len
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|mmapbuf
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|handle
operator|->
name|md
operator|.
name|mmapbuflen
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|handle
operator|->
name|md
operator|.
name|mmapbuf
operator|!=
name|MAP_FAILED
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CTRL_TIMEOUT
value|(5*1000)
end_define

begin_comment
comment|/* milliseconds */
end_comment

begin_define
define|#
directive|define
name|USB_DIR_IN
value|0x80
end_define

begin_define
define|#
directive|define
name|USB_TYPE_STANDARD
value|0x00
end_define

begin_define
define|#
directive|define
name|USB_RECIP_DEVICE
value|0x00
end_define

begin_define
define|#
directive|define
name|USB_REQ_GET_DESCRIPTOR
value|6
end_define

begin_define
define|#
directive|define
name|USB_DT_DEVICE
value|1
end_define

begin_comment
comment|/* probe the descriptors of the devices attached to the bus */
end_comment

begin_comment
comment|/* the descriptors will end up in the captured packet stream */
end_comment

begin_comment
comment|/* and be decoded by external apps like wireshark */
end_comment

begin_comment
comment|/* without these identifying probes packet data can't be fully decoded */
end_comment

begin_function
specifier|static
name|void
name|probe_devices
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|struct
name|usbdevfs_ctrltransfer
name|ctrl
decl_stmt|;
name|struct
name|dirent
modifier|*
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
comment|/* scan usb bus directories for device nodes */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/dev/bus/usb/%03d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return;
while|while
condition|(
operator|(
name|ret
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|data
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|data
operator|->
name|d_name
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/dev/bus/usb/%03d/%s"
argument_list|,
name|bus
argument_list|,
name|data
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* 		 * Sigh.  Different kernels have different member names 		 * for this structure. 		 */
ifdef|#
directive|ifdef
name|HAVE_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
name|ctrl
operator|.
name|bRequestType
operator|=
name|USB_DIR_IN
operator||
name|USB_TYPE_STANDARD
operator||
name|USB_RECIP_DEVICE
expr_stmt|;
name|ctrl
operator|.
name|bRequest
operator|=
name|USB_REQ_GET_DESCRIPTOR
expr_stmt|;
name|ctrl
operator|.
name|wValue
operator|=
name|USB_DT_DEVICE
operator|<<
literal|8
expr_stmt|;
name|ctrl
operator|.
name|wIndex
operator|=
literal|0
expr_stmt|;
name|ctrl
operator|.
name|wLength
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|ctrl
operator|.
name|requesttype
operator|=
name|USB_DIR_IN
operator||
name|USB_TYPE_STANDARD
operator||
name|USB_RECIP_DEVICE
expr_stmt|;
name|ctrl
operator|.
name|request
operator|=
name|USB_REQ_GET_DESCRIPTOR
expr_stmt|;
name|ctrl
operator|.
name|value
operator|=
name|USB_DT_DEVICE
operator|<<
literal|8
expr_stmt|;
name|ctrl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|ctrl
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctrl
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|ctrl
operator|.
name|timeout
operator|=
name|CTRL_TIMEOUT
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|USBDEVFS_CONTROL
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|usb_create
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
modifier|*
name|is_ours
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cpend
decl_stmt|;
name|long
name|devnum
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
comment|/* Does this look like a USB monitoring device? */
name|cp
operator|=
name|strrchr
argument_list|(
name|device
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|device
expr_stmt|;
comment|/* Does it begin with USB_IFACE? */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|USB_IFACE
argument_list|,
sizeof|sizeof
name|USB_IFACE
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Nope, doesn't begin with USB_IFACE */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Yes - is USB_IFACE followed by a number? */
name|cp
operator|+=
sizeof|sizeof
name|USB_IFACE
operator|-
literal|1
expr_stmt|;
name|devnum
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cpend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpend
operator|==
name|cp
operator|||
operator|*
name|cpend
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Not followed by a number. */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|devnum
operator|<
literal|0
condition|)
block|{
comment|/* Followed by a non-valid number. */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* OK, it's probably ours. */
operator|*
name|is_ours
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|pcap_create_common
argument_list|(
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|activate_op
operator|=
name|usb_activate
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_activate
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|char
name|full_path
index|[
name|USB_LINE_LEN
index|]
decl_stmt|;
comment|/* Initialize some components of the pcap structure. */
name|handle
operator|->
name|bufsize
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|linktype
operator|=
name|DLT_USB_LINUX
expr_stmt|;
name|handle
operator|->
name|inject_op
operator|=
name|usb_inject_linux
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|install_bpf_program
expr_stmt|;
comment|/* no kernel filtering */
name|handle
operator|->
name|setdirection_op
operator|=
name|usb_setdirection_linux
expr_stmt|;
name|handle
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* can't change data link type */
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_fd
expr_stmt|;
comment|/*get usb bus index from device name */
if|if
condition|(
name|sscanf
argument_list|(
name|handle
operator|->
name|opt
operator|.
name|source
argument_list|,
name|USB_IFACE
literal|"%d"
argument_list|,
operator|&
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't get USB bus index from %s"
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|source
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/*now select the read method: try to open binary interface */
name|snprintf
argument_list|(
name|full_path
argument_list|,
name|USB_LINE_LEN
argument_list|,
name|LINUX_USB_MON_DEV
literal|"%d"
argument_list|,
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
expr_stmt|;
name|handle
operator|->
name|fd
operator|=
name|open
argument_list|(
name|full_path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 			 * Monitor mode doesn't apply to USB devices. 			 */
name|close
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
comment|/* binary api is available, try to use fast mmap access */
if|if
condition|(
name|usb_mmap
argument_list|(
name|handle
argument_list|)
condition|)
block|{
name|handle
operator|->
name|linktype
operator|=
name|DLT_USB_LINUX_MMAPPED
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|usb_stats_linux_bin
expr_stmt|;
name|handle
operator|->
name|read_op
operator|=
name|usb_read_linux_mmap
expr_stmt|;
name|handle
operator|->
name|cleanup_op
operator|=
name|usb_cleanup_linux_mmap
expr_stmt|;
name|probe_devices
argument_list|(
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
expr_stmt|;
comment|/* 			 * "handle->fd" is a real file, so "select()" and 			 * "poll()" work on it. 			 */
name|handle
operator|->
name|selectable_fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* can't mmap, use plain binary interface access */
name|handle
operator|->
name|stats_op
operator|=
name|usb_stats_linux_bin
expr_stmt|;
name|handle
operator|->
name|read_op
operator|=
name|usb_read_linux_bin
expr_stmt|;
name|probe_devices
argument_list|(
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*Binary interface not available, try open text interface */
name|snprintf
argument_list|(
name|full_path
argument_list|,
name|USB_LINE_LEN
argument_list|,
name|USB_TEXT_DIR
literal|"/%dt"
argument_list|,
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
expr_stmt|;
name|handle
operator|->
name|fd
operator|=
name|open
argument_list|(
name|full_path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* 				 * Not found at the new location; try 				 * the old location. 				 */
name|snprintf
argument_list|(
name|full_path
argument_list|,
name|USB_LINE_LEN
argument_list|,
name|USB_TEXT_DIR_OLD
literal|"/%dt"
argument_list|,
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
expr_stmt|;
name|handle
operator|->
name|fd
operator|=
name|open
argument_list|(
name|full_path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handle
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* no more fallback, give it up*/
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't open USB bus file %s: %s"
argument_list|,
name|full_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 			 * Monitor mode doesn't apply to USB devices. 			 */
name|close
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
name|handle
operator|->
name|stats_op
operator|=
name|usb_stats_linux
expr_stmt|;
name|handle
operator|->
name|read_op
operator|=
name|usb_read_linux
expr_stmt|;
block|}
comment|/* 	 * "handle->fd" is a real file, so "select()" and "poll()" 	 * work on it. 	 */
name|handle
operator|->
name|selectable_fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
comment|/* for plain binary access and text access we need to allocate the read 	 * buffer */
name|handle
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|buffer
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ascii_to_int
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|<
literal|'A'
condition|?
name|c
operator|-
literal|'0'
else|:
operator|(
operator|(
name|c
operator|<
literal|'a'
operator|)
condition|?
name|c
operator|-
literal|'A'
operator|+
literal|10
else|:
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * see<linux-kernel-source>/Documentation/usb/usbmon.txt and   *<linux-kernel-source>/drivers/usb/mon/mon_text.c for urb string   * format description  */
end_comment

begin_function
specifier|static
name|int
name|usb_read_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
comment|/* see: 	* /usr/src/linux/Documentation/usb/usbmon.txt  	* for message format 	*/
name|unsigned
name|timestamp
decl_stmt|;
name|int
name|tag
decl_stmt|,
name|cnt
decl_stmt|,
name|ep_num
decl_stmt|,
name|dev_addr
decl_stmt|,
name|dummy
decl_stmt|,
name|ret
decl_stmt|,
name|urb_len
decl_stmt|,
name|data_len
decl_stmt|;
name|char
name|etype
decl_stmt|,
name|pipeid1
decl_stmt|,
name|pipeid2
decl_stmt|,
name|status
index|[
literal|16
index|]
decl_stmt|,
name|urb_tag
decl_stmt|,
name|line
index|[
name|USB_LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|line
decl_stmt|;
name|u_char
modifier|*
name|rawdata
init|=
name|handle
operator|->
name|buffer
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pkth
decl_stmt|;
name|pcap_usb_header
modifier|*
name|uhdr
init|=
operator|(
name|pcap_usb_header
operator|*
operator|)
name|handle
operator|->
name|buffer
decl_stmt|;
name|u_char
name|urb_transfer
init|=
literal|0
decl_stmt|;
name|int
name|incoming
init|=
literal|0
decl_stmt|;
comment|/* ignore interrupt system call errors */
do|do
block|{
name|ret
operator|=
name|read
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|line
argument_list|,
name|USB_LINE_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
do|while
condition|(
operator|(
name|ret
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|0
return|;
comment|/* no data there */
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't read from fd %d: %s"
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* read urb header; %n argument may increment return value, but it's  	* not mandatory, so does not count on it*/
name|string
index|[
name|ret
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%x %d %c %c%c:%d:%d %s%n"
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|timestamp
argument_list|,
operator|&
name|etype
argument_list|,
operator|&
name|pipeid1
argument_list|,
operator|&
name|pipeid2
argument_list|,
operator|&
name|dev_addr
argument_list|,
operator|&
name|ep_num
argument_list|,
name|status
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|8
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't parse USB bus message '%s', too few tokens (expected 8 got %d)"
argument_list|,
name|string
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|uhdr
operator|->
name|id
operator|=
name|tag
expr_stmt|;
name|uhdr
operator|->
name|device_address
operator|=
name|dev_addr
expr_stmt|;
name|uhdr
operator|->
name|bus_id
operator|=
name|handle
operator|->
name|md
operator|.
name|ifindex
expr_stmt|;
name|uhdr
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|string
operator|+=
name|cnt
expr_stmt|;
comment|/* don't use usbmon provided timestamp, since it have low precision*/
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|pkth
operator|.
name|ts
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't get timestamp for message '%s' %d:%s"
argument_list|,
name|string
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|uhdr
operator|->
name|ts_sec
operator|=
name|pkth
operator|.
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|uhdr
operator|->
name|ts_usec
operator|=
name|pkth
operator|.
name|ts
operator|.
name|tv_usec
expr_stmt|;
comment|/* parse endpoint information */
if|if
condition|(
name|pipeid1
operator|==
literal|'C'
condition|)
name|urb_transfer
operator|=
name|URB_CONTROL
expr_stmt|;
elseif|else
if|if
condition|(
name|pipeid1
operator|==
literal|'Z'
condition|)
name|urb_transfer
operator|=
name|URB_ISOCHRONOUS
expr_stmt|;
elseif|else
if|if
condition|(
name|pipeid1
operator|==
literal|'I'
condition|)
name|urb_transfer
operator|=
name|URB_INTERRUPT
expr_stmt|;
elseif|else
if|if
condition|(
name|pipeid1
operator|==
literal|'B'
condition|)
name|urb_transfer
operator|=
name|URB_BULK
expr_stmt|;
if|if
condition|(
name|pipeid2
operator|==
literal|'i'
condition|)
block|{
name|ep_num
operator||=
name|URB_TRANSFER_IN
expr_stmt|;
name|incoming
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|etype
operator|==
literal|'C'
condition|)
name|incoming
operator|=
operator|!
name|incoming
expr_stmt|;
comment|/* direction check*/
if|if
condition|(
name|incoming
condition|)
block|{
if|if
condition|(
name|handle
operator|->
name|direction
operator|==
name|PCAP_D_OUT
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|handle
operator|->
name|direction
operator|==
name|PCAP_D_IN
condition|)
return|return
literal|0
return|;
name|uhdr
operator|->
name|event_type
operator|=
name|etype
expr_stmt|;
name|uhdr
operator|->
name|transfer_type
operator|=
name|urb_transfer
expr_stmt|;
name|uhdr
operator|->
name|endpoint_number
operator|=
name|ep_num
expr_stmt|;
name|pkth
operator|.
name|caplen
operator|=
sizeof|sizeof
argument_list|(
name|pcap_usb_header
argument_list|)
expr_stmt|;
name|rawdata
operator|+=
sizeof|sizeof
argument_list|(
name|pcap_usb_header
argument_list|)
expr_stmt|;
comment|/* check if this is a setup packet */
name|ret
operator|=
name|sscanf
argument_list|(
name|status
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
comment|/* this a setup packet, setup data can be filled with underscore if 		* usbmon has not been able to read them, so we must parse this fields as  		* strings */
name|pcap_usb_setup
modifier|*
name|shdr
decl_stmt|;
name|char
name|str1
index|[
literal|3
index|]
decl_stmt|,
name|str2
index|[
literal|3
index|]
decl_stmt|,
name|str3
index|[
literal|5
index|]
decl_stmt|,
name|str4
index|[
literal|5
index|]
decl_stmt|,
name|str5
index|[
literal|5
index|]
decl_stmt|;
name|ret
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%s %s %s %s %s%n"
argument_list|,
name|str1
argument_list|,
name|str2
argument_list|,
name|str3
argument_list|,
name|str4
argument_list|,
name|str5
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|5
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't parse USB bus message '%s', too few tokens (expected 5 got %d)"
argument_list|,
name|string
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|string
operator|+=
name|cnt
expr_stmt|;
comment|/* try to convert to corresponding integer */
name|shdr
operator|=
operator|&
name|uhdr
operator|->
name|setup
expr_stmt|;
name|shdr
operator|->
name|bmRequestType
operator|=
name|strtoul
argument_list|(
name|str1
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|bRequest
operator|=
name|strtoul
argument_list|(
name|str2
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|wValue
operator|=
name|htols
argument_list|(
name|strtoul
argument_list|(
name|str3
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|wIndex
operator|=
name|htols
argument_list|(
name|strtoul
argument_list|(
name|str4
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|wLength
operator|=
name|htols
argument_list|(
name|strtoul
argument_list|(
name|str5
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|uhdr
operator|->
name|setup_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|uhdr
operator|->
name|setup_flag
operator|=
literal|1
expr_stmt|;
comment|/* read urb data */
name|ret
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %d%n"
argument_list|,
operator|&
name|urb_len
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't parse urb length from '%s'"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|string
operator|+=
name|cnt
expr_stmt|;
comment|/* urb tag is not present if urb length is 0, so we can stop here  	 * text parsing */
name|pkth
operator|.
name|len
operator|=
name|urb_len
operator|+
name|pkth
operator|.
name|caplen
expr_stmt|;
name|uhdr
operator|->
name|urb_len
operator|=
name|urb_len
expr_stmt|;
name|uhdr
operator|->
name|data_flag
operator|=
literal|1
expr_stmt|;
name|data_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uhdr
operator|->
name|urb_len
operator|==
literal|0
condition|)
goto|goto
name|got
goto|;
comment|/* check for data presence; data is present if and only if urb tag is '=' */
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %c"
argument_list|,
operator|&
name|urb_tag
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't parse urb tag from '%s'"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|urb_tag
operator|!=
literal|'='
condition|)
goto|goto
name|got
goto|;
comment|/* skip urb tag and following space */
name|string
operator|+=
literal|3
expr_stmt|;
comment|/* if we reach this point we got some urb data*/
name|uhdr
operator|->
name|data_flag
operator|=
literal|0
expr_stmt|;
comment|/* read all urb data; if urb length is greater then the usbmon internal  	 * buffer length used by the kernel to spool the URB, we get only 	 * a partial information. 	 * At least until linux 2.6.17 there is no way to set usbmon intenal buffer 	 * length and default value is 130. */
while|while
condition|(
operator|(
name|string
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|string
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pkth
operator|.
name|caplen
operator|<
name|handle
operator|->
name|snapshot
operator|)
condition|)
block|{
name|rawdata
index|[
literal|0
index|]
operator|=
name|ascii_to_int
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|ascii_to_int
argument_list|(
name|string
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rawdata
operator|++
expr_stmt|;
name|string
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|string
operator|++
expr_stmt|;
name|pkth
operator|.
name|caplen
operator|++
expr_stmt|;
name|data_len
operator|++
expr_stmt|;
block|}
name|got
label|:
name|uhdr
operator|->
name|data_len
operator|=
name|data_len
expr_stmt|;
if|if
condition|(
name|pkth
operator|.
name|caplen
operator|>
name|handle
operator|->
name|snapshot
condition|)
name|pkth
operator|.
name|caplen
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|||
name|bpf_filter
argument_list|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|handle
operator|->
name|buffer
argument_list|,
name|pkth
operator|.
name|len
argument_list|,
name|pkth
operator|.
name|caplen
argument_list|)
condition|)
block|{
name|handle
operator|->
name|md
operator|.
name|packets_read
operator|++
expr_stmt|;
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pkth
argument_list|,
name|handle
operator|->
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* didn't pass filter */
block|}
end_function

begin_function
specifier|static
name|int
name|usb_inject_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"inject not supported on "
literal|"USB devices"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_stats_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|dummy
decl_stmt|,
name|ret
decl_stmt|,
name|consumed
decl_stmt|,
name|cnt
decl_stmt|;
name|char
name|string
index|[
name|USB_LINE_LEN
index|]
decl_stmt|;
name|char
name|token
index|[
name|USB_LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|string
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|snprintf
argument_list|(
name|string
argument_list|,
name|USB_LINE_LEN
argument_list|,
name|USB_TEXT_DIR
literal|"/%ds"
argument_list|,
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|string
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* 			 * Not found at the new location; try the old 			 * location. 			 */
name|snprintf
argument_list|(
name|string
argument_list|,
name|USB_LINE_LEN
argument_list|,
name|USB_TEXT_DIR_OLD
literal|"/%ds"
argument_list|,
name|handle
operator|->
name|md
operator|.
name|ifindex
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|string
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't open USB stats file %s: %s"
argument_list|,
name|string
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* read stats line */
do|do
block|{
name|ret
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|string
argument_list|,
name|USB_LINE_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ret
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't read stats from fd %d "
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|string
index|[
name|ret
index|]
operator|=
literal|0
expr_stmt|;
comment|/* extract info on dropped urbs */
for|for
control|(
name|consumed
operator|=
literal|0
init|;
name|consumed
operator|<
name|ret
condition|;
control|)
block|{
comment|/* from the sscanf man page:   		 * The C standard says: "Execution of a %n directive does   		 * not increment the assignment count returned at the completion 		 * of  execution" but the Corrigendum seems to contradict this. 		 * Do not make any assumptions on the effect of %n conversions  		 * on the return value and explicitly check for cnt assignmet*/
name|int
name|ntok
decl_stmt|;
name|cnt
operator|=
operator|-
literal|1
expr_stmt|;
name|ntok
operator|=
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%s%n"
argument_list|,
name|token
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntok
operator|<
literal|1
operator|)
operator|||
operator|(
name|cnt
operator|<
literal|0
operator|)
condition|)
break|break;
name|consumed
operator|+=
name|cnt
expr_stmt|;
name|ptr
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"nreaders"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|stats
operator|->
name|ps_drop
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|!=
literal|1
condition|)
break|break;
name|consumed
operator|+=
name|cnt
expr_stmt|;
name|ptr
operator|+=
name|cnt
expr_stmt|;
block|}
name|stats
operator|->
name|ps_recv
operator|=
name|handle
operator|->
name|md
operator|.
name|packets_read
expr_stmt|;
name|stats
operator|->
name|ps_ifdrop
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_setdirection_linux
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_direction_t
name|d
parameter_list|)
block|{
name|p
operator|->
name|direction
operator|=
name|d
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_stats_linux_bin
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|mon_bin_stats
name|st
decl_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|MON_IOCG_STATS
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't read stats from fd %d:%s "
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|stats
operator|->
name|ps_recv
operator|=
name|handle
operator|->
name|md
operator|.
name|packets_read
operator|+
name|st
operator|.
name|queued
expr_stmt|;
name|stats
operator|->
name|ps_drop
operator|=
name|st
operator|.
name|dropped
expr_stmt|;
name|stats
operator|->
name|ps_ifdrop
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * see<linux-kernel-source>/Documentation/usb/usbmon.txt and   *<linux-kernel-source>/drivers/usb/mon/mon_bin.c binary ABI  */
end_comment

begin_function
specifier|static
name|int
name|usb_read_linux_bin
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|mon_bin_get
name|info
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pkth
decl_stmt|;
name|int
name|clen
init|=
name|handle
operator|->
name|snapshot
operator|-
sizeof|sizeof
argument_list|(
name|pcap_usb_header
argument_list|)
decl_stmt|;
comment|/* the usb header is going to be part of 'packet' data*/
name|info
operator|.
name|hdr
operator|=
operator|(
name|pcap_usb_header
operator|*
operator|)
name|handle
operator|->
name|buffer
expr_stmt|;
name|info
operator|.
name|data
operator|=
name|handle
operator|->
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|pcap_usb_header
argument_list|)
expr_stmt|;
name|info
operator|.
name|data_len
operator|=
name|clen
expr_stmt|;
comment|/* ignore interrupt system call errors */
do|do
block|{
name|ret
operator|=
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|MON_IOCX_GET
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
do|while
condition|(
operator|(
name|ret
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|0
return|;
comment|/* no data there */
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't read from fd %d: %s"
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* we can get less that than really captured from kernel, depending on 	 * snaplen, so adjust header accordingly */
if|if
condition|(
name|info
operator|.
name|hdr
operator|->
name|data_len
operator|<
name|clen
condition|)
name|clen
operator|=
name|info
operator|.
name|hdr
operator|->
name|data_len
expr_stmt|;
name|info
operator|.
name|hdr
operator|->
name|data_len
operator|=
name|clen
expr_stmt|;
name|pkth
operator|.
name|caplen
operator|=
name|clen
operator|+
sizeof|sizeof
argument_list|(
name|pcap_usb_header
argument_list|)
expr_stmt|;
name|pkth
operator|.
name|len
operator|=
name|info
operator|.
name|hdr
operator|->
name|data_len
operator|+
sizeof|sizeof
argument_list|(
name|pcap_usb_header
argument_list|)
expr_stmt|;
name|pkth
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|info
operator|.
name|hdr
operator|->
name|ts_sec
expr_stmt|;
name|pkth
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|info
operator|.
name|hdr
operator|->
name|ts_usec
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|||
name|bpf_filter
argument_list|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|handle
operator|->
name|buffer
argument_list|,
name|pkth
operator|.
name|len
argument_list|,
name|pkth
operator|.
name|caplen
argument_list|)
condition|)
block|{
name|handle
operator|->
name|md
operator|.
name|packets_read
operator|++
expr_stmt|;
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pkth
argument_list|,
name|handle
operator|->
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* didn't pass filter */
block|}
end_function

begin_comment
comment|/*  * see<linux-kernel-source>/Documentation/usb/usbmon.txt and   *<linux-kernel-source>/drivers/usb/mon/mon_bin.c binary ABI  */
end_comment

begin_define
define|#
directive|define
name|VEC_SIZE
value|32
end_define

begin_function
specifier|static
name|int
name|usb_read_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|mon_bin_mfetch
name|fetch
decl_stmt|;
name|int32_t
name|vec
index|[
name|VEC_SIZE
index|]
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pkth
decl_stmt|;
name|pcap_usb_header
modifier|*
name|hdr
decl_stmt|;
name|int
name|nflush
init|=
literal|0
decl_stmt|;
name|int
name|packets
init|=
literal|0
decl_stmt|;
name|int
name|clen
decl_stmt|,
name|max_clen
decl_stmt|;
name|max_clen
operator|=
name|handle
operator|->
name|snapshot
operator|-
sizeof|sizeof
argument_list|(
name|pcap_usb_header
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|limit
init|=
name|max_packets
operator|-
name|packets
decl_stmt|;
if|if
condition|(
name|limit
operator|<=
literal|0
condition|)
name|limit
operator|=
name|VEC_SIZE
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|VEC_SIZE
condition|)
name|limit
operator|=
name|VEC_SIZE
expr_stmt|;
comment|/* try to fetch as many events as possible*/
name|fetch
operator|.
name|offvec
operator|=
name|vec
expr_stmt|;
name|fetch
operator|.
name|nfetch
operator|=
name|limit
expr_stmt|;
name|fetch
operator|.
name|nflush
operator|=
name|nflush
expr_stmt|;
comment|/* ignore interrupt system call errors */
do|do
block|{
name|ret
operator|=
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|MON_IOCX_MFETCH
argument_list|,
operator|&
name|fetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
do|while
condition|(
operator|(
name|ret
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|0
return|;
comment|/* no data there */
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't mfetch fd %d: %s"
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* keep track of processed events, we will flush them later */
name|nflush
operator|=
name|fetch
operator|.
name|nfetch
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fetch
operator|.
name|nfetch
condition|;
operator|++
name|i
control|)
block|{
comment|/* discard filler */
name|hdr
operator|=
operator|(
name|pcap_usb_header
operator|*
operator|)
operator|&
name|handle
operator|->
name|md
operator|.
name|mmapbuf
index|[
name|vec
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|event_type
operator|==
literal|'@'
condition|)
continue|continue;
comment|/* we can get less that than really captured from kernel, depending on 	 		* snaplen, so adjust header accordingly */
name|clen
operator|=
name|max_clen
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|data_len
operator|<
name|clen
condition|)
name|clen
operator|=
name|hdr
operator|->
name|data_len
expr_stmt|;
comment|/* get packet info from header*/
name|pkth
operator|.
name|caplen
operator|=
name|clen
operator|+
sizeof|sizeof
argument_list|(
name|pcap_usb_header_mmapped
argument_list|)
expr_stmt|;
name|pkth
operator|.
name|len
operator|=
name|hdr
operator|->
name|data_len
operator|+
sizeof|sizeof
argument_list|(
name|pcap_usb_header_mmapped
argument_list|)
expr_stmt|;
name|pkth
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|hdr
operator|->
name|ts_sec
expr_stmt|;
name|pkth
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|hdr
operator|->
name|ts_usec
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|||
name|bpf_filter
argument_list|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|hdr
argument_list|,
name|pkth
operator|.
name|len
argument_list|,
name|pkth
operator|.
name|caplen
argument_list|)
condition|)
block|{
name|handle
operator|->
name|md
operator|.
name|packets_read
operator|++
expr_stmt|;
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pkth
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|packets
operator|++
expr_stmt|;
block|}
block|}
comment|/* with max_packets<= 0 we stop afer the first chunk*/
if|if
condition|(
operator|(
name|max_packets
operator|<=
literal|0
operator|)
operator|||
operator|(
name|packets
operator|==
name|max_packets
operator|)
condition|)
break|break;
block|}
comment|/* flush pending events*/
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|MON_IOCH_MFLUSH
argument_list|,
name|nflush
argument_list|)
expr_stmt|;
return|return
name|packets
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_cleanup_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
comment|/* if we have a memory-mapped buffer, unmap it */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|mmapbuf
operator|!=
name|NULL
condition|)
block|{
name|munmap
argument_list|(
name|handle
operator|->
name|md
operator|.
name|mmapbuf
argument_list|,
name|handle
operator|->
name|md
operator|.
name|mmapbuflen
argument_list|)
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|mmapbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|pcap_cleanup_live_common
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

