begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* flex - tool to generate fast lexical analyzers */
end_comment

begin_comment
comment|/*  Copyright (c) 1990 The Regents of the University of California. */
end_comment

begin_comment
comment|/*  All rights reserved. */
end_comment

begin_comment
comment|/*  This code is derived from software contributed to Berkeley by */
end_comment

begin_comment
comment|/*  Vern Paxson. */
end_comment

begin_comment
comment|/*  The United States Government has rights in this work pursuant */
end_comment

begin_comment
comment|/*  to contract no. DE-AC03-76SF00098 between the United States */
end_comment

begin_comment
comment|/*  Department of Energy and the University of California. */
end_comment

begin_comment
comment|/*  This file is part of flex. */
end_comment

begin_comment
comment|/*  Redistribution and use in source and binary forms, with or without */
end_comment

begin_comment
comment|/*  modification, are permitted provided that the following conditions */
end_comment

begin_comment
comment|/*  are met: */
end_comment

begin_comment
comment|/*  1. Redistributions of source code must retain the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer. */
end_comment

begin_comment
comment|/*  2. Redistributions in binary form must reproduce the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer in the */
end_comment

begin_comment
comment|/*     documentation and/or other materials provided with the distribution. */
end_comment

begin_comment
comment|/*  Neither the name of the University nor the names of its contributors */
end_comment

begin_comment
comment|/*  may be used to endorse or promote products derived from this software */
end_comment

begin_comment
comment|/*  without specific prior written permission. */
end_comment

begin_comment
comment|/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
end_comment

begin_comment
comment|/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
end_comment

begin_comment
comment|/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
end_comment

begin_comment
comment|/*  PURPOSE. */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"tables.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|flex_version
index|[]
init|=
name|FLEX_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|flexinit
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|readin
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_up_initial_allocations
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|basename2
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|path
operator|,
name|int
name|should_strip_ext
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these globals are all defined and commented in flexdef.h */
end_comment

begin_decl_stmt
name|int
name|printstats
decl_stmt|,
name|syntaxerror
decl_stmt|,
name|eofseen
decl_stmt|,
name|ddebug
decl_stmt|,
name|trace
decl_stmt|,
name|nowarn
decl_stmt|,
name|spprdflt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interactive
decl_stmt|,
name|lex_compat
decl_stmt|,
name|posix_compat
decl_stmt|,
name|do_yylineno
decl_stmt|,
name|useecs
decl_stmt|,
name|fulltbl
decl_stmt|,
name|usemecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fullspd
decl_stmt|,
name|gen_line_dirs
decl_stmt|,
name|performance_report
decl_stmt|,
name|backing_up_report
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|C_plus_plus
decl_stmt|,
name|long_align
decl_stmt|,
name|use_read
decl_stmt|,
name|yytext_is_array
decl_stmt|,
name|do_yywrap
decl_stmt|,
name|csize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reentrant
decl_stmt|,
name|bison_bridge_lval
decl_stmt|,
name|bison_bridge_lloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yymore_used
decl_stmt|,
name|reject
decl_stmt|,
name|real_reject
decl_stmt|,
name|continued_action
decl_stmt|,
name|in_rule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yymore_really_used
decl_stmt|,
name|reject_really_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datapos
decl_stmt|,
name|dataline
decl_stmt|,
name|linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|skelfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skel_ind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|action_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|action_size
decl_stmt|,
name|defs1_offset
decl_stmt|,
name|prolog_offset
decl_stmt|,
name|action_offset
decl_stmt|,
name|action_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infilename
init|=
name|NULL
decl_stmt|,
modifier|*
name|outfilename
init|=
name|NULL
decl_stmt|,
modifier|*
name|headerfilename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|did_outfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|yyclass
decl_stmt|,
modifier|*
name|extra_type
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_stdinit
decl_stmt|,
name|use_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onestate
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onesym
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onenext
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onedef
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onesp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maximum_mns
decl_stmt|,
name|current_mns
decl_stmt|,
name|current_max_rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_rules
decl_stmt|,
name|num_eof_rules
decl_stmt|,
name|default_rule
decl_stmt|,
name|lastnfa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|firstst
decl_stmt|,
modifier|*
name|lastst
decl_stmt|,
modifier|*
name|finalst
decl_stmt|,
modifier|*
name|transchar
decl_stmt|,
modifier|*
name|trans1
decl_stmt|,
modifier|*
name|trans2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|accptnum
decl_stmt|,
modifier|*
name|assoc_rule
decl_stmt|,
modifier|*
name|state_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|rule_type
decl_stmt|,
modifier|*
name|rule_linenum
decl_stmt|,
modifier|*
name|rule_useful
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_state_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|variable_trailing_context_rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numtemps
decl_stmt|,
name|numprots
decl_stmt|,
name|protprev
index|[
name|MSP
index|]
decl_stmt|,
name|protnext
index|[
name|MSP
index|]
decl_stmt|,
name|prottbl
index|[
name|MSP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|protcomst
index|[
name|MSP
index|]
decl_stmt|,
name|firstprot
decl_stmt|,
name|lastprot
decl_stmt|,
name|protsave
index|[
name|PROT_SAVE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numecs
decl_stmt|,
name|nextecm
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|ecgroup
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|nummecs
decl_stmt|,
name|tecfwd
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tecbck
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastsc
decl_stmt|,
modifier|*
name|scset
decl_stmt|,
modifier|*
name|scbol
decl_stmt|,
modifier|*
name|scxclu
decl_stmt|,
modifier|*
name|sceof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_scs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|scname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_dfa_size
decl_stmt|,
name|current_max_xpairs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_template_xpairs
decl_stmt|,
name|current_max_dfas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastdfa
decl_stmt|,
modifier|*
name|nxt
decl_stmt|,
modifier|*
name|chk
decl_stmt|,
modifier|*
name|tnxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|base
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|nultrans
decl_stmt|,
name|NUL_ec
decl_stmt|,
name|tblend
decl_stmt|,
name|firstfree
decl_stmt|,
modifier|*
modifier|*
name|dss
decl_stmt|,
modifier|*
name|dfasiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|dfaacc_union
modifier|*
name|dfaacc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|accsiz
decl_stmt|,
modifier|*
name|dhash
decl_stmt|,
name|numas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numsnpairs
decl_stmt|,
name|jambase
decl_stmt|,
name|jamstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastccl
decl_stmt|,
modifier|*
name|cclmap
decl_stmt|,
modifier|*
name|ccllen
decl_stmt|,
modifier|*
name|cclng
decl_stmt|,
name|cclreuse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_maxccls
decl_stmt|,
name|current_max_ccl_tbl_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|ccltbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nmstr
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sectnum
decl_stmt|,
name|nummt
decl_stmt|,
name|hshcol
decl_stmt|,
name|dfaeql
decl_stmt|,
name|numeps
decl_stmt|,
name|eps2
decl_stmt|,
name|num_reallocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tmpuses
decl_stmt|,
name|totnst
decl_stmt|,
name|peakpairs
decl_stmt|,
name|numuniq
decl_stmt|,
name|numdup
decl_stmt|,
name|hshsave
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_backing_up
decl_stmt|,
name|bol_needed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|backing_up_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|end_of_buffer_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|input_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_input_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|flex_main_jmp_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
modifier|*
name|rule_has_nl
decl_stmt|,
modifier|*
name|ccl_has_nl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlch
init|=
literal|'\n'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|ansi_func_defs
decl_stmt|,
name|ansi_func_protos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|tablesext
decl_stmt|,
name|tablesverify
decl_stmt|,
name|gentables
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tablesfilename
init|=
literal|0
decl_stmt|,
modifier|*
name|tablesname
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|yytbl_writer
name|tableswr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make sure program_name is initialized so we don't crash if writing  * out an error message before getting the program name from argv[0].  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"flex"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_FILE_NAMES
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile_template
init|=
literal|"lex.%s.%s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backing_name
init|=
literal|"lex.backup"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tablesfile_template
init|=
literal|"lex.%s.tables"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile_template
init|=
literal|"lex%s.%s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backing_name
init|=
literal|"lex.bck"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tablesfile_template
init|=
literal|"lex%s.tbl"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MS_DOS
end_ifdef

begin_decl_stmt
specifier|extern
name|unsigned
name|_stklen
init|=
literal|16384
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From scan.l */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|outfile_path
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|outfile_created
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skelname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_stdout_closed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag to prevent double-fclose() on stdout. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|escaped_qstart
init|=
literal|"[[]]M4_YY_NOOP[M4_YY_NOOP[M4_YY_NOOP[[]]"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|escaped_qend
init|=
literal|"[[]]M4_YY_NOOP]M4_YY_NOOP]M4_YY_NOOP[[]]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For debugging. The max number of filters to apply to skeleton. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|preproc_level
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flex_main
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
name|argv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
name|argv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|flex_main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|exit_status
decl_stmt|,
name|child_status
decl_stmt|;
comment|/* Set a longjmp target. Yes, I know it's a hack, but it gets worse: The 	 * return value of setjmp, if non-zero, is the desired exit code PLUS ONE. 	 * For example, if you want 'main' to return with code '2', then call 	 * longjmp() with an argument of 3. This is because it is invalid to 	 * specify a value of 0 to longjmp. FLEX_EXIT(n) should be used instead of 	 * exit(n); 	 */
name|exit_status
operator|=
name|setjmp
argument_list|(
name|flex_main_jmp_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
condition|)
block|{
if|if
condition|(
name|stdout
operator|&&
operator|!
name|_stdout_closed
operator|&&
operator|!
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|wait
argument_list|(
operator|&
name|child_status
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|child_status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|child_status
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* report an error of a child                  */
if|if
condition|(
name|exit_status
operator|<=
literal|1
condition|)
name|exit_status
operator|=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|exit_status
operator|-
literal|1
return|;
block|}
name|flexinit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|readin
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [1.5] DFA */
name|ntod
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_rules
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|rule_useful
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|default_rule
condition|)
name|line_warning
argument_list|(
name|_
argument_list|(
literal|"rule cannot be matched"
argument_list|)
argument_list|,
name|rule_linenum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spprdflt
operator|&&
operator|!
name|reject
operator|&&
name|rule_useful
index|[
name|default_rule
index|]
condition|)
name|line_warning
argument_list|(
name|_
argument_list|(
literal|"-s option given but default rule can be matched"
argument_list|)
argument_list|,
name|rule_linenum
index|[
name|default_rule
index|]
argument_list|)
expr_stmt|;
comment|/* Generate the C state transition tables from the DFA. */
name|make_tables
argument_list|()
expr_stmt|;
comment|/* Note, flexend does not return.  It exits with its argument 	 * as status. 	 */
name|flexend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* keep compilers/lint happy */
block|}
end_function

begin_comment
comment|/* Wrapper around flex_main, so flex_main can be built as a library. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
if|#
directive|if
name|ENABLE_NLS
if|#
directive|if
name|HAVE_LOCALE_H
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|flex_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* check_options - check user-specified options */
end_comment

begin_function
name|void
name|check_options
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|m4
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lex_compat
condition|)
block|{
if|if
condition|(
name|C_plus_plus
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Can't use -+ with -l option"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
operator|||
name|fullspd
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Can't use -f or -F with -l option"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reentrant
operator|||
name|bison_bridge_lval
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Can't use --reentrant or --bison-bridge with -l option"
argument_list|)
argument_list|)
expr_stmt|;
name|yytext_is_array
operator|=
name|true
expr_stmt|;
name|do_yylineno
operator|=
name|true
expr_stmt|;
name|use_read
operator|=
name|false
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This makes no sense whatsoever. I'm removing it. */
block|if (do_yylineno)
comment|/* This should really be "maintain_backup_tables = true" */
block|reject_really_used = true;
endif|#
directive|endif
if|if
condition|(
name|csize
operator|==
name|unspecified
condition|)
block|{
if|if
condition|(
operator|(
name|fulltbl
operator|||
name|fullspd
operator|)
operator|&&
operator|!
name|useecs
condition|)
name|csize
operator|=
name|DEFAULT_CSIZE
expr_stmt|;
else|else
name|csize
operator|=
name|CSIZE
expr_stmt|;
block|}
if|if
condition|(
name|interactive
operator|==
name|unspecified
condition|)
block|{
if|if
condition|(
name|fulltbl
operator|||
name|fullspd
condition|)
name|interactive
operator|=
name|false
expr_stmt|;
else|else
name|interactive
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|fulltbl
operator|||
name|fullspd
condition|)
block|{
if|if
condition|(
name|usemecs
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf/-CF and -Cm don't make sense together"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf/-CF and -I are incompatible"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_compat
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf/-CF are incompatible with lex-compatibility mode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
operator|&&
name|fullspd
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf and -CF are mutually exclusive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|C_plus_plus
operator|&&
name|fullspd
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Can't use -+ with -CF option"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_plus_plus
operator|&&
name|yytext_is_array
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"%array incompatible with -+ option"
argument_list|)
argument_list|)
expr_stmt|;
name|yytext_is_array
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|C_plus_plus
operator|&&
operator|(
name|reentrant
operator|)
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Options -+ and --reentrant are mutually exclusive."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_plus_plus
operator|&&
name|bison_bridge_lval
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"bison bridge not supported for the C++ scanner."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
block|{
comment|/* Set up doubly-linked equivalence classes. */
comment|/* We loop all the way up to csize, since ecgroup[csize] is 		 * the position used for NUL characters. 		 */
name|ecgroup
index|[
literal|1
index|]
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|nextecm
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
name|nextecm
index|[
name|csize
index|]
operator|=
name|NIL
expr_stmt|;
block|}
else|else
block|{
comment|/* Put everything in its own equivalence class. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|nextecm
index|[
name|i
index|]
operator|=
name|BAD_SUBSCRIPT
expr_stmt|;
comment|/* to catch errors */
block|}
block|}
if|if
condition|(
operator|!
name|ansi_func_defs
condition|)
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_ANSI_FUNC_DEFS"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ansi_func_protos
condition|)
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_ANSI_FUNC_PROTOS"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_type
condition|)
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_EXTRA_TYPE_DEFS"
argument_list|,
name|extra_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_stdout
condition|)
block|{
name|FILE
modifier|*
name|prev_stdout
decl_stmt|;
if|if
condition|(
operator|!
name|did_outfilename
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
name|suffix
operator|=
literal|"cc"
expr_stmt|;
else|else
name|suffix
operator|=
literal|"c"
expr_stmt|;
name|snprintf
argument_list|(
name|outfile_path
argument_list|,
sizeof|sizeof
argument_list|(
name|outfile_path
argument_list|)
argument_list|,
name|outfile_template
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|outfile_path
expr_stmt|;
block|}
name|prev_stdout
operator|=
name|freopen
argument_list|(
name|outfilename
argument_list|,
literal|"w+"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_stdout
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"could not create %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|outfile_created
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Setup the filter chain. */
name|output_chain
operator|=
name|filter_create_int
argument_list|(
name|NULL
argument_list|,
name|filter_tee_header
argument_list|,
name|headerfilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m4
operator|=
name|getenv
argument_list|(
literal|"M4"
argument_list|)
operator|)
condition|)
name|m4
operator|=
name|M4
expr_stmt|;
name|filter_create_ext
argument_list|(
name|output_chain
argument_list|,
name|m4
argument_list|,
literal|"-gP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filter_create_int
argument_list|(
name|output_chain
argument_list|,
name|filter_fix_linedirs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* For debugging, only run the requested number of filters. */
if|if
condition|(
name|preproc_level
operator|>
literal|0
condition|)
block|{
name|filter_truncate
argument_list|(
name|output_chain
argument_list|,
name|preproc_level
argument_list|)
expr_stmt|;
name|filter_apply_chain
argument_list|(
name|output_chain
argument_list|)
expr_stmt|;
block|}
name|yyout
operator|=
name|stdout
expr_stmt|;
comment|/* always generate the tablesverify flag. */
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_TABLES_VERIFY"
argument_list|,
name|tablesverify
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
name|gentables
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tablesverify
condition|)
comment|/* force generation of C tables. */
name|gentables
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|FILE
modifier|*
name|tablesout
decl_stmt|;
name|struct
name|yytbl_hdr
name|hdr
decl_stmt|;
name|char
modifier|*
name|pname
init|=
literal|0
decl_stmt|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_TABLES_EXTERNAL"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tablesfilename
condition|)
block|{
name|nbytes
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|tablesfile_template
argument_list|)
operator|+
literal|2
expr_stmt|;
name|tablesfilename
operator|=
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|nbytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|pname
argument_list|,
name|nbytes
argument_list|,
name|tablesfile_template
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tablesout
operator|=
name|fopen
argument_list|(
name|tablesfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"could not create %s"
argument_list|)
argument_list|,
name|tablesfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pname
condition|)
name|free
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|tablesfilename
operator|=
literal|0
expr_stmt|;
name|yytbl_writer_init
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tablesout
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"tables"
argument_list|)
operator|+
literal|2
expr_stmt|;
name|tablesname
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|nbytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tablesname
argument_list|,
name|nbytes
argument_list|,
literal|"%stables"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|yytbl_hdr_init
argument_list|(
operator|&
name|hdr
argument_list|,
name|flex_version
argument_list|,
name|tablesname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_hdr_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
operator|&
name|hdr
argument_list|)
operator|<=
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"could not write tables header"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skelname
operator|&&
operator|(
name|skelfile
operator|=
name|fopen
argument_list|(
name|skelname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"can't open skeleton file %s"
argument_list|)
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
if|if
condition|(
name|reentrant
condition|)
block|{
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_REENTRANT"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytext_is_array
condition|)
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_TEXT_IS_ARRAY"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bison_bridge_lval
condition|)
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_BISON_LVAL"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bison_bridge_lloc
condition|)
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"<M4_YY_BISON_LLOC>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_PREFIX"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_outfilename
condition|)
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_USE_LINENO"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create the alignment type. */
name|buf_strdefine
argument_list|(
operator|&
name|userdef_buf
argument_list|,
literal|"YY_INT_ALIGNED"
argument_list|,
name|long_align
condition|?
literal|"long int"
else|:
literal|"short int"
argument_list|)
expr_stmt|;
comment|/* Define the start condition macros. */
block|{
name|struct
name|Buf
name|tmpbuf
decl_stmt|;
name|buf_init
argument_list|(
operator|&
name|tmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|fmt
init|=
literal|"#define %s %d\n"
decl_stmt|;
name|size_t
name|strsz
decl_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|flex_alloc
argument_list|(
name|strsz
operator|=
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|scname
index|[
name|i
index|]
argument_list|)
operator|+
name|NUMCHARLINES
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"allocation of macro definition failed"
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
name|strsz
argument_list|,
name|fmt
argument_list|,
name|scname
index|[
name|i
index|]
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_SC_DEFS"
argument_list|,
name|tmpbuf
operator|.
name|elts
argument_list|)
expr_stmt|;
name|buf_destroy
argument_list|(
operator|&
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
comment|/* This is where we begin writing to the file. */
comment|/* Dump the %top code. */
if|if
condition|(
name|top_buf
operator|.
name|elts
condition|)
name|outn
argument_list|(
operator|(
name|char
operator|*
operator|)
name|top_buf
operator|.
name|elts
argument_list|)
expr_stmt|;
comment|/* Dump the m4 definitions. */
name|buf_print_strings
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|m4defs_buf
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
comment|/* memory leak here. */
comment|/* Place a bogus line directive, it will be fixed in the filter. */
name|outn
argument_list|(
literal|"#line 0 \"M4_YY_OUTFILE_NAME\"\n"
argument_list|)
expr_stmt|;
comment|/* Dump the user defined preproc directives. */
if|if
condition|(
name|userdef_buf
operator|.
name|elts
condition|)
name|outn
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|userdef_buf
operator|.
name|elts
operator|)
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [1.0] */
block|}
end_function

begin_comment
comment|/* flexend - terminate flex  *  * note  *    This routine does not return.  */
end_comment

begin_function
name|void
name|flexend
parameter_list|(
name|exit_status
parameter_list|)
name|int
name|exit_status
decl_stmt|;
block|{
specifier|static
name|int
name|called_before
init|=
operator|-
literal|1
decl_stmt|;
comment|/* prevent infinite recursion. */
name|int
name|tblsiz
decl_stmt|;
if|if
condition|(
operator|++
name|called_before
condition|)
name|FLEX_EXIT
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|skelfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|skelfile
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"input error reading skeleton file %s"
argument_list|)
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|skelfile
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing skeleton file %s"
argument_list|)
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf (header_out, 			 "#ifdef YY_HEADER_EXPORT_START_CONDITIONS\n"); 		fprintf (header_out, 			 "/* Beware! Start conditions are not prefixed. */\n");
comment|/* Special case for "INITIAL" */
block|fprintf (header_out, 			 "#undef INITIAL\n#define INITIAL 0\n"); 		for (i = 2; i<= lastsc; i++) 			fprintf (header_out, "#define %s %d\n", scname[i], i - 1); 		fprintf (header_out, 			 "#endif /* YY_HEADER_EXPORT_START_CONDITIONS */\n\n");
comment|/* Kill ALL flex-related macros. This is so the user 		 * can #include more than one generated header file. */
block|fprintf (header_out, "#ifndef YY_HEADER_NO_UNDEFS\n"); 		fprintf (header_out, 			 "/* Undefine all internal macros, etc., that do no belong in the header. */\n\n");          {             const char * undef_list[] = {                  "BEGIN",                 "ECHO",                 "EOB_ACT_CONTINUE_SCAN",                 "EOB_ACT_END_OF_FILE",                 "EOB_ACT_LAST_MATCH",                 "FLEX_SCANNER",                 "FLEX_STD",                 "REJECT",                 "YYFARGS0",                 "YYFARGS1",                 "YYFARGS2",                 "YYFARGS3",                 "YYLMAX",                 "YYSTATE",                 "YY_AT_BOL",                 "YY_BREAK",                 "YY_BUFFER_EOF_PENDING",                 "YY_BUFFER_NEW",                 "YY_BUFFER_NORMAL",                 "YY_BUF_SIZE",                 "M4_YY_CALL_LAST_ARG",                 "M4_YY_CALL_ONLY_ARG",                 "YY_CURRENT_BUFFER",                 "YY_DECL",                 "M4_YY_DECL_LAST_ARG",                 "M4_YY_DEF_LAST_ARG",                 "M4_YY_DEF_ONLY_ARG",                 "YY_DO_BEFORE_ACTION",                 "YY_END_OF_BUFFER",                 "YY_END_OF_BUFFER_CHAR",                 "YY_EXIT_FAILURE",                 "YY_EXTRA_TYPE",                 "YY_FATAL_ERROR",                 "YY_FLEX_DEFINED_ECHO",                 "YY_FLEX_LEX_COMPAT",                 "YY_FLEX_MAJOR_VERSION",                 "YY_FLEX_MINOR_VERSION",                 "YY_FLEX_SUBMINOR_VERSION",                 "YY_FLUSH_BUFFER",                 "YY_G",                 "YY_INPUT",                 "YY_INTERACTIVE",                 "YY_INT_ALIGNED",                 "YY_LAST_ARG",                 "YY_LESS_LINENO",                 "YY_LEX_ARGS",                 "YY_LEX_DECLARATION",                 "YY_LEX_PROTO",                 "YY_MAIN",                 "YY_MORE_ADJ",                 "YY_NEED_STRLEN",                 "YY_NEW_FILE",                 "YY_NULL",                 "YY_NUM_RULES",                 "YY_ONLY_ARG",                 "YY_PARAMS",                 "YY_PROTO",                 "M4_YY_PROTO_LAST_ARG",                 "M4_YY_PROTO_ONLY_ARG void",                 "YY_READ_BUF_SIZE",                 "YY_REENTRANT",                 "YY_RESTORE_YY_MORE_OFFSET",                 "YY_RULE_SETUP",                 "YY_SC_TO_UI",                 "YY_SKIP_YYWRAP",                 "YY_START",                 "YY_START_STACK_INCR",                 "YY_STATE_EOF",                 "YY_STDINIT",                 "YY_TRAILING_HEAD_MASK",                 "YY_TRAILING_MASK",                 "YY_USER_ACTION",                 "YY_USE_CONST",                 "YY_USE_PROTOS",                 "unput",                 "yyTABLES_NAME",                 "yy_create_buffer",                 "yy_delete_buffer",                 "yy_flex_debug",                 "yy_flush_buffer",                 "yy_init_buffer",                 "yy_load_buffer_state",                 "yy_new_buffer",                 "yy_scan_buffer",                 "yy_scan_bytes",                 "yy_scan_string",                 "yy_set_bol",                 "yy_set_interactive",                 "yy_switch_to_buffer", 				"yypush_buffer_state", 				"yypop_buffer_state", 				"yyensure_buffer_stack",                 "yyalloc",                 "yyconst",                 "yyextra",                 "yyfree",                 "yyget_debug",                 "yyget_extra",                 "yyget_in",                 "yyget_leng",                 "yyget_lineno",                 "yyget_lloc",                 "yyget_lval",                 "yyget_out",                 "yyget_text",                 "yyin",                 "yyleng",                 "yyless",                 "yylex",                 "yylex_destroy",                 "yylex_init",                 "yylex_init_extra",                 "yylineno",                 "yylloc",                 "yylval",                 "yymore",                 "yyout",                 "yyrealloc",                 "yyrestart",                 "yyset_debug",                 "yyset_extra",                 "yyset_in",                 "yyset_lineno",                 "yyset_lloc",                 "yyset_lval",                 "yyset_out",                 "yytables_destroy",                 "yytables_fload",                 "yyterminate",                 "yytext",                 "yytext_ptr",                 "yywrap",
comment|/* must be null-terminated */
block|NULL};                   for (i=0; undef_list[i] != NULL; i++)                     fprintf (header_out, "#undef %s\n", undef_list[i]);         }
comment|/* undef any of the auto-generated symbols. */
block|for (i = 0; i< defs_buf.nelts; i++) {
comment|/* don't undef start conditions */
block|if (sclookup (((char **) defs_buf.elts)[i])> 0) 				continue; 			fprintf (header_out, "#undef %s\n", 				 ((char **) defs_buf.elts)[i]); 		}  		fprintf (header_out, 			 "#endif /* !YY_HEADER_NO_UNDEFS */\n"); 		fprintf (header_out, "\n"); 		fprintf (header_out, "#undef %sIN_HEADER\n", prefix); 		fprintf (header_out, "#endif /* %sHEADER_H */\n", prefix);  		if (ferror (header_out)) 			lerrsf (_("error creating header file %s"), 				headerfilename); 		fflush (header_out); 		fclose (header_out);
endif|#
directive|endif
if|if
condition|(
name|exit_status
operator|!=
literal|0
operator|&&
name|outfile_created
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error writing output file %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|_stdout_closed
operator|=
literal|1
operator|)
operator|&&
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing output file %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|outfilename
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error deleting output file %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backing_up_report
operator|&&
name|backing_up_file
condition|)
block|{
if|if
condition|(
name|num_backing_up
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|backing_up_file
argument_list|,
name|_
argument_list|(
literal|"No backing up.\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|fprintf
argument_list|(
name|backing_up_file
argument_list|,
name|_
argument_list|(
literal|"%d backing up (non-accepting) states.\n"
argument_list|)
argument_list|,
name|num_backing_up
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|backing_up_file
argument_list|,
name|_
argument_list|(
literal|"Compressed tables always back up.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|backing_up_file
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error writing backup file %s"
argument_list|)
argument_list|,
name|backing_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|backing_up_file
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing backup file %s"
argument_list|)
argument_list|,
name|backing_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printstats
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s version %s usage statistics:\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|flex_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  scanner options: -"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
name|putc
argument_list|(
literal|'+'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|backing_up_report
condition|)
name|putc
argument_list|(
literal|'b'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|putc
argument_list|(
literal|'d'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf_case_ins
argument_list|()
condition|)
name|putc
argument_list|(
literal|'i'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_compat
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|posix_compat
condition|)
name|putc
argument_list|(
literal|'X'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|'p'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|1
condition|)
name|putc
argument_list|(
literal|'p'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spprdflt
condition|)
name|putc
argument_list|(
literal|'s'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reentrant
condition|)
name|fputs
argument_list|(
literal|"--reentrant"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bison_bridge_lval
condition|)
name|fputs
argument_list|(
literal|"--bison-bridge"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bison_bridge_lloc
condition|)
name|fputs
argument_list|(
literal|"--bison-locations"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_stdout
condition|)
name|putc
argument_list|(
literal|'t'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|printstats
condition|)
name|putc
argument_list|(
literal|'v'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* always true! */
if|if
condition|(
name|nowarn
condition|)
name|putc
argument_list|(
literal|'w'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
operator|==
name|false
condition|)
name|putc
argument_list|(
literal|'B'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
operator|==
name|true
condition|)
name|putc
argument_list|(
literal|'I'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gen_line_dirs
condition|)
name|putc
argument_list|(
literal|'L'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|putc
argument_list|(
literal|'T'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|==
name|unspecified
condition|)
comment|/* We encountered an error fairly early on, so csize 			 * never got specified.  Define it now, to prevent 			 * bogus table sizes being written out below. 			 */
name|csize
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|csize
operator|==
literal|128
condition|)
name|putc
argument_list|(
literal|'7'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'8'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_align
condition|)
name|putc
argument_list|(
literal|'a'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
condition|)
name|putc
argument_list|(
literal|'f'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
name|putc
argument_list|(
literal|'F'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|putc
argument_list|(
literal|'e'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
name|putc
argument_list|(
literal|'m'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_read
condition|)
name|putc
argument_list|(
literal|'r'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_outfilename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -o%s"
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|skelname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -S%s"
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prefix
argument_list|,
literal|"yy"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -P%s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d NFA states\n"
argument_list|)
argument_list|,
name|lastnfa
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d DFA states (%d words)\n"
argument_list|)
argument_list|,
name|lastdfa
argument_list|,
name|current_max_dfas
argument_list|,
name|totnst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d rules\n"
argument_list|)
argument_list|,
name|num_rules
operator|+
name|num_eof_rules
operator|-
literal|1
comment|/* - 1 for def. rule */
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  No backing up\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d backing-up (non-accepting) states\n"
argument_list|)
argument_list|,
name|num_backing_up
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  Compressed tables always back-up\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  Beginning-of-line patterns used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d start conditions\n"
argument_list|)
argument_list|,
name|lastsc
argument_list|,
name|current_max_scs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d epsilon states, %d double epsilon states\n"
argument_list|)
argument_list|,
name|numeps
argument_list|,
name|eps2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastccl
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  no character classes\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d character classes needed %d/%d words of storage, %d reused\n"
argument_list|)
argument_list|,
name|lastccl
argument_list|,
name|current_maxccls
argument_list|,
name|cclmap
index|[
name|lastccl
index|]
operator|+
name|ccllen
index|[
name|lastccl
index|]
argument_list|,
name|current_max_ccl_tbl_size
argument_list|,
name|cclreuse
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d state/nextstate pairs created\n"
argument_list|)
argument_list|,
name|numsnpairs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d unique/duplicate transitions\n"
argument_list|)
argument_list|,
name|numuniq
argument_list|,
name|numdup
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
condition|)
block|{
name|tblsiz
operator|=
name|lastdfa
operator|*
name|numecs
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d table entries\n"
argument_list|)
argument_list|,
name|tblsiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tblsiz
operator|=
literal|2
operator|*
operator|(
name|lastdfa
operator|+
name|numtemps
operator|)
operator|+
literal|2
operator|*
name|tblend
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d base-def entries created\n"
argument_list|)
argument_list|,
name|lastdfa
operator|+
name|numtemps
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d (peak %d) nxt-chk entries created\n"
argument_list|)
argument_list|,
name|tblend
argument_list|,
name|current_max_xpairs
argument_list|,
name|peakpairs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d (peak %d) template nxt-chk entries created\n"
argument_list|)
argument_list|,
name|numtemps
operator|*
name|nummecs
argument_list|,
name|current_max_template_xpairs
argument_list|,
name|numtemps
operator|*
name|numecs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d empty table entries\n"
argument_list|)
argument_list|,
name|nummt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d protos created\n"
argument_list|)
argument_list|,
name|numprots
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d templates created, %d uses\n"
argument_list|)
argument_list|,
name|numtemps
argument_list|,
name|tmpuses
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useecs
condition|)
block|{
name|tblsiz
operator|=
name|tblsiz
operator|+
name|csize
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d equivalence classes created\n"
argument_list|)
argument_list|,
name|numecs
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usemecs
condition|)
block|{
name|tblsiz
operator|=
name|tblsiz
operator|+
name|numecs
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d meta-equivalence classes created\n"
argument_list|)
argument_list|,
name|nummecs
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d (%d saved) hash collisions, %d DFAs equal\n"
argument_list|)
argument_list|,
name|hshcol
argument_list|,
name|hshsave
argument_list|,
name|dfaeql
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d sets of reallocations needed\n"
argument_list|)
argument_list|,
name|num_reallocs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d total table entries needed\n"
argument_list|)
argument_list|,
name|tblsiz
argument_list|)
expr_stmt|;
block|}
name|FLEX_EXIT
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* flexinit - initialize flex */
end_comment

begin_function
name|void
name|flexinit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|sawcmpflag
decl_stmt|,
name|rv
decl_stmt|,
name|optind
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|scanopt_t
name|sopt
decl_stmt|;
name|printstats
operator|=
name|syntaxerror
operator|=
name|trace
operator|=
name|spprdflt
operator|=
name|false
expr_stmt|;
name|lex_compat
operator|=
name|posix_compat
operator|=
name|C_plus_plus
operator|=
name|backing_up_report
operator|=
name|ddebug
operator|=
name|fulltbl
operator|=
name|false
expr_stmt|;
name|fullspd
operator|=
name|long_align
operator|=
name|nowarn
operator|=
name|yymore_used
operator|=
name|continued_action
operator|=
name|false
expr_stmt|;
name|do_yylineno
operator|=
name|yytext_is_array
operator|=
name|in_rule
operator|=
name|reject
operator|=
name|do_stdinit
operator|=
name|false
expr_stmt|;
name|yymore_really_used
operator|=
name|reject_really_used
operator|=
name|unspecified
expr_stmt|;
name|interactive
operator|=
name|csize
operator|=
name|unspecified
expr_stmt|;
name|do_yywrap
operator|=
name|gen_line_dirs
operator|=
name|usemecs
operator|=
name|useecs
operator|=
name|true
expr_stmt|;
name|reentrant
operator|=
name|bison_bridge_lval
operator|=
name|bison_bridge_lloc
operator|=
name|false
expr_stmt|;
name|performance_report
operator|=
literal|0
expr_stmt|;
name|did_outfilename
operator|=
literal|0
expr_stmt|;
name|prefix
operator|=
literal|"yy"
expr_stmt|;
name|yyclass
operator|=
literal|0
expr_stmt|;
name|use_read
operator|=
name|use_stdout
operator|=
name|false
expr_stmt|;
name|tablesext
operator|=
name|tablesverify
operator|=
name|false
expr_stmt|;
name|gentables
operator|=
name|true
expr_stmt|;
name|tablesfilename
operator|=
name|tablesname
operator|=
name|NULL
expr_stmt|;
name|ansi_func_defs
operator|=
name|ansi_func_protos
operator|=
name|true
expr_stmt|;
name|sawcmpflag
operator|=
name|false
expr_stmt|;
comment|/* Initialize dynamic array for holding the rule actions. */
name|action_size
operator|=
literal|2048
expr_stmt|;
comment|/* default size of action array in bytes */
name|action_array
operator|=
name|allocate_character_array
argument_list|(
name|action_size
argument_list|)
expr_stmt|;
name|defs1_offset
operator|=
name|prolog_offset
operator|=
name|action_offset
operator|=
name|action_index
operator|=
literal|0
expr_stmt|;
name|action_array
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Initialize any buffers. */
name|buf_init
argument_list|(
operator|&
name|userdef_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* one long string */
name|buf_init
argument_list|(
operator|&
name|defs_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* list of strings */
name|buf_init
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* one long string */
name|buf_init
argument_list|(
operator|&
name|top_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* one long string */
block|{
specifier|const
name|char
modifier|*
name|m4defs_init_str
index|[]
init|=
block|{
literal|"m4_changequote\n"
block|,
literal|"m4_changequote([[, ]])\n"
block|}
decl_stmt|;
name|buf_init
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|buf_append
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
operator|&
name|m4defs_init_str
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|sf_init
argument_list|()
expr_stmt|;
comment|/* initialize regex lib */
name|flex_init_regex
argument_list|()
expr_stmt|;
comment|/* Enable C++ if program name ends with '+'. */
name|program_name
operator|=
name|basename2
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|program_name
index|[
name|strlen
argument_list|(
name|program_name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'+'
condition|)
name|C_plus_plus
operator|=
name|true
expr_stmt|;
comment|/* read flags */
name|sopt
operator|=
name|scanopt_init
argument_list|(
name|flexopts
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sopt
condition|)
block|{
comment|/* This will only happen when flexopts array is altered. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error. flexopts are malformed.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|FLEX_EXIT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|rv
operator|=
name|scanopt
argument_list|(
name|sopt
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|optind
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
comment|/* Scanopt has already printed an option-specific error message. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|FLEX_EXIT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
expr|enum
name|flexopt_flag_t
operator|)
name|rv
condition|)
block|{
case|case
name|OPT_CPLUSPLUS
case|:
name|C_plus_plus
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_BATCH
case|:
name|interactive
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_BACKUP
case|:
name|backing_up_report
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_DONOTHING
case|:
break|break;
case|case
name|OPT_COMPRESSION
case|:
if|if
condition|(
operator|!
name|sawcmpflag
condition|)
block|{
name|useecs
operator|=
name|false
expr_stmt|;
name|usemecs
operator|=
name|false
expr_stmt|;
name|fulltbl
operator|=
name|false
expr_stmt|;
name|sawcmpflag
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arg
operator|&&
name|arg
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|long_align
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|useecs
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fullspd
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fulltbl
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|usemecs
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|use_read
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|lerrif
argument_list|(
name|_
argument_list|(
literal|"unknown -C option '%c'"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPT_DEBUG
case|:
name|ddebug
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_DEBUG
case|:
name|ddebug
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_FULL
case|:
name|useecs
operator|=
name|usemecs
operator|=
name|false
expr_stmt|;
name|use_read
operator|=
name|fulltbl
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_FAST
case|:
name|useecs
operator|=
name|usemecs
operator|=
name|false
expr_stmt|;
name|use_read
operator|=
name|fullspd
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_HELP
case|:
name|usage
argument_list|()
expr_stmt|;
name|FLEX_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|OPT_INTERACTIVE
case|:
name|interactive
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_CASE_INSENSITIVE
case|:
name|sf_set_case_ins
argument_list|(
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_LEX_COMPAT
case|:
name|lex_compat
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_POSIX_COMPAT
case|:
name|posix_compat
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_PREPROC_LEVEL
case|:
name|preproc_level
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_MAIN
case|:
name|buf_strdefine
argument_list|(
operator|&
name|userdef_buf
argument_list|,
literal|"YY_MAIN"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|do_yywrap
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_NO_MAIN
case|:
name|buf_strdefine
argument_list|(
operator|&
name|userdef_buf
argument_list|,
literal|"YY_MAIN"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_LINE
case|:
name|gen_line_dirs
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_OUTFILE
case|:
name|outfilename
operator|=
name|arg
expr_stmt|;
name|did_outfilename
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_PREFIX
case|:
name|prefix
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_PERF_REPORT
case|:
operator|++
name|performance_report
expr_stmt|;
break|break;
case|case
name|OPT_BISON_BRIDGE
case|:
name|bison_bridge_lval
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_BISON_BRIDGE_LOCATIONS
case|:
name|bison_bridge_lval
operator|=
name|bison_bridge_lloc
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_REENTRANT
case|:
name|reentrant
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_REENTRANT
case|:
name|reentrant
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_SKEL
case|:
name|skelname
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_DEFAULT
case|:
name|spprdflt
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_NO_DEFAULT
case|:
name|spprdflt
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_STDOUT
case|:
name|use_stdout
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_UNISTD_H
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_UNISTD_H", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_UNISTD_H"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_TABLES_FILE
case|:
name|tablesext
operator|=
name|true
expr_stmt|;
name|tablesfilename
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_TABLES_VERIFY
case|:
name|tablesverify
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_TRACE
case|:
name|trace
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_VERBOSE
case|:
name|printstats
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_VERSION
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|flex_version
argument_list|)
expr_stmt|;
name|FLEX_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|OPT_WARN
case|:
name|nowarn
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_NO_WARN
case|:
name|nowarn
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_7BIT
case|:
name|csize
operator|=
literal|128
expr_stmt|;
break|break;
case|case
name|OPT_8BIT
case|:
name|csize
operator|=
name|CSIZE
expr_stmt|;
break|break;
case|case
name|OPT_ALIGN
case|:
name|long_align
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_ALIGN
case|:
name|long_align
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_ALWAYS_INTERACTIVE
case|:
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_ALWAYS_INTERACTIVE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NEVER_INTERACTIVE
case|:
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NEVER_INTERACTIVE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ARRAY
case|:
name|yytext_is_array
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_POINTER
case|:
name|yytext_is_array
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_ECS
case|:
name|useecs
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_ECS
case|:
name|useecs
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_HEADER_FILE
case|:
name|headerfilename
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_META_ECS
case|:
name|usemecs
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_META_ECS
case|:
name|usemecs
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_PREPROCDEFINE
case|:
block|{
comment|/* arg is "symbol" or "symbol=definition". */
name|char
modifier|*
name|def
decl_stmt|;
for|for
control|(
name|def
operator|=
name|arg
init|;
operator|*
name|def
operator|!=
literal|'\0'
operator|&&
operator|*
name|def
operator|!=
literal|'='
condition|;
operator|++
name|def
control|)
empty_stmt|;
name|buf_strappend
argument_list|(
operator|&
name|userdef_buf
argument_list|,
literal|"#define "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|def
operator|==
literal|'\0'
condition|)
block|{
name|buf_strappend
argument_list|(
operator|&
name|userdef_buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
operator|&
name|userdef_buf
argument_list|,
literal|" 1\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_strnappend
argument_list|(
operator|&
name|userdef_buf
argument_list|,
name|arg
argument_list|,
name|def
operator|-
name|arg
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
operator|&
name|userdef_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
operator|&
name|userdef_buf
argument_list|,
name|def
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
operator|&
name|userdef_buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPT_READ
case|:
name|use_read
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_STACK
case|:
comment|//buf_strdefine (&userdef_buf, "YY_STACK_USED", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_STACK_USED"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_STDINIT
case|:
name|do_stdinit
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_STDINIT
case|:
name|do_stdinit
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_YYCLASS
case|:
name|yyclass
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_YYLINENO
case|:
name|do_yylineno
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYLINENO
case|:
name|do_yylineno
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_YYWRAP
case|:
name|do_yywrap
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYWRAP
case|:
name|do_yywrap
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_YYMORE
case|:
name|yymore_really_used
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYMORE
case|:
name|yymore_really_used
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_REJECT
case|:
name|reject_really_used
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_NO_REJECT
case|:
name|reject_really_used
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_NO_ANSI_FUNC_DEFS
case|:
name|ansi_func_defs
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_NO_ANSI_FUNC_PROTOS
case|:
name|ansi_func_protos
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_NO_YY_PUSH_STATE
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_PUSH_STATE", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_PUSH_STATE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YY_POP_STATE
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_POP_STATE", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_POP_STATE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YY_TOP_STATE
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_TOP_STATE", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_TOP_STATE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_UNPUT
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_UNPUT", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_UNPUT"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YY_SCAN_BUFFER
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SCAN_BUFFER", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SCAN_BUFFER"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YY_SCAN_BYTES
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SCAN_BYTES", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SCAN_BYTES"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YY_SCAN_STRING
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SCAN_STRING", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SCAN_STRING"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_EXTRA
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_EXTRA", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_EXTRA"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYSET_EXTRA
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SET_EXTRA", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SET_EXTRA"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_LENG
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_LENG", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_LENG"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_TEXT
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_TEXT", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_TEXT"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_LINENO
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_LINENO", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_LINENO"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYSET_LINENO
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SET_LINENO", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SET_LINENO"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_IN
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_IN", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_IN"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYSET_IN
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SET_IN", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SET_IN"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_OUT
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_OUT", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_OUT"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYSET_OUT
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SET_OUT", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SET_OUT"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_LVAL
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_LVAL", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_LVAL"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYSET_LVAL
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SET_LVAL", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SET_LVAL"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYGET_LLOC
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_GET_LLOC", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_GET_LLOC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NO_YYSET_LLOC
case|:
comment|//buf_strdefine (&userdef_buf, "YY_NO_SET_LLOC", "1");
name|buf_m4_define
argument_list|(
operator|&
name|m4defs_buf
argument_list|,
literal|"M4_YY_NO_SET_LLOC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
comment|/* while scanopt() */
name|scanopt_destroy
argument_list|(
name|sopt
argument_list|)
expr_stmt|;
name|num_input_files
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|input_files
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|set_input_file
argument_list|(
name|num_input_files
operator|>
literal|0
condition|?
name|input_files
index|[
literal|0
index|]
else|:
name|NULL
argument_list|)
expr_stmt|;
name|lastccl
operator|=
name|lastsc
operator|=
name|lastdfa
operator|=
name|lastnfa
operator|=
literal|0
expr_stmt|;
name|num_rules
operator|=
name|num_eof_rules
operator|=
name|default_rule
operator|=
literal|0
expr_stmt|;
name|numas
operator|=
name|numsnpairs
operator|=
name|tmpuses
operator|=
literal|0
expr_stmt|;
name|numecs
operator|=
name|numeps
operator|=
name|eps2
operator|=
name|num_reallocs
operator|=
name|hshcol
operator|=
name|dfaeql
operator|=
name|totnst
operator|=
literal|0
expr_stmt|;
name|numuniq
operator|=
name|numdup
operator|=
name|hshsave
operator|=
name|eofseen
operator|=
name|datapos
operator|=
name|dataline
operator|=
literal|0
expr_stmt|;
name|num_backing_up
operator|=
name|onesp
operator|=
name|numprots
operator|=
literal|0
expr_stmt|;
name|variable_trailing_context_rules
operator|=
name|bol_needed
operator|=
name|false
expr_stmt|;
name|linenum
operator|=
name|sectnum
operator|=
literal|1
expr_stmt|;
name|firstprot
operator|=
name|NIL
expr_stmt|;
comment|/* Used in mkprot() so that the first proto goes in slot 1 	 * of the proto queue. 	 */
name|lastprot
operator|=
literal|1
expr_stmt|;
name|set_up_initial_allocations
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* readin - read in the rules section of the input file(s) */
end_comment

begin_function
name|void
name|readin
parameter_list|()
block|{
specifier|static
name|char
name|yy_stdinit
index|[]
init|=
literal|"FILE *yyin = stdin, *yyout = stdout;"
decl_stmt|;
specifier|static
name|char
name|yy_nostdinit
index|[]
init|=
literal|"FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;"
decl_stmt|;
name|line_directive_out
argument_list|(
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
condition|)
block|{
name|pinpoint_message
argument_list|(
name|_
argument_list|(
literal|"fatal parse error"
argument_list|)
argument_list|)
expr_stmt|;
name|flexend
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|syntaxerror
condition|)
name|flexend
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If the user explicitly requested posix compatibility by specifing the 	 * posix-compat option, then we check for conflicting options. However, if 	 * the POSIXLY_CORRECT variable is set, then we quietly make flex as 	 * posix-compatible as possible.  This is the recommended behavior 	 * according to the GNU Coding Standards. 	 * 	 * Note: The posix option was added to flex to provide the posix behavior 	 * of the repeat operator in regular expressions, e.g., `ab{3}' 	 */
if|if
condition|(
name|posix_compat
condition|)
block|{
comment|/* TODO: This is where we try to make flex behave according to 		 * posiz, AND check for conflicting options. How far should we go 		 * with this? Should we disable all the neat-o flex features? 		 */
comment|/* Update: Estes says no, since other flex features don't violate posix. */
block|}
if|if
condition|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
condition|)
block|{
name|posix_compat
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|backing_up_report
condition|)
block|{
name|backing_up_file
operator|=
name|fopen
argument_list|(
name|backing_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|backing_up_file
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"could not create backing-up info file %s"
argument_list|)
argument_list|,
name|backing_name
argument_list|)
expr_stmt|;
block|}
else|else
name|backing_up_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|yymore_really_used
operator|==
name|true
condition|)
name|yymore_used
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|yymore_really_used
operator|==
name|false
condition|)
name|yymore_used
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|reject_really_used
operator|==
name|true
condition|)
name|reject
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|reject_really_used
operator|==
name|false
condition|)
name|reject
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lex_compat
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"-l AT&T lex compatibility option entails a large performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" and may be the actual source of other reported performance penalties\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%%option yylineno entails a performance penalty ONLY on rules that can match newline characters\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|performance_report
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"-I (interactive) entails a minor performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"yymore() entails a minor performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"REJECT entails a large performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Variable trailing context rules entail a large performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
name|real_reject
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
name|reject
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|fulltbl
operator|||
name|fullspd
operator|)
operator|&&
name|reject
condition|)
block|{
if|if
condition|(
name|real_reject
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"REJECT cannot be used with -f or -F"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_yylineno
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"%option yylineno cannot be used with REJECT"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"variable trailing context rules cannot be used with -f or -F"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
block|{
name|out_m4_define
argument_list|(
literal|"M4_YY_USES_REJECT"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|//outn ("\n#define YY_USES_REJECT");
block|}
if|if
condition|(
operator|!
name|do_yywrap
condition|)
block|{
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
if|if
condition|(
name|reentrant
condition|)
name|outn
argument_list|(
literal|"\n#define yywrap(yyscanner) 1"
argument_list|)
expr_stmt|;
else|else
name|outn
argument_list|(
literal|"\n#define yywrap() 1"
argument_list|)
expr_stmt|;
block|}
name|outn
argument_list|(
literal|"#define YY_SKIP_YYWRAP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddebug
condition|)
name|outn
argument_list|(
literal|"\n#define FLEX_DEBUG"
argument_list|)
expr_stmt|;
name|OUT_BEGIN_CODE
argument_list|()
expr_stmt|;
if|if
condition|(
name|csize
operator|==
literal|256
condition|)
name|outn
argument_list|(
literal|"typedef unsigned char YY_CHAR;"
argument_list|)
expr_stmt|;
else|else
name|outn
argument_list|(
literal|"typedef char YY_CHAR;"
argument_list|)
expr_stmt|;
name|OUT_END_CODE
argument_list|()
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|outn
argument_list|(
literal|"#define yytext_ptr yytext"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|outn
argument_list|(
literal|"#define YY_INTERACTIVE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUT_BEGIN_CODE
argument_list|()
expr_stmt|;
comment|/* In reentrant scanner, stdinit is handled in flex.skl. */
if|if
condition|(
name|do_stdinit
condition|)
block|{
if|if
condition|(
name|reentrant
condition|)
block|{
name|outn
argument_list|(
literal|"#ifdef VMS"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#ifdef __VMS_POSIX"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define YY_STDINIT"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#else"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define YY_STDINIT"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
block|}
name|outn
argument_list|(
literal|"#ifdef VMS"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#ifndef __VMS_POSIX"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
name|yy_nostdinit
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#else"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
name|yy_stdinit
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#else"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
name|yy_stdinit
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reentrant
condition|)
name|outn
argument_list|(
name|yy_nostdinit
argument_list|)
expr_stmt|;
block|}
name|OUT_END_CODE
argument_list|()
expr_stmt|;
block|}
name|OUT_BEGIN_CODE
argument_list|()
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
name|outn
argument_list|(
literal|"typedef yyconst struct yy_trans_info *yy_state_type;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
name|outn
argument_list|(
literal|"typedef int yy_state_type;"
argument_list|)
expr_stmt|;
name|OUT_END_CODE
argument_list|()
expr_stmt|;
if|if
condition|(
name|lex_compat
condition|)
name|outn
argument_list|(
literal|"#define YY_FLEX_LEX_COMPAT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|C_plus_plus
operator|&&
operator|!
name|reentrant
condition|)
block|{
name|outn
argument_list|(
literal|"extern int yylineno;"
argument_list|)
expr_stmt|;
name|OUT_BEGIN_CODE
argument_list|()
expr_stmt|;
name|outn
argument_list|(
literal|"int yylineno = 1;"
argument_list|)
expr_stmt|;
name|OUT_END_CODE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|outn
argument_list|(
literal|"\n#include<FlexLexer.h>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_yywrap
condition|)
block|{
name|outn
argument_list|(
literal|"\nint yyFlexLexer::yywrap() { return 1; }"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yyclass
condition|)
block|{
name|outn
argument_list|(
literal|"int yyFlexLexer::yylex()"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t{"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\tLexerError( \"yyFlexLexer::yylex invoked but %option yyclass used\" );"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\treturn 0;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t}"
argument_list|)
expr_stmt|;
name|out_str
argument_list|(
literal|"\n#define YY_DECL int %s::yylex()\n"
argument_list|,
name|yyclass
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Watch out: yytext_ptr is a variable when yytext is an array, 		 * but it's a macro when yytext is a pointer. 		 */
if|if
condition|(
name|yytext_is_array
condition|)
block|{
if|if
condition|(
operator|!
name|reentrant
condition|)
name|outn
argument_list|(
literal|"extern char yytext[];\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reentrant
condition|)
block|{
name|outn
argument_list|(
literal|"#define yytext_ptr yytext_r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outn
argument_list|(
literal|"extern char *yytext;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define yytext_ptr yytext"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|yyclass
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"%option yyclass only meaningful for C++ scanners"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useecs
condition|)
name|numecs
operator|=
name|cre8ecs
argument_list|(
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|)
expr_stmt|;
else|else
name|numecs
operator|=
name|csize
expr_stmt|;
comment|/* Now map the equivalence class for NUL to its expected place. */
name|ecgroup
index|[
literal|0
index|]
operator|=
name|ecgroup
index|[
name|csize
index|]
expr_stmt|;
name|NUL_ec
operator|=
name|ABS
argument_list|(
name|ecgroup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|ccl2ecl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_up_initial_allocations - allocate memory for internal tables */
end_comment

begin_function
name|void
name|set_up_initial_allocations
parameter_list|()
block|{
name|maximum_mns
operator|=
operator|(
name|long_align
condition|?
name|MAXIMUM_MNS_LONG
else|:
name|MAXIMUM_MNS
operator|)
expr_stmt|;
name|current_mns
operator|=
name|INITIAL_MNS
expr_stmt|;
name|firstst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|lastst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|finalst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|transchar
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|trans1
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|trans2
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|accptnum
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|assoc_rule
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|state_type
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|current_max_rules
operator|=
name|INITIAL_MAX_RULES
expr_stmt|;
name|rule_type
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_linenum
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_useful
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_has_nl
operator|=
name|allocate_bool_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|current_max_scs
operator|=
name|INITIAL_MAX_SCS
expr_stmt|;
name|scset
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scbol
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scxclu
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|sceof
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scname
operator|=
name|allocate_char_ptr_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|current_maxccls
operator|=
name|INITIAL_MAX_CCLS
expr_stmt|;
name|cclmap
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|ccllen
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|cclng
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|ccl_has_nl
operator|=
name|allocate_bool_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|current_max_ccl_tbl_size
operator|=
name|INITIAL_MAX_CCL_TBL_SIZE
expr_stmt|;
name|ccltbl
operator|=
name|allocate_Character_array
argument_list|(
name|current_max_ccl_tbl_size
argument_list|)
expr_stmt|;
name|current_max_dfa_size
operator|=
name|INITIAL_MAX_DFA_SIZE
expr_stmt|;
name|current_max_xpairs
operator|=
name|INITIAL_MAX_XPAIRS
expr_stmt|;
name|nxt
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|chk
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|current_max_template_xpairs
operator|=
name|INITIAL_MAX_TEMPLATE_XPAIRS
expr_stmt|;
name|tnxt
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_template_xpairs
argument_list|)
expr_stmt|;
name|current_max_dfas
operator|=
name|INITIAL_MAX_DFAS
expr_stmt|;
name|base
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|def
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfasiz
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|accsiz
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dhash
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dss
operator|=
name|allocate_int_ptr_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfaacc
operator|=
name|allocate_dfaacc_union
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|nultrans
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* extracts basename from path, optionally stripping the extension "\.*"  * (same concept as /bin/sh `basename`, but different handling of extension). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|basename2
parameter_list|(
name|path
parameter_list|,
name|strip_ext
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|strip_ext
decl_stmt|;
comment|/* boolean */
block|{
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|e
init|=
literal|0
decl_stmt|;
name|b
operator|=
name|path
expr_stmt|;
for|for
control|(
name|b
operator|=
name|path
init|;
operator|*
name|path
condition|;
name|path
operator|++
control|)
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|b
operator|=
name|path
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|path
operator|==
literal|'.'
condition|)
name|e
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|strip_ext
operator|&&
name|e
operator|&&
name|e
operator|>
name|b
condition|)
operator|*
name|e
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|stdout
decl_stmt|;
if|if
condition|(
operator|!
name|did_outfilename
condition|)
block|{
name|snprintf
argument_list|(
name|outfile_path
argument_list|,
sizeof|sizeof
argument_list|(
name|outfile_path
argument_list|)
argument_list|,
name|outfile_template
argument_list|,
name|prefix
argument_list|,
name|C_plus_plus
condition|?
literal|"cc"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|outfile_path
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [OPTIONS] [FILE]...\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Generates programs that perform pattern-matching on text.\n"
literal|"\n"
literal|"Table Compression:\n"
literal|"  -Ca, --align      trade off larger tables for better memory alignment\n"
literal|"  -Ce, --ecs        construct equivalence classes\n"
literal|"  -Cf               do not compress tables; use -f representation\n"
literal|"  -CF               do not compress tables; use -F representation\n"
literal|"  -Cm, --meta-ecs   construct meta-equivalence classes\n"
literal|"  -Cr, --read       use read() instead of stdio for scanner input\n"
literal|"  -f, --full        generate fast, large scanner. Same as -Cfr\n"
literal|"  -F, --fast        use alternate table representation. Same as -CFr\n"
literal|"  -Cem              default compression (same as --ecs --meta-ecs)\n"
literal|"\n"
literal|"Debugging:\n"
literal|"  -d, --debug             enable debug mode in scanner\n"
literal|"  -b, --backup            write backing-up information to %s\n"
literal|"  -p, --perf-report       write performance report to stderr\n"
literal|"  -s, --nodefault         suppress default rule to ECHO unmatched text\n"
literal|"  -T, --trace             %s should run in trace mode\n"
literal|"  -w, --nowarn            do not generate warnings\n"
literal|"  -v, --verbose           write summary of scanner statistics to stdout\n"
literal|"\n"
literal|"Files:\n"
literal|"  -o, --outfile=FILE      specify output filename\n"
literal|"  -S, --skel=FILE         specify skeleton file\n"
literal|"  -t, --stdout            write scanner on stdout instead of %s\n"
literal|"      --yyclass=NAME      name of C++ class\n"
literal|"      --header-file=FILE   create a C header file in addition to the scanner\n"
literal|"      --tables-file[=FILE] write tables to FILE\n"
literal|"\n"
literal|"Scanner behavior:\n"
literal|"  -7, --7bit              generate 7-bit scanner\n"
literal|"  -8, --8bit              generate 8-bit scanner\n"
literal|"  -B, --batch             generate batch scanner (opposite of -I)\n"
literal|"  -i, --case-insensitive  ignore case in patterns\n"
literal|"  -l, --lex-compat        maximal compatibility with original lex\n"
literal|"  -X, --posix-compat      maximal compatibility with POSIX lex\n"
literal|"  -I, --interactive       generate interactive scanner (opposite of -B)\n"
literal|"      --yylineno          track line count in yylineno\n"
literal|"\n"
literal|"Generated code:\n"
literal|"  -+,  --c++               generate C++ scanner class\n"
literal|"  -Dmacro[=defn]           #define macro defn  (default defn is '1')\n"
literal|"  -L,  --noline            suppress #line directives in scanner\n"
literal|"  -P,  --prefix=STRING     use STRING as prefix instead of \"yy\"\n"
literal|"  -R,  --reentrant         generate a reentrant C scanner\n"
literal|"       --bison-bridge      scanner for bison pure parser.\n"
literal|"       --bison-locations   include yylloc support.\n"
literal|"       --stdinit           initialize yyin/yyout to stdin/stdout\n"
literal|"       --noansi-definitions old-style function definitions\n"
literal|"       --noansi-prototypes  empty parameter list in prototypes\n"
literal|"       --nounistd          do not include<unistd.h>\n"
literal|"       --noFUNCTION        do not generate a particular FUNCTION\n"
literal|"\n"
literal|"Miscellaneous:\n"
literal|"  -c                      do-nothing POSIX option\n"
literal|"  -n                      do-nothing POSIX option\n"
literal|"  -?\n"
literal|"  -h, --help              produce this help message\n"
literal|"  -V, --version           report %s version\n"
argument_list|)
argument_list|,
name|backing_name
argument_list|,
name|program_name
argument_list|,
name|outfile_path
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

