begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* flex - tool to generate fast lexical analyzers */
end_comment

begin_comment
comment|/*  Copyright (c) 1990 The Regents of the University of California. */
end_comment

begin_comment
comment|/*  All rights reserved. */
end_comment

begin_comment
comment|/*  This code is derived from software contributed to Berkeley by */
end_comment

begin_comment
comment|/*  Vern Paxson. */
end_comment

begin_comment
comment|/*  The United States Government has rights in this work pursuant */
end_comment

begin_comment
comment|/*  to contract no. DE-AC03-76SF00098 between the United States */
end_comment

begin_comment
comment|/*  Department of Energy and the University of California. */
end_comment

begin_comment
comment|/*  This file is part of flex. */
end_comment

begin_comment
comment|/*  Redistribution and use in source and binary forms, with or without */
end_comment

begin_comment
comment|/*  modification, are permitted provided that the following conditions */
end_comment

begin_comment
comment|/*  are met: */
end_comment

begin_comment
comment|/*  1. Redistributions of source code must retain the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer. */
end_comment

begin_comment
comment|/*  2. Redistributions in binary form must reproduce the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer in the */
end_comment

begin_comment
comment|/*     documentation and/or other materials provided with the distribution. */
end_comment

begin_comment
comment|/*  Neither the name of the University nor the names of its contributors */
end_comment

begin_comment
comment|/*  may be used to endorse or promote products derived from this software */
end_comment

begin_comment
comment|/*  without specific prior written permission. */
end_comment

begin_comment
comment|/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
end_comment

begin_comment
comment|/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
end_comment

begin_comment
comment|/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
end_comment

begin_comment
comment|/*  PURPOSE. */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_include
include|#
directive|include
file|"scanopt.h"
end_include

begin_comment
comment|/* Internal structures */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRCASECMP
end_ifdef

begin_define
define|#
directive|define
name|STRCASECMP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strcasecmp(a,b)
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|STRCASECMP
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|STRCASECMP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
specifier|const
name|char
modifier|*
name|b
decl_stmt|;
block|{
while|while
condition|(
name|tolower
argument_list|(
operator|*
name|a
operator|++
argument_list|)
operator|==
name|tolower
argument_list|(
operator|*
name|b
operator|++
argument_list|)
condition|)
empty_stmt|;
return|return
name|b
operator|-
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARG_NONE
value|0x01
end_define

begin_define
define|#
directive|define
name|ARG_REQ
value|0x02
end_define

begin_define
define|#
directive|define
name|ARG_OPT
value|0x04
end_define

begin_define
define|#
directive|define
name|IS_LONG
value|0x08
end_define

begin_struct
struct|struct
name|_aux
block|{
name|int
name|flags
decl_stmt|;
comment|/* The above hex flags. */
name|int
name|namelen
decl_stmt|;
comment|/* Length of the actual option word, e.g., "--file[=foo]" is 4 */
name|int
name|printlen
decl_stmt|;
comment|/* Length of entire string, e.g., "--file[=foo]" is 12 */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_scanopt_t
block|{
specifier|const
name|optspec_t
modifier|*
name|options
decl_stmt|;
comment|/* List of options. */
name|struct
name|_aux
modifier|*
name|aux
decl_stmt|;
comment|/* Auxiliary data about options. */
name|int
name|optc
decl_stmt|;
comment|/* Number of options. */
name|int
name|argc
decl_stmt|;
comment|/* Number of args. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of strings. */
name|int
name|index
decl_stmt|;
comment|/* Used as: argv[index][subscript]. */
name|int
name|subscript
decl_stmt|;
name|char
name|no_err_msg
decl_stmt|;
comment|/* If true, do not print errors. */
name|char
name|has_long
decl_stmt|;
name|char
name|has_short
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Accessor functions. These WOULD be one-liners, but portability calls. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|NAME
name|PROTO
argument_list|(
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PRINTLEN
name|PROTO
argument_list|(
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|RVAL
name|PROTO
argument_list|(
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FLAGS
name|PROTO
argument_list|(
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|DESC
name|PROTO
argument_list|(
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scanopt_err
name|PROTO
argument_list|(
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|matchlongopt
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_opt
name|PROTO
argument_list|(
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
name|opt_offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|NAME
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|s
operator|->
name|options
index|[
name|i
index|]
operator|.
name|opt_fmt
operator|+
operator|(
operator|(
name|s
operator|->
name|aux
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IS_LONG
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PRINTLEN
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|s
operator|->
name|aux
index|[
name|i
index|]
operator|.
name|printlen
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RVAL
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|s
operator|->
name|options
index|[
name|i
index|]
operator|.
name|r_val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FLAGS
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|s
operator|->
name|aux
index|[
name|i
index|]
operator|.
name|flags
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|DESC
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|s
operator|->
name|options
index|[
name|i
index|]
operator|.
name|desc
condition|?
name|s
operator|->
name|options
index|[
name|i
index|]
operator|.
name|desc
else|:
literal|""
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SCANOPT_USAGE
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|get_cols
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|get_cols
parameter_list|()
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|int
name|cols
init|=
literal|80
decl_stmt|;
comment|/* default */
ifdef|#
directive|ifdef
name|HAVE_NCURSES_H
name|initscr
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
if|if
condition|(
name|COLS
operator|>
literal|0
condition|)
return|return
name|COLS
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cols
operator|=
name|atoi
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
name|cols
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro to check for NULL before assigning a value. */
end_comment

begin_define
define|#
directive|define
name|SAFE_ASSIGN
parameter_list|(
name|ptr
parameter_list|,
name|val
parameter_list|)
define|\
value|do{                      \         if((ptr)!=NULL)      \             *(ptr) = val;    \     }while(0)
end_define

begin_comment
comment|/* Macro to assure we reset subscript whenever we adjust s->index.*/
end_comment

begin_define
define|#
directive|define
name|INC_INDEX
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
define|\
value|do{                    \        (s)->index += (n);  \        (s)->subscript= 0;  \     }while(0)
end_define

begin_function
name|scanopt_t
modifier|*
name|scanopt_init
parameter_list|(
name|options
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|optspec_t
modifier|*
name|options
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_scanopt_t
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|s
operator|->
name|optc
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|argc
operator|=
name|argc
expr_stmt|;
name|s
operator|->
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
expr_stmt|;
name|s
operator|->
name|index
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|subscript
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|no_err_msg
operator|=
operator|(
name|flags
operator|&
name|SCANOPT_NO_ERR_MSG
operator|)
expr_stmt|;
name|s
operator|->
name|has_long
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|has_short
operator|=
literal|0
expr_stmt|;
comment|/* Determine option count. (Find entry with all zeros). */
name|s
operator|->
name|optc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|options
index|[
name|s
operator|->
name|optc
index|]
operator|.
name|opt_fmt
operator|||
name|options
index|[
name|s
operator|->
name|optc
index|]
operator|.
name|r_val
operator|||
name|options
index|[
name|s
operator|->
name|optc
index|]
operator|.
name|desc
condition|)
name|s
operator|->
name|optc
operator|++
expr_stmt|;
comment|/* Build auxiliary data */
name|s
operator|->
name|aux
operator|=
operator|(
expr|struct
name|_aux
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|->
name|optc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_aux
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|optc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|Char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pname
decl_stmt|;
specifier|const
name|struct
name|optspec_t
modifier|*
name|opt
decl_stmt|;
name|struct
name|_aux
modifier|*
name|aux
decl_stmt|;
name|opt
operator|=
name|s
operator|->
name|options
operator|+
name|i
expr_stmt|;
name|aux
operator|=
name|s
operator|->
name|aux
operator|+
name|i
expr_stmt|;
name|aux
operator|->
name|flags
operator|=
name|ARG_NONE
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|opt_fmt
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|opt
operator|->
name|opt_fmt
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|aux
operator|->
name|flags
operator||=
name|IS_LONG
expr_stmt|;
name|pname
operator|=
operator|(
specifier|const
name|Char
operator|*
operator|)
operator|(
name|opt
operator|->
name|opt_fmt
operator|+
literal|2
operator|)
expr_stmt|;
name|s
operator|->
name|has_long
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pname
operator|=
operator|(
specifier|const
name|Char
operator|*
operator|)
operator|(
name|opt
operator|->
name|opt_fmt
operator|+
literal|1
operator|)
expr_stmt|;
name|s
operator|->
name|has_short
operator|=
literal|1
expr_stmt|;
block|}
name|aux
operator|->
name|printlen
operator|=
name|strlen
argument_list|(
name|opt
operator|->
name|opt_fmt
argument_list|)
expr_stmt|;
name|aux
operator|->
name|namelen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pname
operator|+
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
comment|/* detect required arg */
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
operator|||
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
operator|(
name|aux
operator|->
name|flags
operator|&
name|IS_LONG
operator|)
condition|)
block|{
if|if
condition|(
name|aux
operator|->
name|namelen
operator|==
literal|0
condition|)
name|aux
operator|->
name|namelen
operator|=
name|p
operator|-
name|pname
expr_stmt|;
name|aux
operator|->
name|flags
operator||=
name|ARG_REQ
expr_stmt|;
name|aux
operator|->
name|flags
operator|&=
operator|~
name|ARG_NONE
expr_stmt|;
block|}
comment|/* detect optional arg. This overrides required arg. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|aux
operator|->
name|namelen
operator|==
literal|0
condition|)
name|aux
operator|->
name|namelen
operator|=
name|p
operator|-
name|pname
expr_stmt|;
name|aux
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ARG_REQ
operator||
name|ARG_NONE
operator|)
expr_stmt|;
name|aux
operator|->
name|flags
operator||=
name|ARG_OPT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|aux
operator|->
name|namelen
operator|==
literal|0
condition|)
name|aux
operator|->
name|namelen
operator|=
name|p
operator|-
name|pname
expr_stmt|;
block|}
return|return
operator|(
name|scanopt_t
operator|*
operator|)
name|s
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SCANOPT_USAGE
end_ifndef

begin_comment
comment|/* these structs are for scanopt_usage(). */
end_comment

begin_struct
struct|struct
name|usg_elem
block|{
name|int
name|idx
decl_stmt|;
name|struct
name|usg_elem
modifier|*
name|next
decl_stmt|;
name|struct
name|usg_elem
modifier|*
name|alias
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|usg_elem
name|usg_elem
typedef|;
end_typedef

begin_comment
comment|/* Prints a usage message based on contents of optlist.  * Parameters:  *   scanner  - The scanner, already initialized with scanopt_init().  *   fp       - The file stream to write to.  *   usage    - Text to be prepended to option list.  * Return:  Always returns 0 (zero).  * The output looks something like this:  [indent][option, alias1, alias2...][indent][description line1                                             description line2...]  */
end_comment

begin_function
name|int
name|scanopt_usage
parameter_list|(
name|scanner
parameter_list|,
name|fp
parameter_list|,
name|usage
parameter_list|)
name|scanopt_t
modifier|*
name|scanner
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|usage
decl_stmt|;
block|{
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|columns
decl_stmt|,
name|indent
init|=
literal|2
decl_stmt|;
name|usg_elem
modifier|*
name|byr_val
init|=
name|NULL
decl_stmt|;
comment|/* option indices sorted by r_val */
name|usg_elem
modifier|*
name|store
decl_stmt|;
comment|/* array of preallocated elements. */
name|int
name|store_idx
init|=
literal|0
decl_stmt|;
name|usg_elem
modifier|*
name|ue
decl_stmt|;
name|int
name|maxlen
index|[
literal|2
index|]
decl_stmt|;
name|int
name|desccol
init|=
literal|0
decl_stmt|;
name|int
name|print_run
init|=
literal|0
decl_stmt|;
name|maxlen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|maxlen
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|)
name|scanner
expr_stmt|;
if|if
condition|(
name|usage
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the basename of argv[0] */
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
operator|->
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|s
operator|->
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|s
operator|->
name|argv
index|[
literal|0
index|]
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [OPTIONS]...\n"
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Sort by r_val and string. Yes, this is O(n*n), but n is small. */
name|store
operator|=
operator|(
name|usg_elem
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|->
name|optc
operator|*
sizeof|sizeof
argument_list|(
name|usg_elem
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|optc
condition|;
name|i
operator|++
control|)
block|{
comment|/* grab the next preallocate node. */
name|ue
operator|=
name|store
operator|+
name|store_idx
operator|++
expr_stmt|;
name|ue
operator|->
name|idx
operator|=
name|i
expr_stmt|;
name|ue
operator|->
name|next
operator|=
name|ue
operator|->
name|alias
operator|=
name|NULL
expr_stmt|;
comment|/* insert into list. */
if|if
condition|(
operator|!
name|byr_val
condition|)
name|byr_val
operator|=
name|ue
expr_stmt|;
else|else
block|{
name|int
name|found_alias
init|=
literal|0
decl_stmt|;
name|usg_elem
modifier|*
modifier|*
name|ue_curr
decl_stmt|,
modifier|*
modifier|*
name|ptr_if_no_alias
init|=
name|NULL
decl_stmt|;
name|ue_curr
operator|=
operator|&
name|byr_val
expr_stmt|;
while|while
condition|(
operator|*
name|ue_curr
condition|)
block|{
if|if
condition|(
name|RVAL
argument_list|(
name|s
argument_list|,
operator|(
operator|*
name|ue_curr
operator|)
operator|->
name|idx
argument_list|)
operator|==
name|RVAL
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
condition|)
block|{
comment|/* push onto the alias list. */
name|ue_curr
operator|=
operator|&
operator|(
operator|(
operator|*
name|ue_curr
operator|)
operator|->
name|alias
operator|)
expr_stmt|;
name|found_alias
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ptr_if_no_alias
operator|&&
name|STRCASECMP
argument_list|(
name|NAME
argument_list|(
name|s
argument_list|,
operator|(
operator|*
name|ue_curr
operator|)
operator|->
name|idx
argument_list|)
argument_list|,
name|NAME
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ptr_if_no_alias
operator|=
name|ue_curr
expr_stmt|;
block|}
name|ue_curr
operator|=
operator|&
operator|(
operator|(
operator|*
name|ue_curr
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_alias
operator|&&
name|ptr_if_no_alias
condition|)
name|ue_curr
operator|=
name|ptr_if_no_alias
expr_stmt|;
name|ue
operator|->
name|next
operator|=
operator|*
name|ue_curr
expr_stmt|;
operator|*
name|ue_curr
operator|=
name|ue
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (1) { 		printf ("ORIGINAL:\n"); 		for (i = 0; i< s->optc; i++) 			printf ("%2d: %s\n", i, NAME (s, i)); 		printf ("SORTED:\n"); 		ue = byr_val; 		while (ue) { 			usg_elem *ue2;  			printf ("%2d: %s\n", ue->idx, NAME (s, ue->idx)); 			for (ue2 = ue->alias; ue2; ue2 = ue2->next) 				printf ("  +---> %2d: %s\n", ue2->idx, 					NAME (s, ue2->idx)); 			ue = ue->next; 		} 	}
endif|#
directive|endif
comment|/* Now build each row of output. */
comment|/* first pass calculate how much room we need. */
for|for
control|(
name|ue
operator|=
name|byr_val
init|;
name|ue
condition|;
name|ue
operator|=
name|ue
operator|->
name|next
control|)
block|{
name|usg_elem
modifier|*
name|ap
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|nshort
init|=
literal|0
decl_stmt|,
name|nlong
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|CALC_LEN
parameter_list|(
name|i
parameter_list|)
value|do {\           if(FLAGS(s,i)& IS_LONG) \               len +=  (nlong++||nshort) ? 2+PRINTLEN(s,i) : PRINTLEN(s,i);\           else\               len +=  (nshort++||nlong)? 2+PRINTLEN(s,i) : PRINTLEN(s,i);\         }while(0)
if|if
condition|(
operator|!
operator|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
operator|)
condition|)
name|CALC_LEN
argument_list|(
name|ue
operator|->
name|idx
argument_list|)
expr_stmt|;
comment|/* do short aliases first. */
for|for
control|(
name|ap
operator|=
name|ue
operator|->
name|alias
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ap
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
condition|)
continue|continue;
name|CALC_LEN
argument_list|(
name|ap
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
condition|)
name|CALC_LEN
argument_list|(
name|ue
operator|->
name|idx
argument_list|)
expr_stmt|;
comment|/* repeat the above loop, this time for long aliases. */
for|for
control|(
name|ap
operator|=
name|ue
operator|->
name|alias
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ap
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
operator|)
condition|)
continue|continue;
name|CALC_LEN
argument_list|(
name|ap
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|maxlen
index|[
literal|0
index|]
condition|)
name|maxlen
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
comment|/* It's much easier to calculate length for description column! */
name|len
operator|=
name|strlen
argument_list|(
name|DESC
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|maxlen
index|[
literal|1
index|]
condition|)
name|maxlen
index|[
literal|1
index|]
operator|=
name|len
expr_stmt|;
block|}
comment|/* Determine how much room we have, and how much we will allocate to each col. 	 * Do not address pathological cases. Output will just be ugly. */
name|columns
operator|=
name|get_cols
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|maxlen
index|[
literal|0
index|]
operator|+
name|maxlen
index|[
literal|1
index|]
operator|+
name|indent
operator|*
literal|2
operator|>
name|columns
condition|)
block|{
comment|/* col 0 gets whatever it wants. we'll wrap the desc col. */
name|maxlen
index|[
literal|1
index|]
operator|=
name|columns
operator|-
operator|(
name|maxlen
index|[
literal|0
index|]
operator|+
name|indent
operator|*
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|maxlen
index|[
literal|1
index|]
operator|<
literal|14
condition|)
comment|/* 14 is arbitrary lower limit on desc width. */
name|maxlen
index|[
literal|1
index|]
operator|=
name|INT_MAX
expr_stmt|;
block|}
name|desccol
operator|=
name|maxlen
index|[
literal|0
index|]
operator|+
name|indent
operator|*
literal|2
expr_stmt|;
define|#
directive|define
name|PRINT_SPACES
parameter_list|(
name|fp
parameter_list|,
name|n
parameter_list|)
define|\
value|do{\         int _n;\         _n=(n);\         while(_n--> 0)\             fputc(' ',(fp));\     }while(0)
comment|/* Second pass (same as above loop), this time we print. */
comment|/* Sloppy hack: We iterate twice. The first time we print short and long options. 	   The second time we print those lines that have ONLY long options. */
while|while
condition|(
name|print_run
operator|++
operator|<
literal|2
condition|)
block|{
for|for
control|(
name|ue
operator|=
name|byr_val
init|;
name|ue
condition|;
name|ue
operator|=
name|ue
operator|->
name|next
control|)
block|{
name|usg_elem
modifier|*
name|ap
decl_stmt|;
name|int
name|nwords
init|=
literal|0
decl_stmt|,
name|nchars
init|=
literal|0
decl_stmt|,
name|has_short
init|=
literal|0
decl_stmt|;
comment|/* TODO: get has_short schtick to work */
name|has_short
operator|=
operator|!
operator|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
operator|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ue
operator|->
name|alias
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ap
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
operator|)
condition|)
block|{
name|has_short
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|print_run
operator|==
literal|1
operator|&&
operator|!
name|has_short
operator|)
operator|||
operator|(
name|print_run
operator|==
literal|2
operator|&&
name|has_short
operator|)
condition|)
continue|continue;
name|PRINT_SPACES
argument_list|(
name|fp
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|nchars
operator|+=
name|indent
expr_stmt|;
comment|/* Print, adding a ", " between aliases. */
define|#
directive|define
name|PRINT_IT
parameter_list|(
name|i
parameter_list|)
value|do{\                   if(nwords++)\                       nchars+=fprintf(fp,", ");\                   nchars+=fprintf(fp,"%s",s->options[i].opt_fmt);\             }while(0)
if|if
condition|(
operator|!
operator|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
operator|)
condition|)
name|PRINT_IT
argument_list|(
name|ue
operator|->
name|idx
argument_list|)
expr_stmt|;
comment|/* print short aliases first. */
for|for
control|(
name|ap
operator|=
name|ue
operator|->
name|alias
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ap
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
operator|)
condition|)
name|PRINT_IT
argument_list|(
name|ap
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
condition|)
name|PRINT_IT
argument_list|(
name|ue
operator|->
name|idx
argument_list|)
expr_stmt|;
comment|/* repeat the above loop, this time for long aliases. */
for|for
control|(
name|ap
operator|=
name|ue
operator|->
name|alias
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|FLAGS
argument_list|(
name|s
argument_list|,
name|ap
operator|->
name|idx
argument_list|)
operator|&
name|IS_LONG
condition|)
name|PRINT_IT
argument_list|(
name|ap
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
comment|/* pad to desccol */
name|PRINT_SPACES
argument_list|(
name|fp
argument_list|,
name|desccol
operator|-
name|nchars
argument_list|)
expr_stmt|;
comment|/* Print description, wrapped to maxlen[1] columns. */
if|if
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|pstart
decl_stmt|;
name|pstart
operator|=
name|DESC
argument_list|(
name|s
argument_list|,
name|ue
operator|->
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|lastws
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pstart
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|n
operator|<
name|maxlen
index|[
literal|1
index|]
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
call|(
name|Char
call|)
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|lastws
operator|=
name|p
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
comment|/* hit end of desc. done. */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|pstart
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
comment|/* print everything up to here then wrap. */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.*s\n"
argument_list|,
name|n
argument_list|,
name|pstart
argument_list|)
expr_stmt|;
name|PRINT_SPACES
argument_list|(
name|fp
argument_list|,
name|desccol
argument_list|)
expr_stmt|;
name|pstart
operator|=
name|p
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* we hit the edge of the screen. wrap at space if possible. */
if|if
condition|(
name|lastws
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.*s\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lastws
operator|-
name|pstart
argument_list|)
argument_list|,
name|pstart
argument_list|)
expr_stmt|;
name|pstart
operator|=
name|lastws
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.*s\n"
argument_list|,
name|n
argument_list|,
name|pstart
argument_list|)
expr_stmt|;
name|pstart
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
name|PRINT_SPACES
argument_list|(
name|fp
argument_list|,
name|desccol
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
block|}
comment|/* end while */
name|free
argument_list|(
name|store
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no scanopt_usage */
end_comment

begin_function
specifier|static
name|int
name|scanopt_err
parameter_list|(
name|s
parameter_list|,
name|opt_offset
parameter_list|,
name|is_short
parameter_list|,
name|err
parameter_list|)
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|opt_offset
decl_stmt|;
name|int
name|is_short
decl_stmt|;
name|int
name|err
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|optname
init|=
literal|""
decl_stmt|;
name|char
name|optchar
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|optspec_t
modifier|*
name|opt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|opt_offset
operator|>=
literal|0
condition|)
name|opt
operator|=
name|s
operator|->
name|options
operator|+
name|opt_offset
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|no_err_msg
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|index
operator|>
literal|0
operator|&&
name|s
operator|->
name|index
operator|<
name|s
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|is_short
condition|)
block|{
name|optchar
index|[
literal|0
index|]
operator|=
name|s
operator|->
name|argv
index|[
name|s
operator|->
name|index
index|]
index|[
name|s
operator|->
name|subscript
index|]
expr_stmt|;
name|optchar
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|optname
operator|=
name|optchar
expr_stmt|;
block|}
else|else
block|{
name|optname
operator|=
name|s
operator|->
name|argv
index|[
name|s
operator|->
name|index
index|]
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|s
operator|->
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|SCANOPT_ERR_ARG_NOT_ALLOWED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"option `%s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|optname
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCANOPT_ERR_ARG_NOT_FOUND
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"option `%s' requires an argument\n"
argument_list|)
argument_list|,
name|optname
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCANOPT_ERR_OPT_AMBIGUOUS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"option `%s' is ambiguous\n"
argument_list|)
argument_list|,
name|optname
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCANOPT_ERR_OPT_UNRECOGNIZED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Unrecognized option `%s'\n"
argument_list|)
argument_list|,
name|optname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Unknown error=(%d)\n"
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal. Match str against the regex  ^--([^=]+)(=(.*))?  * return 1 if *looks* like a long option.  * 'str' is the only input argument, the rest of the arguments are output only.  * optname will point to str + 2  *  */
end_comment

begin_function
specifier|static
name|int
name|matchlongopt
parameter_list|(
name|str
parameter_list|,
name|optname
parameter_list|,
name|optlen
parameter_list|,
name|arg
parameter_list|,
name|arglen
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
modifier|*
name|optname
decl_stmt|;
name|int
modifier|*
name|optlen
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
name|int
modifier|*
name|arglen
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
operator|*
name|optname
operator|=
operator|*
name|arg
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|optlen
operator|=
operator|*
name|arglen
operator|=
literal|0
expr_stmt|;
comment|/* Match regex /--./   */
name|p
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|||
operator|!
name|p
index|[
literal|2
index|]
condition|)
return|return
literal|0
return|;
name|p
operator|+=
literal|2
expr_stmt|;
operator|*
name|optname
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
comment|/* find the end of optname */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
operator|++
name|p
expr_stmt|;
operator|*
name|optlen
operator|=
name|p
operator|-
operator|*
name|optname
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
comment|/* an option with no '=...' part. */
return|return
literal|1
return|;
comment|/* We saw an '=' char. The rest of p is the arg. */
name|p
operator|++
expr_stmt|;
operator|*
name|arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
operator|++
name|p
expr_stmt|;
operator|*
name|arglen
operator|=
name|p
operator|-
operator|*
name|arg
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal. Look up long or short option by name.  * Long options must match a non-ambiguous prefix, or exact match.  * Short options must be exact.  * Return boolean true if found and no error.  * Error stored in err_code or zero if no error. */
end_comment

begin_function
specifier|static
name|int
name|find_opt
parameter_list|(
name|s
parameter_list|,
name|lookup_long
parameter_list|,
name|optstart
parameter_list|,
name|len
parameter_list|,
name|err_code
parameter_list|,
name|opt_offset
parameter_list|)
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|int
name|lookup_long
decl_stmt|;
name|char
modifier|*
name|optstart
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|err_code
decl_stmt|;
name|int
modifier|*
name|opt_offset
decl_stmt|;
block|{
name|int
name|nmatch
init|=
literal|0
decl_stmt|,
name|lastr_val
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|err_code
operator|=
literal|0
expr_stmt|;
operator|*
name|opt_offset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|optstart
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|optc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|optname
decl_stmt|;
name|optname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|s
operator|->
name|options
index|[
name|i
index|]
operator|.
name|opt_fmt
operator|+
operator|(
name|lookup_long
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|lookup_long
operator|&&
operator|(
name|s
operator|->
name|aux
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IS_LONG
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|s
operator|->
name|aux
index|[
name|i
index|]
operator|.
name|namelen
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|optname
argument_list|,
name|optstart
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nmatch
operator|++
expr_stmt|;
operator|*
name|opt_offset
operator|=
name|i
expr_stmt|;
comment|/* exact match overrides all. */
if|if
condition|(
name|len
operator|==
name|s
operator|->
name|aux
index|[
name|i
index|]
operator|.
name|namelen
condition|)
block|{
name|nmatch
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* ambiguity is ok between aliases. */
if|if
condition|(
name|lastr_val
operator|&&
name|lastr_val
operator|==
name|s
operator|->
name|options
index|[
name|i
index|]
operator|.
name|r_val
condition|)
name|nmatch
operator|--
expr_stmt|;
name|lastr_val
operator|=
name|s
operator|->
name|options
index|[
name|i
index|]
operator|.
name|r_val
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|lookup_long
operator|&&
operator|!
operator|(
name|s
operator|->
name|aux
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IS_LONG
operator|)
condition|)
block|{
if|if
condition|(
name|optname
index|[
literal|0
index|]
operator|==
name|optstart
index|[
literal|0
index|]
condition|)
block|{
name|nmatch
operator|++
expr_stmt|;
operator|*
name|opt_offset
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nmatch
operator|==
literal|0
condition|)
block|{
operator|*
name|err_code
operator|=
name|SCANOPT_ERR_OPT_UNRECOGNIZED
expr_stmt|;
operator|*
name|opt_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmatch
operator|>
literal|1
condition|)
block|{
operator|*
name|err_code
operator|=
name|SCANOPT_ERR_OPT_AMBIGUOUS
expr_stmt|;
operator|*
name|opt_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|*
name|err_code
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|scanopt
parameter_list|(
name|svoid
parameter_list|,
name|arg
parameter_list|,
name|optindex
parameter_list|)
name|scanopt_t
modifier|*
name|svoid
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
name|int
modifier|*
name|optindex
decl_stmt|;
block|{
name|char
modifier|*
name|optname
init|=
name|NULL
decl_stmt|,
modifier|*
name|optarg
init|=
name|NULL
decl_stmt|,
modifier|*
name|pstart
decl_stmt|;
name|int
name|namelen
init|=
literal|0
decl_stmt|,
name|arglen
init|=
literal|0
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|,
name|has_next
decl_stmt|;
specifier|const
name|optspec_t
modifier|*
name|optp
decl_stmt|;
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|struct
name|_aux
modifier|*
name|auxp
decl_stmt|;
name|int
name|is_short
decl_stmt|;
name|int
name|opt_offset
init|=
operator|-
literal|1
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|)
name|svoid
expr_stmt|;
comment|/* Normalize return-parameters. */
name|SAFE_ASSIGN
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SAFE_ASSIGN
argument_list|(
name|optindex
argument_list|,
name|s
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|index
operator|>=
name|s
operator|->
name|argc
condition|)
return|return
literal|0
return|;
comment|/* pstart always points to the start of our current scan. */
name|pstart
operator|=
name|s
operator|->
name|argv
index|[
name|s
operator|->
name|index
index|]
operator|+
name|s
operator|->
name|subscript
expr_stmt|;
if|if
condition|(
operator|!
name|pstart
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s
operator|->
name|subscript
operator|==
literal|0
condition|)
block|{
comment|/* test for exact match of "--" */
if|if
condition|(
name|pstart
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|pstart
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|pstart
index|[
literal|2
index|]
condition|)
block|{
name|SAFE_ASSIGN
argument_list|(
name|optindex
argument_list|,
name|s
operator|->
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|INC_INDEX
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Match an opt. */
if|if
condition|(
name|matchlongopt
argument_list|(
name|pstart
argument_list|,
operator|&
name|optname
argument_list|,
operator|&
name|namelen
argument_list|,
operator|&
name|optarg
argument_list|,
operator|&
name|arglen
argument_list|)
condition|)
block|{
comment|/* it LOOKS like an opt, but is it one?! */
if|if
condition|(
operator|!
name|find_opt
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|optname
argument_list|,
name|namelen
argument_list|,
operator|&
name|errcode
argument_list|,
operator|&
name|opt_offset
argument_list|)
condition|)
block|{
name|scanopt_err
argument_list|(
name|s
argument_list|,
name|opt_offset
argument_list|,
literal|0
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
return|return
name|errcode
return|;
block|}
comment|/* We handle this below. */
name|is_short
operator|=
literal|0
expr_stmt|;
comment|/* Check for short opt.  */
block|}
elseif|else
if|if
condition|(
name|pstart
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|pstart
index|[
literal|1
index|]
condition|)
block|{
comment|/* Pass through to below. */
name|is_short
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|subscript
operator|++
expr_stmt|;
name|pstart
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not an option. We're done. */
return|return
literal|0
return|;
block|}
block|}
comment|/* We have to re-check the subscript status because it 	 * may have changed above. */
if|if
condition|(
name|s
operator|->
name|subscript
operator|!=
literal|0
condition|)
block|{
comment|/* we are somewhere in a run of short opts, 		 * e.g., at the 'z' in `tar -xzf` */
name|optname
operator|=
name|pstart
expr_stmt|;
name|namelen
operator|=
literal|1
expr_stmt|;
name|is_short
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|find_opt
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|pstart
argument_list|,
name|namelen
argument_list|,
operator|&
name|errcode
argument_list|,
operator|&
name|opt_offset
argument_list|)
condition|)
block|{
return|return
name|scanopt_err
argument_list|(
name|s
argument_list|,
name|opt_offset
argument_list|,
literal|1
argument_list|,
name|errcode
argument_list|)
return|;
block|}
name|optarg
operator|=
name|pstart
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|optarg
condition|)
block|{
name|optarg
operator|=
name|NULL
expr_stmt|;
name|arglen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|arglen
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, we have a long or short option matched at opt_offset into 	 * the s->options array (and corresponding aux array). 	 * A trailing argument is in {optarg,arglen}, if any. 	 */
comment|/* Look ahead in argv[] to see if there is something 	 * that we can use as an argument (if needed). */
name|has_next
operator|=
name|s
operator|->
name|index
operator|+
literal|1
operator|<
name|s
operator|->
name|argc
operator|&&
name|strcmp
argument_list|(
literal|"--"
argument_list|,
name|s
operator|->
name|argv
index|[
name|s
operator|->
name|index
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|optp
operator|=
name|s
operator|->
name|options
operator|+
name|opt_offset
expr_stmt|;
name|auxp
operator|=
name|s
operator|->
name|aux
operator|+
name|opt_offset
expr_stmt|;
comment|/* case: no args allowed */
if|if
condition|(
name|auxp
operator|->
name|flags
operator|&
name|ARG_NONE
condition|)
block|{
if|if
condition|(
name|optarg
operator|&&
operator|!
name|is_short
condition|)
block|{
name|scanopt_err
argument_list|(
name|s
argument_list|,
name|opt_offset
argument_list|,
name|is_short
argument_list|,
name|errcode
operator|=
name|SCANOPT_ERR_ARG_NOT_ALLOWED
argument_list|)
expr_stmt|;
name|INC_INDEX
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|errcode
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optarg
condition|)
name|INC_INDEX
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|s
operator|->
name|subscript
operator|++
expr_stmt|;
return|return
name|optp
operator|->
name|r_val
return|;
block|}
comment|/* case: required */
if|if
condition|(
name|auxp
operator|->
name|flags
operator|&
name|ARG_REQ
condition|)
block|{
if|if
condition|(
operator|!
name|optarg
operator|&&
operator|!
name|has_next
condition|)
return|return
name|scanopt_err
argument_list|(
name|s
argument_list|,
name|opt_offset
argument_list|,
name|is_short
argument_list|,
name|SCANOPT_ERR_ARG_NOT_FOUND
argument_list|)
return|;
if|if
condition|(
operator|!
name|optarg
condition|)
block|{
comment|/* Let the next argv element become the argument. */
name|SAFE_ASSIGN
argument_list|(
name|arg
argument_list|,
name|s
operator|->
name|argv
index|[
name|s
operator|->
name|index
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|INC_INDEX
argument_list|(
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SAFE_ASSIGN
argument_list|(
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|optarg
argument_list|)
expr_stmt|;
name|INC_INDEX
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|optp
operator|->
name|r_val
return|;
block|}
comment|/* case: optional */
if|if
condition|(
name|auxp
operator|->
name|flags
operator|&
name|ARG_OPT
condition|)
block|{
name|SAFE_ASSIGN
argument_list|(
name|arg
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|INC_INDEX
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|optp
operator|->
name|r_val
return|;
block|}
comment|/* Should not reach here. */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|scanopt_destroy
parameter_list|(
name|svoid
parameter_list|)
name|scanopt_t
modifier|*
name|svoid
decl_stmt|;
block|{
name|struct
name|_scanopt_t
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|_scanopt_t
operator|*
operator|)
name|svoid
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|aux
condition|)
name|free
argument_list|(
name|s
operator|->
name|aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* vim:set tabstop=8 softtabstop=4 shiftwidth=4: */
end_comment

end_unit

