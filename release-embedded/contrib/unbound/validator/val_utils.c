begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_utils.c - validator utility functions.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains helper functions for the validator module.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_utils.h"
end_include

begin_include
include|#
directive|include
file|"validator/validator.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kentry.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_sigcrypt.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_anchor.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_neg.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_function
name|enum
name|val_classification
name|val_classify_response
parameter_list|(
name|uint16_t
name|query_flags
parameter_list|,
name|struct
name|query_info
modifier|*
name|origqinf
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|size_t
name|skip
parameter_list|)
block|{
name|int
name|rcode
init|=
operator|(
name|int
operator|)
name|FLAGS_GET_RCODE
argument_list|(
name|rep
operator|->
name|flags
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* Normal Name Error's are easy to detect -- but don't mistake a CNAME 	 * chain ending in NXDOMAIN. */
if|if
condition|(
name|rcode
operator|==
name|LDNS_RCODE_NXDOMAIN
operator|&&
name|rep
operator|->
name|an_numrrsets
operator|==
literal|0
condition|)
return|return
name|VAL_CLASS_NAMEERROR
return|;
comment|/* check for referral: nonRD query and it looks like a nodata */
if|if
condition|(
operator|!
operator|(
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
name|rep
operator|->
name|an_numrrsets
operator|==
literal|0
operator|&&
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
condition|)
block|{
comment|/* SOA record in auth indicates it is NODATA instead. 		 * All validation requiring NODATA messages have SOA in  		 * authority section. */
comment|/* uses fact that answer section is empty */
name|int
name|saw_ns
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
return|return
name|VAL_CLASS_NODATA
return|;
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
condition|)
return|return
name|VAL_CLASS_REFERRAL
return|;
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
condition|)
name|saw_ns
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|saw_ns
condition|?
name|VAL_CLASS_REFERRAL
else|:
name|VAL_CLASS_NODATA
return|;
block|}
comment|/* root referral where NS set is in the answer section */
if|if
condition|(
operator|!
operator|(
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
name|rep
operator|->
name|ns_numrrsets
operator|==
literal|0
operator|&&
name|rep
operator|->
name|an_numrrsets
operator|==
literal|1
operator|&&
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
operator|&&
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
name|query_dname_compare
argument_list|(
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|origqinf
operator|->
name|qname
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|VAL_CLASS_REFERRAL
return|;
comment|/* dump bad messages */
if|if
condition|(
name|rcode
operator|!=
name|LDNS_RCODE_NOERROR
operator|&&
name|rcode
operator|!=
name|LDNS_RCODE_NXDOMAIN
condition|)
return|return
name|VAL_CLASS_UNKNOWN
return|;
comment|/* next check if the skip into the answer section shows no answer */
if|if
condition|(
name|skip
operator|>
literal|0
operator|&&
name|rep
operator|->
name|an_numrrsets
operator|<=
name|skip
condition|)
return|return
name|VAL_CLASS_CNAMENOANSWER
return|;
comment|/* Next is NODATA */
if|if
condition|(
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
operator|&&
name|rep
operator|->
name|an_numrrsets
operator|==
literal|0
condition|)
return|return
name|VAL_CLASS_NODATA
return|;
comment|/* We distinguish between CNAME response and other positive/negative 	 * responses because CNAME answers require extra processing. */
comment|/* We distinguish between ANY and CNAME or POSITIVE because  	 * ANY responses are validated differently. */
if|if
condition|(
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
operator|&&
name|qinf
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_ANY
condition|)
return|return
name|VAL_CLASS_ANY
return|;
comment|/* Note that DNAMEs will be ignored here, unless qtype=DNAME. Unless 	 * qtype=CNAME, this will yield a CNAME response. */
for|for
control|(
name|i
operator|=
name|skip
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
operator|&&
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|qinf
operator|->
name|qtype
condition|)
return|return
name|VAL_CLASS_POSITIVE
return|;
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
return|return
name|VAL_CLASS_CNAME
return|;
block|}
name|log_dns_msg
argument_list|(
literal|"validator: error. failed to classify response message: "
argument_list|,
name|qinf
argument_list|,
name|rep
argument_list|)
expr_stmt|;
return|return
name|VAL_CLASS_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/** Get signer name from RRSIG */
end_comment

begin_function
specifier|static
name|void
name|rrsig_get_signer
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|sname
parameter_list|,
name|size_t
modifier|*
name|slen
parameter_list|)
block|{
comment|/* RRSIG rdata is not allowed to be compressed, it is stored 	 * uncompressed in memory as well, so return a ptr to the name */
if|if
condition|(
name|len
operator|<
literal|21
condition|)
block|{
comment|/* too short RRSig: 		 * short, byte, byte, long, long, long, short, "." is 		 * 2	1	1	4	4  4	2	1 = 19 		 * 			and a skip of 18 bytes to the name. 		 * +2 for the rdatalen is 21 bytes len for root label */
operator|*
name|sname
operator|=
name|NULL
expr_stmt|;
operator|*
name|slen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|data
operator|+=
literal|20
expr_stmt|;
comment|/* skip the fixed size bits */
name|len
operator|-=
literal|20
expr_stmt|;
operator|*
name|slen
operator|=
name|dname_valid
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slen
condition|)
block|{
comment|/* bad dname in this rrsig. */
operator|*
name|sname
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
operator|*
name|sname
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|val_find_rrset_signer
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|sname
parameter_list|,
name|size_t
modifier|*
name|slen
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
comment|/* return signer for first signature, or NULL */
if|if
condition|(
name|d
operator|->
name|rrsig_count
operator|==
literal|0
condition|)
block|{
operator|*
name|sname
operator|=
name|NULL
expr_stmt|;
operator|*
name|slen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* get rrsig signer name out of the signature */
name|rrsig_get_signer
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|d
operator|->
name|count
index|]
argument_list|,
name|d
operator|->
name|rr_len
index|[
name|d
operator|->
name|count
index|]
argument_list|,
name|sname
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Find best signer name in this set of rrsigs.  * @param rrset: which rrsigs to look through.  * @param qinf: the query name that needs validation.  * @param signer_name: the best signer_name. Updated if a better one is found.  * @param signer_len: length of signer name.  * @param matchcount: count of current best name (starts at 0 for no match).  * 	Updated if match is improved.  */
end_comment

begin_function
specifier|static
name|void
name|val_find_best_signer
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|signer_name
parameter_list|,
name|size_t
modifier|*
name|signer_len
parameter_list|,
name|int
modifier|*
name|matchcount
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|sign
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|count
init|;
name|i
operator|<
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
name|sign
operator|=
name|d
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
operator|+
literal|18
expr_stmt|;
comment|/* look at signatures that are valid (long enough), 		 * and have a signer name that is a superdomain of qname, 		 * and then check the number of labels in the shared topdomain 		 * improve the match if possible */
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|>
literal|2
operator|+
literal|19
operator|&&
comment|/* rdata, sig + root label*/
name|dname_subdomain_c
argument_list|(
name|qinf
operator|->
name|qname
argument_list|,
name|sign
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|qinf
operator|->
name|qname
argument_list|,
name|dname_count_labels
argument_list|(
name|qinf
operator|->
name|qname
argument_list|)
argument_list|,
name|sign
argument_list|,
name|dname_count_labels
argument_list|(
name|sign
argument_list|)
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
operator|*
name|matchcount
condition|)
block|{
operator|*
name|matchcount
operator|=
name|m
expr_stmt|;
operator|*
name|signer_name
operator|=
name|sign
expr_stmt|;
operator|(
name|void
operator|)
name|dname_count_size_labels
argument_list|(
operator|*
name|signer_name
argument_list|,
name|signer_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|val_find_signer
parameter_list|(
name|enum
name|val_classification
name|subtype
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|signer_name
parameter_list|,
name|size_t
modifier|*
name|signer_len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_POSITIVE
operator|||
name|subtype
operator|==
name|VAL_CLASS_ANY
condition|)
block|{
comment|/* check for the answer rrset */
for|for
control|(
name|i
operator|=
name|skip
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query_dname_compare
argument_list|(
name|qinf
operator|->
name|qname
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val_find_rrset_signer
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|signer_name
argument_list|,
name|signer_len
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|signer_name
operator|=
name|NULL
expr_stmt|;
operator|*
name|signer_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_CNAME
condition|)
block|{
comment|/* check for the first signed cname/dname rrset */
for|for
control|(
name|i
operator|=
name|skip
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|val_find_rrset_signer
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|signer_name
argument_list|,
name|signer_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|signer_name
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DNAME
condition|)
break|break;
comment|/* only check CNAME after a DNAME */
block|}
operator|*
name|signer_name
operator|=
name|NULL
expr_stmt|;
operator|*
name|signer_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_NAMEERROR
operator|||
name|subtype
operator|==
name|VAL_CLASS_NODATA
condition|)
block|{
comment|/*Check to see if the AUTH section NSEC record(s) have rrsigs*/
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|val_find_rrset_signer
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|signer_name
argument_list|,
name|signer_len
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_CNAMENOANSWER
condition|)
block|{
comment|/* find closest superdomain signer name in authority section 		 * NSEC and NSEC3s */
name|int
name|matchcount
init|=
literal|0
decl_stmt|;
operator|*
name|signer_name
operator|=
name|NULL
expr_stmt|;
operator|*
name|signer_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|val_find_best_signer
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|qinf
argument_list|,
name|signer_name
argument_list|,
name|signer_len
argument_list|,
operator|&
name|matchcount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_REFERRAL
condition|)
block|{
comment|/* find keys for the item at skip */
if|if
condition|(
name|skip
operator|<
name|rep
operator|->
name|rrset_count
condition|)
block|{
name|val_find_rrset_signer
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|skip
index|]
argument_list|,
name|signer_name
argument_list|,
name|signer_len
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|signer_name
operator|=
name|NULL
expr_stmt|;
operator|*
name|signer_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"find_signer: could not find signer name"
literal|" for unknown type response"
argument_list|)
expr_stmt|;
operator|*
name|signer_name
operator|=
name|NULL
expr_stmt|;
operator|*
name|signer_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** return number of rrs in an rrset */
end_comment

begin_function
specifier|static
name|size_t
name|rrset_get_count
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|count
return|;
block|}
end_function

begin_comment
comment|/** return TTL of rrset */
end_comment

begin_function
specifier|static
name|uint32_t
name|rrset_get_ttl
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|ttl
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|val_verify_rrset
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|keys
parameter_list|,
name|uint8_t
modifier|*
name|sigalg
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|enum
name|sec_status
name|sec
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
block|{
comment|/* re-verify all other statuses, because keyset may change*/
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"verify rrset cached"
argument_list|,
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|security
return|;
block|}
comment|/* check in the cache if verification has already been done */
name|rrset_check_sec_status
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|rrset
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"verify rrset from cache"
argument_list|,
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|security
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"verify rrset"
argument_list|,
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|dnskeyset_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|rrset
argument_list|,
name|keys
argument_list|,
name|sigalg
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"verify result: %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
comment|/* update rrset security status  	 * only improves security status  	 * and bogus is set only once, even if we rechecked the status */
if|if
condition|(
name|sec
operator|>
name|d
operator|->
name|security
condition|)
block|{
name|d
operator|->
name|security
operator|=
name|sec
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
name|d
operator|->
name|trust
operator|=
name|rrset_trust_validated
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_bogus
condition|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* update ttl for rrset to fixed value. */
name|d
operator|->
name|ttl
operator|=
name|ve
operator|->
name|bogus_ttl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
name|d
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
name|ve
operator|->
name|bogus_ttl
expr_stmt|;
comment|/* leave RR specific TTL: not used for determine 			 * if RRset timed out and clients see proper value. */
name|lock_basic_lock
argument_list|(
operator|&
name|ve
operator|->
name|bogus_lock
argument_list|)
expr_stmt|;
name|ve
operator|->
name|num_rrset_bogus
operator|++
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ve
operator|->
name|bogus_lock
argument_list|)
expr_stmt|;
block|}
comment|/* if status updated - store in cache for reuse */
name|rrset_update_sec_status
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|rrset
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
return|return
name|sec
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|val_verify_rrset_entry
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
comment|/* temporary dnskey rrset-key */
name|struct
name|ub_packed_rrset_key
name|dnskey
decl_stmt|;
name|struct
name|key_entry_data
modifier|*
name|kd
init|=
operator|(
expr|struct
name|key_entry_data
operator|*
operator|)
name|kkey
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
name|dnskey
operator|.
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|kd
operator|->
name|rrset_type
argument_list|)
expr_stmt|;
name|dnskey
operator|.
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|kkey
operator|->
name|key_class
argument_list|)
expr_stmt|;
name|dnskey
operator|.
name|rk
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dnskey
operator|.
name|rk
operator|.
name|dname
operator|=
name|kkey
operator|->
name|name
expr_stmt|;
name|dnskey
operator|.
name|rk
operator|.
name|dname_len
operator|=
name|kkey
operator|->
name|namelen
expr_stmt|;
name|dnskey
operator|.
name|entry
operator|.
name|key
operator|=
operator|&
name|dnskey
expr_stmt|;
name|dnskey
operator|.
name|entry
operator|.
name|data
operator|=
name|kd
operator|->
name|rrset_data
expr_stmt|;
name|sec
operator|=
name|val_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|rrset
argument_list|,
operator|&
name|dnskey
argument_list|,
name|kd
operator|->
name|algo
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|sec
return|;
block|}
end_function

begin_comment
comment|/** verify that a DS RR hashes to a key and that key signs the set */
end_comment

begin_function
specifier|static
name|enum
name|sec_status
name|verify_dnskeys_with_ds_rr
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|size_t
name|ds_idx
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|enum
name|sec_status
name|sec
init|=
name|sec_status_bogus
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|num
decl_stmt|,
name|numchecked
init|=
literal|0
decl_stmt|,
name|numhashok
init|=
literal|0
decl_stmt|;
name|num
operator|=
name|rrset_get_count
argument_list|(
name|dnskey_rrset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Skip DNSKEYs that don't match the basic criteria. */
if|if
condition|(
name|ds_get_key_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
operator|!=
name|dnskey_get_algo
argument_list|(
name|dnskey_rrset
argument_list|,
name|i
argument_list|)
operator|||
name|dnskey_calc_keytag
argument_list|(
name|dnskey_rrset
argument_list|,
name|i
argument_list|)
operator|!=
name|ds_get_keytag
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|numchecked
operator|++
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"attempt DS match algo %d keytag %d"
argument_list|,
name|ds_get_key_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
argument_list|,
name|ds_get_keytag
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert the candidate DNSKEY into a hash using the  		 * same DS hash algorithm. */
if|if
condition|(
operator|!
name|ds_digest_match_dnskey
argument_list|(
name|env
argument_list|,
name|dnskey_rrset
argument_list|,
name|i
argument_list|,
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DS match attempt failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|numhashok
operator|++
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DS match digest ok, trying signature"
argument_list|)
expr_stmt|;
comment|/* Otherwise, we have a match! Make sure that the DNSKEY  		 * verifies *with this key*  */
name|sec
operator|=
name|dnskey_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|dnskey_rrset
argument_list|,
name|i
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
return|return
name|sec
return|;
block|}
comment|/* If it didn't validate with the DNSKEY, try the next one! */
block|}
if|if
condition|(
name|numchecked
operator|==
literal|0
condition|)
name|algo_needs_reason
argument_list|(
name|env
argument_list|,
name|ds_get_key_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
argument_list|,
name|reason
argument_list|,
literal|"no keys have a DS"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numhashok
operator|==
literal|0
condition|)
operator|*
name|reason
operator|=
literal|"DS hash mismatches key"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|*
name|reason
condition|)
operator|*
name|reason
operator|=
literal|"keyset not secured by DNSKEY that matches DS"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_function
name|int
name|val_favorite_ds_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|num
init|=
name|rrset_get_count
argument_list|(
name|ds_rrset
argument_list|)
decl_stmt|;
name|int
name|d
decl_stmt|,
name|digest_algo
init|=
literal|0
decl_stmt|;
comment|/* DS digest algo 0 is not used. */
comment|/* find favorite algo, for now, highest number supported */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ds_digest_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|ds_key_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|d
operator|=
name|ds_get_digest_algo
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|digest_algo
condition|)
name|digest_algo
operator|=
name|d
expr_stmt|;
block|}
return|return
name|digest_algo
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|val_verify_DNSKEY_with_DS
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|uint8_t
modifier|*
name|sigalg
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
comment|/* as long as this is false, we can consider this DS rrset to be 	 * equivalent to no DS rrset. */
name|int
name|has_useful_ds
init|=
literal|0
decl_stmt|,
name|digest_algo
decl_stmt|,
name|alg
decl_stmt|;
name|struct
name|algo_needs
name|needs
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|num
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
if|if
condition|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
operator|!=
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
operator|||
name|query_dname_compare
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DNSKEY RRset did not match DS RRset "
literal|"by name"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"DNSKEY RRset did not match DS RRset by name"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|digest_algo
operator|=
name|val_favorite_ds_algo
argument_list|(
name|ds_rrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigalg
condition|)
name|algo_needs_init_ds
argument_list|(
operator|&
name|needs
argument_list|,
name|ds_rrset
argument_list|,
name|digest_algo
argument_list|,
name|sigalg
argument_list|)
expr_stmt|;
name|num
operator|=
name|rrset_get_count
argument_list|(
name|ds_rrset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check to see if we can understand this DS.  		 * And check it is the strongest digest */
if|if
condition|(
operator|!
name|ds_digest_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|ds_key_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
operator|||
name|ds_get_digest_algo
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
operator|!=
name|digest_algo
condition|)
block|{
continue|continue;
block|}
comment|/* Once we see a single DS with a known digestID and  		 * algorithm, we cannot return INSECURE (with a  		 * "null" KeyEntry). */
name|has_useful_ds
operator|=
name|true
expr_stmt|;
name|sec
operator|=
name|verify_dnskeys_with_ds_rr
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|ds_rrset
argument_list|,
name|i
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
if|if
condition|(
operator|!
name|sigalg
operator|||
name|algo_needs_set_secure
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|ds_get_key_algo
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DS matched DNSKEY."
argument_list|)
expr_stmt|;
return|return
name|sec_status_secure
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sigalg
operator|&&
name|sec
operator|==
name|sec_status_bogus
condition|)
block|{
name|algo_needs_set_bogus
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|ds_get_key_algo
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* None of the DS's worked out. */
comment|/* If no DSs were understandable, then this is OK. */
if|if
condition|(
operator|!
name|has_useful_ds
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"No usable DS records were found -- "
literal|"treating as insecure."
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
comment|/* If any were understandable, then it is bad. */
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Failed to match any usable DS to a DNSKEY."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigalg
operator|&&
operator|(
name|alg
operator|=
name|algo_needs_missing
argument_list|(
operator|&
name|needs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|algo_needs_reason
argument_list|(
name|env
argument_list|,
name|alg
argument_list|,
name|reason
argument_list|,
literal|"missing verification of "
literal|"DNSKEY signature"
argument_list|)
expr_stmt|;
block|}
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_function
name|struct
name|key_entry_key
modifier|*
name|val_verify_new_DNSKEYs
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|int
name|downprot
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|uint8_t
name|sigalg
index|[
name|ALGO_NEEDS_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|enum
name|sec_status
name|sec
init|=
name|val_verify_DNSKEY_with_DS
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|ds_rrset
argument_list|,
name|downprot
condition|?
name|sigalg
else|:
name|NULL
argument_list|,
name|reason
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
return|return
name|key_entry_create_rrset
argument_list|(
name|region
argument_list|,
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|ds_rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|,
name|dnskey_rrset
argument_list|,
name|downprot
condition|?
name|sigalg
else|:
name|NULL
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
return|return
name|key_entry_create_null
argument_list|(
name|region
argument_list|,
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|ds_rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|,
name|rrset_get_ttl
argument_list|(
name|ds_rrset
argument_list|)
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
return|;
block|}
return|return
name|key_entry_create_bad
argument_list|(
name|region
argument_list|,
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|ds_rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|,
name|BOGUS_KEY_TTL
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|val_verify_DNSKEY_with_TA
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ta_ds
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ta_dnskey
parameter_list|,
name|uint8_t
modifier|*
name|sigalg
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
comment|/* as long as this is false, we can consider this anchor to be 	 * equivalent to no anchor. */
name|int
name|has_useful_ta
init|=
literal|0
decl_stmt|,
name|digest_algo
init|=
literal|0
decl_stmt|,
name|alg
decl_stmt|;
name|struct
name|algo_needs
name|needs
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|num
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
if|if
condition|(
name|ta_ds
operator|&&
operator|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
operator|!=
name|ta_ds
operator|->
name|rk
operator|.
name|dname_len
operator|||
name|query_dname_compare
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ta_ds
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DNSKEY RRset did not match DS RRset "
literal|"by name"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"DNSKEY RRset did not match DS RRset by name"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|ta_dnskey
operator|&&
operator|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
operator|!=
name|ta_dnskey
operator|->
name|rk
operator|.
name|dname_len
operator|||
name|query_dname_compare
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ta_dnskey
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DNSKEY RRset did not match anchor RRset "
literal|"by name"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"DNSKEY RRset did not match anchor RRset by name"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|ta_ds
condition|)
name|digest_algo
operator|=
name|val_favorite_ds_algo
argument_list|(
name|ta_ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigalg
condition|)
block|{
if|if
condition|(
name|ta_ds
condition|)
name|algo_needs_init_ds
argument_list|(
operator|&
name|needs
argument_list|,
name|ta_ds
argument_list|,
name|digest_algo
argument_list|,
name|sigalg
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|needs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|needs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta_dnskey
condition|)
name|algo_needs_init_dnskey_add
argument_list|(
operator|&
name|needs
argument_list|,
name|ta_dnskey
argument_list|,
name|sigalg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ta_ds
condition|)
block|{
name|num
operator|=
name|rrset_get_count
argument_list|(
name|ta_ds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check to see if we can understand this DS.  		 * And check it is the strongest digest */
if|if
condition|(
operator|!
name|ds_digest_algo_is_supported
argument_list|(
name|ta_ds
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|ds_key_algo_is_supported
argument_list|(
name|ta_ds
argument_list|,
name|i
argument_list|)
operator|||
name|ds_get_digest_algo
argument_list|(
name|ta_ds
argument_list|,
name|i
argument_list|)
operator|!=
name|digest_algo
condition|)
continue|continue;
comment|/* Once we see a single DS with a known digestID and  		 * algorithm, we cannot return INSECURE (with a  		 * "null" KeyEntry). */
name|has_useful_ta
operator|=
name|true
expr_stmt|;
name|sec
operator|=
name|verify_dnskeys_with_ds_rr
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|ta_ds
argument_list|,
name|i
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
if|if
condition|(
operator|!
name|sigalg
operator|||
name|algo_needs_set_secure
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|ds_get_key_algo
argument_list|(
name|ta_ds
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DS matched DNSKEY."
argument_list|)
expr_stmt|;
return|return
name|sec_status_secure
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sigalg
operator|&&
name|sec
operator|==
name|sec_status_bogus
condition|)
block|{
name|algo_needs_set_bogus
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|ds_get_key_algo
argument_list|(
name|ta_ds
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* None of the DS's worked out: check the DNSKEYs. */
if|if
condition|(
name|ta_dnskey
condition|)
block|{
name|num
operator|=
name|rrset_get_count
argument_list|(
name|ta_dnskey
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check to see if we can understand this DNSKEY */
if|if
condition|(
operator|!
name|dnskey_algo_is_supported
argument_list|(
name|ta_dnskey
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* we saw a useful TA */
name|has_useful_ta
operator|=
name|true
expr_stmt|;
name|sec
operator|=
name|dnskey_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|ta_dnskey
argument_list|,
name|i
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
if|if
condition|(
operator|!
name|sigalg
operator|||
name|algo_needs_set_secure
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|dnskey_get_algo
argument_list|(
name|ta_dnskey
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"anchor matched DNSKEY."
argument_list|)
expr_stmt|;
return|return
name|sec_status_secure
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sigalg
operator|&&
name|sec
operator|==
name|sec_status_bogus
condition|)
block|{
name|algo_needs_set_bogus
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|dnskey_get_algo
argument_list|(
name|ta_dnskey
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If no DSs were understandable, then this is OK. */
if|if
condition|(
operator|!
name|has_useful_ta
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"No usable trust anchors were found -- "
literal|"treating as insecure."
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
comment|/* If any were understandable, then it is bad. */
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Failed to match any usable anchor to a DNSKEY."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigalg
operator|&&
operator|(
name|alg
operator|=
name|algo_needs_missing
argument_list|(
operator|&
name|needs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|algo_needs_reason
argument_list|(
name|env
argument_list|,
name|alg
argument_list|,
name|reason
argument_list|,
literal|"missing verification of "
literal|"DNSKEY signature"
argument_list|)
expr_stmt|;
block|}
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_function
name|struct
name|key_entry_key
modifier|*
name|val_verify_new_DNSKEYs_with_ta
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ta_ds_rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ta_dnskey_rrset
parameter_list|,
name|int
name|downprot
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|uint8_t
name|sigalg
index|[
name|ALGO_NEEDS_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|enum
name|sec_status
name|sec
init|=
name|val_verify_DNSKEY_with_TA
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|ta_ds_rrset
argument_list|,
name|ta_dnskey_rrset
argument_list|,
name|downprot
condition|?
name|sigalg
else|:
name|NULL
argument_list|,
name|reason
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
return|return
name|key_entry_create_rrset
argument_list|(
name|region
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|,
name|dnskey_rrset
argument_list|,
name|downprot
condition|?
name|sigalg
else|:
name|NULL
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
return|return
name|key_entry_create_null
argument_list|(
name|region
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|,
name|rrset_get_ttl
argument_list|(
name|dnskey_rrset
argument_list|)
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
return|;
block|}
return|return
name|key_entry_create_bad
argument_list|(
name|region
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|,
name|BOGUS_KEY_TTL
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|val_dsset_isusable
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rrset_get_count
argument_list|(
name|ds_rrset
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ds_digest_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
operator|&&
name|ds_key_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** get label count for a signature */
end_comment

begin_function
specifier|static
name|uint8_t
name|rrsig_get_labcount
parameter_list|(
name|struct
name|packed_rrset_data
modifier|*
name|d
parameter_list|,
name|size_t
name|sig
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|sig
index|]
operator|<
literal|2
operator|+
literal|4
condition|)
return|return
literal|0
return|;
comment|/* bad sig length */
return|return
name|d
operator|->
name|rr_data
index|[
name|sig
index|]
index|[
literal|2
operator|+
literal|3
index|]
return|;
block|}
end_function

begin_function
name|int
name|val_rrset_wildcard
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|uint8_t
name|labcount
decl_stmt|;
name|int
name|labdiff
decl_stmt|;
name|uint8_t
modifier|*
name|wn
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|wl
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|rrsig_count
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
name|labcount
operator|=
name|rrsig_get_labcount
argument_list|(
name|d
argument_list|,
name|d
operator|->
name|count
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* check rest of signatures identical */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|d
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|labcount
operator|!=
name|rrsig_get_labcount
argument_list|(
name|d
argument_list|,
name|d
operator|->
name|count
operator|+
name|i
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* OK the rrsigs check out */
comment|/* if the RRSIG label count is shorter than the number of actual  	 * labels, then this rrset was synthesized from a wildcard. 	 * Note that the RRSIG label count doesn't count the root label. */
name|wn
operator|=
name|rrset
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|wl
operator|=
name|rrset
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
comment|/* skip a leading wildcard label in the dname (RFC4035 2.2) */
if|if
condition|(
name|dname_is_wild
argument_list|(
name|wn
argument_list|)
condition|)
block|{
name|wn
operator|+=
literal|2
expr_stmt|;
name|wl
operator|-=
literal|2
expr_stmt|;
block|}
name|labdiff
operator|=
operator|(
name|dname_count_labels
argument_list|(
name|wn
argument_list|)
operator|-
literal|1
operator|)
operator|-
operator|(
name|int
operator|)
name|labcount
expr_stmt|;
if|if
condition|(
name|labdiff
operator|>
literal|0
condition|)
block|{
operator|*
name|wc
operator|=
name|wn
expr_stmt|;
name|dname_remove_labels
argument_list|(
name|wc
argument_list|,
operator|&
name|wl
argument_list|,
name|labdiff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|val_chase_cname
parameter_list|(
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|size_t
modifier|*
name|cname_skip
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* skip any DNAMEs, go to the CNAME for next part */
for|for
control|(
name|i
operator|=
operator|*
name|cname_skip
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|query_dname_compare
argument_list|(
name|qchase
operator|->
name|qname
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qchase
operator|->
name|qname
operator|=
name|NULL
expr_stmt|;
name|get_cname_target
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
operator|&
name|qchase
operator|->
name|qname
argument_list|,
operator|&
name|qchase
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qchase
operator|->
name|qname
condition|)
return|return
literal|0
return|;
comment|/* bad CNAME rdata */
operator|(
operator|*
name|cname_skip
operator|)
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* CNAME classified but no matching CNAME ?! */
block|}
end_function

begin_comment
comment|/** see if rrset has signer name as one of the rrsig signers */
end_comment

begin_function
specifier|static
name|int
name|rrset_has_signer
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|count
init|;
name|i
operator|<
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|>
literal|2
operator|+
literal|18
operator|+
name|len
condition|)
block|{
comment|/* at least rdatalen + signature + signame (+1 sig)*/
if|if
condition|(
name|query_dname_compare
argument_list|(
name|name
argument_list|,
name|d
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
operator|+
literal|18
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|val_fill_reply
parameter_list|(
name|struct
name|reply_info
modifier|*
name|chase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|orig
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint8_t
modifier|*
name|signer
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|seen_dname
init|=
literal|0
decl_stmt|;
name|chase
operator|->
name|rrset_count
operator|=
literal|0
expr_stmt|;
name|chase
operator|->
name|an_numrrsets
operator|=
literal|0
expr_stmt|;
name|chase
operator|->
name|ns_numrrsets
operator|=
literal|0
expr_stmt|;
name|chase
operator|->
name|ar_numrrsets
operator|=
literal|0
expr_stmt|;
comment|/* ANSWER section */
for|for
control|(
name|i
operator|=
name|skip
init|;
name|i
operator|<
name|orig
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|signer
condition|)
block|{
if|if
condition|(
name|query_dname_compare
argument_list|(
name|name
argument_list|,
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
name|chase
operator|->
name|rrsets
index|[
name|chase
operator|->
name|an_numrrsets
operator|++
index|]
operator|=
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_dname
operator|&&
name|ntohs
argument_list|(
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
name|chase
operator|->
name|rrsets
index|[
name|chase
operator|->
name|an_numrrsets
operator|++
index|]
operator|=
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|seen_dname
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rrset_has_signer
argument_list|(
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|chase
operator|->
name|rrsets
index|[
name|chase
operator|->
name|an_numrrsets
operator|++
index|]
operator|=
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNAME
condition|)
block|{
name|seen_dname
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* AUTHORITY section */
for|for
control|(
name|i
operator|=
operator|(
name|skip
operator|>
name|orig
operator|->
name|an_numrrsets
operator|)
condition|?
name|skip
else|:
name|orig
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|orig
operator|->
name|an_numrrsets
operator|+
name|orig
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|signer
condition|)
block|{
if|if
condition|(
name|query_dname_compare
argument_list|(
name|name
argument_list|,
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
name|chase
operator|->
name|rrsets
index|[
name|chase
operator|->
name|an_numrrsets
operator|+
name|chase
operator|->
name|ns_numrrsets
operator|++
index|]
operator|=
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rrset_has_signer
argument_list|(
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|chase
operator|->
name|rrsets
index|[
name|chase
operator|->
name|an_numrrsets
operator|+
name|chase
operator|->
name|ns_numrrsets
operator|++
index|]
operator|=
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* ADDITIONAL section */
for|for
control|(
name|i
operator|=
operator|(
name|skip
operator|>
name|orig
operator|->
name|an_numrrsets
operator|+
name|orig
operator|->
name|ns_numrrsets
operator|)
condition|?
name|skip
else|:
name|orig
operator|->
name|an_numrrsets
operator|+
name|orig
operator|->
name|ns_numrrsets
init|;
name|i
operator|<
name|orig
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|signer
condition|)
block|{
if|if
condition|(
name|query_dname_compare
argument_list|(
name|name
argument_list|,
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
name|chase
operator|->
name|rrsets
index|[
name|chase
operator|->
name|an_numrrsets
operator|+
name|orig
operator|->
name|ns_numrrsets
operator|+
name|chase
operator|->
name|ar_numrrsets
operator|++
index|]
operator|=
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rrset_has_signer
argument_list|(
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|chase
operator|->
name|rrsets
index|[
name|chase
operator|->
name|an_numrrsets
operator|+
name|orig
operator|->
name|ns_numrrsets
operator|+
name|chase
operator|->
name|ar_numrrsets
operator|++
index|]
operator|=
name|orig
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|chase
operator|->
name|rrset_count
operator|=
name|chase
operator|->
name|an_numrrsets
operator|+
name|chase
operator|->
name|ns_numrrsets
operator|+
name|chase
operator|->
name|ar_numrrsets
expr_stmt|;
block|}
end_function

begin_function
name|void
name|val_check_nonsecure
parameter_list|(
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* authority */
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
block|{
comment|/* because we want to return the authentic original 			 * message when presented with CD-flagged queries, 			 * we need to preserve AUTHORITY section data. 			 * However, this rrset is not signed or signed 			 * with the wrong keys. Validation has tried to 			 * verify this rrset with the keysets of import. 			 * But this rrset did not verify. 			 * Therefore the message is bogus. 			 */
comment|/* check if authority consists of only an NS record 			 * which is bad, and there is an answer section with 			 * data.  In that case, delete NS and additional to  			 * be lenient and make a minimal response */
if|if
condition|(
name|rep
operator|->
name|an_numrrsets
operator|!=
literal|0
operator|&&
name|rep
operator|->
name|ns_numrrsets
operator|==
literal|1
operator|&&
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"truncate to minimal"
argument_list|)
expr_stmt|;
name|rep
operator|->
name|ns_numrrsets
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|ar_numrrsets
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|rrset_count
operator|=
name|rep
operator|->
name|an_numrrsets
expr_stmt|;
return|return;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"message is bogus, "
literal|"non secure rrset"
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
block|}
comment|/* additional */
if|if
condition|(
operator|!
name|ve
operator|->
name|clean_additional
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
block|{
comment|/* This does not cause message invalidation. It was 			 * simply unsigned data in the additional. The 			 * RRSIG must have been truncated off the message. 			 * 			 * However, we do not want to return possible bogus 			 * data to clients that rely on this service for 			 * their authentication. 			 */
comment|/* remove this unneeded additional rrset */
name|memmove
argument_list|(
name|rep
operator|->
name|rrsets
operator|+
name|i
argument_list|,
name|rep
operator|->
name|rrsets
operator|+
name|i
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
operator|(
name|rep
operator|->
name|rrset_count
operator|-
name|i
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|ar_numrrsets
operator|--
expr_stmt|;
name|rep
operator|->
name|rrset_count
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** check no anchor and unlock */
end_comment

begin_function
specifier|static
name|int
name|check_no_anchor
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|l
parameter_list|,
name|uint16_t
name|c
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
if|if
condition|(
operator|(
name|ta
operator|=
name|anchors_lookup
argument_list|(
name|anchors
argument_list|,
name|nm
argument_list|,
name|l
argument_list|,
name|c
argument_list|)
operator|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|ta
return|;
block|}
end_function

begin_function
name|void
name|val_mark_indeterminate
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_unchecked
operator|&&
name|check_no_anchor
argument_list|(
name|anchors
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
condition|)
block|{
comment|/* mark as indeterminate */
name|d
operator|->
name|security
operator|=
name|sec_status_indeterminate
expr_stmt|;
name|rrset_update_sec_status
argument_list|(
name|r
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|val_mark_insecure
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint8_t
modifier|*
name|kname
parameter_list|,
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_unchecked
operator|&&
name|dname_subdomain_c
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|kname
argument_list|)
condition|)
block|{
comment|/* mark as insecure */
name|d
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
name|rrset_update_sec_status
argument_list|(
name|r
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|size_t
name|val_next_unchecked
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|size_t
name|skip
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
name|skip
operator|+
literal|1
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_unchecked
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
name|rep
operator|->
name|rrset_count
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|val_classification_to_string
parameter_list|(
name|enum
name|val_classification
name|subtype
parameter_list|)
block|{
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|VAL_CLASS_UNTYPED
case|:
return|return
literal|"untyped"
return|;
case|case
name|VAL_CLASS_UNKNOWN
case|:
return|return
literal|"unknown"
return|;
case|case
name|VAL_CLASS_POSITIVE
case|:
return|return
literal|"positive"
return|;
case|case
name|VAL_CLASS_CNAME
case|:
return|return
literal|"cname"
return|;
case|case
name|VAL_CLASS_NODATA
case|:
return|return
literal|"nodata"
return|;
case|case
name|VAL_CLASS_NAMEERROR
case|:
return|return
literal|"nameerror"
return|;
case|case
name|VAL_CLASS_CNAMENOANSWER
case|:
return|return
literal|"cnamenoanswer"
return|;
case|case
name|VAL_CLASS_REFERRAL
case|:
return|return
literal|"referral"
return|;
case|case
name|VAL_CLASS_ANY
case|:
return|return
literal|"qtype_any"
return|;
default|default:
return|return
literal|"bad_val_classification"
return|;
block|}
block|}
end_function

begin_comment
comment|/** log a sock_list entry */
end_comment

begin_function
specifier|static
name|void
name|sock_list_logentry
parameter_list|(
name|enum
name|verbosity_value
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|sock_list
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|len
condition|)
name|log_addr
argument_list|(
name|v
argument_list|,
name|s
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
name|v
argument_list|,
literal|"%s cache"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|val_blacklist
parameter_list|(
name|struct
name|sock_list
modifier|*
modifier|*
name|blacklist
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|sock_list
modifier|*
name|origin
parameter_list|,
name|int
name|cross
parameter_list|)
block|{
comment|/* debug printout */
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
block|{
name|struct
name|sock_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|blacklist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|sock_list_logentry
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"blacklist"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origin
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"blacklist add: cache"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|origin
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|sock_list_logentry
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"blacklist add"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* blacklist the IPs or the cache */
if|if
condition|(
operator|!
name|origin
condition|)
block|{
comment|/* only add if nothing there. anything else also stops cache*/
if|if
condition|(
operator|!
operator|*
name|blacklist
condition|)
name|sock_list_insert
argument_list|(
name|blacklist
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cross
condition|)
name|sock_list_prepend
argument_list|(
name|blacklist
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
name|sock_list_merge
argument_list|(
name|blacklist
argument_list|,
name|region
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|val_has_signed_nsecs
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|num_nsec
init|=
literal|0
decl_stmt|,
name|num_nsec3
init|=
literal|0
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_NSEC
argument_list|)
condition|)
name|num_nsec
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_NSEC3
argument_list|)
condition|)
name|num_nsec3
operator|++
expr_stmt|;
else|else
continue|continue;
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|rrsig_count
operator|!=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|num_nsec
operator|==
literal|0
operator|&&
name|num_nsec3
operator|==
literal|0
condition|)
operator|*
name|reason
operator|=
literal|"no DNSSEC records"
expr_stmt|;
elseif|else
if|if
condition|(
name|num_nsec
operator|!=
literal|0
condition|)
operator|*
name|reason
operator|=
literal|"no signatures over NSECs"
expr_stmt|;
else|else
operator|*
name|reason
operator|=
literal|"no signatures over NSEC3s"
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|dns_msg
modifier|*
name|val_find_DS
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|uint8_t
modifier|*
name|topname
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
init|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rrset
condition|)
block|{
comment|/* DS rrset exists. Return it to the validator immediately*/
name|struct
name|ub_packed_rrset_key
modifier|*
name|copy
init|=
name|packed_rrset_copy_region
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
decl_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy
condition|)
return|return
name|NULL
return|;
name|msg
operator|=
name|dns_msg_create
argument_list|(
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|c
argument_list|,
name|region
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|=
name|copy
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|++
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|++
expr_stmt|;
return|return
name|msg
return|;
block|}
comment|/* lookup in rrset and negative cache for NSEC/NSEC3 */
name|qinfo
operator|.
name|qname
operator|=
name|nm
expr_stmt|;
name|qinfo
operator|.
name|qname_len
operator|=
name|nmlen
expr_stmt|;
name|qinfo
operator|.
name|qtype
operator|=
name|LDNS_RR_TYPE_DS
expr_stmt|;
name|qinfo
operator|.
name|qclass
operator|=
name|c
expr_stmt|;
comment|/* do not add SOA to reply message, it is going to be used internal */
name|msg
operator|=
name|val_neg_getmsg
argument_list|(
name|env
operator|->
name|neg_cache
argument_list|,
operator|&
name|qinfo
argument_list|,
name|region
argument_list|,
name|env
operator|->
name|rrset_cache
argument_list|,
name|env
operator|->
name|scratch_buffer
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
literal|0
argument_list|,
name|topname
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

end_unit

