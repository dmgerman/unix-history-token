begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_nsec3.c - validator NSEC3 denial of existance functions.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains helper functions for the validator module.  * The functions help with NSEC3 checking, the different NSEC3 proofs  * for denial of existance, and proofs for presence of types.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_SSL_H
end_ifdef

begin_include
include|#
directive|include
file|"openssl/ssl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSS
end_ifdef

begin_comment
comment|/* nss3 */
end_comment

begin_include
include|#
directive|include
file|"sechash.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"validator/val_nsec3.h"
end_include

begin_include
include|#
directive|include
file|"validator/validator.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kentry.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/rbtree.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_comment
comment|/* we include nsec.h for the bitmap_has_type function */
end_comment

begin_include
include|#
directive|include
file|"validator/val_nsec.h"
end_include

begin_comment
comment|/**   * This function we get from ldns-compat or from base system   * it returns the number of data bytes stored at the target, or<0 on error.  */
end_comment

begin_function_decl
name|int
name|ldns_b32_ntop_extended_hex
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**   * This function we get from ldns-compat or from base system   * it returns the number of data bytes stored at the target, or<0 on error.  */
end_comment

begin_function_decl
name|int
name|ldns_b32_pton_extended_hex
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Closest encloser (ce) proof results  * Contains the ce and the next-closer (nc) proof.  */
end_comment

begin_struct
struct|struct
name|ce_response
block|{
comment|/** the closest encloser name */
name|uint8_t
modifier|*
name|ce
decl_stmt|;
comment|/** length of ce */
name|size_t
name|ce_len
decl_stmt|;
comment|/** NSEC3 record that proved ce. rrset */
name|struct
name|ub_packed_rrset_key
modifier|*
name|ce_rrset
decl_stmt|;
comment|/** NSEC3 record that proved ce. rr number */
name|int
name|ce_rr
decl_stmt|;
comment|/** NSEC3 record that proved nc. rrset */
name|struct
name|ub_packed_rrset_key
modifier|*
name|nc_rrset
decl_stmt|;
comment|/** NSEC3 record that proved nc. rr*/
name|int
name|nc_rr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Filter conditions for NSEC3 proof  * Used to iterate over the applicable NSEC3 RRs.  */
end_comment

begin_struct
struct|struct
name|nsec3_filter
block|{
comment|/** Zone name, only NSEC3 records for this zone are considered */
name|uint8_t
modifier|*
name|zone
decl_stmt|;
comment|/** length of the zonename */
name|size_t
name|zone_len
decl_stmt|;
comment|/** the list of NSEC3s to filter; array */
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
decl_stmt|;
comment|/** number of rrsets in list */
name|size_t
name|num
decl_stmt|;
comment|/** class of records for the NSEC3, only this class applies */
name|uint16_t
name|fclass
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** return number of rrs in an rrset */
end_comment

begin_function
specifier|static
name|size_t
name|rrset_get_count
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|count
return|;
block|}
end_function

begin_comment
comment|/** return if nsec3 RR has unknown flags */
end_comment

begin_function
specifier|static
name|int
name|nsec3_unknown_flags
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|2
condition|)
return|return
literal|0
return|;
comment|/* malformed */
return|return
call|(
name|int
call|)
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
literal|2
operator|+
literal|1
index|]
operator|&
name|NSEC3_UNKNOWN_FLAGS
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|nsec3_has_optout
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|2
condition|)
return|return
literal|0
return|;
comment|/* malformed */
return|return
call|(
name|int
call|)
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
literal|2
operator|+
literal|1
index|]
operator|&
name|NSEC3_OPTOUT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** return nsec3 RR algorithm */
end_comment

begin_function
specifier|static
name|int
name|nsec3_get_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* malformed */
return|return
call|(
name|int
call|)
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
literal|2
operator|+
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** return if nsec3 RR has known algorithm */
end_comment

begin_function
specifier|static
name|int
name|nsec3_known_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* malformed */
switch|switch
condition|(
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
literal|2
operator|+
literal|0
index|]
condition|)
block|{
case|case
name|NSEC3_HASH_SHA1
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** return nsec3 RR iteration count */
end_comment

begin_function
specifier|static
name|size_t
name|nsec3_get_iter
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|4
condition|)
return|return
literal|0
return|;
comment|/* malformed */
name|memmove
argument_list|(
operator|&
name|i
argument_list|,
name|d
operator|->
name|rr_data
index|[
name|r
index|]
operator|+
literal|2
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|ntohs
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|i
return|;
block|}
end_function

begin_comment
comment|/** return nsec3 RR salt */
end_comment

begin_function
specifier|static
name|int
name|nsec3_get_salt
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|salt
parameter_list|,
name|size_t
modifier|*
name|saltlen
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|5
condition|)
block|{
operator|*
name|salt
operator|=
literal|0
expr_stmt|;
operator|*
name|saltlen
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* malformed */
block|}
operator|*
name|saltlen
operator|=
operator|(
name|size_t
operator|)
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
literal|2
operator|+
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|5
operator|+
operator|(
name|size_t
operator|)
operator|*
name|saltlen
condition|)
block|{
operator|*
name|salt
operator|=
literal|0
expr_stmt|;
operator|*
name|saltlen
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* malformed */
block|}
operator|*
name|salt
operator|=
name|d
operator|->
name|rr_data
index|[
name|r
index|]
operator|+
literal|2
operator|+
literal|5
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|nsec3_get_params
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|,
name|int
modifier|*
name|algo
parameter_list|,
name|size_t
modifier|*
name|iter
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|salt
parameter_list|,
name|size_t
modifier|*
name|saltlen
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nsec3_known_algo
argument_list|(
name|rrset
argument_list|,
name|r
argument_list|)
operator|||
name|nsec3_unknown_flags
argument_list|(
name|rrset
argument_list|,
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|nsec3_get_salt
argument_list|(
name|rrset
argument_list|,
name|r
argument_list|,
name|salt
argument_list|,
name|saltlen
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|algo
operator|=
name|nsec3_get_algo
argument_list|(
name|rrset
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|iter
operator|=
name|nsec3_get_iter
argument_list|(
name|rrset
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|nsec3_get_nextowner
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|next
parameter_list|,
name|size_t
modifier|*
name|nextlen
parameter_list|)
block|{
name|size_t
name|saltlen
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|5
condition|)
block|{
operator|*
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|nextlen
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* malformed */
block|}
name|saltlen
operator|=
operator|(
name|size_t
operator|)
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
literal|2
operator|+
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|5
operator|+
name|saltlen
operator|+
literal|1
condition|)
block|{
operator|*
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|nextlen
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* malformed */
block|}
operator|*
name|nextlen
operator|=
operator|(
name|size_t
operator|)
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
literal|2
operator|+
literal|5
operator|+
name|saltlen
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
literal|2
operator|+
literal|5
operator|+
name|saltlen
operator|+
literal|1
operator|+
operator|*
name|nextlen
condition|)
block|{
operator|*
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|nextlen
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* malformed */
block|}
operator|*
name|next
operator|=
name|d
operator|->
name|rr_data
index|[
name|r
index|]
operator|+
literal|2
operator|+
literal|5
operator|+
name|saltlen
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|size_t
name|nsec3_hash_to_b32
parameter_list|(
name|uint8_t
modifier|*
name|hash
parameter_list|,
name|size_t
name|hashlen
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|size_t
name|zonelen
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|max
parameter_list|)
block|{
comment|/* write b32 of name, leave one for length */
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|max
operator|<
name|hashlen
operator|*
literal|2
operator|+
literal|1
condition|)
comment|/* quick approx of b32, as if hexb16 */
return|return
literal|0
return|;
name|ret
operator|=
name|ldns_b32_ntop_extended_hex
argument_list|(
name|hash
argument_list|,
name|hashlen
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
literal|1
argument_list|,
name|max
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|1
condition|)
return|return
literal|0
return|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|ret
expr_stmt|;
comment|/* length of b32 label */
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|max
operator|-
name|ret
operator|<
name|zonelen
condition|)
return|return
literal|0
return|;
name|memmove
argument_list|(
name|buf
operator|+
name|ret
argument_list|,
name|zone
argument_list|,
name|zonelen
argument_list|)
expr_stmt|;
return|return
name|zonelen
operator|+
operator|(
name|size_t
operator|)
name|ret
return|;
block|}
end_function

begin_function
name|size_t
name|nsec3_get_nextowner_b32
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|max
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|,
modifier|*
name|zone
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|,
name|zonelen
decl_stmt|;
if|if
condition|(
operator|!
name|nsec3_get_nextowner
argument_list|(
name|rrset
argument_list|,
name|r
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* append zone name; the owner name must be<b32>.zone */
name|zone
operator|=
name|rrset
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|zonelen
operator|=
name|rrset
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|zone
argument_list|,
operator|&
name|zonelen
argument_list|)
expr_stmt|;
return|return
name|nsec3_hash_to_b32
argument_list|(
name|nm
argument_list|,
name|nmlen
argument_list|,
name|zone
argument_list|,
name|zonelen
argument_list|,
name|buf
argument_list|,
name|max
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|nsec3_has_type
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|r
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|uint8_t
modifier|*
name|bitmap
decl_stmt|;
name|size_t
name|bitlen
decl_stmt|,
name|skiplen
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|r
operator|<
operator|(
name|int
operator|)
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
name|skiplen
operator|=
literal|2
operator|+
literal|4
expr_stmt|;
comment|/* skip salt */
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
name|skiplen
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* malformed, too short */
name|skiplen
operator|+=
literal|1
operator|+
operator|(
name|size_t
operator|)
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
name|skiplen
index|]
expr_stmt|;
comment|/* skip next hashed owner */
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
name|skiplen
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* malformed, too short */
name|skiplen
operator|+=
literal|1
operator|+
operator|(
name|size_t
operator|)
name|d
operator|->
name|rr_data
index|[
name|r
index|]
index|[
name|skiplen
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|<
name|skiplen
condition|)
return|return
literal|0
return|;
comment|/* malformed, too short */
name|bitlen
operator|=
name|d
operator|->
name|rr_len
index|[
name|r
index|]
operator|-
name|skiplen
expr_stmt|;
name|bitmap
operator|=
name|d
operator|->
name|rr_data
index|[
name|r
index|]
operator|+
name|skiplen
expr_stmt|;
return|return
name|nsecbitmap_has_type_rdata
argument_list|(
name|bitmap
argument_list|,
name|bitlen
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   * Iterate through NSEC3 list, per RR   * This routine gives the next RR in the list (or sets rrset null).   * Usage:  *  * size_t rrsetnum;  * int rrnum;  * struct ub_packed_rrset_key* rrset;  * for(rrset=filter_first(filter,&rrsetnum,&rrnum); rrset;   *	rrset=filter_next(filter,&rrsetnum,&rrnum))  *		do_stuff;  *   * Also filters out   * 	o unknown flag NSEC3s  * 	o unknown algorithm NSEC3s.  * @param filter: nsec3 filter structure.  * @param rrsetnum: in/out rrset number to look at.  * @param rrnum: in/out rr number in rrset to look at.  * @returns ptr to the next rrset (or NULL at end).  */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|filter_next
parameter_list|(
name|struct
name|nsec3_filter
modifier|*
name|filter
parameter_list|,
name|size_t
modifier|*
name|rrsetnum
parameter_list|,
name|int
modifier|*
name|rrnum
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
if|if
condition|(
operator|!
name|filter
operator|->
name|zone
condition|)
comment|/* empty list */
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
operator|*
name|rrsetnum
init|;
name|i
operator|<
name|filter
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* see if RRset qualifies */
if|if
condition|(
name|ntohs
argument_list|(
name|filter
operator|->
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NSEC3
operator|||
name|ntohs
argument_list|(
name|filter
operator|->
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|!=
name|filter
operator|->
name|fclass
condition|)
continue|continue;
comment|/* check RRset zone */
name|nm
operator|=
name|filter
operator|->
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|nmlen
operator|=
name|filter
operator|->
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|nm
argument_list|,
name|filter
operator|->
name|zone
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
operator|*
name|rrsetnum
condition|)
name|r
operator|=
operator|(
operator|*
name|rrnum
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* continue at next RR */
else|else
name|r
operator|=
literal|0
expr_stmt|;
comment|/* new RRset start at first RR */
for|for
control|(
init|;
name|r
operator|<
operator|(
name|int
operator|)
name|rrset_get_count
argument_list|(
name|filter
operator|->
name|list
index|[
name|i
index|]
argument_list|)
condition|;
name|r
operator|++
control|)
block|{
comment|/* skip unknown flags, algo */
if|if
condition|(
name|nsec3_unknown_flags
argument_list|(
name|filter
operator|->
name|list
index|[
name|i
index|]
argument_list|,
name|r
argument_list|)
operator|||
operator|!
name|nsec3_known_algo
argument_list|(
name|filter
operator|->
name|list
index|[
name|i
index|]
argument_list|,
name|r
argument_list|)
condition|)
continue|continue;
comment|/* this one is a good target */
operator|*
name|rrsetnum
operator|=
name|i
expr_stmt|;
operator|*
name|rrnum
operator|=
name|r
expr_stmt|;
return|return
name|filter
operator|->
name|list
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Start iterating over NSEC3 records.  * @param filter: the filter structure, must have been filter_init-ed.  * @param rrsetnum: can be undefined on call, inited.  * @param rrnum: can be undefined on call, inited.  * @return first rrset of an NSEC3, together with rrnum this points to  *	the first RR to examine. Is NULL on empty list.  */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|filter_first
parameter_list|(
name|struct
name|nsec3_filter
modifier|*
name|filter
parameter_list|,
name|size_t
modifier|*
name|rrsetnum
parameter_list|,
name|int
modifier|*
name|rrnum
parameter_list|)
block|{
operator|*
name|rrsetnum
operator|=
literal|0
expr_stmt|;
operator|*
name|rrnum
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|filter_next
argument_list|(
name|filter
argument_list|,
name|rrsetnum
argument_list|,
name|rrnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** see if at least one RR is known (flags, algo) */
end_comment

begin_function
specifier|static
name|int
name|nsec3_rrset_has_known
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
operator|(
name|int
operator|)
name|rrset_get_count
argument_list|(
name|s
argument_list|)
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nsec3_unknown_flags
argument_list|(
name|s
argument_list|,
name|r
argument_list|)
operator|&&
name|nsec3_known_algo
argument_list|(
name|s
argument_list|,
name|r
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * Initialize the filter structure.  * Finds the zone by looking at available NSEC3 records and best match.  * 	(skips the unknown flag and unknown algo NSEC3s).  *  * @param filter: nsec3 filter structure.  * @param list: list of rrsets, an array of them.  * @param num: number of rrsets in list.  * @param qinfo:   *	query name to match a zone for.  *	query type (if DS a higher zone must be chosen)  *	qclass, to filter NSEC3s with.  */
end_comment

begin_function
specifier|static
name|void
name|filter_init
parameter_list|(
name|struct
name|nsec3_filter
modifier|*
name|filter
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|num
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|filter
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|filter
operator|->
name|zone_len
operator|=
literal|0
expr_stmt|;
name|filter
operator|->
name|list
operator|=
name|list
expr_stmt|;
name|filter
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|filter
operator|->
name|fclass
operator|=
name|qinfo
operator|->
name|qclass
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* ignore other stuff in the list */
if|if
condition|(
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NSEC3
operator|||
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|!=
name|qinfo
operator|->
name|qclass
condition|)
continue|continue;
comment|/* skip unknown flags, algo */
if|if
condition|(
operator|!
name|nsec3_rrset_has_known
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
comment|/* since NSEC3s are base32.zonename, we can find the zone 		 * name by stripping off the first label of the record */
name|nm
operator|=
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|nmlen
operator|=
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
expr_stmt|;
comment|/* if we find a domain that can prove about the qname, 		 * and if this domain is closer to the qname */
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|nm
argument_list|)
operator|&&
operator|(
operator|!
name|filter
operator|->
name|zone
operator|||
name|dname_subdomain_c
argument_list|(
name|nm
argument_list|,
name|filter
operator|->
name|zone
argument_list|)
operator|)
condition|)
block|{
comment|/* for a type DS do not accept a zone equal to qname*/
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
name|query_dname_compare
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|dname_is_root
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|)
condition|)
continue|continue;
name|filter
operator|->
name|zone
operator|=
name|nm
expr_stmt|;
name|filter
operator|->
name|zone_len
operator|=
name|nmlen
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Find max iteration count using config settings and key size  * @param ve: validator environment with iteration count config settings.  * @param bits: key size  * @return max iteration count  */
end_comment

begin_function
specifier|static
name|size_t
name|get_max_iter
parameter_list|(
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|size_t
name|bits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|log_assert
argument_list|(
name|ve
operator|->
name|nsec3_keyiter_count
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* round up to nearest config keysize, linear search, keep it small */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ve
operator|->
name|nsec3_keyiter_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bits
operator|<=
name|ve
operator|->
name|nsec3_keysize
index|[
name|i
index|]
condition|)
return|return
name|ve
operator|->
name|nsec3_maxiter
index|[
name|i
index|]
return|;
block|}
comment|/* else, use value for biggest key */
return|return
name|ve
operator|->
name|nsec3_maxiter
index|[
name|ve
operator|->
name|nsec3_keyiter_count
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/**   * Determine if any of the NSEC3 rrs iteration count is too high, from key.  * @param ve: validator environment with iteration count config settings.  * @param filter: what NSEC3s to loop over.  * @param kkey: key entry used for verification; used for iteration counts.  * @return 1 if some nsec3s are above the max iteration count.  */
end_comment

begin_function
specifier|static
name|int
name|nsec3_iteration_count_high
parameter_list|(
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|nsec3_filter
modifier|*
name|filter
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
name|size_t
name|rrsetnum
decl_stmt|;
name|int
name|rrnum
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
comment|/* first determine the max number of iterations */
name|size_t
name|bits
init|=
name|key_entry_keysize
argument_list|(
name|kkey
argument_list|)
decl_stmt|;
name|size_t
name|max_iter
init|=
name|get_max_iter
argument_list|(
name|ve
argument_list|,
name|bits
argument_list|)
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3: keysize %d bits, max iterations %d"
argument_list|,
operator|(
name|int
operator|)
name|bits
argument_list|,
operator|(
name|int
operator|)
name|max_iter
argument_list|)
expr_stmt|;
for|for
control|(
name|rrset
operator|=
name|filter_first
argument_list|(
name|filter
argument_list|,
operator|&
name|rrsetnum
argument_list|,
operator|&
name|rrnum
argument_list|)
init|;
name|rrset
condition|;
name|rrset
operator|=
name|filter_next
argument_list|(
name|filter
argument_list|,
operator|&
name|rrsetnum
argument_list|,
operator|&
name|rrnum
argument_list|)
control|)
block|{
if|if
condition|(
name|nsec3_get_iter
argument_list|(
name|rrset
argument_list|,
name|rrnum
argument_list|)
operator|>
name|max_iter
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* nsec3_cache_compare for rbtree */
end_comment

begin_function
name|int
name|nsec3_hash_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|c1
parameter_list|,
specifier|const
name|void
modifier|*
name|c2
parameter_list|)
block|{
name|struct
name|nsec3_cached_hash
modifier|*
name|h1
init|=
operator|(
expr|struct
name|nsec3_cached_hash
operator|*
operator|)
name|c1
decl_stmt|;
name|struct
name|nsec3_cached_hash
modifier|*
name|h2
init|=
operator|(
expr|struct
name|nsec3_cached_hash
operator|*
operator|)
name|c2
decl_stmt|;
name|uint8_t
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|size_t
name|s1len
decl_stmt|,
name|s2len
decl_stmt|;
name|int
name|c
init|=
name|query_dname_compare
argument_list|(
name|h1
operator|->
name|dname
argument_list|,
name|h2
operator|->
name|dname
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
comment|/* compare parameters */
comment|/* if both malformed, its equal, robustness */
if|if
condition|(
name|nsec3_get_algo
argument_list|(
name|h1
operator|->
name|nsec3
argument_list|,
name|h1
operator|->
name|rr
argument_list|)
operator|!=
name|nsec3_get_algo
argument_list|(
name|h2
operator|->
name|nsec3
argument_list|,
name|h2
operator|->
name|rr
argument_list|)
condition|)
block|{
if|if
condition|(
name|nsec3_get_algo
argument_list|(
name|h1
operator|->
name|nsec3
argument_list|,
name|h1
operator|->
name|rr
argument_list|)
operator|<
name|nsec3_get_algo
argument_list|(
name|h2
operator|->
name|nsec3
argument_list|,
name|h2
operator|->
name|rr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nsec3_get_iter
argument_list|(
name|h1
operator|->
name|nsec3
argument_list|,
name|h1
operator|->
name|rr
argument_list|)
operator|!=
name|nsec3_get_iter
argument_list|(
name|h2
operator|->
name|nsec3
argument_list|,
name|h2
operator|->
name|rr
argument_list|)
condition|)
block|{
if|if
condition|(
name|nsec3_get_iter
argument_list|(
name|h1
operator|->
name|nsec3
argument_list|,
name|h1
operator|->
name|rr
argument_list|)
operator|<
name|nsec3_get_iter
argument_list|(
name|h2
operator|->
name|nsec3
argument_list|,
name|h2
operator|->
name|rr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|nsec3_get_salt
argument_list|(
name|h1
operator|->
name|nsec3
argument_list|,
name|h1
operator|->
name|rr
argument_list|,
operator|&
name|s1
argument_list|,
operator|&
name|s1len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nsec3_get_salt
argument_list|(
name|h2
operator|->
name|nsec3
argument_list|,
name|h2
operator|->
name|rr
argument_list|,
operator|&
name|s2
argument_list|,
operator|&
name|s2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1len
operator|!=
name|s2len
condition|)
block|{
if|if
condition|(
name|s1len
operator|<
name|s2len
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
return|return
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s1len
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|nsec3_get_hashed
parameter_list|(
name|ldns_buffer
modifier|*
name|buf
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|int
name|algo
parameter_list|,
name|size_t
name|iter
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|,
name|size_t
name|saltlen
parameter_list|,
name|uint8_t
modifier|*
name|res
parameter_list|,
name|size_t
name|max
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|hash_len
decl_stmt|;
comment|/* prepare buffer for first iteration */
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|salt
argument_list|,
name|saltlen
argument_list|)
expr_stmt|;
name|ldns_buffer_flip
argument_list|(
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|algo
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA1
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
case|case
name|NSEC3_HASH_SHA1
case|:
ifdef|#
directive|ifdef
name|HAVE_SSL
name|hash_len
operator|=
name|SHA_DIGEST_LENGTH
expr_stmt|;
else|#
directive|else
name|hash_len
operator|=
name|SHA1_LENGTH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hash_len
operator|>
name|max
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_SSL
operator|(
name|void
operator|)
name|SHA1
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iter
condition|;
name|i
operator|++
control|)
block|{
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|res
argument_list|,
name|hash_len
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|salt
argument_list|,
name|saltlen
argument_list|)
expr_stmt|;
name|ldns_buffer_flip
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
operator|(
name|void
operator|)
name|SHA1
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_EVP_SHA1 or NSS */
default|default:
name|log_err
argument_list|(
literal|"nsec3 hash of unknown algo %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|hash_len
return|;
block|}
end_function

begin_comment
comment|/** perform hash of name */
end_comment

begin_function
specifier|static
name|int
name|nsec3_calc_hash
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|ldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|nsec3_cached_hash
modifier|*
name|c
parameter_list|)
block|{
name|int
name|algo
init|=
name|nsec3_get_algo
argument_list|(
name|c
operator|->
name|nsec3
argument_list|,
name|c
operator|->
name|rr
argument_list|)
decl_stmt|;
name|size_t
name|iter
init|=
name|nsec3_get_iter
argument_list|(
name|c
operator|->
name|nsec3
argument_list|,
name|c
operator|->
name|rr
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|salt
decl_stmt|;
name|size_t
name|saltlen
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|nsec3_get_salt
argument_list|(
name|c
operator|->
name|nsec3
argument_list|,
name|c
operator|->
name|rr
argument_list|,
operator|&
name|salt
argument_list|,
operator|&
name|saltlen
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* prepare buffer for first iteration */
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|c
operator|->
name|dname
argument_list|,
name|c
operator|->
name|dname_len
argument_list|)
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|salt
argument_list|,
name|saltlen
argument_list|)
expr_stmt|;
name|ldns_buffer_flip
argument_list|(
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|algo
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA1
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
case|case
name|NSEC3_HASH_SHA1
case|:
ifdef|#
directive|ifdef
name|HAVE_SSL
name|c
operator|->
name|hash_len
operator|=
name|SHA_DIGEST_LENGTH
expr_stmt|;
else|#
directive|else
name|c
operator|->
name|hash_len
operator|=
name|SHA1_LENGTH
expr_stmt|;
endif|#
directive|endif
name|c
operator|->
name|hash
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|c
operator|->
name|hash_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|hash
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_SSL
operator|(
name|void
operator|)
name|SHA1
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
operator|->
name|hash
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
operator|->
name|hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iter
condition|;
name|i
operator|++
control|)
block|{
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|c
operator|->
name|hash
argument_list|,
name|c
operator|->
name|hash_len
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|salt
argument_list|,
name|saltlen
argument_list|)
expr_stmt|;
name|ldns_buffer_flip
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
operator|(
name|void
operator|)
name|SHA1
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
operator|->
name|hash
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
operator|->
name|hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_EVP_SHA1 or NSS */
default|default:
name|log_err
argument_list|(
literal|"nsec3 hash of unknown algo %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** perform b32 encoding of hash */
end_comment

begin_function
specifier|static
name|int
name|nsec3_calc_b32
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|ldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|nsec3_cached_hash
modifier|*
name|c
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|r
operator|=
name|ldns_b32_ntop_extended_hex
argument_list|(
name|c
operator|->
name|hash
argument_list|,
name|c
operator|->
name|hash_len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"b32_ntop_extended_hex: error in encoding: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|b32_len
operator|=
operator|(
name|size_t
operator|)
name|r
expr_stmt|;
name|c
operator|->
name|b32
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|c
operator|->
name|b32_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|b32
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|nsec3_hash_name
parameter_list|(
name|rbtree_t
modifier|*
name|table
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|ldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec3
parameter_list|,
name|int
name|rr
parameter_list|,
name|uint8_t
modifier|*
name|dname
parameter_list|,
name|size_t
name|dname_len
parameter_list|,
name|struct
name|nsec3_cached_hash
modifier|*
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|nsec3_cached_hash
modifier|*
name|c
decl_stmt|;
name|struct
name|nsec3_cached_hash
name|looki
decl_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|rbnode_t
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
name|int
name|r
decl_stmt|;
name|looki
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|looki
expr_stmt|;
name|looki
operator|.
name|nsec3
operator|=
name|nsec3
expr_stmt|;
name|looki
operator|.
name|rr
operator|=
name|rr
expr_stmt|;
name|looki
operator|.
name|dname
operator|=
name|dname
expr_stmt|;
name|looki
operator|.
name|dname_len
operator|=
name|dname_len
expr_stmt|;
comment|/* lookup first in cache */
name|c
operator|=
operator|(
expr|struct
name|nsec3_cached_hash
operator|*
operator|)
name|rbtree_search
argument_list|(
name|table
argument_list|,
operator|&
name|looki
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
operator|*
name|hash
operator|=
name|c
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* create a new entry */
name|c
operator|=
operator|(
expr|struct
name|nsec3_cached_hash
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|node
operator|.
name|key
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|nsec3
operator|=
name|nsec3
expr_stmt|;
name|c
operator|->
name|rr
operator|=
name|rr
expr_stmt|;
name|c
operator|->
name|dname
operator|=
name|dname
expr_stmt|;
name|c
operator|->
name|dname_len
operator|=
name|dname_len
expr_stmt|;
name|r
operator|=
name|nsec3_calc_hash
argument_list|(
name|region
argument_list|,
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|1
condition|)
return|return
name|r
return|;
name|r
operator|=
name|nsec3_calc_b32
argument_list|(
name|region
argument_list|,
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|1
condition|)
return|return
name|r
return|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
endif|#
directive|endif
name|rbtree_insert
argument_list|(
name|table
argument_list|,
operator|&
name|c
operator|->
name|node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* cannot be duplicate, just did lookup */
operator|*
name|hash
operator|=
name|c
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * compare a label lowercased  */
end_comment

begin_function
specifier|static
name|int
name|label_compare_lower
parameter_list|(
name|uint8_t
modifier|*
name|lab1
parameter_list|,
name|uint8_t
modifier|*
name|lab2
parameter_list|,
name|size_t
name|lablen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lablen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|lab1
argument_list|)
operator|!=
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|lab2
argument_list|)
condition|)
block|{
if|if
condition|(
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|lab1
argument_list|)
operator|<
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|lab2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
name|lab1
operator|++
expr_stmt|;
name|lab2
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Compare a hashed name with the owner name of an NSEC3 RRset.  * @param flt: filter with zone name.  * @param hash: the hashed name.  * @param s: rrset with owner name.  * @return true if matches exactly, false if not.  */
end_comment

begin_function
specifier|static
name|int
name|nsec3_hash_matches_owner
parameter_list|(
name|struct
name|nsec3_filter
modifier|*
name|flt
parameter_list|,
name|struct
name|nsec3_cached_hash
modifier|*
name|hash
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
init|=
name|s
operator|->
name|rk
operator|.
name|dname
decl_stmt|;
comment|/* compare, does hash of name based on params in this NSEC3 	 * match the owner name of this NSEC3?  	 * name must be:<hashlength>base32 . zone name  	 * so; first label must not be root label (not zero length), 	 * and match the b32 encoded hash length,  	 * and the label content match the b32 encoded hash 	 * and the rest must be the zone name. 	 */
if|if
condition|(
name|hash
operator|->
name|b32_len
operator|!=
literal|0
operator|&&
operator|(
name|size_t
operator|)
name|nm
index|[
literal|0
index|]
operator|==
name|hash
operator|->
name|b32_len
operator|&&
name|label_compare_lower
argument_list|(
name|nm
operator|+
literal|1
argument_list|,
name|hash
operator|->
name|b32
argument_list|,
name|hash
operator|->
name|b32_len
argument_list|)
operator|==
literal|0
operator|&&
name|query_dname_compare
argument_list|(
name|nm
operator|+
operator|(
name|size_t
operator|)
name|nm
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|flt
operator|->
name|zone
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Find matching NSEC3  * Find the NSEC3Record that matches a hash of a name.  * @param env: module environment with temporary region and buffer.  * @param flt: the NSEC3 RR filter, contains zone name and RRs.  * @param ct: cached hashes table.  * @param nm: name to look for.  * @param nmlen: length of name.  * @param rrset: nsec3 that matches is returned here.  * @param rr: rr number in nsec3 rrset that matches.  * @return true if a matching NSEC3 is found, false if not.  */
end_comment

begin_function
specifier|static
name|int
name|find_matching_nsec3
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|nsec3_filter
modifier|*
name|flt
parameter_list|,
name|rbtree_t
modifier|*
name|ct
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|rrset
parameter_list|,
name|int
modifier|*
name|rr
parameter_list|)
block|{
name|size_t
name|i_rs
decl_stmt|;
name|int
name|i_rr
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|struct
name|nsec3_cached_hash
modifier|*
name|hash
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* this loop skips other-zone and unknown NSEC3s, also non-NSEC3 RRs */
for|for
control|(
name|s
operator|=
name|filter_first
argument_list|(
name|flt
argument_list|,
operator|&
name|i_rs
argument_list|,
operator|&
name|i_rr
argument_list|)
init|;
name|s
condition|;
name|s
operator|=
name|filter_next
argument_list|(
name|flt
argument_list|,
operator|&
name|i_rs
argument_list|,
operator|&
name|i_rr
argument_list|)
control|)
block|{
comment|/* get name hashed for this NSEC3 RR */
name|r
operator|=
name|nsec3_hash_name
argument_list|(
name|ct
argument_list|,
name|env
operator|->
name|scratch
argument_list|,
name|env
operator|->
name|scratch_buffer
argument_list|,
name|s
argument_list|,
name|i_rr
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
operator|&
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"nsec3: malloc failure"
argument_list|)
expr_stmt|;
break|break;
comment|/* alloc failure */
block|}
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
continue|continue;
comment|/* malformed NSEC3 */
elseif|else
if|if
condition|(
name|nsec3_hash_matches_owner
argument_list|(
name|flt
argument_list|,
name|hash
argument_list|,
name|s
argument_list|)
condition|)
block|{
operator|*
name|rrset
operator|=
name|s
expr_stmt|;
comment|/* rrset with this name */
operator|*
name|rr
operator|=
name|i_rr
expr_stmt|;
comment|/* matches hash with these parameters */
return|return
literal|1
return|;
block|}
block|}
operator|*
name|rrset
operator|=
name|NULL
expr_stmt|;
operator|*
name|rr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nsec3_covers
parameter_list|(
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|struct
name|nsec3_cached_hash
modifier|*
name|hash
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|rr
parameter_list|,
name|ldns_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|uint8_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|owner
decl_stmt|;
name|size_t
name|nextlen
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|nsec3_get_nextowner
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|nextlen
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* malformed RR proves nothing */
comment|/* check the owner name is a hashed value . apex 	 * base32 encoded values must have equal length.  	 * hash_value and next hash value must have equal length. */
if|if
condition|(
name|nextlen
operator|!=
name|hash
operator|->
name|hash_len
operator|||
name|hash
operator|->
name|hash_len
operator|==
literal|0
operator|||
name|hash
operator|->
name|b32_len
operator|==
literal|0
operator|||
operator|(
name|size_t
operator|)
operator|*
name|rrset
operator|->
name|rk
operator|.
name|dname
operator|!=
name|hash
operator|->
name|b32_len
operator|||
name|query_dname_compare
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|dname
operator|+
literal|1
operator|+
operator|(
name|size_t
operator|)
operator|*
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|zone
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* bad lengths or owner name */
comment|/* This is the "normal case: owner< next and owner< hash< next */
if|if
condition|(
name|label_compare_lower
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|dname
operator|+
literal|1
argument_list|,
name|hash
operator|->
name|b32
argument_list|,
name|hash
operator|->
name|b32_len
argument_list|)
operator|<
literal|0
operator|&&
name|memcmp
argument_list|(
name|hash
operator|->
name|hash
argument_list|,
name|next
argument_list|,
name|nextlen
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* convert owner name from text to binary */
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|owner
operator|=
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|ldns_b32_pton_extended_hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rrset
operator|->
name|rk
operator|.
name|dname
operator|+
literal|1
argument_list|,
name|hash
operator|->
name|b32_len
argument_list|,
name|owner
argument_list|,
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
return|return
literal|0
return|;
comment|/* bad owner name in some way */
if|if
condition|(
operator|(
name|size_t
operator|)
name|len
operator|!=
name|hash
operator|->
name|hash_len
operator|||
operator|(
name|size_t
operator|)
name|len
operator|!=
name|nextlen
condition|)
return|return
literal|0
return|;
comment|/* wrong length */
comment|/* this is the end of zone case: next<= owner&&  	 * 	(hash> owner || hash< next)  	 * this also covers the only-apex case of next==owner. 	 */
if|if
condition|(
name|memcmp
argument_list|(
name|next
argument_list|,
name|owner
argument_list|,
name|nextlen
argument_list|)
operator|<=
literal|0
operator|&&
operator|(
name|memcmp
argument_list|(
name|hash
operator|->
name|hash
argument_list|,
name|owner
argument_list|,
name|nextlen
argument_list|)
operator|>
literal|0
operator|||
name|memcmp
argument_list|(
name|hash
operator|->
name|hash
argument_list|,
name|next
argument_list|,
name|nextlen
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * findCoveringNSEC3  * Given a name, find a covering NSEC3 from among a list of NSEC3s.  *  * @param env: module environment with temporary region and buffer.  * @param flt: the NSEC3 RR filter, contains zone name and RRs.  * @param ct: cached hashes table.  * @param nm: name to check if covered.  * @param nmlen: length of name.  * @param rrset: covering NSEC3 rrset is returned here.  * @param rr: rr of cover is returned here.  * @return true if a covering NSEC3 is found, false if not.  */
end_comment

begin_function
specifier|static
name|int
name|find_covering_nsec3
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|nsec3_filter
modifier|*
name|flt
parameter_list|,
name|rbtree_t
modifier|*
name|ct
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|rrset
parameter_list|,
name|int
modifier|*
name|rr
parameter_list|)
block|{
name|size_t
name|i_rs
decl_stmt|;
name|int
name|i_rr
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|struct
name|nsec3_cached_hash
modifier|*
name|hash
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* this loop skips other-zone and unknown NSEC3s, also non-NSEC3 RRs */
for|for
control|(
name|s
operator|=
name|filter_first
argument_list|(
name|flt
argument_list|,
operator|&
name|i_rs
argument_list|,
operator|&
name|i_rr
argument_list|)
init|;
name|s
condition|;
name|s
operator|=
name|filter_next
argument_list|(
name|flt
argument_list|,
operator|&
name|i_rs
argument_list|,
operator|&
name|i_rr
argument_list|)
control|)
block|{
comment|/* get name hashed for this NSEC3 RR */
name|r
operator|=
name|nsec3_hash_name
argument_list|(
name|ct
argument_list|,
name|env
operator|->
name|scratch
argument_list|,
name|env
operator|->
name|scratch_buffer
argument_list|,
name|s
argument_list|,
name|i_rr
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
operator|&
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"nsec3: malloc failure"
argument_list|)
expr_stmt|;
break|break;
comment|/* alloc failure */
block|}
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
continue|continue;
comment|/* malformed NSEC3 */
elseif|else
if|if
condition|(
name|nsec3_covers
argument_list|(
name|flt
operator|->
name|zone
argument_list|,
name|hash
argument_list|,
name|s
argument_list|,
name|i_rr
argument_list|,
name|env
operator|->
name|scratch_buffer
argument_list|)
condition|)
block|{
operator|*
name|rrset
operator|=
name|s
expr_stmt|;
comment|/* rrset with this name */
operator|*
name|rr
operator|=
name|i_rr
expr_stmt|;
comment|/* covers hash with these parameters */
return|return
literal|1
return|;
block|}
block|}
operator|*
name|rrset
operator|=
name|NULL
expr_stmt|;
operator|*
name|rr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * findClosestEncloser  * Given a name and a list of NSEC3s, find the candidate closest encloser.  * This will be the first ancestor of 'name' (including itself) to have a  * matching NSEC3 RR.  * @param env: module environment with temporary region and buffer.  * @param flt: the NSEC3 RR filter, contains zone name and RRs.  * @param ct: cached hashes table.  * @param qinfo: query that is verified for.  * @param ce: closest encloser information is returned in here.  * @return true if a closest encloser candidate is found, false if not.  */
end_comment

begin_function
specifier|static
name|int
name|nsec3_find_closest_encloser
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|nsec3_filter
modifier|*
name|flt
parameter_list|,
name|rbtree_t
modifier|*
name|ct
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|ce_response
modifier|*
name|ce
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
init|=
name|qinfo
operator|->
name|qname
decl_stmt|;
name|size_t
name|nmlen
init|=
name|qinfo
operator|->
name|qname_len
decl_stmt|;
comment|/* This scans from longest name to shortest, so the first match  	 * we find is the only viable candidate. */
comment|/* (David:) FIXME: modify so that the NSEC3 matching the zone apex need  	 * not be present. (Mark Andrews idea). 	 * (Wouter:) But make sure you check for DNAME bit in zone apex, 	 * if the NSEC3 you find is the only NSEC3 in the zone, then this 	 * may be the case. */
while|while
condition|(
name|dname_subdomain_c
argument_list|(
name|nm
argument_list|,
name|flt
operator|->
name|zone
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_matching_nsec3
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
operator|&
name|ce
operator|->
name|ce_rrset
argument_list|,
operator|&
name|ce
operator|->
name|ce_rr
argument_list|)
condition|)
block|{
name|ce
operator|->
name|ce
operator|=
name|nm
expr_stmt|;
name|ce
operator|->
name|ce_len
operator|=
name|nmlen
expr_stmt|;
return|return
literal|1
return|;
block|}
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Given a qname and its proven closest encloser, calculate the "next  * closest" name. Basically, this is the name that is one label longer than  * the closest encloser that is still a subdomain of qname.  *  * @param qname: query name.  * @param qnamelen: length of qname.  * @param ce: closest encloser  * @param nm: result name.  * @param nmlen: length of nm.  */
end_comment

begin_function
specifier|static
name|void
name|next_closer
parameter_list|(
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint8_t
modifier|*
name|ce
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|size_t
modifier|*
name|nmlen
parameter_list|)
block|{
name|int
name|strip
init|=
name|dname_count_labels
argument_list|(
name|qname
argument_list|)
operator|-
name|dname_count_labels
argument_list|(
name|ce
argument_list|)
operator|-
literal|1
decl_stmt|;
operator|*
name|nm
operator|=
name|qname
expr_stmt|;
operator|*
name|nmlen
operator|=
name|qnamelen
expr_stmt|;
if|if
condition|(
name|strip
operator|>
literal|0
condition|)
name|dname_remove_labels
argument_list|(
name|nm
argument_list|,
name|nmlen
argument_list|,
name|strip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * proveClosestEncloser  * Given a List of nsec3 RRs, find and prove the closest encloser to qname.  * @param env: module environment with temporary region and buffer.  * @param flt: the NSEC3 RR filter, contains zone name and RRs.  * @param ct: cached hashes table.  * @param qinfo: query that is verified for.  * @param prove_does_not_exist: If true, then if the closest encloser   * 	turns out to be qname, then null is returned.  * 	If set true, and the return value is true, then you can be   * 	certain that the ce.nc_rrset and ce.nc_rr are set properly.  * @param ce: closest encloser information is returned in here.  * @return bogus if no closest encloser could be proven.  * 	secure if a closest encloser could be proven, ce is set.  * 	insecure if the closest-encloser candidate turns out to prove  * 		that an insecure delegation exists above the qname.  */
end_comment

begin_function
specifier|static
name|enum
name|sec_status
name|nsec3_prove_closest_encloser
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|nsec3_filter
modifier|*
name|flt
parameter_list|,
name|rbtree_t
modifier|*
name|ct
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|int
name|prove_does_not_exist
parameter_list|,
name|struct
name|ce_response
modifier|*
name|ce
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nc
decl_stmt|;
name|size_t
name|nc_len
decl_stmt|;
comment|/* robust: clean out ce, in case it gets abused later */
name|memset
argument_list|(
name|ce
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ce
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsec3_find_closest_encloser
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|qinfo
argument_list|,
name|ce
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 proveClosestEncloser: could "
literal|"not find a candidate for the closest encloser."
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"ce candidate"
argument_list|,
name|ce
operator|->
name|ce
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|ce
operator|->
name|ce
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prove_does_not_exist
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 proveClosestEncloser: "
literal|"proved that qname existed, bad"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* otherwise, we need to nothing else to prove that qname  		 * is its own closest encloser. */
return|return
name|sec_status_secure
return|;
block|}
comment|/* If the closest encloser is actually a delegation, then the  	 * response should have been a referral. If it is a DNAME, then  	 * it should have been a DNAME response. */
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|ce
operator|->
name|ce_rrset
argument_list|,
name|ce
operator|->
name|ce_rr
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|nsec3_has_type
argument_list|(
name|ce
operator|->
name|ce_rrset
argument_list|,
name|ce
operator|->
name|ce_rr
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|nsec3_has_type
argument_list|(
name|ce
operator|->
name|ce_rrset
argument_list|,
name|ce
operator|->
name|ce_rr
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 proveClosestEncloser: "
literal|"closest encloser is insecure delegation"
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 proveClosestEncloser: closest "
literal|"encloser was a delegation, bad"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|ce
operator|->
name|ce_rrset
argument_list|,
name|ce
operator|->
name|ce_rr
argument_list|,
name|LDNS_RR_TYPE_DNAME
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 proveClosestEncloser: closest "
literal|"encloser was a DNAME, bad"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* Otherwise, we need to show that the next closer name is covered. */
name|next_closer
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|ce
operator|->
name|ce
argument_list|,
operator|&
name|nc
argument_list|,
operator|&
name|nc_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_covering_nsec3
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|nc
argument_list|,
name|nc_len
argument_list|,
operator|&
name|ce
operator|->
name|nc_rrset
argument_list|,
operator|&
name|ce
operator|->
name|nc_rr
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3: Could not find proof that the "
literal|"candidate encloser was the closest encloser"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
return|return
name|sec_status_secure
return|;
block|}
end_function

begin_comment
comment|/** allocate a wildcard for the closest encloser */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|nsec3_ce_wildcard
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|uint8_t
modifier|*
name|ce
parameter_list|,
name|size_t
name|celen
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|celen
operator|>
name|LDNS_MAX_DOMAINLEN
operator|-
literal|2
condition|)
return|return
literal|0
return|;
comment|/* too long */
name|nm
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|celen
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
block|{
name|log_err
argument_list|(
literal|"nsec3 wildcard: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* alloc failure */
block|}
name|nm
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|nm
index|[
literal|1
index|]
operator|=
operator|(
name|uint8_t
operator|)
literal|'*'
expr_stmt|;
comment|/* wildcard label */
name|memmove
argument_list|(
name|nm
operator|+
literal|2
argument_list|,
name|ce
argument_list|,
name|celen
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|celen
operator|+
literal|2
expr_stmt|;
return|return
name|nm
return|;
block|}
end_function

begin_comment
comment|/** Do the name error proof */
end_comment

begin_function
specifier|static
name|enum
name|sec_status
name|nsec3_do_prove_nameerror
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|nsec3_filter
modifier|*
name|flt
parameter_list|,
name|rbtree_t
modifier|*
name|ct
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
name|struct
name|ce_response
name|ce
decl_stmt|;
name|uint8_t
modifier|*
name|wc
decl_stmt|;
name|size_t
name|wclen
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|wc_rrset
decl_stmt|;
name|int
name|wc_rr
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
comment|/* First locate and prove the closest encloser to qname. We will  	 * use the variant that fails if the closest encloser turns out  	 * to be qname. */
name|sec
operator|=
name|nsec3_prove_closest_encloser
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|qinfo
argument_list|,
literal|1
argument_list|,
operator|&
name|ce
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|sec_status_secure
condition|)
block|{
if|if
condition|(
name|sec
operator|==
name|sec_status_bogus
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nameerror proof: failed "
literal|"to prove a closest encloser"
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nameerror proof: closest "
literal|"nsec3 is an insecure delegation"
argument_list|)
expr_stmt|;
return|return
name|sec
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 namerror: proven ce="
argument_list|,
name|ce
operator|.
name|ce
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* At this point, we know that qname does not exist. Now we need  	 * to prove that the wildcard does not exist. */
name|log_assert
argument_list|(
name|ce
operator|.
name|ce
argument_list|)
expr_stmt|;
name|wc
operator|=
name|nsec3_ce_wildcard
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|ce
operator|.
name|ce
argument_list|,
name|ce
operator|.
name|ce_len
argument_list|,
operator|&
name|wclen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wc
operator|||
operator|!
name|find_covering_nsec3
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|wc
argument_list|,
name|wclen
argument_list|,
operator|&
name|wc_rrset
argument_list|,
operator|&
name|wc_rr
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nameerror proof: could not prove "
literal|"that the applicable wildcard did not exist."
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|ce
operator|.
name|nc_rrset
operator|&&
name|nsec3_has_optout
argument_list|(
name|ce
operator|.
name|nc_rrset
argument_list|,
name|ce
operator|.
name|nc_rr
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nameerror proof: nc has optout"
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
return|return
name|sec_status_secure
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|nsec3_prove_nameerror
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|num
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
name|rbtree_t
name|ct
decl_stmt|;
name|struct
name|nsec3_filter
name|flt
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
name|num
operator|==
literal|0
operator|||
operator|!
name|kkey
operator|||
operator|!
name|key_entry_isgood
argument_list|(
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no valid NSEC3s, bogus */
name|rbtree_init
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|nsec3_hash_cmp
argument_list|)
expr_stmt|;
comment|/* init names-to-hash cache */
name|filter_init
argument_list|(
operator|&
name|flt
argument_list|,
name|list
argument_list|,
name|num
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
comment|/* init RR iterator */
if|if
condition|(
operator|!
name|flt
operator|.
name|zone
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no RRs */
if|if
condition|(
name|nsec3_iteration_count_high
argument_list|(
name|ve
argument_list|,
operator|&
name|flt
argument_list|,
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_insecure
return|;
comment|/* iteration count too high */
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"start nsec3 nameerror proof, zone"
argument_list|,
name|flt
operator|.
name|zone
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|nsec3_do_prove_nameerror
argument_list|(
name|env
argument_list|,
operator|&
name|flt
argument_list|,
operator|&
name|ct
argument_list|,
name|qinfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   * No code to handle qtype=NSEC3 specially.   * This existed in early drafts, but was later (-05) removed.  */
end_comment

begin_comment
comment|/** Do the nodata proof */
end_comment

begin_function
specifier|static
name|enum
name|sec_status
name|nsec3_do_prove_nodata
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|nsec3_filter
modifier|*
name|flt
parameter_list|,
name|rbtree_t
modifier|*
name|ct
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
name|struct
name|ce_response
name|ce
decl_stmt|;
name|uint8_t
modifier|*
name|wc
decl_stmt|;
name|size_t
name|wclen
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
name|int
name|rr
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
if|if
condition|(
name|find_matching_nsec3
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
operator|&
name|rrset
argument_list|,
operator|&
name|rr
argument_list|)
condition|)
block|{
comment|/* cases 1 and 2 */
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: Matching NSEC3 "
literal|"proved that type existed, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
elseif|else
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_CNAME
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: Matching NSEC3 "
literal|"proved that a CNAME existed, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/*  		 * If type DS: filter_init zone find already found a parent 		 *   zone, so this nsec3 is from a parent zone.  		 *   o can be not a delegation (unusual query for normal name, 		 *   	no DS anyway, but we can verify that). 		 *   o can be a delegation (which is the usual DS check). 		 *   o may not have the SOA bit set (only the top of the 		 *   	zone, which must have been above the name, has that). 		 *   	Except for the root; which is checked by itself. 		 * 		 * If not type DS: matching nsec3 must not be a delegation. 		 */
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
name|qinfo
operator|->
name|qname_len
operator|!=
literal|1
operator|&&
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
operator|&&
operator|!
name|dname_is_root
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: apex NSEC3 "
literal|"abused for no DS proof, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
elseif|else
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: matching "
literal|"NSEC3 is insecure delegation"
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: matching "
literal|"NSEC3 is a delegation, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
return|return
name|sec_status_secure
return|;
block|}
comment|/* For cases 3 - 5, we need the proven closest encloser, and it  	 * can't match qname. Although, at this point, we know that it  	 * won't since we just checked that. */
name|sec
operator|=
name|nsec3_prove_closest_encloser
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|qinfo
argument_list|,
literal|1
argument_list|,
operator|&
name|ce
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_bogus
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: did not match qname, "
literal|"nor found a proven closest encloser."
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
operator|&&
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_DS
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: closest nsec3 is insecure "
literal|"delegation."
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
comment|/* Case 3: removed */
comment|/* Case 4: */
name|log_assert
argument_list|(
name|ce
operator|.
name|ce
argument_list|)
expr_stmt|;
name|wc
operator|=
name|nsec3_ce_wildcard
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|ce
operator|.
name|ce
argument_list|,
name|ce
operator|.
name|ce_len
argument_list|,
operator|&
name|wclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|&&
name|find_matching_nsec3
argument_list|(
name|env
argument_list|,
name|flt
argument_list|,
name|ct
argument_list|,
name|wc
argument_list|,
name|wclen
argument_list|,
operator|&
name|rrset
argument_list|,
operator|&
name|rr
argument_list|)
condition|)
block|{
comment|/* found wildcard */
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nodata proof: matching "
literal|"wildcard had qtype, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
elseif|else
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_CNAME
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nodata proof: matching "
literal|"wildcard had a CNAME, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
name|qinfo
operator|->
name|qname_len
operator|!=
literal|1
operator|&&
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nodata proof: matching "
literal|"wildcard for no DS proof has a SOA, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
elseif|else
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nodata proof: matching "
literal|"wilcard is a delegation, bogus"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* everything is peachy keen, except for optout spans */
if|if
condition|(
name|ce
operator|.
name|nc_rrset
operator|&&
name|nsec3_has_optout
argument_list|(
name|ce
operator|.
name|nc_rrset
argument_list|,
name|ce
operator|.
name|nc_rr
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nodata proof: matching "
literal|"wildcard is in optout range, insecure"
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
return|return
name|sec_status_secure
return|;
block|}
comment|/* Case 5: */
comment|/* Due to forwarders, cnames, and other collating effects, we 	 * can see the ordinary unsigned data from a zone beneath an 	 * insecure delegation under an optout here */
if|if
condition|(
operator|!
name|ce
operator|.
name|nc_rrset
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nodata proof: no next closer nsec3"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* We need to make sure that the covering NSEC3 is opt-out. */
name|log_assert
argument_list|(
name|ce
operator|.
name|nc_rrset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsec3_has_optout
argument_list|(
name|ce
operator|.
name|nc_rrset
argument_list|,
name|ce
operator|.
name|nc_rr
argument_list|)
condition|)
block|{
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: covering NSEC3 was not "
literal|"opt-out in an opt-out DS NOERROR/NODATA case."
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveNodata: could not find matching "
literal|"NSEC3, nor matching wildcard, nor optout NSEC3 "
literal|"-- no more options, bogus."
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* RFC5155 section 9.2: if nc has optout then no AD flag set */
return|return
name|sec_status_insecure
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|nsec3_prove_nodata
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|num
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
name|rbtree_t
name|ct
decl_stmt|;
name|struct
name|nsec3_filter
name|flt
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
name|num
operator|==
literal|0
operator|||
operator|!
name|kkey
operator|||
operator|!
name|key_entry_isgood
argument_list|(
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no valid NSEC3s, bogus */
name|rbtree_init
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|nsec3_hash_cmp
argument_list|)
expr_stmt|;
comment|/* init names-to-hash cache */
name|filter_init
argument_list|(
operator|&
name|flt
argument_list|,
name|list
argument_list|,
name|num
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
comment|/* init RR iterator */
if|if
condition|(
operator|!
name|flt
operator|.
name|zone
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no RRs */
if|if
condition|(
name|nsec3_iteration_count_high
argument_list|(
name|ve
argument_list|,
operator|&
name|flt
argument_list|,
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_insecure
return|;
comment|/* iteration count too high */
return|return
name|nsec3_do_prove_nodata
argument_list|(
name|env
argument_list|,
operator|&
name|flt
argument_list|,
operator|&
name|ct
argument_list|,
name|qinfo
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|nsec3_prove_wildcard
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|num
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|uint8_t
modifier|*
name|wc
parameter_list|)
block|{
name|rbtree_t
name|ct
decl_stmt|;
name|struct
name|nsec3_filter
name|flt
decl_stmt|;
name|struct
name|ce_response
name|ce
decl_stmt|;
name|uint8_t
modifier|*
name|nc
decl_stmt|;
name|size_t
name|nc_len
decl_stmt|;
name|size_t
name|wclen
decl_stmt|;
operator|(
name|void
operator|)
name|dname_count_size_labels
argument_list|(
name|wc
argument_list|,
operator|&
name|wclen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
name|num
operator|==
literal|0
operator|||
operator|!
name|kkey
operator|||
operator|!
name|key_entry_isgood
argument_list|(
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no valid NSEC3s, bogus */
name|rbtree_init
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|nsec3_hash_cmp
argument_list|)
expr_stmt|;
comment|/* init names-to-hash cache */
name|filter_init
argument_list|(
operator|&
name|flt
argument_list|,
name|list
argument_list|,
name|num
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
comment|/* init RR iterator */
if|if
condition|(
operator|!
name|flt
operator|.
name|zone
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no RRs */
if|if
condition|(
name|nsec3_iteration_count_high
argument_list|(
name|ve
argument_list|,
operator|&
name|flt
argument_list|,
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_insecure
return|;
comment|/* iteration count too high */
comment|/* We know what the (purported) closest encloser is by just  	 * looking at the supposed generating wildcard.  	 * The *. has already been removed from the wc name. 	 */
name|memset
argument_list|(
operator|&
name|ce
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ce
argument_list|)
argument_list|)
expr_stmt|;
name|ce
operator|.
name|ce
operator|=
name|wc
expr_stmt|;
name|ce
operator|.
name|ce_len
operator|=
name|wclen
expr_stmt|;
comment|/* Now we still need to prove that the original data did not exist. 	 * Otherwise, we need to show that the next closer name is covered. */
name|next_closer
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|ce
operator|.
name|ce
argument_list|,
operator|&
name|nc
argument_list|,
operator|&
name|nc_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_covering_nsec3
argument_list|(
name|env
argument_list|,
operator|&
name|flt
argument_list|,
operator|&
name|ct
argument_list|,
name|nc
argument_list|,
name|nc_len
argument_list|,
operator|&
name|ce
operator|.
name|nc_rrset
argument_list|,
operator|&
name|ce
operator|.
name|nc_rr
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveWildcard: did not find a covering "
literal|"NSEC3 that covered the next closer name."
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|ce
operator|.
name|nc_rrset
operator|&&
name|nsec3_has_optout
argument_list|(
name|ce
operator|.
name|nc_rrset
argument_list|,
name|ce
operator|.
name|nc_rr
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"proveWildcard: NSEC3 optout"
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
return|return
name|sec_status_secure
return|;
block|}
end_function

begin_comment
comment|/** test if list is all secure */
end_comment

begin_function
specifier|static
name|int
name|list_is_secure
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|num
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|list
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|list
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
operator|!=
name|htons
argument_list|(
name|LDNS_RR_TYPE_NSEC3
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
continue|continue;
name|rrset_check_sec_status
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|list
index|[
name|i
index|]
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
continue|continue;
name|d
operator|->
name|security
operator|=
name|val_verify_rrset_entry
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|list
index|[
name|i
index|]
argument_list|,
name|kkey
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"NSEC3 did not verify"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rrset_update_sec_status
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|list
index|[
name|i
index|]
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|nsec3_prove_nods
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|num
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|rbtree_t
name|ct
decl_stmt|;
name|struct
name|nsec3_filter
name|flt
decl_stmt|;
name|struct
name|ce_response
name|ce
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
name|int
name|rr
decl_stmt|;
name|log_assert
argument_list|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
name|num
operator|==
literal|0
operator|||
operator|!
name|kkey
operator|||
operator|!
name|key_entry_isgood
argument_list|(
name|kkey
argument_list|)
condition|)
block|{
operator|*
name|reason
operator|=
literal|"no valid NSEC3s"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
comment|/* no valid NSEC3s, bogus */
block|}
if|if
condition|(
operator|!
name|list_is_secure
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|list
argument_list|,
name|num
argument_list|,
name|kkey
argument_list|,
name|reason
argument_list|)
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* not all NSEC3 records secure */
name|rbtree_init
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|nsec3_hash_cmp
argument_list|)
expr_stmt|;
comment|/* init names-to-hash cache */
name|filter_init
argument_list|(
operator|&
name|flt
argument_list|,
name|list
argument_list|,
name|num
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
comment|/* init RR iterator */
if|if
condition|(
operator|!
name|flt
operator|.
name|zone
condition|)
block|{
operator|*
name|reason
operator|=
literal|"no NSEC3 records"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
comment|/* no RRs */
block|}
if|if
condition|(
name|nsec3_iteration_count_high
argument_list|(
name|ve
argument_list|,
operator|&
name|flt
argument_list|,
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_insecure
return|;
comment|/* iteration count too high */
comment|/* Look for a matching NSEC3 to qname -- this is the normal  	 * NODATA case. */
if|if
condition|(
name|find_matching_nsec3
argument_list|(
name|env
argument_list|,
operator|&
name|flt
argument_list|,
operator|&
name|ct
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
operator|&
name|rrset
argument_list|,
operator|&
name|rr
argument_list|)
condition|)
block|{
comment|/* If the matching NSEC3 has the SOA bit set, it is from  		 * the wrong zone (the child instead of the parent). If  		 * it has the DS bit set, then we were lied to. */
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
operator|&&
name|qinfo
operator|->
name|qname_len
operator|!=
literal|1
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 provenods: NSEC3 is from"
literal|" child zone, bogus"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"NSEC3 from child zone"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
elseif|else
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 provenods: NSEC3 has qtype"
literal|" DS, bogus"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"NSEC3 has DS in bitmap"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* If the NSEC3 RR doesn't have the NS bit set, then  		 * this wasn't a delegation point. */
if|if
condition|(
operator|!
name|nsec3_has_type
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
condition|)
return|return
name|sec_status_indeterminate
return|;
comment|/* Otherwise, this proves no DS. */
return|return
name|sec_status_secure
return|;
block|}
comment|/* Otherwise, we are probably in the opt-out case. */
if|if
condition|(
name|nsec3_prove_closest_encloser
argument_list|(
name|env
argument_list|,
operator|&
name|flt
argument_list|,
operator|&
name|ct
argument_list|,
name|qinfo
argument_list|,
literal|1
argument_list|,
operator|&
name|ce
argument_list|)
operator|!=
name|sec_status_secure
condition|)
block|{
comment|/* an insecure delegation *above* the qname does not prove 		 * anything about this qname exactly, and bogus is bogus */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 provenods: did not match qname, "
literal|"nor found a proven closest encloser."
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"no NSEC3 closest encloser"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* robust extra check */
if|if
condition|(
operator|!
name|ce
operator|.
name|nc_rrset
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 nods proof: no next closer nsec3"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"no NSEC3 next closer"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* we had the closest encloser proof, then we need to check that the 	 * covering NSEC3 was opt-out -- the proveClosestEncloser step already 	 * checked to see if the closest encloser was a delegation or DNAME. 	 */
name|log_assert
argument_list|(
name|ce
operator|.
name|nc_rrset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsec3_has_optout
argument_list|(
name|ce
operator|.
name|nc_rrset
argument_list|,
name|ce
operator|.
name|nc_rr
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec3 provenods: covering NSEC3 was not "
literal|"opt-out in an opt-out DS NOERROR/NODATA case."
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"covering NSEC3 was not opt-out in an opt-out "
literal|"DS NOERROR/NODATA case"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* RFC5155 section 9.2: if nc has optout then no AD flag set */
return|return
name|sec_status_insecure
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|nsec3_prove_nxornodata
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|num
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|int
modifier|*
name|nodata
parameter_list|)
block|{
name|enum
name|sec_status
name|sec
decl_stmt|,
name|secnx
decl_stmt|;
name|rbtree_t
name|ct
decl_stmt|;
name|struct
name|nsec3_filter
name|flt
decl_stmt|;
operator|*
name|nodata
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
name|num
operator|==
literal|0
operator|||
operator|!
name|kkey
operator|||
operator|!
name|key_entry_isgood
argument_list|(
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no valid NSEC3s, bogus */
name|rbtree_init
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|nsec3_hash_cmp
argument_list|)
expr_stmt|;
comment|/* init names-to-hash cache */
name|filter_init
argument_list|(
operator|&
name|flt
argument_list|,
name|list
argument_list|,
name|num
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
comment|/* init RR iterator */
if|if
condition|(
operator|!
name|flt
operator|.
name|zone
condition|)
return|return
name|sec_status_bogus
return|;
comment|/* no RRs */
if|if
condition|(
name|nsec3_iteration_count_high
argument_list|(
name|ve
argument_list|,
operator|&
name|flt
argument_list|,
name|kkey
argument_list|)
condition|)
return|return
name|sec_status_insecure
return|;
comment|/* iteration count too high */
comment|/* try nxdomain and nodata after another, while keeping the 	 * hash cache intact */
name|secnx
operator|=
name|nsec3_do_prove_nameerror
argument_list|(
name|env
argument_list|,
operator|&
name|flt
argument_list|,
operator|&
name|ct
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|secnx
operator|==
name|sec_status_secure
condition|)
return|return
name|sec_status_secure
return|;
name|sec
operator|=
name|nsec3_do_prove_nodata
argument_list|(
name|env
argument_list|,
operator|&
name|flt
argument_list|,
operator|&
name|ct
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
operator|*
name|nodata
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
operator|*
name|nodata
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secnx
operator|==
name|sec_status_insecure
condition|)
block|{
name|sec
operator|=
name|sec_status_insecure
expr_stmt|;
block|}
return|return
name|sec
return|;
block|}
end_function

end_unit

