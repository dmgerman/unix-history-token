begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * services/cache/infra.c - infrastructure cache, server rtt and capabilities  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains the infrastructure cache.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ldns/rr.h>
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/lookup3.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iterator.h"
end_include

begin_comment
comment|/** Timeout when only a single probe query per IP is allowed. */
end_comment

begin_define
define|#
directive|define
name|PROBE_MAXRTO
value|12000
end_define

begin_comment
comment|/* in msec */
end_comment

begin_comment
comment|/** number of timeouts for a type when the domain can be blocked ;  * even if another type has completely rtt maxed it, the different type  * can do this number of packets (until those all timeout too) */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT_COUNT_MAX
value|3
end_define

begin_function
name|size_t
name|infra_sizefunc
parameter_list|(
name|void
modifier|*
name|k
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|d
parameter_list|)
parameter_list|)
block|{
name|struct
name|infra_key
modifier|*
name|key
init|=
operator|(
expr|struct
name|infra_key
operator|*
operator|)
name|k
decl_stmt|;
return|return
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|infra_data
argument_list|)
operator|+
name|key
operator|->
name|namelen
operator|+
name|lock_get_mem
argument_list|(
operator|&
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|infra_compfunc
parameter_list|(
name|void
modifier|*
name|key1
parameter_list|,
name|void
modifier|*
name|key2
parameter_list|)
block|{
name|struct
name|infra_key
modifier|*
name|k1
init|=
operator|(
expr|struct
name|infra_key
operator|*
operator|)
name|key1
decl_stmt|;
name|struct
name|infra_key
modifier|*
name|k2
init|=
operator|(
expr|struct
name|infra_key
operator|*
operator|)
name|key2
decl_stmt|;
name|int
name|r
init|=
name|sockaddr_cmp
argument_list|(
operator|&
name|k1
operator|->
name|addr
argument_list|,
name|k1
operator|->
name|addrlen
argument_list|,
operator|&
name|k2
operator|->
name|addr
argument_list|,
name|k2
operator|->
name|addrlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|k1
operator|->
name|namelen
operator|!=
name|k2
operator|->
name|namelen
condition|)
block|{
if|if
condition|(
name|k1
operator|->
name|namelen
operator|<
name|k2
operator|->
name|namelen
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
return|return
name|query_dname_compare
argument_list|(
name|k1
operator|->
name|zonename
argument_list|,
name|k2
operator|->
name|zonename
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|infra_delkeyfunc
parameter_list|(
name|void
modifier|*
name|k
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|infra_key
modifier|*
name|key
init|=
operator|(
expr|struct
name|infra_key
operator|*
operator|)
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
return|return;
name|lock_rw_destroy
argument_list|(
operator|&
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|key
operator|->
name|zonename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|infra_deldatafunc
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|infra_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|d
decl_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|infra_cache
modifier|*
name|infra_create
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|infra_cache
modifier|*
name|infra
init|=
operator|(
expr|struct
name|infra_cache
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|infra_cache
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|maxmem
init|=
name|cfg
operator|->
name|infra_cache_numhosts
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|infra_key
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|infra_data
argument_list|)
operator|+
name|INFRA_BYTES_NAME
operator|)
decl_stmt|;
name|infra
operator|->
name|hosts
operator|=
name|slabhash_create
argument_list|(
name|cfg
operator|->
name|infra_cache_slabs
argument_list|,
name|INFRA_HOST_STARTSIZE
argument_list|,
name|maxmem
argument_list|,
operator|&
name|infra_sizefunc
argument_list|,
operator|&
name|infra_compfunc
argument_list|,
operator|&
name|infra_delkeyfunc
argument_list|,
operator|&
name|infra_deldatafunc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|infra
operator|->
name|hosts
condition|)
block|{
name|free
argument_list|(
name|infra
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|infra
operator|->
name|host_ttl
operator|=
name|cfg
operator|->
name|host_ttl
expr_stmt|;
return|return
name|infra
return|;
block|}
end_function

begin_function
name|void
name|infra_delete
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|)
block|{
if|if
condition|(
operator|!
name|infra
condition|)
return|return;
name|slabhash_delete
argument_list|(
name|infra
operator|->
name|hosts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|infra
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|infra_cache
modifier|*
name|infra_adjust
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|size_t
name|maxmem
decl_stmt|;
if|if
condition|(
operator|!
name|infra
condition|)
return|return
name|infra_create
argument_list|(
name|cfg
argument_list|)
return|;
name|infra
operator|->
name|host_ttl
operator|=
name|cfg
operator|->
name|host_ttl
expr_stmt|;
name|maxmem
operator|=
name|cfg
operator|->
name|infra_cache_numhosts
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|infra_key
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|infra_data
argument_list|)
operator|+
name|INFRA_BYTES_NAME
operator|)
expr_stmt|;
if|if
condition|(
name|maxmem
operator|!=
name|slabhash_get_size
argument_list|(
name|infra
operator|->
name|hosts
argument_list|)
operator|||
name|cfg
operator|->
name|infra_cache_slabs
operator|!=
name|infra
operator|->
name|hosts
operator|->
name|size
condition|)
block|{
name|infra_delete
argument_list|(
name|infra
argument_list|)
expr_stmt|;
name|infra
operator|=
name|infra_create
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
return|return
name|infra
return|;
block|}
end_function

begin_comment
comment|/** calculate the hash value for a host key */
end_comment

begin_function
specifier|static
name|hashvalue_t
name|hash_addr
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|hashvalue_t
name|h
init|=
literal|0xab
decl_stmt|;
comment|/* select the pieces to hash, some OS have changing data inside */
if|if
condition|(
name|addr_is_ip6
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|in6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
decl_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|in6
operator|->
name|sin6_family
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
operator|->
name|sin6_family
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|in6
operator|->
name|sin6_port
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
operator|->
name|sin6_port
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|in6
operator|->
name|sin6_addr
argument_list|,
name|INET6_SIZE
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sockaddr_in
modifier|*
name|in
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
decl_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|in
operator|->
name|sin_family
argument_list|,
sizeof|sizeof
argument_list|(
name|in
operator|->
name|sin_family
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|in
operator|->
name|sin_port
argument_list|,
sizeof|sizeof
argument_list|(
name|in
operator|->
name|sin_port
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|in
operator|->
name|sin_addr
argument_list|,
name|INET_SIZE
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/** calculate infra hash for a key */
end_comment

begin_function
specifier|static
name|hashvalue_t
name|hash_infra
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|)
block|{
return|return
name|dname_query_hash
argument_list|(
name|name
argument_list|,
name|hash_addr
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** lookup version that does not check host ttl (you check it) */
end_comment

begin_function
name|struct
name|lruhash_entry
modifier|*
name|infra_lookup_nottl
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|int
name|wr
parameter_list|)
block|{
name|struct
name|infra_key
name|k
decl_stmt|;
name|k
operator|.
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|k
operator|.
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|k
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|k
operator|.
name|zonename
operator|=
name|name
expr_stmt|;
name|k
operator|.
name|entry
operator|.
name|hash
operator|=
name|hash_infra
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|k
operator|.
name|entry
operator|.
name|key
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|k
expr_stmt|;
name|k
operator|.
name|entry
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
return|return
name|slabhash_lookup
argument_list|(
name|infra
operator|->
name|hosts
argument_list|,
name|k
operator|.
name|entry
operator|.
name|hash
argument_list|,
operator|&
name|k
argument_list|,
name|wr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** init the data elements */
end_comment

begin_function
specifier|static
name|void
name|data_entry_init
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|uint32_t
name|timenow
parameter_list|)
block|{
name|struct
name|infra_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
name|data
operator|->
name|ttl
operator|=
name|timenow
operator|+
name|infra
operator|->
name|host_ttl
expr_stmt|;
name|rtt_init
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|)
expr_stmt|;
name|data
operator|->
name|edns_version
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|edns_lame_known
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|probedelay
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|isdnsseclame
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|rec_lame
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|lame_type_A
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|lame_other
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|timeout_A
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|timeout_AAAA
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|timeout_other
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Create and init a new entry for a host   * @param infra: infra structure with config parameters.  * @param addr: host address.  * @param addrlen: length of addr.  * @param name: name of zone  * @param namelen: length of name.  * @param tm: time now.  * @return: the new entry or NULL on malloc failure.  */
end_comment

begin_function
specifier|static
name|struct
name|lruhash_entry
modifier|*
name|new_entry
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint32_t
name|tm
parameter_list|)
block|{
name|struct
name|infra_data
modifier|*
name|data
decl_stmt|;
name|struct
name|infra_key
modifier|*
name|key
init|=
operator|(
expr|struct
name|infra_key
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
name|NULL
return|;
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|infra_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key
operator|->
name|zonename
operator|=
name|memdup
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|zonename
condition|)
block|{
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
name|lock_rw_init
argument_list|(
operator|&
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|key
operator|->
name|entry
operator|.
name|hash
operator|=
name|hash_infra
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|key
operator|->
name|entry
operator|.
name|key
operator|=
operator|(
name|void
operator|*
operator|)
name|key
expr_stmt|;
name|key
operator|->
name|entry
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|key
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|data_entry_init
argument_list|(
name|infra
argument_list|,
operator|&
name|key
operator|->
name|entry
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return
operator|&
name|key
operator|->
name|entry
return|;
block|}
end_function

begin_function
name|int
name|infra_host
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|uint32_t
name|timenow
parameter_list|,
name|int
modifier|*
name|edns_vs
parameter_list|,
name|uint8_t
modifier|*
name|edns_lame_known
parameter_list|,
name|int
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
init|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|infra_data
modifier|*
name|data
decl_stmt|;
name|int
name|wr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|e
operator|&&
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|ttl
operator|<
name|timenow
condition|)
block|{
comment|/* it expired, try to reuse existing entry */
name|int
name|old
init|=
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|rtt
operator|.
name|rto
decl_stmt|;
name|uint8_t
name|tA
init|=
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|timeout_A
decl_stmt|;
name|uint8_t
name|tAAAA
init|=
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|timeout_AAAA
decl_stmt|;
name|uint8_t
name|tother
init|=
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|timeout_other
decl_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|e
operator|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
comment|/* if its still there we have a writelock, init */
comment|/* re-initialise */
comment|/* do not touch lameness, it may be valid still */
name|data_entry_init
argument_list|(
name|infra
argument_list|,
name|e
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
name|wr
operator|=
literal|1
expr_stmt|;
comment|/* TOP_TIMEOUT remains on reuse */
if|if
condition|(
name|old
operator|>=
name|USEFUL_SERVER_TOP_TIMEOUT
condition|)
block|{
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|rtt
operator|.
name|rto
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
expr_stmt|;
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|timeout_A
operator|=
name|tA
expr_stmt|;
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|timeout_AAAA
operator|=
name|tAAAA
expr_stmt|;
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|timeout_other
operator|=
name|tother
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* insert new entry */
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|new_entry
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|timenow
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
operator|*
name|edns_vs
operator|=
name|data
operator|->
name|edns_version
expr_stmt|;
operator|*
name|edns_lame_known
operator|=
name|data
operator|->
name|edns_lame_known
expr_stmt|;
operator|*
name|to
operator|=
name|rtt_timeout
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|)
expr_stmt|;
name|slabhash_insert
argument_list|(
name|infra
operator|->
name|hosts
argument_list|,
name|e
operator|->
name|hash
argument_list|,
name|e
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* use existing entry */
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
operator|*
name|edns_vs
operator|=
name|data
operator|->
name|edns_version
expr_stmt|;
operator|*
name|edns_lame_known
operator|=
name|data
operator|->
name|edns_lame_known
expr_stmt|;
operator|*
name|to
operator|=
name|rtt_timeout
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|to
operator|>=
name|PROBE_MAXRTO
operator|&&
name|rtt_notimeout
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|)
operator|*
literal|4
operator|<=
operator|*
name|to
condition|)
block|{
comment|/* delay other queries, this is the probe query */
if|if
condition|(
operator|!
name|wr
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|e
operator|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* flushed from cache real fast, no use to 				allocate just for the probedelay */
return|return
literal|1
return|;
block|}
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
block|}
comment|/* add 999 to round up the timeout value from msec to sec, 		 * then add a whole second so it is certain that this probe 		 * has timed out before the next is allowed */
name|data
operator|->
name|probedelay
operator|=
name|timenow
operator|+
operator|(
operator|(
operator|*
name|to
operator|)
operator|+
literal|1999
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|infra_set_lame
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|uint32_t
name|timenow
parameter_list|,
name|int
name|dnsseclame
parameter_list|,
name|int
name|reclame
parameter_list|,
name|uint16_t
name|qtype
parameter_list|)
block|{
name|struct
name|infra_data
modifier|*
name|data
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|int
name|needtoinsert
init|=
literal|0
decl_stmt|;
name|e
operator|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* insert it */
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|new_entry
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|timenow
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"set_lame: malloc failure"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|needtoinsert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|ttl
operator|<
name|timenow
condition|)
block|{
comment|/* expired, reuse existing entry */
name|data_entry_init
argument_list|(
name|infra
argument_list|,
name|e
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
block|}
comment|/* got an entry, now set the zone lame */
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
comment|/* merge data (if any) */
if|if
condition|(
name|dnsseclame
condition|)
name|data
operator|->
name|isdnsseclame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reclame
condition|)
name|data
operator|->
name|rec_lame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|dnsseclame
operator|&&
operator|!
name|reclame
operator|&&
name|qtype
operator|==
name|LDNS_RR_TYPE_A
condition|)
name|data
operator|->
name|lame_type_A
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|dnsseclame
operator|&&
operator|!
name|reclame
operator|&&
name|qtype
operator|!=
name|LDNS_RR_TYPE_A
condition|)
name|data
operator|->
name|lame_other
operator|=
literal|1
expr_stmt|;
comment|/* done */
if|if
condition|(
name|needtoinsert
condition|)
name|slabhash_insert
argument_list|(
name|infra
operator|->
name|hosts
argument_list|,
name|e
operator|->
name|hash
argument_list|,
name|e
argument_list|,
name|e
operator|->
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|infra_update_tcp_works
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
init|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|infra_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return;
comment|/* doesn't exist */
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|rtt
operator|.
name|rto
operator|>=
name|RTT_MAX_TIMEOUT
condition|)
comment|/* do not disqualify this server altogether, it is better 		 * than nothing */
name|data
operator|->
name|rtt
operator|.
name|rto
operator|=
name|RTT_MAX_TIMEOUT
operator|-
literal|1000
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|infra_rtt_update
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|roundtrip
parameter_list|,
name|int
name|orig_rtt
parameter_list|,
name|uint32_t
name|timenow
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
init|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|infra_data
modifier|*
name|data
decl_stmt|;
name|int
name|needtoinsert
init|=
literal|0
decl_stmt|;
name|int
name|rto
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|new_entry
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|timenow
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|needtoinsert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|ttl
operator|<
name|timenow
condition|)
block|{
name|data_entry_init
argument_list|(
name|infra
argument_list|,
name|e
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
block|}
comment|/* have an entry, update the rtt */
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|roundtrip
operator|==
operator|-
literal|1
condition|)
block|{
name|rtt_lost
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|,
name|orig_rtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|LDNS_RR_TYPE_A
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|timeout_A
operator|<
name|TIMEOUT_COUNT_MAX
condition|)
name|data
operator|->
name|timeout_A
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|timeout_AAAA
operator|<
name|TIMEOUT_COUNT_MAX
condition|)
name|data
operator|->
name|timeout_AAAA
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|timeout_other
operator|<
name|TIMEOUT_COUNT_MAX
condition|)
name|data
operator|->
name|timeout_other
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if we got a reply, but the old timeout was above server 		 * selection height, delete the timeout so the server is 		 * fully available again */
if|if
condition|(
name|rtt_unclamped
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|)
operator|>=
name|USEFUL_SERVER_TOP_TIMEOUT
condition|)
name|rtt_init
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|)
expr_stmt|;
name|rtt_update
argument_list|(
operator|&
name|data
operator|->
name|rtt
argument_list|,
name|roundtrip
argument_list|)
expr_stmt|;
name|data
operator|->
name|probedelay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|LDNS_RR_TYPE_A
condition|)
name|data
operator|->
name|timeout_A
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|qtype
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
name|data
operator|->
name|timeout_AAAA
operator|=
literal|0
expr_stmt|;
else|else
name|data
operator|->
name|timeout_other
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|rtt
operator|.
name|rto
operator|>
literal|0
condition|)
name|rto
operator|=
name|data
operator|->
name|rtt
operator|.
name|rto
expr_stmt|;
if|if
condition|(
name|needtoinsert
condition|)
name|slabhash_insert
argument_list|(
name|infra
operator|->
name|hosts
argument_list|,
name|e
operator|->
name|hash
argument_list|,
name|e
argument_list|,
name|e
operator|->
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|rto
return|;
block|}
end_function

begin_function
name|int
name|infra_get_host_rto
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|struct
name|rtt_info
modifier|*
name|rtt
parameter_list|,
name|int
modifier|*
name|delay
parameter_list|,
name|uint32_t
name|timenow
parameter_list|,
name|int
modifier|*
name|tA
parameter_list|,
name|int
modifier|*
name|tAAAA
parameter_list|,
name|int
modifier|*
name|tother
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
init|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|infra_data
modifier|*
name|data
decl_stmt|;
name|int
name|ttl
init|=
operator|-
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ttl
operator|>=
name|timenow
condition|)
block|{
name|ttl
operator|=
call|(
name|int
call|)
argument_list|(
name|data
operator|->
name|ttl
operator|-
name|timenow
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rtt
argument_list|,
operator|&
name|data
operator|->
name|rtt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rtt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timenow
operator|<
name|data
operator|->
name|probedelay
condition|)
operator|*
name|delay
operator|=
call|(
name|int
call|)
argument_list|(
name|data
operator|->
name|probedelay
operator|-
name|timenow
argument_list|)
expr_stmt|;
else|else
operator|*
name|delay
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|tA
operator|=
operator|(
name|int
operator|)
name|data
operator|->
name|timeout_A
expr_stmt|;
operator|*
name|tAAAA
operator|=
operator|(
name|int
operator|)
name|data
operator|->
name|timeout_AAAA
expr_stmt|;
operator|*
name|tother
operator|=
operator|(
name|int
operator|)
name|data
operator|->
name|timeout_other
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ttl
return|;
block|}
end_function

begin_function
name|int
name|infra_edns_update
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|int
name|edns_version
parameter_list|,
name|uint32_t
name|timenow
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
init|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|infra_data
modifier|*
name|data
decl_stmt|;
name|int
name|needtoinsert
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|new_entry
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|timenow
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|needtoinsert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|ttl
operator|<
name|timenow
condition|)
block|{
name|data_entry_init
argument_list|(
name|infra
argument_list|,
name|e
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
block|}
comment|/* have an entry, update the rtt, and the ttl */
name|data
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
comment|/* do not update if noEDNS and stored is yesEDNS */
if|if
condition|(
operator|!
operator|(
name|edns_version
operator|==
operator|-
literal|1
operator|&&
operator|(
name|data
operator|->
name|edns_version
operator|!=
operator|-
literal|1
operator|&&
name|data
operator|->
name|edns_lame_known
operator|)
operator|)
condition|)
block|{
name|data
operator|->
name|edns_version
operator|=
name|edns_version
expr_stmt|;
name|data
operator|->
name|edns_lame_known
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|needtoinsert
condition|)
name|slabhash_insert
argument_list|(
name|infra
operator|->
name|hosts
argument_list|,
name|e
operator|->
name|hash
argument_list|,
name|e
argument_list|,
name|e
operator|->
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|infra_get_lame_rtt
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|int
modifier|*
name|lame
parameter_list|,
name|int
modifier|*
name|dnsseclame
parameter_list|,
name|int
modifier|*
name|reclame
parameter_list|,
name|int
modifier|*
name|rtt
parameter_list|,
name|uint32_t
name|timenow
parameter_list|)
block|{
name|struct
name|infra_data
modifier|*
name|host
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|e
init|=
name|infra_lookup_nottl
argument_list|(
name|infra
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
name|host
operator|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
operator|*
name|rtt
operator|=
name|rtt_unclamped
argument_list|(
operator|&
name|host
operator|->
name|rtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|->
name|rtt
operator|.
name|rto
operator|>=
name|PROBE_MAXRTO
operator|&&
name|timenow
operator|<
name|host
operator|->
name|probedelay
operator|&&
name|rtt_notimeout
argument_list|(
operator|&
name|host
operator|->
name|rtt
argument_list|)
operator|*
literal|4
operator|<=
name|host
operator|->
name|rtt
operator|.
name|rto
condition|)
block|{
comment|/* single probe for this domain, and we are not probing */
comment|/* unless the query type allows a probe to happen */
if|if
condition|(
name|qtype
operator|==
name|LDNS_RR_TYPE_A
condition|)
block|{
if|if
condition|(
name|host
operator|->
name|timeout_A
operator|>=
name|TIMEOUT_COUNT_MAX
condition|)
operator|*
name|rtt
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
expr_stmt|;
else|else
operator|*
name|rtt
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
operator|-
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
if|if
condition|(
name|host
operator|->
name|timeout_AAAA
operator|>=
name|TIMEOUT_COUNT_MAX
condition|)
operator|*
name|rtt
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
expr_stmt|;
else|else
operator|*
name|rtt
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
operator|-
literal|1000
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|host
operator|->
name|timeout_other
operator|>=
name|TIMEOUT_COUNT_MAX
condition|)
operator|*
name|rtt
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
expr_stmt|;
else|else
operator|*
name|rtt
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
operator|-
literal|1000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timenow
operator|>
name|host
operator|->
name|ttl
condition|)
block|{
comment|/* expired entry */
comment|/* see if this can be a re-probe of an unresponsive server */
comment|/* minus 1000 because that is outside of the RTTBAND, so 		 * blacklisted servers stay blacklisted if this is chosen */
if|if
condition|(
name|host
operator|->
name|rtt
operator|.
name|rto
operator|>=
name|USEFUL_SERVER_TOP_TIMEOUT
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|rtt
operator|=
name|USEFUL_SERVER_TOP_TIMEOUT
operator|-
literal|1000
expr_stmt|;
operator|*
name|lame
operator|=
literal|0
expr_stmt|;
operator|*
name|dnsseclame
operator|=
literal|0
expr_stmt|;
operator|*
name|reclame
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check lameness first */
if|if
condition|(
name|host
operator|->
name|lame_type_A
operator|&&
name|qtype
operator|==
name|LDNS_RR_TYPE_A
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|lame
operator|=
literal|1
expr_stmt|;
operator|*
name|dnsseclame
operator|=
literal|0
expr_stmt|;
operator|*
name|reclame
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|host
operator|->
name|lame_other
operator|&&
name|qtype
operator|!=
name|LDNS_RR_TYPE_A
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|lame
operator|=
literal|1
expr_stmt|;
operator|*
name|dnsseclame
operator|=
literal|0
expr_stmt|;
operator|*
name|reclame
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|host
operator|->
name|isdnsseclame
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|lame
operator|=
literal|0
expr_stmt|;
operator|*
name|dnsseclame
operator|=
literal|1
expr_stmt|;
operator|*
name|reclame
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|host
operator|->
name|rec_lame
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|lame
operator|=
literal|0
expr_stmt|;
operator|*
name|dnsseclame
operator|=
literal|0
expr_stmt|;
operator|*
name|reclame
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* no lameness for this type of query */
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|lame
operator|=
literal|0
expr_stmt|;
operator|*
name|dnsseclame
operator|=
literal|0
expr_stmt|;
operator|*
name|reclame
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|size_t
name|infra_get_mem
parameter_list|(
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
operator|*
name|infra
argument_list|)
operator|+
name|slabhash_get_mem
argument_list|(
name|infra
operator|->
name|hosts
argument_list|)
return|;
block|}
end_function

end_unit

