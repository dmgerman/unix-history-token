begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lz_decoder.c
end_comment

begin_comment
comment|/// \brief      LZ out window
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//  Authors:    Igor Pavlov
end_comment

begin_comment
comment|//              Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// liblzma supports multiple LZ77-based filters. The LZ part is shared
end_comment

begin_comment
comment|// between these filters. The LZ code takes care of dictionary handling
end_comment

begin_comment
comment|// and passing the data between filters in the chain. The filter-specific
end_comment

begin_comment
comment|// part decodes from the input buffer to the dictionary.
end_comment

begin_include
include|#
directive|include
file|"lz_decoder.h"
end_include

begin_struct
struct|struct
name|lzma_coder_s
block|{
comment|/// Dictionary (history buffer)
name|lzma_dict
name|dict
decl_stmt|;
comment|/// The actual LZ-based decoder e.g. LZMA
name|lzma_lz_decoder
name|lz
decl_stmt|;
comment|/// Next filter in the chain, if any. Note that LZMA and LZMA2 are
comment|/// only allowed as the last filter, but the long-range filter in
comment|/// future can be in the middle of the chain.
name|lzma_next_coder
name|next
decl_stmt|;
comment|/// True if the next filter in the chain has returned LZMA_STREAM_END.
name|bool
name|next_finished
decl_stmt|;
comment|/// True if the LZ decoder (e.g. LZMA) has detected end of payload
comment|/// marker. This may become true before next_finished becomes true.
name|bool
name|this_finished
decl_stmt|;
comment|/// Temporary buffer needed when the LZ-based filter is not the last
comment|/// filter in the chain. The output of the next filter is first
comment|/// decoded into buffer[], which is then used as input for the actual
comment|/// LZ-based decoder.
struct|struct
block|{
name|size_t
name|pos
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint8_t
name|buffer
index|[
name|LZMA_BUFFER_SIZE
index|]
decl_stmt|;
block|}
name|temp
struct|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|lz_decoder_reset
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|)
block|{
name|coder
operator|->
name|dict
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|dict
operator|.
name|full
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|dict
operator|.
name|buf
index|[
name|coder
operator|->
name|dict
operator|.
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|coder
operator|->
name|dict
operator|.
name|need_reset
operator|=
name|false
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|decode_buffer
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
comment|// Wrap the dictionary if needed.
if|if
condition|(
name|coder
operator|->
name|dict
operator|.
name|pos
operator|==
name|coder
operator|->
name|dict
operator|.
name|size
condition|)
name|coder
operator|->
name|dict
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
comment|// Store the current dictionary position. It is needed to know
comment|// where to start copying to the out[] buffer.
specifier|const
name|size_t
name|dict_start
init|=
name|coder
operator|->
name|dict
operator|.
name|pos
decl_stmt|;
comment|// Calculate how much we allow coder->lz.code() to decode.
comment|// It must not decode past the end of the dictionary
comment|// buffer, and we don't want it to decode more than is
comment|// actually needed to fill the out[] buffer.
name|coder
operator|->
name|dict
operator|.
name|limit
operator|=
name|coder
operator|->
name|dict
operator|.
name|pos
operator|+
name|my_min
argument_list|(
name|out_size
operator|-
operator|*
name|out_pos
argument_list|,
name|coder
operator|->
name|dict
operator|.
name|size
operator|-
name|coder
operator|->
name|dict
operator|.
name|pos
argument_list|)
expr_stmt|;
comment|// Call the coder->lz.code() to do the actual decoding.
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|lz
operator|.
name|code
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
operator|&
name|coder
operator|->
name|dict
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|)
decl_stmt|;
comment|// Copy the decoded data from the dictionary to the out[]
comment|// buffer.
specifier|const
name|size_t
name|copy_size
init|=
name|coder
operator|->
name|dict
operator|.
name|pos
operator|-
name|dict_start
decl_stmt|;
name|assert
argument_list|(
name|copy_size
operator|<=
name|out_size
operator|-
operator|*
name|out_pos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
operator|+
operator|*
name|out_pos
argument_list|,
name|coder
operator|->
name|dict
operator|.
name|buf
operator|+
name|dict_start
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
operator|*
name|out_pos
operator|+=
name|copy_size
expr_stmt|;
comment|// Reset the dictionary if so requested by coder->lz.code().
if|if
condition|(
name|coder
operator|->
name|dict
operator|.
name|need_reset
condition|)
block|{
name|lz_decoder_reset
argument_list|(
name|coder
argument_list|)
expr_stmt|;
comment|// Since we reset dictionary, we don't check if
comment|// dictionary became full.
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
operator|||
operator|*
name|out_pos
operator|==
name|out_size
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
comment|// Return if everything got decoded or an error
comment|// occurred, or if there's no more data to decode.
comment|//
comment|// Note that detecting if there's something to decode
comment|// is done by looking if dictionary become full
comment|// instead of looking if *in_pos == in_size. This
comment|// is because it is possible that all the input was
comment|// consumed already but some data is pending to be
comment|// written to the dictionary.
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
operator|||
operator|*
name|out_pos
operator|==
name|out_size
operator|||
name|coder
operator|->
name|dict
operator|.
name|pos
operator|<
name|coder
operator|->
name|dict
operator|.
name|size
condition|)
return|return
name|ret
return|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|lzma_ret
name|lz_decode
argument_list|(
name|lzma_coder
operator|*
name|coder
argument_list|,
name|lzma_allocator
operator|*
name|allocator
name|lzma_attribute
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|uint8_t
operator|*
specifier|restrict
name|in
argument_list|,
name|size_t
operator|*
specifier|restrict
name|in_pos
argument_list|,
name|size_t
name|in_size
argument_list|,
name|uint8_t
operator|*
specifier|restrict
name|out
argument_list|,
name|size_t
operator|*
specifier|restrict
name|out_pos
argument_list|,
name|size_t
name|out_size
argument_list|,
name|lzma_action
name|action
argument_list|)
block|{
if|if
condition|(
name|coder
operator|->
name|next
operator|.
name|code
operator|==
name|NULL
condition|)
return|return
name|decode_buffer
argument_list|(
name|coder
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
return|;
comment|// We aren't the last coder in the chain, we need to decode
comment|// our input to a temporary buffer.
while|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
condition|)
block|{
comment|// Fill the temporary buffer if it is empty.
if|if
condition|(
operator|!
name|coder
operator|->
name|next_finished
operator|&&
name|coder
operator|->
name|temp
operator|.
name|pos
operator|==
name|coder
operator|->
name|temp
operator|.
name|size
condition|)
block|{
name|coder
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|temp
operator|.
name|size
argument_list|,
name|LZMA_BUFFER_SIZE
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
name|coder
operator|->
name|next_finished
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
operator|||
name|coder
operator|->
name|temp
operator|.
name|size
operator|==
literal|0
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|coder
operator|->
name|this_finished
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|temp
operator|.
name|size
operator|!=
literal|0
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
if|if
condition|(
name|coder
operator|->
name|next_finished
condition|)
return|return
name|LZMA_STREAM_END
return|;
return|return
name|LZMA_OK
return|;
block|}
specifier|const
name|lzma_ret
name|ret
init|=
name|decode_buffer
argument_list|(
name|coder
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|temp
operator|.
name|pos
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
name|coder
operator|->
name|this_finished
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
elseif|else
if|if
condition|(
name|coder
operator|->
name|next_finished
operator|&&
operator|*
name|out_pos
operator|<
name|out_size
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|lz_decoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|dict
operator|.
name|buf
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|lz
operator|.
name|end
operator|!=
name|NULL
condition|)
name|coder
operator|->
name|lz
operator|.
name|end
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
else|else
name|lzma_free
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_lz_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|,
name|lzma_ret
function_decl|(
modifier|*
name|lz_init
function_decl|)
parameter_list|(
name|lzma_lz_decoder
modifier|*
name|lz
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|options
parameter_list|,
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
parameter_list|)
block|{
comment|// Allocate the base structure if it isn't already allocated.
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|lz_decode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|lz_decoder_end
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|lz
operator|=
name|LZMA_LZ_DECODER_INIT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
block|}
comment|// Allocate and initialize the LZ-based decoder. It will also give
comment|// us the dictionary size.
name|lzma_lz_options
name|lz_options
decl_stmt|;
name|return_if_error
argument_list|(
name|lz_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|lz
argument_list|,
name|allocator
argument_list|,
name|filters
index|[
literal|0
index|]
operator|.
name|options
argument_list|,
operator|&
name|lz_options
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the dictionary size is very small, increase it to 4096 bytes.
comment|// This is to prevent constant wrapping of the dictionary, which
comment|// would slow things down. The downside is that since we don't check
comment|// separately for the real dictionary size, we may happily accept
comment|// corrupt files.
if|if
condition|(
name|lz_options
operator|.
name|dict_size
operator|<
literal|4096
condition|)
name|lz_options
operator|.
name|dict_size
operator|=
literal|4096
expr_stmt|;
comment|// Make dictionary size a multipe of 16. Some LZ-based decoders like
comment|// LZMA use the lowest bits lzma_dict.pos to know the alignment of the
comment|// data. Aligned buffer is also good when memcpying from the
comment|// dictionary to the output buffer, since applications are
comment|// recommended to give aligned buffers to liblzma.
comment|//
comment|// Avoid integer overflow.
if|if
condition|(
name|lz_options
operator|.
name|dict_size
operator|>
name|SIZE_MAX
operator|-
literal|15
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|lz_options
operator|.
name|dict_size
operator|=
operator|(
name|lz_options
operator|.
name|dict_size
operator|+
literal|15
operator|)
operator|&
operator|~
operator|(
call|(
name|size_t
call|)
argument_list|(
literal|15
argument_list|)
operator|)
expr_stmt|;
comment|// Allocate and initialize the dictionary.
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|size
operator|!=
name|lz_options
operator|.
name|dict_size
condition|)
block|{
name|lzma_free
argument_list|(
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|buf
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|buf
operator|=
name|lzma_alloc
argument_list|(
name|lz_options
operator|.
name|dict_size
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|buf
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|size
operator|=
name|lz_options
operator|.
name|dict_size
expr_stmt|;
block|}
name|lz_decoder_reset
argument_list|(
name|next
operator|->
name|coder
argument_list|)
expr_stmt|;
comment|// Use the preset dictionary if it was given to us.
if|if
condition|(
name|lz_options
operator|.
name|preset_dict
operator|!=
name|NULL
operator|&&
name|lz_options
operator|.
name|preset_dict_size
operator|>
literal|0
condition|)
block|{
comment|// If the preset dictionary is bigger than the actual
comment|// dictionary, copy only the tail.
specifier|const
name|size_t
name|copy_size
init|=
name|my_min
argument_list|(
name|lz_options
operator|.
name|preset_dict_size
argument_list|,
name|lz_options
operator|.
name|dict_size
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|offset
init|=
name|lz_options
operator|.
name|preset_dict_size
operator|-
name|copy_size
decl_stmt|;
name|memcpy
argument_list|(
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|buf
argument_list|,
name|lz_options
operator|.
name|preset_dict
operator|+
name|offset
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|pos
operator|=
name|copy_size
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|dict
operator|.
name|full
operator|=
name|copy_size
expr_stmt|;
block|}
comment|// Miscellaneous initializations
name|next
operator|->
name|coder
operator|->
name|next_finished
operator|=
name|false
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|this_finished
operator|=
name|false
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
comment|// Initialize the next filter in the chain, if any.
return|return
name|lzma_next_filter_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|uint64_t
name|lzma_lz_decoder_memusage
parameter_list|(
name|size_t
name|dictionary_size
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
operator|+
call|(
name|uint64_t
call|)
argument_list|(
name|dictionary_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_lz_decoder_uncompressed
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_vli
name|uncompressed_size
parameter_list|)
block|{
name|coder
operator|->
name|lz
operator|.
name|set_uncompressed
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
name|uncompressed_size
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

