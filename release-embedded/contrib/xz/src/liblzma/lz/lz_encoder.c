begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lz_encoder.c
end_comment

begin_comment
comment|/// \brief      LZ in window
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//  Authors:    Igor Pavlov
end_comment

begin_comment
comment|//              Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"lz_encoder.h"
end_include

begin_include
include|#
directive|include
file|"lz_encoder_hash.h"
end_include

begin_comment
comment|// See lz_encoder_hash.h. This is a bit hackish but avoids making
end_comment

begin_comment
comment|// endianness a conditional in makefiles.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WORDS_BIGENDIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SMALL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"lz_encoder_hash_table.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|lzma_coder_s
block|{
comment|/// LZ-based encoder e.g. LZMA
name|lzma_lz_encoder
name|lz
decl_stmt|;
comment|/// History buffer and match finder
name|lzma_mf
name|mf
decl_stmt|;
comment|/// Next coder in the chain
name|lzma_next_coder
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/// \brief      Moves the data in the input window to free space for new data
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// mf->buffer is a sliding input window, which keeps mf->keep_size_before
end_comment

begin_comment
comment|/// bytes of input history available all the time. Now and then we need to
end_comment

begin_comment
comment|/// "slide" the buffer to make space for the new data to the end of the
end_comment

begin_comment
comment|/// buffer. At the same time, data older than keep_size_before is dropped.
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
name|void
name|move_window
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|)
block|{
comment|// Align the move to a multiple of 16 bytes. Some LZ-based encoders
comment|// like LZMA use the lowest bits of mf->read_pos to know the
comment|// alignment of the uncompressed data. We also get better speed
comment|// for memmove() with aligned buffers.
name|assert
argument_list|(
name|mf
operator|->
name|read_pos
operator|>
name|mf
operator|->
name|keep_size_before
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|move_offset
init|=
operator|(
name|mf
operator|->
name|read_pos
operator|-
name|mf
operator|->
name|keep_size_before
operator|)
operator|&
operator|~
name|UINT32_C
argument_list|(
literal|15
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|mf
operator|->
name|write_pos
operator|>
name|move_offset
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|move_size
init|=
name|mf
operator|->
name|write_pos
operator|-
name|move_offset
decl_stmt|;
name|assert
argument_list|(
name|move_offset
operator|+
name|move_size
operator|<=
name|mf
operator|->
name|size
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|mf
operator|->
name|buffer
argument_list|,
name|mf
operator|->
name|buffer
operator|+
name|move_offset
argument_list|,
name|move_size
argument_list|)
expr_stmt|;
name|mf
operator|->
name|offset
operator|+=
name|move_offset
expr_stmt|;
name|mf
operator|->
name|read_pos
operator|-=
name|move_offset
expr_stmt|;
name|mf
operator|->
name|read_limit
operator|-=
name|move_offset
expr_stmt|;
name|mf
operator|->
name|write_pos
operator|-=
name|move_offset
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// \brief      Tries to fill the input window (mf->buffer)
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If we are the last encoder in the chain, our input data is in in[].
end_comment

begin_comment
comment|/// Otherwise we call the next filter in the chain to process in[] and
end_comment

begin_comment
comment|/// write its output to mf->buffer.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This function must not be called once it has returned LZMA_STREAM_END.
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
name|lzma_ret
name|fill_window
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|in
parameter_list|,
name|size_t
modifier|*
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
name|assert
argument_list|(
name|coder
operator|->
name|mf
operator|.
name|read_pos
operator|<=
name|coder
operator|->
name|mf
operator|.
name|write_pos
argument_list|)
expr_stmt|;
comment|// Move the sliding window if needed.
if|if
condition|(
name|coder
operator|->
name|mf
operator|.
name|read_pos
operator|>=
name|coder
operator|->
name|mf
operator|.
name|size
operator|-
name|coder
operator|->
name|mf
operator|.
name|keep_size_after
condition|)
name|move_window
argument_list|(
operator|&
name|coder
operator|->
name|mf
argument_list|)
expr_stmt|;
comment|// Maybe this is ugly, but lzma_mf uses uint32_t for most things
comment|// (which I find cleanest), but we need size_t here when filling
comment|// the history window.
name|size_t
name|write_pos
init|=
name|coder
operator|->
name|mf
operator|.
name|write_pos
decl_stmt|;
name|lzma_ret
name|ret
decl_stmt|;
if|if
condition|(
name|coder
operator|->
name|next
operator|.
name|code
operator|==
name|NULL
condition|)
block|{
comment|// Not using a filter, simply memcpy() as much as possible.
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|mf
operator|.
name|buffer
argument_list|,
operator|&
name|write_pos
argument_list|,
name|coder
operator|->
name|mf
operator|.
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|action
operator|!=
name|LZMA_RUN
operator|&&
operator|*
name|in_pos
operator|==
name|in_size
condition|?
name|LZMA_STREAM_END
else|:
name|LZMA_OK
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|mf
operator|.
name|buffer
argument_list|,
operator|&
name|write_pos
argument_list|,
name|coder
operator|->
name|mf
operator|.
name|size
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
name|coder
operator|->
name|mf
operator|.
name|write_pos
operator|=
name|write_pos
expr_stmt|;
comment|// If end of stream has been reached or flushing completed, we allow
comment|// the encoder to process all the input (that is, read_pos is allowed
comment|// to reach write_pos). Otherwise we keep keep_size_after bytes
comment|// available as prebuffer.
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
name|assert
argument_list|(
operator|*
name|in_pos
operator|==
name|in_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|LZMA_OK
expr_stmt|;
name|coder
operator|->
name|mf
operator|.
name|action
operator|=
name|action
expr_stmt|;
name|coder
operator|->
name|mf
operator|.
name|read_limit
operator|=
name|coder
operator|->
name|mf
operator|.
name|write_pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|->
name|mf
operator|.
name|write_pos
operator|>
name|coder
operator|->
name|mf
operator|.
name|keep_size_after
condition|)
block|{
comment|// This needs to be done conditionally, because if we got
comment|// only little new input, there may be too little input
comment|// to do any encoding yet.
name|coder
operator|->
name|mf
operator|.
name|read_limit
operator|=
name|coder
operator|->
name|mf
operator|.
name|write_pos
operator|-
name|coder
operator|->
name|mf
operator|.
name|keep_size_after
expr_stmt|;
block|}
comment|// Restart the match finder after finished LZMA_SYNC_FLUSH.
if|if
condition|(
name|coder
operator|->
name|mf
operator|.
name|pending
operator|>
literal|0
operator|&&
name|coder
operator|->
name|mf
operator|.
name|read_pos
operator|<
name|coder
operator|->
name|mf
operator|.
name|read_limit
condition|)
block|{
comment|// Match finder may update coder->pending and expects it to
comment|// start from zero, so use a temporary variable.
specifier|const
name|size_t
name|pending
init|=
name|coder
operator|->
name|mf
operator|.
name|pending
decl_stmt|;
name|coder
operator|->
name|mf
operator|.
name|pending
operator|=
literal|0
expr_stmt|;
comment|// Rewind read_pos so that the match finder can hash
comment|// the pending bytes.
name|assert
argument_list|(
name|coder
operator|->
name|mf
operator|.
name|read_pos
operator|>=
name|pending
argument_list|)
expr_stmt|;
name|coder
operator|->
name|mf
operator|.
name|read_pos
operator|-=
name|pending
expr_stmt|;
comment|// Call the skip function directly instead of using
comment|// mf_skip(), since we don't want to touch mf->read_ahead.
name|coder
operator|->
name|mf
operator|.
name|skip
argument_list|(
operator|&
name|coder
operator|->
name|mf
argument_list|,
name|pending
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|lz_encode
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
while|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
operator|&&
operator|(
operator|*
name|in_pos
operator|<
name|in_size
operator|||
name|action
operator|!=
name|LZMA_RUN
operator|)
condition|)
block|{
comment|// Read more data to coder->mf.buffer if needed.
if|if
condition|(
name|coder
operator|->
name|mf
operator|.
name|action
operator|==
name|LZMA_RUN
operator|&&
name|coder
operator|->
name|mf
operator|.
name|read_pos
operator|>=
name|coder
operator|->
name|mf
operator|.
name|read_limit
condition|)
name|return_if_error
argument_list|(
name|fill_window
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|action
argument_list|)
argument_list|)
expr_stmt|;
comment|// Encode
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|lz
operator|.
name|code
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
operator|&
name|coder
operator|->
name|mf
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
comment|// Setting this to LZMA_RUN for cases when we are
comment|// flushing. It doesn't matter when finishing or if
comment|// an error occurred.
name|coder
operator|->
name|mf
operator|.
name|action
operator|=
name|LZMA_RUN
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|lz_encoder_prepare
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
block|{
comment|// For now, the dictionary size is limited to 1.5 GiB. This may grow
comment|// in the future if needed, but it needs a little more work than just
comment|// changing this check.
if|if
condition|(
name|lz_options
operator|->
name|dict_size
operator|<
name|LZMA_DICT_SIZE_MIN
operator|||
name|lz_options
operator|->
name|dict_size
operator|>
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|30
operator|)
operator|+
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|29
operator|)
operator|||
name|lz_options
operator|->
name|nice_len
operator|>
name|lz_options
operator|->
name|match_len_max
condition|)
return|return
name|true
return|;
name|mf
operator|->
name|keep_size_before
operator|=
name|lz_options
operator|->
name|before_size
operator|+
name|lz_options
operator|->
name|dict_size
expr_stmt|;
name|mf
operator|->
name|keep_size_after
operator|=
name|lz_options
operator|->
name|after_size
operator|+
name|lz_options
operator|->
name|match_len_max
expr_stmt|;
comment|// To avoid constant memmove()s, allocate some extra space. Since
comment|// memmove()s become more expensive when the size of the buffer
comment|// increases, we reserve more space when a large dictionary is
comment|// used to make the memmove() calls rarer.
comment|//
comment|// This works with dictionaries up to about 3 GiB. If bigger
comment|// dictionary is wanted, some extra work is needed:
comment|//   - Several variables in lzma_mf have to be changed from uint32_t
comment|//     to size_t.
comment|//   - Memory usage calculation needs something too, e.g. use uint64_t
comment|//     for mf->size.
name|uint32_t
name|reserve
init|=
name|lz_options
operator|->
name|dict_size
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|reserve
operator|>
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|30
operator|)
condition|)
name|reserve
operator|/=
literal|2
expr_stmt|;
name|reserve
operator|+=
operator|(
name|lz_options
operator|->
name|before_size
operator|+
name|lz_options
operator|->
name|match_len_max
operator|+
name|lz_options
operator|->
name|after_size
operator|)
operator|/
literal|2
operator|+
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|19
operator|)
expr_stmt|;
specifier|const
name|uint32_t
name|old_size
init|=
name|mf
operator|->
name|size
decl_stmt|;
name|mf
operator|->
name|size
operator|=
name|mf
operator|->
name|keep_size_before
operator|+
name|reserve
operator|+
name|mf
operator|->
name|keep_size_after
expr_stmt|;
comment|// Deallocate the old history buffer if it exists but has different
comment|// size than what is needed now.
if|if
condition|(
name|mf
operator|->
name|buffer
operator|!=
name|NULL
operator|&&
name|old_size
operator|!=
name|mf
operator|->
name|size
condition|)
block|{
name|lzma_free
argument_list|(
name|mf
operator|->
name|buffer
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|mf
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
comment|// Match finder options
name|mf
operator|->
name|match_len_max
operator|=
name|lz_options
operator|->
name|match_len_max
expr_stmt|;
name|mf
operator|->
name|nice_len
operator|=
name|lz_options
operator|->
name|nice_len
expr_stmt|;
comment|// cyclic_size has to stay smaller than 2 Gi. Note that this doesn't
comment|// mean limiting dictionary size to less than 2 GiB. With a match
comment|// finder that uses multibyte resolution (hashes start at e.g. every
comment|// fourth byte), cyclic_size would stay below 2 Gi even when
comment|// dictionary size is greater than 2 GiB.
comment|//
comment|// It would be possible to allow cyclic_size>= 2 Gi, but then we
comment|// would need to be careful to use 64-bit types in various places
comment|// (size_t could do since we would need bigger than 32-bit address
comment|// space anyway). It would also require either zeroing a multigigabyte
comment|// buffer at initialization (waste of time and RAM) or allow
comment|// normalization in lz_encoder_mf.c to access uninitialized
comment|// memory to keep the code simpler. The current way is simple and
comment|// still allows pretty big dictionaries, so I don't expect these
comment|// limits to change.
name|mf
operator|->
name|cyclic_size
operator|=
name|lz_options
operator|->
name|dict_size
operator|+
literal|1
expr_stmt|;
comment|// Validate the match finder ID and setup the function pointers.
switch|switch
condition|(
name|lz_options
operator|->
name|match_finder
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MF_HC3
case|case
name|LZMA_MF_HC3
case|:
name|mf
operator|->
name|find
operator|=
operator|&
name|lzma_mf_hc3_find
expr_stmt|;
name|mf
operator|->
name|skip
operator|=
operator|&
name|lzma_mf_hc3_skip
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_HC4
case|case
name|LZMA_MF_HC4
case|:
name|mf
operator|->
name|find
operator|=
operator|&
name|lzma_mf_hc4_find
expr_stmt|;
name|mf
operator|->
name|skip
operator|=
operator|&
name|lzma_mf_hc4_skip
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_BT2
case|case
name|LZMA_MF_BT2
case|:
name|mf
operator|->
name|find
operator|=
operator|&
name|lzma_mf_bt2_find
expr_stmt|;
name|mf
operator|->
name|skip
operator|=
operator|&
name|lzma_mf_bt2_skip
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_BT3
case|case
name|LZMA_MF_BT3
case|:
name|mf
operator|->
name|find
operator|=
operator|&
name|lzma_mf_bt3_find
expr_stmt|;
name|mf
operator|->
name|skip
operator|=
operator|&
name|lzma_mf_bt3_skip
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_BT4
case|case
name|LZMA_MF_BT4
case|:
name|mf
operator|->
name|find
operator|=
operator|&
name|lzma_mf_bt4_find
expr_stmt|;
name|mf
operator|->
name|skip
operator|=
operator|&
name|lzma_mf_bt4_skip
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|true
return|;
block|}
comment|// Calculate the sizes of mf->hash and mf->son and check that
comment|// nice_len is big enough for the selected match finder.
specifier|const
name|uint32_t
name|hash_bytes
init|=
name|lz_options
operator|->
name|match_finder
operator|&
literal|0x0F
decl_stmt|;
if|if
condition|(
name|hash_bytes
operator|>
name|mf
operator|->
name|nice_len
condition|)
return|return
name|true
return|;
specifier|const
name|bool
name|is_bt
init|=
operator|(
name|lz_options
operator|->
name|match_finder
operator|&
literal|0x10
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint32_t
name|hs
decl_stmt|;
if|if
condition|(
name|hash_bytes
operator|==
literal|2
condition|)
block|{
name|hs
operator|=
literal|0xFFFF
expr_stmt|;
block|}
else|else
block|{
comment|// Round dictionary size up to the next 2^n - 1 so it can
comment|// be used as a hash mask.
name|hs
operator|=
name|lz_options
operator|->
name|dict_size
operator|-
literal|1
expr_stmt|;
name|hs
operator||=
name|hs
operator|>>
literal|1
expr_stmt|;
name|hs
operator||=
name|hs
operator|>>
literal|2
expr_stmt|;
name|hs
operator||=
name|hs
operator|>>
literal|4
expr_stmt|;
name|hs
operator||=
name|hs
operator|>>
literal|8
expr_stmt|;
name|hs
operator|>>=
literal|1
expr_stmt|;
name|hs
operator||=
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|hs
operator|>
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|24
operator|)
condition|)
block|{
if|if
condition|(
name|hash_bytes
operator|==
literal|3
condition|)
name|hs
operator|=
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|24
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|hs
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
name|mf
operator|->
name|hash_mask
operator|=
name|hs
expr_stmt|;
operator|++
name|hs
expr_stmt|;
if|if
condition|(
name|hash_bytes
operator|>
literal|2
condition|)
name|hs
operator|+=
name|HASH_2_SIZE
expr_stmt|;
if|if
condition|(
name|hash_bytes
operator|>
literal|3
condition|)
name|hs
operator|+=
name|HASH_3_SIZE
expr_stmt|;
comment|/* 	No match finder uses this at the moment. 	if (mf->hash_bytes> 4) 		hs += HASH_4_SIZE; */
comment|// If the above code calculating hs is modified, make sure that
comment|// this assertion stays valid (UINT32_MAX / 5 is not strictly the
comment|// exact limit). If it doesn't, you need to calculate that
comment|// hash_size_sum + sons_count cannot overflow.
name|assert
argument_list|(
name|hs
operator|<
name|UINT32_MAX
operator|/
literal|5
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|old_count
init|=
name|mf
operator|->
name|hash_size_sum
operator|+
name|mf
operator|->
name|sons_count
decl_stmt|;
name|mf
operator|->
name|hash_size_sum
operator|=
name|hs
expr_stmt|;
name|mf
operator|->
name|sons_count
operator|=
name|mf
operator|->
name|cyclic_size
expr_stmt|;
if|if
condition|(
name|is_bt
condition|)
name|mf
operator|->
name|sons_count
operator|*=
literal|2
expr_stmt|;
specifier|const
name|uint32_t
name|new_count
init|=
name|mf
operator|->
name|hash_size_sum
operator|+
name|mf
operator|->
name|sons_count
decl_stmt|;
comment|// Deallocate the old hash array if it exists and has different size
comment|// than what is needed now.
if|if
condition|(
name|old_count
operator|!=
name|new_count
condition|)
block|{
name|lzma_free
argument_list|(
name|mf
operator|->
name|hash
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|mf
operator|->
name|hash
operator|=
name|NULL
expr_stmt|;
block|}
comment|// Maximum number of match finder cycles
name|mf
operator|->
name|depth
operator|=
name|lz_options
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|depth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_bt
condition|)
name|mf
operator|->
name|depth
operator|=
literal|16
operator|+
name|mf
operator|->
name|nice_len
operator|/
literal|2
expr_stmt|;
else|else
name|mf
operator|->
name|depth
operator|=
literal|4
operator|+
name|mf
operator|->
name|nice_len
operator|/
literal|4
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|lz_encoder_init
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
block|{
comment|// Allocate the history buffer.
if|if
condition|(
name|mf
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|mf
operator|->
name|buffer
operator|=
name|lzma_alloc
argument_list|(
name|mf
operator|->
name|size
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|buffer
operator|==
name|NULL
condition|)
return|return
name|true
return|;
block|}
comment|// Use cyclic_size as initial mf->offset. This allows
comment|// avoiding a few branches in the match finders. The downside is
comment|// that match finder needs to be normalized more often, which may
comment|// hurt performance with huge dictionaries.
name|mf
operator|->
name|offset
operator|=
name|mf
operator|->
name|cyclic_size
expr_stmt|;
name|mf
operator|->
name|read_pos
operator|=
literal|0
expr_stmt|;
name|mf
operator|->
name|read_ahead
operator|=
literal|0
expr_stmt|;
name|mf
operator|->
name|read_limit
operator|=
literal|0
expr_stmt|;
name|mf
operator|->
name|write_pos
operator|=
literal|0
expr_stmt|;
name|mf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
comment|// Allocate match finder's hash array.
specifier|const
name|size_t
name|alloc_count
init|=
name|mf
operator|->
name|hash_size_sum
operator|+
name|mf
operator|->
name|sons_count
decl_stmt|;
if|#
directive|if
name|UINT32_MAX
operator|>=
name|SIZE_MAX
operator|/
literal|4
comment|// Check for integer overflow. (Huge dictionaries are not
comment|// possible on 32-bit CPU.)
if|if
condition|(
name|alloc_count
operator|>
name|SIZE_MAX
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
name|true
return|;
endif|#
directive|endif
if|if
condition|(
name|mf
operator|->
name|hash
operator|==
name|NULL
condition|)
block|{
name|mf
operator|->
name|hash
operator|=
name|lzma_alloc
argument_list|(
name|alloc_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|hash
operator|==
name|NULL
condition|)
return|return
name|true
return|;
block|}
name|mf
operator|->
name|son
operator|=
name|mf
operator|->
name|hash
operator|+
name|mf
operator|->
name|hash_size_sum
expr_stmt|;
name|mf
operator|->
name|cyclic_pos
operator|=
literal|0
expr_stmt|;
comment|// Initialize the hash table. Since EMPTY_HASH_VALUE is zero, we
comment|// can use memset().
comment|/* 	for (uint32_t i = 0; i< hash_size_sum; ++i) 		mf->hash[i] = EMPTY_HASH_VALUE; */
name|memzero
argument_list|(
name|mf
operator|->
name|hash
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|mf
operator|->
name|hash_size_sum
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|// We don't need to initialize mf->son, but not doing that will
comment|// make Valgrind complain in normalization (see normalize() in
comment|// lz_encoder_mf.c).
comment|//
comment|// Skipping this initialization is *very* good when big dictionary is
comment|// used but only small amount of data gets actually compressed: most
comment|// of the mf->hash won't get actually allocated by the kernel, so
comment|// we avoid wasting RAM and improve initialization speed a lot.
comment|//memzero(mf->son, (size_t)(mf->sons_count) * sizeof(uint32_t));
comment|// Handle preset dictionary.
if|if
condition|(
name|lz_options
operator|->
name|preset_dict
operator|!=
name|NULL
operator|&&
name|lz_options
operator|->
name|preset_dict_size
operator|>
literal|0
condition|)
block|{
comment|// If the preset dictionary is bigger than the actual
comment|// dictionary, use only the tail.
name|mf
operator|->
name|write_pos
operator|=
name|my_min
argument_list|(
name|lz_options
operator|->
name|preset_dict_size
argument_list|,
name|mf
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mf
operator|->
name|buffer
argument_list|,
name|lz_options
operator|->
name|preset_dict
operator|+
name|lz_options
operator|->
name|preset_dict_size
operator|-
name|mf
operator|->
name|write_pos
argument_list|,
name|mf
operator|->
name|write_pos
argument_list|)
expr_stmt|;
name|mf
operator|->
name|action
operator|=
name|LZMA_SYNC_FLUSH
expr_stmt|;
name|mf
operator|->
name|skip
argument_list|(
name|mf
argument_list|,
name|mf
operator|->
name|write_pos
argument_list|)
expr_stmt|;
block|}
name|mf
operator|->
name|action
operator|=
name|LZMA_RUN
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|extern
name|uint64_t
name|lzma_lz_encoder_memusage
parameter_list|(
specifier|const
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
block|{
comment|// Old buffers must not exist when calling lz_encoder_prepare().
name|lzma_mf
name|mf
init|=
block|{
operator|.
name|buffer
operator|=
name|NULL
block|,
operator|.
name|hash
operator|=
name|NULL
block|,
operator|.
name|hash_size_sum
operator|=
literal|0
block|,
operator|.
name|sons_count
operator|=
literal|0
block|, 	}
decl_stmt|;
comment|// Setup the size information into mf.
if|if
condition|(
name|lz_encoder_prepare
argument_list|(
operator|&
name|mf
argument_list|,
name|NULL
argument_list|,
name|lz_options
argument_list|)
condition|)
return|return
name|UINT64_MAX
return|;
comment|// Calculate the memory usage.
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|mf
operator|.
name|hash_size_sum
operator|+
name|mf
operator|.
name|sons_count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
call|(
name|uint64_t
call|)
argument_list|(
name|mf
operator|.
name|size
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lz_encoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|mf
operator|.
name|hash
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|mf
operator|.
name|buffer
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|lz
operator|.
name|end
operator|!=
name|NULL
condition|)
name|coder
operator|->
name|lz
operator|.
name|end
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
else|else
name|lzma_free
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|lzma_ret
name|lz_encoder_update
argument_list|(
name|lzma_coder
operator|*
name|coder
argument_list|,
name|lzma_allocator
operator|*
name|allocator
argument_list|,
specifier|const
name|lzma_filter
operator|*
name|filters_null
name|lzma_attribute
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|lzma_filter
operator|*
name|reversed_filters
argument_list|)
block|{
if|if
condition|(
name|coder
operator|->
name|lz
operator|.
name|options_update
operator|==
name|NULL
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|return_if_error
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|options_update
argument_list|(
name|coder
operator|->
name|lz
operator|.
name|coder
argument_list|,
name|reversed_filters
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lzma_next_filter_update
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|reversed_filters
operator|+
literal|1
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|extern
name|lzma_ret
name|lzma_lz_encoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|,
name|lzma_ret
function_decl|(
modifier|*
name|lz_init
function_decl|)
parameter_list|(
name|lzma_lz_encoder
modifier|*
name|lz
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|options
parameter_list|,
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SMALL
comment|// We need that the CRC32 table has been initialized.
name|lzma_crc32_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Allocate and initialize the base data structure.
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|lz_encode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|lz_encoder_end
expr_stmt|;
name|next
operator|->
name|update
operator|=
operator|&
name|lz_encoder_update
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|lz
operator|.
name|coder
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|lz
operator|.
name|code
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|lz
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|mf
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|mf
operator|.
name|hash
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|mf
operator|.
name|hash_size_sum
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|mf
operator|.
name|sons_count
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
block|}
comment|// Initialize the LZ-based encoder.
name|lzma_lz_options
name|lz_options
decl_stmt|;
name|return_if_error
argument_list|(
name|lz_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|lz
argument_list|,
name|allocator
argument_list|,
name|filters
index|[
literal|0
index|]
operator|.
name|options
argument_list|,
operator|&
name|lz_options
argument_list|)
argument_list|)
expr_stmt|;
comment|// Setup the size information into next->coder->mf and deallocate
comment|// old buffers if they have wrong size.
if|if
condition|(
name|lz_encoder_prepare
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|mf
argument_list|,
name|allocator
argument_list|,
operator|&
name|lz_options
argument_list|)
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// Allocate new buffers if needed, and do the rest of
comment|// the initialization.
if|if
condition|(
name|lz_encoder_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|mf
argument_list|,
name|allocator
argument_list|,
operator|&
name|lz_options
argument_list|)
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
comment|// Initialize the next filter in the chain, if any.
return|return
name|lzma_next_filter_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_bool
end_extern

begin_macro
unit|)
name|lzma_mf_is_supported
argument_list|(
argument|lzma_match_finder mf
argument_list|)
end_macro

begin_block
block|{
name|bool
name|ret
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MF_HC3
if|if
condition|(
name|mf
operator|==
name|LZMA_MF_HC3
condition|)
name|ret
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_HC4
if|if
condition|(
name|mf
operator|==
name|LZMA_MF_HC4
condition|)
name|ret
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_BT2
if|if
condition|(
name|mf
operator|==
name|LZMA_MF_BT2
condition|)
name|ret
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_BT3
if|if
condition|(
name|mf
operator|==
name|LZMA_MF_BT3
condition|)
name|ret
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MF_BT4
if|if
condition|(
name|mf
operator|==
name|LZMA_MF_BT4
condition|)
name|ret
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_block

end_unit

