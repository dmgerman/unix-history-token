begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2008 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_pi_rcv_t.  * This object represents the PortInfo Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mad_pool.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_remote_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pi_rcv_set_sm
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|)
block|{
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Setting IS_SM bit in port attributes\n"
argument_list|)
expr_stmt|;
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|h_bind
operator|=
name|osm_dr_path_get_bind_handle
argument_list|(
name|p_dr_path
argument_list|)
expr_stmt|;
comment|/* 	   The 'IS_SM' bit isn't already set, so set it. 	 */
name|osm_vendor_set_sm
argument_list|(
name|h_bind
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|pi_rcv_check_and_fix_lid
parameter_list|(
name|osm_log_t
modifier|*
name|log
parameter_list|,
name|ib_port_info_t
modifier|*
specifier|const
name|pi
parameter_list|,
name|osm_physp_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|pi
operator|->
name|base_lid
argument_list|)
operator|>
name|IB_LID_UCAST_END_HO
condition|)
block|{
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F04: "
literal|"Got invalid base LID %u from the network. "
literal|"Corrected to %u.\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pi
operator|->
name|base_lid
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p
operator|->
name|port_info
operator|.
name|base_lid
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|base_lid
operator|=
name|p
operator|->
name|port_info
operator|.
name|base_lid
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pi_rcv_process_endport
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|,
name|IN
specifier|const
name|ib_port_info_t
modifier|*
specifier|const
name|p_pi
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|,
name|mtu
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sm_tbl
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_sm
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* HACK extended port 0 should be handled too! */
if|if
condition|(
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* track the minimal endport MTU and rate */
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|<
name|sm
operator|->
name|p_subn
operator|->
name|min_ca_mtu
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Setting endport minimal MTU to:%u defined by port:0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|mtu
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|min_ca_mtu
operator|=
name|mtu
expr_stmt|;
block|}
name|rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|<
name|sm
operator|->
name|p_subn
operator|->
name|min_ca_rate
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Setting endport minimal rate to:%u defined by port:0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|rate
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|min_ca_rate
operator|=
name|rate
expr_stmt|;
block|}
block|}
if|if
condition|(
name|port_guid
operator|==
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
condition|)
block|{
comment|/* 		   We received the PortInfo for our own port. 		 */
if|if
condition|(
operator|!
operator|(
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_IS_SM
operator|)
condition|)
comment|/* 			   Set the IS_SM bit to indicate our port hosts an SM. 			 */
name|__osm_pi_rcv_set_sm
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_sm_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sm_guid_tbl
expr_stmt|;
if|if
condition|(
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_IS_SM
condition|)
block|{
comment|/* 			 * Before querying the SM - we want to make sure we 			 * clean its state, so if the querying fails we 			 * recognize that this SM is not active. 			 */
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
name|p_sm_tbl
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sm
operator|!=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sm_tbl
argument_list|)
condition|)
comment|/* clean it up */
name|p_sm
operator|->
name|smi
operator|.
name|pri_state
operator|=
literal|0xF0
operator|&
name|p_sm
operator|->
name|smi
operator|.
name|pri_state
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|ignore_other_sm
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ignoring SM on port 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Detected another SM. Requesting SMInfo"
literal|"\n\t\t\t\tPort 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				   This port indicates it's an SM and 				   it's not our own port. 				   Acquire the SMInfo Attribute. 				 */
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|smi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|smi_context
operator|.
name|port_guid
operator|=
name|port_guid
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_SM_INFO
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F05: "
literal|"Failure requesting SMInfo (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_remove
argument_list|(
name|p_sm_tbl
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sm
operator|!=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sm_tbl
argument_list|)
condition|)
name|free
argument_list|(
name|p_sm
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pi_rcv_process_switch_port
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|,
name|IN
name|ib_port_info_t
modifier|*
specifier|const
name|p_pi
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|remote_port_num
decl_stmt|;
name|osm_dr_path_t
name|path
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Check the state of the physical port. 	   If there appears to be something on the other end of the wire, 	   then ask for NodeInfo.  Ignore the switch management port. 	 */
name|port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* if in_sweep_hop_0 is TRUE, then this means the SM is on the switch, 	   and we got switchInfo of our local switch. Do not continue 	   probing through the switch. */
if|if
condition|(
name|port_num
operator|!=
literal|0
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|in_sweep_hop_0
operator|==
name|FALSE
condition|)
block|{
switch|switch
condition|(
name|ib_port_info_get_port_state
argument_list|(
name|p_pi
argument_list|)
condition|)
block|{
case|case
name|IB_LINK_DOWN
case|:
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_physp
condition|)
block|{
name|p_remote_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_remote_physp
argument_list|)
expr_stmt|;
name|remote_port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Unlinking local node 0x%"
name|PRIx64
literal|", port %u"
literal|"\n\t\t\t\tand remote node 0x%"
name|PRIx64
literal|", port %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
argument_list|)
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
condition|)
name|osm_ucast_cache_add_link
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|,
name|p_physp
argument_list|,
name|p_remote_physp
argument_list|)
expr_stmt|;
name|osm_node_unlink
argument_list|(
name|p_node
argument_list|,
operator|(
name|uint8_t
operator|)
name|port_num
argument_list|,
name|p_remote_node
argument_list|,
operator|(
name|uint8_t
operator|)
name|remote_port_num
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IB_LINK_INIT
case|:
case|case
name|IB_LINK_ARMED
case|:
case|case
name|IB_LINK_ACTIVE
case|:
comment|/* 			   To avoid looping forever, only probe the port if it 			   is NOT the port that responded to the SMP.  			   Request node info from the other end of this link: 			   1) Copy the current path from the parent node. 			   2) Extend the path to the next hop thru this port. 			   3) Request node info with the new path  			 */
if|if
condition|(
name|p_pi
operator|->
name|local_port_num
operator|!=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|path
operator|=
operator|*
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|osm_dr_path_extend
argument_list|(
operator|&
name|path
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F02: "
literal|"Failure initiating NodeInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Skipping SMP responder port %u\n"
argument_list|,
name|p_pi
operator|->
name|local_port_num
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F03: "
literal|"Unknown link state = %u, port = %u\n"
argument_list|,
name|ib_port_info_get_port_state
argument_list|(
name|p_pi
argument_list|)
argument_list|,
name|p_pi
operator|->
name|local_port_num
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ib_port_info_get_port_state
argument_list|(
name|p_pi
argument_list|)
operator|>
name|IB_LINK_INIT
operator|&&
name|p_node
operator|->
name|sw
operator|&&
name|p_node
operator|->
name|sw
operator|->
name|need_update
operator|==
literal|1
condition|)
name|p_node
operator|->
name|sw
operator|->
name|need_update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_physp
operator|->
name|need_update
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|port_num
operator|==
literal|0
condition|)
name|pi_rcv_check_and_fix_lid
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_pi
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
comment|/* 	   Update the PortInfo attribute. 	 */
name|osm_physp_set_port_info
argument_list|(
name|p_physp
argument_list|,
name|p_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_num
operator|==
literal|0
condition|)
block|{
comment|/* Determine if base switch port 0 */
if|if
condition|(
name|p_node
operator|->
name|sw
operator|&&
operator|!
name|ib_switch_info_is_enhanced_port0
argument_list|(
operator|&
name|p_node
operator|->
name|sw
operator|->
name|switch_info
argument_list|)
condition|)
comment|/* PortState is not used on BSP0 but just in case it is DOWN */
name|p_physp
operator|->
name|port_info
operator|=
operator|*
name|p_pi
expr_stmt|;
name|__osm_pi_rcv_process_endport
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|,
name|p_pi
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pi_rcv_process_ca_or_router_port
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|,
name|IN
name|ib_port_info_t
modifier|*
specifier|const
name|p_pi
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|UNUSED_PARAM
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|pi_rcv_check_and_fix_lid
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_pi
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
name|osm_physp_set_port_info
argument_list|(
name|p_physp
argument_list|,
name|p_pi
argument_list|)
expr_stmt|;
name|__osm_pi_rcv_process_endport
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|,
name|p_pi
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IBM_VENDOR_ID
value|(0x5076)
end_define

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|get_pkey_table
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_dr_path_t
name|path
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint16_t
name|block_num
decl_stmt|,
name|max_blocks
decl_stmt|;
name|uint32_t
name|attr_mod_ho
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|path
operator|=
operator|*
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|context
operator|.
name|pkey_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|pkey_context
operator|.
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|context
operator|.
name|pkey_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|port_num
operator|=
name|p_physp
operator|->
name|port_num
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
operator|||
name|port_num
operator|==
literal|0
condition|)
comment|/* The maximum blocks is defined by the node info partition cap for CA, 		   router, and switch management ports. */
name|max_blocks
operator|=
operator|(
name|cl_ntoh16
argument_list|(
name|p_node
operator|->
name|node_info
operator|.
name|partition_cap
argument_list|)
operator|+
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|-
literal|1
operator|)
operator|/
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
expr_stmt|;
else|else
block|{
comment|/* This is a switch, and not a management port. The maximum blocks 		   is defined in the switch info partition enforcement cap. */
comment|/* Check for IBM eHCA firmware defect in reporting partition enforcement cap */
if|if
condition|(
name|cl_ntoh32
argument_list|(
name|ib_node_info_get_vendor_id
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
argument_list|)
operator|==
name|IBM_VENDOR_ID
condition|)
name|p_node
operator|->
name|sw
operator|->
name|switch_info
operator|.
name|enforce_cap
operator|=
literal|0
expr_stmt|;
comment|/* Bail out if this is a switch with no partition enforcement capability */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_node
operator|->
name|sw
operator|->
name|switch_info
operator|.
name|enforce_cap
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|max_blocks
operator|=
operator|(
name|cl_ntoh16
argument_list|(
name|p_node
operator|->
name|sw
operator|->
name|switch_info
operator|.
name|enforce_cap
argument_list|)
operator|+
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|-
literal|1
operator|)
operator|/
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
expr_stmt|;
block|}
for|for
control|(
name|block_num
operator|=
literal|0
init|;
name|block_num
operator|<
name|max_blocks
condition|;
name|block_num
operator|++
control|)
block|{
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
name|attr_mod_ho
operator|=
name|block_num
expr_stmt|;
else|else
name|attr_mod_ho
operator|=
name|block_num
operator||
operator|(
name|port_num
operator|<<
literal|16
operator|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|path
argument_list|,
name|IB_MAD_ATTR_P_KEY_TABLE
argument_list|,
name|cl_hton32
argument_list|(
name|attr_mod_ho
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F12: "
literal|"Failure initiating PKeyTable request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pi_rcv_get_pkey_slvl_vla_tables
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|get_pkey_table
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_pi_rcv_process_set
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|ib_port_info_t
modifier|*
name|p_pi
decl_stmt|;
name|osm_pi_context_t
modifier|*
name|p_context
decl_stmt|;
name|osm_log_level_t
name|level
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_context
operator|=
name|osm_madw_get_pi_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pi
operator|=
operator|(
name|ib_port_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|status
argument_list|)
operator|&
literal|0x7fff
condition|)
block|{
comment|/* If port already ACTIVE, don't treat status 7 as error */
if|if
condition|(
name|p_context
operator|->
name|active_transition
operator|&&
operator|(
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|status
argument_list|)
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x1c
condition|)
block|{
name|level
operator|=
name|OSM_LOG_INFO
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Received error status 0x%x for SetResp() during ACTIVE transition\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|status
argument_list|)
operator|&
literal|0x7fff
argument_list|)
expr_stmt|;
comment|/* Should there be a subsequent Get to validate that port is ACTIVE ? */
block|}
else|else
block|{
name|level
operator|=
name|OSM_LOG_ERROR
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F10: "
literal|"Received error status for SetResp()\n"
argument_list|)
expr_stmt|;
block|}
name|osm_dump_port_info
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|,
name|port_guid
argument_list|,
name|port_num
argument_list|,
name|p_pi
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received logical SetResp() for GUID 0x%"
name|PRIx64
literal|", port num %u"
literal|"\n\t\t\t\tfor parent node GUID 0x%"
name|PRIx64
literal|" TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|osm_physp_set_port_info
argument_list|(
name|p_physp
argument_list|,
name|p_pi
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_pi_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_port_info_t
modifier|*
name|p_pi
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_pi_context_t
modifier|*
name|p_context
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|ib_net64_t
name|node_guid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_context
operator|=
name|osm_madw_get_pi_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pi
operator|=
operator|(
name|ib_port_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PORT_INFO
argument_list|)
expr_stmt|;
name|port_num
operator|=
operator|(
name|uint8_t
operator|)
name|cl_ntoh32
argument_list|(
name|p_smp
operator|->
name|attr_mod
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|p_context
operator|->
name|port_guid
expr_stmt|;
name|node_guid
operator|=
name|p_context
operator|->
name|node_guid
expr_stmt|;
name|osm_dump_port_info
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|node_guid
argument_list|,
name|port_guid
argument_list|,
name|port_num
argument_list|,
name|p_pi
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
comment|/* On receipt of client reregister, clear the reregister bit so 	   reregistering won't be sent again and again */
if|if
condition|(
name|ib_port_info_get_client_rereg
argument_list|(
name|p_pi
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Client reregister received on response\n"
argument_list|)
expr_stmt|;
name|ib_port_info_set_client_rereg
argument_list|(
name|p_pi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	   we might get a response during a light sweep looking for a change in 	   the status of a remote port that did not respond in earlier sweeps. 	   So if the context of the Get was light_sweep - we do not need to 	   do anything with the response - just flag that we need a heavy sweep 	 */
if|if
condition|(
name|p_context
operator|->
name|light_sweep
operator|==
name|TRUE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Got light sweep response from remote port of parent node "
literal|"GUID 0x%"
name|PRIx64
literal|" port 0x%016"
name|PRIx64
literal|", Commencing heavy sweep\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F06: "
literal|"No port object for port with GUID 0x%"
name|PRIx64
literal|"\n\t\t\t\tfor parent node GUID 0x%"
name|PRIx64
literal|", TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
comment|/* 	   If we were setting the PortInfo, then receiving 	   this attribute was not part of sweeping the subnet. 	   In this case, just update the PortInfo attribute.  	   In an unfortunate blunder, the IB spec defines the 	   return method for Set() as a GetResp().  Thus, we can't 	   use the method (what would have been SetResp()) to determine 	   our course of action.  So, we have to carry this extra 	   boolean around to determine if we were doing Get() or Set(). 	 */
if|if
condition|(
name|p_context
operator|->
name|set_method
condition|)
name|osm_pi_rcv_process_set
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
else|else
block|{
name|p_port
operator|->
name|discovery_count
operator|++
expr_stmt|;
comment|/* 		   This PortInfo arrived because we did a Get() method, 		   most likely due to a subnet sweep in progress. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Discovered port num %u with GUID 0x%"
name|PRIx64
literal|" for parent node GUID 0x%"
name|PRIx64
literal|", TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* 		   Determine if we encountered a new Physical Port. 		   If so, initialize the new Physical Port then 		   continue processing as normal. 		 */
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Initializing port number %u\n"
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|p_physp
operator|=
operator|&
name|p_node
operator|->
name|physp_table
index|[
name|port_num
index|]
expr_stmt|;
name|osm_physp_init
argument_list|(
name|p_physp
argument_list|,
name|port_guid
argument_list|,
name|port_num
argument_list|,
name|p_node
argument_list|,
name|osm_madw_get_bind_handle
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_smp
operator|->
name|hop_count
argument_list|,
name|p_smp
operator|->
name|initial_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			   Update the directed route path to this port 			   in case the old path is no longer usable. 			 */
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|osm_dr_path_init
argument_list|(
name|p_dr_path
argument_list|,
name|osm_madw_get_bind_handle
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_smp
operator|->
name|hop_count
argument_list|,
name|p_smp
operator|->
name|initial_path
argument_list|)
expr_stmt|;
block|}
comment|/* if port just inited or reached INIT state (external reset) 		   request update for port related tables */
name|p_physp
operator|->
name|need_update
operator|=
operator|(
name|ib_port_info_get_port_state
argument_list|(
name|p_pi
argument_list|)
operator|==
name|IB_LINK_INIT
operator|||
name|p_physp
operator|->
name|need_update
operator|>
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|__osm_pi_rcv_process_ca_or_router_port
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_physp
argument_list|,
name|p_pi
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|__osm_pi_rcv_process_switch_port
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_physp
argument_list|,
name|p_pi
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0F07: "
literal|"Unknown node type %u with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		   Get the tables on the physp. 		 */
if|if
condition|(
name|p_physp
operator|->
name|need_update
operator|||
name|sm
operator|->
name|p_subn
operator|->
name|need_update
condition|)
name|__osm_pi_rcv_get_pkey_slvl_vla_tables
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit
label|:
comment|/* 	   Release the lock before jumping here!! 	 */
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

