begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2006 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *	Implementation of quick map, a binary tree where the caller always  *	provides all necessary storage.  *  */
end_comment

begin_comment
comment|/***************************************************************************** * * Map * * Map is an associative array.  By providing a key, the caller can retrieve * an object from the map.  All objects in the map have an associated key, * as specified by the caller when the object was inserted into the map. * In addition to random access, the caller can traverse the map much like * a linked list, either forwards from the first object or backwards from * the last object.  The objects in the map are always traversed in * order since the nodes are stored sorted. * * This implementation of Map uses a red black tree verified against * Cormen-Leiserson-Rivest text, McGraw-Hill Edition, fourteenth * printing, 1994. * *****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_map.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_fleximap.h>
end_include

begin_comment
comment|/****************************************************************************** ******************************************************************************* **************													   ************ **************			 IMPLEMENTATION OF QUICK MAP			   ************ **************													   ************ ******************************************************************************* ******************************************************************************/
end_comment

begin_comment
comment|/*  * Get the root.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cl_map_item_t
modifier|*
name|__cl_map_root
parameter_list|(
name|IN
specifier|const
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_map
operator|->
name|root
operator|.
name|p_left
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns whether a given item is on the left of its parent.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|__cl_map_is_left_child
parameter_list|(
name|IN
specifier|const
name|cl_map_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
operator|!=
name|p_item
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_item
operator|->
name|p_up
operator|->
name|p_left
operator|==
name|p_item
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the pointer to the parent's pointer to an item.  */
end_comment

begin_function
specifier|static
name|cl_map_item_t
modifier|*
modifier|*
name|__cl_map_get_parent_ptr_to_item
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
operator|!=
name|p_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cl_map_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
return|return
operator|(
operator|&
name|p_item
operator|->
name|p_up
operator|->
name|p_left
operator|)
return|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
operator|->
name|p_right
operator|==
name|p_item
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|p_item
operator|->
name|p_up
operator|->
name|p_right
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rotate a node to the left.  This rotation affects the least number of links  * between nodes and brings the level of C up by one while increasing the depth  * of A one.  Note that the links to/from W, X, Y, and Z are not affected.  *  *	    R				      R  *	    |				      |  *	    A				      C  *	  /   \			        /   \  *	W       C			  A       Z  *	       / \			 / \  *	      B   Z			W   B  *	     / \			   / \  *	    X   Y			  X   Y  */
end_comment

begin_function
specifier|static
name|void
name|__cl_map_rot_left
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
modifier|*
name|pp_root
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_right
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
name|pp_root
operator|=
name|__cl_map_get_parent_ptr_to_item
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
comment|/* Point R to C instead of A. */
operator|*
name|pp_root
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
comment|/* Set C's parent to R. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_up
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
comment|/* Set A's right to B */
name|p_item
operator|->
name|p_right
operator|=
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
expr_stmt|;
comment|/* 	 * Set B's parent to A.  We trap for B being NIL since the 	 * caller may depend on NIL not changing. 	 */
if|if
condition|(
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
operator|->
name|p_up
operator|=
name|p_item
expr_stmt|;
comment|/* Set C's left to A. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
operator|=
name|p_item
expr_stmt|;
comment|/* Set A's parent to C. */
name|p_item
operator|->
name|p_up
operator|=
operator|*
name|pp_root
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rotate a node to the right.  This rotation affects the least number of links  * between nodes and brings the level of A up by one while increasing the depth  * of C one.  Note that the links to/from W, X, Y, and Z are not affected.  *  *	        R				     R  *	        |				     |  *	        C				     A  *	      /   \				   /   \  *	    A       Z			 W       C  *	   / \    				        / \  *	  W   B   				       B   Z  *	     / \				      / \  *	    X   Y				     X   Y  */
end_comment

begin_function
specifier|static
name|void
name|__cl_map_rot_right
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
modifier|*
name|pp_root
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_left
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
comment|/* Point R to A instead of C. */
name|pp_root
operator|=
name|__cl_map_get_parent_ptr_to_item
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pp_root
operator|)
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
comment|/* Set A's parent to R. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_up
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
comment|/* Set C's left to B */
name|p_item
operator|->
name|p_left
operator|=
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
expr_stmt|;
comment|/* 	 * Set B's parent to C.  We trap for B being NIL since the 	 * caller may depend on NIL not changing. 	 */
if|if
condition|(
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
operator|->
name|p_up
operator|=
name|p_item
expr_stmt|;
comment|/* Set A's right to C. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
operator|=
name|p_item
expr_stmt|;
comment|/* Set C's parent to A. */
name|p_item
operator|->
name|p_up
operator|=
operator|*
name|pp_root
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cl_qmap_init
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cl_qmap_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* special setup for the root node */
name|p_map
operator|->
name|root
operator|.
name|p_up
operator|=
operator|&
name|p_map
operator|->
name|root
expr_stmt|;
name|p_map
operator|->
name|root
operator|.
name|p_left
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|root
operator|.
name|p_right
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|root
operator|.
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
comment|/* Setup the node used as terminator for all leaves. */
name|p_map
operator|->
name|nil
operator|.
name|p_up
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|nil
operator|.
name|p_left
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|nil
operator|.
name|p_right
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|nil
operator|.
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_map
operator|->
name|state
operator|=
name|CL_INITIALIZED
expr_stmt|;
name|cl_qmap_remove_all
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|cl_map_item_t
modifier|*
name|cl_qmap_get
parameter_list|(
name|IN
specifier|const
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|__cl_map_root
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
block|{
if|if
condition|(
name|key
operator|==
name|p_item
operator|->
name|key
condition|)
break|break;
comment|/* just right */
if|if
condition|(
name|key
operator|<
name|p_item
operator|->
name|key
condition|)
name|p_item
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
comment|/* too small */
else|else
name|p_item
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
comment|/* too big */
block|}
return|return
operator|(
name|p_item
operator|)
return|;
block|}
end_function

begin_function
name|cl_map_item_t
modifier|*
name|cl_qmap_get_next
parameter_list|(
name|IN
specifier|const
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_item_found
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|__cl_map_root
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|p_item_found
operator|=
operator|(
name|cl_map_item_t
operator|*
operator|)
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
block|{
if|if
condition|(
name|key
operator|<
name|p_item
operator|->
name|key
condition|)
block|{
name|p_item_found
operator|=
name|p_item
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
block|}
else|else
block|{
name|p_item
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p_item_found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cl_qmap_apply_func
parameter_list|(
name|IN
specifier|const
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_pfn_qmap_apply_t
name|pfn_func
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
specifier|const
name|context
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_map_item
decl_stmt|;
comment|/* Note that context can have any arbitrary value. */
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|pfn_func
argument_list|)
expr_stmt|;
name|p_map_item
operator|=
name|cl_qmap_head
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_map_item
operator|!=
name|cl_qmap_end
argument_list|(
name|p_map
argument_list|)
condition|)
block|{
name|pfn_func
argument_list|(
name|p_map_item
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
name|p_map_item
operator|=
name|cl_qmap_next
argument_list|(
name|p_map_item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Balance a tree starting at a given item back to the root.  */
end_comment

begin_function
specifier|static
name|void
name|__cl_map_ins_bal
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_map_item_t
modifier|*
name|p_item
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_grand_uncle
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|!=
operator|&
name|p_map
operator|->
name|root
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
if|if
condition|(
name|__cl_map_is_left_child
argument_list|(
name|p_item
operator|->
name|p_up
argument_list|)
condition|)
block|{
name|p_grand_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_grand_uncle
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_grand_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_grand_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|__cl_map_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
block|{
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
name|__cl_map_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_map_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
operator|->
name|p_up
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_grand_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_grand_uncle
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_grand_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_grand_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|__cl_map_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
block|{
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
name|__cl_map_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_map_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
operator|->
name|p_up
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|cl_map_item_t
modifier|*
name|cl_qmap_insert
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|,
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_insert_at
decl_stmt|,
modifier|*
name|p_comp_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|root
operator|.
name|p_up
operator|==
operator|&
name|p_map
operator|->
name|root
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|root
operator|.
name|color
operator|!=
name|CL_MAP_RED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|nil
operator|.
name|color
operator|!=
name|CL_MAP_RED
argument_list|)
expr_stmt|;
name|p_item
operator|->
name|p_left
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_item
operator|->
name|p_right
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_item
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|p_item
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
comment|/* Find the insertion location. */
name|p_insert_at
operator|=
operator|&
name|p_map
operator|->
name|root
expr_stmt|;
name|p_comp_item
operator|=
name|__cl_map_root
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_comp_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
block|{
name|p_insert_at
operator|=
name|p_comp_item
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|p_insert_at
operator|->
name|key
condition|)
return|return
operator|(
name|p_insert_at
operator|)
return|;
comment|/* Traverse the tree until the correct insertion point is found. */
if|if
condition|(
name|key
operator|<
name|p_insert_at
operator|->
name|key
condition|)
name|p_comp_item
operator|=
name|p_insert_at
operator|->
name|p_left
expr_stmt|;
else|else
name|p_comp_item
operator|=
name|p_insert_at
operator|->
name|p_right
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_insert_at
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_comp_item
operator|==
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
comment|/* Insert the item. */
if|if
condition|(
name|p_insert_at
operator|==
operator|&
name|p_map
operator|->
name|root
condition|)
block|{
name|p_insert_at
operator|->
name|p_left
operator|=
name|p_item
expr_stmt|;
comment|/* 		 * Primitive insert places the new item in front of 		 * the existing item. 		 */
name|__cl_primitive_insert
argument_list|(
operator|&
name|p_map
operator|->
name|nil
operator|.
name|pool_item
operator|.
name|list_item
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|<
name|p_insert_at
operator|->
name|key
condition|)
block|{
name|p_insert_at
operator|->
name|p_left
operator|=
name|p_item
expr_stmt|;
comment|/* 		 * Primitive insert places the new item in front of 		 * the existing item. 		 */
name|__cl_primitive_insert
argument_list|(
operator|&
name|p_insert_at
operator|->
name|pool_item
operator|.
name|list_item
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_insert_at
operator|->
name|p_right
operator|=
name|p_item
expr_stmt|;
comment|/* 		 * Primitive insert places the new item in front of 		 * the existing item. 		 */
name|__cl_primitive_insert
argument_list|(
name|p_insert_at
operator|->
name|pool_item
operator|.
name|list_item
operator|.
name|p_next
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
block|}
comment|/* Increase the count. */
name|p_map
operator|->
name|count
operator|++
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|=
name|p_insert_at
expr_stmt|;
comment|/* 	 * We have added depth to this section of the tree. 	 * Rebalance as necessary as we retrace our path through the tree 	 * and update colors. 	 */
name|__cl_map_ins_bal
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
name|__cl_map_root
argument_list|(
name|p_map
argument_list|)
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
comment|/* 	 * Note that it is not necessary to re-color the nil node black because all 	 * red color assignments are made via the p_up pointer, and nil is never 	 * set as the value of a p_up pointer. 	 */
ifdef|#
directive|ifdef
name|_DEBUG_
comment|/* Set the pointer to the map in the map item for consistency checking. */
name|p_item
operator|->
name|p_map
operator|=
name|p_map
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|p_item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cl_map_del_bal
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_map_item_t
modifier|*
name|p_item
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_uncle
decl_stmt|;
while|while
condition|(
operator|(
name|p_item
operator|->
name|color
operator|!=
name|CL_MAP_RED
operator|)
operator|&&
operator|(
name|p_item
operator|->
name|p_up
operator|!=
operator|&
name|p_map
operator|->
name|root
operator|)
condition|)
block|{
if|if
condition|(
name|__cl_map_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
block|{
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
if|if
condition|(
name|p_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_map_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
block|}
if|if
condition|(
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
if|if
condition|(
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_map_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_uncle
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
block|}
name|p_uncle
operator|->
name|color
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|color
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|__cl_map_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
if|if
condition|(
name|p_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_map_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
block|}
if|if
condition|(
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
if|if
condition|(
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_map_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_uncle
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
block|}
name|p_uncle
operator|->
name|color
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|color
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|__cl_map_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|p_item
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cl_qmap_remove_item
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_child
decl_stmt|,
modifier|*
name|p_del_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_item
operator|==
name|cl_qmap_end
argument_list|(
name|p_map
argument_list|)
condition|)
return|return;
comment|/* must be checked after comparing to cl_qmap_end, since 	   the end is not a valid item. */
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_map
operator|==
name|p_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_item
operator|->
name|p_right
operator|==
operator|&
name|p_map
operator|->
name|nil
operator|)
operator|||
operator|(
name|p_item
operator|->
name|p_left
operator|==
operator|&
name|p_map
operator|->
name|nil
operator|)
condition|)
block|{
comment|/* The item being removed has children on at most on side. */
name|p_del_item
operator|=
name|p_item
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The item being removed has children on both side. 		 * We select the item that will replace it.  After removing 		 * the substitute item and rebalancing, the tree will have the 		 * correct topology.  Exchanging the substitute for the item 		 * will finalize the removal. 		 */
name|p_del_item
operator|=
name|cl_qmap_next
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_del_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the item from the list. */
name|__cl_primitive_remove
argument_list|(
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
comment|/* Decrement the item count. */
name|p_map
operator|->
name|count
operator|--
expr_stmt|;
comment|/* Get the pointer to the new root's child, if any. */
if|if
condition|(
name|p_del_item
operator|->
name|p_left
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
name|p_child
operator|=
name|p_del_item
operator|->
name|p_left
expr_stmt|;
else|else
name|p_child
operator|=
name|p_del_item
operator|->
name|p_right
expr_stmt|;
comment|/* 	 * This assignment may modify the parent pointer of the nil node. 	 * This is inconsequential. 	 */
name|p_child
operator|->
name|p_up
operator|=
name|p_del_item
operator|->
name|p_up
expr_stmt|;
operator|(
operator|*
name|__cl_map_get_parent_ptr_to_item
argument_list|(
name|p_del_item
argument_list|)
operator|)
operator|=
name|p_child
expr_stmt|;
if|if
condition|(
name|p_del_item
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
name|__cl_map_del_bal
argument_list|(
name|p_map
argument_list|,
name|p_child
argument_list|)
expr_stmt|;
comment|/* 	 * Note that the splicing done below does not need to occur before 	 * the tree is balanced, since the actual topology changes are made by the 	 * preceding code.  The topology is preserved by the color assignment made 	 * below (reader should be reminded that p_del_item == p_item in some cases). 	 */
if|if
condition|(
name|p_del_item
operator|!=
name|p_item
condition|)
block|{
comment|/* 		 * Finalize the removal of the specified item by exchanging it with 		 * the substitute which we removed above. 		 */
name|p_del_item
operator|->
name|p_up
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
name|p_del_item
operator|->
name|p_left
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
name|p_del_item
operator|->
name|p_right
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
operator|(
operator|*
name|__cl_map_get_parent_ptr_to_item
argument_list|(
name|p_item
argument_list|)
operator|)
operator|=
name|p_del_item
expr_stmt|;
name|p_item
operator|->
name|p_right
operator|->
name|p_up
operator|=
name|p_del_item
expr_stmt|;
name|p_item
operator|->
name|p_left
operator|->
name|p_up
operator|=
name|p_del_item
expr_stmt|;
name|p_del_item
operator|->
name|color
operator|=
name|p_item
operator|->
name|color
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|nil
operator|.
name|color
operator|!=
name|CL_MAP_RED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_DEBUG_
comment|/* Clear the pointer to the map since the item has been removed. */
name|p_item
operator|->
name|p_map
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|cl_map_item_t
modifier|*
name|cl_qmap_remove
parameter_list|(
name|IN
name|cl_qmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
comment|/* Seek the node with the specified key */
name|p_item
operator|=
name|cl_qmap_get
argument_list|(
name|p_map
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cl_qmap_remove_item
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_item
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cl_qmap_merge
parameter_list|(
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_dest_map
parameter_list|,
name|IN
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_src_map
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|,
modifier|*
name|p_item2
decl_stmt|,
modifier|*
name|p_next
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_dest_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_src_map
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|cl_qmap_head
argument_list|(
name|p_src_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
name|cl_qmap_end
argument_list|(
name|p_src_map
argument_list|)
condition|)
block|{
name|p_next
operator|=
name|cl_qmap_next
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
comment|/* Remove the item from its current map. */
name|cl_qmap_remove_item
argument_list|(
name|p_src_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
comment|/* Insert the item into the destination map. */
name|p_item2
operator|=
name|cl_qmap_insert
argument_list|(
name|p_dest_map
argument_list|,
name|cl_qmap_key
argument_list|(
name|p_item
argument_list|)
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
comment|/* Check that the item was successfully inserted. */
if|if
condition|(
name|p_item2
operator|!=
name|p_item
condition|)
block|{
comment|/* Put the item in back in the source map. */
name|p_item2
operator|=
name|cl_qmap_insert
argument_list|(
name|p_src_map
argument_list|,
name|cl_qmap_key
argument_list|(
name|p_item
argument_list|)
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item2
operator|==
name|p_item
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|=
name|p_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__cl_qmap_delta_move
parameter_list|(
name|IN
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_dest
parameter_list|,
name|IN
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_src
parameter_list|,
name|IN
name|OUT
name|cl_map_item_t
modifier|*
modifier|*
specifier|const
name|pp_item
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_temp
decl_stmt|,
modifier|*
name|p_next
decl_stmt|;
comment|/* 	 * Get the next item so that we can ensure that pp_item points to 	 * a valid item upon return from the function. 	 */
name|p_next
operator|=
name|cl_qmap_next
argument_list|(
operator|*
name|pp_item
argument_list|)
expr_stmt|;
comment|/* Move the old item from its current map the the old map. */
name|cl_qmap_remove_item
argument_list|(
name|p_src
argument_list|,
operator|*
name|pp_item
argument_list|)
expr_stmt|;
name|p_temp
operator|=
name|cl_qmap_insert
argument_list|(
name|p_dest
argument_list|,
name|cl_qmap_key
argument_list|(
operator|*
name|pp_item
argument_list|)
argument_list|,
operator|*
name|pp_item
argument_list|)
expr_stmt|;
comment|/* We should never have duplicates. */
name|CL_ASSERT
argument_list|(
name|p_temp
operator|==
operator|*
name|pp_item
argument_list|)
expr_stmt|;
comment|/* Point pp_item to a valid item in the source map. */
operator|(
operator|*
name|pp_item
operator|)
operator|=
name|p_next
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cl_qmap_delta
parameter_list|(
name|IN
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_map1
parameter_list|,
name|IN
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_map2
parameter_list|,
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_new
parameter_list|,
name|OUT
name|cl_qmap_t
modifier|*
specifier|const
name|p_old
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item1
decl_stmt|,
modifier|*
name|p_item2
decl_stmt|;
name|uint64_t
name|key1
decl_stmt|,
name|key2
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map1
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map2
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_new
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_old
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_qmap_empty
argument_list|(
name|p_new
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_qmap_empty
argument_list|(
name|p_old
argument_list|)
argument_list|)
expr_stmt|;
name|p_item1
operator|=
name|cl_qmap_head
argument_list|(
name|p_map1
argument_list|)
expr_stmt|;
name|p_item2
operator|=
name|cl_qmap_head
argument_list|(
name|p_map2
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item1
operator|!=
name|cl_qmap_end
argument_list|(
name|p_map1
argument_list|)
operator|&&
name|p_item2
operator|!=
name|cl_qmap_end
argument_list|(
name|p_map2
argument_list|)
condition|)
block|{
name|key1
operator|=
name|cl_qmap_key
argument_list|(
name|p_item1
argument_list|)
expr_stmt|;
name|key2
operator|=
name|cl_qmap_key
argument_list|(
name|p_item2
argument_list|)
expr_stmt|;
if|if
condition|(
name|key1
operator|<
name|key2
condition|)
block|{
comment|/* We found an old item. */
name|__cl_qmap_delta_move
argument_list|(
name|p_old
argument_list|,
name|p_map1
argument_list|,
operator|&
name|p_item1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key1
operator|>
name|key2
condition|)
block|{
comment|/* We found a new item. */
name|__cl_qmap_delta_move
argument_list|(
name|p_new
argument_list|,
name|p_map2
argument_list|,
operator|&
name|p_item2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Move both forward since they have the same key. */
name|p_item1
operator|=
name|cl_qmap_next
argument_list|(
name|p_item1
argument_list|)
expr_stmt|;
name|p_item2
operator|=
name|cl_qmap_next
argument_list|(
name|p_item2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the remainder if the end of either source map was reached. */
while|while
condition|(
name|p_item2
operator|!=
name|cl_qmap_end
argument_list|(
name|p_map2
argument_list|)
condition|)
name|__cl_qmap_delta_move
argument_list|(
name|p_new
argument_list|,
name|p_map2
argument_list|,
operator|&
name|p_item2
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item1
operator|!=
name|cl_qmap_end
argument_list|(
name|p_map1
argument_list|)
condition|)
name|__cl_qmap_delta_move
argument_list|(
name|p_old
argument_list|,
name|p_map1
argument_list|,
operator|&
name|p_item1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** ******************************************************************************* **************													   ************ **************				IMPLEMENTATION OF MAP				   ************ **************													   ************ ******************************************************************************* ******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|MAP_GROW_SIZE
value|32
end_define

begin_function
name|void
name|cl_map_construct
parameter_list|(
name|IN
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|cl_qpool_construct
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|cl_status_t
name|cl_map_init
parameter_list|(
name|IN
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|min_items
parameter_list|)
block|{
name|uint32_t
name|grow_size
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
expr_stmt|;
comment|/* 	 * We will grow by min_items/8 items at a time, with a minimum of 	 * MAP_GROW_SIZE. 	 */
name|grow_size
operator|=
name|min_items
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|grow_size
operator|<
name|MAP_GROW_SIZE
condition|)
name|grow_size
operator|=
name|MAP_GROW_SIZE
expr_stmt|;
return|return
operator|(
name|cl_qpool_init
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|,
name|min_items
argument_list|,
literal|0
argument_list|,
name|grow_size
argument_list|,
sizeof|sizeof
argument_list|(
name|cl_map_obj_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cl_map_destroy
parameter_list|(
name|IN
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|cl_qpool_destroy
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|cl_map_insert
parameter_list|(
name|IN
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
specifier|const
name|p_object
parameter_list|)
block|{
name|cl_map_obj_t
modifier|*
name|p_map_obj
decl_stmt|,
modifier|*
name|p_obj_at_key
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|p_map_obj
operator|=
operator|(
name|cl_map_obj_t
operator|*
operator|)
name|cl_qpool_get
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_map_obj
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cl_qmap_set_obj
argument_list|(
name|p_map_obj
argument_list|,
name|p_object
argument_list|)
expr_stmt|;
name|p_obj_at_key
operator|=
operator|(
name|cl_map_obj_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|,
name|key
argument_list|,
operator|&
name|p_map_obj
operator|->
name|item
argument_list|)
expr_stmt|;
comment|/* Return the item to the pool if insertion failed. */
if|if
condition|(
name|p_obj_at_key
operator|!=
name|p_map_obj
condition|)
name|cl_qpool_put
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|,
operator|&
name|p_map_obj
operator|->
name|item
operator|.
name|pool_item
argument_list|)
expr_stmt|;
return|return
operator|(
name|cl_qmap_obj
argument_list|(
name|p_obj_at_key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cl_map_get
parameter_list|(
name|IN
specifier|const
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|cl_qmap_get
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_item
operator|==
name|cl_qmap_end
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|cl_qmap_obj
argument_list|(
name|PARENT_STRUCT
argument_list|(
name|p_item
argument_list|,
name|cl_map_obj_t
argument_list|,
name|item
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cl_map_get_next
parameter_list|(
name|IN
specifier|const
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|cl_qmap_get_next
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_item
operator|==
name|cl_qmap_end
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|cl_qmap_obj
argument_list|(
name|PARENT_STRUCT
argument_list|(
name|p_item
argument_list|,
name|cl_map_obj_t
argument_list|,
name|item
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cl_map_remove_item
parameter_list|(
name|IN
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|cl_map_iterator_t
name|itor
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|itor
operator|->
name|p_map
operator|==
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|itor
operator|==
name|cl_map_end
argument_list|(
name|p_map
argument_list|)
condition|)
return|return;
name|cl_qmap_remove_item
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|,
operator|(
name|cl_map_item_t
operator|*
operator|)
name|itor
argument_list|)
expr_stmt|;
name|cl_qpool_put
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|,
operator|&
operator|(
operator|(
name|cl_map_item_t
operator|*
operator|)
name|itor
operator|)
operator|->
name|pool_item
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|cl_map_remove
parameter_list|(
name|IN
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|uint64_t
name|key
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|void
modifier|*
name|p_obj
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|cl_qmap_remove
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_item
operator|==
name|cl_qmap_end
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p_obj
operator|=
name|cl_qmap_obj
argument_list|(
operator|(
name|cl_map_obj_t
operator|*
operator|)
name|p_item
argument_list|)
expr_stmt|;
name|cl_qpool_put
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_obj
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cl_map_remove_all
parameter_list|(
name|IN
name|cl_map_t
modifier|*
specifier|const
name|p_map
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
comment|/* Return all map items to the pool. */
while|while
condition|(
operator|!
name|cl_is_qmap_empty
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
condition|)
block|{
name|p_item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
expr_stmt|;
name|cl_qmap_remove_item
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
name|cl_qpool_put
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cl_is_qmap_empty
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
condition|)
block|{
name|p_item
operator|=
name|cl_qmap_tail
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|)
expr_stmt|;
name|cl_qmap_remove_item
argument_list|(
operator|&
name|p_map
operator|->
name|qmap
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
name|cl_qpool_put
argument_list|(
operator|&
name|p_map
operator|->
name|pool
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|cl_status_t
name|cl_map_merge
parameter_list|(
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_dest_map
parameter_list|,
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_src_map
parameter_list|)
block|{
name|cl_status_t
name|status
init|=
name|CL_SUCCESS
decl_stmt|;
name|cl_map_iterator_t
name|itor
decl_stmt|,
name|next
decl_stmt|;
name|uint64_t
name|key
decl_stmt|;
name|void
modifier|*
name|p_obj
decl_stmt|,
modifier|*
name|p_obj2
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_dest_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_src_map
argument_list|)
expr_stmt|;
name|itor
operator|=
name|cl_map_head
argument_list|(
name|p_src_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|itor
operator|!=
name|cl_map_end
argument_list|(
name|p_src_map
argument_list|)
condition|)
block|{
name|next
operator|=
name|cl_map_next
argument_list|(
name|itor
argument_list|)
expr_stmt|;
name|p_obj
operator|=
name|cl_map_obj
argument_list|(
name|itor
argument_list|)
expr_stmt|;
name|key
operator|=
name|cl_map_key
argument_list|(
name|itor
argument_list|)
expr_stmt|;
name|cl_map_remove_item
argument_list|(
name|p_src_map
argument_list|,
name|itor
argument_list|)
expr_stmt|;
comment|/* Insert the object into the destination map. */
name|p_obj2
operator|=
name|cl_map_insert
argument_list|(
name|p_dest_map
argument_list|,
name|key
argument_list|,
name|p_obj
argument_list|)
expr_stmt|;
comment|/* Trap for failure. */
if|if
condition|(
name|p_obj
operator|!=
name|p_obj2
condition|)
block|{
if|if
condition|(
operator|!
name|p_obj2
condition|)
name|status
operator|=
name|CL_INSUFFICIENT_MEMORY
expr_stmt|;
comment|/* Put the object back in the source map.  This must succeed. */
name|p_obj2
operator|=
name|cl_map_insert
argument_list|(
name|p_src_map
argument_list|,
name|key
argument_list|,
name|p_obj
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_obj
operator|==
name|p_obj2
argument_list|)
expr_stmt|;
comment|/* If the failure was due to insufficient memory, return. */
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
return|return
operator|(
name|status
operator|)
return|;
block|}
name|itor
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|CL_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cl_map_revert
parameter_list|(
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_map1
parameter_list|,
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_map2
parameter_list|,
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_new
parameter_list|,
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_old
parameter_list|)
block|{
name|cl_status_t
name|status
decl_stmt|;
comment|/* Restore the initial state. */
name|status
operator|=
name|cl_map_merge
argument_list|(
name|p_map1
argument_list|,
name|p_old
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|status
operator|==
name|CL_SUCCESS
argument_list|)
expr_stmt|;
name|status
operator|=
name|cl_map_merge
argument_list|(
name|p_map2
argument_list|,
name|p_new
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|status
operator|==
name|CL_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cl_status_t
name|__cl_map_delta_move
parameter_list|(
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_dest
parameter_list|,
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_src
parameter_list|,
name|IN
name|OUT
name|cl_map_iterator_t
modifier|*
specifier|const
name|p_itor
parameter_list|)
block|{
name|cl_map_iterator_t
name|next
decl_stmt|;
name|void
modifier|*
name|p_obj
decl_stmt|,
modifier|*
name|p_obj2
decl_stmt|;
name|uint64_t
name|key
decl_stmt|;
comment|/* Get a valid iterator so we can continue the loop. */
name|next
operator|=
name|cl_map_next
argument_list|(
operator|*
name|p_itor
argument_list|)
expr_stmt|;
comment|/* Get the pointer to the object for insertion. */
name|p_obj
operator|=
name|cl_map_obj
argument_list|(
operator|*
name|p_itor
argument_list|)
expr_stmt|;
comment|/* Get the key for the object. */
name|key
operator|=
name|cl_map_key
argument_list|(
operator|*
name|p_itor
argument_list|)
expr_stmt|;
comment|/* Move the object. */
name|cl_map_remove_item
argument_list|(
name|p_src
argument_list|,
operator|*
name|p_itor
argument_list|)
expr_stmt|;
name|p_obj2
operator|=
name|cl_map_insert
argument_list|(
name|p_dest
argument_list|,
name|key
argument_list|,
name|p_obj
argument_list|)
expr_stmt|;
comment|/* Check for failure. We should never get a duplicate. */
if|if
condition|(
operator|!
name|p_obj2
condition|)
block|{
name|p_obj2
operator|=
name|cl_map_insert
argument_list|(
name|p_src
argument_list|,
name|key
argument_list|,
name|p_obj
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_obj2
operator|==
name|p_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|CL_INSUFFICIENT_MEMORY
operator|)
return|;
block|}
comment|/* We should never get a duplicate */
name|CL_ASSERT
argument_list|(
name|p_obj
operator|==
name|p_obj2
argument_list|)
expr_stmt|;
comment|/* Update the iterator so that it is valid. */
operator|(
operator|*
name|p_itor
operator|)
operator|=
name|next
expr_stmt|;
return|return
operator|(
name|CL_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|cl_status_t
name|cl_map_delta
parameter_list|(
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_map1
parameter_list|,
name|IN
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_map2
parameter_list|,
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_new
parameter_list|,
name|OUT
name|cl_map_t
modifier|*
specifier|const
name|p_old
parameter_list|)
block|{
name|cl_map_iterator_t
name|itor1
decl_stmt|,
name|itor2
decl_stmt|;
name|uint64_t
name|key1
decl_stmt|,
name|key2
decl_stmt|;
name|cl_status_t
name|status
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map1
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map2
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_new
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_old
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_map_empty
argument_list|(
name|p_new
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_map_empty
argument_list|(
name|p_old
argument_list|)
argument_list|)
expr_stmt|;
name|itor1
operator|=
name|cl_map_head
argument_list|(
name|p_map1
argument_list|)
expr_stmt|;
name|itor2
operator|=
name|cl_map_head
argument_list|(
name|p_map2
argument_list|)
expr_stmt|;
comment|/* 	 * Note that the check is for the end, since duplicate items will remain 	 * in their respective maps. 	 */
while|while
condition|(
name|itor1
operator|!=
name|cl_map_end
argument_list|(
name|p_map1
argument_list|)
operator|&&
name|itor2
operator|!=
name|cl_map_end
argument_list|(
name|p_map2
argument_list|)
condition|)
block|{
name|key1
operator|=
name|cl_map_key
argument_list|(
name|itor1
argument_list|)
expr_stmt|;
name|key2
operator|=
name|cl_map_key
argument_list|(
name|itor2
argument_list|)
expr_stmt|;
if|if
condition|(
name|key1
operator|<
name|key2
condition|)
block|{
name|status
operator|=
name|__cl_map_delta_move
argument_list|(
name|p_old
argument_list|,
name|p_map1
argument_list|,
operator|&
name|itor1
argument_list|)
expr_stmt|;
comment|/* Check for failure. */
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
comment|/* Restore the initial state. */
name|__cl_map_revert
argument_list|(
name|p_map1
argument_list|,
name|p_map2
argument_list|,
name|p_new
argument_list|,
name|p_old
argument_list|)
expr_stmt|;
comment|/* Return the failure status. */
return|return
operator|(
name|status
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|key1
operator|>
name|key2
condition|)
block|{
name|status
operator|=
name|__cl_map_delta_move
argument_list|(
name|p_new
argument_list|,
name|p_map2
argument_list|,
operator|&
name|itor2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
comment|/* Restore the initial state. */
name|__cl_map_revert
argument_list|(
name|p_map1
argument_list|,
name|p_map2
argument_list|,
name|p_new
argument_list|,
name|p_old
argument_list|)
expr_stmt|;
comment|/* Return the failure status. */
return|return
operator|(
name|status
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Move both forward since they have the same key. */
name|itor1
operator|=
name|cl_map_next
argument_list|(
name|itor1
argument_list|)
expr_stmt|;
name|itor2
operator|=
name|cl_map_next
argument_list|(
name|itor2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the remainder if either source map is empty. */
while|while
condition|(
name|itor2
operator|!=
name|cl_map_end
argument_list|(
name|p_map2
argument_list|)
condition|)
block|{
name|status
operator|=
name|__cl_map_delta_move
argument_list|(
name|p_new
argument_list|,
name|p_map2
argument_list|,
operator|&
name|itor2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
comment|/* Restore the initial state. */
name|__cl_map_revert
argument_list|(
name|p_map1
argument_list|,
name|p_map2
argument_list|,
name|p_new
argument_list|,
name|p_old
argument_list|)
expr_stmt|;
comment|/* Return the failure status. */
return|return
operator|(
name|status
operator|)
return|;
block|}
block|}
while|while
condition|(
name|itor1
operator|!=
name|cl_map_end
argument_list|(
name|p_map1
argument_list|)
condition|)
block|{
name|status
operator|=
name|__cl_map_delta_move
argument_list|(
name|p_old
argument_list|,
name|p_map1
argument_list|,
operator|&
name|itor1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
comment|/* Restore the initial state. */
name|__cl_map_revert
argument_list|(
name|p_map1
argument_list|,
name|p_map2
argument_list|,
name|p_new
argument_list|,
name|p_old
argument_list|)
expr_stmt|;
comment|/* Return the failure status. */
return|return
operator|(
name|status
operator|)
return|;
block|}
block|}
return|return
operator|(
name|CL_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** ******************************************************************************* **************													   ************ **************			 IMPLEMENTATION OF FLEXI MAP			   ************ **************													   ************ ******************************************************************************* ******************************************************************************/
end_comment

begin_comment
comment|/*  * Get the root.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cl_fmap_item_t
modifier|*
name|__cl_fmap_root
parameter_list|(
name|IN
specifier|const
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_map
operator|->
name|root
operator|.
name|p_left
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns whether a given item is on the left of its parent.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|__cl_fmap_is_left_child
parameter_list|(
name|IN
specifier|const
name|cl_fmap_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
operator|!=
name|p_item
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_item
operator|->
name|p_up
operator|->
name|p_left
operator|==
name|p_item
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the pointer to the parent's pointer to an item.  */
end_comment

begin_function
specifier|static
name|cl_fmap_item_t
modifier|*
modifier|*
name|__cl_fmap_get_parent_ptr_to_item
parameter_list|(
name|IN
name|cl_fmap_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
operator|!=
name|p_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cl_fmap_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
return|return
operator|(
operator|&
name|p_item
operator|->
name|p_up
operator|->
name|p_left
operator|)
return|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_up
operator|->
name|p_right
operator|==
name|p_item
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|p_item
operator|->
name|p_up
operator|->
name|p_right
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rotate a node to the left.  This rotation affects the least number of links  * between nodes and brings the level of C up by one while increasing the depth  * of A one.  Note that the links to/from W, X, Y, and Z are not affected.  *  *	    R				      R  *	    |				      |  *	    A				      C  *	  /   \			        /   \  *	W       C			  A       Z  *	       / \			 / \  *	      B   Z			W   B  *	     / \			   / \  *	    X   Y			  X   Y  */
end_comment

begin_function
specifier|static
name|void
name|__cl_fmap_rot_left
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_fmap_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
modifier|*
name|pp_root
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_right
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
name|pp_root
operator|=
name|__cl_fmap_get_parent_ptr_to_item
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
comment|/* Point R to C instead of A. */
operator|*
name|pp_root
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
comment|/* Set C's parent to R. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_up
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
comment|/* Set A's right to B */
name|p_item
operator|->
name|p_right
operator|=
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
expr_stmt|;
comment|/* 	 * Set B's parent to A.  We trap for B being NIL since the 	 * caller may depend on NIL not changing. 	 */
if|if
condition|(
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
operator|->
name|p_up
operator|=
name|p_item
expr_stmt|;
comment|/* Set C's left to A. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_left
operator|=
name|p_item
expr_stmt|;
comment|/* Set A's parent to C. */
name|p_item
operator|->
name|p_up
operator|=
operator|*
name|pp_root
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rotate a node to the right.  This rotation affects the least number of links  * between nodes and brings the level of A up by one while increasing the depth  * of C one.  Note that the links to/from W, X, Y, and Z are not affected.  *  *	        R				     R  *	        |				     |  *	        C				     A  *	      /   \				   /   \  *	    A       Z			 W       C  *	   / \    				        / \  *	  W   B   				       B   Z  *	     / \				      / \  *	    X   Y				     X   Y  */
end_comment

begin_function
specifier|static
name|void
name|__cl_fmap_rot_right
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_fmap_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
modifier|*
name|pp_root
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_left
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
comment|/* Point R to A instead of C. */
name|pp_root
operator|=
name|__cl_fmap_get_parent_ptr_to_item
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pp_root
operator|)
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
comment|/* Set A's parent to R. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_up
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
comment|/* Set C's left to B */
name|p_item
operator|->
name|p_left
operator|=
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
expr_stmt|;
comment|/* 	 * Set B's parent to C.  We trap for B being NIL since the 	 * caller may depend on NIL not changing. 	 */
if|if
condition|(
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
operator|->
name|p_up
operator|=
name|p_item
expr_stmt|;
comment|/* Set A's right to C. */
operator|(
operator|*
name|pp_root
operator|)
operator|->
name|p_right
operator|=
name|p_item
expr_stmt|;
comment|/* Set C's parent to A. */
name|p_item
operator|->
name|p_up
operator|=
operator|*
name|pp_root
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cl_fmap_init
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_pfn_fmap_cmp_t
name|pfn_compare
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|pfn_compare
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cl_fmap_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* special setup for the root node */
name|p_map
operator|->
name|root
operator|.
name|p_up
operator|=
operator|&
name|p_map
operator|->
name|root
expr_stmt|;
name|p_map
operator|->
name|root
operator|.
name|p_left
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|root
operator|.
name|p_right
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|root
operator|.
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
comment|/* Setup the node used as terminator for all leaves. */
name|p_map
operator|->
name|nil
operator|.
name|p_up
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|nil
operator|.
name|p_left
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|nil
operator|.
name|p_right
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_map
operator|->
name|nil
operator|.
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
comment|/* Store the compare function pointer. */
name|p_map
operator|->
name|pfn_compare
operator|=
name|pfn_compare
expr_stmt|;
name|p_map
operator|->
name|state
operator|=
name|CL_INITIALIZED
expr_stmt|;
name|cl_fmap_remove_all
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|cl_fmap_item_t
modifier|*
name|cl_fmap_get
parameter_list|(
name|IN
specifier|const
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
specifier|const
name|p_key
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_item
decl_stmt|;
name|intn_t
name|cmp
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|__cl_fmap_root
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
block|{
name|cmp
operator|=
name|p_map
operator|->
name|pfn_compare
argument_list|(
name|p_key
argument_list|,
name|p_item
operator|->
name|p_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
break|break;
comment|/* just right */
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|p_item
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
comment|/* too small */
else|else
name|p_item
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
comment|/* too big */
block|}
return|return
operator|(
name|p_item
operator|)
return|;
block|}
end_function

begin_function
name|cl_fmap_item_t
modifier|*
name|cl_fmap_get_next
parameter_list|(
name|IN
specifier|const
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
specifier|const
name|p_key
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_item
decl_stmt|;
name|cl_fmap_item_t
modifier|*
name|p_item_found
decl_stmt|;
name|intn_t
name|cmp
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|__cl_fmap_root
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|p_item_found
operator|=
operator|(
name|cl_fmap_item_t
operator|*
operator|)
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
block|{
name|cmp
operator|=
name|p_map
operator|->
name|pfn_compare
argument_list|(
name|p_key
argument_list|,
name|p_item
operator|->
name|p_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|p_item_found
operator|=
name|p_item
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
comment|/* too small */
block|}
else|else
block|{
name|p_item
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
comment|/* too big or match */
block|}
block|}
return|return
operator|(
name|p_item_found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cl_fmap_apply_func
parameter_list|(
name|IN
specifier|const
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_pfn_fmap_apply_t
name|pfn_func
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
specifier|const
name|context
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_fmap_item
decl_stmt|;
comment|/* Note that context can have any arbitrary value. */
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|pfn_func
argument_list|)
expr_stmt|;
name|p_fmap_item
operator|=
name|cl_fmap_head
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_fmap_item
operator|!=
name|cl_fmap_end
argument_list|(
name|p_map
argument_list|)
condition|)
block|{
name|pfn_func
argument_list|(
name|p_fmap_item
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
name|p_fmap_item
operator|=
name|cl_fmap_next
argument_list|(
name|p_fmap_item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Balance a tree starting at a given item back to the root.  */
end_comment

begin_function
specifier|static
name|void
name|__cl_fmap_ins_bal
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_fmap_item_t
modifier|*
name|p_item
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_grand_uncle
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|!=
operator|&
name|p_map
operator|->
name|root
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
if|if
condition|(
name|__cl_fmap_is_left_child
argument_list|(
name|p_item
operator|->
name|p_up
argument_list|)
condition|)
block|{
name|p_grand_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_grand_uncle
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_grand_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_grand_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|__cl_fmap_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
block|{
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
name|__cl_fmap_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_fmap_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
operator|->
name|p_up
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_grand_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_grand_uncle
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_grand_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_grand_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|__cl_fmap_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
block|{
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
name|__cl_fmap_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_fmap_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
operator|->
name|p_up
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|cl_fmap_item_t
modifier|*
name|cl_fmap_insert
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
specifier|const
name|p_key
parameter_list|,
name|IN
name|cl_fmap_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_insert_at
decl_stmt|,
modifier|*
name|p_comp_item
decl_stmt|;
name|intn_t
name|cmp
init|=
literal|0
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|root
operator|.
name|p_up
operator|==
operator|&
name|p_map
operator|->
name|root
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|root
operator|.
name|color
operator|!=
name|CL_MAP_RED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|nil
operator|.
name|color
operator|!=
name|CL_MAP_RED
argument_list|)
expr_stmt|;
name|p_item
operator|->
name|p_left
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_item
operator|->
name|p_right
operator|=
operator|&
name|p_map
operator|->
name|nil
expr_stmt|;
name|p_item
operator|->
name|p_key
operator|=
name|p_key
expr_stmt|;
name|p_item
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
comment|/* Find the insertion location. */
name|p_insert_at
operator|=
operator|&
name|p_map
operator|->
name|root
expr_stmt|;
name|p_comp_item
operator|=
name|__cl_fmap_root
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_comp_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
block|{
name|p_insert_at
operator|=
name|p_comp_item
expr_stmt|;
name|cmp
operator|=
name|p_map
operator|->
name|pfn_compare
argument_list|(
name|p_key
argument_list|,
name|p_insert_at
operator|->
name|p_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
operator|(
name|p_insert_at
operator|)
return|;
comment|/* Traverse the tree until the correct insertion point is found. */
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|p_comp_item
operator|=
name|p_insert_at
operator|->
name|p_left
expr_stmt|;
else|else
name|p_comp_item
operator|=
name|p_insert_at
operator|->
name|p_right
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_insert_at
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_comp_item
operator|==
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
comment|/* Insert the item. */
if|if
condition|(
name|p_insert_at
operator|==
operator|&
name|p_map
operator|->
name|root
condition|)
block|{
name|p_insert_at
operator|->
name|p_left
operator|=
name|p_item
expr_stmt|;
comment|/* 		 * Primitive insert places the new item in front of 		 * the existing item. 		 */
name|__cl_primitive_insert
argument_list|(
operator|&
name|p_map
operator|->
name|nil
operator|.
name|pool_item
operator|.
name|list_item
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|p_insert_at
operator|->
name|p_left
operator|=
name|p_item
expr_stmt|;
comment|/* 		 * Primitive insert places the new item in front of 		 * the existing item. 		 */
name|__cl_primitive_insert
argument_list|(
operator|&
name|p_insert_at
operator|->
name|pool_item
operator|.
name|list_item
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_insert_at
operator|->
name|p_right
operator|=
name|p_item
expr_stmt|;
comment|/* 		 * Primitive insert places the new item in front of 		 * the existing item. 		 */
name|__cl_primitive_insert
argument_list|(
name|p_insert_at
operator|->
name|pool_item
operator|.
name|list_item
operator|.
name|p_next
argument_list|,
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
block|}
comment|/* Increase the count. */
name|p_map
operator|->
name|count
operator|++
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|=
name|p_insert_at
expr_stmt|;
comment|/* 	 * We have added depth to this section of the tree. 	 * Rebalance as necessary as we retrace our path through the tree 	 * and update colors. 	 */
name|__cl_fmap_ins_bal
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
name|__cl_fmap_root
argument_list|(
name|p_map
argument_list|)
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
comment|/* 	 * Note that it is not necessary to re-color the nil node black because all 	 * red color assignments are made via the p_up pointer, and nil is never 	 * set as the value of a p_up pointer. 	 */
ifdef|#
directive|ifdef
name|_DEBUG_
comment|/* Set the pointer to the map in the map item for consistency checking. */
name|p_item
operator|->
name|p_map
operator|=
name|p_map
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|p_item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cl_fmap_del_bal
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_fmap_item_t
modifier|*
name|p_item
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_uncle
decl_stmt|;
while|while
condition|(
operator|(
name|p_item
operator|->
name|color
operator|!=
name|CL_MAP_RED
operator|)
operator|&&
operator|(
name|p_item
operator|->
name|p_up
operator|!=
operator|&
name|p_map
operator|->
name|root
operator|)
condition|)
block|{
if|if
condition|(
name|__cl_fmap_is_left_child
argument_list|(
name|p_item
argument_list|)
condition|)
block|{
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
if|if
condition|(
name|p_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_fmap_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
block|}
if|if
condition|(
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
if|if
condition|(
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_fmap_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_uncle
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_right
expr_stmt|;
block|}
name|p_uncle
operator|->
name|color
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|color
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|__cl_fmap_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
if|if
condition|(
name|p_uncle
operator|->
name|color
operator|==
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_fmap_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
block|}
if|if
condition|(
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
if|if
condition|(
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
block|{
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|p_item
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
continue|continue;
block|}
name|p_uncle
operator|->
name|p_right
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|color
operator|=
name|CL_MAP_RED
expr_stmt|;
name|__cl_fmap_rot_left
argument_list|(
name|p_map
argument_list|,
name|p_uncle
argument_list|)
expr_stmt|;
name|p_uncle
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|p_left
expr_stmt|;
block|}
name|p_uncle
operator|->
name|color
operator|=
name|p_item
operator|->
name|p_up
operator|->
name|color
expr_stmt|;
name|p_item
operator|->
name|p_up
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|p_uncle
operator|->
name|p_left
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
name|__cl_fmap_rot_right
argument_list|(
name|p_map
argument_list|,
name|p_item
operator|->
name|p_up
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|p_item
operator|->
name|color
operator|=
name|CL_MAP_BLACK
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cl_fmap_remove_item
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
name|cl_fmap_item_t
modifier|*
specifier|const
name|p_item
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_child
decl_stmt|,
modifier|*
name|p_del_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item
operator|->
name|p_map
operator|==
name|p_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_item
operator|==
name|cl_fmap_end
argument_list|(
name|p_map
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|p_item
operator|->
name|p_right
operator|==
operator|&
name|p_map
operator|->
name|nil
operator|)
operator|||
operator|(
name|p_item
operator|->
name|p_left
operator|==
operator|&
name|p_map
operator|->
name|nil
operator|)
condition|)
block|{
comment|/* The item being removed has children on at most on side. */
name|p_del_item
operator|=
name|p_item
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The item being removed has children on both side. 		 * We select the item that will replace it.  After removing 		 * the substitute item and rebalancing, the tree will have the 		 * correct topology.  Exchanging the substitute for the item 		 * will finalize the removal. 		 */
name|p_del_item
operator|=
name|cl_fmap_next
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_del_item
operator|!=
operator|&
name|p_map
operator|->
name|nil
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the item from the list. */
name|__cl_primitive_remove
argument_list|(
operator|&
name|p_item
operator|->
name|pool_item
operator|.
name|list_item
argument_list|)
expr_stmt|;
comment|/* Decrement the item count. */
name|p_map
operator|->
name|count
operator|--
expr_stmt|;
comment|/* Get the pointer to the new root's child, if any. */
if|if
condition|(
name|p_del_item
operator|->
name|p_left
operator|!=
operator|&
name|p_map
operator|->
name|nil
condition|)
name|p_child
operator|=
name|p_del_item
operator|->
name|p_left
expr_stmt|;
else|else
name|p_child
operator|=
name|p_del_item
operator|->
name|p_right
expr_stmt|;
comment|/* 	 * This assignment may modify the parent pointer of the nil node. 	 * This is inconsequential. 	 */
name|p_child
operator|->
name|p_up
operator|=
name|p_del_item
operator|->
name|p_up
expr_stmt|;
operator|(
operator|*
name|__cl_fmap_get_parent_ptr_to_item
argument_list|(
name|p_del_item
argument_list|)
operator|)
operator|=
name|p_child
expr_stmt|;
if|if
condition|(
name|p_del_item
operator|->
name|color
operator|!=
name|CL_MAP_RED
condition|)
name|__cl_fmap_del_bal
argument_list|(
name|p_map
argument_list|,
name|p_child
argument_list|)
expr_stmt|;
comment|/* 	 * Note that the splicing done below does not need to occur before 	 * the tree is balanced, since the actual topology changes are made by the 	 * preceding code.  The topology is preserved by the color assignment made 	 * below (reader should be reminded that p_del_item == p_item in some cases). 	 */
if|if
condition|(
name|p_del_item
operator|!=
name|p_item
condition|)
block|{
comment|/* 		 * Finalize the removal of the specified item by exchanging it with 		 * the substitute which we removed above. 		 */
name|p_del_item
operator|->
name|p_up
operator|=
name|p_item
operator|->
name|p_up
expr_stmt|;
name|p_del_item
operator|->
name|p_left
operator|=
name|p_item
operator|->
name|p_left
expr_stmt|;
name|p_del_item
operator|->
name|p_right
operator|=
name|p_item
operator|->
name|p_right
expr_stmt|;
operator|(
operator|*
name|__cl_fmap_get_parent_ptr_to_item
argument_list|(
name|p_item
argument_list|)
operator|)
operator|=
name|p_del_item
expr_stmt|;
name|p_item
operator|->
name|p_right
operator|->
name|p_up
operator|=
name|p_del_item
expr_stmt|;
name|p_item
operator|->
name|p_left
operator|->
name|p_up
operator|=
name|p_del_item
expr_stmt|;
name|p_del_item
operator|->
name|color
operator|=
name|p_item
operator|->
name|color
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|nil
operator|.
name|color
operator|!=
name|CL_MAP_RED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_DEBUG_
comment|/* Clear the pointer to the map since the item has been removed. */
name|p_item
operator|->
name|p_map
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|cl_fmap_item_t
modifier|*
name|cl_fmap_remove
parameter_list|(
name|IN
name|cl_fmap_t
modifier|*
specifier|const
name|p_map
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
specifier|const
name|p_key
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map
operator|->
name|state
operator|==
name|CL_INITIALIZED
argument_list|)
expr_stmt|;
comment|/* Seek the node with the specified key */
name|p_item
operator|=
name|cl_fmap_get
argument_list|(
name|p_map
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
name|cl_fmap_remove_item
argument_list|(
name|p_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_item
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cl_fmap_merge
parameter_list|(
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_dest_map
parameter_list|,
name|IN
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_src_map
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_item
decl_stmt|,
modifier|*
name|p_item2
decl_stmt|,
modifier|*
name|p_next
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_dest_map
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_src_map
argument_list|)
expr_stmt|;
name|p_item
operator|=
name|cl_fmap_head
argument_list|(
name|p_src_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
name|cl_fmap_end
argument_list|(
name|p_src_map
argument_list|)
condition|)
block|{
name|p_next
operator|=
name|cl_fmap_next
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
comment|/* Remove the item from its current map. */
name|cl_fmap_remove_item
argument_list|(
name|p_src_map
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
comment|/* Insert the item into the destination map. */
name|p_item2
operator|=
name|cl_fmap_insert
argument_list|(
name|p_dest_map
argument_list|,
name|cl_fmap_key
argument_list|(
name|p_item
argument_list|)
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
comment|/* Check that the item was successfully inserted. */
if|if
condition|(
name|p_item2
operator|!=
name|p_item
condition|)
block|{
comment|/* Put the item in back in the source map. */
name|p_item2
operator|=
name|cl_fmap_insert
argument_list|(
name|p_src_map
argument_list|,
name|cl_fmap_key
argument_list|(
name|p_item
argument_list|)
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_item2
operator|==
name|p_item
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|=
name|p_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__cl_fmap_delta_move
parameter_list|(
name|IN
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_dest
parameter_list|,
name|IN
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_src
parameter_list|,
name|IN
name|OUT
name|cl_fmap_item_t
modifier|*
modifier|*
specifier|const
name|pp_item
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_temp
decl_stmt|,
modifier|*
name|p_next
decl_stmt|;
comment|/* 	 * Get the next item so that we can ensure that pp_item points to 	 * a valid item upon return from the function. 	 */
name|p_next
operator|=
name|cl_fmap_next
argument_list|(
operator|*
name|pp_item
argument_list|)
expr_stmt|;
comment|/* Move the old item from its current map the the old map. */
name|cl_fmap_remove_item
argument_list|(
name|p_src
argument_list|,
operator|*
name|pp_item
argument_list|)
expr_stmt|;
name|p_temp
operator|=
name|cl_fmap_insert
argument_list|(
name|p_dest
argument_list|,
name|cl_fmap_key
argument_list|(
operator|*
name|pp_item
argument_list|)
argument_list|,
operator|*
name|pp_item
argument_list|)
expr_stmt|;
comment|/* We should never have duplicates. */
name|CL_ASSERT
argument_list|(
name|p_temp
operator|==
operator|*
name|pp_item
argument_list|)
expr_stmt|;
comment|/* Point pp_item to a valid item in the source map. */
operator|(
operator|*
name|pp_item
operator|)
operator|=
name|p_next
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cl_fmap_delta
parameter_list|(
name|IN
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_map1
parameter_list|,
name|IN
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_map2
parameter_list|,
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_new
parameter_list|,
name|OUT
name|cl_fmap_t
modifier|*
specifier|const
name|p_old
parameter_list|)
block|{
name|cl_fmap_item_t
modifier|*
name|p_item1
decl_stmt|,
modifier|*
name|p_item2
decl_stmt|;
name|intn_t
name|cmp
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map1
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_map2
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_new
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_old
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_fmap_empty
argument_list|(
name|p_new
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_fmap_empty
argument_list|(
name|p_old
argument_list|)
argument_list|)
expr_stmt|;
name|p_item1
operator|=
name|cl_fmap_head
argument_list|(
name|p_map1
argument_list|)
expr_stmt|;
name|p_item2
operator|=
name|cl_fmap_head
argument_list|(
name|p_map2
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item1
operator|!=
name|cl_fmap_end
argument_list|(
name|p_map1
argument_list|)
operator|&&
name|p_item2
operator|!=
name|cl_fmap_end
argument_list|(
name|p_map2
argument_list|)
condition|)
block|{
name|cmp
operator|=
name|p_map1
operator|->
name|pfn_compare
argument_list|(
name|cl_fmap_key
argument_list|(
name|p_item1
argument_list|)
argument_list|,
name|cl_fmap_key
argument_list|(
name|p_item2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|/* We found an old item. */
name|__cl_fmap_delta_move
argument_list|(
name|p_old
argument_list|,
name|p_map1
argument_list|,
operator|&
name|p_item1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|/* We found a new item. */
name|__cl_fmap_delta_move
argument_list|(
name|p_new
argument_list|,
name|p_map2
argument_list|,
operator|&
name|p_item2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Move both forward since they have the same key. */
name|p_item1
operator|=
name|cl_fmap_next
argument_list|(
name|p_item1
argument_list|)
expr_stmt|;
name|p_item2
operator|=
name|cl_fmap_next
argument_list|(
name|p_item2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the remainder if the end of either source map was reached. */
while|while
condition|(
name|p_item2
operator|!=
name|cl_fmap_end
argument_list|(
name|p_map2
argument_list|)
condition|)
name|__cl_fmap_delta_move
argument_list|(
name|p_new
argument_list|,
name|p_map2
argument_list|,
operator|&
name|p_item2
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item1
operator|!=
name|cl_fmap_end
argument_list|(
name|p_map1
argument_list|)
condition|)
name|__cl_fmap_delta_move
argument_list|(
name|p_old
argument_list|,
name|p_map1
argument_list|,
operator|&
name|p_item1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

