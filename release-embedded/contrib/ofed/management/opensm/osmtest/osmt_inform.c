begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSM_VENDOR_INTF_MTL
end_ifdef

begin_comment
comment|/*  * Abstract:  *    Implementation of InformInfo testing flow..  *    Top level is osmt_run_inform_info_flow:  *     osmt_bind_inform_qp  *     osmt_reg_unreg_inform_info  *     osmt_send_trap_wait_for_forward  *  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_mlx_hca.h>
end_include

begin_include
include|#
directive|include
file|"osmtest.h"
end_include

begin_include
include|#
directive|include
file|"osmt_inform.h"
end_include

begin_comment
comment|/*  * Prepare an asynchronous QP (rcv) for sending inform info and  * handling the incoming reports.  *  */
end_comment

begin_function
name|ib_api_status_t
name|osmt_bind_inform_qp
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|,
name|OUT
name|osmt_qp_ctx_t
modifier|*
name|p_qp_ctx
parameter_list|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
name|VAPI_hca_hndl_t
name|hca_hndl
decl_stmt|;
name|VAPI_hca_id_t
name|hca_id
decl_stmt|;
name|uint32_t
name|port_num
decl_stmt|;
name|VAPI_ret_t
name|vapi_ret
decl_stmt|;
name|IB_MGT_ret_t
name|mgt_ret
decl_stmt|;
name|uint8_t
name|hca_index
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_osmt
operator|->
name|log
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|p_osmt
operator|->
name|local_port
operator|.
name|port_guid
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Binding to port 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* obtain the hca name and port num from the guid */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Finding CA and Port that owns port guid 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
name|mgt_ret
operator|=
name|osm_vendor_get_guid_ca_and_port
argument_list|(
name|p_osmt
operator|->
name|p_vendor
argument_list|,
name|port_guid
argument_list|,
operator|&
name|hca_hndl
argument_list|,
operator|&
name|hca_id
index|[
literal|0
index|]
argument_list|,
operator|&
name|hca_index
argument_list|,
operator|&
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgt_ret
operator|!=
name|IB_MGT_OK
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0109: "
literal|"Unable to obtain CA and port (%d).\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
define|#
directive|define
name|OSMT_MTL_REVERSE_QP1_WELL_KNOWN_Q_KEY
value|0x80010000
name|strncpy
argument_list|(
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|hca_id
argument_list|,
name|hca_id
argument_list|,
sizeof|sizeof
argument_list|(
name|hca_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|hca_hndl
operator|=
name|hca_hndl
expr_stmt|;
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|max_outs_sq
operator|=
literal|10
expr_stmt|;
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|max_outs_rq
operator|=
literal|10
expr_stmt|;
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|qkey
operator|=
name|OSMT_MTL_REVERSE_QP1_WELL_KNOWN_Q_KEY
expr_stmt|;
name|vapi_ret
operator|=
name|osmt_mtl_init_opened_hca
argument_list|(
operator|&
name|p_qp_ctx
operator|->
name|qp_bind_hndl
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0114: "
literal|"Error initializing QP.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* we use the pre-allocated buffers for send and receive : 	   send from buf[0] 	   receive from buf[2] 	 */
name|p_qp_ctx
operator|->
name|p_send_buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|buf_ptr
operator|+
name|GRH_LEN
expr_stmt|;
name|p_qp_ctx
operator|->
name|p_recv_buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|buf_ptr
operator|+
literal|2
operator|*
operator|(
name|GRH_LEN
operator|+
name|MAD_BLOCK_SIZE
operator|)
expr_stmt|;
comment|/* Need to clear assigned memory of p_send_buf - before using it to send any data */
name|memset
argument_list|(
name|p_qp_ctx
operator|->
name|p_send_buf
argument_list|,
literal|0
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Initialized QP:0x%X in VAPI Mode\n"
argument_list|,
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|qp_id
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Binding to IB_MGT SMI\n"
argument_list|)
expr_stmt|;
comment|/* we also need a QP0 handle for sending packets */
name|mgt_ret
operator|=
name|IB_MGT_get_handle
argument_list|(
name|hca_id
argument_list|,
name|port_num
argument_list|,
name|IB_MGT_SMI
argument_list|,
operator|&
operator|(
name|p_qp_ctx
operator|->
name|ib_mgt_qp0_handle
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IB_MGT_OK
operator|!=
name|mgt_ret
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0115: "
literal|"Error obtaining IB_MGT handle to SMI\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Close the QP  */
end_comment

begin_function
name|void
name|osmt_unbind_inform_qp
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|,
name|IN
name|osmt_qp_ctx_t
modifier|*
name|p_qp_ctx
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_osmt
operator|->
name|log
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|osmt_mtl_mad_cleanup
argument_list|(
operator|&
name|p_qp_ctx
operator|->
name|qp_bind_hndl
argument_list|)
expr_stmt|;
name|IB_MGT_release_handle
argument_list|(
name|p_qp_ctx
operator|->
name|ib_mgt_qp0_handle
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Unbind QP handles\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register/Unregister to receive the given InformInfo  *  * Uses the qp context to send the inform info mad.  * Wait for GetResp(InformInfoResp)  *  */
end_comment

begin_function
name|ib_api_status_t
name|osmt_reg_unreg_inform_info
parameter_list|(
name|IN
name|osmtest_t
modifier|*
name|p_osmt
parameter_list|,
name|IN
name|osmt_qp_ctx_t
modifier|*
name|p_qp_ctx
parameter_list|,
name|IN
name|ib_inform_info_t
modifier|*
name|p_inform_info
parameter_list|,
name|IN
name|uint8_t
name|reg_flag
parameter_list|)
block|{
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
init|=
operator|(
name|ib_sa_mad_t
operator|*
operator|)
operator|(
name|p_qp_ctx
operator|->
name|p_send_buf
operator|)
decl_stmt|;
name|ib_inform_info_t
modifier|*
name|p_ii
init|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
decl_stmt|;
comment|/*  SA Payload */
name|VAPI_ret_t
name|vapi_ret
decl_stmt|;
name|VAPI_wc_desc_t
name|wc_desc
decl_stmt|;
name|VAPI_ud_av_hndl_t
name|avh
decl_stmt|;
specifier|static
name|VAPI_wr_id_t
name|wrid
init|=
literal|16198
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_osmt
operator|->
name|log
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* init the MAD */
name|ib_mad_init_new
argument_list|(
operator|(
name|ib_mad_t
operator|*
operator|)
name|p_sa_mad
argument_list|,
name|IB_MCLASS_SUBN_ADM
argument_list|,
operator|(
name|uint8_t
operator|)
literal|2
argument_list|,
name|IB_MAD_METHOD_SET
argument_list|,
name|cl_hton64
argument_list|(
name|wrid
argument_list|)
argument_list|,
operator|(
name|ib_net16_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrid
operator|++
expr_stmt|;
name|p_sa_mad
operator|->
name|attr_id
operator|=
name|IB_MAD_ATTR_INFORM_INFO
expr_stmt|;
comment|/* copy the reference inform info */
name|memcpy
argument_list|(
name|p_ii
argument_list|,
name|p_inform_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_inform_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_flag
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Subscribing InformInfo: Traps from lid:0x%X to 0x%X, trap num :0x%X\n"
argument_list|,
name|p_ii
operator|->
name|lid_range_begin
argument_list|,
name|p_ii
operator|->
name|lid_range_end
argument_list|,
name|p_ii
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"UnSubscribing InformInfo: Traps from lid:0x%X to 0x%X\n"
argument_list|,
name|p_ii
operator|->
name|lid_range_begin
argument_list|,
name|p_ii
operator|->
name|lid_range_end
argument_list|)
expr_stmt|;
block|}
comment|/* set the subscribe bit */
if|if
condition|(
name|reg_flag
condition|)
block|{
name|p_ii
operator|->
name|subscribe
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p_ii
operator|->
name|subscribe
operator|=
literal|0
expr_stmt|;
comment|/* 		 * we need to set the QPN on the mad if we unsubscribe: 		 * o13-2.1.1 - QPN Field need to be set when unsubscribing. 		 */
name|ib_inform_info_set_qpn
argument_list|(
name|p_ii
argument_list|,
name|cl_hton32
argument_list|(
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|qp_id
operator|.
name|qp_num
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|osm_dump_inform_info
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|p_ii
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
comment|/* --------------------- PREP ------------------------- */
if|if
condition|(
name|osmt_mtl_mad_post_recv_bufs
argument_list|(
operator|&
name|p_qp_ctx
operator|->
name|qp_bind_hndl
argument_list|,
name|p_qp_ctx
operator|->
name|p_recv_buf
argument_list|,
literal|1
argument_list|,
comment|/*  but we need only one mad at a time */
name|GRH_LEN
operator|+
name|MAD_BLOCK_SIZE
argument_list|,
name|wrid
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0120: "
literal|"Error posting recv bufs\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posted recv bufs\n"
argument_list|)
expr_stmt|;
name|vapi_ret
operator|=
name|osmt_mtl_create_av
argument_list|(
operator|&
name|p_qp_ctx
operator|->
name|qp_bind_hndl
argument_list|,
name|p_osmt
operator|->
name|local_port
operator|.
name|sm_lid
argument_list|,
operator|&
name|avh
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0121: "
literal|"Error Preparing AVH (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Prepared AVH\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|osm_dump_sa_mad
argument_list|(
name|p_log
argument_list|,
operator|(
name|ib_sa_mad_t
operator|*
operator|)
operator|(
name|p_qp_ctx
operator|->
name|p_send_buf
operator|)
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (i = 56; i< 253; i++) { 			if (i % 8 == 0) { 				printf("\n %d : ", i); 			} 			printf("0x%02X ", p_qp_ctx->p_send_buf[i]); 		}
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* --------------------- SEND ------------------------- */
name|vapi_ret
operator|=
name|osmt_mtl_mad_send
argument_list|(
operator|&
name|p_qp_ctx
operator|->
name|qp_bind_hndl
argument_list|,
name|wrid
argument_list|,
name|p_qp_ctx
operator|->
name|p_send_buf
argument_list|,
literal|1
argument_list|,
comment|/*  SA is QP1 */
literal|0
argument_list|,
comment|/*  SL is 0 */
name|OSMT_MTL_REVERSE_QP1_WELL_KNOWN_Q_KEY
argument_list|,
name|avh
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0122: "
literal|"Error sending mad (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|vapi_ret
operator|=
name|osmt_mtl_mad_poll4cqe
argument_list|(
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|hca_hndl
argument_list|,
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|sq_cq_hndl
argument_list|,
operator|&
name|wc_desc
argument_list|,
literal|20
argument_list|,
literal|10000
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0123: "
literal|"Error getting send completion (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|wc_desc
operator|.
name|status
operator|!=
name|VAPI_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0124: "
literal|"Error on send completion (%s) (%d)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|wc_desc
operator|.
name|status
argument_list|)
argument_list|,
name|wc_desc
operator|.
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Sent MAD\n"
argument_list|)
expr_stmt|;
comment|/* --------------------- RECV ------------------------- */
name|vapi_ret
operator|=
name|osmt_mtl_mad_poll4cqe
argument_list|(
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|hca_hndl
argument_list|,
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|rq_cq_hndl
argument_list|,
operator|&
name|wc_desc
argument_list|,
literal|20
argument_list|,
literal|10000
argument_list|,
operator|&
name|avh
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_SUCCESS
condition|)
block|{
if|if
condition|(
name|vapi_ret
operator|==
name|VAPI_CQ_EMPTY
condition|)
block|{
name|status
operator|=
name|IB_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0125: "
literal|"Error receiving mad (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
comment|/* check to see if successful - by examination of the subscribe bit */
name|p_sa_mad
operator|=
operator|(
name|ib_sa_mad_t
operator|*
operator|)
operator|(
name|p_qp_ctx
operator|->
name|p_recv_buf
operator|+
name|GRH_LEN
operator|)
expr_stmt|;
if|if
condition|(
name|p_sa_mad
operator|->
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Remote error = %s\n"
argument_list|,
name|ib_get_mad_status_str
argument_list|(
operator|(
name|ib_mad_t
operator|*
operator|)
name|p_sa_mad
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_REMOTE_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET_RESP
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Expected IB_MAD_METHOD_GET_RESP but got:(%X)\n"
argument_list|,
name|p_sa_mad
operator|->
name|method
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_REMOTE_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_sa_mad
operator|->
name|attr_id
operator|!=
name|IB_MAD_ATTR_INFORM_INFO
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Expected IB_MAD_ATTR_INFORM_INFO but got:(%X)\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_REMOTE_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_ii
operator|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ii
operator|->
name|subscribe
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0126: "
literal|"Subscribe/Unsubscribe Failed\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_REMOTE_ERROR
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Send a trap (Subn LID Route) Trap(Notice) through the regular  * connection QP connection (targeted at QP0)  *  * Wait for the trap repress  */
end_comment

begin_function
name|ib_api_status_t
name|osmt_send_trap_wait_for_forward
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|,
name|IN
name|osmt_qp_ctx_t
modifier|*
name|p_qp_ctx
parameter_list|)
block|{
name|ib_smp_t
modifier|*
name|p_smp
init|=
operator|(
name|ib_smp_t
operator|*
operator|)
operator|(
name|p_qp_ctx
operator|->
name|p_send_buf
operator|)
decl_stmt|;
name|ib_mad_notice_attr_t
modifier|*
name|p_ntc
init|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|IB_MGT_ret_t
name|mgt_res
decl_stmt|;
name|VAPI_ret_t
name|vapi_ret
decl_stmt|;
name|VAPI_wc_desc_t
name|wc_desc
decl_stmt|;
name|VAPI_ud_av_hndl_t
name|avh
decl_stmt|;
name|IB_ud_av_t
name|av
decl_stmt|;
specifier|static
name|VAPI_wr_id_t
name|wrid
init|=
literal|2222
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_osmt
operator|->
name|log
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Sending Traps to QP0 of SA LID:0x%X\n"
argument_list|,
name|p_osmt
operator|->
name|local_port
operator|.
name|sm_lid
argument_list|)
expr_stmt|;
comment|/* init the MAD */
name|memset
argument_list|(
name|p_smp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_smp_t
argument_list|)
argument_list|)
expr_stmt|;
name|ib_mad_init_new
argument_list|(
operator|(
name|ib_mad_t
operator|*
operator|)
name|p_smp
argument_list|,
name|IB_MCLASS_SUBN_LID
argument_list|,
operator|(
name|uint8_t
operator|)
literal|2
argument_list|,
name|IB_MAD_METHOD_TRAP
argument_list|,
name|cl_hton64
argument_list|(
name|wrid
argument_list|)
argument_list|,
operator|(
name|ib_net16_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrid
operator|++
expr_stmt|;
name|p_smp
operator|->
name|attr_id
operator|=
name|IB_MAD_ATTR_NOTICE
expr_stmt|;
comment|/* prepare the notice */
name|p_ntc
operator|->
name|generic_type
operator|=
literal|0x82
expr_stmt|;
comment|/*  generic, type = 2 */
name|ib_notice_set_prod_type_ho
argument_list|(
name|p_ntc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p_ntc
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|=
name|cl_hton16
argument_list|(
literal|0x26
argument_list|)
expr_stmt|;
name|p_ntc
operator|->
name|issuer_lid
operator|=
name|cl_hton16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* --------------------- PREP ------------------------- */
if|if
condition|(
name|osmt_mtl_mad_post_recv_bufs
argument_list|(
operator|&
name|p_qp_ctx
operator|->
name|qp_bind_hndl
argument_list|,
name|p_qp_ctx
operator|->
name|p_recv_buf
argument_list|,
literal|1
argument_list|,
comment|/*  we need to receive both trap repress and report */
name|GRH_LEN
operator|+
name|MAD_BLOCK_SIZE
argument_list|,
name|wrid
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0127: "
literal|"Error posting recv bufs\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posted recv bufs\n"
argument_list|)
expr_stmt|;
name|av
operator|.
name|dlid
operator|=
name|p_osmt
operator|->
name|local_port
operator|.
name|sm_lid
expr_stmt|;
name|av
operator|.
name|grh_flag
operator|=
name|FALSE
expr_stmt|;
comment|/*  EZ: returned in HACK: use constants */
name|av
operator|.
name|static_rate
operator|=
literal|0
expr_stmt|;
comment|/*  p_mad_addr->static_rate; */
name|av
operator|.
name|src_path_bits
operator|=
literal|1
expr_stmt|;
comment|/*  p_mad_addr->path_bits; */
name|av
operator|.
name|sl
operator|=
literal|0
expr_stmt|;
comment|/*  p_mad_addr->addr_type.gsi.service_level; */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"av.dlid 0x%X, av.static_rate %d, av.path_bits %d\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|av
operator|.
name|dlid
argument_list|)
argument_list|,
name|av
operator|.
name|static_rate
argument_list|,
name|av
operator|.
name|src_path_bits
argument_list|)
expr_stmt|;
comment|/* send it */
name|mgt_res
operator|=
name|IB_MGT_send_mad
argument_list|(
name|p_qp_ctx
operator|->
name|ib_mgt_qp0_handle
argument_list|,
name|p_smp
argument_list|,
comment|/*  actual payload */
operator|&
name|av
argument_list|,
comment|/*  address vector */
name|wrid
argument_list|,
comment|/*  casting the mad wrapper pointer for err cb */
name|p_osmt
operator|->
name|opt
operator|.
name|transaction_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgt_res
operator|!=
name|IB_MGT_OK
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0128: "
literal|"Error sending mad (%d)\n"
argument_list|,
name|mgt_res
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|vapi_ret
operator|=
name|osmt_mtl_create_av
argument_list|(
operator|&
name|p_qp_ctx
operator|->
name|qp_bind_hndl
argument_list|,
name|p_osmt
operator|->
name|local_port
operator|.
name|sm_lid
argument_list|,
operator|&
name|avh
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0129: "
literal|"Error Preparing AVH (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Prepared AVH\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Trap MAD Sent\n"
argument_list|)
expr_stmt|;
comment|/* --------------------- RECV ------------------------- */
name|vapi_ret
operator|=
name|osmt_mtl_mad_poll4cqe
argument_list|(
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|hca_hndl
argument_list|,
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|rq_cq_hndl
argument_list|,
operator|&
name|wc_desc
argument_list|,
literal|200
argument_list|,
literal|10000
argument_list|,
operator|&
name|avh
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_SUCCESS
condition|)
block|{
if|if
condition|(
name|vapi_ret
operator|==
name|VAPI_CQ_EMPTY
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0130: "
literal|"Timeout receiving mad (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0131: "
literal|"Error receiving mad (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
comment|/* check to see if successful - by examination of the subscribe bit */
name|p_sa_mad
operator|=
operator|(
name|ib_sa_mad_t
operator|*
operator|)
operator|(
name|p_qp_ctx
operator|->
name|p_recv_buf
operator|+
name|GRH_LEN
operator|)
expr_stmt|;
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_REPORT
condition|)
block|{
if|if
condition|(
name|p_sa_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_NOTICE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Received the Report!\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1020"
literal|"Did not receive a Report(Notice) but attr:%d\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1020"
literal|"Received an Unexpected Method:%d\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for a trap on QPn  *  */
end_comment

begin_function
name|ib_api_status_t
name|osmt_trap_wait
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|,
name|IN
name|osmt_qp_ctx_t
modifier|*
name|p_qp_ctx
parameter_list|)
block|{
name|ib_smp_t
modifier|*
name|p_smp
init|=
operator|(
name|ib_smp_t
operator|*
operator|)
operator|(
name|p_qp_ctx
operator|->
name|p_send_buf
operator|)
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|VAPI_ret_t
name|vapi_ret
decl_stmt|;
name|VAPI_wc_desc_t
name|wc_desc
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_osmt
operator|->
name|log
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Waiting for Traps under QP:0x%X of SA LID:0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_osmt
operator|->
name|local_port
operator|.
name|sm_lid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* --------------------- RECV ------------------------- */
name|vapi_ret
operator|=
name|osmt_mtl_mad_poll4cqe
argument_list|(
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|hca_hndl
argument_list|,
name|p_qp_ctx
operator|->
name|qp_bind_hndl
operator|.
name|rq_cq_hndl
argument_list|,
operator|&
name|wc_desc
argument_list|,
comment|// 200,
name|p_osmt
operator|->
name|opt
operator|.
name|wait_time
operator|*
literal|100
argument_list|,
literal|10000
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vapi_ret
operator|!=
name|VAPI_SUCCESS
condition|)
block|{
if|if
condition|(
name|vapi_ret
operator|==
name|VAPI_CQ_EMPTY
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0130: "
literal|"Timeout receiving mad (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0131: "
literal|"Error receiving mad (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|vapi_ret
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
comment|/* check to see if successful - by examination of the subscribe bit */
name|p_sa_mad
operator|=
operator|(
name|ib_sa_mad_t
operator|*
operator|)
operator|(
name|p_qp_ctx
operator|->
name|p_recv_buf
operator|+
name|GRH_LEN
operator|)
expr_stmt|;
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_REPORT
condition|)
block|{
if|if
condition|(
name|p_sa_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_NOTICE
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Received the Report!\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1020"
literal|"Did not receive a Report(Notice) but attr:%d\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1020"
literal|"Received an Unexpected Method:%d\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize an inform info attribute:  * Catch all traps in the lid range of the p_osmt  *  */
end_comment

begin_function
name|ib_api_status_t
name|osmt_init_inform_info
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|,
name|OUT
name|ib_inform_info_t
modifier|*
name|p_ii
parameter_list|)
block|{
name|memset
argument_list|(
name|p_ii
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_inform_info_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  p_ii->lid_range_begin = cl_hton16(1); */
name|p_ii
operator|->
name|lid_range_begin
operator|=
literal|0xFFFF
expr_stmt|;
name|p_ii
operator|->
name|lid_range_end
operator|=
name|cl_hton16
argument_list|(
name|p_osmt
operator|->
name|max_lid
argument_list|)
expr_stmt|;
name|p_ii
operator|->
name|is_generic
operator|=
literal|1
expr_stmt|;
comment|/*  have to choose */
name|p_ii
operator|->
name|trap_type
operator|=
literal|0xFFFF
expr_stmt|;
comment|/*  ALL */
name|p_ii
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|=
literal|0xFFFF
expr_stmt|;
comment|/*  ALL */
name|p_ii
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|node_type_lsb
operator|=
literal|0xFFFF
expr_stmt|;
comment|/*  ALL */
name|p_ii
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|node_type_msb
operator|=
literal|0xFF
expr_stmt|;
comment|/*  ALL */
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osmt_init_inform_info_by_trap
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|,
name|IN
name|ib_net16_t
name|trap_num
parameter_list|,
name|OUT
name|ib_inform_info_t
modifier|*
name|p_ii
parameter_list|)
block|{
name|memset
argument_list|(
name|p_ii
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_inform_info_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  p_ii->lid_range_begin = cl_hton16(1); */
name|p_ii
operator|->
name|lid_range_begin
operator|=
literal|0xFFFF
expr_stmt|;
name|p_ii
operator|->
name|lid_range_end
operator|=
name|cl_hton16
argument_list|(
name|p_osmt
operator|->
name|max_lid
argument_list|)
expr_stmt|;
name|p_ii
operator|->
name|is_generic
operator|=
literal|1
expr_stmt|;
comment|/*  have to choose */
name|p_ii
operator|->
name|trap_type
operator|=
literal|0xFFFF
expr_stmt|;
comment|/*  ALL */
name|p_ii
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|=
name|trap_num
expr_stmt|;
comment|/*  ALL */
name|p_ii
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|node_type_lsb
operator|=
literal|0xFFFF
expr_stmt|;
comment|/*  ALL */
name|p_ii
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|node_type_msb
operator|=
literal|0xFF
expr_stmt|;
comment|/*  ALL */
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Run a complete inform info test flow:  * - try to unregister inform info (should fail)  * - register an inform info  * - try to unregister inform info (should succeed)  * - register an inform info  * - send a trap - sleep  * - check that a Report(Notice) arrived that match the sent one  *  */
end_comment

begin_function
name|ib_api_status_t
name|osmt_run_inform_info_flow
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|)
block|{
name|ib_inform_info_t
name|inform_info
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osmt_qp_ctx_t
name|qp_ctx
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* bind the QP */
name|status
operator|=
name|osmt_bind_inform_qp
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* init the inform info */
name|osmt_init_inform_info
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|inform_info
argument_list|)
expr_stmt|;
comment|/* first try to unsubscribe */
name|status
operator|=
name|osmt_reg_unreg_inform_info
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|,
operator|&
name|inform_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* WAS IB_REMOTE_ERROR */
if|if
condition|(
name|status
operator|!=
name|IB_REMOTE_ERROR
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Error during UnSubscribe: (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Expected Failure to UnSubscribe non existing InformInfo\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* send the inform info registration */
name|status
operator|=
name|osmt_reg_unreg_inform_info
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|,
operator|&
name|inform_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* send a trap through QP0 and wait on QPN */
name|status
operator|=
name|osmt_send_trap_wait_for_forward
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Error during Send Trap and Wait For Report: (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* try to unsubscribe for cleanup */
name|status
operator|=
name|osmt_reg_unreg_inform_info
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|,
operator|&
name|inform_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Error during UnSubscribe: (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|==
name|IB_REMOTE_ERROR
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Remote Error during UnSubscribe\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|osmt_unbind_inform_qp
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Run a complete inform info test flow:  * - try to unregister inform info (should fail)  * - register an inform info  * - try to unregister inform info (should succeed)  * - register an inform info  * - send a trap - sleep  * - check that a Report(Notice) arrived that match the sent one  *  */
end_comment

begin_function
name|ib_api_status_t
name|osmt_run_trap64_65_flow
parameter_list|(
name|IN
name|osmtest_t
modifier|*
specifier|const
name|p_osmt
parameter_list|)
block|{
name|ib_inform_info_t
name|inform_info
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osmt_qp_ctx_t
name|qp_ctx
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* bind the QP */
name|status
operator|=
name|osmt_bind_inform_qp
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* init the inform info */
name|osmt_init_inform_info_by_trap
argument_list|(
name|p_osmt
argument_list|,
name|cl_hton16
argument_list|(
literal|64
argument_list|)
argument_list|,
operator|&
name|inform_info
argument_list|)
expr_stmt|;
comment|/* send the inform info registration */
name|status
operator|=
name|osmt_reg_unreg_inform_info
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|,
operator|&
name|inform_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/*--------------------- PREP -------------------------*/
if|if
condition|(
name|osmt_mtl_mad_post_recv_bufs
argument_list|(
operator|&
name|qp_ctx
operator|.
name|qp_bind_hndl
argument_list|,
name|qp_ctx
operator|.
name|p_recv_buf
argument_list|,
literal|1
argument_list|,
comment|/* we need to receive the report */
name|GRH_LEN
operator|+
name|MAD_BLOCK_SIZE
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0127: "
literal|"Error posting recv bufs for trap 64\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posted recv bufs for trap 64\n"
argument_list|)
expr_stmt|;
comment|/* init the inform info */
name|osmt_init_inform_info_by_trap
argument_list|(
name|p_osmt
argument_list|,
name|cl_hton16
argument_list|(
literal|65
argument_list|)
argument_list|,
operator|&
name|inform_info
argument_list|)
expr_stmt|;
comment|/* send the inform info registration */
name|status
operator|=
name|osmt_reg_unreg_inform_info
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|,
operator|&
name|inform_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/*--------------------- PREP -------------------------*/
if|if
condition|(
name|osmt_mtl_mad_post_recv_bufs
argument_list|(
operator|&
name|qp_ctx
operator|.
name|qp_bind_hndl
argument_list|,
name|qp_ctx
operator|.
name|p_recv_buf
argument_list|,
literal|1
argument_list|,
comment|/* we need to reveive the report */
name|GRH_LEN
operator|+
name|MAD_BLOCK_SIZE
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0127: "
literal|"Error posting recv bufs for trap 65\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posted recv bufs for trap 65\n"
argument_list|)
expr_stmt|;
comment|/* Sleep for x seconds in order to allow external script trap generation */
if|#
directive|if
literal|0
block|sleep(p_osmt->opt.wait_time);
endif|#
directive|endif
comment|/* wait for a trap on QPN */
name|status
operator|=
name|osmt_trap_wait
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Error during Send Trap and Wait For Report: (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* try to unsubscribe for cleanup */
name|status
operator|=
name|osmt_reg_unreg_inform_info
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|,
operator|&
name|inform_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Error during UnSubscribe: (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|osmt_unbind_inform_qp
argument_list|(
name|p_osmt
argument_list|,
operator|&
name|qp_ctx
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_osmt
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  OSM_VENDOR_INTF_MTL */
end_comment

end_unit

