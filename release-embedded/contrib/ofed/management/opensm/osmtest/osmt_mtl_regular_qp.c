begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSM_VENDOR_INTF_MTL
end_ifdef

begin_comment
comment|/*                  - Mellanox Confidential and Proprietary -  *  *  Copyright (C) Jul. 2001, Mellanox Technologies Ltd.  ALL RIGHTS RESERVED.  *  *  Except as specifically permitted herein, no portion of the information,  *  including but not limited to object code and source code, may be reproduced,  *  modified, distributed, republished or otherwise exploited in any form or by  *  any means for any purpose without the prior written permission of Mellanox  *  Technologies Ltd. Use of software subject to the terms and conditions  *  detailed in the file "LICENSE.txt".  *  *  End of legal section ......................................................  *  *  osmt_mtl_regular_qp.c -  *    Provide Simple Interface for Sending and Receiving MADS through a regular QP  *  *  Creation date:  *  *  Version: $Id$  *  *  Authors:  *    Eitan Zahavi  *  *  Changes:  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<mtl_common.h>
end_include

begin_include
include|#
directive|include
file|<vapi.h>
end_include

begin_include
include|#
directive|include
file|<evapi.h>
end_include

begin_include
include|#
directive|include
file|<vapi_common.h>
end_include

begin_include
include|#
directive|include
file|<ib_defs.h>
end_include

begin_include
include|#
directive|include
file|<osmt_mtl_regular_qp.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_types.h>
end_include

begin_comment
comment|/*  * Initialize the QP etc.  * Given in res: port_num, max_outs_sq, max_outs_rq  */
end_comment

begin_function
name|VAPI_ret_t
name|osmt_mtl_get_qp_resources
parameter_list|(
name|IN
name|OUT
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|)
block|{
name|VAPI_ret_t
name|ret
decl_stmt|;
name|VAPI_hca_port_t
name|hca_port_info
decl_stmt|;
name|VAPI_qp_init_attr_t
name|qp_init_attr
decl_stmt|;
name|VAPI_qp_prop_t
name|qp_prop
decl_stmt|;
name|VAPI_cqe_num_t
name|act_num
decl_stmt|;
comment|/* Get HCA LID */
name|ret
operator|=
name|VAPI_query_hca_port_prop
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|port_num
argument_list|,
operator|&
name|hca_port_info
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
name|res
operator|->
name|slid
operator|=
name|hca_port_info
operator|.
name|lid
expr_stmt|;
comment|/* Get a PD */
name|ret
operator|=
name|VAPI_alloc_pd
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
operator|&
operator|(
name|res
operator|->
name|pd_hndl
operator|)
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
comment|/* Create CQ for RQ and SQ */
comment|/* TBD - Check we have enough act nums */
name|ret
operator|=
name|VAPI_create_cq
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|max_outs_sq
operator|+
literal|1
argument_list|,
operator|&
operator|(
name|res
operator|->
name|sq_cq_hndl
operator|)
argument_list|,
operator|&
name|act_num
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
name|ret
operator|=
name|VAPI_create_cq
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|max_outs_rq
operator|+
literal|1
argument_list|,
operator|&
operator|(
name|res
operator|->
name|rq_cq_hndl
operator|)
argument_list|,
operator|&
name|act_num
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
comment|/* register event handlers for polling(block mode) internal use */
comment|/* ret= EVAPI_set_comp_eventh(res->hca_hndl,res->rq_cq_hndl, */
comment|/*                            EVAPI_POLL_CQ_UNBLOCK_HANDLER,NULL,&(res->rq_cq_eventh)); */
comment|/* VAPI_CHECK_RET; */
comment|/* ret= EVAPI_set_comp_eventh(res->hca_hndl,res->sq_cq_hndl, */
comment|/*                            EVAPI_POLL_CQ_UNBLOCK_HANDLER,NULL,&(res->sq_cq_eventh)); */
comment|/* VAPI_CHECK_RET; */
comment|/* Create QP */
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_oust_wr_sq
operator|=
name|res
operator|->
name|max_outs_sq
operator|+
literal|1
expr_stmt|;
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_oust_wr_rq
operator|=
name|res
operator|->
name|max_outs_rq
operator|+
literal|1
expr_stmt|;
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_sg_size_sq
operator|=
literal|4
expr_stmt|;
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_sg_size_rq
operator|=
literal|4
expr_stmt|;
name|qp_init_attr
operator|.
name|pd_hndl
operator|=
name|res
operator|->
name|pd_hndl
expr_stmt|;
name|qp_init_attr
operator|.
name|rdd_hndl
operator|=
literal|0
expr_stmt|;
name|qp_init_attr
operator|.
name|rq_cq_hndl
operator|=
name|res
operator|->
name|rq_cq_hndl
expr_stmt|;
name|qp_init_attr
operator|.
name|rq_sig_type
operator|=
name|VAPI_SIGNAL_ALL_WR
expr_stmt|;
comment|/* That's default for IB */
name|qp_init_attr
operator|.
name|sq_cq_hndl
operator|=
name|res
operator|->
name|sq_cq_hndl
expr_stmt|;
name|qp_init_attr
operator|.
name|sq_sig_type
operator|=
name|VAPI_SIGNAL_REQ_WR
expr_stmt|;
name|qp_init_attr
operator|.
name|ts_type
operator|=
name|VAPI_TS_UD
expr_stmt|;
name|ret
operator|=
name|VAPI_create_qp
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
operator|&
name|qp_init_attr
argument_list|,
operator|&
operator|(
name|res
operator|->
name|qp_hndl
operator|)
argument_list|,
operator|&
name|qp_prop
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
name|res
operator|->
name|qp_id
operator|.
name|qp_num
operator|=
name|qp_prop
operator|.
name|qp_num
expr_stmt|;
return|return
operator|(
name|VAPI_OK
operator|)
return|;
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_qp_init
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|)
block|{
name|VAPI_ret_t
name|ret
decl_stmt|;
name|VAPI_qp_attr_t
name|qp_attr
decl_stmt|;
name|VAPI_qp_attr_mask_t
name|qp_attr_mask
decl_stmt|;
name|VAPI_qp_cap_t
name|qp_cap
decl_stmt|;
comment|/* 	 * Change QP to INIT 	 * 	 */
name|QP_ATTR_MASK_CLR_ALL
argument_list|(
name|qp_attr_mask
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|qp_state
operator|=
name|VAPI_INIT
expr_stmt|;
name|QP_ATTR_MASK_SET
argument_list|(
name|qp_attr_mask
argument_list|,
name|QP_ATTR_QP_STATE
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|pkey_ix
operator|=
literal|0
expr_stmt|;
name|QP_ATTR_MASK_SET
argument_list|(
name|qp_attr_mask
argument_list|,
name|QP_ATTR_PKEY_IX
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|port
operator|=
name|res
operator|->
name|port_num
expr_stmt|;
name|QP_ATTR_MASK_SET
argument_list|(
name|qp_attr_mask
argument_list|,
name|QP_ATTR_PORT
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|qkey
operator|=
name|res
operator|->
name|qkey
expr_stmt|;
name|QP_ATTR_MASK_SET
argument_list|(
name|qp_attr_mask
argument_list|,
name|QP_ATTR_QKEY
argument_list|)
expr_stmt|;
comment|/* If I do not set this mask, I get an error from HH. QPM should catch it */
name|ret
operator|=
name|VAPI_modify_qp
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|qp_hndl
argument_list|,
operator|&
name|qp_attr
argument_list|,
operator|&
name|qp_attr_mask
argument_list|,
operator|&
name|qp_cap
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_qp_2_rtr_rts
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|)
block|{
name|VAPI_ret_t
name|ret
decl_stmt|;
name|VAPI_qp_attr_t
name|qp_attr
decl_stmt|;
name|VAPI_qp_attr_mask_t
name|qp_attr_mask
decl_stmt|;
name|VAPI_qp_cap_t
name|qp_cap
decl_stmt|;
comment|/* 	 *  Change QP to RTR 	 * 	 */
name|QP_ATTR_MASK_CLR_ALL
argument_list|(
name|qp_attr_mask
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|qp_state
operator|=
name|VAPI_RTR
expr_stmt|;
name|QP_ATTR_MASK_SET
argument_list|(
name|qp_attr_mask
argument_list|,
name|QP_ATTR_QP_STATE
argument_list|)
expr_stmt|;
comment|/*   qp_attr.rq_psn   = 0;                */
comment|/*   QP_ATTR_MASK_SET(qp_attr_mask,QP_ATTR_RQ_PSN); */
name|ret
operator|=
name|VAPI_modify_qp
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|qp_hndl
argument_list|,
operator|&
name|qp_attr
argument_list|,
operator|&
name|qp_attr_mask
argument_list|,
operator|&
name|qp_cap
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
comment|/* 	 * Change QP to RTS 	 * 	 */
name|QP_ATTR_MASK_CLR_ALL
argument_list|(
name|qp_attr_mask
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|qp_state
operator|=
name|VAPI_RTS
expr_stmt|;
name|QP_ATTR_MASK_SET
argument_list|(
name|qp_attr_mask
argument_list|,
name|QP_ATTR_QP_STATE
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|sq_psn
operator|=
literal|0
expr_stmt|;
name|QP_ATTR_MASK_SET
argument_list|(
name|qp_attr_mask
argument_list|,
name|QP_ATTR_SQ_PSN
argument_list|)
expr_stmt|;
name|ret
operator|=
name|VAPI_modify_qp
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|qp_hndl
argument_list|,
operator|&
name|qp_attr
argument_list|,
operator|&
name|qp_attr_mask
argument_list|,
operator|&
name|qp_cap
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_mad_create_mr
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|)
block|{
name|VAPI_ret_t
name|ret
decl_stmt|;
name|VAPI_mrw_t
name|mr_in
decl_stmt|,
name|mr_out
decl_stmt|;
name|res
operator|->
name|buf_size
operator|=
operator|(
name|MAD_SIZE
operator|+
name|GRH_LEN
operator|)
operator|*
operator|(
name|res
operator|->
name|max_outs_sq
operator|+
name|res
operator|->
name|max_outs_rq
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Register single memory address region for all buffers */
name|res
operator|->
name|buf_ptr
operator|=
name|VMALLOC
argument_list|(
name|res
operator|->
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|buf_ptr
operator|==
operator|(
operator|(
name|VAPI_virt_addr_t
operator|)
name|NULL
operator|)
condition|)
block|{
name|ret
operator|=
name|VAPI_EAGAIN
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
block|}
comment|/* Enable local and remote access to memory region */
name|mr_in
operator|.
name|acl
operator|=
name|VAPI_EN_LOCAL_WRITE
operator||
name|VAPI_EN_REMOTE_WRITE
expr_stmt|;
name|mr_in
operator|.
name|l_key
operator|=
literal|0
expr_stmt|;
name|mr_in
operator|.
name|pd_hndl
operator|=
name|res
operator|->
name|pd_hndl
expr_stmt|;
name|mr_in
operator|.
name|r_key
operator|=
literal|0
expr_stmt|;
name|mr_in
operator|.
name|size
operator|=
name|res
operator|->
name|buf_size
expr_stmt|;
name|ASSERT_VOIDP2UINTN
argument_list|(
name|res
operator|->
name|buf_ptr
argument_list|)
expr_stmt|;
name|mr_in
operator|.
name|start
operator|=
call|(
name|VAPI_virt_addr_t
call|)
argument_list|(
name|uintn_t
argument_list|)
argument_list|(
name|res
operator|->
name|buf_ptr
argument_list|)
expr_stmt|;
name|mr_in
operator|.
name|type
operator|=
name|VAPI_MR
expr_stmt|;
name|ret
operator|=
name|VAPI_register_mr
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
operator|&
name|mr_in
argument_list|,
operator|&
operator|(
name|res
operator|->
name|mr_hndl
operator|)
argument_list|,
operator|&
name|mr_out
argument_list|)
expr_stmt|;
name|VAPI_CHECK_RET
expr_stmt|;
name|res
operator|->
name|l_key
operator|=
name|mr_out
operator|.
name|l_key
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_init_opened_hca
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|)
block|{
name|VAPI_ret_t
name|ret
decl_stmt|;
name|res
operator|->
name|pd_hndl
operator|=
name|VAPI_INVAL_HNDL
expr_stmt|;
name|res
operator|->
name|rq_cq_hndl
operator|=
name|VAPI_INVAL_HNDL
expr_stmt|;
name|res
operator|->
name|sq_cq_hndl
operator|=
name|VAPI_INVAL_HNDL
expr_stmt|;
name|res
operator|->
name|sq_cq_eventh
operator|=
name|VAPI_INVAL_HNDL
expr_stmt|;
name|res
operator|->
name|rq_cq_eventh
operator|=
name|VAPI_INVAL_HNDL
expr_stmt|;
name|res
operator|->
name|qp_hndl
operator|=
name|VAPI_INVAL_HNDL
expr_stmt|;
name|res
operator|->
name|mr_hndl
operator|=
name|VAPI_INVAL_HNDL
expr_stmt|;
comment|/* 	 * Create QP 	 * 	 */
name|ret
operator|=
name|osmt_mtl_get_qp_resources
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* 	 * Move to init 	 * 	 */
name|ret
operator|=
name|osmt_mtl_qp_init
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* 	 * Initialize memory regions 	 * 	 */
name|ret
operator|=
name|osmt_mtl_mad_create_mr
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* only now move to RTR and RTS */
name|ret
operator|=
name|osmt_mtl_qp_2_rtr_rts
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
name|VAPI_OK
return|;
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_mad_cleanup
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|qp_hndl
operator|!=
name|VAPI_INVAL_HNDL
condition|)
block|{
name|VAPI_destroy_qp
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|qp_hndl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|sq_cq_eventh
operator|!=
name|VAPI_INVAL_HNDL
condition|)
block|{
name|EVAPI_clear_comp_eventh
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|sq_cq_eventh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|rq_cq_eventh
operator|!=
name|VAPI_INVAL_HNDL
condition|)
block|{
name|EVAPI_clear_comp_eventh
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|rq_cq_eventh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|rq_cq_hndl
operator|!=
name|VAPI_INVAL_HNDL
condition|)
block|{
name|VAPI_destroy_cq
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|rq_cq_hndl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|sq_cq_hndl
operator|!=
name|VAPI_INVAL_HNDL
condition|)
block|{
name|VAPI_destroy_cq
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|sq_cq_hndl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|mr_hndl
operator|!=
name|VAPI_INVAL_HNDL
condition|)
block|{
name|VAPI_deregister_mr
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|mr_hndl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|pd_hndl
operator|!=
name|VAPI_INVAL_HNDL
condition|)
block|{
name|VAPI_dealloc_pd
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|pd_hndl
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* open/close of HCA should be done system wide - not per application */
block|if (res->hca_hndl != VAPI_INVAL_HNDL) { 		VAPI_close_hca(res->hca_hndl);
comment|/* TBD: HCA_open/close should be done on a system wide basis */
block|}
endif|#
directive|endif
return|return
name|VAPI_OK
return|;
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_create_av
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|,
name|int16_t
name|dlid
parameter_list|,
name|VAPI_ud_av_hndl_t
modifier|*
name|avh_p
parameter_list|)
block|{
name|VAPI_ud_av_t
name|av
decl_stmt|;
name|VAPI_ret_t
name|ret
decl_stmt|;
name|av
operator|.
name|dlid
operator|=
name|dlid
expr_stmt|;
name|av
operator|.
name|port
operator|=
name|res
operator|->
name|port_num
expr_stmt|;
name|av
operator|.
name|sl
operator|=
literal|0
expr_stmt|;
comment|/* dest->sl; */
name|av
operator|.
name|src_path_bits
operator|=
literal|0
expr_stmt|;
comment|/*  dest->ee_dlid.dst_path_bits; */
name|av
operator|.
name|static_rate
operator|=
literal|0
expr_stmt|;
comment|/* GRH ? */
name|av
operator|.
name|grh_flag
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|VAPI_create_addr_hndl
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|pd_hndl
argument_list|,
operator|&
name|av
argument_list|,
name|avh_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|MTL_ERROR1
argument_list|(
literal|"%s: failed VAPI_create_addr_hndl (%s)\n"
argument_list|,
name|__func__
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|VAPI_OK
return|;
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_mad_send
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|,
name|VAPI_wr_id_t
name|id
parameter_list|,
name|void
modifier|*
name|mad
parameter_list|,
name|VAPI_qp_num_t
name|dest_qp
parameter_list|,
name|IB_sl_t
name|sl
parameter_list|,
name|u_int32_t
name|dest_qkey
parameter_list|,
name|VAPI_ud_av_hndl_t
name|avh
parameter_list|)
block|{
name|VAPI_sr_desc_t
name|sr
decl_stmt|;
name|VAPI_sg_lst_entry_t
name|sg_entry
decl_stmt|;
name|VAPI_ret_t
name|ret
decl_stmt|;
comment|/* building SEND request */
name|sr
operator|.
name|opcode
operator|=
name|VAPI_SEND
expr_stmt|;
name|sr
operator|.
name|remote_ah
operator|=
name|avh
expr_stmt|;
name|sr
operator|.
name|remote_qp
operator|=
name|dest_qp
expr_stmt|;
name|sr
operator|.
name|remote_qkey
operator|=
name|dest_qkey
expr_stmt|;
name|sr
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|sr
operator|.
name|set_se
operator|=
name|FALSE
expr_stmt|;
name|sr
operator|.
name|fence
operator|=
name|FALSE
expr_stmt|;
name|sr
operator|.
name|comp_type
operator|=
name|VAPI_SIGNALED
expr_stmt|;
name|sr
operator|.
name|sg_lst_len
operator|=
literal|1
expr_stmt|;
name|sr
operator|.
name|sg_lst_p
operator|=
operator|&
name|sg_entry
expr_stmt|;
name|ASSERT_VOIDP2UINTN
argument_list|(
name|mad
argument_list|)
expr_stmt|;
name|sg_entry
operator|.
name|addr
operator|=
call|(
name|VAPI_virt_addr_t
call|)
argument_list|(
name|uintn_t
argument_list|)
argument_list|(
name|mad
argument_list|)
expr_stmt|;
name|sg_entry
operator|.
name|len
operator|=
name|MAD_SIZE
expr_stmt|;
name|sg_entry
operator|.
name|lkey
operator|=
name|res
operator|->
name|l_key
expr_stmt|;
name|ret
operator|=
name|VAPI_post_sr
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|qp_hndl
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|MTL_ERROR1
argument_list|(
name|__FUNCTION__
literal|": failed VAPI_post_sr (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|VAPI_OK
return|;
block|}
end_function

begin_function
name|int
name|osmt_mtl_mad_post_recv_bufs
parameter_list|(
name|osmt_mtl_mad_res_t
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|buf_array
parameter_list|,
name|u_int32_t
name|num_o_bufs
parameter_list|,
name|u_int32_t
name|size
parameter_list|,
name|VAPI_wr_id_t
name|start_id
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|void
modifier|*
name|cur_buf
decl_stmt|;
name|VAPI_rr_desc_t
name|rr
decl_stmt|;
name|VAPI_sg_lst_entry_t
name|sg_entry
decl_stmt|;
name|VAPI_ret_t
name|ret
decl_stmt|;
name|rr
operator|.
name|opcode
operator|=
name|VAPI_RECEIVE
expr_stmt|;
name|rr
operator|.
name|comp_type
operator|=
name|VAPI_SIGNALED
expr_stmt|;
comment|/* All with CQE (IB compliant) */
name|rr
operator|.
name|sg_lst_len
operator|=
literal|1
expr_stmt|;
comment|/* single buffers */
name|rr
operator|.
name|sg_lst_p
operator|=
operator|&
name|sg_entry
expr_stmt|;
name|sg_entry
operator|.
name|lkey
operator|=
name|res
operator|->
name|l_key
expr_stmt|;
name|cur_buf
operator|=
name|buf_array
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_o_bufs
condition|;
name|i
operator|++
control|)
block|{
name|rr
operator|.
name|id
operator|=
name|start_id
operator|+
name|i
expr_stmt|;
comment|/* WQE id used is the index to buffers ptr array */
name|ASSERT_VOIDP2UINTN
argument_list|(
name|cur_buf
argument_list|)
expr_stmt|;
name|sg_entry
operator|.
name|addr
operator|=
operator|(
name|VAPI_virt_addr_t
operator|)
operator|(
name|uintn_t
operator|)
name|cur_buf
expr_stmt|;
name|sg_entry
operator|.
name|len
operator|=
name|size
expr_stmt|;
name|memset
argument_list|(
name|cur_buf
argument_list|,
literal|0x00
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* fill with 0 */
name|ret
operator|=
name|VAPI_post_rr
argument_list|(
name|res
operator|->
name|hca_hndl
argument_list|,
name|res
operator|->
name|qp_hndl
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|MTL_ERROR1
argument_list|(
name|__FUNCTION__
literal|": failed posting RQ WQE (%s)\n"
argument_list|,
name|VAPI_strerror_sym
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
name|MTL_DEBUG4
argument_list|(
name|__FUNCTION__
literal|": posted buf at %p\n"
argument_list|,
name|cur_buf
argument_list|)
expr_stmt|;
name|cur_buf
operator|+=
name|size
expr_stmt|;
block|}
return|return
name|i
return|;
comment|/* num of buffers posted */
block|}
end_function

begin_function
name|VAPI_ret_t
name|osmt_mtl_mad_poll4cqe
parameter_list|(
name|VAPI_hca_hndl_t
name|hca
parameter_list|,
name|VAPI_cq_hndl_t
name|cq
parameter_list|,
name|VAPI_wc_desc_t
modifier|*
name|wc_desc_p
parameter_list|,
name|u_int32_t
name|max_poll
parameter_list|,
name|u_int32_t
name|poll_sleep
parameter_list|,
name|VAPI_ud_av_hndl_t
modifier|*
name|avh_p
parameter_list|)
block|{
name|VAPI_ret_t
name|ret
init|=
name|VAPI_CQ_EMPTY
decl_stmt|;
name|u_int32_t
name|poll_cnt
init|=
literal|0
decl_stmt|;
comment|/* wait for something to arrive */
while|while
condition|(
operator|(
name|ret
operator|==
name|VAPI_CQ_EMPTY
operator|)
operator|&&
operator|(
name|poll_cnt
operator|<
name|max_poll
operator|)
condition|)
block|{
name|ret
operator|=
name|VAPI_poll_cq
argument_list|(
name|hca
argument_list|,
name|cq
argument_list|,
name|wc_desc_p
argument_list|)
expr_stmt|;
comment|/* don't sleep if we already succeeded) */
if|if
condition|(
name|ret
operator|!=
name|VAPI_CQ_EMPTY
condition|)
block|{
break|break;
block|}
name|usleep
argument_list|(
name|poll_sleep
argument_list|)
expr_stmt|;
name|poll_cnt
operator|++
expr_stmt|;
block|}
comment|/* if passed an AVH to destory - do it */
if|if
condition|(
name|avh_p
operator|!=
name|NULL
condition|)
block|{
name|VAPI_destroy_addr_hndl
argument_list|(
name|hca
argument_list|,
operator|*
name|avh_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|poll_cnt
operator|==
name|max_poll
operator|)
operator|&&
operator|(
name|ret
operator|==
name|VAPI_CQ_EMPTY
operator|)
condition|)
block|{
name|MTL_DEBUG1
argument_list|(
name|__FUNCTION__
literal|": Failed to get completion on wq after %d polls.\n"
argument_list|,
name|max_poll
argument_list|)
expr_stmt|;
return|return
name|VAPI_CQ_EMPTY
return|;
block|}
if|if
condition|(
name|ret
operator|!=
name|VAPI_OK
condition|)
block|{
name|MTL_DEBUG1
argument_list|(
name|__FUNCTION__
literal|": VAPI_poll_cq failed with ret=%s on sq_cq\n"
argument_list|,
name|mtl_strerror_sym
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|wc_desc_p
operator|->
name|status
operator|!=
name|VAPI_SUCCESS
condition|)
block|{
name|MTL_DEBUG1
argument_list|(
name|__FUNCTION__
literal|": completion error (%d) detected\n"
argument_list|,
name|wc_desc_p
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|VAPI_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  OSM_VENDOR_INTF_MTL */
end_comment

end_unit

