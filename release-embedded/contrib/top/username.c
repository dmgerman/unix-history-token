begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Top users/processes display for Unix  *  Version 3  *  *  This program may be freely redistributed,  *  but this entire comment MUST remain intact.  *  *  Copyright (c) 1984, 1989, William LeFebvre, Rice University  *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  Username translation code for top.  *  *  These routines handle uid to username mapping.  *  They use a hashing table scheme to reduce reading overhead.  *  For the time being, these are very straightforward hashing routines.  *  Maybe someday I'll put in something better.  But with the advent of  *  "random access" password files, it might not be worth the effort.  *  *  Changes to these have been provided by John Gilmore (gnu@toad.com).  *  *  The hash has been simplified in this release, to avoid the  *  table overflow problems of previous releases.  If the value  *  at the initial hash location is not right, it is replaced  *  by the right value.  Collisions will cause us to call getpw*  *  but hey, this is a cache, not the Library of Congress.  *  This makes the table size independent of the passwd file size.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"top.local.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_struct
struct|struct
name|hash_el
block|{
name|int
name|uid
decl_stmt|;
name|char
name|name
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|is_empty_hash
parameter_list|(
name|x
parameter_list|)
value|(hash_table[x].name[0] == 0)
end_define

begin_comment
comment|/* simple minded hashing function */
end_comment

begin_comment
comment|/* Uid "nobody" is -2 results in hashit(-2) = -2 which is out of bounds for    the hash_table.  Applied abs() function to fix. 2/16/96 tpugh */
end_comment

begin_define
define|#
directive|define
name|hashit
parameter_list|(
name|i
parameter_list|)
value|(abs(i) % Table_size)
end_define

begin_comment
comment|/* K&R requires that statically declared tables be initialized to zero. */
end_comment

begin_comment
comment|/* We depend on that for hash_table and YOUR compiler had BETTER do it! */
end_comment

begin_decl_stmt
name|struct
name|hash_el
name|hash_table
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|init_hash
argument_list|()
end_macro

begin_block
block|{
comment|/*      *  There used to be some steps we had to take to initialize things.      *  We don't need to do that anymore, but we will leave this stub in      *  just in case future changes require initialization steps.      */
block|}
end_block

begin_function
name|char
modifier|*
name|username
parameter_list|(
name|uid
parameter_list|)
specifier|register
name|int
name|uid
decl_stmt|;
block|{
specifier|register
name|int
name|hashindex
decl_stmt|;
name|hashindex
operator|=
name|hashit
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_empty_hash
argument_list|(
name|hashindex
argument_list|)
operator|||
operator|(
name|hash_table
index|[
name|hashindex
index|]
operator|.
name|uid
operator|!=
name|uid
operator|)
condition|)
block|{
comment|/* not here or not right -- get it out of passwd */
name|hashindex
operator|=
name|get_user
argument_list|(
name|uid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hash_table
index|[
name|hashindex
index|]
operator|.
name|name
operator|)
return|;
block|}
end_function

begin_function
name|int
name|userid
parameter_list|(
name|username
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
comment|/* Eventually we want this to enter everything in the hash table,        but for now we just do it simply and remember just the result.      */
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* enter the result in the hash table */
name|enter_user
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|username
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* return our result */
return|return
operator|(
name|pwd
operator|->
name|pw_uid
operator|)
return|;
block|}
end_function

begin_function
name|int
name|enter_user
parameter_list|(
name|uid
parameter_list|,
name|name
parameter_list|,
name|wecare
parameter_list|)
specifier|register
name|int
name|uid
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|wecare
decl_stmt|;
comment|/* 1 = enter it always, 0 = nice to have */
block|{
specifier|register
name|int
name|hashindex
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"enter_hash(%d, %s, %d)\n"
argument_list|,
name|uid
argument_list|,
name|name
argument_list|,
name|wecare
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hashindex
operator|=
name|hashit
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_empty_hash
argument_list|(
name|hashindex
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|wecare
condition|)
return|return
literal|0
return|;
comment|/* Don't clobber a slot for trash */
if|if
condition|(
name|hash_table
index|[
name|hashindex
index|]
operator|.
name|uid
operator|==
name|uid
condition|)
return|return
operator|(
name|hashindex
operator|)
return|;
comment|/* Fortuitous find */
block|}
comment|/* empty or wrong slot -- fill it with new value */
name|hash_table
index|[
name|hashindex
index|]
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|hash_table
index|[
name|hashindex
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|MAXLOGNAME
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|hashindex
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a userid->name mapping from the system.  * If the passwd database is hashed (#define RANDOM_PW), we  * just handle this uid.  Otherwise we scan the passwd file  * and cache any entries we pass over while looking.  */
end_comment

begin_function
name|int
name|get_user
parameter_list|(
name|uid
parameter_list|)
specifier|register
name|int
name|uid
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
ifdef|#
directive|ifdef
name|RANDOM_PW
comment|/* no performance penalty for using getpwuid makes it easy */
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|enter_user
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
else|#
directive|else
name|int
name|from_start
init|=
literal|0
decl_stmt|;
comment|/*      *  If we just called getpwuid each time, things would be very slow      *  since that just iterates through the passwd file each time.  So,      *  we walk through the file instead (using getpwent) and cache each      *  entry as we go.  Once the right record is found, we cache it and      *  return immediately.  The next time we come in, getpwent will get      *  the next record.  In theory, we never have to read the passwd file      *  a second time (because we cache everything we read).  But in      *  practice, the cache may not be large enough, so if we don't find      *  it the first time we have to scan the file a second time.  This      *  is not very efficient, but it will do for now.      */
while|while
condition|(
name|from_start
operator|++
operator|<
literal|2
condition|)
block|{
while|while
condition|(
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
name|uid
condition|)
block|{
return|return
operator|(
name|enter_user
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|enter_user
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* try again */
name|setpwent
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if we can't find the name at all, then use the uid as the name */
return|return
operator|(
name|enter_user
argument_list|(
name|uid
argument_list|,
name|itoa7
argument_list|(
name|uid
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

