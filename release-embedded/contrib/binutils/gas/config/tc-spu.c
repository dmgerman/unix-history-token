begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* spu.c -- Assembler for the IBM Synergistic Processing Unit (SPU)     Copyright 2006, 2007 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_decl_stmt
specifier|const
name|struct
name|spu_opcode
name|spu_opcodes
index|[]
init|=
block|{
define|#
directive|define
name|APUOP
parameter_list|(
name|TAG
parameter_list|,
name|MACFORMAT
parameter_list|,
name|OPCODE
parameter_list|,
name|MNEMONIC
parameter_list|,
name|ASMFORMAT
parameter_list|,
name|DEP
parameter_list|,
name|PIPE
parameter_list|)
define|\
value|{ MACFORMAT, (OPCODE)<< (32-11), MNEMONIC, ASMFORMAT },
define|#
directive|define
name|APUOPFB
parameter_list|(
name|TAG
parameter_list|,
name|MACFORMAT
parameter_list|,
name|OPCODE
parameter_list|,
name|FB
parameter_list|,
name|MNEMONIC
parameter_list|,
name|ASMFORMAT
parameter_list|,
name|DEP
parameter_list|,
name|PIPE
parameter_list|)
define|\
value|{ MACFORMAT, ((OPCODE)<< (32-11)) | ((FB)<< (32-18)), MNEMONIC, ASMFORMAT },
include|#
directive|include
file|"opcode/spu-insns.h"
undef|#
directive|undef
name|APUOP
undef|#
directive|undef
name|APUOPFB
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|spu_num_opcodes
init|=
sizeof|sizeof
argument_list|(
name|spu_opcodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|spu_opcodes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_RELOCS
value|2
end_define

begin_struct
struct|struct
name|spu_insn
block|{
name|unsigned
name|int
name|opcode
decl_stmt|;
name|expressionS
name|exp
index|[
name|MAX_RELOCS
index|]
decl_stmt|;
name|int
name|reloc_arg
index|[
name|MAX_RELOCS
index|]
decl_stmt|;
name|int
name|flag
index|[
name|MAX_RELOCS
index|]
decl_stmt|;
name|enum
name|spu_insns
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_imm
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
name|struct
name|spu_insn
modifier|*
name|insn
parameter_list|,
name|int
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_reg
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
name|struct
name|spu_insn
modifier|*
name|insn
parameter_list|,
name|int
name|arg
parameter_list|,
name|int
name|accept_expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calcop
parameter_list|(
name|struct
name|spu_opcode
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|param
parameter_list|,
name|struct
name|spu_insn
modifier|*
name|insn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spu_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These bits should be turned off in the first address of every segment */
end_comment

begin_decl_stmt
name|int
name|md_seg_align
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars start a comment anywhere in a source file (except inside    another comment */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars only start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gods own line continuation char */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* as in 0f123.456 */
end_comment

begin_comment
comment|/* or    0H1.234E-12 (see exp chars above) */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dDfF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|4
block|}
block|,
block|{
literal|"bss"
block|,
name|s_lcomm_bytes
block|,
literal|1
block|}
block|,
block|{
literal|"def"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"half"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"int"
block|,
name|spu_cons
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
name|spu_cons
block|,
literal|4
block|}
block|,
block|{
literal|"quad"
block|,
name|spu_cons
block|,
literal|8
block|}
block|,
block|{
literal|"string"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"word"
block|,
name|spu_cons
block|,
literal|4
block|}
block|,
comment|/* Force set to be treated as an instruction.  */
block|{
literal|"set"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|".set"
block|,
name|s_set
block|,
literal|0
block|}
block|,
comment|/* Likewise for eqv.  */
block|{
literal|"eqv"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|".eqv"
block|,
name|s_set
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"file"
block|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* initialize hash table */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* loop until you see the end of the list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spu_num_opcodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* hash each mnemonic and record its position */
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|spu_opcodes
index|[
name|i
index|]
operator|.
name|mnemonic
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|spu_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|retval
argument_list|,
literal|"exists"
argument_list|)
operator|!=
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't hash instruction '%s':%s"
argument_list|)
argument_list|,
name|spu_opcodes
index|[
name|i
index|]
operator|.
name|mnemonic
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_APUASM
value|(OPTION_MD_BASE)
block|{
literal|"apuasm"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_APUASM
block|}
block|,
define|#
directive|define
name|OPTION_DD2
value|(OPTION_MD_BASE+1)
block|{
literal|"mdd2.0"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DD2
block|}
block|,
define|#
directive|define
name|OPTION_DD1
value|(OPTION_MD_BASE+2)
block|{
literal|"mdd1.0"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DD1
block|}
block|,
define|#
directive|define
name|OPTION_DD3
value|(OPTION_MD_BASE+3)
block|{
literal|"mdd3.0"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DD3
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When set (by -apuasm) our assembler emulates the behaviour of apuasm.  * e.g. don't add bias to float conversion and don't right shift  * immediate values. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|emulate_apuasm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use the dd2.0 instructions set.  The only differences are some new  * register names and the orx insn */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_dd2
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_APUASM
case|:
name|emulate_apuasm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_DD3
case|:
name|use_dd2
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_DD2
case|:
name|use_dd2
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_DD1
case|:
name|use_dd2
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ SPU options:\n\   --apuasm		  emulate behaviour of apuasm\n"
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|arg_encode
block|{
name|int
name|size
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|rshift
decl_stmt|;
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|int
name|wlo
decl_stmt|,
name|whi
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|arg_encode
name|arg_encode
index|[
name|A_MAX
index|]
init|=
block|{
block|{
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_T */
block|{
literal|7
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_A */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_B */
block|{
literal|7
block|,
literal|21
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_C */
block|{
literal|7
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_S */
block|{
literal|7
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_H */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_P */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_S3 */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
operator|-
literal|32
block|,
literal|31
block|,
operator|-
literal|31
block|,
literal|0
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_S6 */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_S7N */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
operator|-
literal|64
block|,
literal|63
block|,
operator|-
literal|63
block|,
literal|0
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_S7 */
block|{
literal|8
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM8
block|}
block|,
comment|/* A_U7A */
block|{
literal|8
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM8
block|}
block|,
comment|/* A_U7B */
block|{
literal|10
block|,
literal|14
block|,
literal|0
block|,
operator|-
literal|512
block|,
literal|511
block|,
operator|-
literal|128
block|,
literal|255
block|,
name|BFD_RELOC_SPU_IMM10
block|}
block|,
comment|/* A_S10B */
block|{
literal|10
block|,
literal|14
block|,
literal|0
block|,
operator|-
literal|512
block|,
literal|511
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM10
block|}
block|,
comment|/* A_S10 */
block|{
literal|2
block|,
literal|23
block|,
literal|9
block|,
operator|-
literal|1024
block|,
literal|1023
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_PCREL9a
block|}
block|,
comment|/* A_S11 */
block|{
literal|2
block|,
literal|14
block|,
literal|9
block|,
operator|-
literal|1024
block|,
literal|1023
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_PCREL9b
block|}
block|,
comment|/* A_S11I */
block|{
literal|10
block|,
literal|14
block|,
literal|4
block|,
operator|-
literal|8192
block|,
literal|8191
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM10W
block|}
block|,
comment|/* A_S14 */
block|{
literal|16
block|,
literal|7
block|,
literal|0
block|,
operator|-
literal|32768
block|,
literal|32767
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM16
block|}
block|,
comment|/* A_S16 */
block|{
literal|16
block|,
literal|7
block|,
literal|2
block|,
operator|-
literal|131072
block|,
literal|262143
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM16W
block|}
block|,
comment|/* A_S18 */
block|{
literal|16
block|,
literal|7
block|,
literal|2
block|,
operator|-
literal|262144
block|,
literal|262143
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_PCREL16
block|}
block|,
comment|/* A_R18 */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_U3 */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
literal|31
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_U5 */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|127
block|,
literal|0
block|,
literal|63
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_U6 */
block|{
literal|7
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM7
block|}
block|,
comment|/* A_U7 */
block|{
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|16383
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* A_U14 */
block|{
literal|16
block|,
literal|7
block|,
literal|0
block|,
operator|-
literal|32768
block|,
literal|65535
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM16
block|}
block|,
comment|/* A_X16 */
block|{
literal|18
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|262143
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BFD_RELOC_SPU_IMM18
block|}
block|,
comment|/* A_U18 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some flags for handling errors.  This is very hackish and added after  * the fact. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|syntax_error_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|syntax_error_param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|syntax_reg
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|insn_fmt_string
parameter_list|(
name|struct
name|spu_opcode
modifier|*
name|format
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|+=
name|sprintf
argument_list|(
operator|&
name|buf
index|[
name|len
index|]
argument_list|,
literal|"%s\t"
argument_list|,
name|format
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|format
operator|->
name|arg
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|arg
init|=
name|format
operator|->
name|arg
index|[
name|i
index|]
decl_stmt|;
name|char
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|arg
operator|!=
name|A_P
operator|&&
name|format
operator|->
name|arg
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|A_P
condition|)
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|A_P
condition|)
name|exp
operator|=
literal|"("
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|<
name|A_P
condition|)
name|exp
operator|=
name|i
operator|==
name|syntax_error_arg
condition|?
literal|"REG"
else|:
literal|"reg"
expr_stmt|;
else|else
name|exp
operator|=
name|i
operator|==
name|syntax_error_arg
condition|?
literal|"IMM"
else|:
literal|"imm"
expr_stmt|;
name|len
operator|+=
name|sprintf
argument_list|(
operator|&
name|buf
index|[
name|len
index|]
argument_list|,
literal|"%s"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|format
operator|->
name|arg
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|A_P
condition|)
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
name|char
modifier|*
name|param
decl_stmt|,
modifier|*
name|thisfrag
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|spu_opcode
modifier|*
name|format
decl_stmt|;
name|struct
name|spu_insn
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* skip over instruction to find parameters */
for|for
control|(
name|param
operator|=
name|op
init|;
operator|*
name|param
operator|!=
literal|0
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|param
argument_list|)
condition|;
name|param
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|param
expr_stmt|;
operator|*
name|param
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|param
operator|++
expr_stmt|;
comment|/* try to find the instruction in the hash table */
if|if
condition|(
operator|(
name|format
operator|=
operator|(
expr|struct
name|spu_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|op
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid mnemonic '%s'"
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|use_dd2
operator|&&
name|strcmp
argument_list|(
name|format
operator|->
name|mnemonic
argument_list|,
literal|"orx"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'%s' is only available in DD2.0 or higher."
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* try parsing this instruction into insn */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RELOCS
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|.
name|exp
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|insn
operator|.
name|exp
index|[
name|i
index|]
operator|.
name|X_op_symbol
operator|=
literal|0
expr_stmt|;
name|insn
operator|.
name|exp
index|[
name|i
index|]
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|insn
operator|.
name|exp
index|[
name|i
index|]
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
name|insn
operator|.
name|reloc_arg
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|insn
operator|.
name|flag
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|insn
operator|.
name|opcode
operator|=
name|format
operator|->
name|opcode
expr_stmt|;
name|insn
operator|.
name|tag
operator|=
operator|(
expr|enum
name|spu_insns
operator|)
operator|(
name|format
operator|-
name|spu_opcodes
operator|)
expr_stmt|;
name|syntax_error_arg
operator|=
literal|0
expr_stmt|;
name|syntax_error_param
operator|=
literal|0
expr_stmt|;
name|syntax_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|calcop
argument_list|(
name|format
argument_list|,
name|param
argument_list|,
operator|&
name|insn
argument_list|)
condition|)
break|break;
comment|/* if it doesn't parse try the next instruction */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|format
index|[
literal|0
index|]
operator|.
name|mnemonic
argument_list|,
name|format
index|[
literal|1
index|]
operator|.
name|mnemonic
argument_list|)
condition|)
name|format
operator|++
expr_stmt|;
else|else
block|{
name|int
name|parg
init|=
name|format
index|[
literal|0
index|]
operator|.
name|arg
index|[
name|syntax_error_arg
operator|-
literal|1
index|]
decl_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Error in argument %d.  Expecting:  \"%s\""
argument_list|)
argument_list|,
name|syntax_error_arg
operator|-
operator|(
name|parg
operator|==
name|A_P
operator|)
argument_list|,
name|insn_fmt_string
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|syntax_reg
operator|&
literal|4
operator|)
operator|&&
operator|!
operator|(
name|insn
operator|.
name|tag
operator|==
name|M_RDCH
operator|||
name|insn
operator|.
name|tag
operator|==
name|M_RCHCNT
operator|||
name|insn
operator|.
name|tag
operator|==
name|M_WRCH
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Mixing register syntax, with and without '$'."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|syntax_error_param
condition|)
block|{
specifier|const
name|char
modifier|*
name|d
init|=
name|syntax_error_param
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|!=
literal|'$'
condition|)
name|d
operator|--
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Treating '%-*s' as a symbol."
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|syntax_error_param
operator|-
name|d
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* grow the current frag and plop in the opcode */
name|thisfrag
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|thisfrag
argument_list|,
name|insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* if this instruction requires labels mark it for later */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RELOCS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|.
name|reloc_arg
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
init|=
name|arg_encode
index|[
name|insn
operator|.
name|reloc_arg
index|[
name|i
index|]
index|]
operator|.
name|reloc
decl_stmt|;
name|int
name|pcrel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_SPU_PCREL9a
operator|||
name|reloc
operator|==
name|BFD_RELOC_SPU_PCREL9b
operator|||
name|reloc
operator|==
name|BFD_RELOC_SPU_PCREL16
condition|)
name|pcrel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|flag
index|[
name|i
index|]
operator|==
literal|1
condition|)
name|reloc
operator|=
name|BFD_RELOC_SPU_HI16
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|.
name|flag
index|[
name|i
index|]
operator|==
literal|2
condition|)
name|reloc
operator|=
name|BFD_RELOC_SPU_LO16
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|thisfrag
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|insn
operator|.
name|exp
index|[
name|i
index|]
argument_list|,
name|pcrel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|tc_fix_data
operator|.
name|arg_format
operator|=
name|insn
operator|.
name|reloc_arg
index|[
name|i
index|]
expr_stmt|;
name|fixP
operator|->
name|tc_fix_data
operator|.
name|insn_tag
operator|=
name|insn
operator|.
name|tag
expr_stmt|;
block|}
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|calcop
parameter_list|(
name|struct
name|spu_opcode
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|param
parameter_list|,
name|struct
name|spu_insn
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|int
name|arg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|format
operator|->
name|arg
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
name|format
operator|->
name|arg
index|[
name|i
index|]
expr_stmt|;
name|syntax_error_arg
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|param
argument_list|)
condition|)
name|param
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|param
operator|==
literal|0
operator|||
operator|*
name|param
operator|==
literal|','
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arg
operator|<
name|A_P
condition|)
name|param
operator|=
name|get_reg
argument_list|(
name|param
argument_list|,
name|insn
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|>
name|A_P
condition|)
name|param
operator|=
name|get_imm
argument_list|(
name|param
argument_list|,
name|insn
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
name|A_P
condition|)
block|{
name|paren
operator|++
expr_stmt|;
if|if
condition|(
literal|'('
operator|!=
operator|*
name|param
operator|++
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|param
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|param
argument_list|)
condition|)
name|param
operator|++
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|A_P
operator|&&
name|paren
condition|)
block|{
name|paren
operator|--
expr_stmt|;
if|if
condition|(
literal|')'
operator|!=
operator|*
name|param
operator|++
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|format
operator|->
name|arg
index|[
literal|0
index|]
operator|&&
name|format
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|A_P
operator|&&
name|format
operator|->
name|arg
index|[
name|i
operator|+
literal|1
index|]
operator|!=
name|A_P
condition|)
block|{
if|if
condition|(
literal|','
operator|!=
operator|*
name|param
operator|++
condition|)
block|{
name|syntax_error_arg
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|param
argument_list|)
condition|)
name|param
operator|++
expr_stmt|;
return|return
operator|!
name|paren
operator|&&
operator|(
operator|*
name|param
operator|==
literal|0
operator|||
operator|*
name|param
operator|==
literal|'\n'
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|reg_name
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|REG_NAME
parameter_list|(
name|NO
parameter_list|,
name|NM
parameter_list|)
value|{ NO, sizeof (NM) - 1, NM }
end_define

begin_decl_stmt
specifier|static
name|struct
name|reg_name
name|reg_name
index|[]
init|=
block|{
name|REG_NAME
argument_list|(
literal|0
argument_list|,
literal|"lr"
argument_list|)
block|,
comment|/* link register */
name|REG_NAME
argument_list|(
literal|1
argument_list|,
literal|"sp"
argument_list|)
block|,
comment|/* stack pointer */
name|REG_NAME
argument_list|(
literal|0
argument_list|,
literal|"rp"
argument_list|)
block|,
comment|/* link register */
name|REG_NAME
argument_list|(
literal|127
argument_list|,
literal|"fp"
argument_list|)
block|,
comment|/* frame pointer */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|reg_name
name|sp_reg_name
index|[]
init|=
block|{ }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|reg_name
name|ch_reg_name
index|[]
init|=
block|{
name|REG_NAME
argument_list|(
literal|0
argument_list|,
literal|"SPU_RdEventStat"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|1
argument_list|,
literal|"SPU_WrEventMask"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|2
argument_list|,
literal|"SPU_WrEventAck"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|3
argument_list|,
literal|"SPU_RdSigNotify1"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|4
argument_list|,
literal|"SPU_RdSigNotify2"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|7
argument_list|,
literal|"SPU_WrDec"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|8
argument_list|,
literal|"SPU_RdDec"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|11
argument_list|,
literal|"SPU_RdEventMask"
argument_list|)
block|,
comment|/* DD2.0 only */
name|REG_NAME
argument_list|(
literal|13
argument_list|,
literal|"SPU_RdMachStat"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|14
argument_list|,
literal|"SPU_WrSRR0"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|15
argument_list|,
literal|"SPU_RdSRR0"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|28
argument_list|,
literal|"SPU_WrOutMbox"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|29
argument_list|,
literal|"SPU_RdInMbox"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|30
argument_list|,
literal|"SPU_WrOutIntrMbox"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|9
argument_list|,
literal|"MFC_WrMSSyncReq"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|12
argument_list|,
literal|"MFC_RdTagMask"
argument_list|)
block|,
comment|/* DD2.0 only */
name|REG_NAME
argument_list|(
literal|16
argument_list|,
literal|"MFC_LSA"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|17
argument_list|,
literal|"MFC_EAH"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|18
argument_list|,
literal|"MFC_EAL"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|19
argument_list|,
literal|"MFC_Size"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|20
argument_list|,
literal|"MFC_TagID"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|21
argument_list|,
literal|"MFC_Cmd"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|22
argument_list|,
literal|"MFC_WrTagMask"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|23
argument_list|,
literal|"MFC_WrTagUpdate"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|24
argument_list|,
literal|"MFC_RdTagStat"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|25
argument_list|,
literal|"MFC_RdListStallStat"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|26
argument_list|,
literal|"MFC_WrListStallAck"
argument_list|)
block|,
name|REG_NAME
argument_list|(
literal|27
argument_list|,
literal|"MFC_RdAtomicStat"
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|REG_NAME
end_undef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_reg
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
name|struct
name|spu_insn
modifier|*
name|insn
parameter_list|,
name|int
name|arg
parameter_list|,
name|int
name|accept_expr
parameter_list|)
block|{
name|unsigned
name|regno
decl_stmt|;
name|int
name|saw_prefix
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|param
operator|==
literal|'$'
condition|)
block|{
name|saw_prefix
operator|=
literal|1
expr_stmt|;
name|param
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|A_H
condition|)
comment|/* Channel */
block|{
if|if
condition|(
operator|(
name|param
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|param
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|&&
operator|(
name|param
index|[
literal|1
index|]
operator|==
literal|'h'
operator|||
name|param
index|[
literal|1
index|]
operator|==
literal|'H'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
name|param
index|[
literal|2
index|]
argument_list|)
condition|)
name|param
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
name|A_S
condition|)
comment|/* Special purpose register */
block|{
if|if
condition|(
operator|(
name|param
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|param
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|param
index|[
literal|1
index|]
operator|==
literal|'p'
operator|||
name|param
index|[
literal|1
index|]
operator|==
literal|'P'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
name|param
index|[
literal|2
index|]
argument_list|)
condition|)
name|param
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|param
argument_list|)
condition|)
block|{
name|regno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|param
argument_list|)
condition|)
name|regno
operator|=
name|regno
operator|*
literal|10
operator|+
operator|*
name|param
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|struct
name|reg_name
modifier|*
name|rn
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|A_H
condition|)
comment|/* Channel */
block|{
name|rn
operator|=
name|ch_reg_name
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|ch_reg_name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ch_reg_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
name|A_S
condition|)
comment|/* Special purpose register */
block|{
name|rn
operator|=
name|sp_reg_name
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|sp_reg_name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sp_reg_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rn
operator|=
name|reg_name
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|reg_name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reg_name
argument_list|)
expr_stmt|;
block|}
name|regno
operator|=
literal|128
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rn
index|[
name|i
index|]
operator|.
name|length
operator|>
name|l
operator|&&
literal|0
operator|==
name|strncasecmp
argument_list|(
name|param
argument_list|,
name|rn
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|rn
index|[
name|i
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
name|l
operator|=
name|rn
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|regno
operator|=
name|rn
index|[
name|i
index|]
operator|.
name|regno
expr_stmt|;
block|}
name|param
operator|+=
name|l
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_dd2
operator|&&
name|arg
operator|==
name|A_H
condition|)
block|{
if|if
condition|(
name|regno
operator|==
literal|11
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'SPU_RdEventMask' (channel 11) is only available in DD2.0 or higher."
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
literal|12
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'MFC_RdTagMask' (channel 12) is only available in DD2.0 or higher."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|<
literal|128
condition|)
block|{
name|insn
operator|->
name|opcode
operator||=
name|regno
operator|<<
name|arg_encode
index|[
name|arg
index|]
operator|.
name|pos
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|saw_prefix
operator|&&
name|syntax_reg
operator|==
literal|1
operator|)
operator|||
operator|(
name|saw_prefix
operator|&&
name|syntax_reg
operator|==
literal|2
operator|)
condition|)
name|syntax_reg
operator||=
literal|4
expr_stmt|;
name|syntax_reg
operator||=
name|saw_prefix
condition|?
literal|1
else|:
literal|2
expr_stmt|;
return|return
name|param
return|;
block|}
if|if
condition|(
name|accept_expr
condition|)
block|{
name|char
modifier|*
name|save_ptr
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|save_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|param
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|param
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_register
operator|||
name|ex
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|insn
operator|->
name|opcode
operator||=
name|ex
operator|.
name|X_add_number
operator|<<
name|arg_encode
index|[
name|arg
index|]
operator|.
name|pos
expr_stmt|;
return|return
name|param
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_imm
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
name|struct
name|spu_insn
modifier|*
name|insn
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|save_ptr
decl_stmt|;
name|int
name|low
init|=
literal|0
decl_stmt|,
name|high
init|=
literal|0
decl_stmt|;
name|int
name|reloc_i
init|=
name|insn
operator|->
name|reloc_arg
index|[
literal|0
index|]
operator|>=
literal|0
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|param
argument_list|,
literal|"%lo("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|param
operator|+=
literal|3
expr_stmt|;
name|low
operator|=
literal|1
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Using old style, %%lo(expr), please change to PPC style, expr@l."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|param
argument_list|,
literal|"%hi("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|param
operator|+=
literal|3
expr_stmt|;
name|high
operator|=
literal|1
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Using old style, %%hi(expr), please change to PPC style, expr@h."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|param
argument_list|,
literal|"%pic("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Currently we expect %pic(expr) == expr, so do nothing here. 	 i.e. for code loaded at address 0 $toc will be 0.  */
name|param
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|param
operator|==
literal|'$'
condition|)
block|{
comment|/* Symbols can start with $, but if this symbol matches a register 	 name, it's probably a mistake.  The only way to avoid this 	 warning is to rename the symbol.  */
name|struct
name|spu_insn
name|tmp_insn
decl_stmt|;
specifier|const
name|char
modifier|*
name|np
init|=
name|get_reg
argument_list|(
name|param
argument_list|,
operator|&
name|tmp_insn
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
condition|)
name|syntax_error_param
operator|=
name|np
expr_stmt|;
block|}
name|save_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|param
expr_stmt|;
name|expression
argument_list|(
operator|&
name|insn
operator|->
name|exp
index|[
name|reloc_i
index|]
argument_list|)
expr_stmt|;
name|param
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
comment|/* Similar to ppc_elf_suffix in tc-ppc.c.  We have so few cases to      handle we do it inlined here. */
if|if
condition|(
name|param
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
operator|!
name|ISALNUM
argument_list|(
name|param
index|[
literal|2
index|]
argument_list|)
operator|&&
name|param
index|[
literal|2
index|]
operator|!=
literal|'@'
condition|)
block|{
if|if
condition|(
name|param
index|[
literal|1
index|]
operator|==
literal|'h'
operator|||
name|param
index|[
literal|1
index|]
operator|==
literal|'H'
condition|)
block|{
name|high
operator|=
literal|1
expr_stmt|;
name|param
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|param
index|[
literal|1
index|]
operator|==
literal|'l'
operator|||
name|param
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
name|low
operator|=
literal|1
expr_stmt|;
name|param
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|->
name|exp
index|[
name|reloc_i
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|val
operator|=
name|insn
operator|->
name|exp
index|[
name|reloc_i
index|]
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|emulate_apuasm
condition|)
block|{
comment|/* Convert the value to a format we expect. */
name|val
operator|<<=
name|arg_encode
index|[
name|arg
index|]
operator|.
name|rshift
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|A_U7A
condition|)
name|val
operator|=
literal|173
operator|-
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
name|A_U7B
condition|)
name|val
operator|=
literal|155
operator|-
name|val
expr_stmt|;
block|}
if|if
condition|(
name|high
condition|)
name|val
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|low
condition|)
name|val
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
comment|/* Warn about out of range expressions. */
block|{
name|int
name|hi
init|=
name|arg_encode
index|[
name|arg
index|]
operator|.
name|hi
decl_stmt|;
name|int
name|lo
init|=
name|arg_encode
index|[
name|arg
index|]
operator|.
name|lo
decl_stmt|;
name|int
name|whi
init|=
name|arg_encode
index|[
name|arg
index|]
operator|.
name|whi
decl_stmt|;
name|int
name|wlo
init|=
name|arg_encode
index|[
name|arg
index|]
operator|.
name|wlo
decl_stmt|;
if|if
condition|(
name|hi
operator|>
name|lo
operator|&&
operator|(
name|val
operator|<
name|lo
operator|||
name|val
operator|>
name|hi
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Constant expression %d out of range, [%d, %d]."
argument_list|)
argument_list|,
name|val
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|whi
operator|>
name|wlo
operator|&&
operator|(
name|val
operator|<
name|wlo
operator|||
name|val
operator|>
name|whi
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Constant expression %d out of range, [%d, %d]."
argument_list|)
argument_list|,
name|val
argument_list|,
name|wlo
argument_list|,
name|whi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|A_U7A
condition|)
name|val
operator|=
literal|173
operator|-
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
name|A_U7B
condition|)
name|val
operator|=
literal|155
operator|-
name|val
expr_stmt|;
comment|/* Branch hints have a split encoding.  Do the bottom part. */
if|if
condition|(
name|arg
operator|==
name|A_S11
operator|||
name|arg
operator|==
name|A_S11I
condition|)
name|insn
operator|->
name|opcode
operator||=
operator|(
operator|(
name|val
operator|>>
literal|2
operator|)
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|insn
operator|->
name|opcode
operator||=
operator|(
operator|(
operator|(
name|val
operator|>>
name|arg_encode
index|[
name|arg
index|]
operator|.
name|rshift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|arg_encode
index|[
name|arg
index|]
operator|.
name|size
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|arg_encode
index|[
name|arg
index|]
operator|.
name|pos
operator|)
expr_stmt|;
name|insn
operator|->
name|reloc_arg
index|[
name|reloc_i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|insn
operator|->
name|flag
index|[
name|reloc_i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|->
name|reloc_arg
index|[
name|reloc_i
index|]
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|high
condition|)
name|insn
operator|->
name|flag
index|[
name|reloc_i
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|low
condition|)
name|insn
operator|->
name|flag
index|[
name|reloc_i
index|]
operator|=
literal|2
expr_stmt|;
block|}
return|return
name|param
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|frag
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
parameter_list|)
block|{
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0xc0
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
name|ptr
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SPU_PCREL16
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|frag
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
parameter_list|)
block|{
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0xc0
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
name|ptr
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SPU_PCREL16
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Support @ppu on symbols referenced in .int/.long/.word/.quad.  */
end_comment

begin_function
specifier|static
name|void
name|spu_cons
parameter_list|(
name|int
name|nbytes
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|deferred_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|||
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"@ppu"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
name|enum
name|bfd_reloc_code_real
name|reloc
decl_stmt|;
comment|/* Check for identifier@suffix+constant.  */
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'+'
condition|)
block|{
name|expressionS
name|new_exp
decl_stmt|;
name|expression
argument_list|(
operator|&
name|new_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|exp
operator|.
name|X_add_number
operator|+=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
block|}
name|reloc
operator|=
name|nbytes
operator|==
literal|4
condition|?
name|BFD_RELOC_SPU_PPU32
else|:
name|BFD_RELOC_SPU_PPU64
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* Put terminator back into stream.  */
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|segment_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Relaxation should never occur"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created,    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
condition|)
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
condition|)
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Round up a section's size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|seg
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
name|valueT
name|mask
init|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|size
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Where a PC relative offset is calculated from.  On the spu they    are calculated from the beginning of the branch instruction.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* Fill in rs_align_code fragments.  */
end_comment

begin_function
name|void
name|spu_handle_align
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|nop_pattern
index|[
literal|8
index|]
init|=
block|{
literal|0x40
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* even nop */
literal|0x00
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* odd  nop */
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|bytes
operator|&
literal|3
condition|)
block|{
name|int
name|fix
init|=
name|bytes
operator|&
literal|3
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|bytes
operator|-=
name|fix
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|&
literal|4
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|nop_pattern
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|nop_pattern
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|8
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|res
decl_stmt|;
name|valueT
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|place
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* We can't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
comment|/* Hack around bfd_install_relocation brain damage.  */
name|val
operator|+=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_PCREL16
case|:
case|case
name|BFD_RELOC_SPU_PCREL9a
case|:
case|case
name|BFD_RELOC_SPU_PCREL9b
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SPU_PPU32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SPU_PPU64
condition|)
return|return;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
block|{
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|tc_fix_data
operator|.
name|arg_format
operator|>
name|A_P
condition|)
block|{
name|int
name|hi
init|=
name|arg_encode
index|[
name|fixP
operator|->
name|tc_fix_data
operator|.
name|arg_format
index|]
operator|.
name|hi
decl_stmt|;
name|int
name|lo
init|=
name|arg_encode
index|[
name|fixP
operator|->
name|tc_fix_data
operator|.
name|arg_format
index|]
operator|.
name|lo
decl_stmt|;
if|if
condition|(
name|hi
operator|>
name|lo
operator|&&
operator|(
operator|(
name|offsetT
operator|)
name|val
operator|<
name|lo
operator|||
operator|(
name|offsetT
operator|)
name|val
operator|>
name|hi
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Relocation doesn't fit. (relocation value = 0x%lx)"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|md_number_to_chars
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_64
case|:
name|md_number_to_chars
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_SPU_IMM7
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0x7f
operator|)
operator|<<
literal|14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_IMM8
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0xff
operator|)
operator|<<
literal|14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_IMM10
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0x3ff
operator|)
operator|<<
literal|14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_IMM10W
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0x3ff0
operator|)
operator|<<
literal|10
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_IMM16
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_IMM16W
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0x3fffc
operator|)
operator|<<
literal|5
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_IMM18
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0x3ffff
operator|)
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_PCREL9a
case|:
name|res
operator|=
operator|(
operator|(
name|val
operator|&
literal|0x1fc
operator|)
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x600
operator|)
operator|<<
literal|14
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_PCREL9b
case|:
name|res
operator|=
operator|(
operator|(
name|val
operator|&
literal|0x1fc
operator|)
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x600
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPU_PCREL16
case|:
name|res
operator|=
operator|(
name|val
operator|&
literal|0x3fffc
operator|)
operator|<<
literal|5
expr_stmt|;
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|place
index|[
literal|0
index|]
operator||=
operator|(
name|res
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|place
index|[
literal|1
index|]
operator||=
operator|(
name|res
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|place
index|[
literal|2
index|]
operator||=
operator|(
name|res
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|place
index|[
literal|3
index|]
operator||=
operator|(
name|res
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

