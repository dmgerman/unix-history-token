begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-ia64.c -- Assembler for the HP/Intel IA-64 architecture.    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Contributed by David Mosberger-Tang<davidm@hpl.hp.com>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*   TODO:    - optional operands   - directives: 	.eb 	.estate 	.lb 	.popsection 	.previous 	.psr 	.pushsection   - labels are wrong if automatic alignment is introduced     (e.g., checkout the second real10 definition in test-data.s)   - DV-related stuff:<reg>.safe_across_calls and any other DV-related directives I don't 	  have documentation for. 	verify mod-sched-brs reads/writes are checked/marked (and other 	notes)   */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/ia64.h"
end_include

begin_include
include|#
directive|include
file|"elf/ia64.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NELEMS
parameter_list|(
name|a
parameter_list|)
value|((int) (sizeof (a)/sizeof ((a)[0])))
end_define

begin_comment
comment|/* Some systems define MIN in, e.g., param.h.  */
end_comment

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|NUM_SLOTS
value|4
end_define

begin_define
define|#
directive|define
name|PREV_SLOT
value|md.slot[(md.curr_slot + NUM_SLOTS - 1) % NUM_SLOTS]
end_define

begin_define
define|#
directive|define
name|CURR_SLOT
value|md.slot[md.curr_slot]
end_define

begin_define
define|#
directive|define
name|O_pseudo_fixup
value|(O_max + 1)
end_define

begin_enum
enum|enum
name|special_section
block|{
comment|/* IA-64 ABI section pseudo-ops.  */
name|SPECIAL_SECTION_BSS
init|=
literal|0
block|,
name|SPECIAL_SECTION_SBSS
block|,
name|SPECIAL_SECTION_SDATA
block|,
name|SPECIAL_SECTION_RODATA
block|,
name|SPECIAL_SECTION_COMMENT
block|,
name|SPECIAL_SECTION_UNWIND
block|,
name|SPECIAL_SECTION_UNWIND_INFO
block|,
comment|/* HPUX specific section pseudo-ops.  */
name|SPECIAL_SECTION_INIT_ARRAY
block|,
name|SPECIAL_SECTION_FINI_ARRAY
block|,   }
enum|;
end_enum

begin_enum
enum|enum
name|reloc_func
block|{
name|FUNC_DTP_MODULE
block|,
name|FUNC_DTP_RELATIVE
block|,
name|FUNC_FPTR_RELATIVE
block|,
name|FUNC_GP_RELATIVE
block|,
name|FUNC_LT_RELATIVE
block|,
name|FUNC_LT_RELATIVE_X
block|,
name|FUNC_PC_RELATIVE
block|,
name|FUNC_PLT_RELATIVE
block|,
name|FUNC_SEC_RELATIVE
block|,
name|FUNC_SEG_RELATIVE
block|,
name|FUNC_TP_RELATIVE
block|,
name|FUNC_LTV_RELATIVE
block|,
name|FUNC_LT_FPTR_RELATIVE
block|,
name|FUNC_LT_DTP_MODULE
block|,
name|FUNC_LT_DTP_RELATIVE
block|,
name|FUNC_LT_TP_RELATIVE
block|,
name|FUNC_IPLT_RELOC
block|,   }
enum|;
end_enum

begin_enum
enum|enum
name|reg_symbol
block|{
name|REG_GR
init|=
literal|0
block|,
name|REG_FR
init|=
operator|(
name|REG_GR
operator|+
literal|128
operator|)
block|,
name|REG_AR
init|=
operator|(
name|REG_FR
operator|+
literal|128
operator|)
block|,
name|REG_CR
init|=
operator|(
name|REG_AR
operator|+
literal|128
operator|)
block|,
name|REG_P
init|=
operator|(
name|REG_CR
operator|+
literal|128
operator|)
block|,
name|REG_BR
init|=
operator|(
name|REG_P
operator|+
literal|64
operator|)
block|,
name|REG_IP
init|=
operator|(
name|REG_BR
operator|+
literal|8
operator|)
block|,
name|REG_CFM
block|,
name|REG_PR
block|,
name|REG_PR_ROT
block|,
name|REG_PSR
block|,
name|REG_PSR_L
block|,
name|REG_PSR_UM
block|,
comment|/* The following are pseudo-registers for use by gas only.  */
name|IND_CPUID
block|,
name|IND_DBR
block|,
name|IND_DTR
block|,
name|IND_ITR
block|,
name|IND_IBR
block|,
name|IND_MSR
block|,
name|IND_PKR
block|,
name|IND_PMC
block|,
name|IND_PMD
block|,
name|IND_RR
block|,
comment|/* The following pseudo-registers are used for unwind directives only:  */
name|REG_PSP
block|,
name|REG_PRIUNAT
block|,
name|REG_NUM
block|}
enum|;
end_enum

begin_enum
enum|enum
name|dynreg_type
block|{
name|DYNREG_GR
init|=
literal|0
block|,
comment|/* dynamic general purpose register */
name|DYNREG_FR
block|,
comment|/* dynamic floating point register */
name|DYNREG_PR
block|,
comment|/* dynamic predicate register */
name|DYNREG_NUM_TYPES
block|}
enum|;
end_enum

begin_enum
enum|enum
name|operand_match_result
block|{
name|OPERAND_MATCH
block|,
name|OPERAND_OUT_OF_RANGE
block|,
name|OPERAND_MISMATCH
block|}
enum|;
end_enum

begin_comment
comment|/* On the ia64, we can't know the address of a text label until the    instructions are packed into a bundle.  To handle this, we keep    track of the list of labels that appear in front of each    instruction.  */
end_comment

begin_struct
struct|struct
name|label_fix
block|{
name|struct
name|label_fix
modifier|*
name|next
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|bfd_boolean
name|dw2_mark_labels
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the endianness of the current section.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the default endianness.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_big_endian
init|=
name|TARGET_BYTES_BIG_ENDIAN
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*ia64_number_to_chars
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|valueT
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_float_to_chars_bigendian
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|LITTLENUM_TYPE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_float_to_chars_littleendian
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|LITTLENUM_TYPE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*ia64_float_to_chars
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|LITTLENUM_TYPE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|alias_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|alias_name_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|secalias_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|secalias_name_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of chars besides those in app.c:symbol_chars that can start an    operand.  Used to prevent the scrubber eating vital white-space.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|ia64_symbol_chars
index|[]
init|=
literal|"@?"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";{}"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ia64-specific option processing:  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:N:x::"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_MCONSTANT_GP
value|(OPTION_MD_BASE + 1)
block|{
literal|"mconstant-gp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MCONSTANT_GP
block|}
block|,
define|#
directive|define
name|OPTION_MAUTO_PIC
value|(OPTION_MD_BASE + 2)
block|{
literal|"mauto-pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MAUTO_PIC
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|hash_control
modifier|*
name|pseudo_hash
decl_stmt|;
comment|/* pseudo opcode hash table */
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
comment|/* register name hash table */
name|struct
name|hash_control
modifier|*
name|dynreg_hash
decl_stmt|;
comment|/* dynamic register hash table */
name|struct
name|hash_control
modifier|*
name|const_hash
decl_stmt|;
comment|/* constant hash table */
name|struct
name|hash_control
modifier|*
name|entry_hash
decl_stmt|;
comment|/* code entry hint hash table */
comment|/* If X_op is != O_absent, the registername for the instruction's        qualifying predicate.  If NULL, p0 is assumed for instructions        that are predicatable.  */
name|expressionS
name|qp
decl_stmt|;
comment|/* Optimize for which CPU.  */
enum|enum
block|{
name|itanium1
block|,
name|itanium2
block|}
name|tune
enum|;
comment|/* What to do when hint.b is used.  */
enum|enum
block|{
name|hint_b_error
block|,
name|hint_b_warning
block|,
name|hint_b_ok
block|}
name|hint_b
enum|;
name|unsigned
name|int
name|manual_bundling
range|:
literal|1
decl_stmt|,
name|debug_dv
range|:
literal|1
decl_stmt|,
name|detect_dv
range|:
literal|1
decl_stmt|,
name|explicit_mode
range|:
literal|1
decl_stmt|,
comment|/* which mode we're in */
name|default_explicit_mode
range|:
literal|1
decl_stmt|,
comment|/* which mode is the default */
name|mode_explicitly_set
range|:
literal|1
decl_stmt|,
comment|/* was the current mode explicitly set? */
name|auto_align
range|:
literal|1
decl_stmt|,
name|keep_pending_output
range|:
literal|1
decl_stmt|;
comment|/* What to do when something is wrong with unwind directives.  */
enum|enum
block|{
name|unwind_check_warning
block|,
name|unwind_check_error
block|}
name|unwind_check
enum|;
comment|/* Each bundle consists of up to three instructions.  We keep        track of four most recent instructions so we can correctly set        the end_of_insn_group for the last instruction in a bundle.  */
name|int
name|curr_slot
decl_stmt|;
name|int
name|num_slots_in_use
decl_stmt|;
struct|struct
name|slot
block|{
name|unsigned
name|int
name|end_of_insn_group
range|:
literal|1
decl_stmt|,
name|manual_bundling_on
range|:
literal|1
decl_stmt|,
name|manual_bundling_off
range|:
literal|1
decl_stmt|,
name|loc_directive_seen
range|:
literal|1
decl_stmt|;
name|signed
name|char
name|user_template
decl_stmt|;
comment|/* user-selected template, if any */
name|unsigned
name|char
name|qp_regno
decl_stmt|;
comment|/* qualifying predicate */
comment|/* This duplicates a good fraction of "struct fix" but we 	   can't use a "struct fix" instead since we can't call 	   fix_new_exp() until we know the address of the instruction.  */
name|int
name|num_fixups
decl_stmt|;
struct|struct
name|insn_fix
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|enum
name|ia64_opnd
name|opnd
decl_stmt|;
comment|/* type of operand in need of fix */
name|unsigned
name|int
name|is_pcrel
range|:
literal|1
decl_stmt|;
comment|/* is operand pc-relative? */
name|expressionS
name|expr
decl_stmt|;
comment|/* the value to be inserted */
block|}
name|fixup
index|[
literal|2
index|]
struct|;
comment|/* at most two fixups per insn */
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|struct
name|label_fix
modifier|*
name|label_fixups
decl_stmt|;
name|struct
name|label_fix
modifier|*
name|tag_fixups
decl_stmt|;
name|struct
name|unw_rec_list
modifier|*
name|unwind_record
decl_stmt|;
comment|/* Unwind directive.  */
name|expressionS
name|opnd
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|src_file
decl_stmt|;
name|unsigned
name|int
name|src_line
decl_stmt|;
name|struct
name|dwarf2_line_info
name|debug_line
decl_stmt|;
block|}
name|slot
index|[
name|NUM_SLOTS
index|]
struct|;
name|segT
name|last_text_seg
decl_stmt|;
struct|struct
name|dynreg
block|{
name|struct
name|dynreg
modifier|*
name|next
decl_stmt|;
comment|/* next dynamic register */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|short
name|base
decl_stmt|;
comment|/* the base register number */
name|unsigned
name|short
name|num_regs
decl_stmt|;
comment|/* # of registers in this set */
block|}
modifier|*
name|dynreg
index|[
name|DYNREG_NUM_TYPES
index|]
struct|,
name|in
struct|,
name|loc
struct|,
name|out
struct|,
name|rot
struct|;
name|flagword
name|flags
decl_stmt|;
comment|/* ELF-header flags */
struct|struct
name|mem_offset
block|{
name|unsigned
name|hint
range|:
literal|1
decl_stmt|;
comment|/* is this hint currently valid? */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* mem.offset offset */
name|bfd_vma
name|base
decl_stmt|;
comment|/* mem.offset base */
block|}
name|mem_offset
struct|;
name|int
name|path
decl_stmt|;
comment|/* number of alt. entry points seen */
specifier|const
name|char
modifier|*
modifier|*
name|entry_labels
decl_stmt|;
comment|/* labels of all alternate paths in 				       the current DV-checking block.  */
name|int
name|maxpaths
decl_stmt|;
comment|/* size currently allocated for 				       entry_labels */
name|int
name|pointer_size
decl_stmt|;
comment|/* size in bytes of a pointer */
name|int
name|pointer_size_shift
decl_stmt|;
comment|/* shift size of a pointer for alignment */
name|symbolS
modifier|*
name|indregsym
index|[
name|IND_RR
operator|-
name|IND_CPUID
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|md
struct|;
end_struct

begin_comment
comment|/* These are not const, because they are modified to MMI for non-itanium1    targets below.  */
end_comment

begin_comment
comment|/* MFI bundle of nops.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|le_nop
index|[
literal|16
index|]
init|=
block|{
literal|0x0c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MFI bundle of nops with stop-bit.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|le_nop_stop
index|[
literal|16
index|]
init|=
block|{
literal|0x0d
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* application registers:  */
end_comment

begin_define
define|#
directive|define
name|AR_K0
value|0
end_define

begin_define
define|#
directive|define
name|AR_K7
value|7
end_define

begin_define
define|#
directive|define
name|AR_RSC
value|16
end_define

begin_define
define|#
directive|define
name|AR_BSP
value|17
end_define

begin_define
define|#
directive|define
name|AR_BSPSTORE
value|18
end_define

begin_define
define|#
directive|define
name|AR_RNAT
value|19
end_define

begin_define
define|#
directive|define
name|AR_FCR
value|21
end_define

begin_define
define|#
directive|define
name|AR_EFLAG
value|24
end_define

begin_define
define|#
directive|define
name|AR_CSD
value|25
end_define

begin_define
define|#
directive|define
name|AR_SSD
value|26
end_define

begin_define
define|#
directive|define
name|AR_CFLG
value|27
end_define

begin_define
define|#
directive|define
name|AR_FSR
value|28
end_define

begin_define
define|#
directive|define
name|AR_FIR
value|29
end_define

begin_define
define|#
directive|define
name|AR_FDR
value|30
end_define

begin_define
define|#
directive|define
name|AR_CCV
value|32
end_define

begin_define
define|#
directive|define
name|AR_UNAT
value|36
end_define

begin_define
define|#
directive|define
name|AR_FPSR
value|40
end_define

begin_define
define|#
directive|define
name|AR_ITC
value|44
end_define

begin_define
define|#
directive|define
name|AR_PFS
value|64
end_define

begin_define
define|#
directive|define
name|AR_LC
value|65
end_define

begin_define
define|#
directive|define
name|AR_EC
value|66
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|regnum
decl_stmt|;
block|}
name|ar
index|[]
init|=
block|{
block|{
literal|"ar.k0"
block|,
name|AR_K0
block|}
block|,
block|{
literal|"ar.k1"
block|,
name|AR_K0
operator|+
literal|1
block|}
block|,
block|{
literal|"ar.k2"
block|,
name|AR_K0
operator|+
literal|2
block|}
block|,
block|{
literal|"ar.k3"
block|,
name|AR_K0
operator|+
literal|3
block|}
block|,
block|{
literal|"ar.k4"
block|,
name|AR_K0
operator|+
literal|4
block|}
block|,
block|{
literal|"ar.k5"
block|,
name|AR_K0
operator|+
literal|5
block|}
block|,
block|{
literal|"ar.k6"
block|,
name|AR_K0
operator|+
literal|6
block|}
block|,
block|{
literal|"ar.k7"
block|,
name|AR_K7
block|}
block|,
block|{
literal|"ar.rsc"
block|,
name|AR_RSC
block|}
block|,
block|{
literal|"ar.bsp"
block|,
name|AR_BSP
block|}
block|,
block|{
literal|"ar.bspstore"
block|,
name|AR_BSPSTORE
block|}
block|,
block|{
literal|"ar.rnat"
block|,
name|AR_RNAT
block|}
block|,
block|{
literal|"ar.fcr"
block|,
name|AR_FCR
block|}
block|,
block|{
literal|"ar.eflag"
block|,
name|AR_EFLAG
block|}
block|,
block|{
literal|"ar.csd"
block|,
name|AR_CSD
block|}
block|,
block|{
literal|"ar.ssd"
block|,
name|AR_SSD
block|}
block|,
block|{
literal|"ar.cflg"
block|,
name|AR_CFLG
block|}
block|,
block|{
literal|"ar.fsr"
block|,
name|AR_FSR
block|}
block|,
block|{
literal|"ar.fir"
block|,
name|AR_FIR
block|}
block|,
block|{
literal|"ar.fdr"
block|,
name|AR_FDR
block|}
block|,
block|{
literal|"ar.ccv"
block|,
name|AR_CCV
block|}
block|,
block|{
literal|"ar.unat"
block|,
name|AR_UNAT
block|}
block|,
block|{
literal|"ar.fpsr"
block|,
name|AR_FPSR
block|}
block|,
block|{
literal|"ar.itc"
block|,
name|AR_ITC
block|}
block|,
block|{
literal|"ar.pfs"
block|,
name|AR_PFS
block|}
block|,
block|{
literal|"ar.lc"
block|,
name|AR_LC
block|}
block|,
block|{
literal|"ar.ec"
block|,
name|AR_EC
block|}
block|,   }
struct|;
end_struct

begin_comment
comment|/* control registers:  */
end_comment

begin_define
define|#
directive|define
name|CR_DCR
value|0
end_define

begin_define
define|#
directive|define
name|CR_ITM
value|1
end_define

begin_define
define|#
directive|define
name|CR_IVA
value|2
end_define

begin_define
define|#
directive|define
name|CR_PTA
value|8
end_define

begin_define
define|#
directive|define
name|CR_GPTA
value|9
end_define

begin_define
define|#
directive|define
name|CR_IPSR
value|16
end_define

begin_define
define|#
directive|define
name|CR_ISR
value|17
end_define

begin_define
define|#
directive|define
name|CR_IIP
value|19
end_define

begin_define
define|#
directive|define
name|CR_IFA
value|20
end_define

begin_define
define|#
directive|define
name|CR_ITIR
value|21
end_define

begin_define
define|#
directive|define
name|CR_IIPA
value|22
end_define

begin_define
define|#
directive|define
name|CR_IFS
value|23
end_define

begin_define
define|#
directive|define
name|CR_IIM
value|24
end_define

begin_define
define|#
directive|define
name|CR_IHA
value|25
end_define

begin_define
define|#
directive|define
name|CR_LID
value|64
end_define

begin_define
define|#
directive|define
name|CR_IVR
value|65
end_define

begin_define
define|#
directive|define
name|CR_TPR
value|66
end_define

begin_define
define|#
directive|define
name|CR_EOI
value|67
end_define

begin_define
define|#
directive|define
name|CR_IRR0
value|68
end_define

begin_define
define|#
directive|define
name|CR_IRR3
value|71
end_define

begin_define
define|#
directive|define
name|CR_ITV
value|72
end_define

begin_define
define|#
directive|define
name|CR_PMV
value|73
end_define

begin_define
define|#
directive|define
name|CR_CMCV
value|74
end_define

begin_define
define|#
directive|define
name|CR_LRR0
value|80
end_define

begin_define
define|#
directive|define
name|CR_LRR1
value|81
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|regnum
decl_stmt|;
block|}
name|cr
index|[]
init|=
block|{
block|{
literal|"cr.dcr"
block|,
name|CR_DCR
block|}
block|,
block|{
literal|"cr.itm"
block|,
name|CR_ITM
block|}
block|,
block|{
literal|"cr.iva"
block|,
name|CR_IVA
block|}
block|,
block|{
literal|"cr.pta"
block|,
name|CR_PTA
block|}
block|,
block|{
literal|"cr.gpta"
block|,
name|CR_GPTA
block|}
block|,
block|{
literal|"cr.ipsr"
block|,
name|CR_IPSR
block|}
block|,
block|{
literal|"cr.isr"
block|,
name|CR_ISR
block|}
block|,
block|{
literal|"cr.iip"
block|,
name|CR_IIP
block|}
block|,
block|{
literal|"cr.ifa"
block|,
name|CR_IFA
block|}
block|,
block|{
literal|"cr.itir"
block|,
name|CR_ITIR
block|}
block|,
block|{
literal|"cr.iipa"
block|,
name|CR_IIPA
block|}
block|,
block|{
literal|"cr.ifs"
block|,
name|CR_IFS
block|}
block|,
block|{
literal|"cr.iim"
block|,
name|CR_IIM
block|}
block|,
block|{
literal|"cr.iha"
block|,
name|CR_IHA
block|}
block|,
block|{
literal|"cr.lid"
block|,
name|CR_LID
block|}
block|,
block|{
literal|"cr.ivr"
block|,
name|CR_IVR
block|}
block|,
block|{
literal|"cr.tpr"
block|,
name|CR_TPR
block|}
block|,
block|{
literal|"cr.eoi"
block|,
name|CR_EOI
block|}
block|,
block|{
literal|"cr.irr0"
block|,
name|CR_IRR0
block|}
block|,
block|{
literal|"cr.irr1"
block|,
name|CR_IRR0
operator|+
literal|1
block|}
block|,
block|{
literal|"cr.irr2"
block|,
name|CR_IRR0
operator|+
literal|2
block|}
block|,
block|{
literal|"cr.irr3"
block|,
name|CR_IRR3
block|}
block|,
block|{
literal|"cr.itv"
block|,
name|CR_ITV
block|}
block|,
block|{
literal|"cr.pmv"
block|,
name|CR_PMV
block|}
block|,
block|{
literal|"cr.cmcv"
block|,
name|CR_CMCV
block|}
block|,
block|{
literal|"cr.lrr0"
block|,
name|CR_LRR0
block|}
block|,
block|{
literal|"cr.lrr1"
block|,
name|CR_LRR1
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PSR_MFL
value|4
end_define

begin_define
define|#
directive|define
name|PSR_IC
value|13
end_define

begin_define
define|#
directive|define
name|PSR_DFL
value|18
end_define

begin_define
define|#
directive|define
name|PSR_CPL
value|32
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|const_desc
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|}
name|const_bits
index|[]
init|=
block|{
comment|/* PSR constant masks:  */
comment|/* 0: reserved */
block|{
literal|"psr.be"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|1
block|}
block|,
block|{
literal|"psr.up"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|2
block|}
block|,
block|{
literal|"psr.ac"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|3
block|}
block|,
block|{
literal|"psr.mfl"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|4
block|}
block|,
block|{
literal|"psr.mfh"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|5
block|}
block|,
comment|/* 6-12: reserved */
block|{
literal|"psr.ic"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|13
block|}
block|,
block|{
literal|"psr.i"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|14
block|}
block|,
block|{
literal|"psr.pk"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|15
block|}
block|,
comment|/* 16: reserved */
block|{
literal|"psr.dt"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|17
block|}
block|,
block|{
literal|"psr.dfl"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|18
block|}
block|,
block|{
literal|"psr.dfh"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|19
block|}
block|,
block|{
literal|"psr.sp"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|20
block|}
block|,
block|{
literal|"psr.pp"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|21
block|}
block|,
block|{
literal|"psr.di"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|22
block|}
block|,
block|{
literal|"psr.si"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|23
block|}
block|,
block|{
literal|"psr.db"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|24
block|}
block|,
block|{
literal|"psr.lp"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|25
block|}
block|,
block|{
literal|"psr.tb"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|26
block|}
block|,
block|{
literal|"psr.rt"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|27
block|}
block|,
comment|/* 28-31: reserved */
comment|/* 32-33: cpl (current privilege level) */
block|{
literal|"psr.is"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|34
block|}
block|,
block|{
literal|"psr.mc"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|35
block|}
block|,
block|{
literal|"psr.it"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|36
block|}
block|,
block|{
literal|"psr.id"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|37
block|}
block|,
block|{
literal|"psr.da"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|38
block|}
block|,
block|{
literal|"psr.dd"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|39
block|}
block|,
block|{
literal|"psr.ss"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|40
block|}
block|,
comment|/* 41-42: ri (restart instruction) */
block|{
literal|"psr.ed"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|43
block|}
block|,
block|{
literal|"psr.bn"
block|,
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|)
operator|<<
literal|44
block|}
block|,   }
struct|;
end_struct

begin_comment
comment|/* indirect register-sets/memory:  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|regnum
decl_stmt|;
block|}
name|indirect_reg
index|[]
init|=
block|{
block|{
literal|"CPUID"
block|,
name|IND_CPUID
block|}
block|,
block|{
literal|"cpuid"
block|,
name|IND_CPUID
block|}
block|,
block|{
literal|"dbr"
block|,
name|IND_DBR
block|}
block|,
block|{
literal|"dtr"
block|,
name|IND_DTR
block|}
block|,
block|{
literal|"itr"
block|,
name|IND_ITR
block|}
block|,
block|{
literal|"ibr"
block|,
name|IND_IBR
block|}
block|,
block|{
literal|"msr"
block|,
name|IND_MSR
block|}
block|,
block|{
literal|"pkr"
block|,
name|IND_PKR
block|}
block|,
block|{
literal|"pmc"
block|,
name|IND_PMC
block|}
block|,
block|{
literal|"pmd"
block|,
name|IND_PMD
block|}
block|,
block|{
literal|"rr"
block|,
name|IND_RR
block|}
block|,   }
struct|;
end_struct

begin_comment
comment|/* Pseudo functions used to indicate relocation types (these functions    start with an at sign (@).  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
enum|enum
name|pseudo_type
block|{
name|PSEUDO_FUNC_NONE
block|,
name|PSEUDO_FUNC_RELOC
block|,
name|PSEUDO_FUNC_CONST
block|,
name|PSEUDO_FUNC_REG
block|,
name|PSEUDO_FUNC_FLOAT
block|}
name|type
enum|;
union|union
block|{
name|unsigned
name|long
name|ival
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|}
name|u
union|;
block|}
name|pseudo_func
index|[]
init|=
block|{
comment|/* reloc pseudo functions (these must come first!):  */
block|{
literal|"dtpmod"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"dtprel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"fptr"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"gprel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"ltoff"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"ltoffx"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"pcrel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"pltoff"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"secrel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"segrel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"tprel"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"ltv"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* placeholder for FUNC_LT_FPTR_RELATIVE */
block|{
name|NULL
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* placeholder for FUNC_LT_DTP_MODULE */
block|{
name|NULL
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* placeholder for FUNC_LT_DTP_RELATIVE */
block|{
name|NULL
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* placeholder for FUNC_LT_TP_RELATIVE */
block|{
literal|"iplt"
block|,
name|PSEUDO_FUNC_RELOC
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* mbtype4 constants:  */
block|{
literal|"alt"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0xa
block|}
block|}
block|,
block|{
literal|"brcst"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x0
block|}
block|}
block|,
block|{
literal|"mix"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x8
block|}
block|}
block|,
block|{
literal|"rev"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0xb
block|}
block|}
block|,
block|{
literal|"shuf"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x9
block|}
block|}
block|,
comment|/* fclass constants:  */
block|{
literal|"nat"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x100
block|}
block|}
block|,
block|{
literal|"qnan"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x080
block|}
block|}
block|,
block|{
literal|"snan"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x040
block|}
block|}
block|,
block|{
literal|"pos"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x001
block|}
block|}
block|,
block|{
literal|"neg"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x002
block|}
block|}
block|,
block|{
literal|"zero"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x004
block|}
block|}
block|,
block|{
literal|"unorm"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x008
block|}
block|}
block|,
block|{
literal|"norm"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x010
block|}
block|}
block|,
block|{
literal|"inf"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x020
block|}
block|}
block|,
block|{
literal|"natval"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x100
block|}
block|}
block|,
comment|/* old usage */
comment|/* hint constants: */
block|{
literal|"pause"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|0x0
block|}
block|}
block|,
comment|/* unwind-related constants:  */
block|{
literal|"svr4"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
name|ELFOSABI_NONE
block|}
block|}
block|,
block|{
literal|"hpux"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
name|ELFOSABI_HPUX
block|}
block|}
block|,
block|{
literal|"nt"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
literal|2
block|}
block|}
block|,
comment|/* conflicts w/ELFOSABI_NETBSD */
block|{
literal|"linux"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
name|ELFOSABI_LINUX
block|}
block|}
block|,
block|{
literal|"freebsd"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
name|ELFOSABI_FREEBSD
block|}
block|}
block|,
block|{
literal|"openvms"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
name|ELFOSABI_OPENVMS
block|}
block|}
block|,
block|{
literal|"nsk"
block|,
name|PSEUDO_FUNC_CONST
block|,
block|{
name|ELFOSABI_NSK
block|}
block|}
block|,
comment|/* unwind-related registers:  */
block|{
literal|"priunat"
block|,
name|PSEUDO_FUNC_REG
block|,
block|{
name|REG_PRIUNAT
block|}
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* 41-bit nop opcodes (one per unit):  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|nop
index|[
name|IA64_NUM_UNITS
index|]
init|=
block|{
literal|0x0000000000LL
block|,
comment|/* NIL => break 0 */
literal|0x0008000000LL
block|,
comment|/* I-unit nop */
literal|0x0008000000LL
block|,
comment|/* M-unit nop */
literal|0x4000000000LL
block|,
comment|/* B-unit nop */
literal|0x0008000000LL
block|,
comment|/* F-unit nop */
literal|0x0000000000LL
block|,
comment|/* L-"unit" nop immediate */
literal|0x0008000000LL
block|,
comment|/* X-unit nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can't be `const' as it's passed to input routines (which have the    habit of setting temporary sentinels.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|special_section_name
index|[]
index|[
literal|20
index|]
init|=
block|{
block|{
literal|".bss"
block|}
block|,
block|{
literal|".sbss"
block|}
block|,
block|{
literal|".sdata"
block|}
block|,
block|{
literal|".rodata"
block|}
block|,
block|{
literal|".comment"
block|}
block|,
block|{
literal|".IA_64.unwind"
block|}
block|,
block|{
literal|".IA_64.unwind_info"
block|}
block|,
block|{
literal|".init_array"
block|}
block|,
block|{
literal|".fini_array"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The best template for a particular sequence of up to three    instructions:  */
end_comment

begin_define
define|#
directive|define
name|N
value|IA64_NUM_TYPES
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|best_template
index|[
name|N
index|]
index|[
name|N
index|]
index|[
name|N
index|]
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|N
end_undef

begin_comment
comment|/* Resource dependencies currently in effect */
end_comment

begin_struct
specifier|static
struct|struct
name|rsrc
block|{
name|int
name|depind
decl_stmt|;
comment|/* dependency index */
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dependency
decl_stmt|;
comment|/* actual dependency */
name|unsigned
name|specific
range|:
literal|1
decl_stmt|,
comment|/* is this a specific bit/regno? */
name|link_to_qp_branch
range|:
literal|1
decl_stmt|;
comment|/* will a branch on the same QP clear it?*/
name|int
name|index
decl_stmt|;
comment|/* specific regno/bit within dependency */
name|int
name|note
decl_stmt|;
comment|/* optional qualifying note (0 if none) */
define|#
directive|define
name|STATE_NONE
value|0
define|#
directive|define
name|STATE_STOP
value|1
define|#
directive|define
name|STATE_SRLZ
value|2
name|int
name|insn_srlz
decl_stmt|;
comment|/* current insn serialization state */
name|int
name|data_srlz
decl_stmt|;
comment|/* current data serialization state */
name|int
name|qp_regno
decl_stmt|;
comment|/* qualifying predicate for this usage */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* what file marked this dependency */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* what line marked this dependency */
name|struct
name|mem_offset
name|mem_offset
decl_stmt|;
comment|/* optional memory offset hint */
enum|enum
block|{
name|CMP_NONE
block|,
name|CMP_OR
block|,
name|CMP_AND
block|}
name|cmp_type
enum|;
comment|/* OR or AND compare? */
name|int
name|path
decl_stmt|;
comment|/* corresponding code entry index */
block|}
modifier|*
name|regdeps
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|regdepslen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regdepstotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dv_mode
index|[]
init|=
block|{
literal|"RAW"
block|,
literal|"WAW"
block|,
literal|"WAR"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dv_sem
index|[]
init|=
block|{
literal|"none"
block|,
literal|"implied"
block|,
literal|"impliedf"
block|,
literal|"data"
block|,
literal|"instr"
block|,
literal|"specific"
block|,
literal|"stop"
block|,
literal|"other"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dv_cmp_type
index|[]
init|=
block|{
literal|"none"
block|,
literal|"OR"
block|,
literal|"AND"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current state of PR mutexation */
end_comment

begin_struct
specifier|static
struct|struct
name|qpmutex
block|{
name|valueT
name|prmask
decl_stmt|;
name|int
name|path
decl_stmt|;
block|}
modifier|*
name|qp_mutexes
init|=
name|NULL
struct|;
end_struct

begin_comment
comment|/* QP mutex bitmasks */
end_comment

begin_decl_stmt
specifier|static
name|int
name|qp_mutexeslen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qp_mutexestotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|valueT
name|qp_safe_across_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current state of PR implications */
end_comment

begin_struct
specifier|static
struct|struct
name|qp_imply
block|{
name|unsigned
name|p1
range|:
literal|6
decl_stmt|;
name|unsigned
name|p2
range|:
literal|6
decl_stmt|;
name|unsigned
name|p2_branched
range|:
literal|1
decl_stmt|;
name|int
name|path
decl_stmt|;
block|}
modifier|*
name|qp_implies
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|qp_implieslen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qp_impliestotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of static GR values so that indirect register usage can    sometimes be tracked.  */
end_comment

begin_struct
specifier|static
struct|struct
name|gr
block|{
name|unsigned
name|known
range|:
literal|1
decl_stmt|;
name|int
name|path
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|}
name|gr_values
index|[
literal|128
index|]
init|=
block|{
block|{
literal|1
block|,
ifdef|#
directive|ifdef
name|INT_MAX
name|INT_MAX
block|,
else|#
directive|else
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|gr_values
operator|->
name|path
argument_list|)
operator|-
literal|2
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
block|,
endif|#
directive|endif
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Remember the alignment frag.  */
end_comment

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|align_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the routines required to output the various types of    unwind records.  */
end_comment

begin_comment
comment|/* A slot_number is a frag address plus the slot index (0-2).  We use the    frag address here so that if there is a section switch in the middle of    a function, then instructions emitted to a different section are not    counted.  Since there may be more than one frag for a function, this    means we also need to keep track of which frag this address belongs to    so we can compute inter-frag distances.  This also nicely solves the    problem with nops emitted for align directives, which can't easily be    counted, but can easily be derived from frag sizes.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|unw_rec_list
block|{
name|unwind_record
name|r
decl_stmt|;
name|unsigned
name|long
name|slot_number
decl_stmt|;
name|fragS
modifier|*
name|slot_frag
decl_stmt|;
name|struct
name|unw_rec_list
modifier|*
name|next
decl_stmt|;
block|}
name|unw_rec_list
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SLOT_NUM_NOT_SET
value|(unsigned)-1
end_define

begin_comment
comment|/* Linked list of saved prologue counts.  A very poor    implementation of a map from label numbers to prologue counts.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|label_prologue_count
block|{
name|struct
name|label_prologue_count
modifier|*
name|next
decl_stmt|;
name|unsigned
name|long
name|label_number
decl_stmt|;
name|unsigned
name|int
name|prologue_count
decl_stmt|;
block|}
name|label_prologue_count
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|proc_pending
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|struct
name|proc_pending
modifier|*
name|next
decl_stmt|;
block|}
name|proc_pending
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
block|{
comment|/* Maintain a list of unwind entries for the current function.  */
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|unw_rec_list
modifier|*
name|tail
decl_stmt|;
comment|/* Any unwind entires that should be attached to the current slot      that an insn is being constructed for.  */
name|unw_rec_list
modifier|*
name|current_entry
decl_stmt|;
comment|/* These are used to create the unwind table entry for this function.  */
name|proc_pending
name|proc_pending
decl_stmt|;
name|symbolS
modifier|*
name|info
decl_stmt|;
comment|/* pointer to unwind info */
name|symbolS
modifier|*
name|personality_routine
decl_stmt|;
name|segT
name|saved_text_seg
decl_stmt|;
name|subsegT
name|saved_text_subseg
decl_stmt|;
name|unsigned
name|int
name|force_unwind_entry
range|:
literal|1
decl_stmt|;
comment|/* force generation of unwind entry? */
comment|/* TRUE if processing unwind directives in a prologue region.  */
name|unsigned
name|int
name|prologue
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|prologue_mask
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|prologue_gr
range|:
literal|7
decl_stmt|;
name|unsigned
name|int
name|body
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|insn
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|prologue_count
decl_stmt|;
comment|/* number of .prologues seen so far */
comment|/* Prologue counts at previous .label_state directives.  */
name|struct
name|label_prologue_count
modifier|*
name|saved_prologue_counts
decl_stmt|;
comment|/* List of split up .save-s.  */
name|unw_p_record
modifier|*
name|pending_saves
decl_stmt|;
block|}
name|unwind
struct|;
end_struct

begin_comment
comment|/* The input value is a negated offset from psp, and specifies an address    psp - offset.  The encoded value is psp + 16 - (4 * offset).  Thus we    must add 16 and divide by 4 to get the encoded value.  */
end_comment

begin_define
define|#
directive|define
name|ENCODED_PSP_OFFSET
parameter_list|(
name|OFFSET
parameter_list|)
value|(((OFFSET) + 16) / 4)
end_define

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*vbyte_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* Forward declarations:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_section
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|set_regstack
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dot_align
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|dot_radix
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_special_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_proc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_fframe
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_vframe
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_vframesp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_save
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_restore
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_restorereg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_handlerdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_unwentry
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_altrp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_savemem
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_saveg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_savef
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_saveb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_savegf
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spill
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spillreg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_spillmem
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_label_state
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_copy_state
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_unwabi
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_personality
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_body
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_prologue
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_endp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_template
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_regstk
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_rot
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_byteorder
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_psr
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_alias
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_ln
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cross_section
name|PARAMS
argument_list|(
operator|(
name|int
name|ref
operator|,
name|void
argument_list|(
argument|*cons
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|,
name|int
name|ua
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stmt_float_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stmt_cons_ua
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xfloat_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xstringer
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xdata_ua
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_xfloat_cons_ua
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_prmask
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_pred_rel
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_reg_val
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_serialize
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_dv_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_entry
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dot_mem_offset
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_unwind_entry
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|declare_register
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
name|unsigned
name|int
name|regnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|declare_register_set
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|operand_width
name|PARAMS
argument_list|(
operator|(
expr|enum
name|ia64_opnd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|operand_match_result
name|operand_match
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_opcode
operator|*
name|idesc
operator|,
name|int
name|index
operator|,
name|expressionS
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_operand
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ia64_opcode
modifier|*
name|parse_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|slot
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_one_bundle
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_insn
name|PARAMS
argument_list|(
operator|(
name|fixS
operator|*
operator|,
specifier|const
expr|struct
name|ia64_operand
operator|*
operator|,
name|valueT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|ia64_gen_real_reloc_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
name|sym
operator|,
name|bfd_reloc_code_real_type
name|r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insn_group_break
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_resource
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|,
specifier|const
expr|struct
name|ia64_dependency
operator|*
operator|,
expr|struct
name|rsrc
operator|*
operator|,
name|int
name|depind
operator|,
name|int
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_qp_mutex
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_qp_imply
name|PARAMS
argument_list|(
operator|(
name|int
name|p1
operator|,
name|int
name|p2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_qp_branch_flag
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_qp_mutex
name|PARAMS
argument_list|(
operator|(
name|valueT
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_qp_implies
name|PARAMS
argument_list|(
operator|(
name|valueT
name|p1_mask
operator|,
name|valueT
name|p2_mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|has_suffix_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_register_values
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_dependency
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|action
operator|,
name|int
name|depind
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|instruction_serialization
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|data_serialization
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_marked_resource
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rsrc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_conditional_branch
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_taken_branch
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_interruption_or_rfi
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|depends_on
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|specify_resource
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_dependency
operator|*
operator|,
expr|struct
name|ia64_opcode
operator|*
operator|,
name|int
operator|,
expr|struct
name|rsrc
index|[]
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dv
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
name|idesc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_dependencies
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_resources
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_dependencies
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_register_values
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ia64_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qp_mutex
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resources_match
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rsrc
operator|*
operator|,
expr|struct
name|ia64_opcode
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_vbyte_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_output
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_R1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_R2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_R3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P4_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P5_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P6_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P7_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P8_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P9_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_P10_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_B4_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|format_ab_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X1_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X2_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X3_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|unw_record_type
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_X4_format
name|PARAMS
argument_list|(
operator|(
name|vbyte_func
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_endp
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_body
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_f
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_v
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_br
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fr_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_frgr_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_br_mem
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_br_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_base
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_gr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_when
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_gr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_unwabi
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_epilogue
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_label_state
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_copy_state
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_psprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_sprel
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_reg
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_one_record
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|vbyte_func
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_unw_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|vbyte_func
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|calc_record_size
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_imask
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|slot_index
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|fragS
operator|*
operator|,
name|unsigned
name|long
operator|,
name|fragS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unw_rec_list
modifier|*
name|optimize_unw_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_unw_records
name|PARAMS
argument_list|(
operator|(
name|unw_rec_list
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_predicate_and_operand
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|unsigned
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_expr_to_ab_reg
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_expr_to_xy_reg
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|get_saved_prologue_count
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_prologue_count
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_saved_prologue_counts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine if application register REGNUM resides only in the integer    unit (as opposed to the memory unit).  */
end_comment

begin_function
specifier|static
name|int
name|ar_is_only_in_integer_unit
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|reg
operator|-=
name|REG_AR
expr_stmt|;
return|return
name|reg
operator|>=
literal|64
operator|&&
name|reg
operator|<=
literal|111
return|;
block|}
end_function

begin_comment
comment|/* Determine if application register REGNUM resides only in the memory     unit (as opposed to the integer unit).  */
end_comment

begin_function
specifier|static
name|int
name|ar_is_only_in_memory_unit
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|reg
operator|-=
name|REG_AR
expr_stmt|;
return|return
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|47
return|;
block|}
end_function

begin_comment
comment|/* Switch to section NAME and create section if necessary.  It's    rather ugly that we have to manipulate input_line_pointer but I    don't see any other way to accomplish the same thing without    changing obj-elf.c (which may be the Right Thing, in the end).  */
end_comment

begin_function
specifier|static
name|void
name|set_section
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|;
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|name
expr_stmt|;
name|obj_elf_section
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map 's' to SHF_IA_64_SHORT.  */
end_comment

begin_function
name|int
name|ia64_elf_section_letter
parameter_list|(
name|letter
parameter_list|,
name|ptr_msg
parameter_list|)
name|int
name|letter
decl_stmt|;
name|char
modifier|*
modifier|*
name|ptr_msg
decl_stmt|;
block|{
if|if
condition|(
name|letter
operator|==
literal|'s'
condition|)
return|return
name|SHF_IA_64_SHORT
return|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'o'
condition|)
return|return
name|SHF_LINK_ORDER
return|;
operator|*
name|ptr_msg
operator|=
name|_
argument_list|(
literal|"Bad .section directive: want a,o,s,w,x,M,S,G,T in string"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Map SHF_IA_64_SHORT to SEC_SMALL_DATA.  */
end_comment

begin_function
name|flagword
name|ia64_elf_section_flags
parameter_list|(
name|flags
parameter_list|,
name|attr
parameter_list|,
name|type
parameter_list|)
name|flagword
name|flags
decl_stmt|;
name|int
name|attr
decl_stmt|,
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|attr
operator|&
name|SHF_IA_64_SHORT
condition|)
name|flags
operator||=
name|SEC_SMALL_DATA
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_function
name|int
name|ia64_elf_section_type
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
define|#
directive|define
name|STREQ
parameter_list|(
name|s
parameter_list|)
value|((len == sizeof (s) - 1)&& (strncmp (str, s, sizeof (s) - 1) == 0))
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind_info
argument_list|)
condition|)
return|return
name|SHT_PROGBITS
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind_info_once
argument_list|)
condition|)
return|return
name|SHT_PROGBITS
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
condition|)
return|return
name|SHT_IA_64_UNWIND
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
condition|)
return|return
name|SHT_IA_64_UNWIND
return|;
if|if
condition|(
name|STREQ
argument_list|(
literal|"unwind"
argument_list|)
condition|)
return|return
name|SHT_IA_64_UNWIND
return|;
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|STREQ
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|set_regstack
parameter_list|(
name|ins
parameter_list|,
name|locs
parameter_list|,
name|outs
parameter_list|,
name|rots
parameter_list|)
name|unsigned
name|int
name|ins
decl_stmt|,
name|locs
decl_stmt|,
name|outs
decl_stmt|,
name|rots
decl_stmt|;
block|{
comment|/* Size of frame.  */
name|unsigned
name|int
name|sof
decl_stmt|;
name|sof
operator|=
name|ins
operator|+
name|locs
operator|+
name|outs
expr_stmt|;
if|if
condition|(
name|sof
operator|>
literal|96
condition|)
block|{
name|as_bad
argument_list|(
literal|"Size of frame exceeds maximum of 96 registers"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rots
operator|>
name|sof
condition|)
block|{
name|as_warn
argument_list|(
literal|"Size of rotating registers exceeds frame size"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|md
operator|.
name|in
operator|.
name|base
operator|=
name|REG_GR
operator|+
literal|32
expr_stmt|;
name|md
operator|.
name|loc
operator|.
name|base
operator|=
name|md
operator|.
name|in
operator|.
name|base
operator|+
name|ins
expr_stmt|;
name|md
operator|.
name|out
operator|.
name|base
operator|=
name|md
operator|.
name|loc
operator|.
name|base
operator|+
name|locs
expr_stmt|;
name|md
operator|.
name|in
operator|.
name|num_regs
operator|=
name|ins
expr_stmt|;
name|md
operator|.
name|loc
operator|.
name|num_regs
operator|=
name|locs
expr_stmt|;
name|md
operator|.
name|out
operator|.
name|num_regs
operator|=
name|outs
expr_stmt|;
name|md
operator|.
name|rot
operator|.
name|num_regs
operator|=
name|rots
expr_stmt|;
return|return
name|sof
return|;
block|}
end_function

begin_function
name|void
name|ia64_flush_insns
parameter_list|()
block|{
name|struct
name|label_fix
modifier|*
name|lfix
decl_stmt|;
name|segT
name|saved_seg
decl_stmt|;
name|subsegT
name|saved_subseg
decl_stmt|;
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
name|bfd_boolean
name|mark
decl_stmt|;
if|if
condition|(
operator|!
name|md
operator|.
name|last_text_seg
condition|)
return|return;
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
name|subseg_set
argument_list|(
name|md
operator|.
name|last_text_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
comment|/* force out queued instructions */
comment|/* In case there are labels following the last instruction, resolve      those now.  */
name|mark
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|lfix
operator|=
name|CURR_SLOT
operator|.
name|label_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
block|{
name|symbol_set_value_now
argument_list|(
name|lfix
operator|->
name|sym
argument_list|)
expr_stmt|;
name|mark
operator||=
name|lfix
operator|->
name|dw2_mark_labels
expr_stmt|;
block|}
if|if
condition|(
name|mark
condition|)
block|{
name|dwarf2_where
argument_list|(
operator|&
name|CURR_SLOT
operator|.
name|debug_line
argument_list|)
expr_stmt|;
name|CURR_SLOT
operator|.
name|debug_line
operator|.
name|flags
operator||=
name|DWARF2_FLAG_BASIC_BLOCK
expr_stmt|;
name|dwarf2_gen_line_info
argument_list|(
name|frag_now_fix
argument_list|()
argument_list|,
operator|&
name|CURR_SLOT
operator|.
name|debug_line
argument_list|)
expr_stmt|;
block|}
name|CURR_SLOT
operator|.
name|label_fixups
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lfix
operator|=
name|CURR_SLOT
operator|.
name|tag_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
name|symbol_set_value_now
argument_list|(
name|lfix
operator|->
name|sym
argument_list|)
expr_stmt|;
name|CURR_SLOT
operator|.
name|tag_fixups
operator|=
literal|0
expr_stmt|;
comment|/* In case there are unwind directives following the last instruction,      resolve those now.  We only handle prologue, body, and endp directives      here.  Give an error for others.  */
for|for
control|(
name|ptr
operator|=
name|unwind
operator|.
name|current_entry
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
condition|)
block|{
case|case
name|prologue
case|:
case|case
name|prologue_gr
case|:
case|case
name|body
case|:
case|case
name|endp
case|:
name|ptr
operator|->
name|slot_number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|slot_frag
operator|=
name|frag_now
expr_stmt|;
break|break;
comment|/* Allow any record which doesn't have a "t" field (i.e., 	     doesn't relate to a particular instruction).  */
case|case
name|unwabi
case|:
case|case
name|br_gr
case|:
case|case
name|copy_state
case|:
case|case
name|fr_mem
case|:
case|case
name|frgr_mem
case|:
case|case
name|gr_gr
case|:
case|case
name|gr_mem
case|:
case|case
name|label_state
case|:
case|case
name|rp_br
case|:
case|case
name|spill_base
case|:
case|case
name|spill_mask
case|:
comment|/* nothing */
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unwind directive not followed by an instruction."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
literal|"qualifying predicate not followed by instruction"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_do_align
parameter_list|(
name|int
name|nbytes
parameter_list|)
block|{
name|char
modifier|*
name|saved_input_line_pointer
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
literal|""
expr_stmt|;
name|s_align_bytes
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_cons_align
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|auto_align
condition|)
block|{
name|char
modifier|*
name|saved_input_line_pointer
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
literal|""
expr_stmt|;
name|s_align_bytes
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output COUNT bytes to a memory location.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vbyte_mem_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|output_vbyte_mem
parameter_list|(
name|count
parameter_list|,
name|ptr
parameter_list|,
name|comment
parameter_list|)
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|comment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|vbyte_mem_ptr
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
name|x
operator|++
control|)
operator|*
operator|(
name|vbyte_mem_ptr
operator|++
operator|)
operator|=
name|ptr
index|[
name|x
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of bytes required for records.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vbyte_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|count_output
parameter_list|(
name|count
parameter_list|,
name|ptr
parameter_list|,
name|comment
parameter_list|)
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|comment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|vbyte_count
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_R1_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|rlen
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|rlen
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|char
name|byte
decl_stmt|;
if|if
condition|(
name|rlen
operator|>
literal|0x1f
condition|)
block|{
name|output_R3_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|body
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|prologue
condition|)
name|as_bad
argument_list|(
literal|"record type is not valid"
argument_list|)
expr_stmt|;
name|byte
operator|=
name|UNW_R1
operator||
operator|(
name|r
operator|<<
literal|5
operator|)
operator||
operator|(
name|rlen
operator|&
literal|0x1f
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_R2_format
parameter_list|(
name|f
parameter_list|,
name|mask
parameter_list|,
name|grsave
parameter_list|,
name|rlen
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|grsave
decl_stmt|;
name|unsigned
name|long
name|rlen
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|2
decl_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|grsave
operator|=
operator|(
name|grsave
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_R2
operator||
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|mask
operator|&
literal|0x01
operator|)
operator|<<
literal|7
operator|)
operator||
name|grsave
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|2
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_R3_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|rlen
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|rlen
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|rlen
operator|<=
literal|0x1f
condition|)
block|{
name|output_R1_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|body
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|prologue
condition|)
name|as_bad
argument_list|(
literal|"record type is not valid"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_R3
operator||
name|r
operator|)
expr_stmt|;
name|count
operator|=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
operator|+
literal|1
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P1_format
parameter_list|(
name|f
parameter_list|,
name|brmask
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|brmask
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|byte
operator|=
name|UNW_P1
operator||
operator|(
name|brmask
operator|&
literal|0x1f
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P2_format
parameter_list|(
name|f
parameter_list|,
name|brmask
parameter_list|,
name|gr
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|brmask
decl_stmt|;
name|int
name|gr
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|2
index|]
decl_stmt|;
name|brmask
operator|=
operator|(
name|brmask
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P2
operator||
operator|(
name|brmask
operator|>>
literal|1
operator|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|brmask
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|gr
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|2
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P3_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|reg
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|reg
operator|=
operator|(
name|reg
operator|&
literal|0x7f
operator|)
expr_stmt|;
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|psp_gr
case|:
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rp_gr
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|pfs_gr
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|preds_gr
case|:
name|r
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|unat_gr
case|:
name|r
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|lc_gr
case|:
name|r
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|rp_br
case|:
name|r
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|rnat_gr
case|:
name|r
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|bsp_gr
case|:
name|r
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|bspstore_gr
case|:
name|r
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|fpsr_gr
case|:
name|r
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|priunat_gr
case|:
name|r
operator|=
literal|11
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Invalid record type for P3 format."
argument_list|)
expr_stmt|;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_P3
operator||
operator|(
name|r
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|reg
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|2
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P4_format
parameter_list|(
name|f
parameter_list|,
name|imask
parameter_list|,
name|imask_size
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unsigned
name|char
modifier|*
name|imask
decl_stmt|;
name|unsigned
name|long
name|imask_size
decl_stmt|;
block|{
name|imask
index|[
literal|0
index|]
operator|=
name|UNW_P4
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|imask_size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|imask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P5_format
parameter_list|(
name|f
parameter_list|,
name|grmask
parameter_list|,
name|frmask
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|grmask
decl_stmt|;
name|unsigned
name|long
name|frmask
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|4
index|]
decl_stmt|;
name|grmask
operator|=
operator|(
name|grmask
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P5
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|grmask
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|frmask
operator|&
literal|0x000f0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|frmask
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|bytes
index|[
literal|3
index|]
operator|=
operator|(
name|frmask
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|4
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P6_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|rmask
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|rmask
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rtype
operator|==
name|gr_mem
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|fr_mem
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format P6"
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
name|UNW_P6
operator||
operator|(
name|r
operator|<<
literal|4
operator|)
operator||
operator|(
name|rmask
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P7_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|w1
parameter_list|,
name|w2
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|w1
decl_stmt|;
name|unsigned
name|long
name|w2
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|w1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|mem_stack_f
case|:
name|r
operator|=
literal|0
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|w2
operator|>>
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|mem_stack_v
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|spill_base
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|psp_sprel
case|:
name|r
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|rp_when
case|:
name|r
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|rp_psprel
case|:
name|r
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|pfs_when
case|:
name|r
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|pfs_psprel
case|:
name|r
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|preds_when
case|:
name|r
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|preds_psprel
case|:
name|r
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|lc_when
case|:
name|r
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|lc_psprel
case|:
name|r
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|unat_when
case|:
name|r
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|unat_psprel
case|:
name|r
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|fpsr_when
case|:
name|r
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|fpsr_psprel
case|:
name|r
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_P7
operator||
name|r
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P8_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|2
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P8
expr_stmt|;
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|rp_sprel
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|pfs_sprel
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|preds_sprel
case|:
name|r
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|lc_sprel
case|:
name|r
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|unat_sprel
case|:
name|r
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|fpsr_sprel
case|:
name|r
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|bsp_when
case|:
name|r
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|bsp_psprel
case|:
name|r
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|bsp_sprel
case|:
name|r
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|bspstore_when
case|:
name|r
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|bspstore_psprel
case|:
name|r
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|bspstore_sprel
case|:
name|r
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|rnat_when
case|:
name|r
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|rnat_psprel
case|:
name|r
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|rnat_sprel
case|:
name|r
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|priunat_when_gr
case|:
name|r
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|priunat_psprel
case|:
name|r
operator|=
literal|17
expr_stmt|;
break|break;
case|case
name|priunat_sprel
case|:
name|r
operator|=
literal|18
expr_stmt|;
break|break;
case|case
name|priunat_when_mem
case|:
name|r
operator|=
literal|19
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bytes
index|[
literal|1
index|]
operator|=
name|r
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|2
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P9_format
parameter_list|(
name|f
parameter_list|,
name|grmask
parameter_list|,
name|gr
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|grmask
decl_stmt|;
name|int
name|gr
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|3
index|]
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P9
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
name|grmask
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
name|gr
operator|&
literal|0x7f
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|3
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_P10_format
parameter_list|(
name|f
parameter_list|,
name|abi
parameter_list|,
name|context
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|abi
decl_stmt|;
name|int
name|context
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|3
index|]
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_P10
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
name|abi
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
name|context
operator|&
literal|0xff
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|3
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B1_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|label
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|label
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|label
operator|>
literal|0x1f
condition|)
block|{
name|output_B4_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|copy_state
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|label_state
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format B1"
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
name|UNW_B1
operator||
operator|(
name|r
operator|<<
literal|5
operator|)
operator||
operator|(
name|label
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
literal|1
argument_list|,
operator|&
name|byte
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B2_format
parameter_list|(
name|f
parameter_list|,
name|ecount
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unsigned
name|long
name|ecount
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ecount
operator|>
literal|0x1f
condition|)
block|{
name|output_B3_format
argument_list|(
name|f
argument_list|,
name|ecount
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_B2
operator||
operator|(
name|ecount
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B3_format
parameter_list|(
name|f
parameter_list|,
name|ecount
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unsigned
name|long
name|ecount
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ecount
operator|<=
literal|0x1f
condition|)
block|{
name|output_B2_format
argument_list|(
name|f
argument_list|,
name|ecount
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_B3
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|ecount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_B4_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|label
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|unsigned
name|long
name|label
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|label
operator|<=
literal|0x1f
condition|)
block|{
name|output_B1_format
argument_list|(
name|f
argument_list|,
name|rtype
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtype
operator|==
name|copy_state
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|label_state
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format B1"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|UNW_B4
operator||
operator|(
name|r
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|1
argument_list|,
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
name|format_ab_reg
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|)
name|int
name|ab
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ab
operator|=
operator|(
name|ab
operator|&
literal|3
operator|)
expr_stmt|;
name|reg
operator|=
operator|(
name|reg
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|ret
operator|=
operator|(
name|ab
operator|<<
literal|5
operator|)
operator||
name|reg
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X1_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|t
parameter_list|,
name|w1
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
name|unsigned
name|long
name|w1
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|2
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X1
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|spill_sprel
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|spill_psprel
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format X1"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|r
operator|<<
literal|7
operator|)
operator||
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|2
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|w1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X2_format
parameter_list|(
name|f
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|treg
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|treg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|3
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X2
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
operator|(
operator|(
name|y
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|treg
operator|&
literal|0x7f
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|3
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X3_format
parameter_list|(
name|f
parameter_list|,
name|rtype
parameter_list|,
name|qp
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|t
parameter_list|,
name|w1
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|unw_record_type
name|rtype
decl_stmt|;
name|int
name|qp
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
name|unsigned
name|long
name|w1
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|3
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X3
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|spill_sprel_p
condition|)
name|r
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|spill_psprel_p
condition|)
name|as_bad
argument_list|(
literal|"Invalid record type for format X3"
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|r
operator|<<
literal|7
operator|)
operator||
operator|(
name|qp
operator|&
literal|0x3f
operator|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|3
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
name|count
argument_list|,
name|w1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_X4_format
parameter_list|(
name|f
parameter_list|,
name|qp
parameter_list|,
name|ab
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|treg
parameter_list|,
name|t
parameter_list|)
name|vbyte_func
name|f
decl_stmt|;
name|int
name|qp
decl_stmt|;
name|int
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|treg
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
block|{
name|char
name|bytes
index|[
literal|20
index|]
decl_stmt|;
name|int
name|count
init|=
literal|4
decl_stmt|;
name|bytes
index|[
literal|0
index|]
operator|=
name|UNW_X4
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator|=
operator|(
name|qp
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
name|format_ab_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|)
operator|)
expr_stmt|;
name|bytes
index|[
literal|3
index|]
operator|=
operator|(
operator|(
operator|(
name|y
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|treg
operator|&
literal|0x7f
operator|)
operator|)
expr_stmt|;
name|count
operator|+=
name|output_leb128
argument_list|(
name|bytes
operator|+
literal|4
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|count
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function checks whether there are any outstanding .save-s and    discards them if so.  */
end_comment

begin_function
specifier|static
name|void
name|check_pending_save
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unwind
operator|.
name|pending_saves
condition|)
block|{
name|unw_rec_list
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|as_warn
argument_list|(
literal|"Previous .save incomplete"
argument_list|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|unwind
operator|.
name|list
operator|,
name|prev
operator|=
name|NULL
init|;
name|cur
condition|;
control|)
if|if
condition|(
operator|&
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|==
name|unwind
operator|.
name|pending_saves
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
else|else
name|unwind
operator|.
name|list
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|unwind
operator|.
name|tail
condition|)
name|unwind
operator|.
name|tail
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|unwind
operator|.
name|current_entry
condition|)
name|unwind
operator|.
name|current_entry
operator|=
name|cur
operator|->
name|next
expr_stmt|;
comment|/* Don't free the first discarded record, it's being used as 	       terminator for (currently) br_gr and gr_gr processing, and 	       also prevents leaving a dangling pointer to it in its 	       predecessor.  */
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
name|prev
expr_stmt|;
break|break;
block|}
else|else
block|{
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|cur
condition|)
block|{
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
name|unwind
operator|.
name|pending_saves
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function allocates a record list structure, and initializes fields.  */
end_comment

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|alloc_record
parameter_list|(
name|unw_record_type
name|t
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|slot_number
operator|=
name|SLOT_NUM_NOT_SET
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|type
operator|=
name|t
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Dummy unwind record used for calculating the length of the last prologue or    body region.  */
end_comment

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_endp
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|endp
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|prologue
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_prologue_gr
parameter_list|(
name|saved_mask
parameter_list|,
name|reg
parameter_list|)
name|unsigned
name|int
name|saved_mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|prologue_gr
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grmask
operator|=
name|saved_mask
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grsave
operator|=
name|reg
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_body
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|body
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_f
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|mem_stack_f
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_mem_stack_v
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|mem_stack_v
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|psp_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_psp_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|psp_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_br
parameter_list|(
name|br
parameter_list|)
name|unsigned
name|int
name|br
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_br
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|br
operator|=
name|br
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rp_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rp_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_pfs_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|pfs_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_preds_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|preds_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fr_mem
parameter_list|(
name|mask
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fr_mem
argument_list|)
decl_stmt|;
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|=
name|mask
expr_stmt|;
name|unwind
operator|.
name|pending_saves
operator|=
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unw_rec_list
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
comment|/* Clear least significant set bit.  */
name|mask
operator|&=
operator|~
operator|(
name|mask
operator|&
operator|(
operator|~
name|mask
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
name|ptr
return|;
name|cur
operator|=
name|alloc_record
argument_list|(
name|fr_mem
argument_list|)
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|=
name|mask
expr_stmt|;
comment|/* Retain only least significant bit.  */
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|^=
name|mask
expr_stmt|;
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|cur
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_frgr_mem
parameter_list|(
name|gr_mask
parameter_list|,
name|fr_mask
parameter_list|)
name|unsigned
name|int
name|gr_mask
decl_stmt|;
name|unsigned
name|int
name|fr_mask
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|frgr_mem
argument_list|)
decl_stmt|;
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|unwind
operator|.
name|pending_saves
operator|=
operator|&
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|=
name|fr_mask
expr_stmt|;
while|while
condition|(
name|fr_mask
condition|)
block|{
name|unw_rec_list
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
comment|/* Clear least significant set bit.  */
name|fr_mask
operator|&=
operator|~
operator|(
name|fr_mask
operator|&
operator|(
operator|~
name|fr_mask
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gr_mask
operator|&&
operator|!
name|fr_mask
condition|)
return|return
name|ptr
return|;
name|cur
operator|=
name|alloc_record
argument_list|(
name|frgr_mem
argument_list|)
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|=
name|fr_mask
expr_stmt|;
comment|/* Retain only least significant bit.  */
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
operator|^=
name|fr_mask
expr_stmt|;
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|cur
expr_stmt|;
block|}
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|gr_mask
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unw_rec_list
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
comment|/* Clear least significant set bit.  */
name|gr_mask
operator|&=
operator|~
operator|(
name|gr_mask
operator|&
operator|(
operator|~
name|gr_mask
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gr_mask
condition|)
return|return
name|ptr
return|;
name|cur
operator|=
name|alloc_record
argument_list|(
name|frgr_mem
argument_list|)
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|gr_mask
expr_stmt|;
comment|/* Retain only least significant bit.  */
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|^=
name|gr_mask
expr_stmt|;
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|cur
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_gr
parameter_list|(
name|mask
parameter_list|,
name|reg
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|gr_gr
argument_list|)
decl_stmt|;
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|mask
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|reg
expr_stmt|;
name|unwind
operator|.
name|pending_saves
operator|=
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unw_rec_list
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
comment|/* Clear least significant set bit.  */
name|mask
operator|&=
operator|~
operator|(
name|mask
operator|&
operator|(
operator|~
name|mask
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
name|ptr
return|;
name|cur
operator|=
name|alloc_record
argument_list|(
name|gr_gr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|mask
expr_stmt|;
comment|/* Indicate this record shouldn't be output.  */
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|REG_NUM
expr_stmt|;
comment|/* Retain only least significant bit.  */
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|^=
name|mask
expr_stmt|;
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|cur
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_gr_mem
parameter_list|(
name|mask
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|gr_mem
argument_list|)
decl_stmt|;
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|mask
expr_stmt|;
name|unwind
operator|.
name|pending_saves
operator|=
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unw_rec_list
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
comment|/* Clear least significant set bit.  */
name|mask
operator|&=
operator|~
operator|(
name|mask
operator|&
operator|(
operator|~
name|mask
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
name|ptr
return|;
name|cur
operator|=
name|alloc_record
argument_list|(
name|gr_mem
argument_list|)
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|=
name|mask
expr_stmt|;
comment|/* Retain only least significant bit.  */
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
operator|^=
name|mask
expr_stmt|;
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|cur
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_br_mem
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|br_mem
argument_list|)
decl_stmt|;
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|=
name|mask
expr_stmt|;
name|unwind
operator|.
name|pending_saves
operator|=
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unw_rec_list
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
comment|/* Clear least significant set bit.  */
name|mask
operator|&=
operator|~
operator|(
name|mask
operator|&
operator|(
operator|~
name|mask
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
name|ptr
return|;
name|cur
operator|=
name|alloc_record
argument_list|(
name|br_mem
argument_list|)
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|=
name|mask
expr_stmt|;
comment|/* Retain only least significant bit.  */
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|^=
name|mask
expr_stmt|;
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|cur
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_br_gr
parameter_list|(
name|mask
parameter_list|,
name|reg
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|br_gr
argument_list|)
decl_stmt|;
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|=
name|mask
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|reg
expr_stmt|;
name|unwind
operator|.
name|pending_saves
operator|=
operator|&
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unw_rec_list
modifier|*
name|prev
init|=
name|cur
decl_stmt|;
comment|/* Clear least significant set bit.  */
name|mask
operator|&=
operator|~
operator|(
name|mask
operator|&
operator|(
operator|~
name|mask
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
name|ptr
return|;
name|cur
operator|=
name|alloc_record
argument_list|(
name|br_gr
argument_list|)
expr_stmt|;
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|=
name|mask
expr_stmt|;
comment|/* Indicate this record shouldn't be output.  */
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|REG_NUM
expr_stmt|;
comment|/* Retain only least significant bit.  */
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
operator|^=
name|mask
expr_stmt|;
name|prev
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|=
name|cur
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_base
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|spill_base
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unat_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unat_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_lc_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|lc_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_fpsr_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|fpsr_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_gr
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_when_gr
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_when_mem
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_when_mem
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_priunat_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|priunat_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bsp_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bsp_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_bspstore_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|bspstore_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_when
parameter_list|()
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_when
argument_list|)
decl_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_gr
parameter_list|(
name|gr
parameter_list|)
name|unsigned
name|int
name|gr
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_gr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|=
name|gr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_psprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_rnat_sprel
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|rnat_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_unwabi
parameter_list|(
name|abi
parameter_list|,
name|context
parameter_list|)
name|unsigned
name|long
name|abi
decl_stmt|;
name|unsigned
name|long
name|context
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|unwabi
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|abi
operator|=
name|abi
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|context
operator|=
name|context
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_epilogue
parameter_list|(
name|unsigned
name|long
name|ecount
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|epilogue
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|ecount
operator|=
name|ecount
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_label_state
parameter_list|(
name|unsigned
name|long
name|label
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|label_state
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|label
operator|=
name|label
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_copy_state
parameter_list|(
name|unsigned
name|long
name|label
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|copy_state
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|label
operator|=
name|label
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_psprel
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|,
name|predicate
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|predicate
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|predicate
condition|?
name|spill_psprel_p
else|:
name|spill_psprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|pspoff
operator|=
name|ENCODED_PSP_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
operator|=
name|predicate
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_sprel
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|,
name|predicate
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|predicate
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|predicate
condition|?
name|spill_sprel_p
else|:
name|spill_sprel
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|spoff
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
operator|=
name|predicate
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|output_spill_reg
parameter_list|(
name|ab
parameter_list|,
name|reg
parameter_list|,
name|targ_reg
parameter_list|,
name|xy
parameter_list|,
name|predicate
parameter_list|)
name|unsigned
name|int
name|ab
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|unsigned
name|int
name|targ_reg
decl_stmt|;
name|unsigned
name|int
name|xy
decl_stmt|;
name|unsigned
name|int
name|predicate
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
init|=
name|alloc_record
argument_list|(
name|predicate
condition|?
name|spill_reg_p
else|:
name|spill_reg
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
operator|=
name|ab
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|reg
operator|=
name|targ_reg
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
operator|=
name|xy
expr_stmt|;
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
operator|=
name|predicate
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Given a unw_rec_list process the correct format with the    specified function.  */
end_comment

begin_function
specifier|static
name|void
name|process_one_record
parameter_list|(
name|ptr
parameter_list|,
name|f
parameter_list|)
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
name|vbyte_func
name|f
decl_stmt|;
block|{
name|unsigned
name|int
name|fr_mask
decl_stmt|,
name|gr_mask
decl_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
condition|)
block|{
comment|/* This is a dummy record that takes up no space in the output.  */
case|case
name|endp
case|:
break|break;
case|case
name|gr_mem
case|:
case|case
name|fr_mem
case|:
case|case
name|br_mem
case|:
case|case
name|frgr_mem
case|:
comment|/* These are taken care of by prologue/prologue_gr.  */
break|break;
case|case
name|prologue_gr
case|:
case|case
name|prologue
case|:
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
condition|)
name|output_R2_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grmask
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|grsave
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
argument_list|)
expr_stmt|;
else|else
name|output_R1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
argument_list|)
expr_stmt|;
comment|/* Output descriptor(s) for union of register spills (if any).  */
name|gr_mask
operator|=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|gr_mem
expr_stmt|;
name|fr_mask
operator|=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|fr_mem
expr_stmt|;
if|if
condition|(
name|fr_mask
condition|)
block|{
if|if
condition|(
operator|(
name|fr_mask
operator|&
operator|~
literal|0xfUL
operator|)
operator|==
literal|0
condition|)
name|output_P6_format
argument_list|(
name|f
argument_list|,
name|fr_mem
argument_list|,
name|fr_mask
argument_list|)
expr_stmt|;
else|else
block|{
name|output_P5_format
argument_list|(
name|f
argument_list|,
name|gr_mask
argument_list|,
name|fr_mask
argument_list|)
expr_stmt|;
name|gr_mask
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gr_mask
condition|)
name|output_P6_format
argument_list|(
name|f
argument_list|,
name|gr_mem
argument_list|,
name|gr_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|br_mem
condition|)
name|output_P1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|br_mem
argument_list|)
expr_stmt|;
comment|/* output imask descriptor if necessary:  */
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
condition|)
name|output_P4_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|imask_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|body
case|:
name|output_R1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|mem_stack_f
case|:
case|case
name|mem_stack_v
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|psp_gr
case|:
case|case
name|rp_gr
case|:
case|case
name|pfs_gr
case|:
case|case
name|preds_gr
case|:
case|case
name|unat_gr
case|:
case|case
name|lc_gr
case|:
case|case
name|fpsr_gr
case|:
case|case
name|priunat_gr
case|:
case|case
name|bsp_gr
case|:
case|case
name|bspstore_gr
case|:
case|case
name|rnat_gr
case|:
name|output_P3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_br
case|:
name|output_P3_format
argument_list|(
name|f
argument_list|,
name|rp_br
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|br
argument_list|)
expr_stmt|;
break|break;
case|case
name|psp_sprel
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|psp_sprel
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_when
case|:
case|case
name|pfs_when
case|:
case|case
name|preds_when
case|:
case|case
name|unat_when
case|:
case|case
name|lc_when
case|:
case|case
name|fpsr_when
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_psprel
case|:
case|case
name|pfs_psprel
case|:
case|case
name|preds_psprel
case|:
case|case
name|unat_psprel
case|:
case|case
name|lc_psprel
case|:
case|case
name|fpsr_psprel
case|:
case|case
name|spill_base
case|:
name|output_P7_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|rp_sprel
case|:
case|case
name|pfs_sprel
case|:
case|case
name|preds_sprel
case|:
case|case
name|unat_sprel
case|:
case|case
name|lc_sprel
case|:
case|case
name|fpsr_sprel
case|:
case|case
name|priunat_sprel
case|:
case|case
name|bsp_sprel
case|:
case|case
name|bspstore_sprel
case|:
case|case
name|rnat_sprel
case|:
name|output_P8_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|gr_gr
case|:
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|<
name|REG_NUM
condition|)
block|{
specifier|const
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|gr_mask
operator|=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|)
operator|!=
name|NULL
condition|)
name|gr_mask
operator||=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
expr_stmt|;
name|output_P9_format
argument_list|(
name|f
argument_list|,
name|gr_mask
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|br_gr
case|:
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
operator|<
name|REG_NUM
condition|)
block|{
specifier|const
name|unw_rec_list
modifier|*
name|cur
init|=
name|ptr
decl_stmt|;
name|gr_mask
operator|=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|next
operator|)
operator|!=
name|NULL
condition|)
name|gr_mask
operator||=
name|cur
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
expr_stmt|;
name|output_P2_format
argument_list|(
name|f
argument_list|,
name|gr_mask
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|r
operator|.
name|gr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|spill_mask
case|:
name|as_bad
argument_list|(
literal|"spill_mask record unimplemented."
argument_list|)
expr_stmt|;
break|break;
case|case
name|priunat_when_gr
case|:
case|case
name|priunat_when_mem
case|:
case|case
name|bsp_when
case|:
case|case
name|bspstore_when
case|:
case|case
name|rnat_when
case|:
name|output_P8_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|priunat_psprel
case|:
case|case
name|bsp_psprel
case|:
case|case
name|bspstore_psprel
case|:
case|case
name|rnat_psprel
case|:
name|output_P8_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|off
operator|.
name|psp
argument_list|)
expr_stmt|;
break|break;
case|case
name|unwabi
case|:
name|output_P10_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|abi
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|context
argument_list|)
expr_stmt|;
break|break;
case|case
name|epilogue
case|:
name|output_B3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|ecount
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|label_state
case|:
case|case
name|copy_state
case|:
name|output_B4_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_psprel
case|:
name|output_X1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|pspoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_sprel
case|:
name|output_X1_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|spoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_reg
case|:
name|output_X2_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
operator|>>
literal|1
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_psprel_p
case|:
name|output_X3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|pspoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_sprel_p
case|:
name|output_X3_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|type
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|spoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|spill_reg_p
case|:
name|output_X4_format
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|qp
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|ab
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
operator|>>
literal|1
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|xy
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|where
operator|.
name|reg
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"record_type_not_valid"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a unw_rec_list list, process all the records with    the specified function.  */
end_comment

begin_function
specifier|static
name|void
name|process_unw_records
parameter_list|(
name|list
parameter_list|,
name|f
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|vbyte_func
name|f
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|process_one_record
argument_list|(
name|ptr
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the size of a record list in bytes.  */
end_comment

begin_function
specifier|static
name|int
name|calc_record_size
parameter_list|(
name|list
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
block|{
name|vbyte_count
operator|=
literal|0
expr_stmt|;
name|process_unw_records
argument_list|(
name|list
argument_list|,
name|count_output
argument_list|)
expr_stmt|;
return|return
name|vbyte_count
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bits set in the input value.    Perhaps this has a better place...  */
end_comment

begin_if
if|#
directive|if
name|__GNUC__
operator|>
literal|3
operator|||
operator|(
name|__GNUC__
operator|==
literal|3
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|4
operator|)
end_if

begin_define
define|#
directive|define
name|popcount
value|__builtin_popcount
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|popcount
parameter_list|(
name|unsigned
name|x
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|popcnt
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|}
decl_stmt|;
if|if
condition|(
name|x
operator|<
name|NELEMS
argument_list|(
name|popcnt
argument_list|)
condition|)
return|return
name|popcnt
index|[
name|x
index|]
return|;
return|return
name|popcnt
index|[
name|x
operator|%
name|NELEMS
argument_list|(
name|popcnt
argument_list|)
index|]
operator|+
name|popcount
argument_list|(
name|x
operator|/
name|NELEMS
argument_list|(
name|popcnt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Update IMASK bitmask to reflect the fact that one or more registers    of type TYPE are saved starting at instruction with index T.  If N    bits are set in REGMASK, it is assumed that instructions T through    T+N-1 save these registers.     TYPE values: 	0: no save 	1: instruction saves next fp reg 	2: instruction saves next general reg 	3: instruction saves next branch reg */
end_comment

begin_function
specifier|static
name|void
name|set_imask
parameter_list|(
name|region
parameter_list|,
name|regmask
parameter_list|,
name|t
parameter_list|,
name|type
parameter_list|)
name|unw_rec_list
modifier|*
name|region
decl_stmt|;
name|unsigned
name|long
name|regmask
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|imask
decl_stmt|;
name|unsigned
name|long
name|imask_size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|imask
operator|=
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
expr_stmt|;
name|imask_size
operator|=
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|imask_size
expr_stmt|;
if|if
condition|(
operator|!
name|imask
condition|)
block|{
name|imask_size
operator|=
operator|(
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
operator|*
literal|2
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
literal|1
expr_stmt|;
name|imask
operator|=
name|xmalloc
argument_list|(
name|imask_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|imask
argument_list|,
literal|0
argument_list|,
name|imask_size
argument_list|)
expr_stmt|;
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|imask_size
operator|=
name|imask_size
expr_stmt|;
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|i
operator|=
name|imask
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|t
operator|/
literal|4
operator|)
operator|+
literal|1
expr_stmt|;
name|pos
operator|=
literal|2
operator|*
operator|(
literal|3
operator|-
name|t
operator|%
literal|4
operator|)
expr_stmt|;
while|while
condition|(
name|regmask
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|imask_size
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to spill beyond end of region"
argument_list|)
expr_stmt|;
return|return;
block|}
name|imask
index|[
name|i
index|]
operator||=
operator|(
name|type
operator|&
literal|0x3
operator|)
operator|<<
name|pos
expr_stmt|;
name|regmask
operator|&=
operator|(
name|regmask
operator|-
literal|1
operator|)
expr_stmt|;
name|pos
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the number of instruction slots from FIRST_ADDR to SLOT_ADDR.    SLOT_FRAG is the frag containing SLOT_ADDR, and FIRST_FRAG is the frag    containing FIRST_ADDR.  If BEFORE_RELAX, then we use worst-case estimates    for frag sizes.  */
end_comment

begin_function
name|unsigned
name|long
name|slot_index
parameter_list|(
name|slot_addr
parameter_list|,
name|slot_frag
parameter_list|,
name|first_addr
parameter_list|,
name|first_frag
parameter_list|,
name|before_relax
parameter_list|)
name|unsigned
name|long
name|slot_addr
decl_stmt|;
name|fragS
modifier|*
name|slot_frag
decl_stmt|;
name|unsigned
name|long
name|first_addr
decl_stmt|;
name|fragS
modifier|*
name|first_frag
decl_stmt|;
name|int
name|before_relax
decl_stmt|;
block|{
name|unsigned
name|long
name|index
init|=
literal|0
decl_stmt|;
comment|/* First time we are called, the initial address and frag are invalid.  */
if|if
condition|(
name|first_addr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the two addresses are in different frags, then we need to add in      the remaining size of this frag, and then the entire size of intermediate      frags.  */
while|while
condition|(
name|slot_frag
operator|!=
name|first_frag
condition|)
block|{
name|unsigned
name|long
name|start_addr
init|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|first_frag
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
operator|!
name|before_relax
condition|)
block|{
comment|/* We can get the final addresses only during and after 	     relaxation.  */
if|if
condition|(
name|first_frag
operator|->
name|fr_next
operator|&&
name|first_frag
operator|->
name|fr_next
operator|->
name|fr_address
condition|)
name|index
operator|+=
literal|3
operator|*
operator|(
operator|(
name|first_frag
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|first_frag
operator|->
name|fr_address
operator|-
name|first_frag
operator|->
name|fr_fix
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
else|else
comment|/* We don't know what the final addresses will be. We try our 	   best to estimate.  */
switch|switch
condition|(
name|first_frag
operator|->
name|fr_type
condition|)
block|{
default|default:
break|break;
case|case
name|rs_space
case|:
name|as_fatal
argument_list|(
literal|"only constant space allocation is supported"
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
comment|/* Take alignment into account.  Assume the worst case 	       before relaxation.  */
name|index
operator|+=
literal|3
operator|*
operator|(
operator|(
literal|1
operator|<<
name|first_frag
operator|->
name|fr_offset
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|rs_org
case|:
if|if
condition|(
name|first_frag
operator|->
name|fr_symbol
condition|)
block|{
name|as_fatal
argument_list|(
literal|"only constant offsets are supported"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|rs_fill
case|:
name|index
operator|+=
literal|3
operator|*
operator|(
name|first_frag
operator|->
name|fr_offset
operator|>>
literal|4
operator|)
expr_stmt|;
break|break;
block|}
comment|/* Add in the full size of the frag converted to instruction slots.  */
name|index
operator|+=
literal|3
operator|*
operator|(
name|first_frag
operator|->
name|fr_fix
operator|>>
literal|4
operator|)
expr_stmt|;
comment|/* Subtract away the initial part before first_addr.  */
name|index
operator|-=
operator|(
literal|3
operator|*
operator|(
operator|(
name|first_addr
operator|>>
literal|4
operator|)
operator|-
operator|(
name|start_addr
operator|>>
literal|4
operator|)
operator|)
operator|+
operator|(
operator|(
name|first_addr
operator|&
literal|0x3
operator|)
operator|-
operator|(
name|start_addr
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Move to the beginning of the next frag.  */
name|first_frag
operator|=
name|first_frag
operator|->
name|fr_next
expr_stmt|;
name|first_addr
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|first_frag
operator|->
name|fr_literal
expr_stmt|;
comment|/* This can happen if there is section switching in the middle of a 	 function, causing the frag chain for the function to be broken. 	 It is too difficult to recover safely from this problem, so we just 	 exit with an error.  */
if|if
condition|(
name|first_frag
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
literal|"Section switching in code is not supported."
argument_list|)
expr_stmt|;
block|}
comment|/* Add in the used part of the last frag.  */
name|index
operator|+=
operator|(
literal|3
operator|*
operator|(
operator|(
name|slot_addr
operator|>>
literal|4
operator|)
operator|-
operator|(
name|first_addr
operator|>>
literal|4
operator|)
operator|)
operator|+
operator|(
operator|(
name|slot_addr
operator|&
literal|0x3
operator|)
operator|-
operator|(
name|first_addr
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Optimize unwind record directives.  */
end_comment

begin_function
specifier|static
name|unw_rec_list
modifier|*
name|optimize_unw_records
parameter_list|(
name|list
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|NULL
return|;
comment|/* If the only unwind record is ".prologue" or ".prologue" followed      by ".body", then we can optimize the unwind directives away.  */
if|if
condition|(
name|list
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|&&
operator|(
name|list
operator|->
name|next
operator|->
name|r
operator|.
name|type
operator|==
name|endp
operator|||
operator|(
name|list
operator|->
name|next
operator|->
name|r
operator|.
name|type
operator|==
name|body
operator|&&
name|list
operator|->
name|next
operator|->
name|next
operator|->
name|r
operator|.
name|type
operator|==
name|endp
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Given a complete record list, process any records which have    unresolved fields, (ie length counts for a prologue).  After    this has been run, all necessary information should be available    within each record to generate an image.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_unw_records
parameter_list|(
name|list
parameter_list|,
name|before_relax
parameter_list|)
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|int
name|before_relax
decl_stmt|;
block|{
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|region
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|first_addr
init|=
literal|0
decl_stmt|,
name|rlen
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|;
name|fragS
modifier|*
name|first_frag
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|slot_number
operator|==
name|SLOT_NUM_NOT_SET
condition|)
name|as_bad
argument_list|(
literal|" Insn slot not set in unwind record."
argument_list|)
expr_stmt|;
name|t
operator|=
name|slot_index
argument_list|(
name|ptr
operator|->
name|slot_number
argument_list|,
name|ptr
operator|->
name|slot_frag
argument_list|,
name|first_addr
argument_list|,
name|first_frag
argument_list|,
name|before_relax
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
condition|)
block|{
case|case
name|prologue
case|:
case|case
name|prologue_gr
case|:
case|case
name|body
case|:
block|{
name|unw_rec_list
modifier|*
name|last
decl_stmt|;
name|int
name|size
decl_stmt|;
name|unsigned
name|long
name|last_addr
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|last_frag
init|=
name|NULL
decl_stmt|;
name|first_addr
operator|=
name|ptr
operator|->
name|slot_number
expr_stmt|;
name|first_frag
operator|=
name|ptr
operator|->
name|slot_frag
expr_stmt|;
comment|/* Find either the next body/prologue start, or the end of 	       the function, and determine the size of the region.  */
for|for
control|(
name|last
operator|=
name|ptr
operator|->
name|next
init|;
name|last
operator|!=
name|NULL
condition|;
name|last
operator|=
name|last
operator|->
name|next
control|)
if|if
condition|(
name|last
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|||
name|last
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
operator|||
name|last
operator|->
name|r
operator|.
name|type
operator|==
name|body
operator|||
name|last
operator|->
name|r
operator|.
name|type
operator|==
name|endp
condition|)
block|{
name|last_addr
operator|=
name|last
operator|->
name|slot_number
expr_stmt|;
name|last_frag
operator|=
name|last
operator|->
name|slot_frag
expr_stmt|;
break|break;
block|}
name|size
operator|=
name|slot_index
argument_list|(
name|last_addr
argument_list|,
name|last_frag
argument_list|,
name|first_addr
argument_list|,
name|first_frag
argument_list|,
name|before_relax
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|rlen
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|body
condition|)
comment|/* End of region.  */
name|region
operator|=
literal|0
expr_stmt|;
else|else
name|region
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
case|case
name|epilogue
case|:
if|if
condition|(
name|t
operator|<
name|rlen
condition|)
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|t
operator|=
name|rlen
operator|-
literal|1
operator|-
name|t
expr_stmt|;
else|else
comment|/* This happens when a memory-stack-less procedure uses a 	       ".restore sp" directive at the end of a region to pop 	       the frame state.  */
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|b
operator|.
name|t
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|mem_stack_f
case|:
case|case
name|mem_stack_v
case|:
case|case
name|rp_when
case|:
case|case
name|pfs_when
case|:
case|case
name|preds_when
case|:
case|case
name|unat_when
case|:
case|case
name|lc_when
case|:
case|case
name|fpsr_when
case|:
case|case
name|priunat_when_gr
case|:
case|case
name|priunat_when_mem
case|:
case|case
name|bsp_when
case|:
case|case
name|bspstore_when
case|:
case|case
name|rnat_when
case|:
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|t
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|spill_reg
case|:
case|case
name|spill_sprel
case|:
case|case
name|spill_psprel
case|:
case|case
name|spill_reg_p
case|:
case|case
name|spill_sprel_p
case|:
case|case
name|spill_psprel_p
case|:
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|x
operator|.
name|t
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|frgr_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"frgr_mem record before region record!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|fr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
expr_stmt|;
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|gr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|fr_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"fr_mem record before region record!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|fr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|frmask
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|gr_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"gr_mem record before region record!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|gr_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|br_mem
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"br_mem record before region record!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|->
name|r
operator|.
name|record
operator|.
name|r
operator|.
name|mask
operator|.
name|br_mem
operator||=
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
expr_stmt|;
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|gr_gr
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"gr_gr record before region record!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|grmask
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|br_gr
case|:
if|if
condition|(
operator|!
name|region
condition|)
block|{
name|as_bad
argument_list|(
literal|"br_gr record before region record!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_imask
argument_list|(
name|region
argument_list|,
name|ptr
operator|->
name|r
operator|.
name|record
operator|.
name|p
operator|.
name|brmask
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Estimate the size of a frag before relaxing.  We only have one type of frag    to handle here, which is the unwind info frag.  */
end_comment

begin_function
name|int
name|ia64_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|asection
modifier|*
name|segtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|int
name|len
decl_stmt|,
name|size
decl_stmt|,
name|pad
decl_stmt|;
comment|/* ??? This code is identical to the first part of ia64_convert_frag.  */
name|list
operator|=
operator|(
name|unw_rec_list
operator|*
operator|)
name|frag
operator|->
name|fr_opcode
expr_stmt|;
name|fixup_unw_records
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|calc_record_size
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* pad to pointer-size boundary.  */
name|pad
operator|=
name|len
operator|%
name|md
operator|.
name|pointer_size
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|len
operator|+=
name|md
operator|.
name|pointer_size
operator|-
name|pad
expr_stmt|;
comment|/* Add 8 for the header.  */
name|size
operator|=
name|len
operator|+
literal|8
expr_stmt|;
comment|/* Add a pointer for the personality offset.  */
if|if
condition|(
name|frag
operator|->
name|fr_offset
condition|)
name|size
operator|+=
name|md
operator|.
name|pointer_size
expr_stmt|;
comment|/* fr_var carries the max_chars that we created the fragment with.      We must, of course, have allocated enough memory earlier.  */
name|assert
argument_list|(
name|frag
operator|->
name|fr_var
operator|>=
name|size
argument_list|)
expr_stmt|;
return|return
name|frag
operator|->
name|fr_fix
operator|+
name|size
return|;
block|}
end_function

begin_comment
comment|/* This function converts a rs_machine_dependent variant frag into a   normal fill frag with the unwind image from the the record list.  */
end_comment

begin_function
name|void
name|ia64_convert_frag
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
name|int
name|len
decl_stmt|,
name|size
decl_stmt|,
name|pad
decl_stmt|;
name|valueT
name|flag_value
decl_stmt|;
comment|/* ??? This code is identical to ia64_estimate_size_before_relax.  */
name|list
operator|=
operator|(
name|unw_rec_list
operator|*
operator|)
name|frag
operator|->
name|fr_opcode
expr_stmt|;
name|fixup_unw_records
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|calc_record_size
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* pad to pointer-size boundary.  */
name|pad
operator|=
name|len
operator|%
name|md
operator|.
name|pointer_size
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|len
operator|+=
name|md
operator|.
name|pointer_size
operator|-
name|pad
expr_stmt|;
comment|/* Add 8 for the header.  */
name|size
operator|=
name|len
operator|+
literal|8
expr_stmt|;
comment|/* Add a pointer for the personality offset.  */
if|if
condition|(
name|frag
operator|->
name|fr_offset
condition|)
name|size
operator|+=
name|md
operator|.
name|pointer_size
expr_stmt|;
comment|/* fr_var carries the max_chars that we created the fragment with.      We must, of course, have allocated enough memory earlier.  */
name|assert
argument_list|(
name|frag
operator|->
name|fr_var
operator|>=
name|size
argument_list|)
expr_stmt|;
comment|/* Initialize the header area. fr_offset is initialized with      unwind.personality_routine.  */
if|if
condition|(
name|frag
operator|->
name|fr_offset
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|flag_value
operator|=
operator|(
name|bfd_vma
operator|)
literal|3
operator|<<
literal|32
expr_stmt|;
else|else
comment|/* 32-bit unwind info block.  */
name|flag_value
operator|=
operator|(
name|bfd_vma
operator|)
literal|0x1003
operator|<<
literal|32
expr_stmt|;
block|}
else|else
name|flag_value
operator|=
literal|0
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|frag
operator|->
name|fr_literal
argument_list|,
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|48
operator|)
comment|/* Version.  */
operator||
name|flag_value
comment|/* U& E handler flags.  */
operator||
operator|(
name|len
operator|/
name|md
operator|.
name|pointer_size
operator|)
operator|)
argument_list|,
comment|/* Length.  */
literal|8
argument_list|)
expr_stmt|;
comment|/* Skip the header.  */
name|vbyte_mem_ptr
operator|=
name|frag
operator|->
name|fr_literal
operator|+
literal|8
expr_stmt|;
name|process_unw_records
argument_list|(
name|list
argument_list|,
name|output_vbyte_mem
argument_list|)
expr_stmt|;
comment|/* Fill the padding bytes with zeros.  */
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|md_number_to_chars
argument_list|(
name|frag
operator|->
name|fr_literal
operator|+
name|len
operator|+
literal|8
operator|-
name|md
operator|.
name|pointer_size
operator|+
name|pad
argument_list|,
literal|0
argument_list|,
name|md
operator|.
name|pointer_size
operator|-
name|pad
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|+=
name|size
expr_stmt|;
name|frag
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|frag
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_predicate_and_operand
parameter_list|(
name|e
parameter_list|,
name|qp
parameter_list|,
name|po
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
name|unsigned
modifier|*
name|qp
decl_stmt|;
specifier|const
name|char
modifier|*
name|po
decl_stmt|;
block|{
name|int
name|sep
init|=
name|parse_operand
argument_list|(
name|e
argument_list|,
literal|','
argument_list|)
decl_stmt|;
operator|*
name|qp
operator|=
name|e
operator|->
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_register
operator|||
operator|*
name|qp
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .%s must be a predicate"
argument_list|,
name|po
argument_list|)
expr_stmt|;
operator|*
name|qp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|qp
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
literal|"Pointless use of p0 as first operand to .%s"
argument_list|,
name|po
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|sep
operator|=
name|parse_operand
argument_list|(
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
else|else
name|e
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
return|return
name|sep
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_expr_to_ab_reg
parameter_list|(
name|e
parameter_list|,
name|ab
parameter_list|,
name|regp
parameter_list|,
name|po
parameter_list|,
name|n
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
modifier|*
name|ab
decl_stmt|;
name|unsigned
name|int
modifier|*
name|regp
decl_stmt|;
specifier|const
name|char
modifier|*
name|po
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
init|=
name|e
operator|->
name|X_add_number
decl_stmt|;
operator|*
name|ab
operator|=
operator|*
name|regp
operator|=
literal|0
expr_stmt|;
comment|/* Anything valid is good here.  */
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_register
condition|)
name|reg
operator|=
name|REG_GR
expr_stmt|;
comment|/* Anything invalid is good here.  */
if|if
condition|(
name|reg
operator|>=
operator|(
name|REG_GR
operator|+
literal|4
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_GR
operator|+
literal|7
operator|)
condition|)
block|{
operator|*
name|ab
operator|=
literal|0
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_GR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|reg
operator|>=
operator|(
name|REG_FR
operator|+
literal|2
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_FR
operator|+
literal|5
operator|)
operator|)
operator|||
operator|(
name|reg
operator|>=
operator|(
name|REG_FR
operator|+
literal|16
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_FR
operator|+
literal|31
operator|)
operator|)
condition|)
block|{
operator|*
name|ab
operator|=
literal|1
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_FR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
operator|(
name|REG_BR
operator|+
literal|1
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_BR
operator|+
literal|5
operator|)
condition|)
block|{
operator|*
name|ab
operator|=
literal|2
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_BR
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ab
operator|=
literal|3
expr_stmt|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|REG_PR
case|:
operator|*
name|regp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REG_PSP
case|:
operator|*
name|regp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|REG_PRIUNAT
case|:
operator|*
name|regp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|REG_BR
operator|+
literal|0
case|:
operator|*
name|regp
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSP
case|:
operator|*
name|regp
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSPSTORE
case|:
operator|*
name|regp
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_RNAT
case|:
operator|*
name|regp
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_UNAT
case|:
operator|*
name|regp
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_FPSR
case|:
operator|*
name|regp
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_PFS
case|:
operator|*
name|regp
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_LC
case|:
operator|*
name|regp
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Operand %d to .%s must be a preserved register"
argument_list|,
name|n
argument_list|,
name|po
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|convert_expr_to_xy_reg
parameter_list|(
name|e
parameter_list|,
name|xy
parameter_list|,
name|regp
parameter_list|,
name|po
parameter_list|,
name|n
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
modifier|*
name|xy
decl_stmt|;
name|unsigned
name|int
modifier|*
name|regp
decl_stmt|;
specifier|const
name|char
modifier|*
name|po
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
init|=
name|e
operator|->
name|X_add_number
decl_stmt|;
operator|*
name|xy
operator|=
operator|*
name|regp
operator|=
literal|0
expr_stmt|;
comment|/* Anything valid is good here.  */
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_register
condition|)
name|reg
operator|=
name|REG_GR
expr_stmt|;
comment|/* Anything invalid is good here.  */
if|if
condition|(
name|reg
operator|>=
operator|(
name|REG_GR
operator|+
literal|1
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_GR
operator|+
literal|127
operator|)
condition|)
block|{
operator|*
name|xy
operator|=
literal|0
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_GR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
operator|(
name|REG_FR
operator|+
literal|2
operator|)
operator|&&
name|reg
operator|<=
operator|(
name|REG_FR
operator|+
literal|127
operator|)
condition|)
block|{
operator|*
name|xy
operator|=
literal|1
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_FR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
name|REG_BR
operator|&&
name|reg
operator|<=
operator|(
name|REG_BR
operator|+
literal|7
operator|)
condition|)
block|{
operator|*
name|xy
operator|=
literal|2
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|-
name|REG_BR
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Operand %d to .%s must be a writable register"
argument_list|,
name|n
argument_list|,
name|po
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_align
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* The current frag is an alignment frag.  */
name|align_frag
operator|=
name|frag_now
expr_stmt|;
name|s_align_bytes
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_radix
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|radix
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
return|return;
name|radix
operator|=
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|ia64_canonicalize_symbol_name
argument_list|(
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|radix
argument_list|,
literal|"C"
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"Radix `%s' unsupported or invalid"
argument_list|,
name|radix
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for .loc directives.  If the assembler is not generating    line number info, then we need to remember which instructions have a .loc    directive, and only call dwarf2_gen_line_info for those instructions.  */
end_comment

begin_function
specifier|static
name|void
name|dot_loc
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|CURR_SLOT
operator|.
name|loc_directive_seen
operator|=
literal|1
expr_stmt|;
name|dwarf2_directive_loc
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .sbss, .bss etc. are macros that expand into ".section SECNAME".  */
end_comment

begin_function
specifier|static
name|void
name|dot_special_section
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|set_section
argument_list|(
operator|(
name|char
operator|*
operator|)
name|special_section_name
index|[
name|which
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return -1 for warning and 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|unwind_diagnostic
parameter_list|(
specifier|const
name|char
modifier|*
name|region
parameter_list|,
specifier|const
name|char
modifier|*
name|directive
parameter_list|)
block|{
if|if
condition|(
name|md
operator|.
name|unwind_check
operator|==
name|unwind_check_warning
condition|)
block|{
name|as_warn
argument_list|(
literal|".%s outside of %s"
argument_list|,
name|directive
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|".%s outside of %s"
argument_list|,
name|directive
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if a directive is in a procedure, -1 if a directive isn't in    a procedure but the unwind directive check is set to warning, 0 if    a directive isn't in a procedure and the unwind directive check is set    to error.  */
end_comment

begin_function
specifier|static
name|int
name|in_procedure
parameter_list|(
specifier|const
name|char
modifier|*
name|directive
parameter_list|)
block|{
if|if
condition|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
operator|&&
operator|(
operator|!
name|unwind
operator|.
name|saved_text_seg
operator|||
name|strcmp
argument_list|(
name|directive
argument_list|,
literal|"endp"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
return|return
name|unwind_diagnostic
argument_list|(
literal|"procedure"
argument_list|,
name|directive
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if a directive is in a prologue, -1 if a directive isn't in    a prologue but the unwind directive check is set to warning, 0 if    a directive isn't in a prologue and the unwind directive check is set    to error.  */
end_comment

begin_function
specifier|static
name|int
name|in_prologue
parameter_list|(
specifier|const
name|char
modifier|*
name|directive
parameter_list|)
block|{
name|int
name|in
init|=
name|in_procedure
argument_list|(
name|directive
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|>
literal|0
operator|&&
operator|!
name|unwind
operator|.
name|prologue
condition|)
name|in
operator|=
name|unwind_diagnostic
argument_list|(
literal|"prologue"
argument_list|,
name|directive
argument_list|)
expr_stmt|;
name|check_pending_save
argument_list|()
expr_stmt|;
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if a directive is in a body, -1 if a directive isn't in    a body but the unwind directive check is set to warning, 0 if    a directive isn't in a body and the unwind directive check is set    to error.  */
end_comment

begin_function
specifier|static
name|int
name|in_body
parameter_list|(
specifier|const
name|char
modifier|*
name|directive
parameter_list|)
block|{
name|int
name|in
init|=
name|in_procedure
argument_list|(
name|directive
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|>
literal|0
operator|&&
operator|!
name|unwind
operator|.
name|body
condition|)
name|in
operator|=
name|unwind_diagnostic
argument_list|(
literal|"body region"
argument_list|,
name|directive
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_unwind_entry
parameter_list|(
name|ptr
parameter_list|,
name|sep
parameter_list|)
name|unw_rec_list
modifier|*
name|ptr
decl_stmt|;
name|int
name|sep
decl_stmt|;
block|{
if|if
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|unwind
operator|.
name|tail
condition|)
name|unwind
operator|.
name|tail
operator|->
name|next
operator|=
name|ptr
expr_stmt|;
else|else
name|unwind
operator|.
name|list
operator|=
name|ptr
expr_stmt|;
name|unwind
operator|.
name|tail
operator|=
name|ptr
expr_stmt|;
comment|/* The current entry can in fact be a chain of unwind entries.  */
if|if
condition|(
name|unwind
operator|.
name|current_entry
operator|==
name|NULL
condition|)
name|unwind
operator|.
name|current_entry
operator|=
name|ptr
expr_stmt|;
block|}
comment|/* The current entry can in fact be a chain of unwind entries.  */
if|if
condition|(
name|unwind
operator|.
name|current_entry
operator|==
name|NULL
condition|)
name|unwind
operator|.
name|current_entry
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
block|{
comment|/* Parse a tag permitted for the current directive.  */
name|int
name|ch
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* FIXME: For now, just issue a warning that this isn't implemented.  */
block|{
specifier|static
name|int
name|warned
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
literal|1
expr_stmt|;
name|as_warn
argument_list|(
literal|"Tags on unwind pseudo-ops aren't supported, yet"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|!=
name|NOT_A_CHAR
condition|)
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_fframe
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|int
name|sep
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"fframe"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .fframe must be a constant"
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_mem_stack_f
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_vframe
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|int
name|sep
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"vframe"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|reg
operator|>
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .vframe must be a general register"
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_mem_stack_v
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|2
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_psp_gr
argument_list|(
name|reg
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
name|unwind
operator|.
name|prologue_gr
operator|+
operator|(
name|unsigned
operator|)
name|popcount
argument_list|(
name|unwind
operator|.
name|prologue_mask
operator|&
operator|(
operator|-
literal|2
operator|<<
literal|1
operator|)
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Operand of .vframe contradicts .prologue"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_vframesp
parameter_list|(
name|psp
parameter_list|)
name|int
name|psp
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|int
name|sep
decl_stmt|;
if|if
condition|(
name|psp
condition|)
name|as_warn
argument_list|(
literal|".vframepsp is meaningless, assuming .vframesp was meant"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"vframesp"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Operand to .vframesp must be a constant (sp-relative offset)"
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_mem_stack_v
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_psp_sprel
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_save
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|unsigned
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|int
name|sep
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"save"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|,
literal|','
argument_list|)
expr_stmt|;
else|else
name|e2
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|reg1
operator|=
name|e1
operator|.
name|X_add_number
expr_stmt|;
comment|/* Make sure its a valid ar.xxx reg, OR its br0, aka 'rp'.  */
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .save not a register"
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|REG_PR
expr_stmt|;
comment|/* Anything valid is good here.  */
block|}
name|reg2
operator|=
name|e2
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|reg2
operator|>
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .save not a valid register"
argument_list|)
expr_stmt|;
name|reg2
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|reg1
condition|)
block|{
case|case
name|REG_AR
operator|+
name|AR_BSP
case|:
name|add_unwind_entry
argument_list|(
name|output_bsp_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_bsp_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSPSTORE
case|:
name|add_unwind_entry
argument_list|(
name|output_bspstore_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_bspstore_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_RNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_rnat_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_rnat_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_UNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_unat_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_unat_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_FPSR
case|:
name|add_unwind_entry
argument_list|(
name|output_fpsr_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_fpsr_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_PFS
case|:
name|add_unwind_entry
argument_list|(
name|output_pfs_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|4
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_pfs_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|!=
name|unwind
operator|.
name|prologue_gr
operator|+
operator|(
name|unsigned
operator|)
name|popcount
argument_list|(
name|unwind
operator|.
name|prologue_mask
operator|&
operator|(
operator|-
literal|4
operator|<<
literal|1
operator|)
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Second operand of .save contradicts .prologue"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_LC
case|:
name|add_unwind_entry
argument_list|(
name|output_lc_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_lc_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_BR
case|:
name|add_unwind_entry
argument_list|(
name|output_rp_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|8
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_rp_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|!=
name|unwind
operator|.
name|prologue_gr
condition|)
name|as_warn
argument_list|(
literal|"Second operand of .save contradicts .prologue"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PR
case|:
name|add_unwind_entry
argument_list|(
name|output_preds_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unwind
operator|.
name|prologue_mask
operator|&
literal|1
operator|)
condition|)
name|add_unwind_entry
argument_list|(
name|output_preds_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|!=
name|unwind
operator|.
name|prologue_gr
operator|+
operator|(
name|unsigned
operator|)
name|popcount
argument_list|(
name|unwind
operator|.
name|prologue_mask
operator|&
operator|(
operator|-
literal|1
operator|<<
literal|1
operator|)
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Second operand of .save contradicts .prologue"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PRIUNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_priunat_when_gr
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_priunat_gr
argument_list|(
name|reg2
argument_list|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"First operand to .save not a valid register"
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|NULL
argument_list|,
name|sep
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dot_restore
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|;
name|unsigned
name|long
name|ecount
decl_stmt|;
comment|/* # of _additional_ regions to pop */
name|int
name|sep
decl_stmt|;
if|if
condition|(
operator|!
name|in_body
argument_list|(
literal|"restore"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|e1
operator|.
name|X_add_number
operator|!=
name|REG_GR
operator|+
literal|12
condition|)
name|as_bad
argument_list|(
literal|"First operand to .restore must be stack pointer (sp)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
block|{
name|expressionS
name|e2
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e2
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .restore must be a constant>= 0"
argument_list|)
expr_stmt|;
name|e2
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|ecount
operator|=
name|e2
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
name|ecount
operator|=
name|unwind
operator|.
name|prologue_count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ecount
operator|>=
name|unwind
operator|.
name|prologue_count
condition|)
block|{
name|as_bad
argument_list|(
literal|"Epilogue count of %lu exceeds number of nested prologues (%u)"
argument_list|,
name|ecount
operator|+
literal|1
argument_list|,
name|unwind
operator|.
name|prologue_count
argument_list|)
expr_stmt|;
name|ecount
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_epilogue
argument_list|(
name|ecount
argument_list|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecount
operator|<
name|unwind
operator|.
name|prologue_count
condition|)
name|unwind
operator|.
name|prologue_count
operator|-=
name|ecount
operator|+
literal|1
expr_stmt|;
else|else
name|unwind
operator|.
name|prologue_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_restorereg
parameter_list|(
name|pred
parameter_list|)
name|int
name|pred
decl_stmt|;
block|{
name|unsigned
name|int
name|qp
decl_stmt|,
name|ab
decl_stmt|,
name|reg
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|int
name|sep
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|po
init|=
name|pred
condition|?
literal|"restorereg.p"
else|:
literal|"restorereg"
decl_stmt|;
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
name|po
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pred
condition|)
name|sep
operator|=
name|parse_predicate_and_operand
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|qp
argument_list|,
name|po
argument_list|)
expr_stmt|;
else|else
block|{
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|qp
operator|=
literal|0
expr_stmt|;
block|}
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|,
name|po
argument_list|,
literal|1
operator|+
name|pred
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_spill_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qp
argument_list|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|special_linkonce_name
index|[]
init|=
block|{
literal|".gnu.linkonce.ia64unw."
block|,
literal|".gnu.linkonce.ia64unwi."
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|start_unwind_section
parameter_list|(
specifier|const
name|segT
name|text_seg
parameter_list|,
name|int
name|sec_index
parameter_list|)
block|{
comment|/*     Use a slightly ugly scheme to derive the unwind section names from     the text section name:      text sect.  unwind table sect.     name:       name:                      comments:     ----------  -----------------          --------------------------------     .text       .IA_64.unwind     .text.foo   .IA_64.unwind.text.foo     .foo        .IA_64.unwind.foo     .gnu.linkonce.t.foo 		.gnu.linkonce.ia64unw.foo     _info       .IA_64.unwind_info         gas issues error message (ditto)     _infoFOO    .IA_64.unwind_infoFOO      gas issues error message (ditto)      This mapping is done so that:  	(a) An object file with unwind info only in .text will use 	    unwind section names .IA_64.unwind and .IA_64.unwind_info. 	    This follows the letter of the ABI and also ensures backwards 	    compatibility with older toolchains.  	(b) An object file with unwind info in multiple text sections 	    will use separate unwind sections for each text section. 	    This allows us to properly set the "sh_info" and "sh_link" 	    fields in SHT_IA_64_UNWIND as required by the ABI and also 	    lets GNU ld support programs with multiple segments 	    containing unwind info (as might be the case for certain 	    embedded applications).  	(c) An error is issued if there would be a name clash.   */
specifier|const
name|char
modifier|*
name|text_name
decl_stmt|,
modifier|*
name|sec_text_name
decl_stmt|;
name|char
modifier|*
name|sec_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
name|special_section_name
index|[
name|sec_index
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|size_t
name|prefix_len
decl_stmt|,
name|suffix_len
decl_stmt|,
name|sec_name_len
decl_stmt|;
name|sec_text_name
operator|=
name|segment_name
argument_list|(
name|text_seg
argument_list|)
expr_stmt|;
name|text_name
operator|=
name|sec_text_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|text_name
argument_list|,
literal|"_info"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Illegal section name `%s' (causes unwind section name clash)"
argument_list|,
name|text_name
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|text_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|text_name
operator|=
literal|""
expr_stmt|;
comment|/* Build the unwind section name by appending the (possibly stripped)      text section name to the unwind prefix.  */
name|suffix
operator|=
name|text_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|text_name
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce.t."
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prefix
operator|=
name|special_linkonce_name
index|[
name|sec_index
operator|-
name|SPECIAL_SECTION_UNWIND
index|]
expr_stmt|;
name|suffix
operator|+=
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce.t."
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|prefix_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|suffix_len
operator|=
name|strlen
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|sec_name_len
operator|=
name|prefix_len
operator|+
name|suffix_len
expr_stmt|;
name|sec_name
operator|=
name|alloca
argument_list|(
name|sec_name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sec_name
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sec_name
operator|+
name|prefix_len
argument_list|,
name|suffix
argument_list|,
name|suffix_len
argument_list|)
expr_stmt|;
name|sec_name
index|[
name|sec_name_len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Handle COMDAT group.  */
if|if
condition|(
operator|(
name|text_seg
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|elf_section_flags
argument_list|(
name|text_seg
argument_list|)
operator|&
name|SHF_GROUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|section
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|group_name_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|group_name
init|=
name|elf_group_name
argument_list|(
name|text_seg
argument_list|)
decl_stmt|;
if|if
condition|(
name|group_name
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Group section `%s' has no group signature"
argument_list|,
name|sec_text_name
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* We have to construct a fake section directive. */
name|group_name_len
operator|=
name|strlen
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|sec_name_len
operator|+
literal|16
comment|/* ,"aG",@progbits,  */
operator|+
name|group_name_len
comment|/* ,group_name  */
operator|+
literal|7
operator|)
expr_stmt|;
comment|/* ,comdat  */
name|section
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|section
argument_list|,
name|sec_name
argument_list|,
name|sec_name_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|section
operator|+
name|sec_name_len
argument_list|,
literal|",\"aG\",@progbits,"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|section
operator|+
name|sec_name_len
operator|+
literal|16
argument_list|,
name|group_name
argument_list|,
name|group_name_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|section
operator|+
name|len
operator|-
literal|7
argument_list|,
literal|",comdat"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|section
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|set_section
argument_list|(
name|section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_section
argument_list|(
name|sec_name
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|,
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
block|}
name|elf_linked_to_section
argument_list|(
name|now_seg
argument_list|)
operator|=
name|text_seg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_unwind_image
parameter_list|(
specifier|const
name|segT
name|text_seg
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|pad
decl_stmt|;
name|unw_rec_list
modifier|*
name|list
decl_stmt|;
comment|/* Mark the end of the unwind info, so that we can compute the size of the      last unwind region.  */
name|add_unwind_entry
argument_list|(
name|output_endp
argument_list|()
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
comment|/* Force out pending instructions, to make sure all unwind records have      a valid slot_number field.  */
name|ia64_flush_insns
argument_list|()
expr_stmt|;
comment|/* Generate the unwind record.  */
name|list
operator|=
name|optimize_unw_records
argument_list|(
name|unwind
operator|.
name|list
argument_list|)
expr_stmt|;
name|fixup_unw_records
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|calc_record_size
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|||
name|unwind
operator|.
name|force_unwind_entry
condition|)
block|{
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|0
expr_stmt|;
comment|/* pad to pointer-size boundary.  */
name|pad
operator|=
name|size
operator|%
name|md
operator|.
name|pointer_size
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|size
operator|+=
name|md
operator|.
name|pointer_size
operator|-
name|pad
expr_stmt|;
comment|/* Add 8 for the header.  */
name|size
operator|+=
literal|8
expr_stmt|;
comment|/* Add a pointer for the personality offset.  */
if|if
condition|(
name|unwind
operator|.
name|personality_routine
condition|)
name|size
operator|+=
name|md
operator|.
name|pointer_size
expr_stmt|;
block|}
comment|/* If there are unwind records, switch sections, and output the info.  */
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|start_unwind_section
argument_list|(
name|text_seg
argument_list|,
name|SPECIAL_SECTION_UNWIND_INFO
argument_list|)
expr_stmt|;
comment|/* Make sure the section has 4 byte alignment for ILP32 and 	 8 byte alignment for LP64.  */
name|frag_align
argument_list|(
name|md
operator|.
name|pointer_size_shift
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|md
operator|.
name|pointer_size_shift
argument_list|)
expr_stmt|;
comment|/* Set expression which points to start of unwind descriptor area.  */
name|unwind
operator|.
name|info
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
operator|(
name|long
operator|)
name|unwind
operator|.
name|personality_routine
argument_list|,
operator|(
name|char
operator|*
operator|)
name|list
argument_list|)
expr_stmt|;
comment|/* Add the personality address to the image.  */
if|if
condition|(
name|unwind
operator|.
name|personality_routine
operator|!=
literal|0
condition|)
block|{
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|unwind
operator|.
name|personality_routine
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_BE
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64MSB
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR32MSB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64LSB
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR32LSB
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
name|md
operator|.
name|pointer_size
argument_list|,
name|md
operator|.
name|pointer_size
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free_saved_prologue_counts
argument_list|()
expr_stmt|;
name|unwind
operator|.
name|list
operator|=
name|unwind
operator|.
name|tail
operator|=
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_handlerdata
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
literal|"handlerdata"
argument_list|)
condition|)
return|return;
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|1
expr_stmt|;
comment|/* Remember which segment we're in so we can switch back after .endp */
name|unwind
operator|.
name|saved_text_seg
operator|=
name|now_seg
expr_stmt|;
name|unwind
operator|.
name|saved_text_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Generate unwind info into unwind-info section and then leave that      section as the currently active one so dataXX directives go into      the language specific data area of the unwind info block.  */
name|generate_unwind_image
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_unwentry
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
literal|"unwentry"
argument_list|)
condition|)
return|return;
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_altrp
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"altrp"
argument_list|)
condition|)
return|return;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e
operator|.
name|X_add_number
operator|-
name|REG_BR
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|reg
operator|>
literal|7
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .altrp not a valid branch register"
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_rp_br
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_savemem
parameter_list|(
name|psprel
parameter_list|)
name|int
name|psprel
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|int
name|reg1
decl_stmt|,
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|po
init|=
name|psprel
condition|?
literal|"savepsp"
else|:
literal|"savesp"
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
name|po
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|,
literal|','
argument_list|)
expr_stmt|;
else|else
name|e2
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|reg1
operator|=
name|e1
operator|.
name|X_add_number
expr_stmt|;
name|val
operator|=
name|e2
operator|.
name|X_add_number
expr_stmt|;
comment|/* Make sure its a valid ar.xxx reg, OR its br0, aka 'rp'.  */
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .%s not a register"
argument_list|,
name|po
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|REG_PR
expr_stmt|;
comment|/* Anything valid is good here.  */
block|}
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .%s not a constant"
argument_list|,
name|po
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|reg1
condition|)
block|{
case|case
name|REG_AR
operator|+
name|AR_BSP
case|:
name|add_unwind_entry
argument_list|(
name|output_bsp_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_bsp_psprel
else|:
name|output_bsp_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_BSPSTORE
case|:
name|add_unwind_entry
argument_list|(
name|output_bspstore_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_bspstore_psprel
else|:
name|output_bspstore_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_RNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_rnat_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_rnat_psprel
else|:
name|output_rnat_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_UNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_unat_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_unat_psprel
else|:
name|output_unat_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_FPSR
case|:
name|add_unwind_entry
argument_list|(
name|output_fpsr_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_fpsr_psprel
else|:
name|output_fpsr_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_PFS
case|:
name|add_unwind_entry
argument_list|(
name|output_pfs_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_pfs_psprel
else|:
name|output_pfs_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AR
operator|+
name|AR_LC
case|:
name|add_unwind_entry
argument_list|(
name|output_lc_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_lc_psprel
else|:
name|output_lc_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_BR
case|:
name|add_unwind_entry
argument_list|(
name|output_rp_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_rp_psprel
else|:
name|output_rp_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PR
case|:
name|add_unwind_entry
argument_list|(
name|output_preds_when
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_preds_psprel
else|:
name|output_preds_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_PRIUNAT
case|:
name|add_unwind_entry
argument_list|(
name|output_priunat_when_mem
argument_list|()
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
operator|(
name|psprel
condition|?
name|output_priunat_psprel
else|:
name|output_priunat_sprel
operator|)
operator|(
name|val
operator|)
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"First operand to .%s not a valid register"
argument_list|,
name|po
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|NULL
argument_list|,
name|sep
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dot_saveg
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|grmask
decl_stmt|;
name|int
name|sep
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"save.g"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|grmask
operator|=
name|e
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e
operator|.
name|X_add_number
operator|<=
literal|0
operator|||
name|e
operator|.
name|X_add_number
operator|>
literal|0xf
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .save.g must be a positive 4-bit constant"
argument_list|)
expr_stmt|;
name|grmask
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
block|{
name|unsigned
name|reg
decl_stmt|;
name|int
name|n
init|=
name|popcount
argument_list|(
name|grmask
argument_list|)
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|reg
operator|>
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .save.g must be a general register"
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>
literal|128U
operator|-
name|n
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .save.g must be the first of %d general registers"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_gr_gr
argument_list|(
name|grmask
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|add_unwind_entry
argument_list|(
name|output_gr_mem
argument_list|(
name|grmask
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_savef
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"save.f"
argument_list|)
condition|)
return|return;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e
operator|.
name|X_add_number
operator|<=
literal|0
operator|||
name|e
operator|.
name|X_add_number
operator|>
literal|0xfffff
condition|)
block|{
name|as_bad
argument_list|(
literal|"Operand to .save.f must be a positive 20-bit constant"
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_fr_mem
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_saveb
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|unsigned
name|brmask
decl_stmt|;
name|int
name|sep
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"save.b"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|brmask
operator|=
name|e
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e
operator|.
name|X_add_number
operator|<=
literal|0
operator|||
name|e
operator|.
name|X_add_number
operator|>
literal|0x1f
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .save.b must be a positive 5-bit constant"
argument_list|)
expr_stmt|;
name|brmask
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
block|{
name|unsigned
name|reg
decl_stmt|;
name|int
name|n
init|=
name|popcount
argument_list|(
name|brmask
argument_list|)
decl_stmt|;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|reg
operator|>
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .save.b must be a general register"
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>
literal|128U
operator|-
name|n
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .save.b must be the first of %d general registers"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_br_gr
argument_list|(
name|brmask
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|add_unwind_entry
argument_list|(
name|output_br_mem
argument_list|(
name|brmask
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_savegf
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"save.gf"
argument_list|)
condition|)
return|return;
if|if
condition|(
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|,
literal|','
argument_list|)
operator|==
literal|','
condition|)
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|e2
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e1
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|e1
operator|.
name|X_add_number
operator|>
literal|0xf
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .save.gf must be a non-negative 4-bit constant"
argument_list|)
expr_stmt|;
name|e1
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|e1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e2
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|e2
operator|.
name|X_add_number
operator|>
literal|0xfffff
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .save.gf must be a non-negative 20-bit constant"
argument_list|)
expr_stmt|;
name|e2
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|e2
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|e1
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|e2
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|e1
operator|.
name|X_add_number
operator|==
literal|0
operator|&&
name|e2
operator|.
name|X_add_number
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Operands to .save.gf may not be both zero"
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_frgr_mem
argument_list|(
name|e1
operator|.
name|X_add_number
argument_list|,
name|e2
operator|.
name|X_add_number
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spill
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"spill"
argument_list|)
condition|)
return|return;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Operand to .spill must be a constant"
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_spill_base
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spillreg
parameter_list|(
name|pred
parameter_list|)
name|int
name|pred
decl_stmt|;
block|{
name|int
name|sep
decl_stmt|;
name|unsigned
name|int
name|qp
decl_stmt|,
name|ab
decl_stmt|,
name|xy
decl_stmt|,
name|reg
decl_stmt|,
name|treg
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|po
init|=
name|pred
condition|?
literal|"spillreg.p"
else|:
literal|"spillreg"
decl_stmt|;
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
name|po
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pred
condition|)
name|sep
operator|=
name|parse_predicate_and_operand
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|qp
argument_list|,
name|po
argument_list|)
expr_stmt|;
else|else
block|{
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|qp
operator|=
literal|0
expr_stmt|;
block|}
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|,
name|po
argument_list|,
literal|1
operator|+
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
else|else
name|e
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|convert_expr_to_xy_reg
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|xy
argument_list|,
operator|&
name|treg
argument_list|,
name|po
argument_list|,
literal|2
operator|+
name|pred
argument_list|)
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_spill_reg
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|treg
argument_list|,
name|xy
argument_list|,
name|qp
argument_list|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_spillmem
parameter_list|(
name|psprel
parameter_list|)
name|int
name|psprel
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|int
name|pred
init|=
operator|(
name|psprel
operator|<
literal|0
operator|)
decl_stmt|,
name|sep
decl_stmt|;
name|unsigned
name|int
name|qp
decl_stmt|,
name|ab
decl_stmt|,
name|reg
decl_stmt|;
specifier|const
name|char
modifier|*
name|po
decl_stmt|;
if|if
condition|(
name|pred
condition|)
block|{
name|psprel
operator|=
operator|~
name|psprel
expr_stmt|;
name|po
operator|=
name|psprel
condition|?
literal|"spillpsp.p"
else|:
literal|"spillsp.p"
expr_stmt|;
block|}
else|else
name|po
operator|=
name|psprel
condition|?
literal|"spillpsp"
else|:
literal|"spillsp"
expr_stmt|;
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
name|po
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pred
condition|)
name|sep
operator|=
name|parse_predicate_and_operand
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|qp
argument_list|,
name|po
argument_list|)
expr_stmt|;
else|else
block|{
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|qp
operator|=
literal|0
expr_stmt|;
block|}
name|convert_expr_to_ab_reg
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|reg
argument_list|,
name|po
argument_list|,
literal|1
operator|+
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
expr_stmt|;
else|else
name|e
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Operand %d to .%s must be a constant"
argument_list|,
literal|2
operator|+
name|pred
argument_list|,
name|po
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|psprel
condition|)
name|add_unwind_entry
argument_list|(
name|output_spill_psprel
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|e
operator|.
name|X_add_number
argument_list|,
name|qp
argument_list|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
else|else
name|add_unwind_entry
argument_list|(
name|output_spill_sprel
argument_list|(
name|ab
argument_list|,
name|reg
argument_list|,
name|e
operator|.
name|X_add_number
argument_list|,
name|qp
argument_list|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|get_saved_prologue_count
parameter_list|(
name|lbl
parameter_list|)
name|unsigned
name|long
name|lbl
decl_stmt|;
block|{
name|label_prologue_count
modifier|*
name|lpc
init|=
name|unwind
operator|.
name|saved_prologue_counts
decl_stmt|;
while|while
condition|(
name|lpc
operator|!=
name|NULL
operator|&&
name|lpc
operator|->
name|label_number
operator|!=
name|lbl
condition|)
name|lpc
operator|=
name|lpc
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lpc
operator|!=
name|NULL
condition|)
return|return
name|lpc
operator|->
name|prologue_count
return|;
name|as_bad
argument_list|(
literal|"Missing .label_state %ld"
argument_list|,
name|lbl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_prologue_count
parameter_list|(
name|lbl
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|long
name|lbl
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
name|label_prologue_count
modifier|*
name|lpc
init|=
name|unwind
operator|.
name|saved_prologue_counts
decl_stmt|;
while|while
condition|(
name|lpc
operator|!=
name|NULL
operator|&&
name|lpc
operator|->
name|label_number
operator|!=
name|lbl
condition|)
name|lpc
operator|=
name|lpc
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lpc
operator|!=
name|NULL
condition|)
name|lpc
operator|->
name|prologue_count
operator|=
name|count
expr_stmt|;
else|else
block|{
name|label_prologue_count
modifier|*
name|new_lpc
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_lpc
argument_list|)
argument_list|)
decl_stmt|;
name|new_lpc
operator|->
name|next
operator|=
name|unwind
operator|.
name|saved_prologue_counts
expr_stmt|;
name|new_lpc
operator|->
name|label_number
operator|=
name|lbl
expr_stmt|;
name|new_lpc
operator|->
name|prologue_count
operator|=
name|count
expr_stmt|;
name|unwind
operator|.
name|saved_prologue_counts
operator|=
name|new_lpc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_saved_prologue_counts
parameter_list|()
block|{
name|label_prologue_count
modifier|*
name|lpc
init|=
name|unwind
operator|.
name|saved_prologue_counts
decl_stmt|;
name|label_prologue_count
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|lpc
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|lpc
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|lpc
argument_list|)
expr_stmt|;
name|lpc
operator|=
name|next
expr_stmt|;
block|}
name|unwind
operator|.
name|saved_prologue_counts
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_label_state
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|in_body
argument_list|(
literal|"label_state"
argument_list|)
condition|)
return|return;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|save_prologue_count
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|,
name|unwind
operator|.
name|prologue_count
argument_list|)
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"Operand to .label_state must be a constant"
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_label_state
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_copy_state
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|in_body
argument_list|(
literal|"copy_state"
argument_list|)
condition|)
return|return;
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|unwind
operator|.
name|prologue_count
operator|=
name|get_saved_prologue_count
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"Operand to .copy_state must be a constant"
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_copy_state
argument_list|(
name|e
operator|.
name|X_add_number
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_unwabi
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|unsigned
name|char
name|sep
decl_stmt|;
if|if
condition|(
operator|!
name|in_prologue
argument_list|(
literal|"unwabi"
argument_list|)
condition|)
return|return;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|e1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|parse_operand
argument_list|(
operator|&
name|e2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|e2
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"First operand to .unwabi must be a constant"
argument_list|)
expr_stmt|;
name|e1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|e2
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .unwabi must be a constant"
argument_list|)
expr_stmt|;
name|e2
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|add_unwind_entry
argument_list|(
name|output_unwabi
argument_list|(
name|e1
operator|.
name|X_add_number
argument_list|,
name|e2
operator|.
name|X_add_number
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_personality
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
literal|"personality"
argument_list|)
condition|)
return|return;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|force_unwind_entry
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_proc
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|proc_pending
modifier|*
name|pending
decl_stmt|,
modifier|*
name|last_pending
decl_stmt|;
if|if
condition|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
condition|)
block|{
operator|(
name|md
operator|.
name|unwind_check
operator|==
name|unwind_check_warning
condition|?
name|as_warn
else|:
name|as_bad
operator|)
operator|(
literal|"Missing .endp after previous .proc"
operator|)
expr_stmt|;
while|while
condition|(
name|unwind
operator|.
name|proc_pending
operator|.
name|next
condition|)
block|{
name|pending
operator|=
name|unwind
operator|.
name|proc_pending
operator|.
name|next
expr_stmt|;
name|unwind
operator|.
name|proc_pending
operator|.
name|next
operator|=
name|pending
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pending
argument_list|)
expr_stmt|;
block|}
block|}
name|last_pending
operator|=
name|NULL
expr_stmt|;
comment|/* Parse names of main and alternate entry points and mark them as      function symbols:  */
while|while
condition|(
literal|1
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
name|as_bad
argument_list|(
literal|"Empty argument of .proc"
argument_list|)
expr_stmt|;
else|else
block|{
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"`%s' was already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|last_pending
condition|)
block|{
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
operator|=
name|sym
expr_stmt|;
name|last_pending
operator|=
operator|&
name|unwind
operator|.
name|proc_pending
expr_stmt|;
block|}
else|else
block|{
name|pending
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pending
argument_list|)
argument_list|)
expr_stmt|;
name|pending
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|last_pending
operator|=
name|last_pending
operator|->
name|next
operator|=
name|pending
expr_stmt|;
block|}
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|last_pending
condition|)
block|{
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
name|last_pending
operator|=
operator|&
name|unwind
operator|.
name|proc_pending
expr_stmt|;
block|}
name|last_pending
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|ia64_do_align
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|prologue
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|prologue_count
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|body
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|insn
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|list
operator|=
name|unwind
operator|.
name|tail
operator|=
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_body
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
literal|"body"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|unwind
operator|.
name|prologue
operator|&&
operator|!
name|unwind
operator|.
name|body
operator|&&
name|unwind
operator|.
name|insn
condition|)
name|as_warn
argument_list|(
literal|"Initial .body should precede any instructions"
argument_list|)
expr_stmt|;
name|check_pending_save
argument_list|()
expr_stmt|;
name|unwind
operator|.
name|prologue
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|prologue_mask
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|body
operator|=
literal|1
expr_stmt|;
name|add_unwind_entry
argument_list|(
name|output_body
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_prologue
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|mask
init|=
literal|0
decl_stmt|,
name|grsave
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
literal|"prologue"
argument_list|)
condition|)
return|return;
if|if
condition|(
name|unwind
operator|.
name|prologue
condition|)
block|{
name|as_bad
argument_list|(
literal|".prologue within prologue"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unwind
operator|.
name|body
operator|&&
name|unwind
operator|.
name|insn
condition|)
name|as_warn
argument_list|(
literal|"Initial .prologue should precede any instructions"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|expressionS
name|e
decl_stmt|;
name|int
name|n
decl_stmt|,
name|sep
init|=
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|e
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|e
operator|.
name|X_add_number
operator|>
literal|0xf
condition|)
name|as_bad
argument_list|(
literal|"First operand to .prologue must be a positive 4-bit constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|.
name|X_add_number
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
literal|"Pointless use of zero first operand to .prologue"
argument_list|)
expr_stmt|;
else|else
name|mask
operator|=
name|e
operator|.
name|X_add_number
expr_stmt|;
name|n
operator|=
name|popcount
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|','
condition|)
name|parse_operand
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|e
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|e
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|e
operator|.
name|X_add_number
operator|<
literal|128
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|unwind_check
operator|==
name|unwind_check_error
condition|)
name|as_warn
argument_list|(
literal|"Using a constant as second operand to .prologue is deprecated"
argument_list|)
expr_stmt|;
name|grsave
operator|=
name|e
operator|.
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_register
operator|||
operator|(
name|grsave
operator|=
name|e
operator|.
name|X_add_number
operator|-
name|REG_GR
operator|)
operator|>
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .prologue must be a general register"
argument_list|)
expr_stmt|;
name|grsave
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|grsave
operator|>
literal|128U
operator|-
name|n
condition|)
block|{
name|as_bad
argument_list|(
literal|"Second operand to .prologue must be the first of %d general registers"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|grsave
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
condition|)
name|add_unwind_entry
argument_list|(
name|output_prologue_gr
argument_list|(
name|mask
argument_list|,
name|grsave
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|add_unwind_entry
argument_list|(
name|output_prologue
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|prologue
operator|=
literal|1
expr_stmt|;
name|unwind
operator|.
name|prologue_mask
operator|=
name|mask
expr_stmt|;
name|unwind
operator|.
name|prologue_gr
operator|=
name|grsave
expr_stmt|;
name|unwind
operator|.
name|body
operator|=
literal|0
expr_stmt|;
operator|++
name|unwind
operator|.
name|prologue_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_endp
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|int
name|bytes_per_address
decl_stmt|;
name|long
name|where
decl_stmt|;
name|segT
name|saved_seg
decl_stmt|;
name|subsegT
name|saved_subseg
decl_stmt|;
name|proc_pending
modifier|*
name|pending
decl_stmt|;
name|int
name|unwind_check
init|=
name|md
operator|.
name|unwind_check
decl_stmt|;
name|md
operator|.
name|unwind_check
operator|=
name|unwind_check_error
expr_stmt|;
if|if
condition|(
operator|!
name|in_procedure
argument_list|(
literal|"endp"
argument_list|)
condition|)
return|return;
name|md
operator|.
name|unwind_check
operator|=
name|unwind_check
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|saved_text_seg
condition|)
block|{
name|saved_seg
operator|=
name|unwind
operator|.
name|saved_text_seg
expr_stmt|;
name|saved_subseg
operator|=
name|unwind
operator|.
name|saved_text_subseg
expr_stmt|;
name|unwind
operator|.
name|saved_text_seg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
block|}
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there wasn't a .handlerdata, we haven't generated an image yet.  */
if|if
condition|(
operator|!
name|unwind
operator|.
name|info
condition|)
name|generate_unwind_image
argument_list|(
name|saved_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|info
operator|||
name|unwind
operator|.
name|force_unwind_entry
condition|)
block|{
name|symbolS
modifier|*
name|proc_end
decl_stmt|;
name|subseg_set
argument_list|(
name|md
operator|.
name|last_text_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proc_end
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
name|start_unwind_section
argument_list|(
name|saved_seg
argument_list|,
name|SPECIAL_SECTION_UNWIND
argument_list|)
expr_stmt|;
comment|/* Make sure that section has 4 byte alignment for ILP32 and          8 byte alignment for LP64.  */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|md
operator|.
name|pointer_size_shift
argument_list|)
expr_stmt|;
comment|/* Need space for 3 pointers for procedure start, procedure end, 	 and unwind info.  */
name|memset
argument_list|(
name|frag_more
argument_list|(
literal|3
operator|*
name|md
operator|.
name|pointer_size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
name|md
operator|.
name|pointer_size
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag_now_fix
argument_list|()
operator|-
operator|(
literal|3
operator|*
name|md
operator|.
name|pointer_size
operator|)
expr_stmt|;
name|bytes_per_address
operator|=
name|bfd_arch_bits_per_address
argument_list|(
name|stdoutput
argument_list|)
operator|/
literal|8
expr_stmt|;
comment|/* Issue the values of  a) Proc Begin, b) Proc End, c) Unwind Record.  */
name|e
operator|.
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_LOCAL
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
condition|)
name|e
operator|.
name|X_add_symbol
operator|=
name|symbol_temp_new
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
argument_list|,
name|symbol_get_frag
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|e
operator|.
name|X_add_symbol
operator|=
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
expr_stmt|;
name|ia64_cons_fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|bytes_per_address
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|proc_end
expr_stmt|;
name|ia64_cons_fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
name|bytes_per_address
argument_list|,
name|bytes_per_address
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|info
condition|)
block|{
name|e
operator|.
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|.
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|unwind
operator|.
name|info
expr_stmt|;
name|ia64_cons_fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
operator|(
name|bytes_per_address
operator|*
literal|2
operator|)
argument_list|,
name|bytes_per_address
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
comment|/* Set symbol sizes.  */
name|pending
operator|=
operator|&
name|unwind
operator|.
name|proc_pending
expr_stmt|;
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|pending
operator|->
name|sym
argument_list|)
condition|)
block|{
do|do
block|{
name|symbolS
modifier|*
name|sym
init|=
name|pending
operator|->
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"`%s' was not defined within procedure"
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_SIZE
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
operator|&&
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|==
name|NULL
condition|)
block|{
name|fragS
modifier|*
name|frag
init|=
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|frag
condition|)
block|{
if|if
condition|(
name|frag
operator|==
name|frag_now
operator|&&
name|SEG_NORMAL
argument_list|(
name|now_seg
argument_list|)
condition|)
name|S_SET_SIZE
argument_list|(
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|=
operator|(
name|expressionS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_add_symbol
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_op_symbol
operator|=
name|sym
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
operator|(
name|pending
operator|=
name|pending
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
comment|/* Parse names of main and alternate entry points.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
operator|(
name|md
operator|.
name|unwind_check
operator|==
name|unwind_check_warning
condition|?
name|as_warn
else|:
name|as_bad
operator|)
operator|(
literal|"Empty argument of .endp"
operator|)
expr_stmt|;
else|else
block|{
name|symbolS
modifier|*
name|sym
init|=
name|symbol_find
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|pending
operator|=
operator|&
name|unwind
operator|.
name|proc_pending
init|;
name|pending
condition|;
name|pending
operator|=
name|pending
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sym
operator|==
name|pending
operator|->
name|sym
condition|)
block|{
name|pending
operator|->
name|sym
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|sym
operator|||
operator|!
name|pending
condition|)
name|as_warn
argument_list|(
literal|"`%s' was not specified with previous .proc"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Deliberately only checking for the main entry point here; the      language spec even says all arguments to .endp are ignored.  */
if|if
condition|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
operator|&&
name|S_GET_NAME
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"`%s' should be an operand to this .endp"
argument_list|,
name|S_GET_NAME
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|unwind
operator|.
name|proc_pending
operator|.
name|next
condition|)
block|{
name|pending
operator|=
name|unwind
operator|.
name|proc_pending
operator|.
name|next
expr_stmt|;
name|unwind
operator|.
name|proc_pending
operator|.
name|next
operator|=
name|pending
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pending
argument_list|)
expr_stmt|;
block|}
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
operator|=
name|unwind
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_template
parameter_list|(
name|template
parameter_list|)
name|int
name|template
decl_stmt|;
block|{
name|CURR_SLOT
operator|.
name|user_template
operator|=
name|template
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_regstk
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|ins
decl_stmt|,
name|locs
decl_stmt|,
name|outs
decl_stmt|,
name|rots
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
name|ins
operator|=
name|locs
operator|=
name|outs
operator|=
name|rots
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|ins
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|err
goto|;
name|locs
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|err
goto|;
name|outs
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|err
goto|;
name|rots
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
name|set_regstack
argument_list|(
name|ins
argument_list|,
name|locs
argument_list|,
name|outs
argument_list|,
name|rots
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|as_bad
argument_list|(
literal|"Comma expected"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_rot
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|offsetT
name|num_regs
decl_stmt|;
name|valueT
name|num_alloced
init|=
literal|0
decl_stmt|;
name|struct
name|dynreg
modifier|*
modifier|*
name|drpp
decl_stmt|,
modifier|*
name|dr
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|base_reg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DYNREG_GR
case|:
name|base_reg
operator|=
name|REG_GR
operator|+
literal|32
expr_stmt|;
break|break;
case|case
name|DYNREG_FR
case|:
name|base_reg
operator|=
name|REG_FR
operator|+
literal|32
expr_stmt|;
break|break;
case|case
name|DYNREG_PR
case|:
name|base_reg
operator|=
name|REG_P
operator|+
literal|16
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* First, remove existing names from hash table.  */
for|for
control|(
name|dr
operator|=
name|md
operator|.
name|dynreg
index|[
name|type
index|]
init|;
name|dr
operator|&&
name|dr
operator|->
name|num_regs
condition|;
name|dr
operator|=
name|dr
operator|->
name|next
control|)
block|{
name|hash_delete
argument_list|(
name|md
operator|.
name|dynreg_hash
argument_list|,
name|dr
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* FIXME: Free dr->name.  */
name|dr
operator|->
name|num_regs
operator|=
literal|0
expr_stmt|;
block|}
name|drpp
operator|=
operator|&
name|md
operator|.
name|dynreg
index|[
name|type
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|start
operator|=
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ia64_canonicalize_symbol_name
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'['
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected '['"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* skip '[' */
name|num_regs
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected ']'"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|num_regs
operator|<=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Number of elements must be positive"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|num_alloced
operator|+=
name|num_regs
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DYNREG_GR
case|:
if|if
condition|(
name|num_alloced
operator|>
name|md
operator|.
name|rot
operator|.
name|num_regs
condition|)
block|{
name|as_bad
argument_list|(
literal|"Used more than the declared %d rotating registers"
argument_list|,
name|md
operator|.
name|rot
operator|.
name|num_regs
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|DYNREG_FR
case|:
if|if
condition|(
name|num_alloced
operator|>
literal|96
condition|)
block|{
name|as_bad
argument_list|(
literal|"Used more than the available 96 rotating registers"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|DYNREG_PR
case|:
if|if
condition|(
name|num_alloced
operator|>
literal|48
condition|)
block|{
name|as_bad
argument_list|(
literal|"Used more than the available 48 rotating registers"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|drpp
condition|)
block|{
operator|*
name|drpp
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|drpp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dr
operator|=
operator|*
name|drpp
expr_stmt|;
name|dr
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|dr
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
name|dr
operator|->
name|base
operator|=
name|base_reg
expr_stmt|;
name|drpp
operator|=
operator|&
name|dr
operator|->
name|next
expr_stmt|;
name|base_reg
operator|+=
name|num_regs
expr_stmt|;
if|if
condition|(
name|hash_insert
argument_list|(
name|md
operator|.
name|dynreg_hash
argument_list|,
name|name
argument_list|,
name|dr
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Attempt to redefine register set `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* skip comma */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
name|err
label|:
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_byteorder
parameter_list|(
name|byteorder
parameter_list|)
name|int
name|byteorder
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
if|if
condition|(
name|byteorder
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|endian
operator|==
literal|0
condition|)
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|endian
operator|=
name|default_big_endian
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|byteorder
operator|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|endian
operator|==
literal|1
expr_stmt|;
block|}
else|else
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|endian
operator|=
name|byteorder
condition|?
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|target_big_endian
operator|!=
name|byteorder
condition|)
block|{
name|target_big_endian
operator|=
name|byteorder
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
name|ia64_number_to_chars
operator|=
name|number_to_chars_bigendian
expr_stmt|;
name|ia64_float_to_chars
operator|=
name|ia64_float_to_chars_bigendian
expr_stmt|;
block|}
else|else
block|{
name|ia64_number_to_chars
operator|=
name|number_to_chars_littleendian
expr_stmt|;
name|ia64_float_to_chars
operator|=
name|ia64_float_to_chars_littleendian
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dot_psr
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|option
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|option
operator|=
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"lsb"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_BE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"msb"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_BE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"abi32"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_ABI64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"abi64"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_ABI64
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Unknown psr option `%s'"
argument_list|,
name|option
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_ln
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|new_logical_line
argument_list|(
literal|0
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|cross_section
parameter_list|(
name|ref
parameter_list|,
name|cons
parameter_list|,
name|ua
parameter_list|)
name|int
name|ref
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*cons
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ua
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|saved_auto_align
decl_stmt|;
name|unsigned
name|int
name|section_count
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|start
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'"'
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|input_line_pointer
operator|==
name|start
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing section name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
name|end
operator|=
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Comma expected after section name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|end
operator|=
name|input_line_pointer
operator|+
literal|1
expr_stmt|;
comment|/* skip comma */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
name|md
operator|.
name|keep_pending_output
operator|=
literal|1
expr_stmt|;
name|section_count
operator|=
name|bfd_count_sections
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|obj_elf_section
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_count
operator|!=
name|bfd_count_sections
argument_list|(
name|stdoutput
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Creating sections with .xdataN/.xrealN/.xstringZ is deprecated."
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|end
expr_stmt|;
name|saved_auto_align
operator|=
name|md
operator|.
name|auto_align
expr_stmt|;
if|if
condition|(
name|ua
condition|)
name|md
operator|.
name|auto_align
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|cons
call|)
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ua
condition|)
name|md
operator|.
name|auto_align
operator|=
name|saved_auto_align
expr_stmt|;
name|obj_elf_previous
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|keep_pending_output
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|dot_xdata
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|cross_section
argument_list|(
name|size
argument_list|,
name|cons
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Why doesn't float_cons() call md_cons_align() the way cons() does?  */
end_comment

begin_function
specifier|static
name|void
name|stmt_float_cons
parameter_list|(
name|kind
parameter_list|)
name|int
name|kind
decl_stmt|;
block|{
name|size_t
name|alignment
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'d'
case|:
name|alignment
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|alignment
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
default|default:
name|alignment
operator|=
literal|4
expr_stmt|;
break|break;
block|}
name|ia64_do_align
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|float_cons
argument_list|(
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stmt_cons_ua
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|saved_auto_align
init|=
name|md
operator|.
name|auto_align
decl_stmt|;
name|md
operator|.
name|auto_align
operator|=
literal|0
expr_stmt|;
name|cons
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md
operator|.
name|auto_align
operator|=
name|saved_auto_align
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xfloat_cons
parameter_list|(
name|kind
parameter_list|)
name|int
name|kind
decl_stmt|;
block|{
name|cross_section
argument_list|(
name|kind
argument_list|,
name|stmt_float_cons
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xstringer
parameter_list|(
name|zero
parameter_list|)
name|int
name|zero
decl_stmt|;
block|{
name|cross_section
argument_list|(
name|zero
argument_list|,
name|stringer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xdata_ua
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|cross_section
argument_list|(
name|size
argument_list|,
name|cons
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_xfloat_cons_ua
parameter_list|(
name|kind
parameter_list|)
name|int
name|kind
decl_stmt|;
block|{
name|cross_section
argument_list|(
name|kind
argument_list|,
name|float_cons
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .reg.val<regname>,value */
end_comment

begin_function
specifier|static
name|void
name|dot_reg_val
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|reg
decl_stmt|;
name|expression_and_evaluate
argument_list|(
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register name expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Comma expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|valueT
name|value
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|int
name|regno
init|=
name|reg
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|regno
operator|<=
name|REG_GR
operator|||
name|regno
operator|>
name|REG_GR
operator|+
literal|127
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Register value annotation ignored"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gr_values
index|[
name|regno
operator|-
name|REG_GR
index|]
operator|.
name|known
operator|=
literal|1
expr_stmt|;
name|gr_values
index|[
name|regno
operator|-
name|REG_GR
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|gr_values
index|[
name|regno
operator|-
name|REG_GR
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   .serialize.data   .serialize.instruction  */
end_comment

begin_function
specifier|static
name|void
name|dot_serialize
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|insn_group_break
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|instruction_serialization
argument_list|()
expr_stmt|;
else|else
name|data_serialization
argument_list|()
expr_stmt|;
name|insn_group_break
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* select dv checking mode    .auto    .explicit    .default     A stop is inserted when changing modes  */
end_comment

begin_function
specifier|static
name|void
name|dot_dv_mode
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|manual_bundling
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Directive invalid within a bundle"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'E'
operator|||
name|type
operator|==
literal|'A'
condition|)
name|md
operator|.
name|mode_explicitly_set
operator|=
literal|0
expr_stmt|;
else|else
name|md
operator|.
name|mode_explicitly_set
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|detect_dv
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|md
operator|.
name|explicit_mode
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|md
operator|.
name|explicit_mode
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
case|case
literal|'d'
case|:
if|if
condition|(
name|md
operator|.
name|explicit_mode
operator|!=
name|md
operator|.
name|default_explicit_mode
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
name|md
operator|.
name|default_explicit_mode
expr_stmt|;
name|md
operator|.
name|mode_explicitly_set
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_prmask
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|comma
init|=
literal|""
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|64
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s p%d"
argument_list|,
name|comma
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   .pred.rel.clear [p1 [,p2 [,...]]]     (also .pred.rel "clear" or @clear)   .pred.rel.imply p1, p2                (also .pred.rel "imply" or @imply)   .pred.rel.mutex p1, p2 [,...]         (also .pred.rel "mutex" or @mutex)   .pred.safe_across_calls p1 [, p2 [,...]]  */
end_comment

begin_function
specifier|static
name|void
name|dot_pred_rel
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|p1
init|=
operator|-
literal|1
decl_stmt|,
name|p2
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|form
init|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"mutex"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'m'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"clear"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'c'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"imply"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'i'
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|notes
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'@'
condition|)
block|{
name|char
modifier|*
name|form
init|=
operator|++
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"mutex"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'m'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"clear"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'c'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|form
argument_list|,
literal|"imply"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
literal|'i'
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing predicate relation type"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized predicate relation type"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|valueT
name|bits
init|=
literal|1
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|expressionS
name|pr
decl_stmt|,
modifier|*
name|pr1
decl_stmt|,
modifier|*
name|pr2
decl_stmt|;
name|expression_and_evaluate
argument_list|(
operator|&
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|pr
operator|.
name|X_add_number
operator|>=
name|REG_P
operator|&&
name|pr
operator|.
name|X_add_number
operator|<=
name|REG_P
operator|+
literal|63
condition|)
block|{
name|regno
operator|=
name|pr
operator|.
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
name|bits
operator|<<=
name|regno
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|==
operator|-
literal|1
condition|)
name|p1
operator|=
name|regno
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|==
operator|-
literal|1
condition|)
name|p2
operator|=
name|regno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
literal|'i'
operator|&&
name|pr
operator|.
name|X_op
operator|==
name|O_subtract
operator|&&
operator|(
name|pr1
operator|=
name|symbol_get_value_expression
argument_list|(
name|pr
operator|.
name|X_add_symbol
argument_list|)
operator|)
operator|&&
name|pr1
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|pr1
operator|->
name|X_add_number
operator|>=
name|REG_P
operator|&&
name|pr1
operator|->
name|X_add_number
operator|<=
name|REG_P
operator|+
literal|63
operator|&&
operator|(
name|pr2
operator|=
name|symbol_get_value_expression
argument_list|(
name|pr
operator|.
name|X_op_symbol
argument_list|)
operator|)
operator|&&
name|pr2
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|pr2
operator|->
name|X_add_number
operator|>=
name|REG_P
operator|&&
name|pr2
operator|->
name|X_add_number
operator|<=
name|REG_P
operator|+
literal|63
condition|)
block|{
comment|/* It's a range.  */
name|int
name|stop
decl_stmt|;
name|regno
operator|=
name|pr1
operator|->
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
name|stop
operator|=
name|pr2
operator|->
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|stop
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad register range"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|bits
operator|=
operator|(
operator|(
name|bits
operator|<<
name|stop
operator|)
operator|<<
literal|1
operator|)
operator|-
operator|(
name|bits
operator|<<
name|regno
operator|)
expr_stmt|;
name|count
operator|+=
name|stop
operator|-
name|regno
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Predicate register expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mask
operator|&
name|bits
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Duplicate predicate register ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator||=
name|bits
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|mask
operator|=
operator|~
operator|(
name|valueT
operator|)
literal|0
expr_stmt|;
name|clear_qp_mutex
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|mask
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|count
operator|!=
literal|2
operator|||
name|p1
operator|==
operator|-
literal|1
operator|||
name|p2
operator|==
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Predicate source and target required"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p2
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Use of p0 is not valid in this context"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_qp_imply
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"At least two PR arguments expected"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Use of p0 is not valid in this context"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|add_qp_mutex
argument_list|(
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* note that we don't override any existing relations */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"At least one PR argument expected"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Safe across calls: "
argument_list|)
expr_stmt|;
name|print_prmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|qp_safe_across_calls
operator|=
name|mask
expr_stmt|;
break|break;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .entry label [, label [, ...]]    Hint to DV code that the given labels are to be considered entry points.    Otherwise, only global labels are considered entry points.  */
end_comment

begin_function
specifier|static
name|void
name|dot_entry
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|entry_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Inserting \"%s\" into entry hint table failed: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .mem.offset offset, base    "base" is used to distinguish between offsets from a different base.  */
end_comment

begin_function
specifier|static
name|void
name|dot_mem_offset
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|mem_offset
operator|.
name|offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Comma expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|md
operator|.
name|mem_offset
operator|.
name|base
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ia64-specific pseudo-ops:  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"radix"
block|,
name|dot_radix
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_lcomm_bytes
block|,
literal|1
block|}
block|,
block|{
literal|"loc"
block|,
name|dot_loc
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_BSS
block|}
block|,
block|{
literal|"sbss"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_SBSS
block|}
block|,
block|{
literal|"sdata"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_SDATA
block|}
block|,
block|{
literal|"rodata"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_RODATA
block|}
block|,
block|{
literal|"comment"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_COMMENT
block|}
block|,
block|{
literal|"ia_64.unwind"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_UNWIND
block|}
block|,
block|{
literal|"ia_64.unwind_info"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_UNWIND_INFO
block|}
block|,
block|{
literal|"init_array"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_INIT_ARRAY
block|}
block|,
block|{
literal|"fini_array"
block|,
name|dot_special_section
block|,
name|SPECIAL_SECTION_FINI_ARRAY
block|}
block|,
block|{
literal|"proc"
block|,
name|dot_proc
block|,
literal|0
block|}
block|,
block|{
literal|"body"
block|,
name|dot_body
block|,
literal|0
block|}
block|,
block|{
literal|"prologue"
block|,
name|dot_prologue
block|,
literal|0
block|}
block|,
block|{
literal|"endp"
block|,
name|dot_endp
block|,
literal|0
block|}
block|,
block|{
literal|"fframe"
block|,
name|dot_fframe
block|,
literal|0
block|}
block|,
block|{
literal|"vframe"
block|,
name|dot_vframe
block|,
literal|0
block|}
block|,
block|{
literal|"vframesp"
block|,
name|dot_vframesp
block|,
literal|0
block|}
block|,
block|{
literal|"vframepsp"
block|,
name|dot_vframesp
block|,
literal|1
block|}
block|,
block|{
literal|"save"
block|,
name|dot_save
block|,
literal|0
block|}
block|,
block|{
literal|"restore"
block|,
name|dot_restore
block|,
literal|0
block|}
block|,
block|{
literal|"restorereg"
block|,
name|dot_restorereg
block|,
literal|0
block|}
block|,
block|{
literal|"restorereg.p"
block|,
name|dot_restorereg
block|,
literal|1
block|}
block|,
block|{
literal|"handlerdata"
block|,
name|dot_handlerdata
block|,
literal|0
block|}
block|,
block|{
literal|"unwentry"
block|,
name|dot_unwentry
block|,
literal|0
block|}
block|,
block|{
literal|"altrp"
block|,
name|dot_altrp
block|,
literal|0
block|}
block|,
block|{
literal|"savesp"
block|,
name|dot_savemem
block|,
literal|0
block|}
block|,
block|{
literal|"savepsp"
block|,
name|dot_savemem
block|,
literal|1
block|}
block|,
block|{
literal|"save.g"
block|,
name|dot_saveg
block|,
literal|0
block|}
block|,
block|{
literal|"save.f"
block|,
name|dot_savef
block|,
literal|0
block|}
block|,
block|{
literal|"save.b"
block|,
name|dot_saveb
block|,
literal|0
block|}
block|,
block|{
literal|"save.gf"
block|,
name|dot_savegf
block|,
literal|0
block|}
block|,
block|{
literal|"spill"
block|,
name|dot_spill
block|,
literal|0
block|}
block|,
block|{
literal|"spillreg"
block|,
name|dot_spillreg
block|,
literal|0
block|}
block|,
block|{
literal|"spillsp"
block|,
name|dot_spillmem
block|,
literal|0
block|}
block|,
block|{
literal|"spillpsp"
block|,
name|dot_spillmem
block|,
literal|1
block|}
block|,
block|{
literal|"spillreg.p"
block|,
name|dot_spillreg
block|,
literal|1
block|}
block|,
block|{
literal|"spillsp.p"
block|,
name|dot_spillmem
block|,
operator|~
literal|0
block|}
block|,
block|{
literal|"spillpsp.p"
block|,
name|dot_spillmem
block|,
operator|~
literal|1
block|}
block|,
block|{
literal|"label_state"
block|,
name|dot_label_state
block|,
literal|0
block|}
block|,
block|{
literal|"copy_state"
block|,
name|dot_copy_state
block|,
literal|0
block|}
block|,
block|{
literal|"unwabi"
block|,
name|dot_unwabi
block|,
literal|0
block|}
block|,
block|{
literal|"personality"
block|,
name|dot_personality
block|,
literal|0
block|}
block|,
block|{
literal|"mii"
block|,
name|dot_template
block|,
literal|0x0
block|}
block|,
block|{
literal|"mli"
block|,
name|dot_template
block|,
literal|0x2
block|}
block|,
comment|/* old format, for compatibility */
block|{
literal|"mlx"
block|,
name|dot_template
block|,
literal|0x2
block|}
block|,
block|{
literal|"mmi"
block|,
name|dot_template
block|,
literal|0x4
block|}
block|,
block|{
literal|"mfi"
block|,
name|dot_template
block|,
literal|0x6
block|}
block|,
block|{
literal|"mmf"
block|,
name|dot_template
block|,
literal|0x7
block|}
block|,
block|{
literal|"mib"
block|,
name|dot_template
block|,
literal|0x8
block|}
block|,
block|{
literal|"mbb"
block|,
name|dot_template
block|,
literal|0x9
block|}
block|,
block|{
literal|"bbb"
block|,
name|dot_template
block|,
literal|0xb
block|}
block|,
block|{
literal|"mmb"
block|,
name|dot_template
block|,
literal|0xc
block|}
block|,
block|{
literal|"mfb"
block|,
name|dot_template
block|,
literal|0xe
block|}
block|,
block|{
literal|"align"
block|,
name|dot_align
block|,
literal|0
block|}
block|,
block|{
literal|"regstk"
block|,
name|dot_regstk
block|,
literal|0
block|}
block|,
block|{
literal|"rotr"
block|,
name|dot_rot
block|,
name|DYNREG_GR
block|}
block|,
block|{
literal|"rotf"
block|,
name|dot_rot
block|,
name|DYNREG_FR
block|}
block|,
block|{
literal|"rotp"
block|,
name|dot_rot
block|,
name|DYNREG_PR
block|}
block|,
block|{
literal|"lsb"
block|,
name|dot_byteorder
block|,
literal|0
block|}
block|,
block|{
literal|"msb"
block|,
name|dot_byteorder
block|,
literal|1
block|}
block|,
block|{
literal|"psr"
block|,
name|dot_psr
block|,
literal|0
block|}
block|,
block|{
literal|"alias"
block|,
name|dot_alias
block|,
literal|0
block|}
block|,
block|{
literal|"secalias"
block|,
name|dot_alias
block|,
literal|1
block|}
block|,
block|{
literal|"ln"
block|,
name|dot_ln
block|,
literal|0
block|}
block|,
comment|/* source line info (for debugging) */
block|{
literal|"xdata1"
block|,
name|dot_xdata
block|,
literal|1
block|}
block|,
block|{
literal|"xdata2"
block|,
name|dot_xdata
block|,
literal|2
block|}
block|,
block|{
literal|"xdata4"
block|,
name|dot_xdata
block|,
literal|4
block|}
block|,
block|{
literal|"xdata8"
block|,
name|dot_xdata
block|,
literal|8
block|}
block|,
block|{
literal|"xdata16"
block|,
name|dot_xdata
block|,
literal|16
block|}
block|,
block|{
literal|"xreal4"
block|,
name|dot_xfloat_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"xreal8"
block|,
name|dot_xfloat_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"xreal10"
block|,
name|dot_xfloat_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"xreal16"
block|,
name|dot_xfloat_cons
block|,
literal|'X'
block|}
block|,
block|{
literal|"xstring"
block|,
name|dot_xstringer
block|,
literal|0
block|}
block|,
block|{
literal|"xstringz"
block|,
name|dot_xstringer
block|,
literal|1
block|}
block|,
comment|/* unaligned versions:  */
block|{
literal|"xdata2.ua"
block|,
name|dot_xdata_ua
block|,
literal|2
block|}
block|,
block|{
literal|"xdata4.ua"
block|,
name|dot_xdata_ua
block|,
literal|4
block|}
block|,
block|{
literal|"xdata8.ua"
block|,
name|dot_xdata_ua
block|,
literal|8
block|}
block|,
block|{
literal|"xdata16.ua"
block|,
name|dot_xdata_ua
block|,
literal|16
block|}
block|,
block|{
literal|"xreal4.ua"
block|,
name|dot_xfloat_cons_ua
block|,
literal|'f'
block|}
block|,
block|{
literal|"xreal8.ua"
block|,
name|dot_xfloat_cons_ua
block|,
literal|'d'
block|}
block|,
block|{
literal|"xreal10.ua"
block|,
name|dot_xfloat_cons_ua
block|,
literal|'x'
block|}
block|,
block|{
literal|"xreal16.ua"
block|,
name|dot_xfloat_cons_ua
block|,
literal|'X'
block|}
block|,
comment|/* annotations/DV checking support */
block|{
literal|"entry"
block|,
name|dot_entry
block|,
literal|0
block|}
block|,
block|{
literal|"mem.offset"
block|,
name|dot_mem_offset
block|,
literal|0
block|}
block|,
block|{
literal|"pred.rel"
block|,
name|dot_pred_rel
block|,
literal|0
block|}
block|,
block|{
literal|"pred.rel.clear"
block|,
name|dot_pred_rel
block|,
literal|'c'
block|}
block|,
block|{
literal|"pred.rel.imply"
block|,
name|dot_pred_rel
block|,
literal|'i'
block|}
block|,
block|{
literal|"pred.rel.mutex"
block|,
name|dot_pred_rel
block|,
literal|'m'
block|}
block|,
block|{
literal|"pred.safe_across_calls"
block|,
name|dot_pred_rel
block|,
literal|'s'
block|}
block|,
block|{
literal|"reg.val"
block|,
name|dot_reg_val
block|,
literal|0
block|}
block|,
block|{
literal|"serialize.data"
block|,
name|dot_serialize
block|,
literal|0
block|}
block|,
block|{
literal|"serialize.instruction"
block|,
name|dot_serialize
block|,
literal|1
block|}
block|,
block|{
literal|"auto"
block|,
name|dot_dv_mode
block|,
literal|'a'
block|}
block|,
block|{
literal|"explicit"
block|,
name|dot_dv_mode
block|,
literal|'e'
block|}
block|,
block|{
literal|"default"
block|,
name|dot_dv_mode
block|,
literal|'d'
block|}
block|,
comment|/* ??? These are needed to make gas/testsuite/gas/elf/ehopt.s work.        IA-64 aligns data allocation pseudo-ops by default, so we have to        tell it that these ones are supposed to be unaligned.  Long term,        should rewrite so that only IA-64 specific data allocation pseudo-ops        are aligned by default.  */
block|{
literal|"2byte"
block|,
name|stmt_cons_ua
block|,
literal|2
block|}
block|,
block|{
literal|"4byte"
block|,
name|stmt_cons_ua
block|,
literal|4
block|}
block|,
block|{
literal|"8byte"
block|,
name|stmt_cons_ua
block|,
literal|8
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|pseudo_opcode
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|arg
decl_stmt|;
block|}
name|pseudo_opcode
index|[]
init|=
block|{
comment|/* these are more like pseudo-ops, but don't start with a dot */
block|{
literal|"data1"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"data2"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"data4"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"data8"
block|,
name|cons
block|,
literal|8
block|}
block|,
block|{
literal|"data16"
block|,
name|cons
block|,
literal|16
block|}
block|,
block|{
literal|"real4"
block|,
name|stmt_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"real8"
block|,
name|stmt_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"real10"
block|,
name|stmt_float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"real16"
block|,
name|stmt_float_cons
block|,
literal|'X'
block|}
block|,
block|{
literal|"string"
block|,
name|stringer
block|,
literal|0
block|}
block|,
block|{
literal|"stringz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
comment|/* unaligned versions:  */
block|{
literal|"data2.ua"
block|,
name|stmt_cons_ua
block|,
literal|2
block|}
block|,
block|{
literal|"data4.ua"
block|,
name|stmt_cons_ua
block|,
literal|4
block|}
block|,
block|{
literal|"data8.ua"
block|,
name|stmt_cons_ua
block|,
literal|8
block|}
block|,
block|{
literal|"data16.ua"
block|,
name|stmt_cons_ua
block|,
literal|16
block|}
block|,
block|{
literal|"real4.ua"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"real8.ua"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"real10.ua"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"real16.ua"
block|,
name|float_cons
block|,
literal|'X'
block|}
block|,   }
struct|;
end_struct

begin_comment
comment|/* Declare a register by creating a symbol for it and entering it in    the symbol table.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|declare_register
parameter_list|(
name|name
parameter_list|,
name|regnum
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|regnum
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_create
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|reg_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into register table failed: %s"
argument_list|,
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_register_set
parameter_list|(
name|prefix
parameter_list|,
name|num_regs
parameter_list|,
name|base_regnum
parameter_list|)
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|unsigned
name|int
name|num_regs
decl_stmt|;
name|unsigned
name|int
name|base_regnum
decl_stmt|;
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs
condition|;
operator|++
name|i
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s%u"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
name|name
argument_list|,
name|base_regnum
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|operand_width
parameter_list|(
name|opnd
parameter_list|)
name|enum
name|ia64_opnd
name|opnd
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_operand
modifier|*
name|odesc
init|=
operator|&
name|elf64_ia64_operands
index|[
name|opnd
index|]
decl_stmt|;
name|unsigned
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|odesc
operator|->
name|field
argument_list|)
operator|&&
name|odesc
operator|->
name|field
index|[
name|i
index|]
operator|.
name|bits
condition|;
operator|++
name|i
control|)
name|bits
operator|+=
name|odesc
operator|->
name|field
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|operand_match_result
name|operand_match
parameter_list|(
name|idesc
parameter_list|,
name|index
parameter_list|,
name|e
parameter_list|)
specifier|const
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|index
decl_stmt|;
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|enum
name|ia64_opnd
name|opnd
init|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
decl_stmt|;
name|int
name|bits
decl_stmt|,
name|relocatable
init|=
literal|0
decl_stmt|;
name|struct
name|insn_fix
modifier|*
name|fix
decl_stmt|;
name|bfd_signed_vma
name|val
decl_stmt|;
switch|switch
condition|(
name|opnd
condition|)
block|{
comment|/* constants:  */
case|case
name|IA64_OPND_AR_CCV
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_AR
operator|+
literal|32
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_AR_CSD
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_AR
operator|+
literal|25
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_AR_PFS
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_AR
operator|+
literal|64
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_GR0
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_GR
operator|+
literal|0
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_IP
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_IP
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PR
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PR
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PR_ROT
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PR_ROT
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PSR
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PSR
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PSR_L
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PSR_L
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_PSR_UM
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|REG_PSR_UM
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_C1
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|1
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_C8
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|8
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_C16
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|16
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
comment|/* register operands:  */
case|case
name|IA64_OPND_AR3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_AR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_AR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_B1
case|:
case|case
name|IA64_OPND_B2
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_BR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_BR
operator|+
literal|8
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_CR3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_CR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_CR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_F1
case|:
case|case
name|IA64_OPND_F2
case|:
case|case
name|IA64_OPND_F3
case|:
case|case
name|IA64_OPND_F4
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_FR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_FR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_P1
case|:
case|case
name|IA64_OPND_P2
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_P
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_P
operator|+
literal|64
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_R1
case|:
case|case
name|IA64_OPND_R2
case|:
case|case
name|IA64_OPND_R3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_GR
operator|&&
name|e
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|+
literal|128
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_R3_2
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|e
operator|->
name|X_add_number
operator|>=
name|REG_GR
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|+
literal|4
condition|)
return|return
name|OPERAND_MATCH
return|;
elseif|else
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|+
literal|128
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
comment|/* indirect operands:  */
case|case
name|IA64_OPND_CPUID_R3
case|:
case|case
name|IA64_OPND_DBR_R3
case|:
case|case
name|IA64_OPND_DTR_R3
case|:
case|case
name|IA64_OPND_ITR_R3
case|:
case|case
name|IA64_OPND_IBR_R3
case|:
case|case
name|IA64_OPND_MSR_R3
case|:
case|case
name|IA64_OPND_PKR_R3
case|:
case|case
name|IA64_OPND_PMC_R3
case|:
case|case
name|IA64_OPND_PMD_R3
case|:
case|case
name|IA64_OPND_RR_R3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_index
operator|&&
name|e
operator|->
name|X_op_symbol
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
operator|-
name|IND_CPUID
operator|==
name|opnd
operator|-
name|IA64_OPND_CPUID_R3
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_MR3
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_index
operator|&&
operator|!
name|e
operator|->
name|X_op_symbol
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
comment|/* immediate operands:  */
case|case
name|IA64_OPND_CNT2a
case|:
case|case
name|IA64_OPND_LEN4
case|:
case|case
name|IA64_OPND_LEN6
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|e
operator|->
name|X_add_number
operator|-
literal|1
argument_list|)
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|bits
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_CNT2b
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|e
operator|->
name|X_add_number
operator|-
literal|1
argument_list|)
operator|<
literal|3
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_CNT2c
case|:
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|||
name|val
operator|==
literal|7
operator|||
name|val
operator|==
literal|15
operator|||
name|val
operator|==
literal|16
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_SOR
case|:
comment|/* SOR must be an integer multiple of 8 */
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|e
operator|->
name|X_add_number
operator|&
literal|0x7
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
case|case
name|IA64_OPND_SOF
case|:
case|case
name|IA64_OPND_SOL
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<=
literal|96
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMMU62
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|62
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
else|else
block|{
comment|/* FIXME -- need 62-bit relocation type */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"62-bit relocation not yet implemented"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IA64_OPND_IMMU64
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_subtract
condition|)
block|{
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_IMM64
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_subtract
condition|)
block|{
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
condition|)
name|e
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|0
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
return|return
name|OPERAND_MATCH
return|;
break|break;
case|case
name|IA64_OPND_IMMU5b
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|32
operator|&&
name|val
operator|<=
literal|63
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_CCNT5
case|:
case|case
name|IA64_OPND_CNT5
case|:
case|case
name|IA64_OPND_CNT6
case|:
case|case
name|IA64_OPND_CPOS6a
case|:
case|case
name|IA64_OPND_CPOS6b
case|:
case|case
name|IA64_OPND_CPOS6c
case|:
case|case
name|IA64_OPND_IMMU2
case|:
case|case
name|IA64_OPND_IMMU7a
case|:
case|case
name|IA64_OPND_IMMU7b
case|:
case|case
name|IA64_OPND_IMMU21
case|:
case|case
name|IA64_OPND_IMMU24
case|:
case|case
name|IA64_OPND_MBTYPE4
case|:
case|case
name|IA64_OPND_MHTYPE8
case|:
case|case
name|IA64_OPND_POS6
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|bits
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMMU9
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|bits
operator|)
condition|)
block|{
name|int
name|lobits
init|=
name|e
operator|->
name|X_add_number
operator|&
literal|0x3
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|&
literal|0x3C
operator|)
operator|!=
literal|0
operator|&&
name|lobits
operator|==
literal|0
condition|)
name|e
operator|->
name|X_add_number
operator||=
operator|(
name|bfd_vma
operator|)
literal|0x3
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMM44
case|:
comment|/* least 16 bits must be zero */
if|if
condition|(
operator|(
name|e
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX technically, this is wrong: we should not be issuing warning 	   messages until we're sure this instruction pattern is going to 	   be used! */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"lower 16 bits of mask ignored"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|44
operator|)
operator|)
operator|||
operator|(
name|e
operator|->
name|X_add_number
operator|<
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
operator|-
name|e
operator|->
name|X_add_number
operator|<=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|44
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* sign-extend */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|e
operator|->
name|X_add_number
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|43
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|e
operator|->
name|X_add_number
operator||=
operator|~
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|44
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|OPERAND_MATCH
return|;
block|}
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMM17
case|:
comment|/* bit 0 is a don't care (pr0 is hardwired to 1) */
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|e
operator|->
name|X_add_number
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|||
operator|(
name|e
operator|->
name|X_add_number
operator|<
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
operator|-
name|e
operator|->
name|X_add_number
operator|<=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|17
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* sign-extend */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|e
operator|->
name|X_add_number
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|e
operator|->
name|X_add_number
operator||=
operator|~
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|17
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|OPERAND_MATCH
return|;
block|}
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_IMM14
case|:
case|case
name|IA64_OPND_IMM22
case|:
name|relocatable
operator|=
literal|1
expr_stmt|;
case|case
name|IA64_OPND_IMM1
case|:
case|case
name|IA64_OPND_IMM8
case|:
case|case
name|IA64_OPND_IMM8U4
case|:
case|case
name|IA64_OPND_IMM8M1
case|:
case|case
name|IA64_OPND_IMM8M1U4
case|:
case|case
name|IA64_OPND_IMM8M1U8
case|:
case|case
name|IA64_OPND_IMM9a
case|:
case|case
name|IA64_OPND_IMM9b
case|:
name|bits
operator|=
name|operand_width
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable
operator|&&
operator|(
name|e
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_subtract
operator|||
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
operator|)
condition|)
block|{
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|index
index|]
operator|==
name|IA64_OPND_IMM14
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_IMM14
expr_stmt|;
else|else
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_IMM22
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_subtract
condition|)
block|{
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
condition|)
name|e
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|0
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
operator|!
operator|(
name|e
operator|->
name|X_op
operator|==
name|O_big
operator|&&
name|opnd
operator|==
name|IA64_OPND_IMM8M1U8
operator|)
condition|)
return|return
name|OPERAND_MISMATCH
return|;
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8M1U4
condition|)
block|{
comment|/* Zero is not valid for unsigned compares that take an adjusted 	     constant immediate range.  */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|0
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
comment|/* Sign-extend 32-bit unsigned numbers, so that the following range 	     checks will work.  */
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|&
operator|(
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
operator|<<
literal|32
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|val
operator|=
operator|(
operator|(
name|val
operator|<<
literal|32
operator|)
operator|>>
literal|32
operator|)
expr_stmt|;
comment|/* Check for 0x100000000.  This is valid because 	     0x100000000-1 is the same as ((uint32_t) -1).  */
if|if
condition|(
name|val
operator|==
operator|(
operator|(
name|bfd_signed_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
name|val
operator|=
name|val
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8M1U8
condition|)
block|{
comment|/* Zero is not valid for unsigned compares that take an adjusted 	     constant immediate range.  */
if|if
condition|(
name|e
operator|->
name|X_add_number
operator|==
literal|0
condition|)
return|return
name|OPERAND_OUT_OF_RANGE
return|;
comment|/* Check for 0x10000000000000000.  */
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|generic_bignum
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|generic_bignum
index|[
literal|4
index|]
operator|==
literal|1
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
else|else
name|val
operator|=
name|e
operator|->
name|X_add_number
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8M1
condition|)
name|val
operator|=
name|e
operator|->
name|X_add_number
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_IMM8U4
condition|)
block|{
comment|/* Sign-extend 32-bit unsigned numbers, so that the following range 	     checks will work.  */
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|&
operator|(
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
operator|<<
literal|32
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|val
operator|=
operator|(
operator|(
name|val
operator|<<
literal|32
operator|)
operator|>>
literal|32
operator|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|>=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|val
operator|<
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|val
operator|<
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
operator|-
name|val
operator|<=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
case|case
name|IA64_OPND_INC3
case|:
comment|/* +/- 1, 4, 8, 16 */
name|val
operator|=
name|e
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|==
literal|1
operator|||
name|val
operator|==
literal|4
operator|||
name|val
operator|==
literal|8
operator|||
name|val
operator|==
literal|16
operator|)
condition|)
return|return
name|OPERAND_MATCH
return|;
else|else
return|return
name|OPERAND_OUT_OF_RANGE
return|;
block|}
break|break;
case|case
name|IA64_OPND_TGT25
case|:
case|case
name|IA64_OPND_TGT25b
case|:
case|case
name|IA64_OPND_TGT25c
case|:
case|case
name|IA64_OPND_TGT64
case|:
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT25
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL21F
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT25b
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL21M
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT25c
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL21B
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd
operator|==
name|IA64_OPND_TGT64
condition|)
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_PCREL60B
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|1
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
block|}
case|case
name|IA64_OPND_TAG13
case|:
case|case
name|IA64_OPND_TAG13b
case|:
switch|switch
condition|(
name|e
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
return|return
name|OPERAND_MATCH
return|;
case|case
name|O_symbol
case|:
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
comment|/* There are no external relocs for TAG13/TAG13b fields, so we 	     create a dummy reloc.  This will not live past md_apply_fix.  */
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|fix
operator|->
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|,
name|fix
operator|->
name|code
argument_list|)
expr_stmt|;
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|1
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|IA64_OPND_LDXMOV
case|:
name|fix
operator|=
name|CURR_SLOT
operator|.
name|fixup
operator|+
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
name|fix
operator|->
name|code
operator|=
name|BFD_RELOC_IA64_LDXMOV
expr_stmt|;
name|fix
operator|->
name|opnd
operator|=
name|idesc
operator|->
name|operands
index|[
name|index
index|]
expr_stmt|;
name|fix
operator|->
name|expr
operator|=
operator|*
name|e
expr_stmt|;
name|fix
operator|->
name|is_pcrel
operator|=
literal|0
expr_stmt|;
operator|++
name|CURR_SLOT
operator|.
name|num_fixups
expr_stmt|;
return|return
name|OPERAND_MATCH
return|;
default|default:
break|break;
block|}
return|return
name|OPERAND_MISMATCH
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_operand
parameter_list|(
name|e
parameter_list|,
name|more
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
name|int
name|more
decl_stmt|;
block|{
name|int
name|sep
init|=
literal|'\0'
decl_stmt|;
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|expression_and_evaluate
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sep
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|more
operator|&&
operator|(
name|sep
operator|==
literal|','
operator|||
name|sep
operator|==
name|more
operator|)
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
return|return
name|sep
return|;
block|}
end_function

begin_comment
comment|/* Returns the next entry in the opcode table that matches the one in    IDESC, and frees the entry in IDESC.  If no matching entry is    found, NULL is returned instead.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_opcode
modifier|*
name|get_next_opcode
parameter_list|(
name|struct
name|ia64_opcode
modifier|*
name|idesc
parameter_list|)
block|{
name|struct
name|ia64_opcode
modifier|*
name|next
init|=
name|ia64_find_next_opcode
argument_list|(
name|idesc
argument_list|)
decl_stmt|;
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Parse the operands for the opcode and find the opcode variant that    matches the specified operands, or NULL if no match is possible.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_opcode
modifier|*
name|parse_operands
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|highest_unmatched_operand
decl_stmt|,
name|num_operands
init|=
literal|0
decl_stmt|,
name|num_outputs
init|=
literal|0
decl_stmt|;
name|int
name|error_pos
decl_stmt|,
name|out_of_range_pos
decl_stmt|,
name|curr_out_of_range_pos
decl_stmt|,
name|sep
init|=
literal|0
decl_stmt|;
name|int
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|char
name|reg_class
decl_stmt|;
name|enum
name|ia64_opnd
name|expected_operand
init|=
name|IA64_OPND_NIL
decl_stmt|;
name|enum
name|operand_match_result
name|result
decl_stmt|;
name|char
name|mnemonic
index|[
literal|129
index|]
decl_stmt|;
name|char
modifier|*
name|first_arg
init|=
literal|0
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|saved_input_pointer
decl_stmt|;
name|unsigned
name|int
name|sof
decl_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|idesc
operator|->
name|name
argument_list|)
operator|<=
literal|128
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mnemonic
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|==
name|IA64_OPND_SOF
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_SOF
condition|)
block|{
comment|/* To make the common idiom "alloc loc?=ar.pfs,0,1,0,0" work, we 	 can't parse the first operand until we have parsed the 	 remaining operands of the "alloc" instruction.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|first_arg
operator|=
name|input_line_pointer
expr_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected separator `='"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|input_line_pointer
operator|=
name|end
operator|+
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
operator|++
name|num_outputs
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|<
name|NELEMS
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
argument_list|)
condition|)
block|{
name|sep
operator|=
name|parse_operand
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
operator|+
name|i
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_absent
condition|)
break|break;
block|}
else|else
block|{
name|expressionS
name|dummy
decl_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
operator|&
name|dummy
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy
operator|.
name|X_op
operator|==
name|O_absent
condition|)
break|break;
block|}
operator|++
name|num_operands
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|'='
operator|&&
name|sep
operator|!=
literal|','
condition|)
break|break;
if|if
condition|(
name|sep
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|num_outputs
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Duplicate equal sign (=) in instruction"
argument_list|)
expr_stmt|;
else|else
name|num_outputs
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sep
operator|!=
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Illegal operand separator `%c'"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|==
name|IA64_OPND_SOF
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_SOF
condition|)
block|{
comment|/* Map alloc r1=ar.pfs,i,l,o,r to alloc r1=ar.pfs,(i+l+o),(i+l),r. 	 Note, however, that due to that mapping operand numbers in error 	 messages for any of the constant operands will not be correct.  */
name|know
argument_list|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"alloc"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* The first operand hasn't been parsed/initialized, yet (but 	 num_operands intentionally doesn't account for that).  */
name|i
operator|=
name|num_operands
operator|>
literal|4
condition|?
literal|2
else|:
literal|1
expr_stmt|;
define|#
directive|define
name|FORCE_CONST
parameter_list|(
name|n
parameter_list|)
value|(CURR_SLOT.opnd[n].X_op == O_constant \ 			? CURR_SLOT.opnd[n].X_add_number \ 			: 0)
name|sof
operator|=
name|set_regstack
argument_list|(
name|FORCE_CONST
argument_list|(
name|i
argument_list|)
argument_list|,
name|FORCE_CONST
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|FORCE_CONST
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|,
name|FORCE_CONST
argument_list|(
name|i
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FORCE_CONST
comment|/* now we can parse the first arg:  */
name|saved_input_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|first_arg
expr_stmt|;
name|sep
operator|=
name|parse_operand
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
operator|+
literal|0
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|'='
condition|)
operator|--
name|num_outputs
expr_stmt|;
comment|/* force error */
name|input_line_pointer
operator|=
name|saved_input_pointer
expr_stmt|;
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|=
name|sof
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|X_add_number
operator|=
name|sof
operator|-
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|highest_unmatched_operand
operator|=
operator|-
literal|4
expr_stmt|;
name|curr_out_of_range_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|error_pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|idesc
condition|;
name|idesc
operator|=
name|get_next_opcode
argument_list|(
name|idesc
argument_list|)
control|)
block|{
if|if
condition|(
name|num_outputs
operator|!=
name|idesc
operator|->
name|num_outputs
condition|)
continue|continue;
comment|/* mismatch in # of outputs */
if|if
condition|(
name|highest_unmatched_operand
operator|<
literal|0
condition|)
name|highest_unmatched_operand
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|num_operands
operator|>
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
operator|||
operator|(
name|num_operands
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
operator|&&
name|idesc
operator|->
name|operands
index|[
name|num_operands
index|]
operator|)
operator|||
operator|(
name|num_operands
operator|>
literal|0
operator|&&
operator|!
name|idesc
operator|->
name|operands
index|[
name|num_operands
operator|-
literal|1
index|]
operator|)
condition|)
continue|continue;
comment|/* mismatch in number of arguments */
if|if
condition|(
name|highest_unmatched_operand
operator|<
literal|0
condition|)
name|highest_unmatched_operand
operator||=
literal|2
expr_stmt|;
name|CURR_SLOT
operator|.
name|num_fixups
operator|=
literal|0
expr_stmt|;
comment|/* Try to match all operands.  If we see an out-of-range operand, 	 then continue trying to match the rest of the operands, since if 	 the rest match, then this idesc will give the best error message.  */
name|out_of_range_pos
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_operands
operator|&&
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|=
name|operand_match
argument_list|(
name|idesc
argument_list|,
name|i
argument_list|,
name|CURR_SLOT
operator|.
name|opnd
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|OPERAND_MATCH
condition|)
block|{
if|if
condition|(
name|result
operator|!=
name|OPERAND_OUT_OF_RANGE
condition|)
break|break;
if|if
condition|(
name|out_of_range_pos
operator|<
literal|0
condition|)
comment|/* remember position of the first out-of-range operand: */
name|out_of_range_pos
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we did not match all operands, or if at least one operand was 	 out-of-range, then this idesc does not match.  Keep track of which 	 idesc matched the most operands before failing.  If we have two 	 idescs that failed at the same position, and one had an out-of-range 	 operand, then prefer the out-of-range operand.  Thus if we have 	 "add r0=0x1000000,r1" we get an error saying the constant is out 	 of range instead of an error saying that the constant should have been 	 a register.  */
if|if
condition|(
name|i
operator|!=
name|num_operands
operator|||
name|out_of_range_pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|highest_unmatched_operand
operator|||
operator|(
name|i
operator|==
name|highest_unmatched_operand
operator|&&
name|out_of_range_pos
operator|>
name|curr_out_of_range_pos
operator|)
condition|)
block|{
name|highest_unmatched_operand
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|out_of_range_pos
operator|>=
literal|0
condition|)
block|{
name|expected_operand
operator|=
name|idesc
operator|->
name|operands
index|[
name|out_of_range_pos
index|]
expr_stmt|;
name|error_pos
operator|=
name|out_of_range_pos
expr_stmt|;
block|}
else|else
block|{
name|expected_operand
operator|=
name|idesc
operator|->
name|operands
index|[
name|i
index|]
expr_stmt|;
name|error_pos
operator|=
name|i
expr_stmt|;
block|}
name|curr_out_of_range_pos
operator|=
name|out_of_range_pos
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|idesc
condition|)
block|{
if|if
condition|(
name|expected_operand
condition|)
name|as_bad
argument_list|(
literal|"Operand %u of `%s' should be %s"
argument_list|,
name|error_pos
operator|+
literal|1
argument_list|,
name|mnemonic
argument_list|,
name|elf64_ia64_operands
index|[
name|expected_operand
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|highest_unmatched_operand
operator|<
literal|0
operator|&&
operator|!
operator|(
name|highest_unmatched_operand
operator|&
literal|1
operator|)
condition|)
name|as_bad
argument_list|(
literal|"Wrong number of output operands"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|highest_unmatched_operand
operator|<
literal|0
operator|&&
operator|!
operator|(
name|highest_unmatched_operand
operator|&
literal|2
operator|)
condition|)
name|as_bad
argument_list|(
literal|"Wrong number of input operands"
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Operand mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check that the instruction doesn't use      - r0, f0, or f1 as output operands      - the same predicate twice as output operands      - r0 as address of a base update load or store      - the same GR as output and address of a base update load      - two even- or two odd-numbered FRs as output operands of a floating        point parallel load.      At most two (conflicting) output (or output-like) operands can exist,      (floating point parallel loads have three outputs, but the base register,      if updated, cannot conflict with the actual outputs).  */
name|reg2
operator|=
name|reg1
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_operands
condition|;
operator|++
name|i
control|)
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
name|reg_class
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|)
block|{
case|case
name|IA64_OPND_R1
case|:
case|case
name|IA64_OPND_R2
case|:
case|case
name|IA64_OPND_R3
case|:
if|if
condition|(
name|i
operator|<
name|num_outputs
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|REG_GR
condition|)
name|reg_class
operator|=
literal|'r'
expr_stmt|;
elseif|else
if|if
condition|(
name|reg1
operator|<
literal|0
condition|)
name|reg1
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|<
literal|0
condition|)
name|reg2
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
block|}
break|break;
case|case
name|IA64_OPND_P1
case|:
case|case
name|IA64_OPND_P2
case|:
if|if
condition|(
name|i
operator|<
name|num_outputs
condition|)
block|{
if|if
condition|(
name|reg1
operator|<
literal|0
condition|)
name|reg1
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|<
literal|0
condition|)
name|reg2
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
block|}
break|break;
case|case
name|IA64_OPND_F1
case|:
case|case
name|IA64_OPND_F2
case|:
case|case
name|IA64_OPND_F3
case|:
case|case
name|IA64_OPND_F4
case|:
if|if
condition|(
name|i
operator|<
name|num_outputs
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|>=
name|REG_FR
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|<=
name|REG_FR
operator|+
literal|1
condition|)
block|{
name|reg_class
operator|=
literal|'f'
expr_stmt|;
name|regno
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|<
literal|0
condition|)
name|reg1
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|<
literal|0
condition|)
name|reg2
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
block|}
break|break;
case|case
name|IA64_OPND_MR3
case|:
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_POSTINC
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|REG_GR
condition|)
name|reg_class
operator|=
literal|'m'
expr_stmt|;
elseif|else
if|if
condition|(
name|reg1
operator|<
literal|0
condition|)
name|reg1
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|<
literal|0
condition|)
name|reg2
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|reg_class
condition|)
block|{
case|case
literal|0
case|:
break|break;
default|default:
name|as_warn
argument_list|(
literal|"Invalid use of `%c%d' as output operand"
argument_list|,
name|reg_class
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|as_warn
argument_list|(
literal|"Invalid use of `r%d' as base update address operand"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|reg1
operator|==
name|reg2
condition|)
block|{
if|if
condition|(
name|reg1
operator|>=
name|REG_GR
operator|&&
name|reg1
operator|<=
name|REG_GR
operator|+
literal|127
condition|)
block|{
name|reg1
operator|-=
name|REG_GR
expr_stmt|;
name|reg_class
operator|=
literal|'r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|>=
name|REG_P
operator|&&
name|reg1
operator|<=
name|REG_P
operator|+
literal|63
condition|)
block|{
name|reg1
operator|-=
name|REG_P
expr_stmt|;
name|reg_class
operator|=
literal|'p'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|>=
name|REG_FR
operator|&&
name|reg1
operator|<=
name|REG_FR
operator|+
literal|127
condition|)
block|{
name|reg1
operator|-=
name|REG_FR
expr_stmt|;
name|reg_class
operator|=
literal|'f'
expr_stmt|;
block|}
else|else
name|reg_class
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_class
condition|)
name|as_warn
argument_list|(
literal|"Invalid duplicate use of `%c%d'"
argument_list|,
name|reg_class
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|reg1
operator|>=
name|REG_FR
operator|&&
name|reg1
operator|<=
name|REG_FR
operator|+
literal|31
operator|&&
name|reg2
operator|>=
name|REG_FR
operator|&&
name|reg2
operator|<=
name|REG_FR
operator|+
literal|31
operator|)
operator|||
operator|(
name|reg1
operator|>=
name|REG_FR
operator|+
literal|32
operator|&&
name|reg1
operator|<=
name|REG_FR
operator|+
literal|127
operator|&&
name|reg2
operator|>=
name|REG_FR
operator|+
literal|32
operator|&&
name|reg2
operator|<=
name|REG_FR
operator|+
literal|127
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|reg1
operator|^
name|reg2
operator|)
operator|&
literal|1
operator|)
condition|)
name|as_warn
argument_list|(
literal|"Invalid simultaneous use of `f%d' and `f%d'"
argument_list|,
name|reg1
operator|-
name|REG_FR
argument_list|,
name|reg2
operator|-
name|REG_FR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|reg1
operator|>=
name|REG_FR
operator|&&
name|reg1
operator|<=
name|REG_FR
operator|+
literal|31
operator|&&
name|reg2
operator|>=
name|REG_FR
operator|+
literal|32
operator|&&
name|reg2
operator|<=
name|REG_FR
operator|+
literal|127
operator|)
operator|||
operator|(
name|reg1
operator|>=
name|REG_FR
operator|+
literal|32
operator|&&
name|reg1
operator|<=
name|REG_FR
operator|+
literal|127
operator|&&
name|reg2
operator|>=
name|REG_FR
operator|&&
name|reg2
operator|<=
name|REG_FR
operator|+
literal|31
operator|)
condition|)
name|as_warn
argument_list|(
literal|"Dangerous simultaneous use of `f%d' and `f%d'"
argument_list|,
name|reg1
operator|-
name|REG_FR
argument_list|,
name|reg2
operator|-
name|REG_FR
argument_list|)
expr_stmt|;
return|return
name|idesc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_insn
parameter_list|(
name|slot
parameter_list|,
name|insnp
parameter_list|)
name|struct
name|slot
modifier|*
name|slot
decl_stmt|;
name|bfd_vma
modifier|*
name|insnp
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_operand
modifier|*
name|odesc
decl_stmt|,
modifier|*
name|o2desc
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
init|=
name|slot
operator|->
name|idesc
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_signed_vma
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|insn
operator|=
name|idesc
operator|->
name|opcode
operator||
name|slot
operator|->
name|qp_regno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
operator|&&
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|||
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_index
condition|)
name|val
operator|=
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* This must be the value 0x10000000000000000.  */
name|assert
argument_list|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_IMM8M1U8
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
condition|)
block|{
case|case
name|IA64_OPND_IMMU64
case|:
operator|*
name|insnp
operator|++
operator|=
operator|(
name|val
operator|>>
literal|22
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0x7f
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|7
operator|)
operator|&
literal|0x1ff
operator|)
operator|<<
literal|27
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|21
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|63
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
continue|continue;
case|case
name|IA64_OPND_IMMU62
case|:
name|val
operator|&=
literal|0x3fffffffffffffffULL
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|slot
operator|->
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Value truncated to 62 bits"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|insnp
operator|++
operator|=
operator|(
name|val
operator|>>
literal|21
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0xfffff
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|20
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
continue|continue;
case|case
name|IA64_OPND_TGT64
case|:
name|val
operator|>>=
literal|4
expr_stmt|;
operator|*
name|insnp
operator|++
operator|=
operator|(
operator|(
name|val
operator|>>
literal|20
operator|)
operator|&
literal|0x7fffffffffLL
operator|)
operator|<<
literal|2
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
operator|(
name|val
operator|>>
literal|59
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0xfffff
operator|)
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
continue|continue;
case|case
name|IA64_OPND_AR3
case|:
name|val
operator|-=
name|REG_AR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_B1
case|:
case|case
name|IA64_OPND_B2
case|:
name|val
operator|-=
name|REG_BR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_CR3
case|:
name|val
operator|-=
name|REG_CR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_F1
case|:
case|case
name|IA64_OPND_F2
case|:
case|case
name|IA64_OPND_F3
case|:
case|case
name|IA64_OPND_F4
case|:
name|val
operator|-=
name|REG_FR
expr_stmt|;
break|break;
case|case
name|IA64_OPND_P1
case|:
case|case
name|IA64_OPND_P2
case|:
name|val
operator|-=
name|REG_P
expr_stmt|;
break|break;
case|case
name|IA64_OPND_R1
case|:
case|case
name|IA64_OPND_R2
case|:
case|case
name|IA64_OPND_R3
case|:
case|case
name|IA64_OPND_R3_2
case|:
case|case
name|IA64_OPND_CPUID_R3
case|:
case|case
name|IA64_OPND_DBR_R3
case|:
case|case
name|IA64_OPND_DTR_R3
case|:
case|case
name|IA64_OPND_ITR_R3
case|:
case|case
name|IA64_OPND_IBR_R3
case|:
case|case
name|IA64_OPND_MR3
case|:
case|case
name|IA64_OPND_MSR_R3
case|:
case|case
name|IA64_OPND_PKR_R3
case|:
case|case
name|IA64_OPND_PMC_R3
case|:
case|case
name|IA64_OPND_PMD_R3
case|:
case|case
name|IA64_OPND_RR_R3
case|:
name|val
operator|-=
name|REG_GR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|odesc
operator|=
name|elf64_ia64_operands
operator|+
name|idesc
operator|->
name|operands
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|odesc
operator|->
name|insert
call|)
argument_list|(
name|odesc
argument_list|,
name|val
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_bad_where
argument_list|(
name|slot
operator|->
name|src_file
argument_list|,
name|slot
operator|->
name|src_line
argument_list|,
literal|"Bad operand value: %s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_PSEUDO
condition|)
block|{
if|if
condition|(
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_F2_EQ_F3
operator|)
operator|&&
name|odesc
operator|==
name|elf64_ia64_operands
operator|+
name|IA64_OPND_F3
condition|)
block|{
name|o2desc
operator|=
name|elf64_ia64_operands
operator|+
name|IA64_OPND_F2
expr_stmt|;
call|(
modifier|*
name|o2desc
operator|->
name|insert
call|)
argument_list|(
name|o2desc
argument_list|,
name|val
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_LEN_EQ_64MCNT
operator|)
operator|&&
operator|(
name|odesc
operator|==
name|elf64_ia64_operands
operator|+
name|IA64_OPND_CPOS6a
operator|||
name|odesc
operator|==
name|elf64_ia64_operands
operator|+
name|IA64_OPND_POS6
operator|)
condition|)
block|{
name|o2desc
operator|=
name|elf64_ia64_operands
operator|+
name|IA64_OPND_LEN6
expr_stmt|;
call|(
modifier|*
name|o2desc
operator|->
name|insert
call|)
argument_list|(
name|o2desc
argument_list|,
literal|64
operator|-
name|val
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|insnp
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_one_bundle
parameter_list|()
block|{
name|int
name|manual_bundling_off
init|=
literal|0
decl_stmt|,
name|manual_bundling
init|=
literal|0
decl_stmt|;
name|enum
name|ia64_unit
name|required_unit
decl_stmt|,
name|insn_unit
init|=
literal|0
decl_stmt|;
name|enum
name|ia64_insn_type
name|type
index|[
literal|3
index|]
decl_stmt|,
name|insn_type
decl_stmt|;
name|unsigned
name|int
name|template
decl_stmt|,
name|orig_template
decl_stmt|;
name|bfd_vma
name|insn
index|[
literal|3
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|end_of_insn_group
init|=
literal|0
decl_stmt|,
name|user_template
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|curr
decl_stmt|,
name|last_slot
decl_stmt|;
name|bfd_vma
name|t0
init|=
literal|0
decl_stmt|,
name|t1
init|=
literal|0
decl_stmt|;
name|struct
name|label_fix
modifier|*
name|lfix
decl_stmt|;
name|bfd_boolean
name|mark_label
decl_stmt|;
name|struct
name|insn_fix
modifier|*
name|ifix
decl_stmt|;
name|char
name|mnemonic
index|[
literal|16
index|]
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|addr_mod
decl_stmt|;
name|first
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
name|NUM_SLOTS
operator|-
name|md
operator|.
name|num_slots_in_use
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
name|know
argument_list|(
name|first
operator|>=
literal|0
operator|&&
name|first
operator|<
name|NUM_SLOTS
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
literal|3
argument_list|,
name|md
operator|.
name|num_slots_in_use
argument_list|)
expr_stmt|;
comment|/* Determine template: user user_template if specified, best match      otherwise:  */
if|if
condition|(
name|md
operator|.
name|slot
index|[
name|first
index|]
operator|.
name|user_template
operator|>=
literal|0
condition|)
name|user_template
operator|=
name|template
operator|=
name|md
operator|.
name|slot
index|[
name|first
index|]
operator|.
name|user_template
expr_stmt|;
else|else
block|{
comment|/* Auto select appropriate template.  */
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|label_fixups
operator|&&
name|i
operator|!=
literal|0
condition|)
break|break;
name|type
index|[
name|i
index|]
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
operator|->
name|type
expr_stmt|;
name|curr
operator|=
operator|(
name|curr
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
block|}
name|template
operator|=
name|best_template
index|[
name|type
index|[
literal|0
index|]
index|]
index|[
name|type
index|[
literal|1
index|]
index|]
index|[
name|type
index|[
literal|2
index|]
index|]
expr_stmt|;
block|}
comment|/* initialize instructions with appropriate nops:  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|insn
index|[
name|i
index|]
operator|=
name|nop
index|[
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
name|i
index|]
index|]
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* Check to see if this bundle is at an offset that is a multiple of 16-bytes      from the start of the frag.  */
name|addr_mod
operator|=
name|frag_now_fix
argument_list|()
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|frag_now
operator|->
name|has_code
operator|&&
name|frag_now
operator|->
name|insn_addr
operator|!=
name|addr_mod
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction address is not a multiple of 16"
argument_list|)
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|insn_addr
operator|=
name|addr_mod
expr_stmt|;
name|frag_now
operator|->
name|has_code
operator|=
literal|1
expr_stmt|;
comment|/* now fill in slots with as many insns as possible:  */
name|curr
operator|=
name|first
expr_stmt|;
name|idesc
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
expr_stmt|;
name|end_of_insn_group
operator|=
literal|0
expr_stmt|;
name|last_slot
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
operator|&&
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|;
operator|++
name|i
control|)
block|{
comment|/* If we have unwind records, we may need to update some now.  */
name|unw_rec_list
modifier|*
name|ptr
init|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
decl_stmt|;
name|unw_rec_list
modifier|*
name|end_ptr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
comment|/* Find the last prologue/body record in the list for the current 	     insn, and set the slot number for all records up to that point. 	     This needs to be done now, because prologue/body records refer to 	     the current point, not the point after the instruction has been 	     issued.  This matters because there may have been nops emitted 	     meanwhile.  Any non-prologue non-body record followed by a 	     prologue/body record must also refer to the current point.  */
name|unw_rec_list
modifier|*
name|last_ptr
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|end_ptr
operator|==
name|NULL
operator|&&
name|j
operator|<
name|md
operator|.
name|num_slots_in_use
condition|;
operator|++
name|j
control|)
name|end_ptr
operator|=
name|md
operator|.
name|slot
index|[
operator|(
name|curr
operator|+
name|j
operator|)
operator|%
name|NUM_SLOTS
index|]
operator|.
name|unwind_record
expr_stmt|;
for|for
control|(
name|last_ptr
operator|=
name|NULL
init|;
name|ptr
operator|!=
name|end_ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue
operator|||
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|prologue_gr
operator|||
name|ptr
operator|->
name|r
operator|.
name|type
operator|==
name|body
condition|)
name|last_ptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|last_ptr
condition|)
block|{
comment|/* Make last_ptr point one after the last prologue/body 		 record.  */
name|last_ptr
operator|=
name|last_ptr
operator|->
name|next
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
init|;
name|ptr
operator|!=
name|last_ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|ptr
operator|->
name|slot_number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|f
operator|+
name|i
expr_stmt|;
name|ptr
operator|->
name|slot_frag
operator|=
name|frag_now
expr_stmt|;
block|}
comment|/* Remove the initialized records, so that we won't accidentally 		 update them again if we insert a nop and continue.  */
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
operator|=
name|last_ptr
expr_stmt|;
block|}
block|}
name|manual_bundling_off
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|manual_bundling_off
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|manual_bundling_on
condition|)
block|{
if|if
condition|(
name|curr
operator|==
name|first
condition|)
name|manual_bundling
operator|=
literal|1
expr_stmt|;
else|else
break|break;
comment|/* Need to start a new bundle.  */
block|}
comment|/* If this instruction specifies a template, then it must be the first 	 instruction of a bundle.  */
if|if
condition|(
name|curr
operator|!=
name|first
operator|&&
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|user_template
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_SLOT2
condition|)
block|{
if|if
condition|(
name|manual_bundling
operator|&&
operator|!
name|manual_bundling_off
condition|)
block|{
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' must be last in bundle"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
name|manual_bundling
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Suppress meaningless post-loop errors.  */
block|}
name|i
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_LAST
condition|)
block|{
name|int
name|required_slot
decl_stmt|;
name|unsigned
name|int
name|required_template
decl_stmt|;
comment|/* If we need a stop bit after an M slot, our only choice is 	     template 5 (M;;MI).  If we need a stop bit after a B 	     slot, our only choice is to place it at the end of the 	     bundle, because the only available templates are MIB, 	     MBB, BBB, MMB, and MFB.  We don't handle anything other 	     than M and B slots because these are the only kind of 	     instructions that can have the IA64_OPCODE_LAST bit set.  */
name|required_template
operator|=
name|template
expr_stmt|;
switch|switch
condition|(
name|idesc
operator|->
name|type
condition|)
block|{
case|case
name|IA64_TYPE_M
case|:
name|required_slot
operator|=
literal|0
expr_stmt|;
name|required_template
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_B
case|:
name|required_slot
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"Internal error: don't know how to force %s to end"
literal|"of instruction group"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
name|required_slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|manual_bundling
operator|&&
operator|(
name|i
operator|>
name|required_slot
operator|||
operator|(
name|required_slot
operator|==
literal|2
operator|&&
operator|!
name|manual_bundling_off
operator|)
operator|||
operator|(
name|user_template
operator|>=
literal|0
comment|/* Changing from MMI to M;MI is OK.  */
operator|&&
operator|(
name|template
operator|^
name|required_template
operator|)
operator|>
literal|1
operator|)
operator|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' must be last in instruction group"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
operator|&&
name|required_slot
operator|==
literal|2
operator|&&
operator|!
name|manual_bundling_off
condition|)
name|manual_bundling
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Suppress meaningless post-loop errors.  */
block|}
if|if
condition|(
name|required_slot
operator|<
name|i
condition|)
comment|/* Can't fit this instruction.  */
break|break;
name|i
operator|=
name|required_slot
expr_stmt|;
if|if
condition|(
name|required_template
operator|!=
name|template
condition|)
block|{
comment|/* If we switch the template, we need to reset the NOPs 	         after slot i.  The slot-types of the instructions ahead 	         of i never change, so we don't need to worry about 	         changing NOPs in front of this slot.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
literal|3
condition|;
operator|++
name|j
control|)
name|insn
index|[
name|j
index|]
operator|=
name|nop
index|[
name|ia64_templ_desc
index|[
name|required_template
index|]
operator|.
name|exec_unit
index|[
name|j
index|]
index|]
expr_stmt|;
comment|/* We just picked a template that includes the stop bit in the 		 middle, so we don't need another one emitted later.  */
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|end_of_insn_group
operator|=
literal|0
expr_stmt|;
block|}
name|template
operator|=
name|required_template
expr_stmt|;
block|}
if|if
condition|(
name|curr
operator|!=
name|first
operator|&&
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|label_fixups
condition|)
block|{
if|if
condition|(
name|manual_bundling
condition|)
block|{
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"Label must be first in a bundle"
argument_list|)
expr_stmt|;
name|manual_bundling
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Suppress meaningless post-loop errors.  */
block|}
comment|/* This insn must go into the first slot of a bundle.  */
break|break;
block|}
if|if
condition|(
name|end_of_insn_group
operator|&&
name|md
operator|.
name|num_slots_in_use
operator|>=
literal|1
condition|)
block|{
comment|/* We need an instruction group boundary in the middle of a 	     bundle.  See if we can switch to an other template with 	     an appropriate boundary.  */
name|orig_template
operator|=
name|template
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|(
name|user_template
operator|==
literal|4
operator|||
operator|(
name|user_template
operator|<
literal|0
operator|&&
operator|(
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
literal|0
index|]
operator|==
name|IA64_UNIT_M
operator|)
operator|)
operator|)
condition|)
block|{
name|template
operator|=
literal|5
expr_stmt|;
name|end_of_insn_group
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
operator|&&
operator|(
name|user_template
operator|==
literal|0
operator|||
operator|(
name|user_template
operator|<
literal|0
operator|&&
operator|(
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
literal|1
index|]
operator|==
name|IA64_UNIT_I
operator|)
operator|)
operator|)
comment|/* This test makes sure we don't switch the template if 		      the next instruction is one that needs to be first in 		      an instruction group.  Since all those instructions are 		      in the M group, there is no way such an instruction can 		      fit in this bundle even if we switch the template.  The 		      reason we have to check for this is that otherwise we 		      may end up generating "MI;;I M.." which has the deadly 		      effect that the second M instruction is no longer the 		      first in the group! --davidm 99/12/16  */
operator|&&
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_FIRST
operator|)
operator|==
literal|0
condition|)
block|{
name|template
operator|=
literal|1
expr_stmt|;
name|end_of_insn_group
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|user_template
operator|==
literal|0
operator|&&
operator|!
operator|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_FIRST
operator|)
condition|)
comment|/* Use the next slot.  */
continue|continue;
elseif|else
if|if
condition|(
name|curr
operator|!=
name|first
condition|)
comment|/* can't fit this insn */
break|break;
if|if
condition|(
name|template
operator|!=
name|orig_template
condition|)
comment|/* if we switch the template, we need to reset the NOPs 	       after slot i.  The slot-types of the instructions ahead 	       of i never change, so we don't need to worry about 	       changing NOPs in front of this slot.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
literal|3
condition|;
operator|++
name|j
control|)
name|insn
index|[
name|j
index|]
operator|=
name|nop
index|[
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
name|required_unit
operator|=
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|exec_unit
index|[
name|i
index|]
expr_stmt|;
comment|/* resolve dynamic opcodes such as "break", "hint", and "nop":  */
if|if
condition|(
name|idesc
operator|->
name|type
operator|==
name|IA64_TYPE_DYN
condition|)
block|{
name|enum
name|ia64_opnd
name|opnd1
decl_stmt|,
name|opnd2
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"break"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|insn_unit
operator|=
name|required_unit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"hint"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|insn_unit
operator|=
name|required_unit
expr_stmt|;
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_B
condition|)
block|{
switch|switch
condition|(
name|md
operator|.
name|hint_b
condition|)
block|{
case|case
name|hint_b_ok
case|:
break|break;
case|case
name|hint_b_warning
case|:
name|as_warn
argument_list|(
literal|"hint in B unit may be treated as nop"
argument_list|)
expr_stmt|;
break|break;
case|case
name|hint_b_error
case|:
comment|/* When manual bundling is off and there is no 			 user template, we choose a different unit so 			 that hint won't go into the current slot. We 			 will fill the current bundle with nops and 			 try to put hint into the next bundle.  */
if|if
condition|(
operator|!
name|manual_bundling
operator|&&
name|user_template
operator|<
literal|0
condition|)
name|insn_unit
operator|=
name|IA64_UNIT_I
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"hint in B unit can't be used"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"chk.s"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|insn_unit
operator|=
name|IA64_UNIT_M
expr_stmt|;
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_I
operator|||
operator|(
name|required_unit
operator|==
name|IA64_UNIT_F
operator|&&
name|template
operator|==
literal|6
operator|)
condition|)
name|insn_unit
operator|=
name|IA64_UNIT_I
expr_stmt|;
block|}
else|else
name|as_fatal
argument_list|(
literal|"emit_one_bundle: unexpected dynamic op"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mnemonic
argument_list|,
sizeof|sizeof
argument_list|(
name|mnemonic
argument_list|)
argument_list|,
literal|"%s.%c"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
literal|"?imbfxx"
index|[
name|insn_unit
index|]
argument_list|)
expr_stmt|;
name|opnd1
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|opnd2
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
comment|/* moves to/from ARs have collisions */
if|if
condition|(
name|opnd1
operator|==
name|IA64_OPND_AR3
operator|||
name|opnd2
operator|==
name|IA64_OPND_AR3
condition|)
block|{
while|while
condition|(
name|idesc
operator|!=
name|NULL
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|!=
name|opnd1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|!=
name|opnd2
operator|)
condition|)
name|idesc
operator|=
name|get_next_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
operator|=
name|idesc
expr_stmt|;
block|}
else|else
block|{
name|insn_type
operator|=
name|idesc
operator|->
name|type
expr_stmt|;
name|insn_unit
operator|=
name|IA64_UNIT_NIL
expr_stmt|;
switch|switch
condition|(
name|insn_type
condition|)
block|{
case|case
name|IA64_TYPE_A
case|:
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_I
operator|||
name|required_unit
operator|==
name|IA64_UNIT_M
condition|)
name|insn_unit
operator|=
name|required_unit
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_X
case|:
name|insn_unit
operator|=
name|IA64_UNIT_L
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_I
case|:
name|insn_unit
operator|=
name|IA64_UNIT_I
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_M
case|:
name|insn_unit
operator|=
name|IA64_UNIT_M
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_B
case|:
name|insn_unit
operator|=
name|IA64_UNIT_B
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_F
case|:
name|insn_unit
operator|=
name|IA64_UNIT_F
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|insn_unit
operator|!=
name|required_unit
condition|)
continue|continue;
comment|/* Try next slot.  */
comment|/* Now is a good time to fix up the labels for this insn.  */
name|mark_label
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|lfix
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|label_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
block|{
name|S_SET_VALUE
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|16
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|mark_label
operator||=
name|lfix
operator|->
name|dw2_mark_labels
expr_stmt|;
block|}
for|for
control|(
name|lfix
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|tag_fixups
init|;
name|lfix
condition|;
name|lfix
operator|=
name|lfix
operator|->
name|next
control|)
block|{
name|S_SET_VALUE
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|16
operator|+
name|i
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lfix
operator|->
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_DWARF2
operator|||
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|loc_directive_seen
operator|||
name|mark_label
condition|)
block|{
name|bfd_vma
name|addr
init|=
name|frag_now
operator|->
name|fr_address
operator|+
name|frag_now_fix
argument_list|()
operator|-
literal|16
operator|+
name|i
decl_stmt|;
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|loc_directive_seen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mark_label
condition|)
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|debug_line
operator|.
name|flags
operator||=
name|DWARF2_FLAG_BASIC_BLOCK
expr_stmt|;
name|dwarf2_gen_line_info
argument_list|(
name|addr
argument_list|,
operator|&
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|debug_line
argument_list|)
expr_stmt|;
block|}
name|build_insn
argument_list|(
name|md
operator|.
name|slot
operator|+
name|curr
argument_list|,
name|insn
operator|+
name|i
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
comment|/* Set slot numbers for all remaining unwind records belonging to the 	     current insn.  There can not be any prologue/body unwind records 	     here.  */
for|for
control|(
init|;
name|ptr
operator|!=
name|end_ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|ptr
operator|->
name|slot_number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|f
operator|+
name|i
expr_stmt|;
name|ptr
operator|->
name|slot_frag
operator|=
name|frag_now
expr_stmt|;
block|}
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|unwind_record
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|required_unit
operator|==
name|IA64_UNIT_L
condition|)
block|{
name|know
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* skip one slot for long/X-unit instructions */
operator|++
name|i
expr_stmt|;
block|}
operator|--
name|md
operator|.
name|num_slots_in_use
expr_stmt|;
name|last_slot
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|num_fixups
condition|;
operator|++
name|j
control|)
block|{
name|ifix
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|fixup
operator|+
name|j
expr_stmt|;
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|16
operator|+
name|i
argument_list|,
literal|8
argument_list|,
operator|&
name|ifix
operator|->
name|expr
argument_list|,
name|ifix
operator|->
name|is_pcrel
argument_list|,
name|ifix
operator|->
name|code
argument_list|)
expr_stmt|;
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
operator|=
name|ifix
operator|->
name|opnd
expr_stmt|;
name|fix
operator|->
name|fx_file
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
expr_stmt|;
name|fix
operator|->
name|fx_line
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
expr_stmt|;
block|}
name|end_of_insn_group
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|end_of_insn_group
expr_stmt|;
comment|/* clear slot:  */
name|ia64_free_opcode
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|md
operator|.
name|slot
operator|+
name|curr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|user_template
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|manual_bundling_off
condition|)
block|{
name|manual_bundling
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|curr
operator|=
operator|(
name|curr
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
name|idesc
operator|=
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
expr_stmt|;
block|}
comment|/* A user template was specified, but the first following instruction did      not fit.  This can happen with or without manual bundling.  */
if|if
condition|(
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
operator|&&
name|last_slot
operator|<
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' does not fit into %s template"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Drop first insn so we don't livelock.  */
operator|--
name|md
operator|.
name|num_slots_in_use
expr_stmt|;
name|know
argument_list|(
name|curr
operator|==
name|first
argument_list|)
expr_stmt|;
name|ia64_free_opcode
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|idesc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|md
operator|.
name|slot
operator|+
name|curr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|user_template
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|manual_bundling
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|last_slot
operator|>=
literal|2
condition|)
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' does not fit into bundle"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
name|template
operator|==
literal|2
condition|)
name|where
operator|=
literal|"X slot"
expr_stmt|;
elseif|else
if|if
condition|(
name|last_slot
operator|==
literal|0
condition|)
name|where
operator|=
literal|"slots 2 or 3"
expr_stmt|;
else|else
name|where
operator|=
literal|"slot 3"
expr_stmt|;
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"`%s' can't go in %s of %s template"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
name|where
argument_list|,
name|ia64_templ_desc
index|[
name|template
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|as_bad_where
argument_list|(
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_file
argument_list|,
name|md
operator|.
name|slot
index|[
name|curr
index|]
operator|.
name|src_line
argument_list|,
literal|"Missing '}' at end of file"
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|md
operator|.
name|num_slots_in_use
operator|<
name|NUM_SLOTS
argument_list|)
expr_stmt|;
name|t0
operator|=
name|end_of_insn_group
operator||
operator|(
name|template
operator|<<
literal|1
operator|)
operator||
operator|(
name|insn
index|[
literal|0
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|insn
index|[
literal|1
index|]
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|=
operator|(
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|18
operator|)
operator|&
literal|0x7fffff
operator|)
operator||
operator|(
name|insn
index|[
literal|2
index|]
operator|<<
literal|23
operator|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|0
argument_list|,
name|t0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|8
argument_list|,
name|t1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Switches from the Intel assembler.  */
case|case
literal|'m'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ilp64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"lp64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"p64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_ABI64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ilp32"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_ABI64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"le"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator|&=
operator|~
name|EF_IA_64_BE
expr_stmt|;
name|default_big_endian
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"be"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_BE
expr_stmt|;
name|default_big_endian
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"unwind-check="
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arg
operator|+=
literal|13
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"warning"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|unwind_check
operator|=
name|unwind_check_warning
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|unwind_check
operator|=
name|unwind_check_error
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"hint.b="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arg
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ok"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|hint_b
operator|=
name|hint_b_ok
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"warning"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|hint_b
operator|=
name|hint_b_warning
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|hint_b
operator|=
name|hint_b_error
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"tune="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arg
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"itanium1"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|tune
operator|=
name|itanium1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"itanium2"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|.
name|tune
operator|=
name|itanium2
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"so"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Suppress signon message.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pi"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Reject privileged instructions.  FIXME */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"us"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Allow union of signed and unsigned range.  FIXME */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"close_fcalls"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Do not resolve global function calls.  */
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'C'
case|:
comment|/* temp[="prefix"]  Insert temporary labels into the object file 			  symbol table prefixed by "prefix". 			  Default prefix is ":temp:".        */
break|break;
case|case
literal|'a'
case|:
comment|/* indirect=<tgt>	Assume unannotated indirect branches behavior 			according to<tgt> -- 			exit:	branch out from the current context (default) 			labels:	all labels in context may be branch targets        */
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"indirect="
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'x'
case|:
comment|/* -X conflicts with an ignored option, use -x instead */
name|md
operator|.
name|detect_dv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"explicit"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* set default mode to explicit */
name|md
operator|.
name|default_explicit_mode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|default_explicit_mode
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|detect_dv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"debug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|debug_dv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"debugx"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|default_explicit_mode
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|debug_dv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"debugn"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|.
name|debug_dv
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|detect_dv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized option '-x%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* nops		Print nops statistics.  */
break|break;
comment|/* GNU specific switches for gcc.  */
case|case
name|OPTION_MCONSTANT_GP
case|:
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_CONS_GP
expr_stmt|;
break|break;
case|case
name|OPTION_MAUTO_PIC
case|:
name|md
operator|.
name|flags
operator||=
name|EF_IA_64_NOFUNCDESC_CONS_GP
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ IA-64 options:\n\   --mconstant-gp	  mark output file as using the constant-GP model\n\ 			  (sets ELF header flag EF_IA_64_CONS_GP)\n\   --mauto-pic		  mark output file as using the constant-GP model\n\ 			  without function descriptors (sets ELF header flag\n\ 			  EF_IA_64_NOFUNCDESC_CONS_GP)\n\   -milp32|-milp64|-mlp64|-mp64	select data model (default -mlp64)\n\   -mle | -mbe		  select little- or big-endian byte order (default -mle)\n\   -mtune=[itanium1|itanium2]\n\ 			  tune for a specific CPU (default -mtune=itanium2)\n\   -munwind-check=[warning|error]\n\ 			  unwind directive check (default -munwind-check=warning)\n\   -mhint.b=[ok|warning|error]\n\ 			  hint.b check (default -mhint.b=error)\n\   -x | -xexplicit	  turn on dependency violation checking\n\   -xauto		  automagically remove dependency violations (default)\n\   -xnone		  turn off dependency violation checking\n\   -xdebug		  debug dependency violation checker\n\   -xdebugn		  debug dependency violation checker but turn off\n\ 			  dependency violation checking\n\   -xdebugx		  debug dependency violation checker and turn on\n\ 			  dependency violation checking\n"
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_after_parse_args
parameter_list|()
block|{
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"--gstabs is not supported for ia64"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE fits in TEMPL at SLOT.  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|int
name|templ
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|enum
name|ia64_unit
name|unit
decl_stmt|;
name|int
name|result
decl_stmt|;
name|unit
operator|=
name|ia64_templ_desc
index|[
name|templ
index|]
operator|.
name|exec_unit
index|[
name|slot
index|]
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IA64_TYPE_DYN
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* for nop and break */
case|case
name|IA64_TYPE_A
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_I
operator|||
name|unit
operator|==
name|IA64_UNIT_M
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_X
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_L
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_I
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_I
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_M
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_M
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_B
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_B
operator|)
expr_stmt|;
break|break;
case|case
name|IA64_TYPE_F
case|:
name|result
operator|=
operator|(
name|unit
operator|==
name|IA64_UNIT_F
operator|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* For Itanium 1, add a bit of extra goodness if a nop of type F or B would fit    in TEMPL at SLOT.  For Itanium 2, add a bit of extra goodness if a nop of    type M or I would fit in TEMPL at SLOT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|extra_goodness
parameter_list|(
name|int
name|templ
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
switch|switch
condition|(
name|md
operator|.
name|tune
condition|)
block|{
case|case
name|itanium1
case|:
if|if
condition|(
name|slot
operator|==
literal|1
operator|&&
name|match
argument_list|(
name|templ
argument_list|,
name|IA64_TYPE_F
argument_list|,
name|slot
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|slot
operator|==
literal|2
operator|&&
name|match
argument_list|(
name|templ
argument_list|,
name|IA64_TYPE_B
argument_list|,
name|slot
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|itanium2
case|:
if|if
condition|(
name|match
argument_list|(
name|templ
argument_list|,
name|IA64_TYPE_M
argument_list|,
name|slot
argument_list|)
operator|||
name|match
argument_list|(
name|templ
argument_list|,
name|IA64_TYPE_I
argument_list|,
name|slot
argument_list|)
condition|)
comment|/* Favor M- and I-unit NOPs.  We definitely want to avoid 	   F-unit and B-unit may cause split-issue or less-than-optimal 	   branch-prediction.  */
return|return
literal|2
return|;
else|else
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It sets    up all the tables, etc. that the MD part of the assembler will need    that can be determined before arguments are parsed.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|t
decl_stmt|,
name|goodness
decl_stmt|,
name|best
decl_stmt|,
name|ok
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|md
operator|.
name|auto_align
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|explicit_mode
operator|=
name|md
operator|.
name|default_explicit_mode
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Make sure function pointers get initialized.  */
name|target_big_endian
operator|=
operator|-
literal|1
expr_stmt|;
name|dot_byteorder
argument_list|(
name|default_big_endian
argument_list|)
expr_stmt|;
name|alias_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|alias_name_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|secalias_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|secalias_name_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_DTP_MODULE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<dtpmod>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_DTP_MODULE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_DTP_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<dtprel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_DTP_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_FPTR_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<fptr>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_FPTR_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_GP_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<gprel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_GP_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoff>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_RELATIVE_X
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoffx>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_RELATIVE_X
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_PC_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<pcrel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_PC_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_PLT_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<pltoff>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_PLT_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_SEC_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<secrel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_SEC_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_SEG_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<segrel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_SEG_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_TP_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<tprel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_TP_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LTV_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltv>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LTV_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_FPTR_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoff.fptr>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_FPTR_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_DTP_MODULE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoff.dtpmod>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_DTP_MODULE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_DTP_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoff.dptrel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_DTP_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_LT_TP_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<ltoff.tprel>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_LT_TP_RELATIVE
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_func
index|[
name|FUNC_IPLT_RELOC
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|symbol_new
argument_list|(
literal|".<iplt>"
argument_list|,
name|undefined_section
argument_list|,
name|FUNC_IPLT_RELOC
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|tune
operator|!=
name|itanium1
condition|)
block|{
comment|/* Convert MFI NOPs bundles into MMI NOPs bundles.  */
name|le_nop
index|[
literal|0
index|]
operator|=
literal|0x8
expr_stmt|;
name|le_nop_stop
index|[
literal|0
index|]
operator|=
literal|0x9
expr_stmt|;
block|}
comment|/* Compute the table of best templates.  We compute goodness as a      base 4 value, in which each match counts for 3.  Match-failures      result in NOPs and we use extra_goodness() to pick the execution      units that are best suited for issuing the NOP.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|k
control|)
block|{
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|NELEMS
argument_list|(
name|ia64_templ_desc
argument_list|)
condition|;
operator|++
name|t
control|)
block|{
name|goodness
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|==
literal|2
operator|&&
name|j
operator|==
name|IA64_TYPE_X
operator|)
operator|||
name|match
argument_list|(
name|t
argument_list|,
name|k
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
literal|3
operator|+
literal|3
expr_stmt|;
else|else
name|goodness
operator|=
literal|3
operator|+
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|j
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|goodness
operator|=
literal|3
expr_stmt|;
name|goodness
operator|+=
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|goodness
operator|+=
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|==
literal|2
operator|&&
name|i
operator|==
name|IA64_TYPE_X
operator|)
operator|||
name|match
argument_list|(
name|t
argument_list|,
name|j
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
literal|3
expr_stmt|;
else|else
name|goodness
operator|=
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
condition|)
name|goodness
operator|=
literal|3
operator|+
name|extra_goodness
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|goodness
operator|>
name|best
condition|)
block|{
name|best
operator|=
name|goodness
expr_stmt|;
name|best_template
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_TEMPLATES
comment|/* For debugging changes to the best_template calculations.  We don't care      about combinations with invalid instructions, so start the loops at 1.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IA64_NUM_TYPES
condition|;
operator|++
name|k
control|)
block|{
name|char
name|type_letter
index|[
name|IA64_NUM_TYPES
index|]
init|=
block|{
literal|'n'
block|,
literal|'a'
block|,
literal|'i'
block|,
literal|'m'
block|,
literal|'b'
block|,
literal|'f'
block|,
literal|'x'
block|,
literal|'d'
block|}
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%c%c %s\n"
argument_list|,
name|type_letter
index|[
name|i
index|]
argument_list|,
name|type_letter
index|[
name|j
index|]
argument_list|,
name|type_letter
index|[
name|k
index|]
argument_list|,
name|ia64_templ_desc
index|[
name|best_template
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SLOTS
condition|;
operator|++
name|i
control|)
name|md
operator|.
name|slot
index|[
name|i
index|]
operator|.
name|user_template
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|.
name|pseudo_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|pseudo_opcode
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|pseudo_hash
argument_list|,
name|pseudo_opcode
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|pseudo_opcode
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
literal|"ia64.md_begin: can't hash `%s': %s"
argument_list|,
name|pseudo_opcode
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|md
operator|.
name|dynreg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|md
operator|.
name|const_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|md
operator|.
name|entry_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* general registers:  */
name|declare_register_set
argument_list|(
literal|"r"
argument_list|,
literal|128
argument_list|,
name|REG_GR
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"gp"
argument_list|,
name|REG_GR
operator|+
literal|1
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"sp"
argument_list|,
name|REG_GR
operator|+
literal|12
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"tp"
argument_list|,
name|REG_GR
operator|+
literal|13
argument_list|)
expr_stmt|;
name|declare_register_set
argument_list|(
literal|"ret"
argument_list|,
literal|4
argument_list|,
name|REG_GR
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* floating point registers:  */
name|declare_register_set
argument_list|(
literal|"f"
argument_list|,
literal|128
argument_list|,
name|REG_FR
argument_list|)
expr_stmt|;
name|declare_register_set
argument_list|(
literal|"farg"
argument_list|,
literal|8
argument_list|,
name|REG_FR
operator|+
literal|8
argument_list|)
expr_stmt|;
name|declare_register_set
argument_list|(
literal|"fret"
argument_list|,
literal|8
argument_list|,
name|REG_FR
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* branch registers:  */
name|declare_register_set
argument_list|(
literal|"b"
argument_list|,
literal|8
argument_list|,
name|REG_BR
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"rp"
argument_list|,
name|REG_BR
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* predicate registers:  */
name|declare_register_set
argument_list|(
literal|"p"
argument_list|,
literal|64
argument_list|,
name|REG_P
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"pr"
argument_list|,
name|REG_PR
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"pr.rot"
argument_list|,
name|REG_PR_ROT
argument_list|)
expr_stmt|;
comment|/* application registers:  */
name|declare_register_set
argument_list|(
literal|"ar"
argument_list|,
literal|128
argument_list|,
name|REG_AR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|ar
argument_list|)
condition|;
operator|++
name|i
control|)
name|declare_register
argument_list|(
name|ar
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|REG_AR
operator|+
name|ar
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
comment|/* control registers:  */
name|declare_register_set
argument_list|(
literal|"cr"
argument_list|,
literal|128
argument_list|,
name|REG_CR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|cr
argument_list|)
condition|;
operator|++
name|i
control|)
name|declare_register
argument_list|(
name|cr
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|REG_CR
operator|+
name|cr
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"ip"
argument_list|,
name|REG_IP
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"cfm"
argument_list|,
name|REG_CFM
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"psr"
argument_list|,
name|REG_PSR
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"psr.l"
argument_list|,
name|REG_PSR_L
argument_list|)
expr_stmt|;
name|declare_register
argument_list|(
literal|"psr.um"
argument_list|,
name|REG_PSR_UM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|indirect_reg
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|regnum
init|=
name|indirect_reg
index|[
name|i
index|]
operator|.
name|regnum
decl_stmt|;
name|md
operator|.
name|indregsym
index|[
name|regnum
operator|-
name|IND_CPUID
index|]
operator|=
name|declare_register
argument_list|(
name|indirect_reg
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
comment|/* pseudo-registers used to specify unwind info:  */
name|declare_register
argument_list|(
literal|"psp"
argument_list|,
name|REG_PSP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|const_bits
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|hash_insert
argument_list|(
name|md
operator|.
name|const_hash
argument_list|,
name|const_bits
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|const_bits
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into constant hash table failed: %s"
argument_list|,
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Set the architecture and machine depending on defaults and command line      options.  */
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
name|ok
operator|=
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_ia64
argument_list|,
name|bfd_mach_ia64_elf64
argument_list|)
expr_stmt|;
else|else
name|ok
operator|=
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_ia64
argument_list|,
name|bfd_mach_ia64_elf32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the pointer size and pointer shift size depending on md.flags */
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
block|{
name|md
operator|.
name|pointer_size
operator|=
literal|8
expr_stmt|;
comment|/* pointers are 8 bytes */
name|md
operator|.
name|pointer_size_shift
operator|=
literal|3
expr_stmt|;
comment|/* alignment is 8 bytes = 2^2 */
block|}
else|else
block|{
name|md
operator|.
name|pointer_size
operator|=
literal|4
expr_stmt|;
comment|/* pointers are 4 bytes */
name|md
operator|.
name|pointer_size_shift
operator|=
literal|2
expr_stmt|;
comment|/* alignment is 4 bytes = 2^2 */
block|}
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|path
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|maxpaths
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|entry_labels
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the default options in md.  Cannot do this in md_begin because    that is called after md_parse_option which is where we set the    options in md based on command line options.  */
end_comment

begin_function
name|void
name|ia64_init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|md
operator|.
name|flags
operator|=
name|MD_FLAGS_DEFAULT
expr_stmt|;
name|md
operator|.
name|detect_dv
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: We should change it to unwind_check_error someday.  */
name|md
operator|.
name|unwind_check
operator|=
name|unwind_check_warning
expr_stmt|;
name|md
operator|.
name|hint_b
operator|=
name|hint_b_error
expr_stmt|;
name|md
operator|.
name|tune
operator|=
name|itanium2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string for the target object file format.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ia64_target_format
parameter_list|()
block|{
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_BE
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
if|#
directive|if
name|defined
argument_list|(
name|TE_AIX50
argument_list|)
return|return
literal|"elf64-ia64-aix-big"
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TE_HPUX
argument_list|)
return|return
literal|"elf64-ia64-hpux-big"
return|;
else|#
directive|else
return|return
literal|"elf64-ia64-big"
return|;
endif|#
directive|endif
else|else
if|#
directive|if
name|defined
argument_list|(
name|TE_AIX50
argument_list|)
return|return
literal|"elf32-ia64-aix-big"
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TE_HPUX
argument_list|)
return|return
literal|"elf32-ia64-hpux-big"
return|;
else|#
directive|else
return|return
literal|"elf32-ia64-big"
return|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
condition|)
if|#
directive|if
name|defined
argument_list|(
name|TE_AIX50
argument_list|)
return|return
literal|"elf64-ia64-aix-little"
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TE_FreeBSD
argument_list|)
return|return
literal|"elf64-ia64-freebsd"
return|;
else|#
directive|else
return|return
literal|"elf64-ia64-little"
return|;
endif|#
directive|endif
else|else
ifdef|#
directive|ifdef
name|TE_AIX50
return|return
literal|"elf32-ia64-aix-little"
return|;
else|#
directive|else
return|return
literal|"elf32-ia64-little"
return|;
endif|#
directive|endif
block|}
block|}
else|else
return|return
literal|"unknown-format"
return|;
block|}
end_function

begin_function
name|void
name|ia64_end_of_source
parameter_list|()
block|{
comment|/* terminate insn group upon reaching end of file:  */
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* emits slots we haven't written yet:  */
name|ia64_flush_insns
argument_list|()
expr_stmt|;
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|md
operator|.
name|flags
argument_list|)
expr_stmt|;
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_start_line
parameter_list|()
block|{
specifier|static
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
comment|/* Make sure we don't reference input_line_pointer[-1] when that's        not valid.  */
name|first
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
literal|"qualifying predicate not followed by instruction"
argument_list|)
expr_stmt|;
name|md
operator|.
name|qp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
name|ignore_input
argument_list|()
condition|)
return|return;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|';'
operator|&&
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|detect_dv
operator|&&
operator|!
name|md
operator|.
name|explicit_mode
condition|)
block|{
specifier|static
name|int
name|warned
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
literal|1
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Explicit stops are ignored in auto mode"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|manual_bundling
condition|)
name|as_warn
argument_list|(
literal|"Found '{' when manual bundling is already turned on"
argument_list|)
expr_stmt|;
else|else
name|CURR_SLOT
operator|.
name|manual_bundling_on
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|manual_bundling
operator|=
literal|1
expr_stmt|;
comment|/* Bundling is only acceptable in explicit mode 	 or when in default automatic mode.  */
if|if
condition|(
name|md
operator|.
name|detect_dv
operator|&&
operator|!
name|md
operator|.
name|explicit_mode
condition|)
block|{
if|if
condition|(
operator|!
name|md
operator|.
name|mode_explicitly_set
operator|&&
operator|!
name|md
operator|.
name|default_explicit_mode
condition|)
name|dot_dv_mode
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Found '{' after explicit switch to automatic mode"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
operator|!
name|md
operator|.
name|manual_bundling
condition|)
name|as_warn
argument_list|(
literal|"Found '}' when manual bundling is off"
argument_list|)
expr_stmt|;
else|else
name|PREV_SLOT
operator|.
name|manual_bundling_off
operator|=
literal|1
expr_stmt|;
name|md
operator|.
name|manual_bundling
operator|=
literal|0
expr_stmt|;
comment|/* switch back to automatic mode, if applicable */
if|if
condition|(
name|md
operator|.
name|detect_dv
operator|&&
name|md
operator|.
name|explicit_mode
operator|&&
operator|!
name|md
operator|.
name|mode_explicitly_set
operator|&&
operator|!
name|md
operator|.
name|default_explicit_mode
condition|)
name|dot_dv_mode
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is a hook for ia64_frob_label, so that it can distinguish tags from    labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defining_tag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ia64_unrecognized_line
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'('
case|:
name|expression_and_evaluate
argument_list|(
operator|&
name|md
operator|.
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected ')'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
literal|"Qualifying predicate expected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_add_number
operator|<
name|REG_P
operator|||
name|md
operator|.
name|qp
operator|.
name|X_add_number
operator|>=
name|REG_P
operator|+
literal|64
condition|)
block|{
name|as_bad
argument_list|(
literal|"Predicate register expected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
literal|'['
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|symbolS
modifier|*
name|tag
decl_stmt|;
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
literal|"Tag must come before qualifying predicate."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This implements just enough of read_a_source_file in read.c to 	   recognize labels.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|temp
operator|=
operator|(
name|temp
operator|*
literal|10
operator|)
operator|+
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
name|fb_label_instance_inc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|s
operator|=
name|fb_label_name
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
comment|/* Put ':' back for error messages' sake.  */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected ':'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|defining_tag
operator|=
literal|1
expr_stmt|;
name|tag
operator|=
name|colon
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|defining_tag
operator|=
literal|0
expr_stmt|;
comment|/* Put ':' back for error messages' sake.  */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected ']'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|as_bad
argument_list|(
literal|"Tag name expected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
default|default:
break|break;
block|}
comment|/* Not a valid line.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ia64_frob_label
parameter_list|(
name|sym
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|label_fix
modifier|*
name|fix
decl_stmt|;
comment|/* Tags need special handling since they are not bundle breaks like      labels.  */
if|if
condition|(
name|defining_tag
condition|)
block|{
name|fix
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
expr_stmt|;
name|fix
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|CURR_SLOT
operator|.
name|tag_fixups
expr_stmt|;
name|fix
operator|->
name|dw2_mark_labels
operator|=
name|FALSE
expr_stmt|;
name|CURR_SLOT
operator|.
name|tag_fixups
operator|=
name|fix
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
name|md
operator|.
name|last_text_seg
operator|=
name|now_seg
expr_stmt|;
name|fix
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
expr_stmt|;
name|fix
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|CURR_SLOT
operator|.
name|label_fixups
expr_stmt|;
name|fix
operator|->
name|dw2_mark_labels
operator|=
name|dwarf2_loc_mark_labels
expr_stmt|;
name|CURR_SLOT
operator|.
name|label_fixups
operator|=
name|fix
expr_stmt|;
comment|/* Keep track of how many code entry points we've seen.  */
if|if
condition|(
name|md
operator|.
name|path
operator|==
name|md
operator|.
name|maxpaths
condition|)
block|{
name|md
operator|.
name|maxpaths
operator|+=
literal|20
expr_stmt|;
name|md
operator|.
name|entry_labels
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|md
operator|.
name|entry_labels
argument_list|,
name|md
operator|.
name|maxpaths
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|entry_labels
index|[
name|md
operator|.
name|path
operator|++
index|]
operator|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TE_HPUX
end_ifdef

begin_comment
comment|/* The HP-UX linker will give unresolved symbol errors for symbols    that are declared but unused.  This routine removes declared,    unused symbols from an object.  */
end_comment

begin_function
name|int
name|ia64_frob_symbol
parameter_list|(
name|sym
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
operator|&
name|bfd_und_section
operator|&&
operator|!
name|symbol_used_p
argument_list|(
name|sym
argument_list|)
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|S_GET_OTHER
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|STV_DEFAULT
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
operator|&
name|bfd_abs_section
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ia64_flush_pending_output
parameter_list|()
block|{
if|if
condition|(
operator|!
name|md
operator|.
name|keep_pending_output
operator|&&
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
comment|/* ??? This causes many unnecessary stop bits to be emitted. 	 Unfortunately, it isn't clear if it is safe to remove this.  */
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ia64_flush_insns
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do ia64-specific expression optimization.  All that's done here is    to transform index expressions that are either due to the indexing    of rotating registers or due to the indexing of indirect register    sets.  */
end_comment

begin_function
name|int
name|ia64_optimize_expr
parameter_list|(
name|l
parameter_list|,
name|op
parameter_list|,
name|r
parameter_list|)
name|expressionS
modifier|*
name|l
decl_stmt|;
name|operatorT
name|op
decl_stmt|;
name|expressionS
modifier|*
name|r
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|!=
name|O_index
condition|)
return|return
literal|0
return|;
name|resolve_expression
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
name|unsigned
name|num_regs
init|=
name|l
operator|->
name|X_add_number
operator|>>
literal|16
decl_stmt|;
name|resolve_expression
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_regs
condition|)
block|{
comment|/* Left side is a .rotX-allocated register.  */
if|if
condition|(
name|r
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Rotating register index must be a non-negative constant"
argument_list|)
expr_stmt|;
name|r
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|valueT
operator|)
name|r
operator|->
name|X_add_number
operator|>=
name|num_regs
condition|)
block|{
name|as_bad
argument_list|(
literal|"Index out of range 0..%u"
argument_list|,
name|num_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|l
operator|->
name|X_add_number
operator|=
operator|(
name|l
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|+
name|r
operator|->
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|l
operator|->
name|X_add_number
operator|>=
name|IND_CPUID
operator|&&
name|l
operator|->
name|X_add_number
operator|<=
name|IND_RR
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|X_op
operator|!=
name|O_register
operator|||
name|r
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|||
name|r
operator|->
name|X_add_number
operator|>
name|REG_GR
operator|+
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"Indirect register index must be a general register"
argument_list|)
expr_stmt|;
name|r
operator|->
name|X_add_number
operator|=
name|REG_GR
expr_stmt|;
block|}
name|l
operator|->
name|X_op
operator|=
name|O_index
expr_stmt|;
name|l
operator|->
name|X_op_symbol
operator|=
name|md
operator|.
name|indregsym
index|[
name|l
operator|->
name|X_add_number
operator|-
name|IND_CPUID
index|]
expr_stmt|;
name|l
operator|->
name|X_add_number
operator|=
name|r
operator|->
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|as_bad
argument_list|(
literal|"Index can only be applied to rotating or indirect registers"
argument_list|)
expr_stmt|;
comment|/* Fall back to some register use of which has as little as possible      side effects, to minimize subsequent error messages.  */
name|l
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|l
operator|->
name|X_add_number
operator|=
name|REG_GR
operator|+
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ia64_parse_name
parameter_list|(
name|name
parameter_list|,
name|e
parameter_list|,
name|nextcharP
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|expressionS
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|nextcharP
decl_stmt|;
block|{
name|struct
name|const_desc
modifier|*
name|cdesc
decl_stmt|;
name|struct
name|dynreg
modifier|*
name|dr
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
block|{
name|enum
name|pseudo_type
name|pseudo_type
init|=
name|PSEUDO_FUNC_NONE
decl_stmt|;
comment|/* Find what relocation pseudo-function we're dealing with.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|NELEMS
argument_list|(
name|pseudo_func
argument_list|)
condition|;
operator|++
name|idx
control|)
if|if
condition|(
name|pseudo_func
index|[
name|idx
index|]
operator|.
name|name
operator|&&
name|pseudo_func
index|[
name|idx
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|1
index|]
operator|&&
name|strcmp
argument_list|(
name|pseudo_func
index|[
name|idx
index|]
operator|.
name|name
operator|+
literal|1
argument_list|,
name|name
operator|+
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pseudo_type
operator|=
name|pseudo_func
index|[
name|idx
index|]
operator|.
name|type
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|pseudo_type
condition|)
block|{
case|case
name|PSEUDO_FUNC_RELOC
case|:
name|end
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|nextcharP
operator|!=
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected '('"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Skip '('.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing ')'"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Skip ')'.  */
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_pseudo_fixup
condition|)
block|{
name|as_bad
argument_list|(
literal|"Not a symbolic expression"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|idx
operator|!=
name|FUNC_LT_RELATIVE
condition|)
block|{
name|as_bad
argument_list|(
literal|"Illegal combination of relocation functions"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|S_GET_VALUE
argument_list|(
name|e
operator|->
name|X_op_symbol
argument_list|)
condition|)
block|{
case|case
name|FUNC_FPTR_RELATIVE
case|:
name|idx
operator|=
name|FUNC_LT_FPTR_RELATIVE
expr_stmt|;
break|break;
case|case
name|FUNC_DTP_MODULE
case|:
name|idx
operator|=
name|FUNC_LT_DTP_MODULE
expr_stmt|;
break|break;
case|case
name|FUNC_DTP_RELATIVE
case|:
name|idx
operator|=
name|FUNC_LT_DTP_RELATIVE
expr_stmt|;
break|break;
case|case
name|FUNC_TP_RELATIVE
case|:
name|idx
operator|=
name|FUNC_LT_TP_RELATIVE
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Illegal combination of relocation functions"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Make sure gas doesn't get rid of local symbols that are used 	     in relocs.  */
name|e
operator|->
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|e
operator|->
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|idx
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|done
label|:
operator|*
name|nextcharP
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
break|break;
case|case
name|PSEUDO_FUNC_CONST
case|:
name|e
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|pseudo_func
index|[
name|idx
index|]
operator|.
name|u
operator|.
name|ival
expr_stmt|;
break|break;
case|case
name|PSEUDO_FUNC_REG
case|:
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|pseudo_func
index|[
name|idx
index|]
operator|.
name|u
operator|.
name|ival
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* first see if NAME is a known register name:  */
name|sym
operator|=
name|hash_find
argument_list|(
name|md
operator|.
name|reg_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|cdesc
operator|=
name|hash_find
argument_list|(
name|md
operator|.
name|const_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
condition|)
block|{
name|e
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|cdesc
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* check for inN, locN, or outN:  */
name|idx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|dr
operator|=
operator|&
name|md
operator|.
name|in
expr_stmt|;
name|idx
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|dr
operator|=
operator|&
name|md
operator|.
name|loc
expr_stmt|;
name|idx
operator|=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'u'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|dr
operator|=
operator|&
name|md
operator|.
name|out
expr_stmt|;
name|idx
operator|=
literal|3
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Ignore register numbers with leading zeroes, except zero itself.  */
if|if
condition|(
name|dr
operator|&&
operator|(
name|name
index|[
name|idx
index|]
operator|!=
literal|'0'
operator|||
name|name
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|unsigned
name|long
name|regnum
decl_stmt|;
comment|/* The name is inN, locN, or outN; parse the register number.  */
name|regnum
operator|=
name|strtoul
argument_list|(
name|name
operator|+
name|idx
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|name
operator|+
name|idx
operator|&&
operator|*
name|end
operator|==
literal|'\0'
operator|&&
name|regnum
operator|<
literal|96
condition|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|dr
operator|->
name|num_regs
condition|)
block|{
if|if
condition|(
operator|!
name|dr
operator|->
name|num_regs
condition|)
name|as_bad
argument_list|(
literal|"No current frame"
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Register number out of range 0..%u"
argument_list|,
name|dr
operator|->
name|num_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|regnum
operator|=
literal|0
expr_stmt|;
block|}
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|dr
operator|->
name|base
operator|+
name|regnum
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|end
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|end
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|ia64_canonicalize_symbol_name
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dr
operator|=
name|hash_find
argument_list|(
name|md
operator|.
name|dynreg_hash
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
comment|/* We've got ourselves the name of a rotating register set. 	 Store the base register number in the low 16 bits of 	 X_add_number and the size of the register set in the top 16 	 bits.  */
name|e
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|dr
operator|->
name|base
operator||
operator|(
name|dr
operator|->
name|num_regs
operator|<<
literal|16
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove the '#' suffix that indicates a symbol as opposed to a register.  */
end_comment

begin_function
name|char
modifier|*
name|ia64_canonicalize_symbol_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|,
name|full
init|=
name|len
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'#'
condition|)
operator|--
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|full
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Standalone `#' is illegal"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
name|full
operator|-
literal|1
condition|)
name|as_warn
argument_list|(
literal|"Redundant `#' suffix operators"
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return true if idesc is a conditional branch instruction.  This excludes    the modulo scheduled branches, and br.ia.  Mod-sched branches are excluded    because they always read/write resources regardless of the value of the    qualifying predicate.  br.ia must always use p0, and hence is always    taken.  Thus this function returns true for branches which can fall    through, and which use no resources if they do fall through.  */
end_comment

begin_function
specifier|static
name|int
name|is_conditional_branch
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
comment|/* br is a conditional branch.  Everything that starts with br. except      br.ia, br.c{loop,top,exit}, and br.w{top,exit} is a conditional branch.      Everything that starts with brl is a conditional branch.  */
return|return
operator|(
name|idesc
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
operator|(
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|!=
literal|'i'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|!=
literal|'c'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|!=
literal|'w'
operator|)
operator|||
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'l'
comment|/* br.cond, br.call, br.clr  */
operator|||
operator|(
name|idesc
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|'c'
operator|&&
operator|(
name|idesc
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'a'
operator|||
name|idesc
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'o'
operator|||
operator|(
name|idesc
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'l'
operator|&&
name|idesc
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'r'
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether the given opcode is a taken branch.  If there's any doubt,    returns zero.  */
end_comment

begin_function
specifier|static
name|int
name|is_taken_branch
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|is_conditional_branch
argument_list|(
name|idesc
argument_list|)
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|0
operator|)
operator|||
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br.ia"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether the given opcode is an interruption or rfi.  If there's any    doubt, returns zero.  */
end_comment

begin_function
specifier|static
name|int
name|is_interruption_or_rfi
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"rfi"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the index of the given dependency in the opcode's list of chks, or    -1 if there is no dependency.  */
end_comment

begin_function
specifier|static
name|int
name|depends_on
parameter_list|(
name|depind
parameter_list|,
name|idesc
parameter_list|)
name|int
name|depind
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|ia64_opcode_dependency
modifier|*
name|dep
init|=
name|idesc
operator|->
name|dependencies
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dep
operator|->
name|nchks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|depind
operator|==
name|DEP
argument_list|(
name|dep
operator|->
name|chks
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine a set of specific resources used for a particular resource    class.  Returns the number of specific resources identified  For those    cases which are not determinable statically, the resource returned is    marked nonspecific.     Meanings of value in 'NOTE':    1) only read/write when the register number is explicitly encoded in the    insn.    2) only read CFM when accessing a rotating GR, FR, or PR.  mov pr only    accesses CFM when qualifying predicate is in the rotating region.    3) general register value is used to specify an indirect register; not    determinable statically.    4) only read the given resource when bits 7:0 of the indirect index    register value does not match the register number of the resource; not    determinable statically.    5) all rules are implementation specific.    6) only when both the index specified by the reader and the index specified    by the writer have the same value in bits 63:61; not determinable    statically.    7) only access the specified resource when the corresponding mask bit is    set    8) PSR.dfh is only read when these insns reference FR32-127.  PSR.dfl is    only read when these insns reference FR2-31    9) PSR.mfl is only written when these insns write FR2-31.  PSR.mfh is only    written when these insns write FR32-127    10) The PSR.bn bit is only accessed when one of GR16-31 is specified in the    instruction    11) The target predicates are written independently of PR[qp], but source    registers are only read if PR[qp] is true.  Since the state of PR[qp]    cannot statically be determined, all source registers are marked used.    12) This insn only reads the specified predicate register when that    register is the PR[qp].    13) This reference to ld-c only applies to teh GR whose value is loaded    with data returned from memory, not the post-incremented address register.    14) The RSE resource includes the implementation-specific RSE internal    state resources.  At least one (and possibly more) of these resources are    read by each instruction listed in IC:rse-readers.  At least one (and    possibly more) of these resources are written by each insn listed in    IC:rse-writers.    15+16) Represents reserved instructions, which the assembler does not    generate.    17) CR[TPR] has a RAW dependency only between mov-to-CR-TPR and    mov-to-PSR-l or ssm instructions that set PSR.i, PSR.pp or PSR.up.     Memory resources (i.e. locations in memory) are *not* marked or tracked by    this code; there are no dependency violations based on memory access. */
end_comment

begin_define
define|#
directive|define
name|MAX_SPECS
value|256
end_define

begin_define
define|#
directive|define
name|DV_CHK
value|1
end_define

begin_define
define|#
directive|define
name|DV_REG
value|0
end_define

begin_function
specifier|static
name|int
name|specify_resource
parameter_list|(
name|dep
parameter_list|,
name|idesc
parameter_list|,
name|type
parameter_list|,
name|specs
parameter_list|,
name|note
parameter_list|,
name|path
parameter_list|)
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* is this a DV chk or a DV reg? */
name|struct
name|rsrc
name|specs
index|[
name|MAX_SPECS
index|]
decl_stmt|;
comment|/* returned specific resources */
name|int
name|note
decl_stmt|;
comment|/* resource note for this insn's usage */
name|int
name|path
decl_stmt|;
comment|/* which execution path to examine */
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rsrc_write
init|=
literal|0
decl_stmt|;
name|struct
name|rsrc
name|tmpl
decl_stmt|;
if|if
condition|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_WAW
operator|||
operator|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_RAW
operator|&&
name|type
operator|==
name|DV_REG
operator|)
operator|||
operator|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_WAR
operator|&&
name|type
operator|==
name|DV_CHK
operator|)
condition|)
name|rsrc_write
operator|=
literal|1
expr_stmt|;
comment|/* template for any resources we identify */
name|tmpl
operator|.
name|dependency
operator|=
name|dep
expr_stmt|;
name|tmpl
operator|.
name|note
operator|=
name|note
expr_stmt|;
name|tmpl
operator|.
name|insn_srlz
operator|=
name|tmpl
operator|.
name|data_srlz
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|qp_regno
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
name|tmpl
operator|.
name|link_to_qp_branch
operator|=
literal|1
expr_stmt|;
name|tmpl
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|mem_offset
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|mem_offset
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|specific
operator|=
literal|1
expr_stmt|;
name|tmpl
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|tmpl
operator|.
name|cmp_type
operator|=
name|CMP_NONE
expr_stmt|;
name|tmpl
operator|.
name|depind
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|file
operator|=
name|NULL
expr_stmt|;
name|tmpl
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|.
name|path
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|UNHANDLED
define|\
value|as_warn (_("Unhandled dependency %s for %s (%s), note %d"), \ dep->name, idesc->name, (rsrc_write?"write":"read"), note)
define|#
directive|define
name|KNOWN
parameter_list|(
name|REG
parameter_list|)
value|(gr_values[REG].known&& gr_values[REG].path>= path)
comment|/* we don't need to track these */
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_NONE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|dep
operator|->
name|specifier
condition|)
block|{
case|case
name|IA64_RS_AR_K
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<=
literal|7
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_AR_UNAT
case|:
comment|/* This is a mov =AR or mov AR= instruction.  */
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|AR_UNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a spill/fill, or other instruction that modifies the 	     unat register.  */
comment|/* Unless we can determine the specific bits used, mark the whole 	     thing; bits 8:3 of the memory address indicate the bit used in 	     UNAT.  The .mem.offset hint may be used to eliminate a small 	     subset of conflicts.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|mem_offset
operator|.
name|hint
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Using hint for spill/fill\n"
argument_list|)
expr_stmt|;
comment|/* The index isn't actually used, just set it to something 		 approximating the bit index.  */
name|specs
index|[
name|count
index|]
operator|.
name|index
operator|=
operator|(
name|md
operator|.
name|mem_offset
operator|.
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|1
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|offset
operator|=
name|md
operator|.
name|mem_offset
operator|.
name|offset
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|mem_offset
operator|.
name|base
operator|=
name|md
operator|.
name|mem_offset
operator|.
name|base
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IA64_RS_AR
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
literal|8
operator|&&
name|regno
operator|<=
literal|15
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|20
operator|&&
name|regno
operator|<=
literal|23
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|31
operator|&&
name|regno
operator|<=
literal|39
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|41
operator|&&
name|regno
operator|<=
literal|47
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|67
operator|&&
name|regno
operator|<=
literal|111
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_ARb
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
literal|48
operator|&&
name|regno
operator|<=
literal|63
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|112
operator|&&
name|regno
operator|<=
literal|127
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|48
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|112
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_BR
case|:
if|if
condition|(
name|note
operator|!=
literal|1
condition|)
block|{
name|UNHANDLED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B2
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_BR
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|idesc
operator|->
name|num_outputs
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_B2
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_BR
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|IA64_RS_CPUID
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CPUID_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_DBR
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_DBR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
operator|&&
operator|!
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_IBR
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_IBR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_MSR
case|:
if|if
condition|(
name|note
operator|==
literal|5
condition|)
block|{
comment|/* These are implementation specific.  Force all references to 	     conflict with all other references.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PKR
case|:
comment|/* 16 or more registers */
if|if
condition|(
name|note
operator|==
literal|3
operator|||
name|note
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PKR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Uses all registers *except* the one in R3.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|!=
operator|(
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
comment|/* probe et al.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PMC
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PMC_R3
operator|||
operator|(
operator|!
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PMD_R3
operator|)
condition|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_R3
operator|&&
operator|!
name|rsrc_write
operator|)
condition|?
literal|1
else|:
operator|!
name|rsrc_write
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|index
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PMD
case|:
comment|/* four or more registers */
if|if
condition|(
name|note
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PMD_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_RR
case|:
comment|/* eight registers */
if|if
condition|(
name|note
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_RR_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
operator|&&
name|KNOWN
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
operator|(
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|>>
literal|61
operator|)
operator|&
literal|0x7
expr_stmt|;
block|}
else|else
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|0
operator|&&
operator|!
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CR_IRR
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
comment|/* handle mov-from-CR-IVR; it's a read that writes CR[IRR] */
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|regno
operator|==
name|CR_IVR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CR_IRR0
operator|+
name|i
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|regno
operator|>=
name|CR_IRR0
operator|&&
name|regno
operator|<=
name|CR_IRR3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CR_LRR
case|:
if|if
condition|(
name|note
operator|!=
literal|1
condition|)
block|{
name|UNHANDLED
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
operator|(
name|regno
operator|==
name|CR_LRR0
operator|||
name|regno
operator|==
name|CR_LRR1
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IA64_RS_CR
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_FR
case|:
case|case
name|IA64_RS_FRb
case|:
if|if
condition|(
name|note
operator|!=
literal|1
condition|)
block|{
name|UNHANDLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsrc_write
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_FRb
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_F1
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|idesc
operator|->
name|num_outputs
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F4
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|IA64_RS_GR
case|:
if|if
condition|(
name|note
operator|==
literal|13
condition|)
block|{
comment|/* This reference applies only to the GR whose value is loaded with 	     data returned from memory.  */
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_POSTINC
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MR3
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look for anything that reads a GR.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MR3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_CPUID_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_DBR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_IBR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_MSR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PKR_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PMC_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PMD_R3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_RR_R3
operator|||
operator|(
operator|(
name|i
operator|>=
name|idesc
operator|->
name|num_outputs
operator|)
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
comment|/* addl source register.  */
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3_2
operator|)
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
comment|/* This is the same as IA64_RS_PRr, except that the register range is 	 from 1 - 15, and there are no rotating register reads/writes here.  */
case|case
name|IA64_RS_PR
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
comment|/* Mark only those registers indicated by the mask.  */
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|11
condition|)
comment|/* note 11 implies note 1 as well */
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|1
operator|&&
name|regno
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|1
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|or_andcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or.andcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|and_orcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and.orcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p1
operator|>=
literal|1
operator|&&
name|p1
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_OR
else|:
operator|(
name|and_orcm
condition|?
name|CMP_AND
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p2
operator|>=
literal|1
operator|&&
name|p2
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_AND
else|:
operator|(
name|and_orcm
condition|?
name|CMP_OR
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|1
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|16
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
comment|/* This is the general case for PRs.  IA64_RS_PR and IA64_RS_PR63 are 	 simplified cases of this.  */
case|case
name|IA64_RS_PRr
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
comment|/* Mark only those registers indicated by the mask.  */
if|if
condition|(
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
literal|16
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rsrc_write
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PR_ROT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|11
condition|)
comment|/* note 11 implies note 1 as well */
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|16
operator|&&
name|regno
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|regno
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|16
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|or_andcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or.andcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|and_orcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and.orcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p1
operator|>=
literal|16
operator|&&
name|p1
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_OR
else|:
operator|(
name|and_orcm
condition|?
name|CMP_AND
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
name|p2
operator|>=
literal|16
operator|&&
name|p2
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_AND
else|:
operator|(
name|and_orcm
condition|?
name|CMP_OR
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|p2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>=
literal|16
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|<
literal|63
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|CURR_SLOT
operator|.
name|qp_regno
expr_stmt|;
block|}
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_PSR
case|:
comment|/* Verify that the instruction is using the PSR bit indicated in 	 dep->regindex.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PSR_UM
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|regindex
operator|<
literal|6
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PSR
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|regindex
operator|<
literal|32
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|35
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|36
operator|||
operator|(
operator|!
name|rsrc_write
operator|&&
name|dep
operator|->
name|regindex
operator|==
name|PSR_CPL
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_PSR_L
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|regindex
operator|<
literal|32
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|35
operator|||
name|dep
operator|->
name|regindex
operator|==
literal|36
operator|||
operator|(
name|rsrc_write
operator|&&
name|dep
operator|->
name|regindex
operator|==
name|PSR_CPL
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Several PSR bits have very specific dependencies.  */
switch|switch
condition|(
name|dep
operator|->
name|regindex
condition|)
block|{
default|default:
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
break|break;
case|case
name|PSR_IC
case|:
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
comment|/* Only certain CR accesses use PSR.ic */
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_CR3
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_CR3
condition|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_CR3
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|index
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
default|default:
break|break;
case|case
name|CR_ITIR
case|:
case|case
name|CR_IFS
case|:
case|case
name|CR_IIM
case|:
case|case
name|CR_IIP
case|:
case|case
name|CR_IPSR
case|:
case|case
name|CR_ISR
case|:
case|case
name|CR_IFA
case|:
case|case
name|CR_IHA
case|:
case|case
name|CR_IIPA
case|:
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|PSR_CPL
case|:
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
comment|/* Only some AR accesses use cpl */
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|index
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|AR_ITC
operator|||
operator|(
name|index
operator|==
literal|0
operator|&&
operator|(
name|regno
operator|==
name|AR_ITC
operator|||
name|regno
operator|==
name|AR_RSC
operator|||
operator|(
name|regno
operator|>=
name|AR_K0
operator|&&
name|regno
operator|<=
name|AR_K7
operator|)
operator|)
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_IMMU24
condition|)
block|{
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|dep
operator|->
name|regindex
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|8
condition|)
block|{
name|int
name|min
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_DFL
condition|?
literal|2
else|:
literal|32
decl_stmt|;
name|int
name|max
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_DFL
condition|?
literal|31
else|:
literal|127
decl_stmt|;
comment|/* dfh is read on FR32-127; dfl is read on FR2-31 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F4
condition|)
block|{
name|int
name|reg
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
name|min
operator|&&
name|reg
operator|<=
name|max
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|9
condition|)
block|{
name|int
name|min
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_MFL
condition|?
literal|2
else|:
literal|32
decl_stmt|;
name|int
name|max
init|=
name|dep
operator|->
name|regindex
operator|==
name|PSR_MFL
condition|?
literal|31
else|:
literal|127
decl_stmt|;
comment|/* mfh is read on writes to FR32-127; mfl is read on writes to 	     FR2-31 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F1
condition|)
block|{
name|int
name|reg
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
name|min
operator|&&
name|reg
operator|<=
name|max
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|10
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|16
operator|&&
name|regno
operator|<=
literal|31
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_AR_FPSR
case|:
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|AR_FPSR
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_ARX
case|:
comment|/* Handle all AR[REG] resources */
if|if
condition|(
name|note
operator|==
literal|0
operator|||
name|note
operator|==
literal|1
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_AR3
operator|&&
name|regno
operator|==
name|dep
operator|->
name|regindex
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
comment|/* other AR[REG] resources may be affected by AR accesses */
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
comment|/* AR[] writes */
name|regno
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
expr_stmt|;
switch|switch
condition|(
name|dep
operator|->
name|regindex
condition|)
block|{
default|default:
break|break;
case|case
name|AR_BSP
case|:
case|case
name|AR_RNAT
case|:
if|if
condition|(
name|regno
operator|==
name|AR_BSPSTORE
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
case|case
name|AR_RSC
case|:
if|if
condition|(
operator|!
name|rsrc_write
operator|&&
operator|(
name|regno
operator|==
name|AR_BSPSTORE
operator|||
name|regno
operator|==
name|AR_RNAT
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
comment|/* AR[] reads */
name|regno
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
expr_stmt|;
switch|switch
condition|(
name|dep
operator|->
name|regindex
condition|)
block|{
default|default:
break|break;
case|case
name|AR_RSC
case|:
if|if
condition|(
name|regno
operator|==
name|AR_BSPSTORE
operator|||
name|regno
operator|==
name|AR_RNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CRX
case|:
comment|/* Handle all CR[REG] resources. 	 ??? FIXME: The rule 17 isn't really handled correctly.   */
if|if
condition|(
name|note
operator|==
literal|0
operator|||
name|note
operator|==
literal|1
operator|||
name|note
operator|==
literal|17
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
operator|!
name|rsrc_write
index|]
operator|==
name|IA64_OPND_CR3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
operator|!
name|rsrc_write
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|dep
operator|->
name|regindex
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rsrc_write
condition|)
block|{
comment|/* Reads from CR[IVR] affect other resources.  */
if|if
condition|(
name|regno
operator|==
name|CR_IVR
condition|)
block|{
if|if
condition|(
operator|(
name|dep
operator|->
name|regindex
operator|>=
name|CR_IRR0
operator|&&
name|dep
operator|->
name|regindex
operator|<=
name|CR_IRR3
operator|)
operator|||
name|dep
operator|->
name|regindex
operator|==
name|CR_TPR
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_INSERVICE
case|:
comment|/* look for write of EOI (67) or read of IVR (65) */
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
operator|==
name|CR_EOI
operator|)
operator|||
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_CR3
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_CR
operator|==
name|CR_IVR
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_GR0
case|:
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_CFM
case|:
if|if
condition|(
name|note
operator|!=
literal|2
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if any of the registers accessed are in the rotating region. 	     mov to/from pr accesses CFM only when qp_regno is in the rotating 	     region */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|idesc
operator|->
name|operands
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|int
name|num
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
comment|/* Assumes that md.rot.num_regs is always valid */
if|if
condition|(
name|md
operator|.
name|rot
operator|.
name|num_regs
operator|>
literal|0
operator|&&
name|num
operator|>
literal|31
operator|&&
name|num
operator|<
literal|31
operator|+
name|md
operator|.
name|rot
operator|.
name|num_regs
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F3
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_F4
condition|)
block|{
name|int
name|num
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_FR
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|31
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|num
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|15
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|>
literal|15
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|specific
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
comment|/* This is the same as IA64_RS_PRr, except simplified to account for 	 the fact that there is only one register.  */
case|case
name|IA64_RS_PR63
case|:
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|7
condition|)
block|{
name|valueT
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|==
name|IA64_OPND_IMM17
condition|)
name|mask
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
literal|63
operator|)
condition|)
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|11
condition|)
block|{
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
operator|==
literal|63
operator|)
operator|||
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
operator|==
literal|63
operator|)
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|63
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|note
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|or_andcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or.andcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|and_orcm
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and.orcm"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
if|if
condition|(
name|p1
operator|==
literal|63
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_OR
else|:
operator|(
name|and_orcm
condition|?
name|CMP_AND
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p2
operator|==
literal|63
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
condition|)
block|{
name|specs
index|[
name|count
index|]
operator|=
name|tmpl
expr_stmt|;
name|specs
index|[
name|count
operator|++
index|]
operator|.
name|cmp_type
operator|=
operator|(
name|or_andcm
condition|?
name|CMP_AND
else|:
operator|(
name|and_orcm
condition|?
name|CMP_OR
else|:
name|CMP_NONE
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|63
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_RSE
case|:
comment|/* FIXME we can identify some individual RSE written resources, but RSE 	 read resources have not yet been completely identified, so for now 	 treat RSE as a single resource */
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rsrc_write
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSPSTORE
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSPSTORE
operator|||
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_RNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSP
operator|||
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_BSPSTORE
operator|||
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
operator|==
name|AR_RNAT
condition|)
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
block|}
break|break;
case|case
name|IA64_RS_ANY
case|:
comment|/* FIXME -- do any of these need to be non-specific? */
name|specs
index|[
name|count
operator|++
index|]
operator|=
name|tmpl
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized dependency specifier %d\n"
argument_list|)
argument_list|,
name|dep
operator|->
name|specifier
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Clear branch flags on marked resources.  This breaks the link between the    QP of the marking instruction and a subsequent branch on the same QP.  */
end_comment

begin_function
specifier|static
name|void
name|clear_qp_branch_flag
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regdepslen
condition|;
name|i
operator|++
control|)
block|{
name|valueT
name|bit
init|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|regdeps
index|[
name|i
index|]
operator|.
name|qp_regno
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|bit
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|regdeps
index|[
name|i
index|]
operator|.
name|link_to_qp_branch
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* MASK contains 2 and only 2 PRs which are mutually exclusive.  Remove    any mutexes which contain one of the PRs and create new ones when    needed.  */
end_comment

begin_function
specifier|static
name|int
name|update_qp_mutex
parameter_list|(
name|valueT
name|mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|add
init|=
literal|0
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|qp_mutexeslen
condition|)
block|{
if|if
condition|(
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If it destroys and creates the same mutex, do nothing.  */
if|if
condition|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|==
name|mask
operator|&&
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|path
operator|==
name|md
operator|.
name|path
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|add
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|keep
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Clearing mutex relation"
argument_list|)
expr_stmt|;
name|print_prmask
argument_list|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with the old mutex with more than 3+ PRs only if 		 the new mutex on the same execution path with it.  		 FIXME: The 3+ mutex support is incomplete. 		 dot_pred_rel () may be a better place to fix it.  */
if|if
condition|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|path
operator|==
name|md
operator|.
name|path
condition|)
block|{
comment|/* If it is a proper subset of the mutex, create a 		     new mutex.  */
if|if
condition|(
name|add
operator|==
literal|0
operator|&&
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
name|add
operator|=
literal|1
expr_stmt|;
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&=
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Modify the mutex if there are more than one 			 PR left.  */
name|keep
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|keep
operator|==
literal|0
condition|)
comment|/* Remove the mutex.  */
name|qp_mutexes
index|[
name|i
index|]
operator|=
name|qp_mutexes
index|[
operator|--
name|qp_mutexeslen
index|]
expr_stmt|;
block|}
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|add
operator|==
literal|1
condition|)
name|add_qp_mutex
argument_list|(
name|mask
argument_list|)
expr_stmt|;
return|return
name|add
return|;
block|}
end_function

begin_comment
comment|/* Remove any mutexes which contain any of the PRs indicated in the mask.     Any changes to a PR clears the mutex relations which include that PR.  */
end_comment

begin_function
specifier|static
name|void
name|clear_qp_mutex
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|qp_mutexeslen
condition|)
block|{
if|if
condition|(
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Clearing mutex relation"
argument_list|)
expr_stmt|;
name|print_prmask
argument_list|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|qp_mutexes
index|[
name|i
index|]
operator|=
name|qp_mutexes
index|[
operator|--
name|qp_mutexeslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear implies relations which contain PRs in the given masks.    P1_MASK indicates the source of the implies relation, while P2_MASK    indicates the implied PR.  */
end_comment

begin_function
specifier|static
name|void
name|clear_qp_implies
parameter_list|(
name|p1_mask
parameter_list|,
name|p2_mask
parameter_list|)
name|valueT
name|p1_mask
decl_stmt|;
name|valueT
name|p2_mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|qp_implieslen
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
operator|)
operator|&
name|p1_mask
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|)
operator|&
name|p2_mask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Clearing implied relation PR%d->PR%d\n"
argument_list|,
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
argument_list|,
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
argument_list|)
expr_stmt|;
name|qp_implies
index|[
name|i
index|]
operator|=
name|qp_implies
index|[
operator|--
name|qp_implieslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add the PRs specified to the list of implied relations.  */
end_comment

begin_function
specifier|static
name|void
name|add_qp_imply
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
name|valueT
name|mask
decl_stmt|;
name|valueT
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* p0 is not meaningful here.  */
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p2
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return;
comment|/* If it exists already, ignore it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_implieslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
operator|==
name|p1
operator|&&
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|==
name|p2
operator|&&
name|qp_implies
index|[
name|i
index|]
operator|.
name|path
operator|==
name|md
operator|.
name|path
operator|&&
operator|!
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2_branched
condition|)
return|return;
block|}
if|if
condition|(
name|qp_implieslen
operator|==
name|qp_impliestotlen
condition|)
block|{
name|qp_impliestotlen
operator|+=
literal|20
expr_stmt|;
name|qp_implies
operator|=
operator|(
expr|struct
name|qp_imply
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|qp_implies
argument_list|,
name|qp_impliestotlen
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|qp_imply
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Registering PR%d implies PR%d\n"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
index|]
operator|.
name|p1
operator|=
name|p1
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
index|]
operator|.
name|p2
operator|=
name|p2
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
name|qp_implies
index|[
name|qp_implieslen
operator|++
index|]
operator|.
name|p2_branched
operator|=
literal|0
expr_stmt|;
comment|/* Add in the implied transitive relations; for everything that p2 implies,      make p1 imply that, too; for everything that implies p1, make it imply p2      as well.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_implieslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
operator|==
name|p2
condition|)
name|add_qp_imply
argument_list|(
name|p1
argument_list|,
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|==
name|p1
condition|)
name|add_qp_imply
argument_list|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
comment|/* Add in mutex relations implied by this implies relation; for each mutex      relation containing p2, duplicate it and replace p2 with p1.  */
name|bit
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p1
expr_stmt|;
name|mask
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_mutexeslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
condition|)
name|add_qp_mutex
argument_list|(
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
operator|~
name|mask
operator|)
operator||
name|bit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add the PRs specified in the mask to the mutex list; this means that only    one of the PRs can be true at any time.  PR0 should never be included in    the mask.  */
end_comment

begin_function
specifier|static
name|void
name|add_qp_mutex
parameter_list|(
name|mask
parameter_list|)
name|valueT
name|mask
decl_stmt|;
block|{
if|if
condition|(
name|mask
operator|&
literal|0x1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|qp_mutexeslen
operator|==
name|qp_mutexestotlen
condition|)
block|{
name|qp_mutexestotlen
operator|+=
literal|20
expr_stmt|;
name|qp_mutexes
operator|=
operator|(
expr|struct
name|qpmutex
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|qp_mutexes
argument_list|,
name|qp_mutexestotlen
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|qpmutex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Registering mutex on"
argument_list|)
expr_stmt|;
name|print_prmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|qp_mutexes
index|[
name|qp_mutexeslen
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
name|qp_mutexes
index|[
name|qp_mutexeslen
operator|++
index|]
operator|.
name|prmask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|has_suffix_p
parameter_list|(
name|name
parameter_list|,
name|suffix
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|size_t
name|sufflen
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|<=
name|sufflen
condition|)
return|return
literal|0
return|;
return|return
name|strcmp
argument_list|(
name|name
operator|+
name|namelen
operator|-
name|sufflen
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_register_values
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Clearing register values\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|;
name|i
operator|++
control|)
name|gr_values
index|[
name|i
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep track of register values/changes which affect DV tracking.     optimization note: should add a flag to classes of insns where otherwise we    have to examine a group of strings to identify them.  */
end_comment

begin_function
specifier|static
name|void
name|note_register_values
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|valueT
name|qp_changemask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Invalidate values for registers being written to.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idesc
operator|->
name|num_outputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|)
name|gr_values
index|[
name|regno
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_R3_2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
literal|4
condition|)
name|gr_values
index|[
name|regno
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_P2
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|qp_changemask
operator||=
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PR
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
operator|&
operator|(
name|valueT
operator|)
literal|0x10000
condition|)
name|qp_changemask
operator|=
operator|~
operator|(
name|valueT
operator|)
literal|0x1FFFF
operator||
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
else|else
name|qp_changemask
operator|=
name|idesc
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
name|i
index|]
operator|==
name|IA64_OPND_PR_ROT
condition|)
block|{
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
literal|43
operator|)
condition|)
name|qp_changemask
operator|=
operator|-
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
literal|44
operator|)
operator||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
else|else
name|qp_changemask
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|qp_changemask
operator|&=
operator|~
operator|(
name|valueT
operator|)
literal|0xFFFF
expr_stmt|;
break|break;
block|}
block|}
comment|/* Always clear qp branch flags on any PR change.  */
comment|/* FIXME there may be exceptions for certain compares.  */
name|clear_qp_branch_flag
argument_list|(
name|qp_changemask
argument_list|)
expr_stmt|;
comment|/* Invalidate rotating registers on insns which affect RRBs in CFM.  */
if|if
condition|(
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_MOD_RRBS
condition|)
block|{
name|qp_changemask
operator||=
operator|~
operator|(
name|valueT
operator|)
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"clrrrb.pr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|32
operator|+
name|md
operator|.
name|rot
operator|.
name|num_regs
condition|;
name|i
operator|++
control|)
name|gr_values
index|[
name|i
index|]
operator|.
name|known
operator|=
literal|0
expr_stmt|;
block|}
name|clear_qp_mutex
argument_list|(
name|qp_changemask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|qp_changemask
argument_list|,
name|qp_changemask
argument_list|)
expr_stmt|;
block|}
comment|/* After a call, all register values are undefined, except those marked      as "safe".  */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br.call"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"brl.call"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME keep GR values which are marked as "safe_across_calls"  */
name|clear_register_values
argument_list|()
expr_stmt|;
name|clear_qp_mutex
argument_list|(
operator|~
name|qp_safe_across_calls
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
operator|~
name|qp_safe_across_calls
argument_list|,
operator|~
name|qp_safe_across_calls
argument_list|)
expr_stmt|;
name|clear_qp_branch_flag
argument_list|(
operator|~
name|qp_safe_across_calls
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_interruption_or_rfi
argument_list|(
name|idesc
argument_list|)
operator|||
name|is_taken_branch
argument_list|(
name|idesc
argument_list|)
condition|)
block|{
name|clear_register_values
argument_list|()
expr_stmt|;
name|clear_qp_mutex
argument_list|(
operator|~
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
operator|~
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|~
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Look for mutex and implies relations.  */
elseif|else
if|if
condition|(
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_P2
operator|)
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_P2
operator|)
condition|)
block|{
name|int
name|p1
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|int
name|p2
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
name|REG_P
decl_stmt|;
name|valueT
name|p1mask
init|=
operator|(
name|p1
operator|!=
literal|0
operator|)
condition|?
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p1
else|:
literal|0
decl_stmt|;
name|valueT
name|p2mask
init|=
operator|(
name|p2
operator|!=
literal|0
operator|)
condition|?
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p2
else|:
literal|0
decl_stmt|;
comment|/* If both PRs are PR0, we can't really do anything.  */
if|if
condition|(
name|p1
operator|==
literal|0
operator|&&
name|p2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Ignoring PRs due to inclusion of p0\n"
argument_list|)
expr_stmt|;
block|}
comment|/* In general, clear mutexes and implies which include P1 or P2, 	 with the following exceptions.  */
elseif|else
if|if
condition|(
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".or.andcm"
argument_list|)
operator|||
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".and.orcm"
argument_list|)
condition|)
block|{
name|clear_qp_implies
argument_list|(
name|p2mask
argument_list|,
name|p1mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".andcm"
argument_list|)
operator|||
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".and"
argument_list|)
condition|)
block|{
name|clear_qp_implies
argument_list|(
literal|0
argument_list|,
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".orcm"
argument_list|)
operator|||
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".or"
argument_list|)
condition|)
block|{
name|clear_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|added
init|=
literal|0
decl_stmt|;
name|clear_qp_implies
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|,
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
comment|/* If one of the PRs is PR0, we call clear_qp_mutex.  */
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p2
operator|==
literal|0
condition|)
name|clear_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
else|else
name|added
operator|=
name|update_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|0
operator|||
name|has_suffix_p
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".unc"
argument_list|)
condition|)
block|{
if|if
condition|(
name|added
operator|==
literal|0
operator|&&
name|p1
operator|&&
name|p2
condition|)
name|add_qp_mutex
argument_list|(
name|p1mask
operator||
name|p2mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|p1
condition|)
name|add_qp_imply
argument_list|(
name|p1
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
condition|)
name|add_qp_imply
argument_list|(
name|p2
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Look for mov imm insns into GRs.  */
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_R1
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMM22
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMMU64
operator|)
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"movl"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|)
block|{
name|gr_values
index|[
name|regno
index|]
operator|.
name|known
operator|=
literal|1
expr_stmt|;
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
name|gr_values
index|[
name|regno
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Know gr%d = "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Look for dep.z imm insns.  */
elseif|else
if|if
condition|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_R1
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMM8
operator|&&
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"dep.z"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
name|REG_GR
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
name|NELEMS
argument_list|(
name|gr_values
argument_list|)
condition|)
block|{
name|valueT
name|value
init|=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|1
index|]
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|3
index|]
operator|.
name|X_add_number
operator|<
literal|64
condition|)
name|value
operator|&=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|3
index|]
operator|.
name|X_add_number
operator|)
operator|-
literal|1
expr_stmt|;
name|value
operator|<<=
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
name|gr_values
index|[
name|regno
index|]
operator|.
name|known
operator|=
literal|1
expr_stmt|;
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|gr_values
index|[
name|regno
index|]
operator|.
name|path
operator|=
name|md
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Know gr%d = "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|gr_values
index|[
name|regno
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|clear_qp_mutex
argument_list|(
name|qp_changemask
argument_list|)
expr_stmt|;
name|clear_qp_implies
argument_list|(
name|qp_changemask
argument_list|,
name|qp_changemask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return whether the given predicate registers are currently mutex.  */
end_comment

begin_function
specifier|static
name|int
name|qp_mutex
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|path
parameter_list|)
name|int
name|p1
decl_stmt|;
name|int
name|p2
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|valueT
name|mask
decl_stmt|;
if|if
condition|(
name|p1
operator|!=
name|p2
condition|)
block|{
name|mask
operator|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p1
operator|)
operator||
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|p2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_mutexeslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|path
operator|>=
name|path
operator|&&
operator|(
name|qp_mutexes
index|[
name|i
index|]
operator|.
name|prmask
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return whether the given resource is in the given insn's list of chks    Return 1 if the conflict is absolutely determined, 2 if it's a potential    conflict.  */
end_comment

begin_function
specifier|static
name|int
name|resources_match
parameter_list|(
name|rs
parameter_list|,
name|idesc
parameter_list|,
name|note
parameter_list|,
name|qp_regno
parameter_list|,
name|path
parameter_list|)
name|struct
name|rsrc
modifier|*
name|rs
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|int
name|note
decl_stmt|;
name|int
name|qp_regno
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
name|struct
name|rsrc
name|specs
index|[
name|MAX_SPECS
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* If the marked resource's qp_regno and the given qp_regno are mutex,      we don't need to check.  One exception is note 11, which indicates that      target predicates are written regardless of PR[qp].  */
if|if
condition|(
name|qp_mutex
argument_list|(
name|rs
operator|->
name|qp_regno
argument_list|,
name|qp_regno
argument_list|,
name|path
argument_list|)
operator|&&
name|note
operator|!=
literal|11
condition|)
return|return
literal|0
return|;
name|count
operator|=
name|specify_resource
argument_list|(
name|rs
operator|->
name|dependency
argument_list|,
name|idesc
argument_list|,
name|DV_CHK
argument_list|,
name|specs
argument_list|,
name|note
argument_list|,
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* UNAT checking is a bit more specific than other resources */
if|if
condition|(
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_AR_UNAT
operator|&&
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|hint
operator|&&
name|rs
operator|->
name|mem_offset
operator|.
name|hint
condition|)
block|{
if|if
condition|(
name|rs
operator|->
name|mem_offset
operator|.
name|base
operator|==
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|base
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|rs
operator|->
name|mem_offset
operator|.
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
operator|)
operator|==
operator|(
operator|(
name|specs
index|[
name|count
index|]
operator|.
name|mem_offset
operator|.
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
operator|)
condition|)
return|return
literal|1
return|;
else|else
continue|continue;
block|}
block|}
comment|/* Skip apparent PR write conflicts where both writes are an AND or both 	 writes are an OR.  */
if|if
condition|(
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_PR
operator|||
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_PRr
operator|||
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|==
name|IA64_RS_PR63
condition|)
block|{
if|if
condition|(
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|!=
name|CMP_NONE
operator|&&
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
operator|==
name|rs
operator|->
name|cmp_type
condition|)
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s on parallel compare allowed (PR%d)\n"
argument_list|,
name|dv_mode
index|[
name|rs
operator|->
name|dependency
operator|->
name|mode
index|]
argument_list|,
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|!=
name|IA64_RS_PR63
condition|?
name|specs
index|[
name|count
index|]
operator|.
name|index
else|:
literal|63
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s on parallel compare conflict %s vs %s on PR%d\n"
argument_list|,
name|dv_mode
index|[
name|rs
operator|->
name|dependency
operator|->
name|mode
index|]
argument_list|,
name|dv_cmp_type
index|[
name|rs
operator|->
name|cmp_type
index|]
argument_list|,
name|dv_cmp_type
index|[
name|specs
index|[
name|count
index|]
operator|.
name|cmp_type
index|]
argument_list|,
name|rs
operator|->
name|dependency
operator|->
name|specifier
operator|!=
name|IA64_RS_PR63
condition|?
name|specs
index|[
name|count
index|]
operator|.
name|index
else|:
literal|63
argument_list|)
expr_stmt|;
block|}
comment|/* If either resource is not specific, conservatively assume a conflict        */
if|if
condition|(
operator|!
name|specs
index|[
name|count
index|]
operator|.
name|specific
operator|||
operator|!
name|rs
operator|->
name|specific
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|specs
index|[
name|count
index|]
operator|.
name|index
operator|==
name|rs
operator|->
name|index
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate an instruction group break; if INSERT_STOP is non-zero, then    insert a stop to create the break.  Update all resource dependencies    appropriately.  If QP_REGNO is non-zero, only apply the break to resources    which use the same QP_REGNO and have the link_to_qp_branch flag set.    If SAVE_CURRENT is non-zero, don't affect resources marked by the current    instruction.  */
end_comment

begin_function
specifier|static
name|void
name|insn_group_break
parameter_list|(
name|insert_stop
parameter_list|,
name|qp_regno
parameter_list|,
name|save_current
parameter_list|)
name|int
name|insert_stop
decl_stmt|;
name|int
name|qp_regno
decl_stmt|;
name|int
name|save_current
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|insert_stop
operator|&&
name|md
operator|.
name|num_slots_in_use
operator|>
literal|0
condition|)
name|PREV_SLOT
operator|.
name|end_of_insn_group
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Insn group break%s"
argument_list|,
operator|(
name|insert_stop
condition|?
literal|" (w/stop)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp_regno
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" effective for QP=%d"
argument_list|,
name|qp_regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
init|=
name|regdeps
index|[
name|i
index|]
operator|.
name|dependency
decl_stmt|;
if|if
condition|(
name|qp_regno
operator|!=
literal|0
operator|&&
name|regdeps
index|[
name|i
index|]
operator|.
name|qp_regno
operator|!=
name|qp_regno
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|save_current
operator|&&
name|CURR_SLOT
operator|.
name|src_file
operator|==
name|regdeps
index|[
name|i
index|]
operator|.
name|file
operator|&&
name|CURR_SLOT
operator|.
name|src_line
operator|==
name|regdeps
index|[
name|i
index|]
operator|.
name|line
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* clear dependencies which are automatically cleared by a stop, or 	 those that have reached the appropriate state of insn serialization */
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_IMPLIED
operator|||
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_IMPLIEDF
operator|||
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|==
name|STATE_SRLZ
condition|)
block|{
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|i
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_DATA
operator|||
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_INSTR
operator|||
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_SPECIFIC
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|==
name|STATE_NONE
condition|)
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|=
name|STATE_STOP
expr_stmt|;
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|data_srlz
operator|==
name|STATE_NONE
condition|)
name|regdeps
index|[
name|i
index|]
operator|.
name|data_srlz
operator|=
name|STATE_STOP
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add the given resource usage spec to the list of active dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|mark_resource
parameter_list|(
name|idesc
parameter_list|,
name|dep
parameter_list|,
name|spec
parameter_list|,
name|depind
parameter_list|,
name|path
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|rsrc
modifier|*
name|spec
decl_stmt|;
name|int
name|depind
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
if|if
condition|(
name|regdepslen
operator|==
name|regdepstotlen
condition|)
block|{
name|regdepstotlen
operator|+=
literal|20
expr_stmt|;
name|regdeps
operator|=
operator|(
expr|struct
name|rsrc
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|regdeps
argument_list|,
name|regdepstotlen
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rsrc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|regdeps
index|[
name|regdepslen
index|]
operator|=
operator|*
name|spec
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|depind
operator|=
name|depind
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|file
operator|=
name|CURR_SLOT
operator|.
name|src_file
expr_stmt|;
name|regdeps
index|[
name|regdepslen
index|]
operator|.
name|line
operator|=
name|CURR_SLOT
operator|.
name|src_line
expr_stmt|;
name|print_dependency
argument_list|(
literal|"Adding"
argument_list|,
name|regdepslen
argument_list|)
expr_stmt|;
operator|++
name|regdepslen
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_dependency
parameter_list|(
name|action
parameter_list|,
name|depind
parameter_list|)
specifier|const
name|char
modifier|*
name|action
decl_stmt|;
name|int
name|depind
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s %s '%s'"
argument_list|,
name|action
argument_list|,
name|dv_mode
index|[
operator|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|dependency
operator|)
operator|->
name|mode
index|]
argument_list|,
operator|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|dependency
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|specific
operator|&&
name|regdeps
index|[
name|depind
index|]
operator|.
name|index
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%d)"
argument_list|,
name|regdeps
index|[
name|depind
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|mem_offset
operator|.
name|hint
condition|)
block|{
name|fputs
argument_list|(
literal|" "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|regdeps
index|[
name|depind
index|]
operator|.
name|mem_offset
operator|.
name|base
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"+"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|regdeps
index|[
name|depind
index|]
operator|.
name|mem_offset
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|instruction_serialization
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Instruction serialization\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regdepslen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|==
name|STATE_STOP
condition|)
name|regdeps
index|[
name|i
index|]
operator|.
name|insn_srlz
operator|=
name|STATE_SRLZ
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|data_serialization
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Data serialization\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|data_srlz
operator|==
name|STATE_STOP
comment|/* Note: as of 991210, all "other" dependencies are cleared by a 	     data serialization.  This might change with new tables */
operator|||
operator|(
name|regdeps
index|[
name|i
index|]
operator|.
name|dependency
operator|)
operator|->
name|semantics
operator|==
name|IA64_DVS_OTHER
condition|)
block|{
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|i
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert stops and serializations as needed to avoid DVs.  */
end_comment

begin_function
specifier|static
name|void
name|remove_marked_resource
parameter_list|(
name|rs
parameter_list|)
name|struct
name|rsrc
modifier|*
name|rs
decl_stmt|;
block|{
switch|switch
condition|(
name|rs
operator|->
name|dependency
operator|->
name|semantics
condition|)
block|{
case|case
name|IA64_DVS_SPECIFIC
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Implementation-specific, assume worst case...\n"
argument_list|)
expr_stmt|;
comment|/* ...fall through...  */
case|case
name|IA64_DVS_INSTR
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserting instr serialization\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|insn_srlz
operator|<
name|STATE_STOP
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|insn_srlz
operator|<
name|STATE_SRLZ
condition|)
block|{
name|struct
name|slot
name|oldslot
init|=
name|CURR_SLOT
decl_stmt|;
comment|/* Manually jam a srlz.i insn into the stream */
name|memset
argument_list|(
operator|&
name|CURR_SLOT
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CURR_SLOT
argument_list|)
argument_list|)
expr_stmt|;
name|CURR_SLOT
operator|.
name|user_template
operator|=
operator|-
literal|1
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
literal|"srlz.i"
argument_list|)
expr_stmt|;
name|instruction_serialization
argument_list|()
expr_stmt|;
name|md
operator|.
name|curr_slot
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
if|if
condition|(
operator|++
name|md
operator|.
name|num_slots_in_use
operator|>=
name|NUM_SLOTS
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
name|CURR_SLOT
operator|=
name|oldslot
expr_stmt|;
block|}
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_DVS_OTHER
case|:
comment|/* as of rev2 (991220) of the DV tables, all 			    "other" types of DV are eliminated 			    by a data serialization */
case|case
name|IA64_DVS_DATA
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserting data serialization\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|data_srlz
operator|<
name|STATE_STOP
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|struct
name|slot
name|oldslot
init|=
name|CURR_SLOT
decl_stmt|;
comment|/* Manually jam a srlz.d insn into the stream */
name|memset
argument_list|(
operator|&
name|CURR_SLOT
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CURR_SLOT
argument_list|)
argument_list|)
expr_stmt|;
name|CURR_SLOT
operator|.
name|user_template
operator|=
operator|-
literal|1
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
literal|"srlz.d"
argument_list|)
expr_stmt|;
name|data_serialization
argument_list|()
expr_stmt|;
name|md
operator|.
name|curr_slot
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
if|if
condition|(
operator|++
name|md
operator|.
name|num_slots_in_use
operator|>=
name|NUM_SLOTS
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
name|CURR_SLOT
operator|=
name|oldslot
expr_stmt|;
block|}
break|break;
case|case
name|IA64_DVS_IMPLIED
case|:
case|case
name|IA64_DVS_IMPLIEDF
case|:
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserting stop\n"
argument_list|)
expr_stmt|;
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Check the resources used by the given opcode against the current dependency    list.     The check is run once for each execution path encountered.  In this case,    a unique execution path is the sequence of instructions following a code    entry point, e.g. the following has three execution paths, one starting    at L0, one at L1, and one at L2.     L0:     nop    L1:     add    L2:     add    br.ret */
end_comment

begin_function
specifier|static
name|void
name|check_dependencies
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_opcode_dependency
modifier|*
name|opdeps
init|=
name|idesc
operator|->
name|dependencies
decl_stmt|;
name|int
name|path
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Note that the number of marked resources may change within the      loop if in auto mode.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
name|struct
name|rsrc
modifier|*
name|rs
init|=
operator|&
name|regdeps
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
init|=
name|rs
operator|->
name|dependency
decl_stmt|;
name|int
name|chkind
decl_stmt|;
name|int
name|note
decl_stmt|;
name|int
name|start_over
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dep
operator|->
name|semantics
operator|==
name|IA64_DVS_NONE
operator|||
operator|(
name|chkind
operator|=
name|depends_on
argument_list|(
name|rs
operator|->
name|depind
argument_list|,
name|idesc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|note
operator|=
name|NOTE
argument_list|(
name|opdeps
operator|->
name|chks
index|[
name|chkind
index|]
argument_list|)
expr_stmt|;
comment|/* Check this resource against each execution path seen thus far.  */
for|for
control|(
name|path
operator|=
literal|0
init|;
name|path
operator|<=
name|md
operator|.
name|path
condition|;
name|path
operator|++
control|)
block|{
name|int
name|matchtype
decl_stmt|;
comment|/* If the dependency wasn't on the path being checked, ignore it.  */
if|if
condition|(
name|rs
operator|->
name|path
operator|<
name|path
condition|)
continue|continue;
comment|/* If the QP for this insn implies a QP which has branched, don't 	     bother checking.  Ed. NOTE: I don't think this check is terribly 	     useful; what's the point of generating code which will only be 	     reached if its QP is zero? 	     This code was specifically inserted to handle the following code, 	     based on notes from Intel's DV checking code, where p1 implies p2.  		  mov r4 = 2 	     (p2) br.cond L 	     (p1) mov r4 = 7 	  */
if|if
condition|(
name|CURR_SLOT
operator|.
name|qp_regno
operator|!=
literal|0
condition|)
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|int
name|implies
decl_stmt|;
for|for
control|(
name|implies
operator|=
literal|0
init|;
name|implies
operator|<
name|qp_implieslen
condition|;
name|implies
operator|++
control|)
block|{
if|if
condition|(
name|qp_implies
index|[
name|implies
index|]
operator|.
name|path
operator|>=
name|path
operator|&&
name|qp_implies
index|[
name|implies
index|]
operator|.
name|p1
operator|==
name|CURR_SLOT
operator|.
name|qp_regno
operator|&&
name|qp_implies
index|[
name|implies
index|]
operator|.
name|p2_branched
condition|)
block|{
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|skip
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|matchtype
operator|=
name|resources_match
argument_list|(
name|rs
argument_list|,
name|idesc
argument_list|,
name|note
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|,
name|path
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|pathmsg
index|[
literal|256
index|]
init|=
literal|""
decl_stmt|;
name|char
name|indexmsg
index|[
literal|256
index|]
init|=
literal|""
decl_stmt|;
name|int
name|certain
init|=
operator|(
name|matchtype
operator|==
literal|1
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|0
condition|)
name|snprintf
argument_list|(
name|pathmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|pathmsg
argument_list|)
argument_list|,
literal|" when entry is at label '%s'"
argument_list|,
name|md
operator|.
name|entry_labels
index|[
name|path
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchtype
operator|==
literal|1
operator|&&
name|rs
operator|->
name|index
operator|>=
literal|0
condition|)
name|snprintf
argument_list|(
name|indexmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|indexmsg
argument_list|)
argument_list|,
literal|", specific resource number is %d"
argument_list|,
name|rs
operator|->
name|index
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Use of '%s' %s %s dependency '%s' (%s)%s%s"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
operator|(
name|certain
condition|?
literal|"violates"
else|:
literal|"may violate"
operator|)
argument_list|,
name|dv_mode
index|[
name|dep
operator|->
name|mode
index|]
argument_list|,
name|dep
operator|->
name|name
argument_list|,
name|dv_sem
index|[
name|dep
operator|->
name|semantics
index|]
argument_list|,
name|pathmsg
argument_list|,
name|indexmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|explicit_mode
condition|)
block|{
name|as_warn
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|<
name|md
operator|.
name|path
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Only the first path encountering the conflict "
literal|"is reported"
argument_list|)
argument_list|)
expr_stmt|;
name|as_warn_where
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|rs
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"This is the location of the "
literal|"conflicting usage"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't bother checking other paths, to avoid duplicating 		     the same warning */
break|break;
block|}
else|else
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s @ %s:%d\n"
argument_list|,
name|msg
argument_list|,
name|rs
operator|->
name|file
argument_list|,
name|rs
operator|->
name|line
argument_list|)
expr_stmt|;
name|remove_marked_resource
argument_list|(
name|rs
argument_list|)
expr_stmt|;
comment|/* since the set of dependencies has changed, start over */
comment|/* FIXME -- since we're removing dvs as we go, we 		     probably don't really need to start over...  */
name|start_over
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|start_over
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Register new dependencies based on the given opcode.  */
end_comment

begin_function
specifier|static
name|void
name|mark_resources
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|ia64_opcode_dependency
modifier|*
name|opdeps
init|=
name|idesc
operator|->
name|dependencies
decl_stmt|;
name|int
name|add_only_qp_reads
init|=
literal|0
decl_stmt|;
comment|/* A conditional branch only uses its resources if it is taken; if it is      taken, we stop following that path.  The other branch types effectively      *always* write their resources.  If it's not taken, register only QP      reads.  */
if|if
condition|(
name|is_conditional_branch
argument_list|(
name|idesc
argument_list|)
operator|||
name|is_interruption_or_rfi
argument_list|(
name|idesc
argument_list|)
condition|)
block|{
name|add_only_qp_reads
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Registering '%s' resource usage\n"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opdeps
operator|->
name|nregs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ia64_dependency
modifier|*
name|dep
decl_stmt|;
name|struct
name|rsrc
name|specs
index|[
name|MAX_SPECS
index|]
decl_stmt|;
name|int
name|note
decl_stmt|;
name|int
name|path
decl_stmt|;
name|int
name|count
decl_stmt|;
name|dep
operator|=
name|ia64_find_dependency
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|note
operator|=
name|NOTE
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_only_qp_reads
operator|&&
operator|!
operator|(
name|dep
operator|->
name|mode
operator|==
name|IA64_DV_WAR
operator|&&
operator|(
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_PR
operator|||
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_PRr
operator|||
name|dep
operator|->
name|specifier
operator|==
name|IA64_RS_PR63
operator|)
operator|)
condition|)
continue|continue;
name|count
operator|=
name|specify_resource
argument_list|(
name|dep
argument_list|,
name|idesc
argument_list|,
name|DV_REG
argument_list|,
name|specs
argument_list|,
name|note
argument_list|,
name|md
operator|.
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|mark_resource
argument_list|(
name|idesc
argument_list|,
name|dep
argument_list|,
operator|&
name|specs
index|[
name|count
index|]
argument_list|,
name|DEP
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|md
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* The execution path may affect register values, which may in turn 	 affect which indirect-access resources are accessed.  */
switch|switch
condition|(
name|dep
operator|->
name|specifier
condition|)
block|{
default|default:
break|break;
case|case
name|IA64_RS_CPUID
case|:
case|case
name|IA64_RS_DBR
case|:
case|case
name|IA64_RS_IBR
case|:
case|case
name|IA64_RS_MSR
case|:
case|case
name|IA64_RS_PKR
case|:
case|case
name|IA64_RS_PMC
case|:
case|case
name|IA64_RS_PMD
case|:
case|case
name|IA64_RS_RR
case|:
for|for
control|(
name|path
operator|=
literal|0
init|;
name|path
operator|<
name|md
operator|.
name|path
condition|;
name|path
operator|++
control|)
block|{
name|count
operator|=
name|specify_resource
argument_list|(
name|dep
argument_list|,
name|idesc
argument_list|,
name|DV_REG
argument_list|,
name|specs
argument_list|,
name|note
argument_list|,
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|mark_resource
argument_list|(
name|idesc
argument_list|,
name|dep
argument_list|,
operator|&
name|specs
index|[
name|count
index|]
argument_list|,
name|DEP
argument_list|(
name|opdeps
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove dependencies when they no longer apply.  */
end_comment

begin_function
specifier|static
name|void
name|update_dependencies
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"srlz.i"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|instruction_serialization
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"srlz.d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data_serialization
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_interruption_or_rfi
argument_list|(
name|idesc
argument_list|)
operator|||
name|is_taken_branch
argument_list|(
name|idesc
argument_list|)
condition|)
block|{
comment|/* Although technically the taken branch doesn't clear dependencies 	 which require a srlz.[id], we don't follow the branch; the next 	 instruction is assumed to start with a clean slate.  */
name|regdepslen
operator|=
literal|0
expr_stmt|;
name|md
operator|.
name|path
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_conditional_branch
argument_list|(
name|idesc
argument_list|)
operator|&&
name|CURR_SLOT
operator|.
name|qp_regno
operator|!=
literal|0
condition|)
block|{
name|int
name|is_call
init|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".call"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_implieslen
condition|;
name|i
operator|++
control|)
block|{
comment|/* If the conditional branch's predicate is implied by the predicate 	     in an existing dependency, remove that dependency.  */
if|if
condition|(
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2
operator|==
name|CURR_SLOT
operator|.
name|qp_regno
condition|)
block|{
name|int
name|depind
init|=
literal|0
decl_stmt|;
comment|/* Note that this implied predicate takes a branch so that if 		 a later insn generates a DV but its predicate implies this 		 one, we can avoid the false DV warning.  */
name|qp_implies
index|[
name|i
index|]
operator|.
name|p2_branched
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|depind
operator|<
name|regdepslen
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|depind
index|]
operator|.
name|qp_regno
operator|==
name|qp_implies
index|[
name|i
index|]
operator|.
name|p1
condition|)
block|{
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|depind
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|depind
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|depind
expr_stmt|;
block|}
block|}
block|}
comment|/* Any marked resources which have this same predicate should be 	 cleared, provided that the QP hasn't been modified between the 	 marking instruction and the branch.  */
if|if
condition|(
name|is_call
condition|)
block|{
name|insn_group_break
argument_list|(
literal|0
argument_list|,
name|CURR_SLOT
operator|.
name|qp_regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|regdepslen
condition|)
block|{
if|if
condition|(
name|regdeps
index|[
name|i
index|]
operator|.
name|qp_regno
operator|==
name|CURR_SLOT
operator|.
name|qp_regno
operator|&&
name|regdeps
index|[
name|i
index|]
operator|.
name|link_to_qp_branch
operator|&&
operator|(
name|regdeps
index|[
name|i
index|]
operator|.
name|file
operator|!=
name|CURR_SLOT
operator|.
name|src_file
operator|||
name|regdeps
index|[
name|i
index|]
operator|.
name|line
operator|!=
name|CURR_SLOT
operator|.
name|src_line
operator|)
condition|)
block|{
comment|/* Treat like a taken branch */
name|print_dependency
argument_list|(
literal|"Removing"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regdeps
index|[
name|i
index|]
operator|=
name|regdeps
index|[
operator|--
name|regdepslen
index|]
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Examine the current instruction for dependency violations.  */
end_comment

begin_function
specifier|static
name|int
name|check_dv
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
block|{
if|if
condition|(
name|md
operator|.
name|debug_dv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking %s for violations (line %d, %d/%d)\n"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
name|CURR_SLOT
operator|.
name|src_line
argument_list|,
name|idesc
operator|->
name|dependencies
operator|->
name|nchks
argument_list|,
name|idesc
operator|->
name|dependencies
operator|->
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* Look through the list of currently marked resources; if the current      instruction has the dependency in its chks list which uses that resource,      check against the specific resources used.  */
name|check_dependencies
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* Look up the instruction's regdeps (RAW writes, WAW writes, and WAR reads),      then add them to the list of marked resources.  */
name|mark_resources
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* There are several types of dependency semantics, and each has its own      requirements for being cleared       Instruction serialization (insns separated by interruption, rfi, or      writer + srlz.i + reader, all in separate groups) clears DVS_INSTR.       Data serialization (instruction serialization, or writer + srlz.d +      reader, where writer and srlz.d are in separate groups) clears      DVS_DATA. (This also clears DVS_OTHER, but that is not guaranteed to      always be the case).       Instruction group break (groups separated by stop, taken branch,      interruption or rfi) clears DVS_IMPLIED and DVS_IMPLIEDF.    */
name|update_dependencies
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* Sometimes, knowing a register value allows us to avoid giving a false DV      warning.  Keep track of as many as possible that are useful.  */
name|note_register_values
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
comment|/* We don't need or want this anymore.  */
name|md
operator|.
name|mem_offset
operator|.
name|hint
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate one line of assembly.  Pseudo ops and labels do not show    here.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|,
modifier|*
name|mnemonic
decl_stmt|;
specifier|const
name|struct
name|pseudo_opcode
modifier|*
name|pdesc
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|idesc
decl_stmt|;
name|unsigned
name|char
name|qp_regno
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* extract the opcode (mnemonic):  */
name|mnemonic
operator|=
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|pdesc
operator|=
operator|(
expr|struct
name|pseudo_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|md
operator|.
name|pseudo_hash
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdesc
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
call|(
modifier|*
name|pdesc
operator|->
name|handler
call|)
argument_list|(
name|pdesc
operator|->
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Find the instruction descriptor matching the arguments.  */
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|!
name|idesc
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown opcode `%s'"
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|idesc
operator|=
name|parse_operands
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|idesc
condition|)
goto|goto
name|done
goto|;
comment|/* Handle the dynamic ops we can handle now:  */
if|if
condition|(
name|idesc
operator|->
name|type
operator|==
name|IA64_TYPE_DYN
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|CURR_SLOT
operator|.
name|opnd
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|<
literal|4
condition|)
name|mnemonic
operator|=
literal|"addl"
expr_stmt|;
else|else
name|mnemonic
operator|=
literal|"adds"
expr_stmt|;
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enum
name|ia64_opnd
name|opnd1
decl_stmt|,
name|opnd2
decl_stmt|;
name|int
name|rop
decl_stmt|;
name|opnd1
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|opnd2
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|opnd1
operator|==
name|IA64_OPND_AR3
condition|)
name|rop
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd2
operator|==
name|IA64_OPND_AR3
condition|)
name|rop
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
if|if
condition|(
name|ar_is_only_in_integer_unit
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
name|mnemonic
operator|=
literal|"mov.i"
expr_stmt|;
elseif|else
if|if
condition|(
name|ar_is_only_in_memory_unit
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
name|mnemonic
operator|=
literal|"mov.m"
expr_stmt|;
else|else
name|rop
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rop
operator|>=
literal|0
condition|)
block|{
name|ia64_free_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|idesc
operator|=
name|ia64_find_opcode
argument_list|(
name|mnemonic
argument_list|)
expr_stmt|;
while|while
condition|(
name|idesc
operator|!=
name|NULL
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|!=
name|opnd1
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|!=
name|opnd2
operator|)
condition|)
name|idesc
operator|=
name|get_next_opcode
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov.i"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov.m"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enum
name|ia64_opnd
name|opnd1
decl_stmt|,
name|opnd2
decl_stmt|;
name|int
name|rop
decl_stmt|;
name|opnd1
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|opnd2
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|opnd1
operator|==
name|IA64_OPND_AR3
condition|)
name|rop
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|opnd2
operator|==
name|IA64_OPND_AR3
condition|)
name|rop
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|char
name|unit
init|=
literal|'a'
decl_stmt|;
if|if
condition|(
name|ar_is_only_in_integer_unit
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
name|unit
operator|=
literal|'i'
expr_stmt|;
elseif|else
if|if
condition|(
name|ar_is_only_in_memory_unit
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_add_number
argument_list|)
condition|)
name|unit
operator|=
literal|'m'
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|'a'
operator|&&
name|unit
operator|!=
name|idesc
operator|->
name|name
index|[
literal|4
index|]
condition|)
name|as_bad
argument_list|(
literal|"AR %d can only be accessed by %c-unit"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|CURR_SLOT
operator|.
name|opnd
index|[
name|rop
index|]
operator|.
name|X_add_number
operator|-
name|REG_AR
argument_list|)
argument_list|,
name|TOUPPER
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"hint.b"
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|md
operator|.
name|hint_b
condition|)
block|{
case|case
name|hint_b_ok
case|:
break|break;
case|case
name|hint_b_warning
case|:
name|as_warn
argument_list|(
literal|"hint.b may be treated as nop"
argument_list|)
expr_stmt|;
break|break;
case|case
name|hint_b_error
case|:
name|as_bad
argument_list|(
literal|"hint.b shouldn't be used"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|qp_regno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|qp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|qp_regno
operator|=
name|md
operator|.
name|qp
operator|.
name|X_add_number
operator|-
name|REG_P
expr_stmt|;
name|md
operator|.
name|qp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
name|flags
operator|=
name|idesc
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IA64_OPCODE_FIRST
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The alignment frag has to end with a stop bit only if the 	 next instruction after the alignment directive has to be 	 the first instruction in an instruction group.  */
if|if
condition|(
name|align_frag
condition|)
block|{
while|while
condition|(
name|align_frag
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
block|{
name|align_frag
operator|=
name|align_frag
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
operator|!
name|align_frag
condition|)
break|break;
block|}
comment|/* align_frag can be NULL if there are directives in 	     between.  */
if|if
condition|(
name|align_frag
operator|&&
name|align_frag
operator|->
name|fr_next
operator|==
name|frag_now
condition|)
name|align_frag
operator|->
name|tc_frag_data
operator|=
literal|1
expr_stmt|;
block|}
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|align_frag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IA64_OPCODE_NO_PRED
operator|)
operator|!=
literal|0
operator|&&
name|qp_regno
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"`%s' cannot be predicated"
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Build the instruction.  */
name|CURR_SLOT
operator|.
name|qp_regno
operator|=
name|qp_regno
expr_stmt|;
name|CURR_SLOT
operator|.
name|idesc
operator|=
name|idesc
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|CURR_SLOT
operator|.
name|src_file
argument_list|,
operator|&
name|CURR_SLOT
operator|.
name|src_line
argument_list|)
expr_stmt|;
name|dwarf2_where
argument_list|(
operator|&
name|CURR_SLOT
operator|.
name|debug_line
argument_list|)
expr_stmt|;
comment|/* Add unwind entries, if there are any.  */
if|if
condition|(
name|unwind
operator|.
name|current_entry
condition|)
block|{
name|CURR_SLOT
operator|.
name|unwind_record
operator|=
name|unwind
operator|.
name|current_entry
expr_stmt|;
name|unwind
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unwind
operator|.
name|pending_saves
condition|)
block|{
if|if
condition|(
name|unwind
operator|.
name|pending_saves
operator|->
name|next
condition|)
block|{
comment|/* Attach the next pending save to the next slot so that its 	     slot number will get set correctly.  */
name|add_unwind_entry
argument_list|(
name|unwind
operator|.
name|pending_saves
operator|->
name|next
argument_list|,
name|NOT_A_CHAR
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|pending_saves
operator|=
operator|&
name|unwind
operator|.
name|pending_saves
operator|->
name|next
operator|->
name|r
operator|.
name|record
operator|.
name|p
expr_stmt|;
block|}
else|else
name|unwind
operator|.
name|pending_saves
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
operator|&&
name|S_IS_DEFINED
argument_list|(
name|unwind
operator|.
name|proc_pending
operator|.
name|sym
argument_list|)
condition|)
name|unwind
operator|.
name|insn
operator|=
literal|1
expr_stmt|;
comment|/* Check for dependency violations.  */
if|if
condition|(
name|md
operator|.
name|detect_dv
condition|)
name|check_dv
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
name|md
operator|.
name|curr_slot
operator|=
operator|(
name|md
operator|.
name|curr_slot
operator|+
literal|1
operator|)
operator|%
name|NUM_SLOTS
expr_stmt|;
if|if
condition|(
operator|++
name|md
operator|.
name|num_slots_in_use
operator|>=
name|NUM_SLOTS
condition|)
name|emit_one_bundle
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IA64_OPCODE_LAST
operator|)
operator|!=
literal|0
condition|)
name|insn_group_break
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|.
name|last_text_seg
operator|=
name|now_seg
expr_stmt|;
name|done
label|:
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when symbol NAME cannot be found in the symbol table.    Should be used for dynamic valued symbols only.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called for any expression that can not be recognized.  When the    function is called, `input_line_pointer' will point to the start of    the expression.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'['
case|:
operator|++
name|input_line_pointer
expr_stmt|;
name|expression_and_evaluate
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Closing bracket missing"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_register
operator|||
name|e
operator|->
name|X_add_number
operator|<
name|REG_GR
operator|||
name|e
operator|->
name|X_add_number
operator|>
name|REG_GR
operator|+
literal|127
condition|)
block|{
name|as_bad
argument_list|(
literal|"Index must be a general register"
argument_list|)
expr_stmt|;
name|e
operator|->
name|X_add_number
operator|=
name|REG_GR
expr_stmt|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|e
operator|->
name|X_op
operator|=
name|O_index
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return;
name|err
label|:
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if it's OK to adjust a reloc by replacing the symbol with    a section symbol plus some offset.  For relocs involving @fptr(),    directives we don't want such adjustments since we need to have the    original symbol's name in the reloc.  */
end_comment

begin_function
name|int
name|ia64_fix_adjustable
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
comment|/* Prevent all adjustments to global symbols */
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR32LSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ia64_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR32LSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
case|case
name|BFD_RELOC_IA64_LTOFF22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF64I
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF22
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF64I
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF64MSB
case|:
case|case
name|BFD_RELOC_IA64_PLTOFF64LSB
case|:
case|case
name|BFD_RELOC_IA64_LTOFF22X
case|:
case|case
name|BFD_RELOC_IA64_LDXMOV
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decide from what point a pc-relative relocation is relative to,    relative to the pc-relative fixup.  Er, relatively speaking.  */
end_comment

begin_function
name|long
name|ia64_pcrel_from_section
parameter_list|(
name|fix
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
name|unsigned
name|long
name|off
init|=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix
operator|->
name|fx_where
decl_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|off
operator|&=
operator|~
literal|0xfUL
expr_stmt|;
return|return
name|off
return|;
block|}
end_function

begin_comment
comment|/* Used to emit section-relative relocs for the dwarf2 debug data.  */
end_comment

begin_function
name|void
name|ia64_dwarf2_emit_offset
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_pseudo_fixup
expr_stmt|;
name|expr
operator|.
name|X_op_symbol
operator|=
name|pseudo_func
index|[
name|FUNC_SEC_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|symbol
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called whenever some data item (not an instruction) needs a    fixup.  We pick the right reloc code depending on the byteorder    currently in effect.  */
end_comment

begin_function
name|void
name|ia64_cons_fix_new
parameter_list|(
name|f
parameter_list|,
name|where
parameter_list|,
name|nbytes
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|f
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
comment|/* There are no reloc for 8 and 16 bit quantities, but we allow 	 them here since they will work fine as long as the expression 	 is fully defined at the end of the pass over the source file.  */
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|target_big_endian
condition|)
name|code
operator|=
name|BFD_RELOC_IA64_DIR32MSB
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_IA64_DIR32LSB
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* In 32-bit mode, data8 could mean function descriptors too.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|&&
name|S_GET_VALUE
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|FUNC_IPLT_RELOC
operator|&&
operator|!
operator|(
name|md
operator|.
name|flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|code
operator|=
name|BFD_RELOC_IA64_IPLTMSB
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_IA64_IPLTLSB
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|code
operator|=
name|BFD_RELOC_IA64_DIR64MSB
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_IA64_DIR64LSB
expr_stmt|;
break|break;
block|}
case|case
literal|16
case|:
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|&&
name|S_GET_VALUE
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|FUNC_IPLT_RELOC
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|code
operator|=
name|BFD_RELOC_IA64_IPLTMSB
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_IA64_IPLTLSB
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
default|default:
name|as_bad
argument_list|(
literal|"Unsupported fixup size %d"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_pseudo_fixup
condition|)
block|{
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|code
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* ??? If code unchanged, unsupported.  */
block|}
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|f
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* We need to store the byte order in effect in case we're going      to fix an 8 or 16 bit relocation (for which there no real      relocs available).  See md_apply_fix().  */
name|fix
operator|->
name|tc_fix_data
operator|.
name|bigendian
operator|=
name|target_big_endian
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual relocation we wish to associate with the pseudo    reloc described by SYM and R_TYPE.  SYM should be one of the    symbols in the pseudo_func array, or NULL.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|ia64_gen_real_reloc_type
parameter_list|(
name|sym
parameter_list|,
name|r_type
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|new
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|NULL
decl_stmt|,
modifier|*
name|suffix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
return|return
name|r_type
return|;
block|}
switch|switch
condition|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|FUNC_FPTR_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_FPTR64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"FPTR"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_GP_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_GPREL64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"GPREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_LT_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF64I
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"LTOFF"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_LT_RELATIVE_X
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF22X
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"LTOFF"
expr_stmt|;
name|suffix
operator|=
literal|"X"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_PC_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PCREL64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"PCREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_PLT_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_PLTOFF64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"PLTOFF"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_SEC_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SECREL64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"SECREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_SEG_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_SEGREL64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"SEGREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_LTV_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTV64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"LTV"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_LT_FPTR_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_FPTR64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"LTOFF_FPTR"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_TP_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM14
case|:
name|new
operator|=
name|BFD_RELOC_IA64_TPREL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_TPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_TPREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_TPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_TPREL64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"TPREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_LT_TP_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_TPREL22
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"LTOFF_TPREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_DTP_MODULE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPMOD64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPMOD64LSB
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"DTPMOD"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_LT_DTP_MODULE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_DTPMOD22
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"LTOFF_DTPMOD"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_DTP_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM14
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPREL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|new
operator|=
name|BFD_RELOC_IA64_DTPREL64I
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"DTPREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_LT_DTP_RELATIVE
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|new
operator|=
name|BFD_RELOC_IA64_LTOFF_DTPREL22
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"LTOFF_DTPREL"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC_IPLT_RELOC
case|:
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_IPLTMSB
case|:
return|return
name|r_type
return|;
case|case
name|BFD_RELOC_IA64_IPLTLSB
case|:
return|return
name|r_type
return|;
default|default:
name|type
operator|=
literal|"IPLT"
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
else|else
block|{
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|width
operator|=
literal|32
expr_stmt|;
name|suffix
operator|=
literal|"MSB"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|width
operator|=
literal|32
expr_stmt|;
name|suffix
operator|=
literal|"LSB"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|width
operator|=
literal|64
expr_stmt|;
name|suffix
operator|=
literal|"MSB"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|width
operator|=
literal|64
expr_stmt|;
name|suffix
operator|=
literal|"LSB"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_UNUSED
case|:
name|width
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM14
case|:
name|width
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|width
operator|=
literal|22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|width
operator|=
literal|64
expr_stmt|;
name|suffix
operator|=
literal|"I"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* This should be an error, but since previously there wasn't any 	 diagnostic here, dont't make it fail because of this for now.  */
name|as_warn
argument_list|(
literal|"Cannot express %s%d%s relocation"
argument_list|,
name|type
argument_list|,
name|width
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
name|r_type
return|;
block|}
block|}
end_function

begin_comment
comment|/* Here is where generate the appropriate reloc for pseudo relocation    functions.  */
end_comment

begin_function
name|void
name|ia64_validate_fix
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
if|if
condition|(
name|fix
operator|->
name|fx_offset
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|"No addend allowed in @fptr() relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fix_insn
parameter_list|(
name|fix
parameter_list|,
name|odesc
parameter_list|,
name|value
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
specifier|const
name|struct
name|ia64_operand
modifier|*
name|odesc
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
index|[
literal|3
index|]
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|control_bits
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|fixpos
decl_stmt|;
name|long
name|slot
decl_stmt|;
name|slot
operator|=
name|fix
operator|->
name|fx_where
operator|&
literal|0x3
expr_stmt|;
name|fixpos
operator|=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
operator|(
name|fix
operator|->
name|fx_where
operator|-
name|slot
operator|)
expr_stmt|;
comment|/* Bundles are always in little-endian byte order */
name|t0
operator|=
name|bfd_getl64
argument_list|(
name|fixpos
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_getl64
argument_list|(
name|fixpos
operator|+
literal|8
argument_list|)
expr_stmt|;
name|control_bits
operator|=
name|t0
operator|&
literal|0x1f
expr_stmt|;
name|insn
index|[
literal|0
index|]
operator|=
operator|(
name|t0
operator|>>
literal|5
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|t0
operator|>>
literal|46
operator|)
operator|&
literal|0x3ffff
operator|)
operator||
operator|(
operator|(
name|t1
operator|&
literal|0x7fffff
operator|)
operator|<<
literal|18
operator|)
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator|=
operator|(
name|t1
operator|>>
literal|23
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|odesc
operator|-
name|elf64_ia64_operands
operator|==
name|IA64_OPND_IMMU64
condition|)
block|{
name|insn
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|22
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator||=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x7f
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|7
operator|)
operator|&
literal|0x1ff
operator|)
operator|<<
literal|27
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|21
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|63
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|odesc
operator|-
name|elf64_ia64_operands
operator|==
name|IA64_OPND_IMMU62
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3fffffffffffffffULL
condition|)
name|err
operator|=
literal|"integer operand out of range"
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|21
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator||=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0xfffff
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|20
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|odesc
operator|-
name|elf64_ia64_operands
operator|==
name|IA64_OPND_TGT64
condition|)
block|{
name|value
operator|>>=
literal|4
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|20
operator|)
operator|&
literal|0x7fffffffffLL
operator|)
operator|<<
literal|2
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator||=
operator|(
operator|(
operator|(
operator|(
name|value
operator|>>
literal|59
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|36
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|0
operator|)
operator|&
literal|0xfffff
operator|)
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|err
operator|=
call|(
modifier|*
name|odesc
operator|->
name|insert
call|)
argument_list|(
name|odesc
argument_list|,
name|value
argument_list|,
name|insn
operator|+
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|t0
operator|=
name|control_bits
operator||
operator|(
name|insn
index|[
literal|0
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|insn
index|[
literal|1
index|]
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|=
operator|(
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|18
operator|)
operator|&
literal|0x7fffff
operator|)
operator||
operator|(
name|insn
index|[
literal|2
index|]
operator|<<
literal|23
operator|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|fixpos
operator|+
literal|0
argument_list|,
name|t0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|fixpos
operator|+
literal|8
argument_list|,
name|t1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to simplify or even eliminate a fixup.  The return value is    ignored; perhaps it was once meaningful, but now it is historical.    To indicate that a fixup has been eliminated, set FIXP->FX_DONE.     If fixp->fx_addsy is non-NULL, we'll have to generate a reloc entry    (if possible).  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fix
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|fixpos
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|fixpos
operator|=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fix
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IA64_PCREL21B
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21BI
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21F
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21M
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL60B
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL22
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64I
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL32MSB
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL32LSB
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64MSB
case|:
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64LSB
case|:
break|break;
default|default:
name|fix
operator|->
name|fx_r_type
operator|=
name|ia64_gen_real_reloc_type
argument_list|(
name|pseudo_func
index|[
name|FUNC_PC_RELATIVE
index|]
operator|.
name|u
operator|.
name|sym
argument_list|,
name|fix
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_UNUSED
case|:
comment|/* This must be a TAG13 or TAG13b operand.  There are no external 	     relocs defined for them, so we must give an error.  */
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
literal|"%s must have a constant value"
argument_list|,
name|elf64_ia64_operands
index|[
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_IA64_TPREL14
case|:
case|case
name|BFD_RELOC_IA64_TPREL22
case|:
case|case
name|BFD_RELOC_IA64_TPREL64I
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_TPREL22
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_DTPMOD22
case|:
case|case
name|BFD_RELOC_IA64_DTPREL14
case|:
case|case
name|BFD_RELOC_IA64_DTPREL22
case|:
case|case
name|BFD_RELOC_IA64_DTPREL64I
case|:
case|case
name|BFD_RELOC_IA64_LTOFF_DTPREL22
case|:
name|S_SET_THREAD_LOCAL
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
operator|==
name|IA64_OPND_NIL
condition|)
block|{
if|if
condition|(
name|fix
operator|->
name|tc_fix_data
operator|.
name|bigendian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
name|fix
operator|->
name|fx_size
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
name|fix
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fix_insn
argument_list|(
name|fix
argument_list|,
name|elf64_ia64_operands
operator|+
name|fix
operator|->
name|tc_fix_data
operator|.
name|opnd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the BFD reloc to be stuck in the object file from the    fixup used internally in the assembler.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|sec
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
operator|->
name|howto
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Cannot represent %s relocation in object file"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LIT.  The number    of LITTLENUMS emitted is stored in *SIZE.  An error message is    returned, or NULL on OK.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|5
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|lit
parameter_list|,
name|size
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|lit
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
block|{
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|prec
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* IEEE floats */
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
call|(
modifier|*
name|ia64_float_to_chars
call|)
argument_list|(
name|lit
argument_list|,
name|words
argument_list|,
name|prec
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'X'
condition|)
block|{
comment|/* It is 10 byte floating point with 6 byte padding.  */
name|memset
argument_list|(
operator|&
name|lit
index|[
literal|10
index|]
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|size
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle ia64 specific semantics of the align directive.  */
end_comment

begin_function
name|void
name|ia64_md_do_align
parameter_list|(
name|n
parameter_list|,
name|fill
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|int
name|n
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|fill
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|len
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|max
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|subseg_text_p
argument_list|(
name|now_seg
argument_list|)
condition|)
name|ia64_flush_insns
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents    of an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|ia64_handle_align
parameter_list|(
name|fragp
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
name|int
name|bytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|nop
decl_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
comment|/* Check if this frag has to end with a stop bit.  */
name|nop
operator|=
name|fragp
operator|->
name|tc_frag_data
condition|?
name|le_nop_stop
else|:
name|le_nop
expr_stmt|;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* If no paddings are needed, we check if we need a stop bit.  */
if|if
condition|(
operator|!
name|bytes
operator|&&
name|fragp
operator|->
name|tc_frag_data
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_fix
operator|<
literal|16
condition|)
if|#
directive|if
literal|1
comment|/* FIXME: It won't work with 	   .align 16 	   alloc r32=ar.pfs,1,2,4,0 	 */
empty_stmt|;
else|#
directive|else
name|as_bad_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"Can't add stop bit to mark end of instruction group"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
comment|/* Bundles are always in little-endian byte order. Make sure 	   the previous bundle has the stop bit.  */
operator|*
operator|(
name|p
operator|-
literal|16
operator|)
operator||=
literal|1
expr_stmt|;
block|}
comment|/* Make sure we are on a 16-byte boundary, in case someone has been      putting data into a text section.  */
if|if
condition|(
name|bytes
operator|&
literal|15
condition|)
block|{
name|int
name|fix
init|=
name|bytes
operator|&
literal|15
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|bytes
operator|-=
name|fix
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
block|}
comment|/* Instruction bundles are always little-endian.  */
name|memcpy
argument_list|(
name|p
argument_list|,
name|nop
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_float_to_chars_bigendian
parameter_list|(
name|char
modifier|*
name|lit
parameter_list|,
name|LITTLENUM_TYPE
modifier|*
name|words
parameter_list|,
name|int
name|prec
parameter_list|)
block|{
while|while
condition|(
name|prec
operator|--
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|lit
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|words
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lit
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_float_to_chars_littleendian
parameter_list|(
name|char
modifier|*
name|lit
parameter_list|,
name|LITTLENUM_TYPE
modifier|*
name|words
parameter_list|,
name|int
name|prec
parameter_list|)
block|{
while|while
condition|(
name|prec
operator|--
condition|)
block|{
name|number_to_chars_littleendian
argument_list|(
name|lit
argument_list|,
call|(
name|long
call|)
argument_list|(
name|words
index|[
name|prec
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lit
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ia64_elf_section_change_hook
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|elf_section_type
argument_list|(
name|now_seg
argument_list|)
operator|==
name|SHT_IA_64_UNWIND
operator|&&
name|elf_linked_to_section
argument_list|(
name|now_seg
argument_list|)
operator|==
name|NULL
condition|)
name|elf_linked_to_section
argument_list|(
name|now_seg
argument_list|)
operator|=
name|text_section
expr_stmt|;
name|dot_byteorder
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if a label should be made global.  */
end_comment

begin_function
name|void
name|ia64_check_label
parameter_list|(
name|symbolS
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
name|S_SET_EXTERNAL
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used to remember where .alias and .secalias directives are seen. We    will rename symbol and section names when we are about to output    the relocatable file.  */
end_comment

begin_struct
struct|struct
name|alias
block|{
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The file where the directive is seen.  */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* The line number the directive is at.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The original name of the symbol.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Called for .alias and .secalias directives. If SECTION is 1, it is    .secalias. Otherwise, it is .alias.  */
end_comment

begin_function
specifier|static
name|void
name|dot_alias
parameter_list|(
name|int
name|section
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|alias
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|char
modifier|*
name|end_name
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_string
decl_stmt|;
name|struct
name|alias
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|ahash
decl_stmt|,
modifier|*
name|nhash
decl_stmt|;
specifier|const
name|char
modifier|*
name|kind
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|end_name
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|ia64_canonicalize_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* We call demand_copy_C_string to check if alias string is valid.      There should be a closing `"' and no `\0' in the string.  */
name|alias
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|==
name|NULL
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Make a copy of name string.  */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
condition|)
block|{
name|kind
operator|=
literal|"section"
expr_stmt|;
name|ahash
operator|=
name|secalias_hash
expr_stmt|;
name|nhash
operator|=
name|secalias_name_hash
expr_stmt|;
block|}
else|else
block|{
name|kind
operator|=
literal|"symbol"
expr_stmt|;
name|ahash
operator|=
name|alias_hash
expr_stmt|;
name|nhash
operator|=
name|alias_name_hash
expr_stmt|;
block|}
comment|/* Check if alias has been used before.  */
name|h
operator|=
operator|(
expr|struct
name|alias
operator|*
operator|)
name|hash_find
argument_list|(
name|ahash
argument_list|,
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is already the alias of %s `%s'"
argument_list|)
argument_list|,
name|alias
argument_list|,
name|kind
argument_list|,
name|h
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check if name already has an alias.  */
name|a
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|hash_find
argument_list|(
name|nhash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|a
argument_list|,
name|alias
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s `%s' already has an alias `%s'"
argument_list|)
argument_list|,
name|kind
argument_list|,
name|name
argument_list|,
name|a
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|h
operator|=
operator|(
expr|struct
name|alias
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|h
operator|->
name|file
argument_list|,
operator|&
name|h
operator|->
name|line
argument_list|)
expr_stmt|;
name|h
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|error_string
operator|=
name|hash_jam
argument_list|(
name|ahash
argument_list|,
name|alias
argument_list|,
operator|(
name|PTR
operator|)
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_string
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"inserting \"%s\" into %s alias hash table failed: %s"
argument_list|)
argument_list|,
name|alias
argument_list|,
name|kind
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error_string
operator|=
name|hash_jam
argument_list|(
name|nhash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_string
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"inserting \"%s\" into %s name hash table failed: %s"
argument_list|)
argument_list|,
name|alias
argument_list|,
name|kind
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
name|out
label|:
name|obstack_free
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|notes
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* It renames the original symbol name to its alias.  */
end_comment

begin_function
specifier|static
name|void
name|do_alias
parameter_list|(
specifier|const
name|char
modifier|*
name|alias
parameter_list|,
name|PTR
name|value
parameter_list|)
block|{
name|struct
name|alias
modifier|*
name|h
init|=
operator|(
expr|struct
name|alias
operator|*
operator|)
name|value
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
name|symbol_find
argument_list|(
name|h
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|as_warn_where
argument_list|(
name|h
operator|->
name|file
argument_list|,
name|h
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"symbol `%s' aliased to `%s' is not used"
argument_list|)
argument_list|,
name|h
operator|->
name|name
argument_list|,
name|alias
argument_list|)
expr_stmt|;
else|else
name|S_SET_NAME
argument_list|(
name|sym
argument_list|,
operator|(
name|char
operator|*
operator|)
name|alias
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from write_object_file.  */
end_comment

begin_function
name|void
name|ia64_adjust_symtab
parameter_list|(
name|void
parameter_list|)
block|{
name|hash_traverse
argument_list|(
name|alias_hash
argument_list|,
name|do_alias
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* It renames the original section name to its alias.  */
end_comment

begin_function
specifier|static
name|void
name|do_secalias
parameter_list|(
specifier|const
name|char
modifier|*
name|alias
parameter_list|,
name|PTR
name|value
parameter_list|)
block|{
name|struct
name|alias
modifier|*
name|h
init|=
operator|(
expr|struct
name|alias
operator|*
operator|)
name|value
decl_stmt|;
name|segT
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|h
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|as_warn_where
argument_list|(
name|h
operator|->
name|file
argument_list|,
name|h
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"section `%s' aliased to `%s' is not used"
argument_list|)
argument_list|,
name|h
operator|->
name|name
argument_list|,
name|alias
argument_list|)
expr_stmt|;
else|else
name|sec
operator|->
name|name
operator|=
name|alias
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from write_object_file.  */
end_comment

begin_function
name|void
name|ia64_frob_file
parameter_list|(
name|void
parameter_list|)
block|{
name|hash_traverse
argument_list|(
name|secalias_hash
argument_list|,
name|do_secalias
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

