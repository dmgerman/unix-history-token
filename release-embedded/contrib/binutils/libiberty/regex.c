begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended regular expression matching and search library,    version 0.12.    (Implements POSIX draft P1003.2/D11.2, except for some of the    internationalization features.)     Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2005 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, write to the Free    Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301 USA.  */
end_comment

begin_comment
comment|/* This file has been modified for usage in libiberty.  It includes "xregex.h"    instead of<regex.h>.  The "xregex.h" header file renames all external    routines with an "x" prefix so they do not collide with the native regex    routines or with other components regex routines. */
end_comment

begin_comment
comment|/* AIX requires this to be the first thing in the file. */
end_comment

begin_if
if|#
directive|if
name|defined
name|_AIX
operator|&&
operator|!
name|defined
name|__GNUC__
operator|&&
operator|!
name|defined
name|REGEX_MALLOC
end_if

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|_GNU_SOURCE
end_undef

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INSIDE_RECURSION
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ansidecl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INSIDE_RECURSION
end_ifndef

begin_if
if|#
directive|if
name|defined
name|STDC_HEADERS
operator|&&
operator|!
name|defined
name|emacs
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We need this for `regex.h', and perhaps for the Emacs include files.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|WIDE_CHAR_SUPPORT
value|(HAVE_WCTYPE_H&& HAVE_WCHAR_H&& HAVE_BTOWC)
end_define

begin_comment
comment|/* For platform which support the ISO C amendement 1 functionality we    support user defined character classes.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|WIDE_CHAR_SUPPORT
end_if

begin_comment
comment|/* Solaris 2.5 has a bug:<wchar.h> must be included before<wctype.h>.  */
end_comment

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* We have to keep the namespace clean.  */
end_comment

begin_define
define|#
directive|define
name|regfree
parameter_list|(
name|preg
parameter_list|)
value|__regfree (preg)
end_define

begin_define
define|#
directive|define
name|regexec
parameter_list|(
name|pr
parameter_list|,
name|st
parameter_list|,
name|nm
parameter_list|,
name|pm
parameter_list|,
name|ef
parameter_list|)
value|__regexec (pr, st, nm, pm, ef)
end_define

begin_define
define|#
directive|define
name|regcomp
parameter_list|(
name|preg
parameter_list|,
name|pattern
parameter_list|,
name|cflags
parameter_list|)
value|__regcomp (preg, pattern, cflags)
end_define

begin_define
define|#
directive|define
name|regerror
parameter_list|(
name|errcode
parameter_list|,
name|preg
parameter_list|,
name|errbuf
parameter_list|,
name|errbuf_size
parameter_list|)
define|\
value|__regerror(errcode, preg, errbuf, errbuf_size)
end_define

begin_define
define|#
directive|define
name|re_set_registers
parameter_list|(
name|bu
parameter_list|,
name|re
parameter_list|,
name|nu
parameter_list|,
name|st
parameter_list|,
name|en
parameter_list|)
define|\
value|__re_set_registers (bu, re, nu, st, en)
end_define

begin_define
define|#
directive|define
name|re_match_2
parameter_list|(
name|bufp
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|)
define|\
value|__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
end_define

begin_define
define|#
directive|define
name|re_match
parameter_list|(
name|bufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|)
define|\
value|__re_match (bufp, string, size, pos, regs)
end_define

begin_define
define|#
directive|define
name|re_search
parameter_list|(
name|bufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|)
define|\
value|__re_search (bufp, string, size, startpos, range, regs)
end_define

begin_define
define|#
directive|define
name|re_compile_pattern
parameter_list|(
name|pattern
parameter_list|,
name|length
parameter_list|,
name|bufp
parameter_list|)
define|\
value|__re_compile_pattern (pattern, length, bufp)
end_define

begin_define
define|#
directive|define
name|re_set_syntax
parameter_list|(
name|syntax
parameter_list|)
value|__re_set_syntax (syntax)
end_define

begin_define
define|#
directive|define
name|re_search_2
parameter_list|(
name|bufp
parameter_list|,
name|st1
parameter_list|,
name|s1
parameter_list|,
name|st2
parameter_list|,
name|s2
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|)
define|\
value|__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
end_define

begin_define
define|#
directive|define
name|re_compile_fastmap
parameter_list|(
name|bufp
parameter_list|)
value|__re_compile_fastmap (bufp)
end_define

begin_define
define|#
directive|define
name|btowc
value|__btowc
end_define

begin_comment
comment|/* We are also using some library internals.  */
end_comment

begin_include
include|#
directive|include
file|<locale/localeinfo.h>
end_include

begin_include
include|#
directive|include
file|<locale/elem-hash.h>
end_include

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_include
include|#
directive|include
file|<locale/coll-lookup.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is for other GNU distributions with internationalized messages.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|HAVE_LIBINTL_H
operator|&&
name|ENABLE_NLS
operator|)
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_undef
undef|#
directive|undef
name|gettext
end_undef

begin_define
define|#
directive|define
name|gettext
parameter_list|(
name|msgid
parameter_list|)
value|__dcgettext ("libc", msgid, LC_MESSAGES)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|gettext
parameter_list|(
name|msgid
parameter_list|)
value|(msgid)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|gettext_noop
end_ifndef

begin_comment
comment|/* This define is so xgettext can find the internationalizable    strings.  */
end_comment

begin_define
define|#
directive|define
name|gettext_noop
parameter_list|(
name|String
parameter_list|)
value|String
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The `emacs' switch turns on certain matching commands    that make sense only in Emacs. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not emacs */
end_comment

begin_comment
comment|/* If we are not linking with Emacs proper,    we can't use the relocating allocator    even if config.h says that we can.  */
end_comment

begin_undef
undef|#
directive|undef
name|REL_ALLOC
end_undef

begin_if
if|#
directive|if
name|defined
name|STDC_HEADERS
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When used in Emacs's lib-src, we need to get bzero and bcopy somehow.    If nothing else has been done, use the method below.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INHIBIT_STRING_HEADER
end_ifdef

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|HAVE_BZERO
operator|&&
name|defined
name|HAVE_BCOPY
operator|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
name|bzero
operator|&&
operator|!
name|defined
name|bcopy
end_if

begin_undef
undef|#
directive|undef
name|INHIBIT_STRING_HEADER
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the normal way of making sure we have a bcopy and a bzero.    This is used in most programs--a few other programs avoid this    by defining INHIBIT_STRING_HEADER.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INHIBIT_STRING_HEADER
end_ifndef

begin_if
if|#
directive|if
name|defined
name|HAVE_STRING_H
operator|||
name|defined
name|STDC_HEADERS
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|bzero
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|(memset (s, '\0', n), (s))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|__bzero (s, n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|memcmp
end_ifndef

begin_define
define|#
directive|define
name|memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|bcmp (s1, s2, n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|memcpy
end_ifndef

begin_define
define|#
directive|define
name|memcpy
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|(bcopy (s, d, n), (d))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the syntax stuff for \<, \>, etc.  */
end_comment

begin_comment
comment|/* This must be nonzero for the wordchar and notwordchar pattern    commands in re_match_2.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Sword
end_ifndef

begin_define
define|#
directive|define
name|Sword
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
end_ifdef

begin_define
define|#
directive|define
name|SWITCH_ENUM_CAST
parameter_list|(
name|x
parameter_list|)
value|((int)(x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SWITCH_ENUM_CAST
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MB_LEN_MAX
end_ifndef

begin_define
define|#
directive|define
name|MB_LEN_MAX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Get the interface, including the syntax bits.  */
end_comment

begin_include
include|#
directive|include
file|"xregex.h"
end_include

begin_comment
comment|/* change for libiberty */
end_comment

begin_comment
comment|/* isalpha etc. are used for the character classes.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Jim Meyering writes:     "... Some ctype macros are valid only for character codes that    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when    using /bin/cc or gcc but without giving an ansi option).  So, all    ctype uses should be through macros like ISPRINT...  If    STDC_HEADERS is defined, then autoconf has verified that the ctype    macros don't need to be guarded with references to isascii. ...    Defining isascii to 1 should let any compiler worth its salt    eliminate the&& through constant folding."    Solaris defines some of these symbols so we must undefine them first.  */
end_comment

begin_undef
undef|#
directive|undef
name|ISASCII
end_undef

begin_if
if|#
directive|if
name|defined
name|STDC_HEADERS
operator|||
operator|(
operator|!
name|defined
name|isascii
operator|&&
operator|!
name|defined
name|HAVE_ISASCII
operator|)
end_if

begin_define
define|#
directive|define
name|ISASCII
parameter_list|(
name|c
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISASCII
parameter_list|(
name|c
parameter_list|)
value|isascii(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|isblank
end_ifdef

begin_define
define|#
directive|define
name|ISBLANK
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isblank (c))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISBLANK
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|isgraph
end_ifdef

begin_define
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isgraph (c))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isprint (c)&& !isspace (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|ISPRINT
end_undef

begin_define
define|#
directive|define
name|ISPRINT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isprint (c))
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isdigit (c))
end_define

begin_define
define|#
directive|define
name|ISALNUM
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isalnum (c))
end_define

begin_define
define|#
directive|define
name|ISALPHA
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isalpha (c))
end_define

begin_define
define|#
directive|define
name|ISCNTRL
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& iscntrl (c))
end_define

begin_define
define|#
directive|define
name|ISLOWER
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& islower (c))
end_define

begin_define
define|#
directive|define
name|ISPUNCT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& ispunct (c))
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isspace (c))
end_define

begin_define
define|#
directive|define
name|ISUPPER
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isupper (c))
end_define

begin_define
define|#
directive|define
name|ISXDIGIT
parameter_list|(
name|c
parameter_list|)
value|(ISASCII (c)&& isxdigit (c))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_tolower
end_ifdef

begin_define
define|#
directive|define
name|TOLOWER
parameter_list|(
name|c
parameter_list|)
value|_tolower(c)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TOLOWER
parameter_list|(
name|c
parameter_list|)
value|tolower(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|(void *)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We remove any previous definition of `SIGN_EXTEND_CHAR',    since ours (we hope) works properly with all combinations of    machines, compilers, `char' and `unsigned char' argument types.    (Per Bothner suggested the basic approach.)  */
end_comment

begin_undef
undef|#
directive|undef
name|SIGN_EXTEND_CHAR
end_undef

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_define
define|#
directive|define
name|SIGN_EXTEND_CHAR
parameter_list|(
name|c
parameter_list|)
value|((signed char) (c))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_comment
comment|/* As in Harbison and Steele.  */
end_comment

begin_define
define|#
directive|define
name|SIGN_EXTEND_CHAR
parameter_list|(
name|c
parameter_list|)
value|((((unsigned char) (c)) ^ 128) - 128)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* How many characters in the character set.  */
end_comment

begin_define
define|#
directive|define
name|CHAR_SET_SIZE
value|256
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYNTAX_TABLE
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|re_syntax_table
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not SYNTAX_TABLE */
end_comment

begin_decl_stmt
specifier|static
name|char
name|re_syntax_table
index|[
name|CHAR_SET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_syntax_once
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|init_syntax_once
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
name|bzero
argument_list|(
name|re_syntax_table
argument_list|,
sizeof|sizeof
name|re_syntax_table
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|CHAR_SET_SIZE
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
condition|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
name|re_syntax_table
index|[
literal|'_'
index|]
operator|=
name|Sword
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not SYNTAX_TABLE */
end_comment

begin_define
define|#
directive|define
name|SYNTAX
parameter_list|(
name|c
parameter_list|)
value|re_syntax_table[(unsigned char) (c)]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Integer type for pointers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|defined
name|HAVE_UINTPTR_T
end_if

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|uintptr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we    use `alloca' instead of `malloc'.  This is because using malloc in    re_search* or re_match* could cause memory leaks when C-g is used in    Emacs; also, malloc is slower and causes storage fragmentation.  On    the other hand, malloc is more portable, and easier to debug.     Because we sometimes use alloca, some routines have to be macros,    not functions -- `alloca'-allocated space disappears at the end of the    function it is called in.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REGEX_MALLOC
end_ifdef

begin_define
define|#
directive|define
name|REGEX_ALLOCATE
value|malloc
end_define

begin_define
define|#
directive|define
name|REGEX_REALLOCATE
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
value|realloc (source, nsize)
end_define

begin_define
define|#
directive|define
name|REGEX_FREE
value|free
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not REGEX_MALLOC  */
end_comment

begin_comment
comment|/* Emacs already defines alloca, sometimes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_comment
comment|/* Make alloca work the best possible way.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_if
if|#
directive|if
name|HAVE_ALLOCA_H
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not alloca */
end_comment

begin_define
define|#
directive|define
name|REGEX_ALLOCATE
value|alloca
end_define

begin_comment
comment|/* Assumes a `char *destination' variable.  */
end_comment

begin_define
define|#
directive|define
name|REGEX_REALLOCATE
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
define|\
value|(destination = (char *) alloca (nsize),				\    memcpy (destination, source, osize))
end_define

begin_comment
comment|/* No need to do anything to free, after alloca.  */
end_comment

begin_define
define|#
directive|define
name|REGEX_FREE
parameter_list|(
name|arg
parameter_list|)
value|((void)0)
end_define

begin_comment
comment|/* Do nothing!  But inhibit gcc warning.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REGEX_MALLOC */
end_comment

begin_comment
comment|/* Define how to allocate the failure stack.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|REL_ALLOC
operator|&&
name|defined
name|REGEX_MALLOC
end_if

begin_define
define|#
directive|define
name|REGEX_ALLOCATE_STACK
parameter_list|(
name|size
parameter_list|)
define|\
value|r_alloc (&failure_stack_ptr, (size))
end_define

begin_define
define|#
directive|define
name|REGEX_REALLOCATE_STACK
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
define|\
value|r_re_alloc (&failure_stack_ptr, (nsize))
end_define

begin_define
define|#
directive|define
name|REGEX_FREE_STACK
parameter_list|(
name|ptr
parameter_list|)
define|\
value|r_alloc_free (&failure_stack_ptr)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not using relocating allocator */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REGEX_MALLOC
end_ifdef

begin_define
define|#
directive|define
name|REGEX_ALLOCATE_STACK
value|malloc
end_define

begin_define
define|#
directive|define
name|REGEX_REALLOCATE_STACK
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
value|realloc (source, nsize)
end_define

begin_define
define|#
directive|define
name|REGEX_FREE_STACK
value|free
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not REGEX_MALLOC */
end_comment

begin_define
define|#
directive|define
name|REGEX_ALLOCATE_STACK
value|alloca
end_define

begin_define
define|#
directive|define
name|REGEX_REALLOCATE_STACK
parameter_list|(
name|source
parameter_list|,
name|osize
parameter_list|,
name|nsize
parameter_list|)
define|\
value|REGEX_REALLOCATE (source, osize, nsize)
end_define

begin_comment
comment|/* No need to explicitly free anything.  */
end_comment

begin_define
define|#
directive|define
name|REGEX_FREE_STACK
parameter_list|(
name|arg
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REGEX_MALLOC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not using relocating allocator */
end_comment

begin_comment
comment|/* True if `size1' is non-NULL and PTR is pointing anywhere inside    `string1' or just past its end.  This works if PTR is NULL, which is    a good thing.  */
end_comment

begin_define
define|#
directive|define
name|FIRST_STRING_P
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(size1&& string1<= (ptr)&& (ptr)<= string1 + size1)
end_define

begin_comment
comment|/* (Re)Allocate N items of type T using malloc, or fail.  */
end_comment

begin_define
define|#
directive|define
name|TALLOC
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|((t *) malloc ((n) * sizeof (t)))
end_define

begin_define
define|#
directive|define
name|RETALLOC
parameter_list|(
name|addr
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|((addr) = (t *) realloc (addr, (n) * sizeof (t)))
end_define

begin_define
define|#
directive|define
name|RETALLOC_IF
parameter_list|(
name|addr
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
end_define

begin_define
define|#
directive|define
name|REGEX_TALLOC
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
end_define

begin_define
define|#
directive|define
name|BYTEWIDTH
value|8
end_define

begin_comment
comment|/* In bits.  */
end_comment

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|((strcmp (s1, s2) == 0))
end_define

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_typedef
typedef|typedef
name|char
name|boolean
typedef|;
end_typedef

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_function_decl
specifier|static
name|reg_errcode_t
name|byte_regex_compile
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|byte_re_match_2_internal
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|byte_re_search_2
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|startpos
parameter_list|,
name|int
name|range
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|byte_re_compile_fastmap
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_function_decl
specifier|static
name|reg_errcode_t
name|wcs_regex_compile
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcs_re_match_2_internal
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|cstring1
parameter_list|,
name|int
name|csize1
parameter_list|,
specifier|const
name|char
modifier|*
name|cstring2
parameter_list|,
name|int
name|csize2
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|,
name|wchar_t
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
name|wchar_t
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
modifier|*
name|mbs_offset1
parameter_list|,
name|int
modifier|*
name|mbs_offset2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcs_re_search_2
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|startpos
parameter_list|,
name|int
name|range
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcs_re_compile_fastmap
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* These are the command codes that appear in compiled regular    expressions.  Some opcodes are followed by argument bytes.  A    command code can specify any interpretation whatsoever for its    arguments.  Zero bytes may appear in the compiled regular expression.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|no_op
init|=
literal|0
block|,
comment|/* Succeed right away--no more backtracking.  */
name|succeed
block|,
comment|/* Followed by one byte giving n, then by n literal bytes.  */
name|exactn
block|,
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* Same as exactn, but contains binary data.  */
name|exactn_bin
block|,
endif|#
directive|endif
comment|/* Matches any (more or less) character.  */
name|anychar
block|,
comment|/* Matches any one char belonging to specified set.  First            following byte is number of bitmap bytes.  Then come bytes            for a bitmap saying which chars are in.  Bits in each byte            are ordered low-bit-first.  A character is in the set if its            bit is 1.  A character too large to have a bit in the map is            automatically not in the set.  */
comment|/* ifdef MBS_SUPPORT, following element is length of character 	   classes, length of collating symbols, length of equivalence 	   classes, length of character ranges, and length of characters. 	   Next, character class element, collating symbols elements, 	   equivalence class elements, range elements, and character 	   elements follow. 	   See regex_compile function.  */
name|charset
block|,
comment|/* Same parameters as charset, but match any character that is            not one of those specified.  */
name|charset_not
block|,
comment|/* Start remembering the text that is matched, for storing in a            register.  Followed by one byte with the register number, in            the range 0 to one less than the pattern buffer's re_nsub            field.  Then followed by one byte with the number of groups            inner to this one.  (This last has to be part of the            start_memory only because we need it in the on_failure_jump            of re_match_2.)  */
name|start_memory
block|,
comment|/* Stop remembering the text that is matched and store it in a            memory register.  Followed by one byte with the register            number, in the range 0 to one less than `re_nsub' in the            pattern buffer, and one byte with the number of inner groups,            just like `start_memory'.  (We need the number of inner            groups here because we don't have any easy way of finding the            corresponding start_memory when we're at a stop_memory.)  */
name|stop_memory
block|,
comment|/* Match a duplicate of something remembered. Followed by one            byte containing the register number.  */
name|duplicate
block|,
comment|/* Fail unless at beginning of line.  */
name|begline
block|,
comment|/* Fail unless at end of line.  */
name|endline
block|,
comment|/* Succeeds if at beginning of buffer (if emacs) or at beginning            of string to be matched (if not).  */
name|begbuf
block|,
comment|/* Analogously, for end of buffer/string.  */
name|endbuf
block|,
comment|/* Followed by two byte relative address to which to jump.  */
name|jump
block|,
comment|/* Same as jump, but marks the end of an alternative.  */
name|jump_past_alt
block|,
comment|/* Followed by two-byte relative address of place to resume at            in case of failure.  */
comment|/* ifdef MBS_SUPPORT, the size of address is 1.  */
name|on_failure_jump
block|,
comment|/* Like on_failure_jump, but pushes a placeholder instead of the            current string position when executed.  */
name|on_failure_keep_string_jump
block|,
comment|/* Throw away latest failure point and then jump to following            two-byte relative address.  */
comment|/* ifdef MBS_SUPPORT, the size of address is 1.  */
name|pop_failure_jump
block|,
comment|/* Change to pop_failure_jump if know won't have to backtrack to            match; otherwise change to jump.  This is used to jump            back to the beginning of a repeat.  If what follows this jump            clearly won't match what the repeat does, such that we can be            sure that there is no use backtracking out of repetitions            already matched, then we change it to a pop_failure_jump.            Followed by two-byte address.  */
comment|/* ifdef MBS_SUPPORT, the size of address is 1.  */
name|maybe_pop_jump
block|,
comment|/* Jump to following two-byte address, and push a dummy failure            point. This failure point will be thrown away if an attempt            is made to use it for a failure.  A `+' construct makes this            before the first repeat.  Also used as an intermediary kind            of jump when compiling an alternative.  */
comment|/* ifdef MBS_SUPPORT, the size of address is 1.  */
name|dummy_failure_jump
block|,
comment|/* Push a dummy failure point and continue.  Used at the end of 	   alternatives.  */
name|push_dummy_failure
block|,
comment|/* Followed by two-byte relative address and two-byte number n.            After matching N times, jump to the address upon failure.  */
comment|/* ifdef MBS_SUPPORT, the size of address is 1.  */
name|succeed_n
block|,
comment|/* Followed by two-byte relative address, and two-byte number n.            Jump to the address N times, then fail.  */
comment|/* ifdef MBS_SUPPORT, the size of address is 1.  */
name|jump_n
block|,
comment|/* Set the following two-byte relative address to the            subsequent two-byte number.  The address *includes* the two            bytes of number.  */
comment|/* ifdef MBS_SUPPORT, the size of address is 1.  */
name|set_number_at
block|,
name|wordchar
block|,
comment|/* Matches any word-constituent character.  */
name|notwordchar
block|,
comment|/* Matches any char that is not a word-constituent.  */
name|wordbeg
block|,
comment|/* Succeeds if at word beginning.  */
name|wordend
block|,
comment|/* Succeeds if at word end.  */
name|wordbound
block|,
comment|/* Succeeds if at a word boundary.  */
name|notwordbound
comment|/* Succeeds if not at a word boundary.  */
ifdef|#
directive|ifdef
name|emacs
block|,
name|before_dot
block|,
comment|/* Succeeds if before point.  */
name|at_dot
block|,
comment|/* Succeeds if at point.  */
name|after_dot
block|,
comment|/* Succeeds if after point.  */
comment|/* Matches any character whose syntax is specified.  Followed by            a byte which contains a syntax code, e.g., Sword.  */
name|syntaxspec
block|,
comment|/* Matches any character whose syntax is not that specified.  */
name|notsyntaxspec
endif|#
directive|endif
comment|/* emacs */
block|}
name|re_opcode_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BYTE
end_ifdef

begin_define
define|#
directive|define
name|CHAR_T
value|char
end_define

begin_define
define|#
directive|define
name|UCHAR_T
value|unsigned char
end_define

begin_define
define|#
directive|define
name|COMPILED_BUFFER_VAR
value|bufp->buffer
end_define

begin_define
define|#
directive|define
name|OFFSET_ADDRESS_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|PREFIX
parameter_list|(
name|name
parameter_list|)
value|byte_##name
end_define

begin_define
define|#
directive|define
name|ARG_PREFIX
parameter_list|(
name|name
parameter_list|)
value|name
end_define

begin_define
define|#
directive|define
name|PUT_CHAR
parameter_list|(
name|c
parameter_list|)
value|putchar (c)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|CHAR_T
value|wchar_t
end_define

begin_define
define|#
directive|define
name|UCHAR_T
value|wchar_t
end_define

begin_define
define|#
directive|define
name|COMPILED_BUFFER_VAR
value|wc_buffer
end_define

begin_define
define|#
directive|define
name|OFFSET_ADDRESS_SIZE
value|1
end_define

begin_comment
comment|/* the size which STORE_NUMBER macro use */
end_comment

begin_define
define|#
directive|define
name|CHAR_CLASS_SIZE
value|((__alignof__(wctype_t)+sizeof(wctype_t))/sizeof(CHAR_T)+1)
end_define

begin_define
define|#
directive|define
name|PREFIX
parameter_list|(
name|name
parameter_list|)
value|wcs_##name
end_define

begin_define
define|#
directive|define
name|ARG_PREFIX
parameter_list|(
name|name
parameter_list|)
value|c##name
end_define

begin_comment
comment|/* Should we use wide stream??  */
end_comment

begin_define
define|#
directive|define
name|PUT_CHAR
parameter_list|(
name|c
parameter_list|)
value|printf ("%C", c);
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_define
define|#
directive|define
name|WCHAR
end_define

begin_define
define|#
directive|define
name|INSIDE_RECURSION
end_define

begin_include
include|#
directive|include
file|"regex.c"
end_include

begin_undef
undef|#
directive|undef
name|INSIDE_RECURSION
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BYTE
end_define

begin_define
define|#
directive|define
name|INSIDE_RECURSION
end_define

begin_include
include|#
directive|include
file|"regex.c"
end_include

begin_undef
undef|#
directive|undef
name|INSIDE_RECURSION
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INSIDE_RECURSION
end_ifdef

begin_comment
comment|/* Common operations on the compiled pattern.  */
end_comment

begin_comment
comment|/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
end_comment

begin_comment
comment|/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|STORE_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|number
parameter_list|)
define|\
value|do {									\     *(destination) = (UCHAR_T)(number);				\   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|STORE_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|number
parameter_list|)
define|\
value|do {									\     (destination)[0] = (number)& 0377;					\     (destination)[1] = (number)>> 8;					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_comment
comment|/* Same as STORE_NUMBER, except increment DESTINATION to    the byte after where the number is stored.  Therefore, DESTINATION    must be an lvalue.  */
end_comment

begin_comment
comment|/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */
end_comment

begin_define
define|#
directive|define
name|STORE_NUMBER_AND_INCR
parameter_list|(
name|destination
parameter_list|,
name|number
parameter_list|)
define|\
value|do {									\     STORE_NUMBER (destination, number);					\     (destination) += OFFSET_ADDRESS_SIZE;				\   } while (0)
end_define

begin_comment
comment|/* Put into DESTINATION a number stored in two contiguous bytes starting    at SOURCE.  */
end_comment

begin_comment
comment|/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|EXTRACT_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
define|\
value|do {									\     (destination) = *(source);						\   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|EXTRACT_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
define|\
value|do {									\     (destination) = *(source)& 0377;					\     (destination) += SIGN_EXTEND_CHAR (*((source) + 1))<< 8;		\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|PREFIX
function_decl|(
name|extract_number
function_decl|)
parameter_list|(
name|int
modifier|*
name|dest
parameter_list|,
name|UCHAR_T
modifier|*
name|source
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|PREFIX
function|(
name|extract_number
function|)
parameter_list|(
name|int
modifier|*
name|dest
parameter_list|,
name|UCHAR_T
modifier|*
name|source
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WCHAR
operator|*
name|dest
operator|=
operator|*
name|source
expr_stmt|;
else|#
directive|else
comment|/* BYTE */
name|int
name|temp
init|=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|source
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
operator|*
name|dest
operator|=
operator|*
name|source
operator|&
literal|0377
expr_stmt|;
operator|*
name|dest
operator|+=
name|temp
operator|<<
literal|8
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EXTRACT_MACROS
end_ifndef

begin_comment
comment|/* To debug the macros.  */
end_comment

begin_undef
undef|#
directive|undef
name|EXTRACT_NUMBER
end_undef

begin_define
define|#
directive|define
name|EXTRACT_NUMBER
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|PREFIX(extract_number) (&dest, src)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EXTRACT_MACROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.    SOURCE must be an lvalue.  */
end_comment

begin_define
define|#
directive|define
name|EXTRACT_NUMBER_AND_INCR
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
define|\
value|do {									\     EXTRACT_NUMBER (destination, source);				\     (source) += OFFSET_ADDRESS_SIZE; 					\   } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|PREFIX
function_decl|(
name|extract_number_and_incr
function_decl|)
parameter_list|(
name|int
modifier|*
name|destination
parameter_list|,
name|UCHAR_T
modifier|*
modifier|*
name|source
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|PREFIX
function|(
name|extract_number_and_incr
function|)
parameter_list|(
name|int
modifier|*
name|destination
parameter_list|,
name|UCHAR_T
modifier|*
modifier|*
name|source
parameter_list|)
block|{
name|PREFIX
argument_list|(
name|extract_number
argument_list|)
argument_list|(
name|destination
argument_list|,
operator|*
name|source
argument_list|)
expr_stmt|;
operator|*
name|source
operator|+=
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EXTRACT_MACROS
end_ifndef

begin_undef
undef|#
directive|undef
name|EXTRACT_NUMBER_AND_INCR
end_undef

begin_define
define|#
directive|define
name|EXTRACT_NUMBER_AND_INCR
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|PREFIX(extract_number_and_incr) (&dest,&src)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EXTRACT_MACROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* If DEBUG is defined, Regex prints many voluminous messages about what    it is doing (if the variable `debug' is nonzero).  If linked with the    main program in `iregex.c', you can enter patterns and strings    interactively.  And if linked with the main program in `main.c' and    the other test files, you can run the already-written tests.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_comment
comment|/* We use standard I/O for debugging.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* It is useful to test things that ``must'' be true when debugging.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG_STATEMENT
parameter_list|(
name|e
parameter_list|)
value|e
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT1
parameter_list|(
name|x
parameter_list|)
value|if (debug) printf (x)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT2
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|)
value|if (debug) printf (x1, x2)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT3
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|)
value|if (debug) printf (x1, x2, x3)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT4
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|,
name|x4
parameter_list|)
value|if (debug) printf (x1, x2, x3, x4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_define
define|#
directive|define
name|DEBUG_PRINT_COMPILED_PATTERN
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|e
parameter_list|)
define|\
value|if (debug) PREFIX(print_partial_compiled_pattern) (s, e)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT_DOUBLE_STRING
parameter_list|(
name|w
parameter_list|,
name|s1
parameter_list|,
name|sz1
parameter_list|,
name|s2
parameter_list|,
name|sz2
parameter_list|)
define|\
value|if (debug) PREFIX(print_double_string) (w, s1, sz1, s2, sz2)
end_define

begin_comment
comment|/* Print the fastmap in human-readable form.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_function
name|void
name|print_fastmap
parameter_list|(
name|char
modifier|*
name|fastmap
parameter_list|)
block|{
name|unsigned
name|was_a_range
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|)
block|{
if|if
condition|(
name|fastmap
index|[
name|i
operator|++
index|]
condition|)
block|{
name|was_a_range
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|&&
name|fastmap
index|[
name|i
index|]
condition|)
block|{
name|was_a_range
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|was_a_range
condition|)
block|{
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_comment
comment|/* Print a compiled pattern string in human-readable form, starting at    the START pointer into it and ending just before the pointer END.  */
end_comment

begin_function
name|void
name|PREFIX
function|(
name|print_partial_compiled_pattern
function|)
parameter_list|(
name|UCHAR_T
modifier|*
name|start
parameter_list|,
name|UCHAR_T
modifier|*
name|end
parameter_list|)
block|{
name|int
name|mcnt
decl_stmt|,
name|mcnt2
decl_stmt|;
name|UCHAR_T
modifier|*
name|p1
decl_stmt|;
name|UCHAR_T
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|UCHAR_T
modifier|*
name|pend
init|=
name|end
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"(null)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Loop over pattern commands.  */
while|while
condition|(
name|p
operator|<
name|pend
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"%td:\t"
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%ld:\t"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|++
condition|)
block|{
case|case
name|no_op
case|:
name|printf
argument_list|(
literal|"/no_op"
argument_list|)
expr_stmt|;
break|break;
case|case
name|exactn
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/exactn/%d"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
do|do
block|{
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
break|break;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
case|case
name|exactn_bin
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/exactn_bin/%d"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|"/%lx"
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
break|break;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
case|case
name|start_memory
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/start_memory/%d/%ld"
argument_list|,
name|mcnt
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|stop_memory
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/stop_memory/%d/%ld"
argument_list|,
name|mcnt
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|duplicate
case|:
name|printf
argument_list|(
literal|"/duplicate/%ld"
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|anychar
case|:
name|printf
argument_list|(
literal|"/anychar"
argument_list|)
expr_stmt|;
break|break;
case|case
name|charset
case|:
case|case
name|charset_not
case|:
block|{
ifdef|#
directive|ifdef
name|WCHAR
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|wchar_t
modifier|*
name|workp
init|=
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"/charset [%s"
argument_list|,
operator|(
name|re_opcode_t
operator|)
operator|*
operator|(
name|workp
operator|-
literal|1
operator|)
operator|==
name|charset_not
condition|?
literal|"^"
else|:
literal|""
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
name|length
operator|=
operator|*
name|workp
operator|++
expr_stmt|;
comment|/* the length of char_classes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"[:%lx:]"
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|length
operator|=
operator|*
name|workp
operator|++
expr_stmt|;
comment|/* the length of collating_symbol */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"[."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|(
name|i
operator|++
operator|,
operator|*
name|p
operator|++
operator|)
argument_list|)
expr_stmt|;
name|i
operator|++
operator|,
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|".]"
argument_list|)
expr_stmt|;
block|}
name|length
operator|=
operator|*
name|workp
operator|++
expr_stmt|;
comment|/* the length of equivalence_class */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"[="
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|(
name|i
operator|++
operator|,
operator|*
name|p
operator|++
operator|)
argument_list|)
expr_stmt|;
name|i
operator|++
operator|,
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"=]"
argument_list|)
expr_stmt|;
block|}
name|length
operator|=
operator|*
name|workp
operator|++
expr_stmt|;
comment|/* the length of char_range */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|wchar_t
name|range_start
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|wchar_t
name|range_end
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|printf
argument_list|(
literal|"%C-%C"
argument_list|,
name|range_start
argument_list|,
name|range_end
argument_list|)
expr_stmt|;
block|}
name|length
operator|=
operator|*
name|workp
operator|++
expr_stmt|;
comment|/* the length of char */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%C"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|int
name|c
decl_stmt|,
name|last
init|=
operator|-
literal|100
decl_stmt|;
specifier|register
name|int
name|in_range
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"/charset [%s"
argument_list|,
operator|(
name|re_opcode_t
operator|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
name|charset_not
condition|?
literal|"^"
else|:
literal|""
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|+
operator|*
name|p
operator|<
name|pend
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|c
operator|/
literal|8
operator|<
operator|*
name|p
operator|&&
operator|(
name|p
index|[
literal|1
operator|+
operator|(
name|c
operator|/
literal|8
operator|)
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Are we starting a range?  */
if|if
condition|(
name|last
operator|+
literal|1
operator|==
name|c
operator|&&
operator|!
name|in_range
condition|)
block|{
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|in_range
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Have we broken a range?  */
elseif|else
if|if
condition|(
name|last
operator|+
literal|1
operator|!=
name|c
operator|&&
name|in_range
condition|)
block|{
name|putchar
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|in_range
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|in_range
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|in_range
condition|)
name|putchar
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
operator|+
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
block|}
break|break;
case|case
name|begline
case|:
name|printf
argument_list|(
literal|"/begline"
argument_list|)
expr_stmt|;
break|break;
case|case
name|endline
case|:
name|printf
argument_list|(
literal|"/endline"
argument_list|)
expr_stmt|;
break|break;
case|case
name|on_failure_jump
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/on_failure_jump to %td"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/on_failure_jump to %ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|on_failure_keep_string_jump
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/on_failure_keep_string_jump to %td"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/on_failure_keep_string_jump to %ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|dummy_failure_jump
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/dummy_failure_jump to %td"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/dummy_failure_jump to %ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|push_dummy_failure
case|:
name|printf
argument_list|(
literal|"/push_dummy_failure"
argument_list|)
expr_stmt|;
break|break;
case|case
name|maybe_pop_jump
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/maybe_pop_jump to %td"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/maybe_pop_jump to %ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|pop_failure_jump
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/pop_failure_jump to %td"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/pop_failure_jump to %ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|jump_past_alt
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/jump_past_alt to %td"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/jump_past_alt to %ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|jump
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/jump to %td"
argument_list|,
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/jump to %ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|+
name|mcnt
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|succeed_n
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt2
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/succeed_n to %td, %d times"
argument_list|,
name|p1
operator|-
name|start
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/succeed_n to %ld, %d times"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p1
operator|-
name|start
argument_list|)
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|jump_n
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt2
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/jump_n to %d, %d times"
argument_list|,
name|p1
operator|-
name|start
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
break|break;
case|case
name|set_number_at
case|:
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|PREFIX
argument_list|(
name|extract_number_and_incr
argument_list|)
argument_list|(
operator|&
name|mcnt2
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"/set_number_at location %td to %d"
argument_list|,
name|p1
operator|-
name|start
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"/set_number_at location %ld to %d"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p1
operator|-
name|start
argument_list|)
argument_list|,
name|mcnt2
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|wordbound
case|:
name|printf
argument_list|(
literal|"/wordbound"
argument_list|)
expr_stmt|;
break|break;
case|case
name|notwordbound
case|:
name|printf
argument_list|(
literal|"/notwordbound"
argument_list|)
expr_stmt|;
break|break;
case|case
name|wordbeg
case|:
name|printf
argument_list|(
literal|"/wordbeg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|wordend
case|:
name|printf
argument_list|(
literal|"/wordend"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
name|printf
argument_list|(
literal|"/before_dot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|at_dot
case|:
name|printf
argument_list|(
literal|"/at_dot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|after_dot
case|:
name|printf
argument_list|(
literal|"/after_dot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|syntaxspec
case|:
name|printf
argument_list|(
literal|"/syntaxspec"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/%d"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|printf
argument_list|(
literal|"/notsyntaxspec"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"/%d"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
name|wordchar
case|:
name|printf
argument_list|(
literal|"/wordchar"
argument_list|)
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
name|printf
argument_list|(
literal|"/notwordchar"
argument_list|)
expr_stmt|;
break|break;
case|case
name|begbuf
case|:
name|printf
argument_list|(
literal|"/begbuf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|endbuf
case|:
name|printf
argument_list|(
literal|"/endbuf"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?%ld"
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"%td:\tend of pattern.\n"
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%ld:\tend of pattern.\n"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|p
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|PREFIX
function|(
name|print_compiled_pattern
function|)
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
block|{
name|UCHAR_T
modifier|*
name|buffer
init|=
operator|(
name|UCHAR_T
operator|*
operator|)
name|bufp
operator|->
name|buffer
decl_stmt|;
name|PREFIX
argument_list|(
name|print_partial_compiled_pattern
argument_list|)
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|+
name|bufp
operator|->
name|used
operator|/
sizeof|sizeof
argument_list|(
name|UCHAR_T
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ld bytes used/%ld bytes allocated.\n"
argument_list|,
name|bufp
operator|->
name|used
argument_list|,
name|bufp
operator|->
name|allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|fastmap_accurate
operator|&&
name|bufp
operator|->
name|fastmap
condition|)
block|{
name|printf
argument_list|(
literal|"fastmap: "
argument_list|)
expr_stmt|;
name|print_fastmap
argument_list|(
name|bufp
operator|->
name|fastmap
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
name|printf
argument_list|(
literal|"re_nsub: %Zd\t"
argument_list|,
name|bufp
operator|->
name|re_nsub
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"re_nsub: %ld\t"
argument_list|,
operator|(
name|long
name|int
operator|)
name|bufp
operator|->
name|re_nsub
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"regs_alloc: %d\t"
argument_list|,
name|bufp
operator|->
name|regs_allocated
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"can_be_null: %d\t"
argument_list|,
name|bufp
operator|->
name|can_be_null
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"newline_anchor: %d\n"
argument_list|,
name|bufp
operator|->
name|newline_anchor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no_sub: %d\t"
argument_list|,
name|bufp
operator|->
name|no_sub
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"not_bol: %d\t"
argument_list|,
name|bufp
operator|->
name|not_bol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"not_eol: %d\t"
argument_list|,
name|bufp
operator|->
name|not_eol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"syntax: %lx\n"
argument_list|,
name|bufp
operator|->
name|syntax
argument_list|)
expr_stmt|;
comment|/* Perhaps we should print the translate table?  */
block|}
end_function

begin_function
name|void
name|PREFIX
function|(
name|print_double_string
function|)
parameter_list|(
specifier|const
name|CHAR_T
modifier|*
name|where
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|)
block|{
name|int
name|this_char
decl_stmt|;
if|if
condition|(
name|where
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"(null)"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|FIRST_STRING_P
argument_list|(
name|where
argument_list|)
condition|)
block|{
for|for
control|(
name|this_char
operator|=
name|where
operator|-
name|string1
init|;
name|this_char
operator|<
name|size1
condition|;
name|this_char
operator|++
control|)
name|PUT_CHAR
argument_list|(
name|string1
index|[
name|this_char
index|]
argument_list|)
expr_stmt|;
name|where
operator|=
name|string2
expr_stmt|;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|this_char
operator|=
name|where
operator|-
name|string2
init|;
name|this_char
operator|<
name|size2
condition|;
name|this_char
operator|++
control|)
block|{
name|PUT_CHAR
argument_list|(
name|string2
index|[
name|this_char
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cnt
operator|>
literal|100
condition|)
block|{
name|fputs
argument_list|(
literal|"..."
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_function
name|void
name|printchar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not DEBUG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_STATEMENT
parameter_list|(
name|e
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT1
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT2
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT3
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT4
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|,
name|x3
parameter_list|,
name|x4
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_define
define|#
directive|define
name|DEBUG_PRINT_COMPILED_PATTERN
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|e
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINT_DOUBLE_STRING
parameter_list|(
name|w
parameter_list|,
name|s1
parameter_list|,
name|sz1
parameter_list|,
name|s2
parameter_list|,
name|sz2
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEBUG */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_comment
comment|/* This  convert a multibyte string to a wide character string.    And write their correspondances to offset_buffer(see below)    and write whether each wchar_t is binary data to is_binary.    This assume invalid multibyte sequences as binary data.    We assume offset_buffer and is_binary is already allocated    enough space.  */
end_comment

begin_function_decl
specifier|static
name|size_t
name|convert_mbs_to_wcs
parameter_list|(
name|CHAR_T
modifier|*
name|dest
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
modifier|*
name|offset_buffer
parameter_list|,
name|char
modifier|*
name|is_binary
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|size_t
name|convert_mbs_to_wcs
parameter_list|(
name|CHAR_T
modifier|*
name|dest
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
modifier|*
name|offset_buffer
parameter_list|,
name|char
modifier|*
name|is_binary
parameter_list|)
comment|/* It hold correspondances between src(char string) and 	dest(wchar_t string) for optimization. 	e.g. src  = "xxxyzz"              dest = {'X', 'Y', 'Z'} 	      (each "xxx", "y" and "zz" represent one multibyte character 	       corresponding to 'X', 'Y' and 'Z'.) 	  offset_buffer = {0, 0+3("xxx"), 0+3+1("y"), 0+3+1+2("zz")} 	  	        = {0, 3, 4, 6}      */
block|{
name|wchar_t
modifier|*
name|pdest
init|=
name|dest
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|psrc
init|=
name|src
decl_stmt|;
name|size_t
name|wc_count
init|=
literal|0
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|consumed
decl_stmt|;
name|size_t
name|mb_remain
init|=
name|len
decl_stmt|;
name|size_t
name|mb_count
init|=
literal|0
decl_stmt|;
comment|/* Initialize the conversion state.  */
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|offset_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|mb_remain
operator|>
literal|0
condition|;
operator|++
name|wc_count
operator|,
operator|++
name|pdest
operator|,
name|mb_remain
operator|-=
name|consumed
operator|,
name|psrc
operator|+=
name|consumed
control|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|consumed
operator|=
name|__mbrtowc
argument_list|(
name|pdest
argument_list|,
name|psrc
argument_list|,
name|mb_remain
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
else|#
directive|else
name|consumed
operator|=
name|mbrtowc
argument_list|(
name|pdest
argument_list|,
name|psrc
argument_list|,
name|mb_remain
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|consumed
operator|<=
literal|0
condition|)
comment|/* failed to convert. maybe src contains binary data. 	   So we consume 1 byte manualy.  */
block|{
operator|*
name|pdest
operator|=
operator|*
name|psrc
expr_stmt|;
name|consumed
operator|=
literal|1
expr_stmt|;
name|is_binary
index|[
name|wc_count
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|is_binary
index|[
name|wc_count
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* In sjis encoding, we use yen sign as escape character in 	 place of reverse solidus. So we convert 0x5c(yen sign in 	 sjis) to not 0xa5(yen sign in UCS2) but 0x5c(reverse 	 solidus in UCS2).  */
if|if
condition|(
name|consumed
operator|==
literal|1
operator|&&
operator|(
name|int
operator|)
operator|*
name|psrc
operator|==
literal|0x5c
operator|&&
operator|(
name|int
operator|)
operator|*
name|pdest
operator|==
literal|0xa5
condition|)
operator|*
name|pdest
operator|=
operator|(
name|wchar_t
operator|)
operator|*
name|psrc
expr_stmt|;
name|offset_buffer
index|[
name|wc_count
operator|+
literal|1
index|]
operator|=
name|mb_count
operator|+=
name|consumed
expr_stmt|;
block|}
comment|/* Fill remain of the buffer with sentinel.  */
for|for
control|(
name|i
operator|=
name|wc_count
operator|+
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
name|offset_buffer
index|[
name|i
index|]
operator|=
name|mb_count
operator|+
literal|1
expr_stmt|;
return|return
name|wc_count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_comment
comment|/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can    also be assigned to arbitrarily: each pattern buffer stores its own    syntax, so it can be changed between regex compilations.  */
end_comment

begin_comment
comment|/* This has no initializer because initialized variables in Emacs    become read-only after dumping.  */
end_comment

begin_decl_stmt
name|reg_syntax_t
name|re_syntax_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the precise syntax of regexps for compilation.  This provides    for compatibility for various utilities which historically have    different, incompatible syntaxes.     The argument SYNTAX is a bit mask comprised of the various bits    defined in regex.h.  We return the old syntax.  */
end_comment

begin_function
name|reg_syntax_t
name|re_set_syntax
parameter_list|(
name|reg_syntax_t
name|syntax
parameter_list|)
block|{
name|reg_syntax_t
name|ret
init|=
name|re_syntax_options
decl_stmt|;
name|re_syntax_options
operator|=
name|syntax
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|syntax
operator|&
name|RE_DEBUG
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
condition|)
comment|/* was on but now is not */
name|debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_set_syntax
argument_list|,
argument|re_set_syntax
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This table gives an error message for each of the error codes listed    in regex.h.  Obviously the order here has to be same as there.    POSIX doesn't require that we do anything for REG_NOERROR,    but why not be nice?  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|re_error_msgid
index|[]
init|=
block|{
name|gettext_noop
argument_list|(
literal|"Success"
argument_list|)
block|,
comment|/* REG_NOERROR */
name|gettext_noop
argument_list|(
literal|"No match"
argument_list|)
block|,
comment|/* REG_NOMATCH */
name|gettext_noop
argument_list|(
literal|"Invalid regular expression"
argument_list|)
block|,
comment|/* REG_BADPAT */
name|gettext_noop
argument_list|(
literal|"Invalid collation character"
argument_list|)
block|,
comment|/* REG_ECOLLATE */
name|gettext_noop
argument_list|(
literal|"Invalid character class name"
argument_list|)
block|,
comment|/* REG_ECTYPE */
name|gettext_noop
argument_list|(
literal|"Trailing backslash"
argument_list|)
block|,
comment|/* REG_EESCAPE */
name|gettext_noop
argument_list|(
literal|"Invalid back reference"
argument_list|)
block|,
comment|/* REG_ESUBREG */
name|gettext_noop
argument_list|(
literal|"Unmatched [ or [^"
argument_list|)
block|,
comment|/* REG_EBRACK */
name|gettext_noop
argument_list|(
literal|"Unmatched ( or \\("
argument_list|)
block|,
comment|/* REG_EPAREN */
name|gettext_noop
argument_list|(
literal|"Unmatched \\{"
argument_list|)
block|,
comment|/* REG_EBRACE */
name|gettext_noop
argument_list|(
literal|"Invalid content of \\{\\}"
argument_list|)
block|,
comment|/* REG_BADBR */
name|gettext_noop
argument_list|(
literal|"Invalid range end"
argument_list|)
block|,
comment|/* REG_ERANGE */
name|gettext_noop
argument_list|(
literal|"Memory exhausted"
argument_list|)
block|,
comment|/* REG_ESPACE */
name|gettext_noop
argument_list|(
literal|"Invalid preceding regular expression"
argument_list|)
block|,
comment|/* REG_BADRPT */
name|gettext_noop
argument_list|(
literal|"Premature end of regular expression"
argument_list|)
block|,
comment|/* REG_EEND */
name|gettext_noop
argument_list|(
literal|"Regular expression too big"
argument_list|)
block|,
comment|/* REG_ESIZE */
name|gettext_noop
argument_list|(
literal|"Unmatched ) or \\)"
argument_list|)
comment|/* REG_ERPAREN */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSIDE_RECURSION */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_comment
comment|/* Avoiding alloca during matching, to placate r_alloc.  */
end_comment

begin_comment
comment|/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the    searching and matching functions should not call alloca.  On some    systems, alloca is implemented in terms of malloc, and if we're    using the relocating allocator routines, then malloc could cause a    relocation, which might (if the strings being searched are in the    ralloc heap) shift the data out from underneath the regexp    routines.     Here's another reason to avoid allocation: Emacs    processes input from X in a signal handler; processing X input may    call malloc; if input arrives while a matching routine is calling    malloc, then we're scrod.  But Emacs can't just block input while    calling matching routines; then we don't notice interrupts when    they come in.  So, Emacs blocks input around all regexp calls    except the matching calls, which it leaves unprotected, in the    faith that they will not malloc.  */
end_comment

begin_comment
comment|/* Normally, this is fine.  */
end_comment

begin_define
define|#
directive|define
name|MATCH_MAY_ALLOCATE
end_define

begin_comment
comment|/* When using GNU C, we are not REALLY using the C alloca, no matter    what config.h may say.  So don't take precautions for it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_undef
undef|#
directive|undef
name|C_ALLOCA
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The match routines may not allocate if (1) they would do it with malloc    and (2) it's not safe for them to use malloc.    Note that if REL_ALLOC is defined, matching would not use malloc for the    failure stack, but we would still use it for the register vectors;    so REL_ALLOC should not affect this.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
name|C_ALLOCA
operator|||
name|defined
name|REGEX_MALLOC
operator|)
operator|&&
name|defined
name|emacs
end_if

begin_undef
undef|#
directive|undef
name|MATCH_MAY_ALLOCATE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|INSIDE_RECURSION
end_ifdef

begin_comment
comment|/* Failure stack declarations and macros; both re_compile_fastmap and    re_match_2 use a failure stack.  These have to be macros because of    REGEX_ALLOCATE_STACK.  */
end_comment

begin_comment
comment|/* Number of failure points for which to initially allocate space    when matching.  If this number is exceeded, we allocate more    space, so it is not a hard limit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INIT_FAILURE_ALLOC
end_ifndef

begin_define
define|#
directive|define
name|INIT_FAILURE_ALLOC
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Roughly the maximum number of failure points on the stack.  Would be    exactly that if always used MAX_FAILURE_ITEMS items each time we failed.    This is a variable only so users of regex can assign to it; we never    change it ourselves.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INT_IS_16BIT
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_if
if|#
directive|if
name|defined
name|MATCH_MAY_ALLOCATE
end_if

begin_comment
comment|/* 4400 was enough to cause a crash on Alpha OSF/1,    whose default stack limit is 2mb.  */
end_comment

begin_decl_stmt
name|long
name|int
name|re_max_failures
init|=
literal|4000
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|long
name|int
name|re_max_failures
init|=
literal|2000
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|union
name|PREFIX
function|(
name|fail_stack_elt
function|)
block|{
name|UCHAR_T
modifier|*
name|pointer
decl_stmt|;
name|long
name|int
name|integer
decl_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|union
name|PREFIX
function_decl|(
name|fail_stack_elt
function_decl|)
name|PREFIX
argument_list|(
argument|fail_stack_elt_t
argument_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|*
name|stack
expr_stmt|;
name|unsigned
name|long
name|int
name|size
decl_stmt|;
name|unsigned
name|long
name|int
name|avail
decl_stmt|;
comment|/* Offset of next open position.  */
block|}
name|PREFIX
typedef|(
name|fail_stack_type
typedef|);
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INT_IS_16BIT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_if
if|#
directive|if
name|defined
name|MATCH_MAY_ALLOCATE
end_if

begin_comment
comment|/* 4400 was enough to cause a crash on Alpha OSF/1,    whose default stack limit is 2mb.  */
end_comment

begin_decl_stmt
name|int
name|re_max_failures
init|=
literal|4000
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|re_max_failures
init|=
literal|2000
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|union
name|PREFIX
function|(
name|fail_stack_elt
function|)
block|{
name|UCHAR_T
modifier|*
name|pointer
decl_stmt|;
name|int
name|integer
decl_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|union
name|PREFIX
function_decl|(
name|fail_stack_elt
function_decl|)
name|PREFIX
argument_list|(
argument|fail_stack_elt_t
argument_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|*
name|stack
expr_stmt|;
name|unsigned
name|size
decl_stmt|;
name|unsigned
name|avail
decl_stmt|;
comment|/* Offset of next open position.  */
block|}
name|PREFIX
typedef|(
name|fail_stack_type
typedef|);
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INT_IS_16BIT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_define
define|#
directive|define
name|FAIL_STACK_EMPTY
parameter_list|()
value|(fail_stack.avail == 0)
end_define

begin_define
define|#
directive|define
name|FAIL_STACK_PTR_EMPTY
parameter_list|()
value|(fail_stack_ptr->avail == 0)
end_define

begin_define
define|#
directive|define
name|FAIL_STACK_FULL
parameter_list|()
value|(fail_stack.avail == fail_stack.size)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define macros to initialize and free the failure stack.    Do `return -2' if the alloc fails.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
end_ifdef

begin_define
define|#
directive|define
name|INIT_FAIL_STACK
parameter_list|()
define|\
value|do {									\     fail_stack.stack = (PREFIX(fail_stack_elt_t) *)		\       REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (PREFIX(fail_stack_elt_t))); \ 									\     if (fail_stack.stack == NULL)				\       return -2;							\ 									\     fail_stack.size = INIT_FAILURE_ALLOC;			\     fail_stack.avail = 0;					\   } while (0)
end_define

begin_define
define|#
directive|define
name|RESET_FAIL_STACK
parameter_list|()
value|REGEX_FREE_STACK (fail_stack.stack)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INIT_FAIL_STACK
parameter_list|()
define|\
value|do {									\     fail_stack.avail = 0;					\   } while (0)
end_define

begin_define
define|#
directive|define
name|RESET_FAIL_STACK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.     Return 1 if succeeds, and 0 if either ran out of memory    allocating space for it or it was already too large.     REGEX_REALLOCATE_STACK requires `destination' be declared.   */
end_comment

begin_define
define|#
directive|define
name|DOUBLE_FAIL_STACK
parameter_list|(
name|fail_stack
parameter_list|)
define|\
value|((fail_stack).size> (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\    ? 0									\    : ((fail_stack).stack = (PREFIX(fail_stack_elt_t) *)			\         REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\           (fail_stack).size * sizeof (PREFIX(fail_stack_elt_t)),	\           ((fail_stack).size<< 1) * sizeof (PREFIX(fail_stack_elt_t))),\ 									\       (fail_stack).stack == NULL					\       ? 0								\       : ((fail_stack).size<<= 1, 					\          1)))
end_define

begin_comment
comment|/* Push pointer POINTER on FAIL_STACK.    Return 1 if was able to do so and 0 if ran out of memory allocating    space to do so.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_PATTERN_OP
parameter_list|(
name|POINTER
parameter_list|,
name|FAIL_STACK
parameter_list|)
define|\
value|((FAIL_STACK_FULL ()							\&& !DOUBLE_FAIL_STACK (FAIL_STACK))					\    ? 0									\    : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,	\       1))
end_define

begin_comment
comment|/* Push a pointer value onto the failure stack.    Assumes the variable `fail_stack'.  Probably should only    be called from within `PUSH_FAILURE_POINT'.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_FAILURE_POINTER
parameter_list|(
name|item
parameter_list|)
define|\
value|fail_stack.stack[fail_stack.avail++].pointer = (UCHAR_T *) (item)
end_define

begin_comment
comment|/* This pushes an integer-valued item onto the failure stack.    Assumes the variable `fail_stack'.  Probably should only    be called from within `PUSH_FAILURE_POINT'.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_FAILURE_INT
parameter_list|(
name|item
parameter_list|)
define|\
value|fail_stack.stack[fail_stack.avail++].integer = (item)
end_define

begin_comment
comment|/* Push a fail_stack_elt_t value onto the failure stack.    Assumes the variable `fail_stack'.  Probably should only    be called from within `PUSH_FAILURE_POINT'.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_FAILURE_ELT
parameter_list|(
name|item
parameter_list|)
define|\
value|fail_stack.stack[fail_stack.avail++] =  (item)
end_define

begin_comment
comment|/* These three POP... operations complement the three PUSH... operations.    All assume that `fail_stack' is nonempty.  */
end_comment

begin_define
define|#
directive|define
name|POP_FAILURE_POINTER
parameter_list|()
value|fail_stack.stack[--fail_stack.avail].pointer
end_define

begin_define
define|#
directive|define
name|POP_FAILURE_INT
parameter_list|()
value|fail_stack.stack[--fail_stack.avail].integer
end_define

begin_define
define|#
directive|define
name|POP_FAILURE_ELT
parameter_list|()
value|fail_stack.stack[--fail_stack.avail]
end_define

begin_comment
comment|/* Used to omit pushing failure point id's when we're not debugging.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEBUG_PUSH
value|PUSH_FAILURE_INT
end_define

begin_define
define|#
directive|define
name|DEBUG_POP
parameter_list|(
name|item_addr
parameter_list|)
value|*(item_addr) = POP_FAILURE_INT ()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG_PUSH
parameter_list|(
name|item
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUG_POP
parameter_list|(
name|item_addr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Push the information about the state we will need    if we ever fail back to it.     Requires variables fail_stack, regstart, regend, reg_info, and    num_regs_pushed be declared.  DOUBLE_FAIL_STACK requires `destination'    be declared.     Does `return FAILURE_CODE' if runs out of memory.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_FAILURE_POINT
parameter_list|(
name|pattern_place
parameter_list|,
name|string_place
parameter_list|,
name|failure_code
parameter_list|)
define|\
value|do {									\     char *destination;							\
comment|/* Must be int, so when we don't save any registers, the arithmetic	\        of 0 + -1 isn't done as unsigned.  */
value|\
comment|/* Can't be int, since there is not a shred of a guarantee that int	\        is wide enough to hold a value of something to which pointer can	\        be assigned */
value|\     active_reg_t this_reg;						\     									\     DEBUG_STATEMENT (failure_id++);					\     DEBUG_STATEMENT (nfailure_points_pushed++);				\     DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\     DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\     DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\ 									\     DEBUG_PRINT2 ("  slots needed: %ld\n", NUM_FAILURE_ITEMS);		\     DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\ 									\
comment|/* Ensure we have enough space allocated for what we will push.  */
value|\     while (REMAINING_AVAIL_SLOTS< NUM_FAILURE_ITEMS)			\       {									\         if (!DOUBLE_FAIL_STACK (fail_stack))				\           return failure_code;						\ 									\         DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\ 		       (fail_stack).size);				\         DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\       }									\ 									\
comment|/* Push the info, starting with the registers.  */
value|\     DEBUG_PRINT1 ("\n");						\ 									\     if (1)								\       for (this_reg = lowest_active_reg; this_reg<= highest_active_reg; \ 	   this_reg++)							\ 	{								\ 	  DEBUG_PRINT2 ("  Pushing reg: %lu\n", this_reg);		\ 	  DEBUG_STATEMENT (num_regs_pushed++);				\ 									\ 	  DEBUG_PRINT2 ("    start: %p\n", regstart[this_reg]);		\ 	  PUSH_FAILURE_POINTER (regstart[this_reg]);			\ 									\ 	  DEBUG_PRINT2 ("    end: %p\n", regend[this_reg]);		\ 	  PUSH_FAILURE_POINTER (regend[this_reg]);			\ 									\ 	  DEBUG_PRINT2 ("    info: %p\n      ",				\ 			reg_info[this_reg].word.pointer);		\ 	  DEBUG_PRINT2 (" match_null=%d",				\ 			REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\ 	  DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\ 	  DEBUG_PRINT2 (" matched_something=%d",			\ 			MATCHED_SOMETHING (reg_info[this_reg]));	\ 	  DEBUG_PRINT2 (" ever_matched=%d",				\ 			EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\ 	  DEBUG_PRINT1 ("\n");						\ 	  PUSH_FAILURE_ELT (reg_info[this_reg].word);			\ 	}								\ 									\     DEBUG_PRINT2 ("  Pushing  low active reg: %ld\n", lowest_active_reg);\     PUSH_FAILURE_INT (lowest_active_reg);				\ 									\     DEBUG_PRINT2 ("  Pushing high active reg: %ld\n", highest_active_reg);\     PUSH_FAILURE_INT (highest_active_reg);				\ 									\     DEBUG_PRINT2 ("  Pushing pattern %p:\n", pattern_place);		\     DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\     PUSH_FAILURE_POINTER (pattern_place);				\ 									\     DEBUG_PRINT2 ("  Pushing string %p: `", string_place);		\     DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \ 				 size2);				\     DEBUG_PRINT1 ("'\n");						\     PUSH_FAILURE_POINTER (string_place);				\ 									\     DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\     DEBUG_PUSH (failure_id);						\   } while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_comment
comment|/* This is the number of items that are pushed and popped on the stack    for each register.  */
end_comment

begin_define
define|#
directive|define
name|NUM_REG_ITEMS
value|3
end_define

begin_comment
comment|/* Individual items aside from the registers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|NUM_NONREG_ITEMS
value|5
end_define

begin_comment
comment|/* Includes failure point id.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUM_NONREG_ITEMS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We push at most this many items on the stack.  */
end_comment

begin_comment
comment|/* We used to use (num_regs - 1), which is the number of registers    this regexp will save; but that was changed to 5    to avoid stack overflow for a regexp with lots of parens.  */
end_comment

begin_define
define|#
directive|define
name|MAX_FAILURE_ITEMS
value|(5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
end_define

begin_comment
comment|/* We actually push this many items.  */
end_comment

begin_define
define|#
directive|define
name|NUM_FAILURE_ITEMS
define|\
value|(((0							\      ? 0 : highest_active_reg - lowest_active_reg + 1)	\     * NUM_REG_ITEMS)					\    + NUM_NONREG_ITEMS)
end_define

begin_comment
comment|/* How many items can still be added to the stack without overflowing it.  */
end_comment

begin_define
define|#
directive|define
name|REMAINING_AVAIL_SLOTS
value|((fail_stack).size - (fail_stack).avail)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_comment
comment|/* Pops what PUSH_FAIL_STACK pushes.     We restore into the parameters, all of which should be lvalues:      STR -- the saved data position.      PAT -- the saved pattern position.      LOW_REG, HIGH_REG -- the highest and lowest active registers.      REGSTART, REGEND -- arrays of string positions.      REG_INFO -- array of information about each subexpression.     Also assumes the variables `fail_stack' and (if debugging), `bufp',    `pend', `string1', `size1', `string2', and `size2'.  */
end_comment

begin_define
define|#
directive|define
name|POP_FAILURE_POINT
parameter_list|(
name|str
parameter_list|,
name|pat
parameter_list|,
name|low_reg
parameter_list|,
name|high_reg
parameter_list|,
name|regstart
parameter_list|,
name|regend
parameter_list|,
name|reg_info
parameter_list|)
define|\
value|{									\   DEBUG_STATEMENT (unsigned failure_id;)				\   active_reg_t this_reg;						\   const UCHAR_T *string_temp;						\ 									\   assert (!FAIL_STACK_EMPTY ());					\ 									\
comment|/* Remove failure points and point to how many regs pushed.  */
value|\   DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\   DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\   DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\ 									\   assert (fail_stack.avail>= NUM_NONREG_ITEMS);			\ 									\   DEBUG_POP (&failure_id);						\   DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\ 									\
comment|/* If the saved string location is NULL, it came from an		\      on_failure_keep_string_jump opcode, and we want to throw away the	\      saved NULL, thus retaining our current position in the string.  */
value|\   string_temp = POP_FAILURE_POINTER ();					\   if (string_temp != NULL)						\     str = (const CHAR_T *) string_temp;					\ 									\   DEBUG_PRINT2 ("  Popping string %p: `", str);				\   DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\   DEBUG_PRINT1 ("'\n");							\ 									\   pat = (UCHAR_T *) POP_FAILURE_POINTER ();				\   DEBUG_PRINT2 ("  Popping pattern %p:\n", pat);			\   DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\ 									\
comment|/* Restore register info.  */
value|\   high_reg = (active_reg_t) POP_FAILURE_INT ();				\   DEBUG_PRINT2 ("  Popping high active reg: %ld\n", high_reg);		\ 									\   low_reg = (active_reg_t) POP_FAILURE_INT ();				\   DEBUG_PRINT2 ("  Popping  low active reg: %ld\n", low_reg);		\ 									\   if (1)								\     for (this_reg = high_reg; this_reg>= low_reg; this_reg--)		\       {									\ 	DEBUG_PRINT2 ("    Popping reg: %ld\n", this_reg);		\ 									\ 	reg_info[this_reg].word = POP_FAILURE_ELT ();			\ 	DEBUG_PRINT2 ("      info: %p\n",				\ 		      reg_info[this_reg].word.pointer);			\ 									\ 	regend[this_reg] = (const CHAR_T *) POP_FAILURE_POINTER ();	\ 	DEBUG_PRINT2 ("      end: %p\n", regend[this_reg]);		\ 									\ 	regstart[this_reg] = (const CHAR_T *) POP_FAILURE_POINTER ();	\ 	DEBUG_PRINT2 ("      start: %p\n", regstart[this_reg]);		\       }									\   else									\     {									\       for (this_reg = highest_active_reg; this_reg> high_reg; this_reg--) \ 	{								\ 	  reg_info[this_reg].word.integer = 0;				\ 	  regend[this_reg] = 0;						\ 	  regstart[this_reg] = 0;					\ 	}								\       highest_active_reg = high_reg;					\     }									\ 									\   set_regs_matched_done = 0;						\   DEBUG_STATEMENT (nfailure_points_popped++);				\ }
end_define

begin_comment
comment|/* POP_FAILURE_POINT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Structure for per-register (a.k.a. per-group) information.    Other register information, such as the    starting and ending positions (which are addresses), and the list of    inner groups (which is a bits list) are maintained in separate    variables.     We are making a (strictly speaking) nonportable assumption here: that    the compiler will pack our bit fields into something that fits into    the type of `word', i.e., is something that fits into one item on the    failure stack.  */
end_comment

begin_comment
comment|/* Declarations and macros for re_match_2.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|PREFIX
argument_list|(
argument|fail_stack_elt_t
argument_list|)
name|word
expr_stmt|;
struct|struct
block|{
comment|/* This field is one if this group can match the empty string,          zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
define|#
directive|define
name|MATCH_NULL_UNSET_VALUE
value|3
name|unsigned
name|match_null_string_p
range|:
literal|2
decl_stmt|;
name|unsigned
name|is_active
range|:
literal|1
decl_stmt|;
name|unsigned
name|matched_something
range|:
literal|1
decl_stmt|;
name|unsigned
name|ever_matched_something
range|:
literal|1
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|PREFIX
typedef|(
name|register_info_type
typedef|);
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_define
define|#
directive|define
name|REG_MATCH_NULL_STRING_P
parameter_list|(
name|R
parameter_list|)
value|((R).bits.match_null_string_p)
end_define

begin_define
define|#
directive|define
name|IS_ACTIVE
parameter_list|(
name|R
parameter_list|)
value|((R).bits.is_active)
end_define

begin_define
define|#
directive|define
name|MATCHED_SOMETHING
parameter_list|(
name|R
parameter_list|)
value|((R).bits.matched_something)
end_define

begin_define
define|#
directive|define
name|EVER_MATCHED_SOMETHING
parameter_list|(
name|R
parameter_list|)
value|((R).bits.ever_matched_something)
end_define

begin_comment
comment|/* Call this when have matched a real character; it sets `matched' flags    for the subexpressions which we are currently inside.  Also records    that those subexprs have matched.  */
end_comment

begin_define
define|#
directive|define
name|SET_REGS_MATCHED
parameter_list|()
define|\
value|do									\     {									\       if (!set_regs_matched_done)					\ 	{								\ 	  active_reg_t r;						\ 	  set_regs_matched_done = 1;					\ 	  for (r = lowest_active_reg; r<= highest_active_reg; r++)	\ 	    {								\ 	      MATCHED_SOMETHING (reg_info[r])				\ 		= EVER_MATCHED_SOMETHING (reg_info[r])			\ 		= 1;							\ 	    }								\ 	}								\     }									\   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_comment
comment|/* Registers are set to a sentinel when they haven't yet matched.  */
end_comment

begin_function_decl
specifier|static
name|CHAR_T
name|PREFIX
parameter_list|(
name|reg_unset_dummy
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|REG_UNSET_VALUE
value|(&PREFIX(reg_unset_dummy))
end_define

begin_define
define|#
directive|define
name|REG_UNSET
parameter_list|(
name|e
parameter_list|)
value|((e) == REG_UNSET_VALUE)
end_define

begin_comment
comment|/* Subroutine declarations and macros for regex_compile.  */
end_comment

begin_function_decl
specifier|static
name|void
name|PREFIX
function_decl|(
name|store_op1
function_decl|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PREFIX
function_decl|(
name|store_op2
function_decl|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PREFIX
function_decl|(
name|insert_op1
function_decl|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg
parameter_list|,
name|UCHAR_T
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PREFIX
function_decl|(
name|insert_op2
function_decl|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|,
name|UCHAR_T
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|PREFIX
function_decl|(
name|at_begline_loc_p
function_decl|)
parameter_list|(
specifier|const
name|CHAR_T
modifier|*
name|pattern
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|p
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|PREFIX
function_decl|(
name|at_endline_loc_p
function_decl|)
parameter_list|(
specifier|const
name|CHAR_T
modifier|*
name|p
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|pend
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_function_decl
specifier|static
name|reg_errcode_t
name|wcs_compile_range
parameter_list|(
name|CHAR_T
name|range_start
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
modifier|*
name|p_ptr
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|pend
parameter_list|,
name|char
modifier|*
name|translate
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|UCHAR_T
modifier|*
name|b
parameter_list|,
name|CHAR_T
modifier|*
name|char_set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_space
parameter_list|(
name|int
name|num
parameter_list|,
name|CHAR_T
modifier|*
name|loc
parameter_list|,
name|CHAR_T
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_function_decl
specifier|static
name|reg_errcode_t
name|byte_compile_range
parameter_list|(
name|unsigned
name|int
name|range_start
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|p_ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|pend
parameter_list|,
name|char
modifier|*
name|translate
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_comment
comment|/* Fetch the next character in the uncompiled pattern---translating it    if necessary.  Also cast from a signed character in the constant    string passed to us by the user to an unsigned char that we can use    as an array index (in, e.g., `translate').  */
end_comment

begin_comment
comment|/* ifdef MBS_SUPPORT, we translate only if character<= 0xff,    because it is impossible to allocate 4GB array for some encodings    which have 4 byte character_set like UCS4.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATFETCH
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|PATFETCH
parameter_list|(
name|c
parameter_list|)
define|\
value|do {if (p == pend) return REG_EEND;					\     c = (UCHAR_T) *p++;							\     if (translate&& (c<= 0xff)) c = (UCHAR_T) translate[c];		\   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|PATFETCH
parameter_list|(
name|c
parameter_list|)
define|\
value|do {if (p == pend) return REG_EEND;					\     c = (unsigned char) *p++;						\     if (translate) c = (unsigned char) translate[c];			\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fetch the next character in the uncompiled pattern, with no    translation.  */
end_comment

begin_define
define|#
directive|define
name|PATFETCH_RAW
parameter_list|(
name|c
parameter_list|)
define|\
value|do {if (p == pend) return REG_EEND;					\     c = (UCHAR_T) *p++; 	       					\   } while (0)
end_define

begin_comment
comment|/* Go backwards one character in the pattern.  */
end_comment

begin_define
define|#
directive|define
name|PATUNFETCH
value|p--
end_define

begin_comment
comment|/* If `translate' is non-null, return translate[D], else just D.  We    cast the subscript to translate because some data is declared as    `char *', to avoid warnings when a string constant is passed.  But    when we use a character as a subscript we must make it unsigned.  */
end_comment

begin_comment
comment|/* ifdef MBS_SUPPORT, we translate only if character<= 0xff,    because it is impossible to allocate 4GB array for some encodings    which have 4 byte character_set like UCS4.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRANSLATE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|TRANSLATE
parameter_list|(
name|d
parameter_list|)
define|\
value|((translate&& ((UCHAR_T) (d))<= 0xff) \    ? (char) translate[(unsigned char) (d)] : (d))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|TRANSLATE
parameter_list|(
name|d
parameter_list|)
define|\
value|(translate ? (char) translate[(unsigned char) (d)] : (char) (d))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros for outputting the compiled pattern into `buffer'.  */
end_comment

begin_comment
comment|/* If the buffer isn't allocated when it comes in, use this.  */
end_comment

begin_define
define|#
directive|define
name|INIT_BUF_SIZE
value|(32 * sizeof(UCHAR_T))
end_define

begin_comment
comment|/* Make sure we have at least N more bytes of space in buffer.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|GET_BUFFER_SPACE
parameter_list|(
name|n
parameter_list|)
define|\
value|while (((unsigned long)b - (unsigned long)COMPILED_BUFFER_VAR	\             + (n)*sizeof(CHAR_T))> bufp->allocated)			\       EXTEND_BUFFER ()
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|GET_BUFFER_SPACE
parameter_list|(
name|n
parameter_list|)
define|\
value|while ((unsigned long) (b - bufp->buffer + (n))> bufp->allocated)	\       EXTEND_BUFFER ()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_comment
comment|/* Make sure we have one more byte of buffer space and then add C to it.  */
end_comment

begin_define
define|#
directive|define
name|BUF_PUSH
parameter_list|(
name|c
parameter_list|)
define|\
value|do {									\     GET_BUFFER_SPACE (1);						\     *b++ = (UCHAR_T) (c);						\   } while (0)
end_define

begin_comment
comment|/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
end_comment

begin_define
define|#
directive|define
name|BUF_PUSH_2
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
define|\
value|do {									\     GET_BUFFER_SPACE (2);						\     *b++ = (UCHAR_T) (c1);						\     *b++ = (UCHAR_T) (c2);						\   } while (0)
end_define

begin_comment
comment|/* As with BUF_PUSH_2, except for three bytes.  */
end_comment

begin_define
define|#
directive|define
name|BUF_PUSH_3
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|c3
parameter_list|)
define|\
value|do {									\     GET_BUFFER_SPACE (3);						\     *b++ = (UCHAR_T) (c1);						\     *b++ = (UCHAR_T) (c2);						\     *b++ = (UCHAR_T) (c3);						\   } while (0)
end_define

begin_comment
comment|/* Store a jump with opcode OP at LOC to location TO.  We store a    relative address offset by the three bytes the jump itself occupies.  */
end_comment

begin_define
define|#
directive|define
name|STORE_JUMP
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|)
define|\
value|PREFIX(store_op1) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)))
end_define

begin_comment
comment|/* Likewise, for a two-argument jump.  */
end_comment

begin_define
define|#
directive|define
name|STORE_JUMP2
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|,
name|arg
parameter_list|)
define|\
value|PREFIX(store_op2) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)), arg)
end_define

begin_comment
comment|/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
end_comment

begin_define
define|#
directive|define
name|INSERT_JUMP
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|)
define|\
value|PREFIX(insert_op1) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)), b)
end_define

begin_comment
comment|/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
end_comment

begin_define
define|#
directive|define
name|INSERT_JUMP2
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|to
parameter_list|,
name|arg
parameter_list|)
define|\
value|PREFIX(insert_op2) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)),\ 	      arg, b)
end_define

begin_comment
comment|/* This is not an arbitrary limit: the arguments which represent offsets    into the pattern are two bytes long.  So if 2^16 bytes turns out to    be too small, many things would have to change.  */
end_comment

begin_comment
comment|/* Any other compiler which, like MSC, has allocation limit below 2^16    bytes will have to use approach similar to what was done below for    MSC and drop MAX_BUF_SIZE a bit.  Otherwise you may end up    reallocating to 0 bytes.  Such thing is not going to work too well.    You have been warned!!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_if
if|#
directive|if
name|defined
name|_MSC_VER
operator|&&
operator|!
name|defined
name|WIN32
end_if

begin_comment
comment|/* Microsoft C 16-bit versions limit malloc to approx 65512 bytes.    The REALLOC define eliminates a flurry of conversion warnings,    but is not required. */
end_comment

begin_define
define|#
directive|define
name|MAX_BUF_SIZE
value|65500L
end_define

begin_define
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|realloc ((p), (size_t) (s))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_BUF_SIZE
value|(1L<< 16)
end_define

begin_define
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|realloc ((p), (s))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Extend the buffer by twice its current size via realloc and    reset the pointers that pointed into the old block to point to the    correct places in the new one.  If extending the buffer results in it    being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
end_comment

begin_if
if|#
directive|if
name|__BOUNDED_POINTERS__
end_if

begin_define
define|#
directive|define
name|SET_HIGH_BOUND
parameter_list|(
name|P
parameter_list|)
value|(__ptrhigh (P) = __ptrlow (P) + bufp->allocated)
end_define

begin_define
define|#
directive|define
name|MOVE_BUFFER_POINTER
parameter_list|(
name|P
parameter_list|)
define|\
value|(__ptrlow (P) += incr, SET_HIGH_BOUND (P), __ptrvalue (P) += incr)
end_define

begin_define
define|#
directive|define
name|ELSE_EXTEND_BUFFER_HIGH_BOUND
define|\
value|else						\     {						\       SET_HIGH_BOUND (b);			\       SET_HIGH_BOUND (begalt);			\       if (fixup_alt_jump)			\ 	SET_HIGH_BOUND (fixup_alt_jump);	\       if (laststart)				\ 	SET_HIGH_BOUND (laststart);		\       if (pending_exact)			\ 	SET_HIGH_BOUND (pending_exact);		\     }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MOVE_BUFFER_POINTER
parameter_list|(
name|P
parameter_list|)
value|(P) += incr
end_define

begin_define
define|#
directive|define
name|ELSE_EXTEND_BUFFER_HIGH_BOUND
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|EXTEND_BUFFER
parameter_list|()
define|\
value|do {									\     UCHAR_T *old_buffer = COMPILED_BUFFER_VAR;				\     int wchar_count;							\     if (bufp->allocated + sizeof(UCHAR_T)> MAX_BUF_SIZE)		\       return REG_ESIZE;							\     bufp->allocated<<= 1;						\     if (bufp->allocated> MAX_BUF_SIZE)					\       bufp->allocated = MAX_BUF_SIZE;					\
comment|/* How many characters the new buffer can have?  */
value|\     wchar_count = bufp->allocated / sizeof(UCHAR_T);			\     if (wchar_count == 0) wchar_count = 1;				\
comment|/* Truncate the buffer to CHAR_T align.  */
value|\     bufp->allocated = wchar_count * sizeof(UCHAR_T);			\     RETALLOC (COMPILED_BUFFER_VAR, wchar_count, UCHAR_T);		\     bufp->buffer = (char*)COMPILED_BUFFER_VAR;				\     if (COMPILED_BUFFER_VAR == NULL)					\       return REG_ESPACE;						\
comment|/* If the buffer moved, move all the pointers into it.  */
value|\     if (old_buffer != COMPILED_BUFFER_VAR)				\       {									\ 	int incr = COMPILED_BUFFER_VAR - old_buffer;			\ 	MOVE_BUFFER_POINTER (b);					\ 	MOVE_BUFFER_POINTER (begalt);					\ 	if (fixup_alt_jump)						\ 	  MOVE_BUFFER_POINTER (fixup_alt_jump);				\ 	if (laststart)							\ 	  MOVE_BUFFER_POINTER (laststart);				\ 	if (pending_exact)						\ 	  MOVE_BUFFER_POINTER (pending_exact);				\       }									\     ELSE_EXTEND_BUFFER_HIGH_BOUND					\   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|EXTEND_BUFFER
parameter_list|()
define|\
value|do {									\     UCHAR_T *old_buffer = COMPILED_BUFFER_VAR;				\     if (bufp->allocated == MAX_BUF_SIZE)				\       return REG_ESIZE;							\     bufp->allocated<<= 1;						\     if (bufp->allocated> MAX_BUF_SIZE)					\       bufp->allocated = MAX_BUF_SIZE;					\     bufp->buffer = (UCHAR_T *) REALLOC (COMPILED_BUFFER_VAR,		\ 						bufp->allocated);	\     if (COMPILED_BUFFER_VAR == NULL)					\       return REG_ESPACE;						\
comment|/* If the buffer moved, move all the pointers into it.  */
value|\     if (old_buffer != COMPILED_BUFFER_VAR)				\       {									\ 	int incr = COMPILED_BUFFER_VAR - old_buffer;			\ 	MOVE_BUFFER_POINTER (b);					\ 	MOVE_BUFFER_POINTER (begalt);					\ 	if (fixup_alt_jump)						\ 	  MOVE_BUFFER_POINTER (fixup_alt_jump);				\ 	if (laststart)							\ 	  MOVE_BUFFER_POINTER (laststart);				\ 	if (pending_exact)						\ 	  MOVE_BUFFER_POINTER (pending_exact);				\       }									\     ELSE_EXTEND_BUFFER_HIGH_BOUND					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_comment
comment|/* Since we have one byte reserved for the register number argument to    {start,stop}_memory, the maximum number of groups we can report    things about is what fits in that byte.  */
end_comment

begin_define
define|#
directive|define
name|MAX_REGNUM
value|255
end_define

begin_comment
comment|/* But patterns can have more than `MAX_REGNUM' registers.  We just    ignore the excess.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|regnum_t
typedef|;
end_typedef

begin_comment
comment|/* Macros for the compile stack.  */
end_comment

begin_comment
comment|/* Since offsets can go either forwards or backwards, this type needs to    be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
end_comment

begin_comment
comment|/* int may be not enough when sizeof(int) == 2.  */
end_comment

begin_typedef
typedef|typedef
name|long
name|pattern_offset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|pattern_offset_t
name|begalt_offset
decl_stmt|;
name|pattern_offset_t
name|fixup_alt_jump
decl_stmt|;
name|pattern_offset_t
name|inner_group_offset
decl_stmt|;
name|pattern_offset_t
name|laststart_offset
decl_stmt|;
name|regnum_t
name|regnum
decl_stmt|;
block|}
name|compile_stack_elt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|compile_stack_elt_t
modifier|*
name|stack
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
name|unsigned
name|avail
decl_stmt|;
comment|/* Offset of next open position.  */
block|}
name|compile_stack_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INIT_COMPILE_STACK_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|COMPILE_STACK_EMPTY
value|(compile_stack.avail == 0)
end_define

begin_define
define|#
directive|define
name|COMPILE_STACK_FULL
value|(compile_stack.avail == compile_stack.size)
end_define

begin_comment
comment|/* The next available element.  */
end_comment

begin_define
define|#
directive|define
name|COMPILE_STACK_TOP
value|(compile_stack.stack[compile_stack.avail])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_comment
comment|/* Set the bit for character C in a list.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_define
define|#
directive|define
name|SET_LIST_BIT
parameter_list|(
name|c
parameter_list|)
define|\
value|(b[((unsigned char) (c)) / BYTEWIDTH]               \    |= 1<< (((unsigned char) c) % BYTEWIDTH))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEFINED_ONCE */
end_comment

begin_comment
comment|/* Get the next unsigned number in the uncompiled pattern.  */
end_comment

begin_define
define|#
directive|define
name|GET_UNSIGNED_NUMBER
parameter_list|(
name|num
parameter_list|)
define|\
value|{									\     while (p != pend)							\       {									\ 	PATFETCH (c);							\ 	if (c< '0' || c> '9')						\ 	  break;							\ 	if (num<= RE_DUP_MAX)						\ 	  {								\ 	    if (num< 0)						\ 	      num = 0;							\ 	    num = num * 10 + c - '0';					\ 	  }								\       }									\   }
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|WIDE_CHAR_SUPPORT
end_if

begin_comment
comment|/* The GNU C library provides support for user-defined character classes    and the functions from ISO C amendement 1.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CHARCLASS_NAME_MAX
end_ifdef

begin_define
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|CHARCLASS_NAME_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* This shouldn't happen but some implementation might still have this    problem.  Use a reasonable default value.  */
end_comment

begin_define
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|IS_CHAR_CLASS
parameter_list|(
name|string
parameter_list|)
value|__wctype (string)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_CHAR_CLASS
parameter_list|(
name|string
parameter_list|)
value|wctype (string)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|6
end_define

begin_comment
comment|/* Namely, `xdigit'.  */
end_comment

begin_define
define|#
directive|define
name|IS_CHAR_CLASS
parameter_list|(
name|string
parameter_list|)
define|\
value|(STREQ (string, "alpha") || STREQ (string, "upper")			\     || STREQ (string, "lower") || STREQ (string, "digit")		\     || STREQ (string, "alnum") || STREQ (string, "xdigit")		\     || STREQ (string, "space") || STREQ (string, "print")		\     || STREQ (string, "punct") || STREQ (string, "graph")		\     || STREQ (string, "cntrl") || STREQ (string, "blank"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEFINED_ONCE */
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MATCH_MAY_ALLOCATE
end_ifndef

begin_comment
comment|/* If we cannot allocate large objects within re_match_2_internal,    we make the fail stack and register vectors global.    The fail stack, we grow to the maximum size when a regexp    is compiled.    The register vectors, we adjust in size each time we    compile a regexp, according to the number of registers it needs.  */
end_comment

begin_expr_stmt
specifier|static
name|PREFIX
argument_list|(
argument|fail_stack_type
argument_list|)
name|fail_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size with which the following vectors are currently allocated.    That is so we can make them bigger as needed,    but never make them smaller.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFINED_ONCE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|regs_allocated_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|regstart
decl_stmt|,
modifier|*
modifier|*
name|regend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|old_regstart
decl_stmt|,
modifier|*
modifier|*
name|old_regend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|best_regstart
decl_stmt|,
modifier|*
modifier|*
name|best_regend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|reg_dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEFINED_ONCE */
end_comment

begin_expr_stmt
specifier|static
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|PREFIX
argument_list|(
name|reg_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|PREFIX
argument_list|(
name|reg_info_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Make the register vectors big enough for NUM_REGS registers,    but don't make them smaller.  */
end_comment

begin_function
specifier|static
name|void
name|PREFIX
function|(
name|regex_grow_registers
function|)
parameter_list|(
name|int
name|num_regs
parameter_list|)
block|{
if|if
condition|(
name|num_regs
operator|>
name|regs_allocated_size
condition|)
block|{
name|RETALLOC_IF
argument_list|(
name|regstart
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|regend
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|old_regstart
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|old_regend
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|best_regstart
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|best_regend
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|PREFIX
argument_list|(
name|reg_info
argument_list|)
argument_list|,
name|num_regs
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|reg_dummy
argument_list|,
name|num_regs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|RETALLOC_IF
argument_list|(
name|PREFIX
argument_list|(
name|reg_info_dummy
argument_list|)
argument_list|,
name|num_regs
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
argument_list|)
expr_stmt|;
name|regs_allocated_size
operator|=
name|num_regs
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MATCH_MAY_ALLOCATE */
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_ONCE
end_ifndef

begin_function_decl
specifier|static
name|boolean
name|group_in_compile_stack
parameter_list|(
name|compile_stack_type
name|compile_stack
parameter_list|,
name|regnum_t
name|regnum
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEFINED_ONCE */
end_comment

begin_comment
comment|/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.    Returns one of error codes defined in `regex.h', or zero for success.     Assumes the `allocated' (and perhaps `buffer') and `translate'    fields are set in BUFP on entry.     If it succeeds, results are put in BUFP (if it returns an error, the    contents of BUFP are undefined):      `buffer' is the compiled pattern;      `syntax' is set to SYNTAX;      `used' is set to the length of the compiled pattern;      `fastmap_accurate' is zero;      `re_nsub' is the number of subexpressions in PATTERN;      `not_bol' and `not_eol' are zero;     The `fastmap' and `newline_anchor' fields are neither    examined nor set.  */
end_comment

begin_comment
comment|/* Return, freeing storage we allocated.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|FREE_STACK_RETURN
parameter_list|(
name|value
parameter_list|)
define|\
value|return (free(pattern), free(mbs_offset), free(is_binary), free (compile_stack.stack), value)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FREE_STACK_RETURN
parameter_list|(
name|value
parameter_list|)
define|\
value|return (free (compile_stack.stack), value)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|PREFIX
function|(
name|regex_compile
function|)
parameter_list|(
specifier|const
name|char
modifier|*
name|ARG_PREFIX
parameter_list|(
name|pattern
parameter_list|)
parameter_list|,
name|size_t
name|ARG_PREFIX
parameter_list|(
name|size
parameter_list|)
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
block|{
comment|/* We fetch characters from PATTERN here.  Even though PATTERN is      `char *' (i.e., signed), we declare these variables as unsigned, so      they can be reliably used as array indices.  */
specifier|register
name|UCHAR_T
name|c
decl_stmt|,
name|c1
decl_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* A temporary space to keep wchar_t pattern and compiled pattern.  */
name|CHAR_T
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|COMPILED_BUFFER_VAR
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* offset buffer for optimization. See convert_mbs_to_wc.  */
name|int
modifier|*
name|mbs_offset
init|=
name|NULL
decl_stmt|;
comment|/* It hold whether each wchar_t is binary data or not.  */
name|char
modifier|*
name|is_binary
init|=
name|NULL
decl_stmt|;
comment|/* A flag whether exactn is handling binary data or not.  */
name|char
name|is_exactn_bin
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
comment|/* A random temporary spot in PATTERN.  */
specifier|const
name|CHAR_T
modifier|*
name|p1
decl_stmt|;
comment|/* Points to the end of the buffer, where we should append.  */
specifier|register
name|UCHAR_T
modifier|*
name|b
decl_stmt|;
comment|/* Keeps track of unclosed groups.  */
name|compile_stack_type
name|compile_stack
decl_stmt|;
comment|/* Points to the current (ending) position in the pattern.  */
ifdef|#
directive|ifdef
name|WCHAR
specifier|const
name|CHAR_T
modifier|*
name|p
decl_stmt|;
specifier|const
name|CHAR_T
modifier|*
name|pend
decl_stmt|;
else|#
directive|else
comment|/* BYTE */
specifier|const
name|CHAR_T
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
specifier|const
name|CHAR_T
modifier|*
name|pend
init|=
name|pattern
operator|+
name|size
decl_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
comment|/* How to translate the characters in the pattern.  */
name|RE_TRANSLATE_TYPE
name|translate
init|=
name|bufp
operator|->
name|translate
decl_stmt|;
comment|/* Address of the count-byte of the most recently inserted `exactn'      command.  This makes it possible to tell if a new exact-match      character can be added to that command or if the character requires      a new `exactn' command.  */
name|UCHAR_T
modifier|*
name|pending_exact
init|=
literal|0
decl_stmt|;
comment|/* Address of start of the most recently finished expression.      This tells, e.g., postfix * where to find the start of its      operand.  Reset at the beginning of groups and alternatives.  */
name|UCHAR_T
modifier|*
name|laststart
init|=
literal|0
decl_stmt|;
comment|/* Address of beginning of regexp, or inside of last group.  */
name|UCHAR_T
modifier|*
name|begalt
decl_stmt|;
comment|/* Address of the place where a forward jump should go to the end of      the containing expression.  Each alternative of an `or' -- except the      last -- ends with a forward jump of this sort.  */
name|UCHAR_T
modifier|*
name|fixup_alt_jump
init|=
literal|0
decl_stmt|;
comment|/* Counts open-groups as they are encountered.  Remembered for the      matching close-group on the compile stack, so the same register      number is put in the stop_memory as the start_memory.  */
name|regnum_t
name|regnum
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* Initialize the wchar_t PATTERN and offset_buffer.  */
name|p
operator|=
name|pend
operator|=
name|pattern
operator|=
name|TALLOC
argument_list|(
name|csize
operator|+
literal|1
argument_list|,
name|CHAR_T
argument_list|)
expr_stmt|;
name|mbs_offset
operator|=
name|TALLOC
argument_list|(
name|csize
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|is_binary
operator|=
name|TALLOC
argument_list|(
name|csize
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
name|mbs_offset
operator|==
name|NULL
operator|||
name|is_binary
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mbs_offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
name|pattern
index|[
name|csize
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* sentinel */
name|size
operator|=
name|convert_mbs_to_wcs
argument_list|(
name|pattern
argument_list|,
name|cpattern
argument_list|,
name|csize
argument_list|,
name|mbs_offset
argument_list|,
name|is_binary
argument_list|)
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mbs_offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
return|return
name|REG_BADPAT
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|DEBUG_PRINT1
argument_list|(
literal|"\nCompiling pattern: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|unsigned
name|debug_count
decl_stmt|;
for|for
control|(
name|debug_count
operator|=
literal|0
init|;
name|debug_count
operator|<
name|size
condition|;
name|debug_count
operator|++
control|)
name|PUT_CHAR
argument_list|(
name|pattern
index|[
name|debug_count
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/* Initialize the compile stack.  */
name|compile_stack
operator|.
name|stack
operator|=
name|TALLOC
argument_list|(
name|INIT_COMPILE_STACK_SIZE
argument_list|,
name|compile_stack_elt_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_stack
operator|.
name|stack
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|WCHAR
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mbs_offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|REG_ESPACE
return|;
block|}
name|compile_stack
operator|.
name|size
operator|=
name|INIT_COMPILE_STACK_SIZE
expr_stmt|;
name|compile_stack
operator|.
name|avail
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the pattern buffer.  */
name|bufp
operator|->
name|syntax
operator|=
name|syntax
expr_stmt|;
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
name|bufp
operator|->
name|not_bol
operator|=
name|bufp
operator|->
name|not_eol
operator|=
literal|0
expr_stmt|;
comment|/* Set `used' to zero, so that if we return an error, the pattern      printer (for debugging) will think there's no pattern.  We reset it      at the end.  */
name|bufp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* Always count groups, whether or not bufp->no_sub is set.  */
name|bufp
operator|->
name|re_nsub
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
name|emacs
operator|&&
operator|!
name|defined
name|SYNTAX_TABLE
comment|/* Initialize the syntax table.  */
name|init_syntax_once
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bufp
operator|->
name|allocated
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bufp
operator|->
name|buffer
condition|)
block|{
comment|/* If zero allocated, but buffer is non-null, try to realloc              enough space.  This loses if buffer's address is bogus, but              that is the user's responsibility.  */
ifdef|#
directive|ifdef
name|WCHAR
comment|/* Free bufp->buffer and allocate an array for wchar_t pattern 	     buffer.  */
name|free
argument_list|(
name|bufp
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|COMPILED_BUFFER_VAR
operator|=
name|TALLOC
argument_list|(
name|INIT_BUF_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|UCHAR_T
argument_list|)
argument_list|,
name|UCHAR_T
argument_list|)
expr_stmt|;
else|#
directive|else
name|RETALLOC
argument_list|(
name|COMPILED_BUFFER_VAR
argument_list|,
name|INIT_BUF_SIZE
argument_list|,
name|UCHAR_T
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
block|}
else|else
block|{
comment|/* Caller did not allocate a buffer.  Do it for them.  */
name|COMPILED_BUFFER_VAR
operator|=
name|TALLOC
argument_list|(
name|INIT_BUF_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|UCHAR_T
argument_list|)
argument_list|,
name|UCHAR_T
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|COMPILED_BUFFER_VAR
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
name|bufp
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|COMPILED_BUFFER_VAR
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
name|bufp
operator|->
name|allocated
operator|=
name|INIT_BUF_SIZE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WCHAR
else|else
name|COMPILED_BUFFER_VAR
operator|=
operator|(
name|UCHAR_T
operator|*
operator|)
name|bufp
operator|->
name|buffer
expr_stmt|;
endif|#
directive|endif
name|begalt
operator|=
name|b
operator|=
name|COMPILED_BUFFER_VAR
expr_stmt|;
comment|/* Loop through the uncompiled pattern until we're at the end.  */
while|while
condition|(
name|p
operator|!=
name|pend
condition|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
block|{
if|if
condition|(
comment|/* If at start of pattern, it's an operator.  */
name|p
operator|==
name|pattern
operator|+
literal|1
comment|/* If context independent, it's an operator.  */
operator|||
name|syntax
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
comment|/* Otherwise, depends on what's come before.  */
operator|||
name|PREFIX
argument_list|(
name|at_begline_loc_p
argument_list|)
argument_list|(
name|pattern
argument_list|,
name|p
argument_list|,
name|syntax
argument_list|)
condition|)
name|BUF_PUSH
argument_list|(
name|begline
argument_list|)
expr_stmt|;
else|else
goto|goto
name|normal_char
goto|;
block|}
break|break;
case|case
literal|'$'
case|:
block|{
if|if
condition|(
comment|/* If at end of pattern, it's an operator.  */
name|p
operator|==
name|pend
comment|/* If context independent, it's an operator.  */
operator|||
name|syntax
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
comment|/* Otherwise, depends on what's next.  */
operator|||
name|PREFIX
argument_list|(
name|at_endline_loc_p
argument_list|)
argument_list|(
name|p
argument_list|,
name|pend
argument_list|,
name|syntax
argument_list|)
condition|)
name|BUF_PUSH
argument_list|(
name|endline
argument_list|)
expr_stmt|;
else|else
goto|goto
name|normal_char
goto|;
block|}
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|||
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|handle_plus
label|:
case|case
literal|'*'
case|:
comment|/* If there is no previous pattern... */
if|if
condition|(
operator|!
name|laststart
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_OPS
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
block|}
block|{
comment|/* Are we optimizing this jump?  */
name|boolean
name|keep_string_p
init|=
name|false
decl_stmt|;
comment|/* 1 means zero (many) matches is allowed.  */
name|char
name|zero_times_ok
init|=
literal|0
decl_stmt|,
name|many_times_ok
init|=
literal|0
decl_stmt|;
comment|/* If there is a sequence of repetition chars, collapse it                down to just one (the right one).  We can't combine                interval operators with these because of, e.g., `a{2}*',                which should only match an even number of `a's.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|zero_times_ok
operator||=
name|c
operator|!=
literal|'+'
expr_stmt|;
name|many_times_ok
operator||=
name|c
operator|!=
literal|'?'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|||
operator|(
operator|!
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|==
literal|'+'
operator|||
name|c1
operator|==
literal|'?'
operator|)
condition|)
block|{
name|PATUNFETCH
expr_stmt|;
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|c1
expr_stmt|;
block|}
else|else
block|{
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
comment|/* If we get here, we found another repeat character.  */
block|}
comment|/* Star, etc. applied to an empty pattern is equivalent                to an empty pattern.  */
if|if
condition|(
operator|!
name|laststart
condition|)
break|break;
comment|/* Now we know whether or not zero matches is allowed                and also whether or not two or more matches is allowed.  */
if|if
condition|(
name|many_times_ok
condition|)
block|{
comment|/* More than one repetition is allowed, so put in at the                    end a backward relative jump from `b' to before the next                    jump we're going to put in below (which jumps from                    laststart to after this jump).                     But if we are at the `*' in the exact sequence `.*\n',                    insert an unconditional jump backwards to the .,                    instead of the beginning of the loop.  This way we only                    push a failure point once, instead of every time                    through the loop.  */
name|assert
argument_list|(
name|p
operator|-
literal|1
operator|>
name|pattern
argument_list|)
expr_stmt|;
comment|/* Allocate the space for the jump.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
comment|/* We know we are not at the first character of the pattern,                    because laststart was nonzero.  And we've already                    incremented `p', by the way, to be the character after                    the `*'.  Do we have to do something analogous here                    for null bytes, because of RE_DOT_NOT_NULL?  */
if|if
condition|(
name|TRANSLATE
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|2
operator|)
argument_list|)
operator|==
name|TRANSLATE
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|zero_times_ok
operator|&&
name|p
operator|<
name|pend
operator|&&
name|TRANSLATE
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|TRANSLATE
argument_list|(
literal|'\n'
argument_list|)
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
block|{
comment|/* We have .*\n.  */
name|STORE_JUMP
argument_list|(
name|jump
argument_list|,
name|b
argument_list|,
name|laststart
argument_list|)
expr_stmt|;
name|keep_string_p
operator|=
name|true
expr_stmt|;
block|}
else|else
comment|/* Anything else.  */
name|STORE_JUMP
argument_list|(
name|maybe_pop_jump
argument_list|,
name|b
argument_list|,
name|laststart
operator|-
operator|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* We've added more stuff to the buffer.  */
name|b
operator|+=
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
block|}
comment|/* On failure, jump from laststart to b + 3, which will be the                end of the buffer after this jump is inserted.  */
comment|/* ifdef WCHAR, 'b + 1 + OFFSET_ADDRESS_SIZE' instead of 	       'b + 3'.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|keep_string_p
condition|?
name|on_failure_keep_string_jump
else|:
name|on_failure_jump
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|zero_times_ok
condition|)
block|{
comment|/* At least one repetition is required, so insert a                    `dummy_failure_jump' before the initial                    `on_failure_jump' instruction of the loop. This                    effects a skip over that instruction the first time                    we hit that loop.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|dummy_failure_jump
argument_list|,
name|laststart
argument_list|,
name|laststart
operator|+
literal|2
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'.'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|anychar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
block|{
name|boolean
name|had_char_class
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
name|CHAR_T
name|range_start
init|=
literal|0xffffffff
decl_stmt|;
else|#
directive|else
name|unsigned
name|int
name|range_start
init|=
literal|0xffffffff
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* We assume a charset(_not) structure as a wchar_t array. 	       charset[0] = (re_opcode_t) charset(_not)                charset[1] = l (= length of char_classes)                charset[2] = m (= length of collating_symbols)                charset[3] = n (= length of equivalence_classes) 	       charset[4] = o (= length of char_ranges) 	       charset[5] = p (= length of chars)                 charset[6] = char_class (wctype_t)                charset[6+CHAR_CLASS_SIZE] = char_class (wctype_t)                          ...                charset[l+5]  = char_class (wctype_t)                 charset[l+6]  = collating_symbol (wchar_t)                             ...                charset[l+m+5]  = collating_symbol (wchar_t) 					ifdef _LIBC we use the index if 					_NL_COLLATE_SYMB_EXTRAMB instead of 					wchar_t string.                 charset[l+m+6]  = equivalence_classes (wchar_t)                               ...                charset[l+m+n+5]  = equivalence_classes (wchar_t) 					ifdef _LIBC we use the index in 					_NL_COLLATE_WEIGHT instead of 					wchar_t string.  	       charset[l+m+n+6] = range_start 	       charset[l+m+n+7] = range_end 	                       ... 	       charset[l+m+n+2o+4] = range_start 	       charset[l+m+n+2o+5] = range_end 					ifdef _LIBC we use the value looked up 					in _NL_COLLATE_COLLSEQ instead of 					wchar_t character.  	       charset[l+m+n+2o+6] = char 	                          ... 	       charset[l+m+n+2o+p+5] = char  	     */
comment|/* We need at least 6 spaces: the opcode, the length of                char_classes, the length of collating_symbols, the length of                equivalence_classes, the length of char_ranges, the length of                chars.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/* Save b as laststart. And We use laststart as the pointer 	       to the first element of the charset here. 	       In other words, laststart[i] indicates charset[i].  */
name|laststart
operator|=
name|b
expr_stmt|;
comment|/* We test `*p == '^' twice, instead of using an if                statement, so we only need one BUF_PUSH.  */
name|BUF_PUSH
argument_list|(
operator|*
name|p
operator|==
literal|'^'
condition|?
name|charset_not
else|:
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Push the length of char_classes, the length of                collating_symbols, the length of equivalence_classes, the                length of char_ranges and the length of chars.  */
name|BUF_PUSH_3
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remember the first position in the bracket expression.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* charset_not matches newline according to a syntax bit.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|b
index|[
operator|-
literal|6
index|]
operator|==
name|charset_not
operator|&&
operator|(
name|syntax
operator|&
name|RE_HAT_LISTS_NOT_NEWLINE
operator|)
condition|)
block|{
name|BUF_PUSH
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|laststart
index|[
literal|5
index|]
operator|++
expr_stmt|;
comment|/* Update the length of characters  */
block|}
comment|/* Read in characters and ranges, setting map bits.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* \ might escape characters inside [...] and [^...].  */
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|laststart
index|[
literal|5
index|]
operator|++
expr_stmt|;
comment|/* Update the length of chars  */
name|range_start
operator|=
name|c1
expr_stmt|;
continue|continue;
block|}
comment|/* Could be the end of the bracket expression.  If it's                    not (i.e., when the bracket expression is `[]' so                    far), the ']' character bit gets set way below.  */
if|if
condition|(
name|c
operator|==
literal|']'
operator|&&
name|p
operator|!=
name|p1
operator|+
literal|1
condition|)
break|break;
comment|/* Look ahead to see if it's a range when the last thing                    was a character class.  */
if|if
condition|(
name|had_char_class
operator|&&
name|c
operator|==
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ERANGE
argument_list|)
expr_stmt|;
comment|/* Look ahead to see if it's a range when the last thing                    was a character: if this is a hyphen not at the                    beginning or the end of a list, then it's the range                    operator.  */
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
operator|(
name|p
operator|-
literal|2
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'['
operator|)
operator|&&
operator|!
operator|(
name|p
operator|-
literal|3
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|3
index|]
operator|==
literal|'['
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'^'
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* Allocate the space for range_start and range_end.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Update the pointer to indicate end of buffer.  */
name|b
operator|+=
literal|2
expr_stmt|;
name|ret
operator|=
name|wcs_compile_range
argument_list|(
name|range_start
argument_list|,
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|b
argument_list|,
name|laststart
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|range_start
operator|=
literal|0xffffffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
comment|/* This handles ranges made up of characters only.  */
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* Move past the `-'.  */
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
comment|/* Allocate the space for range_start and range_end.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Update the pointer to indicate end of buffer.  */
name|b
operator|+=
literal|2
expr_stmt|;
name|ret
operator|=
name|wcs_compile_range
argument_list|(
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|b
argument_list|,
name|laststart
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|range_start
operator|=
literal|0xffffffff
expr_stmt|;
block|}
comment|/* See if we're at the beginning of a possible character                    class.  */
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
operator|&&
name|c
operator|==
literal|'['
operator|&&
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* Leave room for the null.  */
name|char
name|str
index|[
name|CHAR_CLASS_MAX_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If pattern is `[[:'.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|)
operator|||
name|p
operator|==
name|pend
condition|)
break|break;
if|if
condition|(
name|c1
operator|<
name|CHAR_CLASS_MAX_LENGTH
condition|)
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
comment|/* This is in any case an invalid class name.  */
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If isn't a word bracketed by `[:' and `:]':                        undo the ending character, the letters, and leave                        the leading `:' and `[' (but store them as character).  */
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
name|wctype_t
name|wt
decl_stmt|;
name|uintptr_t
name|alignedp
decl_stmt|;
comment|/* Query the character class as wctype_t.  */
name|wt
operator|=
name|IS_CHAR_CLASS
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt
operator|==
literal|0
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the character                            class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
comment|/* Allocate the space for character class.  */
name|GET_BUFFER_SPACE
argument_list|(
name|CHAR_CLASS_SIZE
argument_list|)
expr_stmt|;
comment|/* Update the pointer to indicate end of buffer.  */
name|b
operator|+=
name|CHAR_CLASS_SIZE
expr_stmt|;
comment|/* Move data which follow character classes 			    not to violate the data.  */
name|insert_space
argument_list|(
name|CHAR_CLASS_SIZE
argument_list|,
name|laststart
operator|+
literal|6
operator|+
name|laststart
index|[
literal|1
index|]
argument_list|,
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
name|alignedp
operator|=
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
name|laststart
operator|+
literal|6
operator|+
name|laststart
index|[
literal|1
index|]
argument_list|)
operator|+
name|__alignof__
argument_list|(
name|wctype_t
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
call|(
name|uintptr_t
call|)
argument_list|(
name|__alignof__
argument_list|(
name|wctype_t
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Store the character class.  */
operator|*
operator|(
operator|(
name|wctype_t
operator|*
operator|)
name|alignedp
operator|)
operator|=
name|wt
expr_stmt|;
comment|/* Update length of char_classes */
name|laststart
index|[
literal|1
index|]
operator|+=
name|CHAR_CLASS_SIZE
expr_stmt|;
name|had_char_class
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
name|BUF_PUSH
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|BUF_PUSH
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|laststart
index|[
literal|5
index|]
operator|+=
literal|2
expr_stmt|;
comment|/* Update the length of characters  */
name|range_start
operator|=
literal|':'
expr_stmt|;
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
operator|&&
name|c
operator|==
literal|'['
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'='
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
block|{
name|CHAR_T
name|str
index|[
literal|128
index|]
decl_stmt|;
comment|/* Should be large enough.  */
name|CHAR_T
name|delim
init|=
operator|*
name|p
decl_stmt|;
comment|/* '=' or '.'  */
ifdef|#
directive|ifdef
name|_LIBC
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If pattern is `[[=' or '[[.'.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|delim
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|)
operator|||
name|p
operator|==
name|pend
condition|)
break|break;
if|if
condition|(
name|c1
operator|<
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|-
literal|1
condition|)
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
comment|/* This is in any case an invalid class name.  */
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|delim
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
comment|/* If we have no collation data we use the default 			   collation in which each character is in a class 			   by itself.  It also means that ASCII is the 			   character set and therefore we cannot have character 			   with more than one byte in the multibyte 			   representation.  */
comment|/* If not defined _LIBC, we push the name and 			   `\0' for the sake of matching performance.  */
name|int
name|datasize
init|=
name|c1
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|int32_t
name|idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|c1
operator|!=
literal|1
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
else|else
block|{
specifier|const
name|int32_t
modifier|*
name|table
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|weights
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|extra
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|indirect
decl_stmt|;
name|wint_t
modifier|*
name|cp
decl_stmt|;
comment|/* This #include defines a local function!  */
include|#
directive|include
file|<locale/weightwc.h>
if|if
condition|(
name|delim
operator|==
literal|'='
condition|)
block|{
comment|/* We push the index for equivalence class.  */
name|cp
operator|=
operator|(
name|wint_t
operator|*
operator|)
name|str
expr_stmt|;
name|table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEWC
argument_list|)
expr_stmt|;
name|weights
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_WEIGHTWC
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_EXTRAWC
argument_list|)
expr_stmt|;
name|indirect
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_INDIRECTWC
argument_list|)
expr_stmt|;
name|idx
operator|=
name|findidx
argument_list|(
operator|(
specifier|const
name|wint_t
operator|*
operator|*
operator|)
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
operator|||
name|cp
operator|<
operator|(
name|wint_t
operator|*
operator|)
name|str
operator|+
name|c1
condition|)
comment|/* This is no valid character.  */
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|idx
expr_stmt|;
block|}
else|else
comment|/* delim == '.' */
block|{
comment|/* We push collation sequence value 				   for collating symbol.  */
name|int32_t
name|table_size
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|symb_table
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
name|int32_t
name|idx
decl_stmt|;
name|int32_t
name|elem
decl_stmt|;
name|int32_t
name|second
decl_stmt|;
name|int32_t
name|hash
decl_stmt|;
name|char
name|char_str
index|[
name|c1
index|]
decl_stmt|;
comment|/* We have to convert the name to a single-byte 				   string.  This is possible since the names 				   consist of ASCII characters and the internal 				   representation is UCS4.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c1
condition|;
operator|++
name|i
control|)
name|char_str
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|table_size
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_HASH_SIZEMB
argument_list|)
expr_stmt|;
name|symb_table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_TABLEMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
expr_stmt|;
comment|/* Locate the character in the hashing table.  */
name|hash
operator|=
name|elem_hash
argument_list|(
name|char_str
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|elem
operator|=
name|hash
operator|%
name|table_size
expr_stmt|;
name|second
operator|=
name|hash
operator|%
operator|(
name|table_size
operator|-
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* First compare the hashing value.  */
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
name|hash
operator|&&
name|c1
operator|==
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
index|]
operator|&&
name|memcmp
argument_list|(
name|char_str
argument_list|,
operator|&
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
operator|+
literal|1
index|]
argument_list|,
name|c1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yep, this is the entry.  */
name|idx
operator|=
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
expr_stmt|;
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
comment|/* Next entry.  */
name|elem
operator|+=
name|second
expr_stmt|;
block|}
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Compute the index of the byte sequence 				       in the table.  */
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
comment|/* Adjust for the alignment.  */
name|idx
operator|=
operator|(
name|idx
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|idx
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
literal|0
operator|&&
name|c1
operator|==
literal|1
condition|)
block|{
comment|/* No valid character.  Match it as a 				       single byte character.  */
name|had_char_class
operator|=
name|false
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Update the length of characters  */
name|laststart
index|[
literal|5
index|]
operator|++
expr_stmt|;
name|range_start
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
comment|/* Throw away the ] at the end of the 				       collating symbol.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* exit from the switch block.  */
continue|continue;
block|}
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
block|}
name|datasize
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Throw away the ] at the end of the equivalence                            class (or collating symbol).  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Allocate the space for the equivalence class 			   (or collating symbol) (and '\0' if needed).  */
name|GET_BUFFER_SPACE
argument_list|(
name|datasize
argument_list|)
expr_stmt|;
comment|/* Update the pointer to indicate end of buffer.  */
name|b
operator|+=
name|datasize
expr_stmt|;
if|if
condition|(
name|delim
operator|==
literal|'='
condition|)
block|{
comment|/* equivalence class  */
comment|/* Calculate the offset of char_ranges, 			       which is next to equivalence_classes.  */
name|offset
operator|=
name|laststart
index|[
literal|1
index|]
operator|+
name|laststart
index|[
literal|2
index|]
operator|+
name|laststart
index|[
literal|3
index|]
operator|+
literal|6
expr_stmt|;
comment|/* Insert space.  */
name|insert_space
argument_list|(
name|datasize
argument_list|,
name|laststart
operator|+
name|offset
argument_list|,
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Write the equivalence_class and \0.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datasize
condition|;
name|i
operator|++
control|)
name|laststart
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
comment|/* Update the length of equivalence_classes.  */
name|laststart
index|[
literal|3
index|]
operator|+=
name|datasize
expr_stmt|;
name|had_char_class
operator|=
name|true
expr_stmt|;
block|}
else|else
comment|/* delim == '.' */
block|{
comment|/* collating symbol  */
comment|/* Calculate the offset of the equivalence_classes, 			       which is next to collating_symbols.  */
name|offset
operator|=
name|laststart
index|[
literal|1
index|]
operator|+
name|laststart
index|[
literal|2
index|]
operator|+
literal|6
expr_stmt|;
comment|/* Insert space and write the collationg_symbol 			       and \0.  */
name|insert_space
argument_list|(
name|datasize
argument_list|,
name|laststart
operator|+
name|offset
argument_list|,
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datasize
condition|;
name|i
operator|++
control|)
name|laststart
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
comment|/* In re_match_2_internal if range_start< -1, we 			       assume -range_start is the offset of the 			       collating symbol which is specified as 			       the character of the range start.  So we assign 			       -(laststart[1] + laststart[2] + 6) to 			       range_start.  */
name|range_start
operator|=
operator|-
operator|(
name|laststart
index|[
literal|1
index|]
operator|+
name|laststart
index|[
literal|2
index|]
operator|+
literal|6
operator|)
expr_stmt|;
comment|/* Update the length of collating_symbol.  */
name|laststart
index|[
literal|2
index|]
operator|+=
name|datasize
expr_stmt|;
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
name|BUF_PUSH
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|delim
argument_list|)
expr_stmt|;
name|laststart
index|[
literal|5
index|]
operator|+=
literal|2
expr_stmt|;
comment|/* Update the length of characters  */
name|range_start
operator|=
name|delim
expr_stmt|;
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|had_char_class
operator|=
name|false
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|laststart
index|[
literal|5
index|]
operator|++
expr_stmt|;
comment|/* Update the length of characters  */
name|range_start
operator|=
name|c
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* BYTE */
comment|/* Ensure that we have enough space to push a charset: the                opcode, the length count, and the bitset; 34 bytes in all.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|34
argument_list|)
expr_stmt|;
name|laststart
operator|=
name|b
expr_stmt|;
comment|/* We test `*p == '^' twice, instead of using an if                statement, so we only need one BUF_PUSH.  */
name|BUF_PUSH
argument_list|(
operator|*
name|p
operator|==
literal|'^'
condition|?
name|charset_not
else|:
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Remember the first position in the bracket expression.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* Push the number of bytes in the bitmap.  */
name|BUF_PUSH
argument_list|(
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* Clear the whole map.  */
name|bzero
argument_list|(
name|b
argument_list|,
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* charset_not matches newline according to a syntax bit.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|b
index|[
operator|-
literal|2
index|]
operator|==
name|charset_not
operator|&&
operator|(
name|syntax
operator|&
name|RE_HAT_LISTS_NOT_NEWLINE
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Read in characters and ranges, setting map bits.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* \ might escape characters inside [...] and [^...].  */
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|range_start
operator|=
name|c1
expr_stmt|;
continue|continue;
block|}
comment|/* Could be the end of the bracket expression.  If it's                    not (i.e., when the bracket expression is `[]' so                    far), the ']' character bit gets set way below.  */
if|if
condition|(
name|c
operator|==
literal|']'
operator|&&
name|p
operator|!=
name|p1
operator|+
literal|1
condition|)
break|break;
comment|/* Look ahead to see if it's a range when the last thing                    was a character class.  */
if|if
condition|(
name|had_char_class
operator|&&
name|c
operator|==
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ERANGE
argument_list|)
expr_stmt|;
comment|/* Look ahead to see if it's a range when the last thing                    was a character: if this is a hyphen not at the                    beginning or the end of a list, then it's the range                    operator.  */
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
operator|(
name|p
operator|-
literal|2
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'['
operator|)
operator|&&
operator|!
operator|(
name|p
operator|-
literal|3
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|3
index|]
operator|==
literal|'['
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'^'
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
name|reg_errcode_t
name|ret
init|=
name|byte_compile_range
argument_list|(
name|range_start
argument_list|,
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|range_start
operator|=
literal|0xffffffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
comment|/* This handles ranges made up of characters only.  */
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* Move past the `-'.  */
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|byte_compile_range
argument_list|(
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|range_start
operator|=
literal|0xffffffff
expr_stmt|;
block|}
comment|/* See if we're at the beginning of a possible character                    class.  */
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
operator|&&
name|c
operator|==
literal|'['
operator|&&
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* Leave room for the null.  */
name|char
name|str
index|[
name|CHAR_CLASS_MAX_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If pattern is `[[:'.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|)
operator|||
name|p
operator|==
name|pend
condition|)
break|break;
if|if
condition|(
name|c1
operator|<
name|CHAR_CLASS_MAX_LENGTH
condition|)
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
comment|/* This is in any case an invalid class name.  */
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If isn't a word bracketed by `[:' and `:]':                        undo the ending character, the letters, and leave                        the leading `:' and `[' (but set bits for them).  */
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|WIDE_CHAR_SUPPORT
name|boolean
name|is_lower
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"lower"
argument_list|)
decl_stmt|;
name|boolean
name|is_upper
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"upper"
argument_list|)
decl_stmt|;
name|wctype_t
name|wt
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|wt
operator|=
name|IS_CHAR_CLASS
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt
operator|==
literal|0
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the character                            class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
literal|1
operator|<<
name|BYTEWIDTH
condition|;
operator|++
name|ch
control|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|__iswctype
argument_list|(
name|__btowc
argument_list|(
name|ch
argument_list|)
argument_list|,
name|wt
argument_list|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|iswctype
argument_list|(
name|btowc
argument_list|(
name|ch
argument_list|)
argument_list|,
name|wt
argument_list|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|translate
operator|&&
operator|(
name|is_upper
operator|||
name|is_lower
operator|)
operator|&&
operator|(
name|ISUPPER
argument_list|(
name|ch
argument_list|)
operator|||
name|ISLOWER
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|had_char_class
operator|=
name|true
expr_stmt|;
else|#
directive|else
name|int
name|ch
decl_stmt|;
name|boolean
name|is_alnum
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"alnum"
argument_list|)
decl_stmt|;
name|boolean
name|is_alpha
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"alpha"
argument_list|)
decl_stmt|;
name|boolean
name|is_blank
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"blank"
argument_list|)
decl_stmt|;
name|boolean
name|is_cntrl
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"cntrl"
argument_list|)
decl_stmt|;
name|boolean
name|is_digit
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"digit"
argument_list|)
decl_stmt|;
name|boolean
name|is_graph
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"graph"
argument_list|)
decl_stmt|;
name|boolean
name|is_lower
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"lower"
argument_list|)
decl_stmt|;
name|boolean
name|is_print
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"print"
argument_list|)
decl_stmt|;
name|boolean
name|is_punct
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"punct"
argument_list|)
decl_stmt|;
name|boolean
name|is_space
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"space"
argument_list|)
decl_stmt|;
name|boolean
name|is_upper
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"upper"
argument_list|)
decl_stmt|;
name|boolean
name|is_xdigit
init|=
name|STREQ
argument_list|(
name|str
argument_list|,
literal|"xdigit"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_CHAR_CLASS
argument_list|(
name|str
argument_list|)
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the character                            class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
literal|1
operator|<<
name|BYTEWIDTH
condition|;
name|ch
operator|++
control|)
block|{
comment|/* This was split into 3 if's to 			       avoid an arbitrary limit in some compiler.  */
if|if
condition|(
operator|(
name|is_alnum
operator|&&
name|ISALNUM
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_alpha
operator|&&
name|ISALPHA
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_blank
operator|&&
name|ISBLANK
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_cntrl
operator|&&
name|ISCNTRL
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is_digit
operator|&&
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_graph
operator|&&
name|ISGRAPH
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_lower
operator|&&
name|ISLOWER
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_print
operator|&&
name|ISPRINT
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is_punct
operator|&&
name|ISPUNCT
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_space
operator|&&
name|ISSPACE
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_upper
operator|&&
name|ISUPPER
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_xdigit
operator|&&
name|ISXDIGIT
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|translate
operator|&&
operator|(
name|is_upper
operator|||
name|is_lower
operator|)
operator|&&
operator|(
name|ISUPPER
argument_list|(
name|ch
argument_list|)
operator|||
name|ISLOWER
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|had_char_class
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* libc || wctype.h */
block|}
else|else
block|{
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|range_start
operator|=
literal|':'
expr_stmt|;
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
operator|&&
name|c
operator|==
literal|'['
operator|&&
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|unsigned
name|char
name|str
index|[
name|MB_LEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If pattern is `[[='.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'='
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|)
operator|||
name|p
operator|==
name|pend
condition|)
break|break;
if|if
condition|(
name|c1
operator|<
name|MB_LEN_MAX
condition|)
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
comment|/* This is in any case an invalid class name.  */
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* If we have no collation data we use the default 			   collation in which each character is in a class 			   by itself.  It also means that ASCII is the 			   character set and therefore we cannot have character 			   with more than one byte in the multibyte 			   representation.  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|c1
operator|!=
literal|1
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the equivalence 			       class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Set the bit for the character.  */
name|SET_LIST_BIT
argument_list|(
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
else|else
block|{
comment|/* Try to match the byte sequence in `str' against 			       those known to the collate implementation. 			       First find out whether the bytes in `str' are 			       actually from exactly one character.  */
specifier|const
name|int32_t
modifier|*
name|table
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|weights
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|indirect
decl_stmt|;
name|int32_t
name|idx
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cp
init|=
name|str
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* This #include defines a local function!  */
include|#
directive|include
file|<locale/weight.h>
name|table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEMB
argument_list|)
expr_stmt|;
name|weights
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_WEIGHTMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_EXTRAMB
argument_list|)
expr_stmt|;
name|indirect
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_INDIRECTMB
argument_list|)
expr_stmt|;
name|idx
operator|=
name|findidx
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
operator|||
name|cp
operator|<
name|str
operator|+
name|c1
condition|)
comment|/* This is no valid character.  */
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the equivalence 			       class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Now we have to go throught the whole table 			       and find all characters which have the same 			       first level weight.  			       XXX Note that this is not entirely correct. 			       we would have to match multibyte sequences 			       but this is not possible with the current 			       implementation.  */
for|for
control|(
name|ch
operator|=
literal|1
init|;
name|ch
operator|<
literal|256
condition|;
operator|++
name|ch
control|)
comment|/* XXX This test would have to be changed if we 				 would allow matching multibyte sequences.  */
if|if
condition|(
name|table
index|[
name|ch
index|]
operator|>
literal|0
condition|)
block|{
name|int32_t
name|idx2
init|=
name|table
index|[
name|ch
index|]
decl_stmt|;
name|size_t
name|len
init|=
name|weights
index|[
name|idx2
index|]
decl_stmt|;
comment|/* Test whether the lenghts match.  */
if|if
condition|(
name|weights
index|[
name|idx
index|]
operator|==
name|len
condition|)
block|{
comment|/* They do.  New compare the bytes of 					 the weight.  */
name|size_t
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cnt
operator|<
name|len
operator|&&
operator|(
name|weights
index|[
name|idx
operator|+
literal|1
operator|+
name|cnt
index|]
operator|==
name|weights
index|[
name|idx2
operator|+
literal|1
operator|+
name|cnt
index|]
operator|)
condition|)
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|len
condition|)
comment|/* They match.  Mark the character as 					   acceptable.  */
name|SET_LIST_BIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|had_char_class
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|range_start
operator|=
literal|'='
expr_stmt|;
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
operator|&&
name|c
operator|==
literal|'['
operator|&&
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|unsigned
name|char
name|str
index|[
literal|128
index|]
decl_stmt|;
comment|/* Should be large enough.  */
ifdef|#
directive|ifdef
name|_LIBC
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If pattern is `[[.'.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'.'
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|)
operator|||
name|p
operator|==
name|pend
condition|)
break|break;
if|if
condition|(
name|c1
operator|<
sizeof|sizeof
argument_list|(
name|str
argument_list|)
condition|)
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
comment|/* This is in any case an invalid class name.  */
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
operator|&&
operator|*
name|p
operator|==
literal|']'
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* If we have no collation data we use the default 			   collation in which each character is the name 			   for its own class which contains only the one 			   character.  It also means that ASCII is the 			   character set and therefore we cannot have character 			   with more than one byte in the multibyte 			   representation.  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|c1
operator|!=
literal|1
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the equivalence 			       class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Set the bit for the character.  */
name|SET_LIST_BIT
argument_list|(
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|range_start
operator|=
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|str
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
else|else
block|{
comment|/* Try to match the byte sequence in `str' against 			       those known to the collate implementation. 			       First find out whether the bytes in `str' are 			       actually from exactly one character.  */
name|int32_t
name|table_size
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|symb_table
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
name|int32_t
name|idx
decl_stmt|;
name|int32_t
name|elem
decl_stmt|;
name|int32_t
name|second
decl_stmt|;
name|int32_t
name|hash
decl_stmt|;
name|table_size
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_HASH_SIZEMB
argument_list|)
expr_stmt|;
name|symb_table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_TABLEMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
expr_stmt|;
comment|/* Locate the character in the hashing table.  */
name|hash
operator|=
name|elem_hash
argument_list|(
name|str
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|elem
operator|=
name|hash
operator|%
name|table_size
expr_stmt|;
name|second
operator|=
name|hash
operator|%
operator|(
name|table_size
operator|-
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* First compare the hashing value.  */
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
name|hash
operator|&&
name|c1
operator|==
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
index|]
operator|&&
name|memcmp
argument_list|(
name|str
argument_list|,
operator|&
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
operator|+
literal|1
index|]
argument_list|,
name|c1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yep, this is the entry.  */
name|idx
operator|=
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
expr_stmt|;
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
comment|/* Next entry.  */
name|elem
operator|+=
name|second
expr_stmt|;
block|}
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
literal|0
condition|)
comment|/* This is no valid character.  */
name|FREE_STACK_RETURN
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
comment|/* Throw away the ] at the end of the equivalence 			       class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Now add the multibyte character(s) we found 			       to the accept list.  			       XXX Note that this is not entirely correct. 			       we would have to match multibyte sequences 			       but this is not possible with the current 			       implementation.  Also, we have to match 			       collating symbols, which expand to more than 			       one file, as a whole and not allow the 			       individual bytes.  */
name|c1
operator|=
name|extra
index|[
name|idx
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|1
condition|)
name|range_start
operator|=
name|extra
index|[
name|idx
index|]
expr_stmt|;
while|while
condition|(
name|c1
operator|--
operator|>
literal|0
condition|)
block|{
name|SET_LIST_BIT
argument_list|(
name|extra
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|range_start
operator|=
literal|'.'
expr_stmt|;
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|had_char_class
operator|=
name|false
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|range_start
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Discard any (non)matching list bytes that are all 0 at the                end of the map.  Decrease the map-length byte too.  */
while|while
condition|(
operator|(
name|int
operator|)
name|b
index|[
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|b
index|[
name|b
index|[
operator|-
literal|1
index|]
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|b
index|[
operator|-
literal|1
index|]
operator|--
expr_stmt|;
name|b
operator|+=
name|b
index|[
operator|-
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
block|}
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|handle_open
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|')'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|handle_close
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NEWLINE_ALT
condition|)
goto|goto
name|handle_alt
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
condition|)
goto|goto
name|handle_alt
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'{'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_INTERVALS
operator|&&
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|handle_interval
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|==
name|pend
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
comment|/* Do not translate the character after the \, so that we can              distinguish, e.g., \B from \b, even if we normally would              translate, e.g., B to b.  */
name|PATFETCH_RAW
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_open
label|:
name|bufp
operator|->
name|re_nsub
operator|++
expr_stmt|;
name|regnum
operator|++
expr_stmt|;
if|if
condition|(
name|COMPILE_STACK_FULL
condition|)
block|{
name|RETALLOC
argument_list|(
name|compile_stack
operator|.
name|stack
argument_list|,
name|compile_stack
operator|.
name|size
operator|<<
literal|1
argument_list|,
name|compile_stack_elt_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_stack
operator|.
name|stack
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
name|compile_stack
operator|.
name|size
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* These are the values to restore when we hit end of this                  group.  They are all relative offsets, so that if the                  whole pattern moves because of realloc, they will still                  be valid.  */
name|COMPILE_STACK_TOP
operator|.
name|begalt_offset
operator|=
name|begalt
operator|-
name|COMPILED_BUFFER_VAR
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|fixup_alt_jump
operator|=
name|fixup_alt_jump
condition|?
name|fixup_alt_jump
operator|-
name|COMPILED_BUFFER_VAR
operator|+
literal|1
else|:
literal|0
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|laststart_offset
operator|=
name|b
operator|-
name|COMPILED_BUFFER_VAR
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|regnum
operator|=
name|regnum
expr_stmt|;
comment|/* We will eventually replace the 0 with the number of                  groups inner to this one.  But do not push a                  start_memory for groups beyond the last one we can                  represent in the compiled pattern.  */
if|if
condition|(
name|regnum
operator|<=
name|MAX_REGNUM
condition|)
block|{
name|COMPILE_STACK_TOP
operator|.
name|inner_group_offset
operator|=
name|b
operator|-
name|COMPILED_BUFFER_VAR
operator|+
literal|2
expr_stmt|;
name|BUF_PUSH_3
argument_list|(
name|start_memory
argument_list|,
name|regnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|compile_stack
operator|.
name|avail
operator|++
expr_stmt|;
name|fixup_alt_jump
operator|=
literal|0
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
comment|/* If we've reached MAX_REGNUM groups, then this open 		 won't actually generate any code, so we'll have to 		 clear pending_exact explicitly.  */
name|pending_exact
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backslash
goto|;
if|if
condition|(
name|COMPILE_STACK_EMPTY
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
condition|)
goto|goto
name|normal_backslash
goto|;
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_ERPAREN
argument_list|)
expr_stmt|;
block|}
name|handle_close
label|:
if|if
condition|(
name|fixup_alt_jump
condition|)
block|{
comment|/* Push a dummy failure point at the end of the                      alternative for a possible future                      `pop_failure_jump' to pop.  See comments at                      `push_dummy_failure' in `re_match_2'.  */
name|BUF_PUSH
argument_list|(
name|push_dummy_failure
argument_list|)
expr_stmt|;
comment|/* We allocated space for this jump when we assigned                      to `fixup_alt_jump', in the `handle_alt' case below.  */
name|STORE_JUMP
argument_list|(
name|jump_past_alt
argument_list|,
name|fixup_alt_jump
argument_list|,
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* See similar code for backslashed left paren above.  */
if|if
condition|(
name|COMPILE_STACK_EMPTY
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
condition|)
goto|goto
name|normal_char
goto|;
else|else
name|FREE_STACK_RETURN
argument_list|(
name|REG_ERPAREN
argument_list|)
expr_stmt|;
block|}
comment|/* Since we just checked for an empty stack above, this                  ``can't happen''.  */
name|assert
argument_list|(
name|compile_stack
operator|.
name|avail
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|{
comment|/* We don't just want to restore into `regnum', because                    later groups should continue to be numbered higher,                    as in `(ab)c(de)' -- the second group is #2.  */
name|regnum_t
name|this_group_regnum
decl_stmt|;
name|compile_stack
operator|.
name|avail
operator|--
expr_stmt|;
name|begalt
operator|=
name|COMPILED_BUFFER_VAR
operator|+
name|COMPILE_STACK_TOP
operator|.
name|begalt_offset
expr_stmt|;
name|fixup_alt_jump
operator|=
name|COMPILE_STACK_TOP
operator|.
name|fixup_alt_jump
condition|?
name|COMPILED_BUFFER_VAR
operator|+
name|COMPILE_STACK_TOP
operator|.
name|fixup_alt_jump
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|laststart
operator|=
name|COMPILED_BUFFER_VAR
operator|+
name|COMPILE_STACK_TOP
operator|.
name|laststart_offset
expr_stmt|;
name|this_group_regnum
operator|=
name|COMPILE_STACK_TOP
operator|.
name|regnum
expr_stmt|;
comment|/* If we've reached MAX_REGNUM groups, then this open 		   won't actually generate any code, so we'll have to 		   clear pending_exact explicitly.  */
name|pending_exact
operator|=
literal|0
expr_stmt|;
comment|/* We're at the end of the group, so now we know how many                    groups were inside this one.  */
if|if
condition|(
name|this_group_regnum
operator|<=
name|MAX_REGNUM
condition|)
block|{
name|UCHAR_T
modifier|*
name|inner_group_loc
init|=
name|COMPILED_BUFFER_VAR
operator|+
name|COMPILE_STACK_TOP
operator|.
name|inner_group_offset
decl_stmt|;
operator|*
name|inner_group_loc
operator|=
name|regnum
operator|-
name|this_group_regnum
expr_stmt|;
name|BUF_PUSH_3
argument_list|(
name|stop_memory
argument_list|,
name|this_group_regnum
argument_list|,
name|regnum
operator|-
name|this_group_regnum
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* `\|'.  */
if|if
condition|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|||
name|syntax
operator|&
name|RE_NO_BK_VBAR
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_alt
label|:
if|if
condition|(
name|syntax
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
comment|/* Insert before the previous alternative a jump which                  jumps to this alternative if the former fails.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|on_failure_jump
argument_list|,
name|begalt
argument_list|,
name|b
operator|+
literal|2
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
comment|/* The alternative before this one has a jump after it                  which gets executed if it gets matched.  Adjust that                  jump so it will jump to this alternative's analogous                  jump (put in below, which in turn will jump to the next                  (if any) alternative's such jump, etc.).  The last such                  jump jumps to the correct final destination.  A picture:                           _____ _____                           |   | |   |                           |   v |   v                          a | b   | c                   If we are at `b', then fixup_alt_jump right now points to a                  three-byte space after `a'.  We'll put in the jump, set                  fixup_alt_jump to right after `b', and leave behind three                  bytes which we'll fill in when we get to after `c'.  */
if|if
condition|(
name|fixup_alt_jump
condition|)
name|STORE_JUMP
argument_list|(
name|jump_past_alt
argument_list|,
name|fixup_alt_jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Mark and leave space for a jump after this alternative,                  to be filled in later either by next alternative or                  when know we're at the end of a series of alternatives.  */
name|fixup_alt_jump
operator|=
name|b
expr_stmt|;
name|GET_BUFFER_SPACE
argument_list|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* If \{ is a literal.  */
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
comment|/* If we're at `\{' and it's not the open-interval                         operator.  */
operator|||
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_interval
label|:
block|{
comment|/* If got here, then the syntax allows intervals.  */
comment|/* At least (most) this many matches must be made.  */
name|int
name|lower_bound
init|=
operator|-
literal|1
decl_stmt|,
name|upper_bound
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Place in the uncompiled pattern (i.e., just after 		   the '{') to go back to if the interval is invalid.  */
specifier|const
name|CHAR_T
modifier|*
name|beg_interval
init|=
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
goto|goto
name|invalid_interval
goto|;
name|GET_UNSIGNED_NUMBER
argument_list|(
name|lower_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|GET_UNSIGNED_NUMBER
argument_list|(
name|upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper_bound
operator|<
literal|0
condition|)
name|upper_bound
operator|=
name|RE_DUP_MAX
expr_stmt|;
block|}
else|else
comment|/* Interval such as `{1}' => match exactly once. */
name|upper_bound
operator|=
name|lower_bound
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<=
name|lower_bound
operator|&&
name|lower_bound
operator|<=
name|upper_bound
operator|)
condition|)
goto|goto
name|invalid_interval
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\\'
operator|||
name|p
operator|==
name|pend
condition|)
goto|goto
name|invalid_interval
goto|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'}'
condition|)
goto|goto
name|invalid_interval
goto|;
comment|/* If it's invalid to have no preceding re.  */
if|if
condition|(
operator|!
name|laststart
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_OPS
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_INVALID_INTERVAL_ORD
operator|)
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
condition|)
name|laststart
operator|=
name|b
expr_stmt|;
else|else
goto|goto
name|unfetch_interval
goto|;
block|}
comment|/* We just parsed a valid interval.  */
if|if
condition|(
name|RE_DUP_MAX
operator|<
name|upper_bound
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
comment|/* If the upper bound is zero, don't want to succeed at                    all; jump from `laststart' to `b + 3', which will be 		   the end of the buffer after we insert the jump.  */
comment|/* ifdef WCHAR, 'b + 1 + OFFSET_ADDRESS_SIZE' 		   instead of 'b + 3'.  */
if|if
condition|(
name|upper_bound
operator|==
literal|0
condition|)
block|{
name|GET_BUFFER_SPACE
argument_list|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|INSERT_JUMP
argument_list|(
name|jump
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
block|}
comment|/* Otherwise, we have a nontrivial interval.  When                     we're all done, the pattern will look like:                       set_number_at<jump count><upper bound>                       set_number_at<succeed_n count><lower bound>                       succeed_n<after jump addr><succeed_n count><body of loop>                       jump_n<succeed_n addr><jump count>                     (The upper bound and `jump_n' are omitted if                     `upper_bound' is 1, though.)  */
else|else
block|{
comment|/* If the upper bound is> 1, we need to insert                         more at the end of the loop.  */
name|unsigned
name|nbytes
init|=
literal|2
operator|+
literal|4
operator|*
name|OFFSET_ADDRESS_SIZE
operator|+
operator|(
name|upper_bound
operator|>
literal|1
operator|)
operator|*
operator|(
literal|2
operator|+
literal|4
operator|*
name|OFFSET_ADDRESS_SIZE
operator|)
decl_stmt|;
name|GET_BUFFER_SPACE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Initialize lower bound of the `succeed_n', even                         though it will be set during matching by its                         attendant `set_number_at' (inserted next),                         because `re_compile_fastmap' needs to know.                         Jump to the `jump_n' we might insert below.  */
name|INSERT_JUMP2
argument_list|(
name|succeed_n
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
operator|+
operator|(
name|upper_bound
operator|>
literal|1
operator|)
operator|*
operator|(
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
operator|)
argument_list|,
name|lower_bound
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
comment|/* Code to initialize the lower bound.  Insert                         before the `succeed_n'.  The `5' is the last two                         bytes of this `set_number_at', plus 3 bytes of                         the following `succeed_n'.  */
comment|/* ifdef WCHAR, The '1+2*OFFSET_ADDRESS_SIZE' 			is the 'set_number_at', plus '1+OFFSET_ADDRESS_SIZE' 			of the following `succeed_n'.  */
name|PREFIX
argument_list|(
name|insert_op2
argument_list|)
argument_list|(
name|set_number_at
argument_list|,
name|laststart
argument_list|,
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
argument_list|,
name|lower_bound
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
if|if
condition|(
name|upper_bound
operator|>
literal|1
condition|)
block|{
comment|/* More than one repetition is allowed, so                             append a backward jump to the `succeed_n'                             that starts this interval.                              When we've reached this during matching,                             we'll have matched the interval once, so                             jump back only `upper_bound - 1' times.  */
name|STORE_JUMP2
argument_list|(
name|jump_n
argument_list|,
name|b
argument_list|,
name|laststart
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
operator|+
literal|1
argument_list|,
name|upper_bound
operator|-
literal|1
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
comment|/* The location we want to set is the second                             parameter of the `jump_n'; that is `b-2' as                             an absolute address.  `laststart' will be                             the `set_number_at' we're about to insert;                             `laststart+3' the number to set, the source                             for the relative address.  But we are                             inserting into the middle of the pattern --                             so everything is getting moved up by 5.                             Conclusion: (b - 2) - (laststart + 3) + 5,                             i.e., b - laststart.                              We insert this at the beginning of the loop                             so that if we fail during matching, we'll                             reinitialize the bounds.  */
name|PREFIX
argument_list|(
name|insert_op2
argument_list|)
argument_list|(
name|set_number_at
argument_list|,
name|laststart
argument_list|,
name|b
operator|-
name|laststart
argument_list|,
name|upper_bound
operator|-
literal|1
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
block|}
block|}
name|pending_exact
operator|=
literal|0
expr_stmt|;
break|break;
name|invalid_interval
label|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_INVALID_INTERVAL_ORD
operator|)
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|p
operator|==
name|pend
condition|?
name|REG_EBRACE
else|:
name|REG_BADBR
argument_list|)
expr_stmt|;
name|unfetch_interval
label|:
comment|/* Match the characters as literals.  */
name|p
operator|=
name|beg_interval
expr_stmt|;
name|c
operator|=
literal|'{'
expr_stmt|;
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|normal_backslash
goto|;
block|}
ifdef|#
directive|ifdef
name|emacs
comment|/* There is no way to specify the before_dot and after_dot                operators.  rms says this is ok.  --karl  */
case|case
literal|'='
case|:
name|BUF_PUSH
argument_list|(
name|at_dot
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
name|syntaxspec
argument_list|,
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
name|notsyntaxspec
argument_list|,
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
literal|'w'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|wordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH
argument_list|(
name|notwordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|wordbeg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|wordend
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|wordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|notwordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|begbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
condition|)
goto|goto
name|normal_char
goto|;
name|BUF_PUSH
argument_list|(
name|endbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_REFS
condition|)
goto|goto
name|normal_char
goto|;
name|c1
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c1
operator|>
name|regnum
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_ESUBREG
argument_list|)
expr_stmt|;
comment|/* Can't back reference to a subexpression if inside of it.  */
if|if
condition|(
name|group_in_compile_stack
argument_list|(
name|compile_stack
argument_list|,
operator|(
name|regnum_t
operator|)
name|c1
argument_list|)
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|BUF_PUSH_2
argument_list|(
name|duplicate
argument_list|,
name|c1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|handle_plus
goto|;
else|else
goto|goto
name|normal_backslash
goto|;
default|default:
name|normal_backslash
label|:
comment|/* You might think it would be useful for \ to mean                  not to translate; but if we don't translate it                  it will never match anything.  */
name|c
operator|=
name|TRANSLATE
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|normal_char
goto|;
block|}
break|break;
default|default:
comment|/* Expects the character in `c'.  */
name|normal_char
label|:
comment|/* If no exactn currently being built.  */
if|if
condition|(
operator|!
name|pending_exact
ifdef|#
directive|ifdef
name|WCHAR
comment|/* If last exactn handle binary(or character) and 		 new exactn handle character(or binary).  */
operator|||
name|is_exactn_bin
operator|!=
name|is_binary
index|[
name|p
operator|-
literal|1
operator|-
name|pattern
index|]
endif|#
directive|endif
comment|/* WCHAR */
comment|/* If last exactn not at current position.  */
operator|||
name|pending_exact
operator|+
operator|*
name|pending_exact
operator|+
literal|1
operator|!=
name|b
comment|/* We have only one byte following the exactn for the count.  */
operator|||
operator|*
name|pending_exact
operator|==
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|-
literal|1
comment|/* If followed by a repetition operator.  */
operator|||
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'^'
operator|||
operator|(
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|?
operator|*
name|p
operator|==
literal|'\\'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
else|:
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
operator|)
operator|||
operator|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|?
operator|*
name|p
operator|==
literal|'{'
else|:
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'{'
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Start building a new exactn.  */
name|laststart
operator|=
name|b
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* Is this exactn binary data or character? */
name|is_exactn_bin
operator|=
name|is_binary
index|[
name|p
operator|-
literal|1
operator|-
name|pattern
index|]
expr_stmt|;
if|if
condition|(
name|is_exactn_bin
condition|)
name|BUF_PUSH_2
argument_list|(
name|exactn_bin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|BUF_PUSH_2
argument_list|(
name|exactn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|BUF_PUSH_2
argument_list|(
name|exactn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
name|pending_exact
operator|=
name|b
operator|-
literal|1
expr_stmt|;
block|}
name|BUF_PUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pending_exact
operator|)
operator|++
expr_stmt|;
break|break;
block|}
comment|/* switch (c) */
block|}
comment|/* while p != pend */
comment|/* Through the pattern now.  */
if|if
condition|(
name|fixup_alt_jump
condition|)
name|STORE_JUMP
argument_list|(
name|jump_past_alt
argument_list|,
name|fixup_alt_jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPILE_STACK_EMPTY
condition|)
name|FREE_STACK_RETURN
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
comment|/* If we don't want backtracking, force success      the first time we reach the end of the compiled pattern.  */
if|if
condition|(
name|syntax
operator|&
name|RE_NO_POSIX_BACKTRACKING
condition|)
name|BUF_PUSH
argument_list|(
name|succeed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mbs_offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|compile_stack
operator|.
name|stack
argument_list|)
expr_stmt|;
comment|/* We have succeeded; set the length of the buffer.  */
ifdef|#
directive|ifdef
name|WCHAR
name|bufp
operator|->
name|used
operator|=
operator|(
name|uintptr_t
operator|)
name|b
operator|-
operator|(
name|uintptr_t
operator|)
name|COMPILED_BUFFER_VAR
expr_stmt|;
else|#
directive|else
name|bufp
operator|->
name|used
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|DEBUG_PRINT1
argument_list|(
literal|"\nCompiled pattern: \n"
argument_list|)
expr_stmt|;
name|PREFIX
function_decl|(
name|print_compiled_pattern
function_decl|)
parameter_list|(
name|bufp
parameter_list|)
function_decl|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
ifndef|#
directive|ifndef
name|MATCH_MAY_ALLOCATE
comment|/* Initialize the failure stack to the largest possible stack.  This      isn't necessary unless we're trying to avoid calling alloca in      the search and match routines.  */
block|{
name|int
name|num_regs
init|=
name|bufp
operator|->
name|re_nsub
operator|+
literal|1
decl_stmt|;
comment|/* Since DOUBLE_FAIL_STACK refuses to double only if the current size        is strictly greater than re_max_failures, the largest possible stack        is 2 * re_max_failures failure points.  */
if|if
condition|(
name|fail_stack
operator|.
name|size
operator|<
operator|(
literal|2
operator|*
name|re_max_failures
operator|*
name|MAX_FAILURE_ITEMS
operator|)
condition|)
block|{
name|fail_stack
operator|.
name|size
operator|=
operator|(
literal|2
operator|*
name|re_max_failures
operator|*
name|MAX_FAILURE_ITEMS
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|emacs
if|if
condition|(
operator|!
name|fail_stack
operator|.
name|stack
condition|)
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|*
operator|)
name|xmalloc
argument_list|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|*
operator|)
name|xrealloc
argument_list|(
name|fail_stack
operator|.
name|stack
argument_list|,
operator|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not emacs */
if|if
condition|(
operator|!
name|fail_stack
operator|.
name|stack
condition|)
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|*
operator|)
name|malloc
argument_list|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fail_stack
operator|.
name|stack
operator|=
operator|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
operator|*
operator|)
name|realloc
argument_list|(
name|fail_stack
operator|.
name|stack
argument_list|,
operator|(
name|fail_stack
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|(
name|fail_stack_elt_t
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not emacs */
block|}
name|PREFIX
function_decl|(
name|regex_grow_registers
function_decl|)
parameter_list|(
name|num_regs
parameter_list|)
function_decl|;
block|}
endif|#
directive|endif
comment|/* not MATCH_MAY_ALLOCATE */
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* regex_compile */
end_comment

begin_comment
comment|/* Subroutines for `regex_compile'.  */
end_comment

begin_comment
comment|/* Store OP at LOC followed by two-byte integer parameter ARG.  */
end_comment

begin_comment
comment|/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
end_comment

begin_function
specifier|static
name|void
name|PREFIX
function|(
name|store_op1
function|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
operator|*
name|loc
operator|=
operator|(
name|UCHAR_T
operator|)
name|op
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|loc
operator|+
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
end_comment

begin_comment
comment|/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
end_comment

begin_function
specifier|static
name|void
name|PREFIX
function|(
name|store_op2
function|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
operator|*
name|loc
operator|=
operator|(
name|UCHAR_T
operator|)
name|op
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|loc
operator|+
literal|1
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|loc
operator|+
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the bytes from LOC to END to open up three bytes of space at LOC    for OP followed by two-byte integer parameter ARG.  */
end_comment

begin_comment
comment|/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
end_comment

begin_function
specifier|static
name|void
name|PREFIX
function|(
name|insert_op1
function|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg
parameter_list|,
name|UCHAR_T
modifier|*
name|end
parameter_list|)
block|{
specifier|register
name|UCHAR_T
modifier|*
name|pfrom
init|=
name|end
decl_stmt|;
specifier|register
name|UCHAR_T
modifier|*
name|pto
init|=
name|end
operator|+
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
decl_stmt|;
while|while
condition|(
name|pfrom
operator|!=
name|loc
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|PREFIX
function_decl|(
name|store_op1
function_decl|)
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|arg
parameter_list|)
function_decl|;
block|}
end_function

begin_comment
comment|/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
end_comment

begin_comment
comment|/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
end_comment

begin_function
specifier|static
name|void
name|PREFIX
function|(
name|insert_op2
function|)
parameter_list|(
name|re_opcode_t
name|op
parameter_list|,
name|UCHAR_T
modifier|*
name|loc
parameter_list|,
name|int
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|,
name|UCHAR_T
modifier|*
name|end
parameter_list|)
block|{
specifier|register
name|UCHAR_T
modifier|*
name|pfrom
init|=
name|end
decl_stmt|;
specifier|register
name|UCHAR_T
modifier|*
name|pto
init|=
name|end
operator|+
literal|1
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
decl_stmt|;
while|while
condition|(
name|pfrom
operator|!=
name|loc
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|PREFIX
function_decl|(
name|store_op2
function_decl|)
parameter_list|(
name|op
parameter_list|,
name|loc
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
function_decl|;
block|}
end_function

begin_comment
comment|/* P points to just after a ^ in PATTERN.  Return true if that ^ comes    after an alternative or a begin-subexpression.  We assume there is at    least one character before the ^.  */
end_comment

begin_function
specifier|static
name|boolean
name|PREFIX
function|(
name|at_begline_loc_p
function|)
parameter_list|(
specifier|const
name|CHAR_T
modifier|*
name|pattern
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|p
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
block|{
specifier|const
name|CHAR_T
modifier|*
name|prev
init|=
name|p
operator|-
literal|2
decl_stmt|;
name|boolean
name|prev_prev_backslash
init|=
name|prev
operator|>
name|pattern
operator|&&
name|prev
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
decl_stmt|;
return|return
comment|/* After a subexpression?  */
operator|(
operator|*
name|prev
operator|==
literal|'('
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
operator|||
name|prev_prev_backslash
operator|)
operator|)
comment|/* After an alternative?  */
operator|||
operator|(
operator|*
name|prev
operator|==
literal|'|'
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
operator|||
name|prev_prev_backslash
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The dual of at_begline_loc_p.  This one is for $.  We assume there is    at least one character after the $, i.e., `P< PEND'.  */
end_comment

begin_function
specifier|static
name|boolean
name|PREFIX
function|(
name|at_endline_loc_p
function|)
parameter_list|(
specifier|const
name|CHAR_T
modifier|*
name|p
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|pend
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
block|{
specifier|const
name|CHAR_T
modifier|*
name|next
init|=
name|p
decl_stmt|;
name|boolean
name|next_backslash
init|=
operator|*
name|next
operator|==
literal|'\\'
decl_stmt|;
specifier|const
name|CHAR_T
modifier|*
name|next_next
init|=
name|p
operator|+
literal|1
operator|<
name|pend
condition|?
name|p
operator|+
literal|1
else|:
literal|0
decl_stmt|;
return|return
comment|/* Before a subexpression?  */
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|?
operator|*
name|next
operator|==
literal|')'
else|:
name|next_backslash
operator|&&
name|next_next
operator|&&
operator|*
name|next_next
operator|==
literal|')'
operator|)
comment|/* Before an alternative?  */
operator|||
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
condition|?
operator|*
name|next
operator|==
literal|'|'
else|:
name|next_backslash
operator|&&
name|next_next
operator|&&
operator|*
name|next_next
operator|==
literal|'|'
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_comment
comment|/* Returns true if REGNUM is in one of COMPILE_STACK's elements and    false if it's not.  */
end_comment

begin_function
specifier|static
name|boolean
name|group_in_compile_stack
parameter_list|(
name|compile_stack_type
name|compile_stack
parameter_list|,
name|regnum_t
name|regnum
parameter_list|)
block|{
name|int
name|this_element
decl_stmt|;
for|for
control|(
name|this_element
operator|=
name|compile_stack
operator|.
name|avail
operator|-
literal|1
init|;
name|this_element
operator|>=
literal|0
condition|;
name|this_element
operator|--
control|)
if|if
condition|(
name|compile_stack
operator|.
name|stack
index|[
name|this_element
index|]
operator|.
name|regnum
operator|==
name|regnum
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INSIDE_RECURSION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_comment
comment|/* This insert space, which size is "num", into the pattern at "loc".    "end" must point the end of the allocated buffer.  */
end_comment

begin_function
specifier|static
name|void
name|insert_space
parameter_list|(
name|int
name|num
parameter_list|,
name|CHAR_T
modifier|*
name|loc
parameter_list|,
name|CHAR_T
modifier|*
name|end
parameter_list|)
block|{
specifier|register
name|CHAR_T
modifier|*
name|pto
init|=
name|end
decl_stmt|;
specifier|register
name|CHAR_T
modifier|*
name|pfrom
init|=
name|end
operator|-
name|num
decl_stmt|;
while|while
condition|(
name|pfrom
operator|>=
name|loc
condition|)
operator|*
name|pto
operator|--
operator|=
operator|*
name|pfrom
operator|--
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_function
specifier|static
name|reg_errcode_t
name|wcs_compile_range
parameter_list|(
name|CHAR_T
name|range_start_char
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
modifier|*
name|p_ptr
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|pend
parameter_list|,
name|RE_TRANSLATE_TYPE
name|translate
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|CHAR_T
modifier|*
name|b
parameter_list|,
name|CHAR_T
modifier|*
name|char_set
parameter_list|)
block|{
specifier|const
name|CHAR_T
modifier|*
name|p
init|=
operator|*
name|p_ptr
decl_stmt|;
name|CHAR_T
name|range_start
decl_stmt|,
name|range_end
decl_stmt|;
name|reg_errcode_t
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|uint32_t
name|nrules
decl_stmt|;
name|uint32_t
name|start_val
decl_stmt|,
name|end_val
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_ERANGE
return|;
ifdef|#
directive|ifdef
name|_LIBC
name|nrules
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|collseq
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQWC
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
decl_stmt|;
if|if
condition|(
name|range_start_char
operator|<
operator|-
literal|1
condition|)
block|{
comment|/* range_start is a collating symbol.  */
name|int32_t
modifier|*
name|wextra
decl_stmt|;
comment|/* Retreive the index and get collation sequence value.  */
name|wextra
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|extra
operator|+
name|char_set
index|[
operator|-
name|range_start_char
index|]
operator|)
expr_stmt|;
name|start_val
operator|=
name|wextra
index|[
literal|1
operator|+
operator|*
name|wextra
index|]
expr_stmt|;
block|}
else|else
name|start_val
operator|=
name|collseq_table_lookup
argument_list|(
name|collseq
argument_list|,
name|TRANSLATE
argument_list|(
name|range_start_char
argument_list|)
argument_list|)
expr_stmt|;
name|end_val
operator|=
name|collseq_table_lookup
argument_list|(
name|collseq
argument_list|,
name|TRANSLATE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Report an error if the range is empty and the syntax prohibits 	 this.  */
name|ret
operator|=
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_EMPTY_RANGES
operator|)
operator|&&
operator|(
name|start_val
operator|>
name|end_val
operator|)
operator|)
condition|?
name|REG_ERANGE
else|:
name|REG_NOERROR
expr_stmt|;
comment|/* Insert space to the end of the char_ranges.  */
name|insert_space
argument_list|(
literal|2
argument_list|,
name|b
operator|-
name|char_set
index|[
literal|5
index|]
operator|-
literal|2
argument_list|,
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|b
operator|-
name|char_set
index|[
literal|5
index|]
operator|-
literal|2
operator|)
operator|=
operator|(
name|wchar_t
operator|)
name|start_val
expr_stmt|;
operator|*
operator|(
name|b
operator|-
name|char_set
index|[
literal|5
index|]
operator|-
literal|1
operator|)
operator|=
operator|(
name|wchar_t
operator|)
name|end_val
expr_stmt|;
name|char_set
index|[
literal|4
index|]
operator|++
expr_stmt|;
comment|/* ranges_index */
block|}
else|else
endif|#
directive|endif
block|{
name|range_start
operator|=
operator|(
name|range_start_char
operator|>=
literal|0
operator|)
condition|?
name|TRANSLATE
argument_list|(
name|range_start_char
argument_list|)
else|:
name|range_start_char
expr_stmt|;
name|range_end
operator|=
name|TRANSLATE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Report an error if the range is empty and the syntax prohibits 	 this.  */
name|ret
operator|=
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_EMPTY_RANGES
operator|)
operator|&&
operator|(
name|range_start
operator|>
name|range_end
operator|)
operator|)
condition|?
name|REG_ERANGE
else|:
name|REG_NOERROR
expr_stmt|;
comment|/* Insert space to the end of the char_ranges.  */
name|insert_space
argument_list|(
literal|2
argument_list|,
name|b
operator|-
name|char_set
index|[
literal|5
index|]
operator|-
literal|2
argument_list|,
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|b
operator|-
name|char_set
index|[
literal|5
index|]
operator|-
literal|2
operator|)
operator|=
name|range_start
expr_stmt|;
operator|*
operator|(
name|b
operator|-
name|char_set
index|[
literal|5
index|]
operator|-
literal|1
operator|)
operator|=
name|range_end
expr_stmt|;
name|char_set
index|[
literal|4
index|]
operator|++
expr_stmt|;
comment|/* ranges_index */
block|}
comment|/* Have to increment the pointer into the pattern string, so the      caller isn't still at the ending character.  */
operator|(
operator|*
name|p_ptr
operator|)
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_comment
comment|/* Read the ending character of a range (in a bracket expression) from the    uncompiled pattern *P_PTR (which ends at PEND).  We assume the    starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)    Then we set the translation of all bits between the starting and    ending characters (inclusive) in the compiled pattern B.     Return an error code.     We use these short variable names so we can use the same macros as    `regex_compile' itself.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|byte_compile_range
parameter_list|(
name|unsigned
name|int
name|range_start_char
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|p_ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|pend
parameter_list|,
name|RE_TRANSLATE_TYPE
name|translate
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
name|unsigned
name|this_char
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|p_ptr
decl_stmt|;
name|reg_errcode_t
name|ret
decl_stmt|;
if|#
directive|if
name|_LIBC
specifier|const
name|unsigned
name|char
modifier|*
name|collseq
decl_stmt|;
name|unsigned
name|int
name|start_colseq
decl_stmt|;
name|unsigned
name|int
name|end_colseq
decl_stmt|;
else|#
directive|else
name|unsigned
name|end_char
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_ERANGE
return|;
comment|/* Have to increment the pointer into the pattern string, so the      caller isn't still at the ending character.  */
operator|(
operator|*
name|p_ptr
operator|)
operator|++
expr_stmt|;
comment|/* Report an error if the range is empty and the syntax prohibits this.  */
name|ret
operator|=
name|syntax
operator|&
name|RE_NO_EMPTY_RANGES
condition|?
name|REG_ERANGE
else|:
name|REG_NOERROR
expr_stmt|;
if|#
directive|if
name|_LIBC
name|collseq
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQMB
argument_list|)
expr_stmt|;
name|start_colseq
operator|=
name|collseq
index|[
operator|(
name|unsigned
name|char
operator|)
name|TRANSLATE
argument_list|(
name|range_start_char
argument_list|)
index|]
expr_stmt|;
name|end_colseq
operator|=
name|collseq
index|[
operator|(
name|unsigned
name|char
operator|)
name|TRANSLATE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|this_char
operator|=
literal|0
init|;
name|this_char
operator|<=
operator|(
name|unsigned
name|char
operator|)
operator|-
literal|1
condition|;
operator|++
name|this_char
control|)
block|{
name|unsigned
name|int
name|this_colseq
init|=
name|collseq
index|[
operator|(
name|unsigned
name|char
operator|)
name|TRANSLATE
argument_list|(
name|this_char
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|start_colseq
operator|<=
name|this_colseq
operator|&&
name|this_colseq
operator|<=
name|end_colseq
condition|)
block|{
name|SET_LIST_BIT
argument_list|(
name|TRANSLATE
argument_list|(
name|this_char
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|REG_NOERROR
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* Here we see why `this_char' has to be larger than an `unsigned      char' -- we would otherwise go into an infinite loop, since all      characters<= 0xff.  */
name|range_start_char
operator|=
name|TRANSLATE
argument_list|(
name|range_start_char
argument_list|)
expr_stmt|;
comment|/* TRANSLATE(p[0]) is casted to char (not unsigned char) in TRANSLATE,      and some compilers cast it to int implicitly, so following for_loop      may fall to (almost) infinite loop.      e.g. If translate[p[0]] = 0xff, end_char may equals to 0xffffffff.      To avoid this, we cast p[0] to unsigned int and truncate it.  */
name|end_char
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|TRANSLATE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|this_char
operator|=
name|range_start_char
init|;
name|this_char
operator|<=
name|end_char
condition|;
operator|++
name|this_char
control|)
block|{
name|SET_LIST_BIT
argument_list|(
name|TRANSLATE
argument_list|(
name|this_char
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|REG_NOERROR
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_escape
end_escape

begin_comment
comment|/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in    BUFP.  A fastmap records which of the (1<< BYTEWIDTH) possible    characters can start a string that matches the pattern.  This fastmap    is used by re_search to skip quickly over impossible starting points.     The caller must supply the address of a (1<< BYTEWIDTH)-byte data    area as BUFP->fastmap.     We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in    the pattern buffer.     Returns 0 if we succeed, -2 if an internal error.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_comment
comment|/* local function for re_compile_fastmap.    truncate wchar_t character to char.  */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|char
name|truncate_wchar
parameter_list|(
name|CHAR_T
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|unsigned
name|char
name|truncate_wchar
parameter_list|(
name|CHAR_T
name|c
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|MB_CUR_MAX
index|]
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|retval
operator|=
name|__wcrtomb
argument_list|(
name|buf
argument_list|,
name|c
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
else|#
directive|else
name|retval
operator|=
name|wcrtomb
argument_list|(
name|buf
argument_list|,
name|c
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
operator|>
literal|0
condition|?
name|buf
index|[
literal|0
index|]
else|:
operator|(
name|unsigned
name|char
operator|)
name|c
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_function
specifier|static
name|int
name|PREFIX
function|(
name|re_compile_fastmap
function|)
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
name|PREFIX
argument_list|(
argument|fail_stack_type
argument_list|)
name|fail_stack
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|REGEX_MALLOC
name|char
modifier|*
name|destination
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|bufp
operator|->
name|fastmap
decl_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* We need to cast pattern to (wchar_t*), because we casted this compiled      pattern to (char*) in regex_compile.  */
name|UCHAR_T
modifier|*
name|pattern
init|=
operator|(
name|UCHAR_T
operator|*
operator|)
name|bufp
operator|->
name|buffer
decl_stmt|;
specifier|register
name|UCHAR_T
modifier|*
name|pend
init|=
operator|(
name|UCHAR_T
operator|*
operator|)
operator|(
name|bufp
operator|->
name|buffer
operator|+
name|bufp
operator|->
name|used
operator|)
decl_stmt|;
else|#
directive|else
comment|/* BYTE */
name|UCHAR_T
modifier|*
name|pattern
init|=
name|bufp
operator|->
name|buffer
decl_stmt|;
specifier|register
name|UCHAR_T
modifier|*
name|pend
init|=
name|pattern
operator|+
name|bufp
operator|->
name|used
decl_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
name|UCHAR_T
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
ifdef|#
directive|ifdef
name|REL_ALLOC
comment|/* This holds the pointer to the failure stack, when      it is allocated relocatably.  */
name|fail_stack_elt_t
modifier|*
name|failure_stack_ptr
decl_stmt|;
endif|#
directive|endif
comment|/* Assume that each path through the pattern can be null until      proven otherwise.  We set this false at the bottom of switch      statement, to which we get only if a particular path doesn't      match the empty string.  */
name|boolean
name|path_can_be_null
init|=
name|true
decl_stmt|;
comment|/* We aren't doing a `succeed_n' to begin with.  */
name|boolean
name|succeed_n_p
init|=
name|false
decl_stmt|;
name|assert
argument_list|(
name|fastmap
operator|!=
name|NULL
operator|&&
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INIT_FAIL_STACK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|fastmap
argument_list|,
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* Assume nothing's valid.  */
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|1
expr_stmt|;
comment|/* It will be when we're done.  */
name|bufp
operator|->
name|can_be_null
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
operator|||
operator|*
name|p
operator|==
operator|(
name|UCHAR_T
operator|)
name|succeed
condition|)
block|{
comment|/* We have reached the (effective) end of pattern.  */
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
condition|)
block|{
name|bufp
operator|->
name|can_be_null
operator||=
name|path_can_be_null
expr_stmt|;
comment|/* Reset for next path.  */
name|path_can_be_null
operator|=
name|true
expr_stmt|;
name|p
operator|=
name|fail_stack
operator|.
name|stack
index|[
operator|--
name|fail_stack
operator|.
name|avail
index|]
operator|.
name|pointer
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
comment|/* We should never be about to go beyond the end of the pattern.  */
name|assert
argument_list|(
name|p
operator|<
name|pend
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SWITCH_ENUM_CAST
argument_list|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
comment|/* I guess the idea here is to simply not bother with a fastmap            if a backreference is used, since it's too hard to figure out            the fastmap for the corresponding group.  Setting            `can_be_null' stops `re_search_2' from using the fastmap, so            that is all we do.  */
case|case
name|duplicate
case|:
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* Following are the cases which match a character.  These end          with `break'.  */
ifdef|#
directive|ifdef
name|WCHAR
case|case
name|exactn
case|:
name|fastmap
index|[
name|truncate_wchar
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
break|break;
else|#
directive|else
comment|/* BYTE */
case|case
name|exactn
case|:
name|fastmap
index|[
name|p
index|[
literal|1
index|]
index|]
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* WCHAR */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
case|case
name|exactn_bin
case|:
name|fastmap
index|[
name|p
index|[
literal|1
index|]
index|]
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WCHAR
comment|/* It is hard to distinguish fastmap from (multi byte) characters            which depends on current locale.  */
case|case
name|charset
case|:
case|case
name|charset_not
case|:
case|case
name|wordchar
case|:
case|case
name|notwordchar
case|:
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
else|#
directive|else
comment|/* BYTE */
case|case
name|charset
case|:
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|charset_not
case|:
comment|/* Chars beyond end of map must be allowed.  */
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|*
name|BYTEWIDTH
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
operator|)
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|wordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* WCHAR */
case|case
name|anychar
case|:
block|{
name|int
name|fastmap_newline
init|=
name|fastmap
index|[
literal|'\n'
index|]
decl_stmt|;
comment|/* `.' matches anything ...  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
comment|/* ... except perhaps newline.  */
if|if
condition|(
operator|!
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
name|fastmap
index|[
literal|'\n'
index|]
operator|=
name|fastmap_newline
expr_stmt|;
comment|/* Return if we have already set `can_be_null'; if we have, 	       then the fastmap is irrelevant.  Something's wrong here.  */
elseif|else
if|if
condition|(
name|bufp
operator|->
name|can_be_null
condition|)
goto|goto
name|done
goto|;
comment|/* Otherwise, have to check alternative paths.  */
break|break;
block|}
ifdef|#
directive|ifdef
name|emacs
case|case
name|syntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* All cases after this match the empty string.  These end with          `continue'.  */
case|case
name|before_dot
case|:
case|case
name|at_dot
case|:
case|case
name|after_dot
case|:
continue|continue;
endif|#
directive|endif
comment|/* emacs */
case|case
name|no_op
case|:
case|case
name|begline
case|:
case|case
name|endline
case|:
case|case
name|begbuf
case|:
case|case
name|endbuf
case|:
case|case
name|wordbound
case|:
case|case
name|notwordbound
case|:
case|case
name|wordbeg
case|:
case|case
name|wordend
case|:
case|case
name|push_dummy_failure
case|:
continue|continue;
case|case
name|jump_n
case|:
case|case
name|pop_failure_jump
case|:
case|case
name|maybe_pop_jump
case|:
case|case
name|jump
case|:
case|case
name|jump_past_alt
case|:
case|case
name|dummy_failure_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
continue|continue;
comment|/* Jump backward implies we just went through the body of a              loop and matched nothing.  Opcode jumped to should be              `on_failure_jump' or `succeed_n'.  Just treat it like an              ordinary jump.  For a * loop, it has pushed its failure              point already; if so, discard that as redundant.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|!=
name|on_failure_jump
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|!=
name|succeed_n
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|j
expr_stmt|;
comment|/* If what's on the stack is where we are now, pop it.  */
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
operator|&&
name|fail_stack
operator|.
name|stack
index|[
name|fail_stack
operator|.
name|avail
operator|-
literal|1
index|]
operator|.
name|pointer
operator|==
name|p
condition|)
name|fail_stack
operator|.
name|avail
operator|--
expr_stmt|;
continue|continue;
case|case
name|on_failure_jump
case|:
case|case
name|on_failure_keep_string_jump
case|:
name|handle_on_failure_jump
label|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* For some patterns, e.g., `(a?)?', `p+j' here points to the              end of the pattern.  We don't want to push such a point,              since when we restore it above, entering the switch will              increment `p' past the end of the pattern.  We don't need              to push such a point since we obviously won't find any more              fastmap entries beyond `pend'.  Such a pattern can match              the null string, though.  */
if|if
condition|(
name|p
operator|+
name|j
operator|<
name|pend
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH_PATTERN_OP
argument_list|(
name|p
operator|+
name|j
argument_list|,
name|fail_stack
argument_list|)
condition|)
block|{
name|RESET_FAIL_STACK
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
else|else
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|succeed_n_p
condition|)
block|{
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|k
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the n.  */
name|succeed_n_p
operator|=
name|false
expr_stmt|;
block|}
continue|continue;
case|case
name|succeed_n
case|:
comment|/* Get to the number of times to succeed.  */
name|p
operator|+=
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
comment|/* Increment p past the n for when k != 0.  */
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|k
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
name|p
operator|-=
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
name|succeed_n_p
operator|=
name|true
expr_stmt|;
comment|/* Spaghetti code alert.  */
goto|goto
name|handle_on_failure_jump
goto|;
block|}
continue|continue;
case|case
name|set_number_at
case|:
name|p
operator|+=
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
continue|continue;
case|case
name|start_memory
case|:
case|case
name|stop_memory
case|:
name|p
operator|+=
literal|2
expr_stmt|;
continue|continue;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* We have listed all the cases.  */
block|}
comment|/* switch *p++ */
comment|/* Getting here means we have found the possible starting          characters for one path of the pattern -- and that the empty          string does not match.  We need not follow this path further.          Instead, look at the next alternative (remembered on the          stack), or quit if no more.  The test at the top of the loop          does these things.  */
name|path_can_be_null
operator|=
name|false
expr_stmt|;
name|p
operator|=
name|pend
expr_stmt|;
block|}
comment|/* while p */
comment|/* Set `can_be_null' for the last path (also the first path, if the      pattern is empty).  */
name|bufp
operator|->
name|can_be_null
operator||=
name|path_can_be_null
expr_stmt|;
name|done
label|:
name|RESET_FAIL_STACK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_function
name|int
name|re_compile_fastmap
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
condition|)
return|return
name|wcs_re_compile_fastmap
argument_list|(
name|bufp
argument_list|)
return|;
else|else
endif|#
directive|endif
return|return
name|byte_re_compile_fastmap
argument_list|(
name|bufp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* re_compile_fastmap */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_compile_fastmap
argument_list|,
argument|re_compile_fastmap
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Set REGS to hold NUM_REGS registers, storing them in STARTS and    ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use    this memory for recording register information.  STARTS and ENDS    must be allocated using the malloc library routine, and must each    be at least NUM_REGS * sizeof (regoff_t) bytes long.     If NUM_REGS == 0, then subsequent matches should allocate their own    register data.     Unless this function is called, the first search or match using    PATTERN_BUFFER will allocate its own register data, without    freeing the old data.  */
end_comment

begin_function
name|void
name|re_set_registers
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|unsigned
name|num_regs
parameter_list|,
name|regoff_t
modifier|*
name|starts
parameter_list|,
name|regoff_t
modifier|*
name|ends
parameter_list|)
block|{
if|if
condition|(
name|num_regs
condition|)
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_REALLOCATE
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|starts
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|ends
expr_stmt|;
block|}
else|else
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|regs
operator|->
name|end
operator|=
operator|(
name|regoff_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_set_registers
argument_list|,
argument|re_set_registers
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Searching routines.  */
end_comment

begin_comment
comment|/* Like re_search_2, below, but only one string is specified, and    doesn't let you say where to stop matching.  */
end_comment

begin_function
name|int
name|re_search
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|startpos
parameter_list|,
name|int
name|range
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|)
block|{
return|return
name|re_search_2
argument_list|(
name|bufp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_search
argument_list|,
argument|re_search
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Using the compiled pattern in BUFP->buffer, first tries to match the    virtual concatenation of STRING1 and STRING2, starting first at index    STARTPOS, then at STARTPOS + 1, and so on.     STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.     RANGE is how far to scan while trying to match.  RANGE = 0 means try    only at STARTPOS; in general, the last start tried is STARTPOS +    RANGE.     In REGS, return the indices of the virtual concatenation of STRING1    and STRING2 that matched the entire BUFP->buffer and its contained    subexpressions.     Do not consider matching one past the index STOP in the virtual    concatenation of STRING1 and STRING2.     We return either the position in the strings at which the match was    found, -1 if no match, or -2 if error (such as failure    stack overflow).  */
end_comment

begin_function
name|int
name|re_search_2
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|startpos
parameter_list|,
name|int
name|range
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
condition|)
return|return
name|wcs_re_search_2
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
return|;
else|else
endif|#
directive|endif
return|return
name|byte_re_search_2
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* re_search_2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_search_2
argument_list|,
argument|re_search_2
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INSIDE_RECURSION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
end_ifdef

begin_define
define|#
directive|define
name|FREE_VAR
parameter_list|(
name|var
parameter_list|)
value|if (var) REGEX_FREE (var); var = NULL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FREE_VAR
parameter_list|(
name|var
parameter_list|)
value|if (var) free (var); var = NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|MAX_ALLOCA_SIZE
value|2000
end_define

begin_define
define|#
directive|define
name|FREE_WCS_BUFFERS
parameter_list|()
define|\
value|do {									      \     if (size1> MAX_ALLOCA_SIZE)					      \       {									      \ 	free (wcs_string1);						      \ 	free (mbs_offset1);						      \       }									      \     else								      \       {									      \ 	FREE_VAR (wcs_string1);						      \ 	FREE_VAR (mbs_offset1);						      \       }									      \     if (size2> MAX_ALLOCA_SIZE) 					      \       {									      \ 	free (wcs_string2);						      \ 	free (mbs_offset2);						      \       }									      \     else								      \       {									      \ 	FREE_VAR (wcs_string2);						      \ 	FREE_VAR (mbs_offset2);						      \       }									      \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|PREFIX
function|(
name|re_search_2
function|)
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|startpos
parameter_list|,
name|int
name|range
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|bufp
operator|->
name|fastmap
decl_stmt|;
specifier|register
name|RE_TRANSLATE_TYPE
name|translate
init|=
name|bufp
operator|->
name|translate
decl_stmt|;
name|int
name|total_size
init|=
name|size1
operator|+
name|size2
decl_stmt|;
name|int
name|endpos
init|=
name|startpos
operator|+
name|range
decl_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* We need wchar_t* buffers correspond to cstring1, cstring2.  */
name|wchar_t
modifier|*
name|wcs_string1
init|=
name|NULL
decl_stmt|,
modifier|*
name|wcs_string2
init|=
name|NULL
decl_stmt|;
comment|/* We need the size of wchar_t buffers correspond to csize1, csize2.  */
name|int
name|wcs_size1
init|=
literal|0
decl_stmt|,
name|wcs_size2
init|=
literal|0
decl_stmt|;
comment|/* offset buffer for optimizatoin. See convert_mbs_to_wc.  */
name|int
modifier|*
name|mbs_offset1
init|=
name|NULL
decl_stmt|,
modifier|*
name|mbs_offset2
init|=
name|NULL
decl_stmt|;
comment|/* They hold whether each wchar_t is binary data or not.  */
name|char
modifier|*
name|is_binary
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
comment|/* Check for out-of-range STARTPOS.  */
if|if
condition|(
name|startpos
operator|<
literal|0
operator|||
name|startpos
operator|>
name|total_size
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Fix up RANGE if it might eventually take us outside      the virtual concatenation of STRING1 and STRING2.      Make sure we won't move STARTPOS below 0 or above TOTAL_SIZE.  */
if|if
condition|(
name|endpos
operator|<
literal|0
condition|)
name|range
operator|=
literal|0
operator|-
name|startpos
expr_stmt|;
elseif|else
if|if
condition|(
name|endpos
operator|>
name|total_size
condition|)
name|range
operator|=
name|total_size
operator|-
name|startpos
expr_stmt|;
comment|/* If the search isn't to be a backwards one, don't waste time in a      search for a pattern that must be anchored.  */
if|if
condition|(
name|bufp
operator|->
name|used
operator|>
literal|0
operator|&&
name|range
operator|>
literal|0
operator|&&
operator|(
operator|(
name|re_opcode_t
operator|)
name|bufp
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
name|begbuf
comment|/* `begline' is like `begbuf' if it cannot match at newlines.  */
operator|||
operator|(
operator|(
name|re_opcode_t
operator|)
name|bufp
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
name|begline
operator|&&
operator|!
name|bufp
operator|->
name|newline_anchor
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|startpos
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|range
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|emacs
comment|/* In a forward search for something that starts with \=.      don't keep searching past point.  */
if|if
condition|(
name|bufp
operator|->
name|used
operator|>
literal|0
operator|&&
operator|(
name|re_opcode_t
operator|)
name|bufp
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
name|at_dot
operator|&&
name|range
operator|>
literal|0
condition|)
block|{
name|range
operator|=
name|PT
operator|-
name|startpos
expr_stmt|;
if|if
condition|(
name|range
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* emacs */
comment|/* Update the fastmap now if not correct already.  */
if|if
condition|(
name|fastmap
operator|&&
operator|!
name|bufp
operator|->
name|fastmap_accurate
condition|)
if|if
condition|(
name|re_compile_fastmap
argument_list|(
name|bufp
argument_list|)
operator|==
operator|-
literal|2
condition|)
return|return
operator|-
literal|2
return|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* Allocate wchar_t array for wcs_string1 and wcs_string2 and      fill them with converted string.  */
if|if
condition|(
name|size1
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|size1
operator|>
name|MAX_ALLOCA_SIZE
condition|)
block|{
name|wcs_string1
operator|=
name|TALLOC
argument_list|(
name|size1
operator|+
literal|1
argument_list|,
name|CHAR_T
argument_list|)
expr_stmt|;
name|mbs_offset1
operator|=
name|TALLOC
argument_list|(
name|size1
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|is_binary
operator|=
name|TALLOC
argument_list|(
name|size1
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wcs_string1
operator|=
name|REGEX_TALLOC
argument_list|(
name|size1
operator|+
literal|1
argument_list|,
name|CHAR_T
argument_list|)
expr_stmt|;
name|mbs_offset1
operator|=
name|REGEX_TALLOC
argument_list|(
name|size1
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|is_binary
operator|=
name|REGEX_TALLOC
argument_list|(
name|size1
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wcs_string1
operator|||
operator|!
name|mbs_offset1
operator|||
operator|!
name|is_binary
condition|)
block|{
if|if
condition|(
name|size1
operator|>
name|MAX_ALLOCA_SIZE
condition|)
block|{
name|free
argument_list|(
name|wcs_string1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mbs_offset1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FREE_VAR
argument_list|(
name|wcs_string1
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|mbs_offset1
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|2
return|;
block|}
name|wcs_size1
operator|=
name|convert_mbs_to_wcs
argument_list|(
name|wcs_string1
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|mbs_offset1
argument_list|,
name|is_binary
argument_list|)
expr_stmt|;
name|wcs_string1
index|[
name|wcs_size1
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* for a sentinel  */
if|if
condition|(
name|size1
operator|>
name|MAX_ALLOCA_SIZE
condition|)
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
else|else
name|FREE_VAR
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|size2
operator|>
name|MAX_ALLOCA_SIZE
condition|)
block|{
name|wcs_string2
operator|=
name|TALLOC
argument_list|(
name|size2
operator|+
literal|1
argument_list|,
name|CHAR_T
argument_list|)
expr_stmt|;
name|mbs_offset2
operator|=
name|TALLOC
argument_list|(
name|size2
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|is_binary
operator|=
name|TALLOC
argument_list|(
name|size2
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wcs_string2
operator|=
name|REGEX_TALLOC
argument_list|(
name|size2
operator|+
literal|1
argument_list|,
name|CHAR_T
argument_list|)
expr_stmt|;
name|mbs_offset2
operator|=
name|REGEX_TALLOC
argument_list|(
name|size2
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|is_binary
operator|=
name|REGEX_TALLOC
argument_list|(
name|size2
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wcs_string2
operator|||
operator|!
name|mbs_offset2
operator|||
operator|!
name|is_binary
condition|)
block|{
name|FREE_WCS_BUFFERS
argument_list|()
expr_stmt|;
if|if
condition|(
name|size2
operator|>
name|MAX_ALLOCA_SIZE
condition|)
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
else|else
name|FREE_VAR
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|wcs_size2
operator|=
name|convert_mbs_to_wcs
argument_list|(
name|wcs_string2
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|mbs_offset2
argument_list|,
name|is_binary
argument_list|)
expr_stmt|;
name|wcs_string2
index|[
name|wcs_size2
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* for a sentinel  */
if|if
condition|(
name|size2
operator|>
name|MAX_ALLOCA_SIZE
condition|)
name|free
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
else|else
name|FREE_VAR
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WCHAR */
comment|/* Loop through the string, looking for a place to start matching.  */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If a fastmap is supplied, skip quickly over characters that          cannot be the start of a match.  If the pattern can match the          null string, however, we don't need to skip characters; we want          the first null string.  */
if|if
condition|(
name|fastmap
operator|&&
name|startpos
operator|<
name|total_size
operator|&&
operator|!
name|bufp
operator|->
name|can_be_null
condition|)
block|{
if|if
condition|(
name|range
operator|>
literal|0
condition|)
comment|/* Searching forwards.  */
block|{
specifier|register
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|lim
init|=
literal|0
decl_stmt|;
name|int
name|irange
init|=
name|range
decl_stmt|;
if|if
condition|(
name|startpos
operator|<
name|size1
operator|&&
name|startpos
operator|+
name|range
operator|>=
name|size1
condition|)
name|lim
operator|=
name|range
operator|-
operator|(
name|size1
operator|-
name|startpos
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|startpos
operator|>=
name|size1
condition|?
name|string2
operator|-
name|size1
else|:
name|string1
operator|)
operator|+
name|startpos
expr_stmt|;
comment|/* Written out as an if-else to avoid testing `translate'                  inside the loop.  */
if|if
condition|(
name|translate
condition|)
while|while
condition|(
name|range
operator|>
name|lim
operator|&&
operator|!
name|fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
name|translate
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|++
index|]
index|]
condition|)
name|range
operator|--
expr_stmt|;
else|else
while|while
condition|(
name|range
operator|>
name|lim
operator|&&
operator|!
name|fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|++
index|]
condition|)
name|range
operator|--
expr_stmt|;
name|startpos
operator|+=
name|irange
operator|-
name|range
expr_stmt|;
block|}
else|else
comment|/* Searching backwards.  */
block|{
specifier|register
name|CHAR_T
name|c
init|=
operator|(
name|size1
operator|==
literal|0
operator|||
name|startpos
operator|>=
name|size1
condition|?
name|string2
index|[
name|startpos
operator|-
name|size1
index|]
else|:
name|string1
index|[
name|startpos
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
name|TRANSLATE
argument_list|(
name|c
argument_list|)
index|]
condition|)
goto|goto
name|advance
goto|;
block|}
block|}
comment|/* If can't match the null string, and that's all we have left, fail.  */
if|if
condition|(
name|range
operator|>=
literal|0
operator|&&
name|startpos
operator|==
name|total_size
operator|&&
name|fastmap
operator|&&
operator|!
name|bufp
operator|->
name|can_be_null
condition|)
block|{
ifdef|#
directive|ifdef
name|WCHAR
name|FREE_WCS_BUFFERS
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|WCHAR
name|val
operator|=
name|wcs_re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|,
name|wcs_string1
argument_list|,
name|wcs_size1
argument_list|,
name|wcs_string2
argument_list|,
name|wcs_size2
argument_list|,
name|mbs_offset1
argument_list|,
name|mbs_offset2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BYTE */
name|val
operator|=
name|byte_re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BYTE */
ifndef|#
directive|ifndef
name|REGEX_MALLOC
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|WCHAR
name|FREE_WCS_BUFFERS
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|startpos
return|;
block|}
if|if
condition|(
name|val
operator|==
operator|-
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|WCHAR
name|FREE_WCS_BUFFERS
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|2
return|;
block|}
name|advance
label|:
if|if
condition|(
operator|!
name|range
condition|)
break|break;
elseif|else
if|if
condition|(
name|range
operator|>
literal|0
condition|)
block|{
name|range
operator|--
expr_stmt|;
name|startpos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|range
operator|++
expr_stmt|;
name|startpos
operator|--
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|WCHAR
name|FREE_WCS_BUFFERS
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_comment
comment|/* This converts PTR, a pointer into one of the search wchar_t strings    `string1' and `string2' into an multibyte string offset from the    beginning of that string. We use mbs_offset to optimize.    See convert_mbs_to_wcs.  */
end_comment

begin_define
define|#
directive|define
name|POINTER_TO_OFFSET
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(FIRST_STRING_P (ptr)							\    ? ((regoff_t)(mbs_offset1 != NULL? mbs_offset1[(ptr)-string1] : 0))	\    : ((regoff_t)((mbs_offset2 != NULL? mbs_offset2[(ptr)-string2] : 0)	\ 		 + csize1)))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_comment
comment|/* This converts PTR, a pointer into one of the search strings `string1'    and `string2' into an offset from the beginning of that string.  */
end_comment

begin_define
define|#
directive|define
name|POINTER_TO_OFFSET
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(FIRST_STRING_P (ptr)				\    ? ((regoff_t) ((ptr) - string1))		\    : ((regoff_t) ((ptr) - string2 + size1)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_comment
comment|/* Macros for dealing with the split strings in re_match_2.  */
end_comment

begin_define
define|#
directive|define
name|MATCHING_IN_FIRST_STRING
value|(dend == end_match_1)
end_define

begin_comment
comment|/* Call before fetching a character with *d.  This switches over to    string2 if necessary.  */
end_comment

begin_define
define|#
directive|define
name|PREFETCH
parameter_list|()
define|\
value|while (d == dend)						    	\     {									\
comment|/* End of string2 => fail.  */
value|\       if (dend == end_match_2) 						\         goto fail;							\
comment|/* End of string1 => advance to string2.  */
value|\       d = string2;						        \       dend = end_match_2;						\     }
end_define

begin_comment
comment|/* Test if at very beginning or at very end of the virtual concatenation    of `string1' and `string2'.  If only one string, it's `string2'.  */
end_comment

begin_define
define|#
directive|define
name|AT_STRINGS_BEG
parameter_list|(
name|d
parameter_list|)
value|((d) == (size1 ? string1 : string2) || !size2)
end_define

begin_define
define|#
directive|define
name|AT_STRINGS_END
parameter_list|(
name|d
parameter_list|)
value|((d) == end2)
end_define

begin_comment
comment|/* Test if D points to a character which is word-constituent.  We have    two special cases to check for: if past the end of string1, look at    the first character in string2; and if before the beginning of    string2, look at the last character in string1.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_comment
comment|/* Use internationalized API instead of SYNTAX.  */
end_comment

begin_define
define|#
directive|define
name|WORDCHAR_P
parameter_list|(
name|d
parameter_list|)
define|\
value|(iswalnum ((wint_t)((d) == end1 ? *string2				\            : (d) == string2 - 1 ? *(end1 - 1) : *(d))) != 0		\    || ((d) == end1 ? *string2						\        : (d) == string2 - 1 ? *(end1 - 1) : *(d)) == L'_')
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|WORDCHAR_P
parameter_list|(
name|d
parameter_list|)
define|\
value|(SYNTAX ((d) == end1 ? *string2					\            : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\    == Sword)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_comment
comment|/* Disabled due to a compiler bug -- see comment at case wordbound */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Test if the character before D and the one at D differ with respect    to being word-constituent.  */
end_comment

begin_define
define|#
directive|define
name|AT_WORD_BOUNDARY
parameter_list|(
name|d
parameter_list|)
define|\
value|(AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\    || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Free everything we malloc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|FREE_VARIABLES
parameter_list|()
define|\
value|do {									\     REGEX_FREE_STACK (fail_stack.stack);				\     FREE_VAR (regstart);						\     FREE_VAR (regend);							\     FREE_VAR (old_regstart);						\     FREE_VAR (old_regend);						\     FREE_VAR (best_regstart);						\     FREE_VAR (best_regend);						\     FREE_VAR (reg_info);						\     FREE_VAR (reg_dummy);						\     FREE_VAR (reg_info_dummy);						\     if (!cant_free_wcs_buf)						\       {									\         FREE_VAR (string1);						\         FREE_VAR (string2);						\         FREE_VAR (mbs_offset1);						\         FREE_VAR (mbs_offset2);						\       }									\   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|FREE_VARIABLES
parameter_list|()
define|\
value|do {									\     REGEX_FREE_STACK (fail_stack.stack);				\     FREE_VAR (regstart);						\     FREE_VAR (regend);							\     FREE_VAR (old_regstart);						\     FREE_VAR (old_regend);						\     FREE_VAR (best_regstart);						\     FREE_VAR (best_regend);						\     FREE_VAR (reg_info);						\     FREE_VAR (reg_dummy);						\     FREE_VAR (reg_info_dummy);						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_define
define|#
directive|define
name|FREE_VARIABLES
parameter_list|()
define|\
value|do {									\     if (!cant_free_wcs_buf)						\       {									\         FREE_VAR (string1);						\         FREE_VAR (string2);						\         FREE_VAR (mbs_offset1);						\         FREE_VAR (mbs_offset2);						\       }									\   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BYTE */
end_comment

begin_define
define|#
directive|define
name|FREE_VARIABLES
parameter_list|()
value|((void)0)
end_define

begin_comment
comment|/* Do nothing!  But inhibit gcc warning. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MATCH_MAY_ALLOCATE */
end_comment

begin_comment
comment|/* These values must meet several constraints.  They must not be valid    register values; since we have a limit of 255 registers (because    we use only one byte in the pattern for the register number), we can    use numbers larger than 255.  They must differ by 1, because of    NUM_FAILURE_ITEMS above.  And the value for the lowest register must    be larger than the value for the highest register, so we do not try    to actually save any registers when none are active.  */
end_comment

begin_define
define|#
directive|define
name|NO_HIGHEST_ACTIVE_REG
value|(1<< BYTEWIDTH)
end_define

begin_define
define|#
directive|define
name|NO_LOWEST_ACTIVE_REG
value|(NO_HIGHEST_ACTIVE_REG + 1)
end_define

begin_escape
end_escape

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_comment
comment|/* Matching routines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* Emacs never uses this.  */
end_comment

begin_comment
comment|/* re_match is like re_match_2 except it takes only a single string.  */
end_comment

begin_function
name|int
name|re_match
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
condition|)
name|result
operator|=
name|wcs_re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|result
operator|=
name|byte_re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REGEX_MALLOC
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_match
argument_list|,
argument|re_match
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INSIDE_RECURSION
end_ifdef

begin_decl_stmt
specifier|static
name|boolean
name|PREFIX
argument_list|(
name|group_match_null_string_p
argument_list|)
argument_list|(
name|UCHAR_T
operator|*
operator|*
name|p
argument_list|,
name|UCHAR_T
operator|*
name|end
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|PREFIX
argument_list|(
name|alt_match_null_string_p
argument_list|)
argument_list|(
name|UCHAR_T
operator|*
name|p
argument_list|,
name|UCHAR_T
operator|*
name|end
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|PREFIX
argument_list|(
name|common_op_match_null_string_p
argument_list|)
argument_list|(
name|UCHAR_T
operator|*
operator|*
name|p
argument_list|,
name|UCHAR_T
operator|*
name|end
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|PREFIX
function_decl|(
name|bcmp_translate
function_decl|)
parameter_list|(
specifier|const
name|CHAR_T
modifier|*
name|s1
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|s2
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|translate
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_comment
comment|/* re_match_2 matches the compiled pattern in BUFP against the    the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1    and SIZE2, respectively).  We start matching at POS, and stop    matching at STOP.     If REGS is non-null and the `no_sub' field of BUFP is nonzero, we    store offsets for the substring each group matched in REGS.  See the    documentation for exactly how many groups we fill.     We return -1 if no match, -2 if an internal error (such as the    failure stack overflowing).  Otherwise, we return the length of the    matched substring.  */
end_comment

begin_function
name|int
name|re_match_2
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
specifier|const
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
condition|)
name|result
operator|=
name|wcs_re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|result
operator|=
name|byte_re_match_2_internal
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REGEX_MALLOC
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_match_2
argument_list|,
argument|re_match_2
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INSIDE_RECURSION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_function_decl
specifier|static
name|int
name|count_mbs_length
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This check the substring (from 0, to length) of the multibyte string,    to which offset_buffer correspond. And count how many wchar_t_characters    the substring occupy. We use offset_buffer to optimization.    See convert_mbs_to_wcs.  */
end_comment

begin_function
specifier|static
name|int
name|count_mbs_length
parameter_list|(
name|int
modifier|*
name|offset_buffer
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|;
comment|/* Check whether the size is valid.  */
if|if
condition|(
name|length
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|offset_buffer
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* If there are no multibyte character, offset_buffer[i] == i.    Optmize for this case.  */
if|if
condition|(
name|offset_buffer
index|[
name|length
index|]
operator|==
name|length
condition|)
return|return
name|length
return|;
comment|/* Set up upper with length. (because for all i, offset_buffer[i]>= i)  */
name|upper
operator|=
name|length
expr_stmt|;
name|lower
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|int
name|middle
init|=
operator|(
name|lower
operator|+
name|upper
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|middle
operator|==
name|lower
operator|||
name|middle
operator|==
name|upper
condition|)
break|break;
if|if
condition|(
name|offset_buffer
index|[
name|middle
index|]
operator|>
name|length
condition|)
name|upper
operator|=
name|middle
expr_stmt|;
elseif|else
if|if
condition|(
name|offset_buffer
index|[
name|middle
index|]
operator|<
name|length
condition|)
name|lower
operator|=
name|middle
expr_stmt|;
else|else
return|return
name|middle
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR */
end_comment

begin_comment
comment|/* This is a separate function so that we can force an alloca cleanup    afterwards.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WCHAR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|wcs_re_match_2_internal
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|bufp
argument_list|,
specifier|const
name|char
operator|*
name|cstring1
argument_list|,
name|int
name|csize1
argument_list|,
specifier|const
name|char
operator|*
name|cstring2
argument_list|,
name|int
name|csize2
argument_list|,
name|int
name|pos
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|int
name|stop
argument_list|,
comment|/* string1 == string2 == NULL means string1/2, size1/2 and 	mbs_offset1/2 need seting up in this function.  */
comment|/* We need wchar_t* buffers correspond to cstring1, cstring2.  */
name|wchar_t
operator|*
name|string1
argument_list|,
name|int
name|size1
argument_list|,
name|wchar_t
operator|*
name|string2
argument_list|,
name|int
name|size2
argument_list|,
comment|/* offset buffer for optimizatoin. See convert_mbs_to_wc.  */
name|int
operator|*
name|mbs_offset1
argument_list|,
name|int
operator|*
name|mbs_offset2
argument_list|)
else|#
directive|else
comment|/* BYTE */
decl|static
name|int
name|byte_re_match_2_internal
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|bufp
argument_list|,
specifier|const
name|char
operator|*
name|string1
argument_list|,
name|int
name|size1
argument_list|,
specifier|const
name|char
operator|*
name|string2
argument_list|,
name|int
name|size2
argument_list|,
name|int
name|pos
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|int
name|stop
argument_list|)
endif|#
directive|endif
comment|/* BYTE */
block|{
comment|/* General temporaries.  */
name|int
name|mcnt
decl_stmt|;
name|UCHAR_T
modifier|*
name|p1
decl_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
comment|/* They hold whether each wchar_t is binary data or not.  */
name|char
modifier|*
name|is_binary
init|=
name|NULL
decl_stmt|;
comment|/* If true, we can't free string1/2, mbs_offset1/2.  */
name|int
name|cant_free_wcs_buf
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
comment|/* Just past the end of the corresponding string.  */
specifier|const
name|CHAR_T
modifier|*
name|end1
decl_stmt|,
modifier|*
name|end2
decl_stmt|;
comment|/* Pointers into string1 and string2, just past the last characters in      each to consider matching.  */
specifier|const
name|CHAR_T
modifier|*
name|end_match_1
decl_stmt|,
modifier|*
name|end_match_2
decl_stmt|;
comment|/* Where we are in the data, and the end of the current string.  */
specifier|const
name|CHAR_T
modifier|*
name|d
decl_stmt|,
modifier|*
name|dend
decl_stmt|;
comment|/* Where we are in the pattern, and the end of the pattern.  */
ifdef|#
directive|ifdef
name|WCHAR
name|UCHAR_T
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|UCHAR_T
modifier|*
name|pend
decl_stmt|;
else|#
directive|else
comment|/* BYTE */
name|UCHAR_T
modifier|*
name|p
init|=
name|bufp
operator|->
name|buffer
decl_stmt|;
specifier|register
name|UCHAR_T
modifier|*
name|pend
init|=
name|p
operator|+
name|bufp
operator|->
name|used
decl_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
comment|/* Mark the opcode just after a start_memory, so we can test for an      empty subpattern when we get to the stop_memory.  */
name|UCHAR_T
modifier|*
name|just_past_start_mem
init|=
literal|0
decl_stmt|;
comment|/* We use this to map every character in the string.  */
name|RE_TRANSLATE_TYPE
name|translate
init|=
name|bufp
operator|->
name|translate
decl_stmt|;
comment|/* Failure point stack.  Each place that can handle a failure further      down the line pushes a failure point on this stack.  It consists of      restart, regend, and reg_info for all registers corresponding to      the subexpressions we're currently inside, plus the number of such      registers, and, finally, two char *'s.  The first char * is where      to resume scanning the pattern; the second one is where to resume      scanning the strings.  If the latter is zero, the failure point is      a ``dummy''; if a failure happens and the failure point is a dummy,      it gets discarded and the next next one is tried.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, this is global.  */
name|PREFIX
argument_list|(
argument|fail_stack_type
argument_list|)
name|fail_stack
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|unsigned
name|failure_id
decl_stmt|;
name|unsigned
name|nfailure_points_pushed
init|=
literal|0
decl_stmt|,
name|nfailure_points_popped
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REL_ALLOC
comment|/* This holds the pointer to the failure stack, when      it is allocated relocatably.  */
name|fail_stack_elt_t
modifier|*
name|failure_stack_ptr
decl_stmt|;
endif|#
directive|endif
comment|/* We fill all the registers internally, independent of what we      return, for use in backreferences.  The number here includes      an element for register zero.  */
name|size_t
name|num_regs
init|=
name|bufp
operator|->
name|re_nsub
operator|+
literal|1
decl_stmt|;
comment|/* The currently active registers.  */
name|active_reg_t
name|lowest_active_reg
init|=
name|NO_LOWEST_ACTIVE_REG
decl_stmt|;
name|active_reg_t
name|highest_active_reg
init|=
name|NO_HIGHEST_ACTIVE_REG
decl_stmt|;
comment|/* Information on the contents of registers. These are pointers into      the input strings; they record just what was matched (on this      attempt) by a subexpression part of the pattern, that is, the      regnum-th regstart pointer points to where in the pattern we began      matching and the regnum-th regend points to right after where we      stopped matching the regnum-th subexpression.  (The zeroth register      keeps track of what the whole pattern matches.)  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|CHAR_T
modifier|*
modifier|*
name|regstart
decl_stmt|,
modifier|*
modifier|*
name|regend
decl_stmt|;
endif|#
directive|endif
comment|/* If a group that's operated upon by a repetition operator fails to      match anything, then the register for its start will need to be      restored because it will have been set to wherever in the string we      are when we last see its open-group operator.  Similarly for a      register's end.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|CHAR_T
modifier|*
modifier|*
name|old_regstart
decl_stmt|,
modifier|*
modifier|*
name|old_regend
decl_stmt|;
endif|#
directive|endif
comment|/* The is_active field of reg_info helps us keep track of which (possibly      nested) subexpressions we are currently in. The matched_something      field of reg_info[reg_num] helps us tell whether or not we have      matched any of the pattern so far this time through the reg_num-th      subexpression.  These two fields get reset each time through any      loop their register is in.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, this is global.  */
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info
expr_stmt|;
endif|#
directive|endif
comment|/* The following record the register info as found in the above      variables when we find a match better than any we've seen before.      This happens as we backtrack through the failure points, which in      turn happens only if we have not yet matched the entire string. */
name|unsigned
name|best_regs_set
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|CHAR_T
modifier|*
modifier|*
name|best_regstart
decl_stmt|,
modifier|*
modifier|*
name|best_regend
decl_stmt|;
endif|#
directive|endif
comment|/* Logically, this is `best_regend[0]'.  But we don't want to have to      allocate space for that if we're not allocating space for anything      else (see below).  Also, we never need info about register 0 for      any of the other register vectors, and it seems rather a kludge to      treat `best_regend' differently than the rest.  So we keep track of      the end of the best match so far in a separate variable.  We      initialize this to NULL so that when we backtrack the first time      and need to test it, it's not garbage.  */
specifier|const
name|CHAR_T
modifier|*
name|match_end
init|=
name|NULL
decl_stmt|;
comment|/* This helps SET_REGS_MATCHED avoid doing redundant work.  */
name|int
name|set_regs_matched_done
init|=
literal|0
decl_stmt|;
comment|/* Used when we pop values we don't care about.  */
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* otherwise, these are global.  */
specifier|const
name|CHAR_T
modifier|*
modifier|*
name|reg_dummy
decl_stmt|;
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info_dummy
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Counts the total number of registers pushed.  */
name|unsigned
name|num_regs_pushed
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|DEBUG_PRINT1
argument_list|(
literal|"\n\nEntering re_match_2.\n"
argument_list|)
expr_stmt|;
name|INIT_FAIL_STACK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MATCH_MAY_ALLOCATE
comment|/* Do not bother to initialize all the register variables if there are      no groups in the pattern, as it takes a fair amount of time.  If      there are groups, we include space for register 0 (the whole      pattern), even though we never use it, since it simplifies the      array indexing.  We should fix this.  */
if|if
condition|(
name|bufp
operator|->
name|re_nsub
condition|)
block|{
name|regstart
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|CHAR_T
operator|*
argument_list|)
expr_stmt|;
name|regend
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|CHAR_T
operator|*
argument_list|)
expr_stmt|;
name|old_regstart
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|CHAR_T
operator|*
argument_list|)
expr_stmt|;
name|old_regend
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|CHAR_T
operator|*
argument_list|)
expr_stmt|;
name|best_regstart
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|CHAR_T
operator|*
argument_list|)
expr_stmt|;
name|best_regend
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|CHAR_T
operator|*
argument_list|)
expr_stmt|;
name|reg_info
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
argument_list|)
expr_stmt|;
name|reg_dummy
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
specifier|const
name|CHAR_T
operator|*
argument_list|)
expr_stmt|;
name|reg_info_dummy
operator|=
name|REGEX_TALLOC
argument_list|(
name|num_regs
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|regstart
operator|&&
name|regend
operator|&&
name|old_regstart
operator|&&
name|old_regend
operator|&&
name|reg_info
operator|&&
name|best_regstart
operator|&&
name|best_regend
operator|&&
name|reg_dummy
operator|&&
name|reg_info_dummy
operator|)
condition|)
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
else|else
block|{
comment|/* We must initialize all our variables to NULL, so that          `FREE_VARIABLES' doesn't try to free them.  */
name|regstart
operator|=
name|regend
operator|=
name|old_regstart
operator|=
name|old_regend
operator|=
name|best_regstart
operator|=
name|best_regend
operator|=
name|reg_dummy
operator|=
name|NULL
expr_stmt|;
name|reg_info
operator|=
name|reg_info_dummy
operator|=
operator|(
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MATCH_MAY_ALLOCATE */
comment|/* The starting position is bogus.  */
ifdef|#
directive|ifdef
name|WCHAR
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>
name|csize1
operator|+
name|csize2
condition|)
else|#
directive|else
comment|/* BYTE */
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>
name|size1
operator|+
name|size2
condition|)
endif|#
directive|endif
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|WCHAR
comment|/* Allocate wchar_t array for string1 and string2 and      fill them with converted string.  */
if|if
condition|(
name|string1
operator|==
name|NULL
operator|&&
name|string2
operator|==
name|NULL
condition|)
block|{
comment|/* We need seting up buffers here.  */
comment|/* We must free wcs buffers in this function.  */
name|cant_free_wcs_buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csize1
operator|!=
literal|0
condition|)
block|{
name|string1
operator|=
name|REGEX_TALLOC
argument_list|(
name|csize1
operator|+
literal|1
argument_list|,
name|CHAR_T
argument_list|)
expr_stmt|;
name|mbs_offset1
operator|=
name|REGEX_TALLOC
argument_list|(
name|csize1
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|is_binary
operator|=
name|REGEX_TALLOC
argument_list|(
name|csize1
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|string1
operator|||
operator|!
name|mbs_offset1
operator|||
operator|!
name|is_binary
condition|)
block|{
name|FREE_VAR
argument_list|(
name|string1
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|mbs_offset1
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
if|if
condition|(
name|csize2
operator|!=
literal|0
condition|)
block|{
name|string2
operator|=
name|REGEX_TALLOC
argument_list|(
name|csize2
operator|+
literal|1
argument_list|,
name|CHAR_T
argument_list|)
expr_stmt|;
name|mbs_offset2
operator|=
name|REGEX_TALLOC
argument_list|(
name|csize2
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|is_binary
operator|=
name|REGEX_TALLOC
argument_list|(
name|csize2
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|string2
operator|||
operator|!
name|mbs_offset2
operator|||
operator|!
name|is_binary
condition|)
block|{
name|FREE_VAR
argument_list|(
name|string1
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|mbs_offset1
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|string2
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|mbs_offset2
argument_list|)
expr_stmt|;
name|FREE_VAR
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|size2
operator|=
name|convert_mbs_to_wcs
argument_list|(
name|string2
argument_list|,
name|cstring2
argument_list|,
name|csize2
argument_list|,
name|mbs_offset2
argument_list|,
name|is_binary
argument_list|)
expr_stmt|;
name|string2
index|[
name|size2
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* for a sentinel  */
name|FREE_VAR
argument_list|(
name|is_binary
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We need to cast pattern to (wchar_t*), because we casted this compiled      pattern to (char*) in regex_compile.  */
name|p
operator|=
name|pattern
operator|=
operator|(
name|CHAR_T
operator|*
operator|)
name|bufp
operator|->
name|buffer
expr_stmt|;
name|pend
operator|=
operator|(
name|CHAR_T
operator|*
operator|)
operator|(
name|bufp
operator|->
name|buffer
operator|+
name|bufp
operator|->
name|used
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
comment|/* Initialize subexpression text positions to -1 to mark ones that no      start_memory/stop_memory has been seen for. Also initialize the      register information struct.  */
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|num_regs
condition|;
name|mcnt
operator|++
control|)
block|{
name|regstart
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
operator|=
name|old_regstart
index|[
name|mcnt
index|]
operator|=
name|old_regend
index|[
name|mcnt
index|]
operator|=
name|REG_UNSET_VALUE
expr_stmt|;
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
name|MATCH_NULL_UNSET_VALUE
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|EVER_MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We move `string1' into `string2' if the latter's empty -- but not if      `string1' is null.  */
if|if
condition|(
name|size2
operator|==
literal|0
operator|&&
name|string1
operator|!=
name|NULL
condition|)
block|{
name|string2
operator|=
name|string1
expr_stmt|;
name|size2
operator|=
name|size1
expr_stmt|;
name|string1
operator|=
literal|0
expr_stmt|;
name|size1
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
name|mbs_offset2
operator|=
name|mbs_offset1
expr_stmt|;
name|csize2
operator|=
name|csize1
expr_stmt|;
name|mbs_offset1
operator|=
name|NULL
expr_stmt|;
name|csize1
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|end1
operator|=
name|string1
operator|+
name|size1
expr_stmt|;
name|end2
operator|=
name|string2
operator|+
name|size2
expr_stmt|;
comment|/* Compute where to stop matching, within the two strings.  */
ifdef|#
directive|ifdef
name|WCHAR
if|if
condition|(
name|stop
operator|<=
name|csize1
condition|)
block|{
name|mcnt
operator|=
name|count_mbs_length
argument_list|(
name|mbs_offset1
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|end_match_1
operator|=
name|string1
operator|+
name|mcnt
expr_stmt|;
name|end_match_2
operator|=
name|string2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stop
operator|>
name|csize1
operator|+
name|csize2
condition|)
name|stop
operator|=
name|csize1
operator|+
name|csize2
expr_stmt|;
name|end_match_1
operator|=
name|end1
expr_stmt|;
name|mcnt
operator|=
name|count_mbs_length
argument_list|(
name|mbs_offset2
argument_list|,
name|stop
operator|-
name|csize1
argument_list|)
expr_stmt|;
name|end_match_2
operator|=
name|string2
operator|+
name|mcnt
expr_stmt|;
block|}
if|if
condition|(
name|mcnt
operator|<
literal|0
condition|)
block|{
comment|/* count_mbs_length return error.  */
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
if|if
condition|(
name|stop
operator|<=
name|size1
condition|)
block|{
name|end_match_1
operator|=
name|string1
operator|+
name|stop
expr_stmt|;
name|end_match_2
operator|=
name|string2
expr_stmt|;
block|}
else|else
block|{
name|end_match_1
operator|=
name|end1
expr_stmt|;
name|end_match_2
operator|=
name|string2
operator|+
name|stop
operator|-
name|size1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WCHAR */
comment|/* `p' scans through the pattern as `d' scans through the data.      `dend' is the end of the input string that `d' points within.  `d'      is advanced into the following input string whenever necessary, but      this happens before fetching; therefore, at the beginning of the      loop, `d' can be pointing at the end of a string, but it cannot      equal `string2'.  */
ifdef|#
directive|ifdef
name|WCHAR
if|if
condition|(
name|size1
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|csize1
condition|)
block|{
name|mcnt
operator|=
name|count_mbs_length
argument_list|(
name|mbs_offset1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|d
operator|=
name|string1
operator|+
name|mcnt
expr_stmt|;
name|dend
operator|=
name|end_match_1
expr_stmt|;
block|}
else|else
block|{
name|mcnt
operator|=
name|count_mbs_length
argument_list|(
name|mbs_offset2
argument_list|,
name|pos
operator|-
name|csize1
argument_list|)
expr_stmt|;
name|d
operator|=
name|string2
operator|+
name|mcnt
expr_stmt|;
name|dend
operator|=
name|end_match_2
expr_stmt|;
block|}
if|if
condition|(
name|mcnt
operator|<
literal|0
condition|)
block|{
comment|/* count_mbs_length return error.  */
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
if|if
condition|(
name|size1
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|size1
condition|)
block|{
name|d
operator|=
name|string1
operator|+
name|pos
expr_stmt|;
name|dend
operator|=
name|end_match_1
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|string2
operator|+
name|pos
operator|-
name|size1
expr_stmt|;
name|dend
operator|=
name|end_match_2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WCHAR */
name|DEBUG_PRINT1
argument_list|(
literal|"The compiled pattern is:\n"
argument_list|)
expr_stmt|;
name|DEBUG_PRINT_COMPILED_PATTERN
argument_list|(
name|bufp
argument_list|,
name|p
argument_list|,
name|pend
argument_list|)
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"The string to match is: `"
argument_list|)
expr_stmt|;
name|DEBUG_PRINT_DOUBLE_STRING
argument_list|(
name|d
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|)
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
comment|/* This loops over pattern commands.  It exits by returning from the      function if the match is complete, or it drops through if the match      fails at this starting point in the input data.  */
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"\n%p: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"\n0x%x: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
comment|/* End of pattern means we might have succeeded.  */
name|DEBUG_PRINT1
argument_list|(
literal|"end of pattern ... "
argument_list|)
expr_stmt|;
comment|/* If we haven't matched the entire string, and we want the              longest match, try backtracking.  */
if|if
condition|(
name|d
operator|!=
name|end_match_2
condition|)
block|{
comment|/* 1 if this match ends in the same string (string1 or string2) 		 as the best previous match.  */
name|boolean
name|same_str_p
init|=
operator|(
name|FIRST_STRING_P
argument_list|(
name|match_end
argument_list|)
operator|==
name|MATCHING_IN_FIRST_STRING
operator|)
decl_stmt|;
comment|/* 1 if this match is the best seen so far.  */
name|boolean
name|best_match_p
decl_stmt|;
comment|/* AIX compiler got confused when this was combined 		 with the previous declaration.  */
if|if
condition|(
name|same_str_p
condition|)
name|best_match_p
operator|=
name|d
operator|>
name|match_end
expr_stmt|;
else|else
name|best_match_p
operator|=
operator|!
name|MATCHING_IN_FIRST_STRING
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"backtracking.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
condition|)
block|{
comment|/* More failure points to try.  */
comment|/* If exceeds best match so far, save it.  */
if|if
condition|(
operator|!
name|best_regs_set
operator|||
name|best_match_p
condition|)
block|{
name|best_regs_set
operator|=
name|true
expr_stmt|;
name|match_end
operator|=
name|d
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"\nSAVING match as best so far.\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|num_regs
condition|;
name|mcnt
operator|++
control|)
block|{
name|best_regstart
index|[
name|mcnt
index|]
operator|=
name|regstart
index|[
name|mcnt
index|]
expr_stmt|;
name|best_regend
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
expr_stmt|;
block|}
block|}
goto|goto
name|fail
goto|;
block|}
comment|/* If no failure points, don't restore garbage.  And if                  last match is real best match, don't restore second                  best one. */
elseif|else
if|if
condition|(
name|best_regs_set
operator|&&
operator|!
name|best_match_p
condition|)
block|{
name|restore_best_regs
label|:
comment|/* Restore best match.  It may happen that `dend ==                      end_match_1' while the restored d is in string2.                      For example, the pattern `x.*y.*z' against the                      strings `x-' and `y-z-', if the two strings are                      not consecutive in memory.  */
name|DEBUG_PRINT1
argument_list|(
literal|"Restoring best registers.\n"
argument_list|)
expr_stmt|;
name|d
operator|=
name|match_end
expr_stmt|;
name|dend
operator|=
operator|(
operator|(
name|d
operator|>=
name|string1
operator|&&
name|d
operator|<=
name|end1
operator|)
condition|?
name|end_match_1
else|:
name|end_match_2
operator|)
expr_stmt|;
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|num_regs
condition|;
name|mcnt
operator|++
control|)
block|{
name|regstart
index|[
name|mcnt
index|]
operator|=
name|best_regstart
index|[
name|mcnt
index|]
expr_stmt|;
name|regend
index|[
name|mcnt
index|]
operator|=
name|best_regend
index|[
name|mcnt
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* d != end_match_2 */
name|succeed_label
label|:
name|DEBUG_PRINT1
argument_list|(
literal|"Accepting match.\n"
argument_list|)
expr_stmt|;
comment|/* If caller wants register contents data back, do it.  */
if|if
condition|(
name|regs
operator|&&
operator|!
name|bufp
operator|->
name|no_sub
condition|)
block|{
comment|/* Have the register data arrays been allocated?  */
if|if
condition|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_UNALLOCATED
condition|)
block|{
comment|/* No.  So allocate them with malloc.  We need one                      extra element beyond `num_regs' for the `-1' marker                      GNU code uses.  */
name|regs
operator|->
name|num_regs
operator|=
name|MAX
argument_list|(
name|RE_NREGS
argument_list|,
name|num_regs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|TALLOC
argument_list|(
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|TALLOC
argument_list|(
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|start
operator|==
name|NULL
operator|||
name|regs
operator|->
name|end
operator|==
name|NULL
condition|)
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_REALLOCATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_REALLOCATE
condition|)
block|{
comment|/* Yes.  If we need more elements than were already                      allocated, reallocate them.  If we need fewer, just                      leave it alone.  */
if|if
condition|(
name|regs
operator|->
name|num_regs
operator|<
name|num_regs
operator|+
literal|1
condition|)
block|{
name|regs
operator|->
name|num_regs
operator|=
name|num_regs
operator|+
literal|1
expr_stmt|;
name|RETALLOC
argument_list|(
name|regs
operator|->
name|start
argument_list|,
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
name|RETALLOC
argument_list|(
name|regs
operator|->
name|end
argument_list|,
name|regs
operator|->
name|num_regs
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|start
operator|==
name|NULL
operator|||
name|regs
operator|->
name|end
operator|==
name|NULL
condition|)
block|{
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* These braces fend off a "empty body in an else-statement" 		     warning under GCC when assert expands to nothing.  */
name|assert
argument_list|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_FIXED
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the pointer data in `regstart' and `regend' to                  indices.  Register zero has to be set differently,                  since we haven't kept track of any info for it.  */
if|if
condition|(
name|regs
operator|->
name|num_regs
operator|>
literal|0
condition|)
block|{
name|regs
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|pos
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
if|if
condition|(
name|MATCHING_IN_FIRST_STRING
condition|)
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
name|mbs_offset1
operator|!=
name|NULL
condition|?
name|mbs_offset1
index|[
name|d
operator|-
name|string1
index|]
else|:
literal|0
expr_stmt|;
else|else
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
name|csize1
operator|+
operator|(
name|mbs_offset2
operator|!=
name|NULL
condition|?
name|mbs_offset2
index|[
name|d
operator|-
name|string2
index|]
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
operator|(
name|MATCHING_IN_FIRST_STRING
condition|?
operator|(
call|(
name|regoff_t
call|)
argument_list|(
name|d
operator|-
name|string1
argument_list|)
operator|)
else|:
operator|(
call|(
name|regoff_t
call|)
argument_list|(
name|d
operator|-
name|string2
operator|+
name|size1
argument_list|)
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
block|}
comment|/* Go through the first `min (num_regs, regs->num_regs)'                  registers, since that is all we initialized.  */
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|MIN
argument_list|(
name|num_regs
argument_list|,
name|regs
operator|->
name|num_regs
argument_list|)
condition|;
name|mcnt
operator|++
control|)
block|{
if|if
condition|(
name|REG_UNSET
argument_list|(
name|regstart
index|[
name|mcnt
index|]
argument_list|)
operator|||
name|REG_UNSET
argument_list|(
name|regend
index|[
name|mcnt
index|]
argument_list|)
condition|)
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
operator|(
name|regoff_t
operator|)
name|POINTER_TO_OFFSET
argument_list|(
name|regstart
index|[
name|mcnt
index|]
argument_list|)
expr_stmt|;
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|(
name|regoff_t
operator|)
name|POINTER_TO_OFFSET
argument_list|(
name|regend
index|[
name|mcnt
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the regs structure we return has more elements than                  were in the pattern, set the extra elements to -1.  If                  we (re)allocated the registers, this is the case,                  because we always allocate enough to have at least one                  -1 at the end.  */
for|for
control|(
name|mcnt
operator|=
name|num_regs
init|;
operator|(
name|unsigned
operator|)
name|mcnt
operator|<
name|regs
operator|->
name|num_regs
condition|;
name|mcnt
operator|++
control|)
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* regs&& !bufp->no_sub */
name|DEBUG_PRINT4
argument_list|(
literal|"%u failure points pushed, %u popped (%u remain).\n"
argument_list|,
name|nfailure_points_pushed
argument_list|,
name|nfailure_points_popped
argument_list|,
name|nfailure_points_pushed
operator|-
name|nfailure_points_popped
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"%u registers pushed.\n"
argument_list|,
name|num_regs_pushed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
if|if
condition|(
name|MATCHING_IN_FIRST_STRING
condition|)
name|mcnt
operator|=
name|mbs_offset1
operator|!=
name|NULL
condition|?
name|mbs_offset1
index|[
name|d
operator|-
name|string1
index|]
else|:
literal|0
expr_stmt|;
else|else
name|mcnt
operator|=
operator|(
name|mbs_offset2
operator|!=
name|NULL
condition|?
name|mbs_offset2
index|[
name|d
operator|-
name|string2
index|]
else|:
literal|0
operator|)
operator|+
name|csize1
expr_stmt|;
name|mcnt
operator|-=
name|pos
expr_stmt|;
else|#
directive|else
name|mcnt
operator|=
name|d
operator|-
name|pos
operator|-
operator|(
name|MATCHING_IN_FIRST_STRING
condition|?
name|string1
else|:
name|string2
operator|-
name|size1
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
name|DEBUG_PRINT2
argument_list|(
literal|"Returning %d from re_match_2.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
name|mcnt
return|;
block|}
comment|/* Otherwise match next pattern command.  */
switch|switch
condition|(
name|SWITCH_ENUM_CAST
argument_list|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
comment|/* Ignore these.  Used to ignore the n of succeed_n's which            currently have n == 0.  */
case|case
name|no_op
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING no_op.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|succeed
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING succeed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|succeed_label
goto|;
comment|/* Match the next n pattern characters exactly.  The following            byte in the pattern defines n, and the n bytes after that            are the characters to match.  */
case|case
name|exactn
case|:
ifdef|#
directive|ifdef
name|MBS_SUPPORT
case|case
name|exactn_bin
case|:
endif|#
directive|endif
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING exactn %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
comment|/* This is written out as an if-else so we don't waste time              testing `translate' inside the loop.  */
if|if
condition|(
name|translate
condition|)
block|{
do|do
block|{
name|PREFETCH
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
if|if
condition|(
operator|*
name|d
operator|<=
literal|0xff
condition|)
block|{
if|if
condition|(
operator|(
name|UCHAR_T
operator|)
name|translate
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|++
index|]
operator|!=
operator|(
name|UCHAR_T
operator|)
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|d
operator|++
operator|!=
operator|(
name|CHAR_T
operator|)
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|UCHAR_T
operator|)
name|translate
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|++
index|]
operator|!=
operator|(
name|UCHAR_T
operator|)
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
comment|/* WCHAR */
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|++
operator|!=
operator|(
name|CHAR_T
operator|)
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
break|break;
comment|/* Match any character except possibly a newline or a null.  */
case|case
name|anychar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING anychar.\n"
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
operator|&&
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_DOT_NOT_NULL
operator|&&
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
literal|'\000'
operator|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"  Matched `%ld'.\n"
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
case|case
name|charset
case|:
case|case
name|charset_not
case|:
block|{
specifier|register
name|UCHAR_T
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
name|unsigned
name|int
name|i
decl_stmt|,
name|char_class_length
decl_stmt|,
name|coll_symbol_length
decl_stmt|,
name|equiv_class_length
decl_stmt|,
name|ranges_length
decl_stmt|,
name|chars_length
decl_stmt|,
name|length
decl_stmt|;
name|CHAR_T
modifier|*
name|workp
decl_stmt|,
modifier|*
name|workp2
decl_stmt|,
modifier|*
name|charset_top
decl_stmt|;
define|#
directive|define
name|WORK_BUFFER_SIZE
value|128
name|CHAR_T
name|str_buf
index|[
name|WORK_BUFFER_SIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|uint32_t
name|nrules
decl_stmt|;
endif|#
directive|endif
comment|/* _LIBC */
endif|#
directive|endif
comment|/* WCHAR */
name|boolean
name|negate
init|=
operator|(
name|re_opcode_t
operator|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
name|charset_not
decl_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING charset%s.\n"
argument_list|,
name|negate
condition|?
literal|"_not"
else|:
literal|""
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
name|c
operator|=
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
comment|/* The character to match.  */
ifdef|#
directive|ifdef
name|WCHAR
ifdef|#
directive|ifdef
name|_LIBC
name|nrules
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _LIBC */
name|charset_top
operator|=
name|p
operator|-
literal|1
expr_stmt|;
name|char_class_length
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|coll_symbol_length
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|equiv_class_length
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|ranges_length
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|chars_length
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* p points charset[6], so the address of the next instruction 	       (charset[l+m+n+2o+k+p']) equals p[l+m+n+2*o+p'], 	       where l=length of char_classes, m=length of collating_symbol, 	       n=equivalence_class, o=length of char_range, 	       p'=length of character.  */
name|workp
operator|=
name|p
expr_stmt|;
comment|/* Update p to indicate the next instruction.  */
name|p
operator|+=
name|char_class_length
operator|+
name|coll_symbol_length
operator|+
name|equiv_class_length
operator|+
literal|2
operator|*
name|ranges_length
operator|+
name|chars_length
expr_stmt|;
comment|/* match with char_class?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|char_class_length
condition|;
name|i
operator|+=
name|CHAR_CLASS_SIZE
control|)
block|{
name|wctype_t
name|wctype
decl_stmt|;
name|uintptr_t
name|alignedp
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|workp
operator|+
name|__alignof__
argument_list|(
name|wctype_t
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
call|(
name|uintptr_t
call|)
argument_list|(
name|__alignof__
argument_list|(
name|wctype_t
argument_list|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|wctype
operator|=
operator|*
operator|(
operator|(
name|wctype_t
operator|*
operator|)
name|alignedp
operator|)
expr_stmt|;
name|workp
operator|+=
name|CHAR_CLASS_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|__iswctype
argument_list|(
operator|(
name|wint_t
operator|)
name|c
argument_list|,
name|wctype
argument_list|)
condition|)
goto|goto
name|char_set_matched
goto|;
else|#
directive|else
if|if
condition|(
name|iswctype
argument_list|(
operator|(
name|wint_t
operator|)
name|c
argument_list|,
name|wctype
argument_list|)
condition|)
goto|goto
name|char_set_matched
goto|;
endif|#
directive|endif
block|}
comment|/* match with collating_symbol?  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|extra
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
decl_stmt|;
for|for
control|(
name|workp2
operator|=
name|workp
operator|+
name|coll_symbol_length
init|;
name|workp
operator|<
name|workp2
condition|;
name|workp
operator|++
control|)
block|{
name|int32_t
modifier|*
name|wextra
decl_stmt|;
name|wextra
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|extra
operator|+
operator|*
name|workp
operator|++
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|wextra
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TRANSLATE
argument_list|(
name|d
index|[
name|i
index|]
argument_list|)
operator|!=
name|wextra
index|[
literal|1
operator|+
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|*
name|wextra
condition|)
block|{
comment|/* Update d, however d will be incremented at 			   char_set_matched:, we decrement d here.  */
name|d
operator|+=
name|i
operator|-
literal|1
expr_stmt|;
goto|goto
name|char_set_matched
goto|;
block|}
block|}
block|}
else|else
comment|/* (nrules == 0) */
endif|#
directive|endif
comment|/* If we can't look up collation data, we use wcscoll 		 instead.  */
block|{
for|for
control|(
name|workp2
operator|=
name|workp
operator|+
name|coll_symbol_length
init|;
name|workp
operator|<
name|workp2
condition|;
control|)
block|{
specifier|const
name|CHAR_T
modifier|*
name|backup_d
init|=
name|d
decl_stmt|,
modifier|*
name|backup_dend
init|=
name|dend
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|length
operator|=
name|__wcslen
argument_list|(
name|workp
argument_list|)
expr_stmt|;
else|#
directive|else
name|length
operator|=
name|wcslen
argument_list|(
name|workp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If wcscoll(the collating symbol, whole string)> 0, 		       any substring of the string never match with the 		       collating symbol.  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|__wcscoll
argument_list|(
name|workp
argument_list|,
name|d
argument_list|)
operator|>
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|wcscoll
argument_list|(
name|workp
argument_list|,
name|d
argument_list|)
operator|>
literal|0
condition|)
endif|#
directive|endif
block|{
name|workp
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* First, we compare the collating symbol with 		       the first character of the string. 		       If it don't match, we add the next character to 		       the compare buffer in turn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WORK_BUFFER_SIZE
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|int
name|match
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|dend
condition|)
block|{
if|if
condition|(
name|dend
operator|==
name|end_match_2
condition|)
break|break;
name|d
operator|=
name|string2
expr_stmt|;
name|dend
operator|=
name|end_match_2
expr_stmt|;
block|}
comment|/* add next character to the compare buffer.  */
name|str_buf
index|[
name|i
index|]
operator|=
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|str_buf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|match
operator|=
name|__wcscoll
argument_list|(
name|workp
argument_list|,
name|str_buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|match
operator|=
name|wcscoll
argument_list|(
name|workp
argument_list|,
name|str_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|match
operator|==
literal|0
condition|)
goto|goto
name|char_set_matched
goto|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
comment|/* (str_buf> workp) indicate (str_buf + X> workp), 			     because for all X (str_buf + X> str_buf). 			     So we don't need continue this loop.  */
break|break;
comment|/* Otherwise(str_buf< workp), 			   (str_buf+next_character) may equals (workp). 			   So we continue this loop.  */
block|}
comment|/* not matched */
name|d
operator|=
name|backup_d
expr_stmt|;
name|dend
operator|=
name|backup_dend
expr_stmt|;
name|workp
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* match with equivalence_class?  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
specifier|const
name|CHAR_T
modifier|*
name|backup_d
init|=
name|d
decl_stmt|,
modifier|*
name|backup_dend
init|=
name|dend
decl_stmt|;
comment|/* Try to match the equivalence class against 		   those known to the collate implementation.  */
specifier|const
name|int32_t
modifier|*
name|table
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|weights
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|extra
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|indirect
decl_stmt|;
name|int32_t
name|idx
decl_stmt|,
name|idx2
decl_stmt|;
name|wint_t
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* This #include defines a local function!  */
include|#
directive|include
file|<locale/weightwc.h>
name|table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEWC
argument_list|)
expr_stmt|;
name|weights
operator|=
operator|(
specifier|const
name|wint_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_WEIGHTWC
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|wint_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_EXTRAWC
argument_list|)
expr_stmt|;
name|indirect
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_INDIRECTWC
argument_list|)
expr_stmt|;
comment|/* Write 1 collating element to str_buf, and 		   get its index.  */
name|idx2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|idx2
operator|==
literal|0
operator|&&
name|i
operator|<
name|WORK_BUFFER_SIZE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
operator|(
name|wint_t
operator|*
operator|)
name|str_buf
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|dend
condition|)
block|{
if|if
condition|(
name|dend
operator|==
name|end_match_2
condition|)
break|break;
name|d
operator|=
name|string2
expr_stmt|;
name|dend
operator|=
name|end_match_2
expr_stmt|;
block|}
name|str_buf
index|[
name|i
index|]
operator|=
name|TRANSLATE
argument_list|(
operator|*
operator|(
name|d
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|str_buf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* sentinel */
name|idx2
operator|=
name|findidx
argument_list|(
operator|(
specifier|const
name|wint_t
operator|*
operator|*
operator|)
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* Update d, however d will be incremented at 		   char_set_matched:, we decrement d here.  */
name|d
operator|=
name|backup_d
operator|+
operator|(
operator|(
name|wchar_t
operator|*
operator|)
name|cp
operator|-
operator|(
name|wchar_t
operator|*
operator|)
name|str_buf
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|dend
condition|)
block|{
if|if
condition|(
name|dend
operator|==
name|end_match_2
condition|)
name|d
operator|=
name|dend
expr_stmt|;
else|else
block|{
name|d
operator|=
name|string2
expr_stmt|;
name|dend
operator|=
name|end_match_2
expr_stmt|;
block|}
block|}
name|len
operator|=
name|weights
index|[
name|idx2
index|]
expr_stmt|;
for|for
control|(
name|workp2
operator|=
name|workp
operator|+
name|equiv_class_length
init|;
name|workp
operator|<
name|workp2
condition|;
name|workp
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|int32_t
operator|)
operator|*
name|workp
expr_stmt|;
comment|/* We already checked idx != 0 in regex_compile. */
if|if
condition|(
name|idx2
operator|!=
literal|0
operator|&&
name|len
operator|==
name|weights
index|[
name|idx
index|]
condition|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cnt
operator|<
name|len
operator|&&
operator|(
name|weights
index|[
name|idx
operator|+
literal|1
operator|+
name|cnt
index|]
operator|==
name|weights
index|[
name|idx2
operator|+
literal|1
operator|+
name|cnt
index|]
operator|)
condition|)
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|len
condition|)
goto|goto
name|char_set_matched
goto|;
block|}
block|}
comment|/* not matched */
name|d
operator|=
name|backup_d
expr_stmt|;
name|dend
operator|=
name|backup_dend
expr_stmt|;
block|}
else|else
comment|/* (nrules == 0) */
endif|#
directive|endif
comment|/* If we can't look up collation data, we use wcscoll 		 instead.  */
block|{
for|for
control|(
name|workp2
operator|=
name|workp
operator|+
name|equiv_class_length
init|;
name|workp
operator|<
name|workp2
condition|;
control|)
block|{
specifier|const
name|CHAR_T
modifier|*
name|backup_d
init|=
name|d
decl_stmt|,
modifier|*
name|backup_dend
init|=
name|dend
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|length
operator|=
name|__wcslen
argument_list|(
name|workp
argument_list|)
expr_stmt|;
else|#
directive|else
name|length
operator|=
name|wcslen
argument_list|(
name|workp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If wcscoll(the collating symbol, whole string)> 0, 		       any substring of the string never match with the 		       collating symbol.  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|__wcscoll
argument_list|(
name|workp
argument_list|,
name|d
argument_list|)
operator|>
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|wcscoll
argument_list|(
name|workp
argument_list|,
name|d
argument_list|)
operator|>
literal|0
condition|)
endif|#
directive|endif
block|{
name|workp
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/* First, we compare the equivalence class with 		       the first character of the string. 		       If it don't match, we add the next character to 		       the compare buffer in turn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WORK_BUFFER_SIZE
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|int
name|match
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|dend
condition|)
block|{
if|if
condition|(
name|dend
operator|==
name|end_match_2
condition|)
break|break;
name|d
operator|=
name|string2
expr_stmt|;
name|dend
operator|=
name|end_match_2
expr_stmt|;
block|}
comment|/* add next character to the compare buffer.  */
name|str_buf
index|[
name|i
index|]
operator|=
name|TRANSLATE
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|str_buf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|match
operator|=
name|__wcscoll
argument_list|(
name|workp
argument_list|,
name|str_buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|match
operator|=
name|wcscoll
argument_list|(
name|workp
argument_list|,
name|str_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|match
operator|==
literal|0
condition|)
goto|goto
name|char_set_matched
goto|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
comment|/* (str_buf> workp) indicate (str_buf + X> workp), 			   because for all X (str_buf + X> str_buf). 			   So we don't need continue this loop.  */
break|break;
comment|/* Otherwise(str_buf< workp), 			   (str_buf+next_character) may equals (workp). 			   So we continue this loop.  */
block|}
comment|/* not matched */
name|d
operator|=
name|backup_d
expr_stmt|;
name|dend
operator|=
name|backup_dend
expr_stmt|;
name|workp
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* match with char_range?  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|collseqval
decl_stmt|;
specifier|const
name|char
modifier|*
name|collseq
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQWC
argument_list|)
decl_stmt|;
name|collseqval
operator|=
name|collseq_table_lookup
argument_list|(
name|collseq
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|workp
operator|<
name|p
operator|-
name|chars_length
condition|;
control|)
block|{
name|uint32_t
name|start_val
decl_stmt|,
name|end_val
decl_stmt|;
comment|/* We already compute the collation sequence value 		       of the characters (or collating symbols).  */
name|start_val
operator|=
operator|(
name|uint32_t
operator|)
operator|*
name|workp
operator|++
expr_stmt|;
comment|/* range_start */
name|end_val
operator|=
operator|(
name|uint32_t
operator|)
operator|*
name|workp
operator|++
expr_stmt|;
comment|/* range_end */
if|if
condition|(
name|start_val
operator|<=
name|collseqval
operator|&&
name|collseqval
operator|<=
name|end_val
condition|)
goto|goto
name|char_set_matched
goto|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
comment|/* We set range_start_char at str_buf[0], range_end_char 		   at str_buf[4], and compared char at str_buf[2].  */
name|str_buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|str_buf
index|[
literal|2
index|]
operator|=
name|c
expr_stmt|;
name|str_buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|str_buf
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|workp
operator|<
name|p
operator|-
name|chars_length
condition|;
control|)
block|{
name|wchar_t
modifier|*
name|range_start_char
decl_stmt|,
modifier|*
name|range_end_char
decl_stmt|;
comment|/* match if (range_start_char<= c<= range_end_char).  */
comment|/* If range_start(or end)< 0, we assume -range_start(end) 		       is the offset of the collating symbol which is specified 		       as the character of the range start(end).  */
comment|/* range_start */
if|if
condition|(
operator|*
name|workp
operator|<
literal|0
condition|)
name|range_start_char
operator|=
name|charset_top
operator|-
operator|(
operator|*
name|workp
operator|++
operator|)
expr_stmt|;
else|else
block|{
name|str_buf
index|[
literal|0
index|]
operator|=
operator|*
name|workp
operator|++
expr_stmt|;
name|range_start_char
operator|=
name|str_buf
expr_stmt|;
block|}
comment|/* range_end */
if|if
condition|(
operator|*
name|workp
operator|<
literal|0
condition|)
name|range_end_char
operator|=
name|charset_top
operator|-
operator|(
operator|*
name|workp
operator|++
operator|)
expr_stmt|;
else|else
block|{
name|str_buf
index|[
literal|4
index|]
operator|=
operator|*
name|workp
operator|++
expr_stmt|;
name|range_end_char
operator|=
name|str_buf
operator|+
literal|4
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|__wcscoll
argument_list|(
name|range_start_char
argument_list|,
name|str_buf
operator|+
literal|2
argument_list|)
operator|<=
literal|0
operator|&&
name|__wcscoll
argument_list|(
name|str_buf
operator|+
literal|2
argument_list|,
name|range_end_char
argument_list|)
operator|<=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|wcscoll
argument_list|(
name|range_start_char
argument_list|,
name|str_buf
operator|+
literal|2
argument_list|)
operator|<=
literal|0
operator|&&
name|wcscoll
argument_list|(
name|str_buf
operator|+
literal|2
argument_list|,
name|range_end_char
argument_list|)
operator|<=
literal|0
condition|)
endif|#
directive|endif
goto|goto
name|char_set_matched
goto|;
block|}
block|}
comment|/* match with char?  */
for|for
control|(
init|;
name|workp
operator|<
name|p
condition|;
name|workp
operator|++
control|)
if|if
condition|(
name|c
operator|==
operator|*
name|workp
condition|)
goto|goto
name|char_set_matched
goto|;
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
name|char_set_matched
label|:
if|if
condition|(
name|negate
condition|)
goto|goto
name|fail
goto|;
else|#
directive|else
comment|/* Cast to `unsigned' instead of `unsigned char' in case the                bit list is a full 32 bytes long.  */
if|if
condition|(
name|c
operator|<
call|(
name|unsigned
call|)
argument_list|(
operator|*
name|p
operator|*
name|BYTEWIDTH
argument_list|)
operator|&&
name|p
index|[
literal|1
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
name|p
operator|+=
literal|1
operator|+
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|negate
condition|)
goto|goto
name|fail
goto|;
undef|#
directive|undef
name|WORK_BUFFER_SIZE
endif|#
directive|endif
comment|/* WCHAR */
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
block|}
comment|/* The beginning of a group is represented by start_memory.            The arguments are the register number in the next byte, and the            number of groups inner to this one in the next.  The text            matched within the group is recorded (in the internal            registers data structure) under the register number.  */
case|case
name|start_memory
case|:
name|DEBUG_PRINT3
argument_list|(
literal|"EXECUTING start_memory %ld (%ld):\n"
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|p
argument_list|,
operator|(
name|long
name|int
operator|)
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Find out if this group can match the empty string.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* To send to group_match_null_string_p.  */
if|if
condition|(
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|==
name|MATCH_NULL_UNSET_VALUE
condition|)
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
name|PREFIX
argument_list|(
name|group_match_null_string_p
argument_list|)
argument_list|(
operator|&
name|p1
argument_list|,
name|pend
argument_list|,
name|reg_info
argument_list|)
expr_stmt|;
comment|/* Save the position in the string where we were the last time              we were at this open-group operator in case the group is              operated upon by a repetition operator, e.g., with `(a*)*b'              against `ab'; then we want to ignore where we are now in              the string in case this attempt to match fails.  */
name|old_regstart
index|[
operator|*
name|p
index|]
operator|=
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|REG_UNSET
argument_list|(
name|regstart
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|d
else|:
name|regstart
index|[
operator|*
name|p
index|]
else|:
name|regstart
index|[
operator|*
name|p
index|]
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"  old_regstart: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|old_regstart
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|regstart
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"  regstart: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|regstart
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear this whenever we change the register activity status.  */
name|set_regs_matched_done
operator|=
literal|0
expr_stmt|;
comment|/* This is the new highest active register.  */
name|highest_active_reg
operator|=
operator|*
name|p
expr_stmt|;
comment|/* If nothing was active before, this is the new lowest active              register.  */
if|if
condition|(
name|lowest_active_reg
operator|==
name|NO_LOWEST_ACTIVE_REG
condition|)
name|lowest_active_reg
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Move past the register number and inner group count.  */
name|p
operator|+=
literal|2
expr_stmt|;
name|just_past_start_mem
operator|=
name|p
expr_stmt|;
break|break;
comment|/* The stop_memory opcode represents the end of a group.  Its            arguments are the same as start_memory's: the register            number, and the number of inner groups.  */
case|case
name|stop_memory
case|:
name|DEBUG_PRINT3
argument_list|(
literal|"EXECUTING stop_memory %ld (%ld):\n"
argument_list|,
operator|(
name|long
name|int
operator|)
operator|*
name|p
argument_list|,
operator|(
name|long
name|int
operator|)
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* We need to save the string position the last time we were at              this close-group operator in case the group is operated              upon by a repetition operator, e.g., with `((a*)*(b*)*)*'              against `aba'; then we want to ignore where we are now in              the string in case this attempt to match fails.  */
name|old_regend
index|[
operator|*
name|p
index|]
operator|=
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|REG_UNSET
argument_list|(
name|regend
index|[
operator|*
name|p
index|]
argument_list|)
condition|?
name|d
else|:
name|regend
index|[
operator|*
name|p
index|]
else|:
name|regend
index|[
operator|*
name|p
index|]
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"      old_regend: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|old_regend
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|regend
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"      regend: %d\n"
argument_list|,
name|POINTER_TO_OFFSET
argument_list|(
name|regend
index|[
operator|*
name|p
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This register isn't active anymore.  */
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear this whenever we change the register activity status.  */
name|set_regs_matched_done
operator|=
literal|0
expr_stmt|;
comment|/* If this was the only register active, nothing is active              anymore.  */
if|if
condition|(
name|lowest_active_reg
operator|==
name|highest_active_reg
condition|)
block|{
name|lowest_active_reg
operator|=
name|NO_LOWEST_ACTIVE_REG
expr_stmt|;
name|highest_active_reg
operator|=
name|NO_HIGHEST_ACTIVE_REG
expr_stmt|;
block|}
else|else
block|{
comment|/* We must scan for the new highest active register, since                  it isn't necessarily one less than now: consider                  (a(b)c(d(e)f)g).  When group 3 ends, after the f), the                  new highest active register is 1.  */
name|UCHAR_T
name|r
init|=
operator|*
name|p
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|r
operator|>
literal|0
operator|&&
operator|!
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
name|r
index|]
argument_list|)
condition|)
name|r
operator|--
expr_stmt|;
comment|/* If we end up at register zero, that means that we saved                  the registers as the result of an `on_failure_jump', not                  a `start_memory', and we jumped to past the innermost                  `stop_memory'.  For example, in ((.)*) we save                  registers 1 and 2 as a result of the *, but when we pop                  back to the second ), we are at the stop_memory 1.                  Thus, nothing is active.  */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|lowest_active_reg
operator|=
name|NO_LOWEST_ACTIVE_REG
expr_stmt|;
name|highest_active_reg
operator|=
name|NO_HIGHEST_ACTIVE_REG
expr_stmt|;
block|}
else|else
name|highest_active_reg
operator|=
name|r
expr_stmt|;
block|}
comment|/* If just failed to match something this time around with a              group that's operated on by a repetition operator, try to              force exit from the ``loop'', and restore the register              information for this group that we had before trying this              last match.  */
if|if
condition|(
operator|(
operator|!
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|||
name|just_past_start_mem
operator|==
name|p
operator|-
literal|1
operator|)
operator|&&
operator|(
name|p
operator|+
literal|2
operator|)
operator|<
name|pend
condition|)
block|{
name|boolean
name|is_a_jump_n
init|=
name|false
decl_stmt|;
name|p1
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|mcnt
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|++
condition|)
block|{
case|case
name|jump_n
case|:
name|is_a_jump_n
operator|=
name|true
expr_stmt|;
case|case
name|pop_failure_jump
case|:
case|case
name|maybe_pop_jump
case|:
case|case
name|jump
case|:
case|case
name|dummy_failure_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_a_jump_n
condition|)
name|p1
operator|+=
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
empty_stmt|;
block|}
name|p1
operator|+=
name|mcnt
expr_stmt|;
comment|/* If the next operation is a jump backwards in the pattern 	         to an on_failure_jump right before the start_memory                  corresponding to this stop_memory, exit from the loop                  by forcing a failure after pushing on the stack the                  on_failure_jump's jump in the pattern, and d.  */
if|if
condition|(
name|mcnt
operator|<
literal|0
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|on_failure_jump
operator|&&
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
index|]
operator|==
name|start_memory
operator|&&
name|p1
index|[
literal|2
operator|+
name|OFFSET_ADDRESS_SIZE
index|]
operator|==
operator|*
name|p
condition|)
block|{
comment|/* If this group ever matched anything, then restore                      what its registers were before trying this last                      failed match, e.g., with `(a*)*b' against `ab' for                      regstart[1], and, e.g., with `((a*)*(b*)*)*'                      against `aba' for regend[3].                       Also restore the registers for inner groups for,                      e.g., `((a*)(b*))*' against `aba' (register 3 would                      otherwise get trashed).  */
if|if
condition|(
name|EVER_MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|r
decl_stmt|;
name|EVER_MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Restore this and inner groups' (if any) registers.  */
for|for
control|(
name|r
operator|=
operator|*
name|p
init|;
name|r
operator|<
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|+
operator|(
name|unsigned
operator|)
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|;
name|r
operator|++
control|)
block|{
name|regstart
index|[
name|r
index|]
operator|=
name|old_regstart
index|[
name|r
index|]
expr_stmt|;
comment|/* xx why this test?  */
if|if
condition|(
name|old_regend
index|[
name|r
index|]
operator|>=
name|regstart
index|[
name|r
index|]
condition|)
name|regend
index|[
name|r
index|]
operator|=
name|old_regend
index|[
name|r
index|]
expr_stmt|;
block|}
block|}
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|PUSH_FAILURE_POINT
argument_list|(
name|p1
operator|+
name|mcnt
argument_list|,
name|d
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Move past the register number and the inner group count.  */
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* \<digit> has been turned into a `duplicate' command which is            followed by the numeric value of<digit> as the register number.  */
case|case
name|duplicate
case|:
block|{
specifier|register
specifier|const
name|CHAR_T
modifier|*
name|d2
decl_stmt|,
modifier|*
name|dend2
decl_stmt|;
name|int
name|regno
init|=
operator|*
name|p
operator|++
decl_stmt|;
comment|/* Get which register to match against.  */
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING duplicate %d.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Can't back reference a group which we've never matched.  */
if|if
condition|(
name|REG_UNSET
argument_list|(
name|regstart
index|[
name|regno
index|]
argument_list|)
operator|||
name|REG_UNSET
argument_list|(
name|regend
index|[
name|regno
index|]
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Where in input to try to start matching.  */
name|d2
operator|=
name|regstart
index|[
name|regno
index|]
expr_stmt|;
comment|/* Where to stop matching; if both the place to start and                the place to stop matching are in the same string, then                set to the place to stop, otherwise, for now have to use                the end of the first string.  */
name|dend2
operator|=
operator|(
operator|(
name|FIRST_STRING_P
argument_list|(
name|regstart
index|[
name|regno
index|]
argument_list|)
operator|==
name|FIRST_STRING_P
argument_list|(
name|regend
index|[
name|regno
index|]
argument_list|)
operator|)
condition|?
name|regend
index|[
name|regno
index|]
else|:
name|end_match_1
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If necessary, advance to next segment in register                    contents.  */
while|while
condition|(
name|d2
operator|==
name|dend2
condition|)
block|{
if|if
condition|(
name|dend2
operator|==
name|end_match_2
condition|)
break|break;
if|if
condition|(
name|dend2
operator|==
name|regend
index|[
name|regno
index|]
condition|)
break|break;
comment|/* End of string1 => advance to string2. */
name|d2
operator|=
name|string2
expr_stmt|;
name|dend2
operator|=
name|regend
index|[
name|regno
index|]
expr_stmt|;
block|}
comment|/* At end of register contents => success */
if|if
condition|(
name|d2
operator|==
name|dend2
condition|)
break|break;
comment|/* If necessary, advance to next segment in data.  */
name|PREFETCH
argument_list|()
expr_stmt|;
comment|/* How many characters left in this segment to match.  */
name|mcnt
operator|=
name|dend
operator|-
name|d
expr_stmt|;
comment|/* Want how many consecutive characters we can match in                    one shot, so, if necessary, adjust the count.  */
if|if
condition|(
name|mcnt
operator|>
name|dend2
operator|-
name|d2
condition|)
name|mcnt
operator|=
name|dend2
operator|-
name|d2
expr_stmt|;
comment|/* Compare that many; failure if mismatch, else move                    past them.  */
if|if
condition|(
name|translate
condition|?
name|PREFIX
argument_list|(
name|bcmp_translate
argument_list|)
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
argument_list|,
name|translate
argument_list|)
else|:
name|memcmp
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
operator|*
sizeof|sizeof
argument_list|(
name|UCHAR_T
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|d
operator|+=
name|mcnt
operator|,
name|d2
operator|+=
name|mcnt
expr_stmt|;
comment|/* Do this because we've match some characters.  */
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
comment|/* begline matches the empty string at the beginning of the string            (unless `not_bol' is set in `bufp'), and, if            `newline_anchor' is set, after newlines.  */
case|case
name|begline
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING begline.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bufp
operator|->
name|not_bol
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|bufp
operator|->
name|newline_anchor
condition|)
block|{
break|break;
block|}
comment|/* In all other cases, we fail.  */
goto|goto
name|fail
goto|;
comment|/* endline is the dual of begline.  */
case|case
name|endline
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING endline.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bufp
operator|->
name|not_eol
condition|)
break|break;
block|}
comment|/* We have to ``prefetch'' the next character.  */
elseif|else
if|if
condition|(
operator|(
name|d
operator|==
name|end1
condition|?
operator|*
name|string2
else|:
operator|*
name|d
operator|)
operator|==
literal|'\n'
operator|&&
name|bufp
operator|->
name|newline_anchor
condition|)
block|{
break|break;
block|}
goto|goto
name|fail
goto|;
comment|/* Match at the very beginning of the data.  */
case|case
name|begbuf
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING begbuf.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
condition|)
break|break;
goto|goto
name|fail
goto|;
comment|/* Match at the very end of the data.  */
case|case
name|endbuf
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING endbuf.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
break|break;
goto|goto
name|fail
goto|;
comment|/* on_failure_keep_string_jump is used to optimize `.*\n'.  It            pushes NULL as the value for the string on the stack.  Then            `pop_failure_point' will keep the current value for the            string, instead of restoring it.  To see why, consider            matching `foo\nbar' against `.*\n'.  The .* matches the foo;            then the . fails against the \n.  But the next thing we want            to do is match the \n against the \n; if we restored the            string value, we would be back at the foo.             Because this is used only in specific cases, we don't need to            check all the things that `on_failure_jump' does, to make            sure the right things get saved on the stack.  Hence we don't            share its code.  The only reason to push anything on the            stack at all is that otherwise we would have to change            `anychar's code to do something besides goto fail in this            case; that seems worse than this.  */
case|case
name|on_failure_keep_string_jump
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING on_failure_keep_string_jump"
argument_list|)
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to %p):\n"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to 0x%x):\n"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSH_FAILURE_POINT
argument_list|(
name|p
operator|+
name|mcnt
argument_list|,
name|NULL
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* Uses of on_failure_jump:             Each alternative starts with an on_failure_jump that points            to the beginning of the next alternative.  Each alternative            except the last ends with a jump that in effect jumps past            the rest of the alternatives.  (They really jump to the            ending jump of the following alternative, because tensioning            these jumps is a hassle.)             Repeats start with an on_failure_jump that points past both            the repetition text and either the following jump or            pop_failure_jump back to this on_failure_jump.  */
case|case
name|on_failure_jump
case|:
name|on_failure
label|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING on_failure_jump"
argument_list|)
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to %p)"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|" %d (to 0x%x)"
argument_list|,
name|mcnt
argument_list|,
name|p
operator|+
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this on_failure_jump comes right before a group (i.e.,              the original * applied to a group), save the information              for that group and all inner ones, so that if we fail back              to this point, the group's information will be correct.              For example, in \(a*\)*\1, we need the preceding group,              and in \(zz\(a*\)b*\)\2, we need the inner group.  */
comment|/* We can't use `p' to check ahead because we push              a failure point to `p + mcnt' after we do this.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* We need to skip no_op's before we look for the              start_memory in case this on_failure_jump is happening as              the result of a completed succeed_n, as in \(a\)\{1,3\}b\1              against aba.  */
while|while
condition|(
name|p1
operator|<
name|pend
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|no_op
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|<
name|pend
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|start_memory
condition|)
block|{
comment|/* We have a new highest active register now.  This will                  get reset at the start_memory we are about to get to,                  but we will have saved all the registers relevant to                  this repetition op, as described above.  */
name|highest_active_reg
operator|=
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
operator|+
operator|*
operator|(
name|p1
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|lowest_active_reg
operator|==
name|NO_LOWEST_ACTIVE_REG
condition|)
name|lowest_active_reg
operator|=
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|DEBUG_PRINT1
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|PUSH_FAILURE_POINT
argument_list|(
name|p
operator|+
name|mcnt
argument_list|,
name|d
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* A smart repeat ends with `maybe_pop_jump'. 	   We change it to either `pop_failure_jump' or `jump'.  */
case|case
name|maybe_pop_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING maybe_pop_jump %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|{
specifier|register
name|UCHAR_T
modifier|*
name|p2
init|=
name|p
decl_stmt|;
comment|/* Compare the beginning of the repeat with what in the                pattern follows its end. If we can establish that there                is nothing that they would both match, i.e., that we                would have to backtrack because of (as in, e.g., `a*a')                then we can change to pop_failure_jump, because we'll                never have to backtrack.                 This is not true in the case of alternatives: in                `(a|ab)*' we do need to backtrack to the `ab' alternative                (e.g., if the string was `ab').  But instead of trying to                detect that here, the alternative has put on a dummy                failure point which is what we will end up popping.  */
comment|/* Skip over open/close-group commands. 	       If what follows this loop is a ...+ construct, 	       look at what begins its body, since we will have to 	       match at least one of that.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p2
operator|+
literal|2
operator|<
name|pend
operator|&&
operator|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|stop_memory
operator|||
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|start_memory
operator|)
condition|)
name|p2
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|+
literal|2
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
operator|<
name|pend
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|dummy_failure_jump
condition|)
name|p2
operator|+=
literal|2
operator|+
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
else|else
break|break;
block|}
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
comment|/* p1[0] ... p1[2] are the `on_failure_jump' corresponding 	       to the `maybe_finalize_jump' of this case.  Examine what 	       follows.  */
comment|/* If we're at the end of the pattern, we can change.  */
if|if
condition|(
name|p2
operator|==
name|pend
condition|)
block|{
comment|/* Consider what happens when matching ":\(.*\)" 		   against ":/".  I don't really understand this code 		   yet.  */
name|p
index|[
operator|-
operator|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
operator|)
index|]
operator|=
operator|(
name|UCHAR_T
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  End of pattern: change to `pop_failure_jump'.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|exactn
ifdef|#
directive|ifdef
name|MBS_SUPPORT
operator|||
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|exactn_bin
endif|#
directive|endif
operator|||
operator|(
name|bufp
operator|->
name|newline_anchor
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|endline
operator|)
condition|)
block|{
specifier|register
name|UCHAR_T
name|c
init|=
operator|*
name|p2
operator|==
operator|(
name|UCHAR_T
operator|)
name|endline
condition|?
literal|'\n'
else|:
name|p2
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
index|]
operator|==
name|exactn
ifdef|#
directive|ifdef
name|MBS_SUPPORT
operator|||
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
index|]
operator|==
name|exactn_bin
endif|#
directive|endif
operator|)
operator|&&
name|p1
index|[
literal|3
operator|+
name|OFFSET_ADDRESS_SIZE
index|]
operator|!=
name|c
condition|)
block|{
name|p
index|[
operator|-
operator|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
operator|)
index|]
operator|=
operator|(
name|UCHAR_T
operator|)
name|pop_failure_jump
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR
name|DEBUG_PRINT3
argument_list|(
literal|"  %C != %C => pop_failure_jump.\n"
argument_list|,
operator|(
name|wint_t
operator|)
name|c
argument_list|,
operator|(
name|wint_t
operator|)
name|p1
index|[
literal|3
operator|+
name|OFFSET_ADDRESS_SIZE
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|"  %c != %c => pop_failure_jump.\n"
argument_list|,
operator|(
name|char
operator|)
name|c
argument_list|,
operator|(
name|char
operator|)
name|p1
index|[
literal|3
operator|+
name|OFFSET_ADDRESS_SIZE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|WCHAR
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset
operator|||
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset_not
condition|)
block|{
name|int
name|negate
init|=
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset_not
decl_stmt|;
if|if
condition|(
name|c
operator|<
call|(
name|unsigned
call|)
argument_list|(
name|p1
index|[
literal|4
index|]
operator|*
name|BYTEWIDTH
argument_list|)
operator|&&
name|p1
index|[
literal|5
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
comment|/* `negate' is equal to 1 if c would match, which means                         that we can't change to pop_failure_jump.  */
if|if
condition|(
operator|!
name|negate
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  No match => pop_failure_jump.\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not WCHAR */
block|}
ifndef|#
directive|ifndef
name|WCHAR
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p2
operator|==
name|charset
condition|)
block|{
comment|/* We win if the first character of the loop is not part                    of the charset.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|exactn
operator|&&
operator|!
operator|(
operator|(
name|int
operator|)
name|p2
index|[
literal|1
index|]
operator|*
name|BYTEWIDTH
operator|>
operator|(
name|int
operator|)
name|p1
index|[
literal|5
index|]
operator|&&
operator|(
name|p2
index|[
literal|2
operator|+
name|p1
index|[
literal|5
index|]
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|p1
index|[
literal|5
index|]
operator|%
name|BYTEWIDTH
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  No match => pop_failure_jump.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset_not
condition|)
block|{
name|int
name|idx
decl_stmt|;
comment|/* We win if the charset_not inside the loop 		       lists every character listed in the charset after.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
operator|(
name|int
operator|)
name|p2
index|[
literal|1
index|]
condition|;
name|idx
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|p2
index|[
literal|2
operator|+
name|idx
index|]
operator|==
literal|0
operator|||
operator|(
name|idx
operator|<
operator|(
name|int
operator|)
name|p1
index|[
literal|4
index|]
operator|&&
operator|(
operator|(
name|p2
index|[
literal|2
operator|+
name|idx
index|]
operator|&
operator|~
name|p1
index|[
literal|5
operator|+
name|idx
index|]
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|idx
operator|==
name|p2
index|[
literal|1
index|]
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  No match => pop_failure_jump.\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
literal|3
index|]
operator|==
name|charset
condition|)
block|{
name|int
name|idx
decl_stmt|;
comment|/* We win if the charset inside the loop 		       has no overlap with the one after the loop.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
operator|(
name|int
operator|)
name|p2
index|[
literal|1
index|]
operator|&&
name|idx
operator|<
operator|(
name|int
operator|)
name|p1
index|[
literal|4
index|]
condition|;
name|idx
operator|++
control|)
if|if
condition|(
operator|(
name|p2
index|[
literal|2
operator|+
name|idx
index|]
operator|&
name|p1
index|[
literal|5
operator|+
name|idx
index|]
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|idx
operator|==
name|p2
index|[
literal|1
index|]
operator|||
name|idx
operator|==
name|p1
index|[
literal|4
index|]
condition|)
block|{
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|pop_failure_jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  No match => pop_failure_jump.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* not WCHAR */
block|}
name|p
operator|-=
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
comment|/* Point at relative address again.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|pop_failure_jump
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|UCHAR_T
operator|)
name|jump
expr_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"  Match => jump.\n"
argument_list|)
expr_stmt|;
goto|goto
name|unconditional_jump
goto|;
block|}
comment|/* Note fall through.  */
comment|/* The end of a simple repeat has a pop_failure_jump back to            its matching on_failure_jump, where the latter will push a            failure point.  The pop_failure_jump takes off failure            points put on by this pop_failure_jump's matching            on_failure_jump; we got through the pattern to here from the            matching on_failure_jump, so didn't fail.  */
case|case
name|pop_failure_jump
case|:
block|{
comment|/* We need to pass separate storage for the lowest and                highest registers, even though we don't care about the                actual values.  Otherwise, we will restore only one                register from the stack, since lowest will == highest in                `pop_failure_point'.  */
name|active_reg_t
name|dummy_low_reg
decl_stmt|,
name|dummy_high_reg
decl_stmt|;
name|UCHAR_T
modifier|*
name|pdummy
init|=
name|NULL
decl_stmt|;
specifier|const
name|CHAR_T
modifier|*
name|sdummy
init|=
name|NULL
decl_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING pop_failure_jump.\n"
argument_list|)
expr_stmt|;
name|POP_FAILURE_POINT
argument_list|(
name|sdummy
argument_list|,
name|pdummy
argument_list|,
name|dummy_low_reg
argument_list|,
name|dummy_high_reg
argument_list|,
name|reg_dummy
argument_list|,
name|reg_dummy
argument_list|,
name|reg_info_dummy
argument_list|)
expr_stmt|;
block|}
comment|/* Note fall through.  */
name|unconditional_jump
label|:
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"\n%p: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"\n0x%x: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note fall through.  */
comment|/* Unconditionally jump (without popping any failure points).  */
case|case
name|jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Get the amount to jump.  */
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING jump %d "
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|p
operator|+=
name|mcnt
expr_stmt|;
comment|/* Do the jump.  */
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"(to %p).\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"(to 0x%x).\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* We need this opcode so we can detect where alternatives end            in `group_match_null_string_p' et al.  */
case|case
name|jump_past_alt
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING jump_past_alt.\n"
argument_list|)
expr_stmt|;
goto|goto
name|unconditional_jump
goto|;
comment|/* Normally, the on_failure_jump pushes a failure point, which            then gets popped at pop_failure_jump.  We will end up at            pop_failure_jump, also, and with a pattern of, say, `a+', we            are skipping over the on_failure_jump, so we have to push            something meaningless for pop_failure_jump to pop.  */
case|case
name|dummy_failure_jump
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING dummy_failure_jump.\n"
argument_list|)
expr_stmt|;
comment|/* It doesn't matter what we push for the string here.  What              the code at `fail' tests is the value for the pattern.  */
name|PUSH_FAILURE_POINT
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|unconditional_jump
goto|;
comment|/* At the end of an alternative, we need to push a dummy failure            point in case we are followed by a `pop_failure_jump', because            we don't want the failure point for the alternative to be            popped.  For example, matching `(a|ab)*' against `aab'            requires that we match the `ab' alternative.  */
case|case
name|push_dummy_failure
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING push_dummy_failure.\n"
argument_list|)
expr_stmt|;
comment|/* See comments just above at `dummy_failure_jump' about the              two zeroes.  */
name|PUSH_FAILURE_POINT
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* Have to succeed matching what follows at least n times.            After that, handle like `on_failure_jump'.  */
case|case
name|succeed_n
case|:
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING succeed_n %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mcnt
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Originally, this is how many times we HAVE to succeed.  */
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
block|{
name|mcnt
operator|--
expr_stmt|;
name|p
operator|+=
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
name|STORE_NUMBER_AND_INCR
argument_list|(
name|p
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting %p to %d.\n"
argument_list|,
name|p
operator|-
name|OFFSET_ADDRESS_SIZE
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting 0x%x to %d.\n"
argument_list|,
name|p
operator|-
name|OFFSET_ADDRESS_SIZE
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|mcnt
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT2
argument_list|(
literal|"  Setting two bytes from %p to no_op.\n"
argument_list|,
name|p
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT2
argument_list|(
literal|"  Setting two bytes from 0x%x to no_op.\n"
argument_list|,
name|p
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _LIBC */
ifdef|#
directive|ifdef
name|WCHAR
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|UCHAR_T
operator|)
name|no_op
expr_stmt|;
else|#
directive|else
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|UCHAR_T
operator|)
name|no_op
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|UCHAR_T
operator|)
name|no_op
expr_stmt|;
endif|#
directive|endif
comment|/* WCHAR */
goto|goto
name|on_failure
goto|;
block|}
break|break;
case|case
name|jump_n
case|:
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING jump_n %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
comment|/* Originally, this is how many times we CAN jump.  */
if|if
condition|(
name|mcnt
condition|)
block|{
name|mcnt
operator|--
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|p
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting %p to %d.\n"
argument_list|,
name|p
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting 0x%x to %d.\n"
argument_list|,
name|p
operator|+
name|OFFSET_ADDRESS_SIZE
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _LIBC */
goto|goto
name|unconditional_jump
goto|;
block|}
comment|/* If don't have to jump any more, skip over the rest of command.  */
else|else
name|p
operator|+=
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
break|break;
case|case
name|set_number_at
case|:
block|{
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING set_number_at.\n"
argument_list|)
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting %p to %d.\n"
argument_list|,
name|p1
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_PRINT3
argument_list|(
literal|"  Setting 0x%x to %d.\n"
argument_list|,
name|p1
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STORE_NUMBER
argument_list|(
name|p1
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|/* The DEC Alpha C compiler 3.x generates incorrect code for the 	   test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of 	   AT_WORD_BOUNDARY, so this code is disabled.  Expanding the 	   macro and introducing temporary variables works around the bug.  */
block|case wordbound: 	  DEBUG_PRINT1 ("EXECUTING wordbound.\n"); 	  if (AT_WORD_BOUNDARY (d)) 	    break; 	  goto fail;  	case notwordbound: 	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n"); 	  if (AT_WORD_BOUNDARY (d)) 	    goto fail; 	  break;
else|#
directive|else
case|case
name|wordbound
case|:
block|{
name|boolean
name|prevchar
decl_stmt|,
name|thischar
decl_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING wordbound.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|||
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
break|break;
name|prevchar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
expr_stmt|;
name|thischar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevchar
operator|!=
name|thischar
condition|)
break|break;
goto|goto
name|fail
goto|;
block|}
case|case
name|notwordbound
case|:
block|{
name|boolean
name|prevchar
decl_stmt|,
name|thischar
decl_stmt|;
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING notwordbound.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|||
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|prevchar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
expr_stmt|;
name|thischar
operator|=
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevchar
operator|!=
name|thischar
condition|)
goto|goto
name|fail
goto|;
break|break;
block|}
endif|#
directive|endif
case|case
name|wordbeg
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING wordbeg.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
operator|&&
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|||
operator|!
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|wordend
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING wordend.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AT_STRINGS_BEG
argument_list|(
name|d
argument_list|)
operator|&&
name|WORDCHAR_P
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|AT_STRINGS_END
argument_list|(
name|d
argument_list|)
operator|||
operator|!
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING before_dot.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
argument_list|)
operator|>=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|at_dot
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING at_dot.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
argument_list|)
operator|!=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|after_dot
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING after_dot.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
argument_list|)
operator|<=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|syntaxspec
case|:
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING syntaxspec %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
goto|goto
name|matchsyntax
goto|;
case|case
name|wordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING Emacs wordchar.\n"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
name|matchsyntax
label|:
name|PREFETCH
argument_list|()
expr_stmt|;
comment|/* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|DEBUG_PRINT2
argument_list|(
literal|"EXECUTING notsyntaxspec %d.\n"
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
goto|goto
name|matchnotsyntax
goto|;
case|case
name|notwordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING Emacs notwordchar.\n"
argument_list|)
expr_stmt|;
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
name|matchnotsyntax
label|:
name|PREFETCH
argument_list|()
expr_stmt|;
comment|/* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
break|break;
else|#
directive|else
comment|/* not emacs */
case|case
name|wordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING non-Emacs wordchar.\n"
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
name|DEBUG_PRINT1
argument_list|(
literal|"EXECUTING non-Emacs notwordchar.\n"
argument_list|)
expr_stmt|;
name|PREFETCH
argument_list|()
expr_stmt|;
if|if
condition|(
name|WORDCHAR_P
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
argument_list|()
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* not emacs */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
continue|continue;
comment|/* Successfully executed one pattern command; keep going.  */
comment|/* We goto here if a matching operation fails. */
name|fail
label|:
if|if
condition|(
operator|!
name|FAIL_STACK_EMPTY
argument_list|()
condition|)
block|{
comment|/* A restart point is known.  Restore to that state.  */
name|DEBUG_PRINT1
argument_list|(
literal|"\nFAIL:\n"
argument_list|)
expr_stmt|;
name|POP_FAILURE_POINT
argument_list|(
name|d
argument_list|,
name|p
argument_list|,
name|lowest_active_reg
argument_list|,
name|highest_active_reg
argument_list|,
name|regstart
argument_list|,
name|regend
argument_list|,
name|reg_info
argument_list|)
expr_stmt|;
comment|/* If this failure point is a dummy, try the next one.  */
if|if
condition|(
operator|!
name|p
condition|)
goto|goto
name|fail
goto|;
comment|/* If we failed to the end of the pattern, don't examine *p.  */
name|assert
argument_list|(
name|p
operator|<=
name|pend
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|pend
condition|)
block|{
name|boolean
name|is_a_jump_n
init|=
name|false
decl_stmt|;
comment|/* If failed to a backwards jump that's part of a repetition                  loop, need to pop this failure point and use the next one.  */
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p
condition|)
block|{
case|case
name|jump_n
case|:
name|is_a_jump_n
operator|=
name|true
expr_stmt|;
case|case
name|maybe_pop_jump
case|:
case|case
name|pop_failure_jump
case|:
case|case
name|jump
case|:
name|p1
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
if|if
condition|(
operator|(
name|is_a_jump_n
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|succeed_n
operator|)
operator|||
operator|(
operator|!
name|is_a_jump_n
operator|&&
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|==
name|on_failure_jump
operator|)
condition|)
goto|goto
name|fail
goto|;
break|break;
default|default:
comment|/* do nothing */
empty_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|>=
name|string1
operator|&&
name|d
operator|<=
name|end1
condition|)
name|dend
operator|=
name|end_match_1
expr_stmt|;
block|}
else|else
break|break;
comment|/* Matching at this starting point really fails.  */
block|}
comment|/* for (;;) */
if|if
condition|(
name|best_regs_set
condition|)
goto|goto
name|restore_best_regs
goto|;
name|FREE_VARIABLES
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Failure to match.  */
block|}
end_decl_stmt

begin_comment
comment|/* re_match_2 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutine definitions for re_match_2.  */
end_comment

begin_comment
comment|/* We are passed P pointing to a register number after a start_memory.     Return true if the pattern up to the corresponding stop_memory can    match the empty string, and false otherwise.     If we find the matching stop_memory, sets P to point to one past its number.    Otherwise, sets P to an undefined byte less than or equal to END.     We don't handle duplicates properly (yet).  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|PREFIX
argument_list|(
name|group_match_null_string_p
argument_list|)
argument_list|(
name|UCHAR_T
operator|*
operator|*
name|p
argument_list|,
name|UCHAR_T
operator|*
name|end
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info
argument_list|)
block|{
name|int
name|mcnt
decl_stmt|;
comment|/* Point to after the args to the start_memory.  */
name|UCHAR_T
modifier|*
name|p1
init|=
operator|*
name|p
operator|+
literal|2
decl_stmt|;
while|while
condition|(
name|p1
operator|<
name|end
condition|)
block|{
comment|/* Skip over opcodes that can match nothing, and return true or 	 false, as appropriate, when we get to one that can't, or to the          matching stop_memory.  */
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
condition|)
block|{
comment|/* Could be either a loop or a series of alternatives.  */
case|case
name|on_failure_jump
case|:
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* If the next operation is not a jump backwards in the 	     pattern.  */
if|if
condition|(
name|mcnt
operator|>=
literal|0
condition|)
block|{
comment|/* Go through the on_failure_jumps of the alternatives,                  seeing if any of the alternatives cannot match nothing.                  The last alternative starts with only a jump,                  whereas the rest start with on_failure_jump and end                  with a jump, e.g., here is the pattern for `a|b|c':                   /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6                  /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3                  /exactn/1/c                   So, we have to first go through the first (n-1)                  alternatives and then deal with the last one separately.  */
comment|/* Deal with the first (n-1) alternatives, which start                  with an on_failure_jump (see above) that jumps to right                  past a jump_past_alt.  */
while|while
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
name|mcnt
operator|-
operator|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
operator|)
index|]
operator|==
name|jump_past_alt
condition|)
block|{
comment|/* `mcnt' holds how many bytes long the alternative                      is, including the ending `jump_past_alt' and                      its number.  */
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|alt_match_null_string_p
argument_list|)
argument_list|(
name|p1
argument_list|,
name|p1
operator|+
name|mcnt
operator|-
operator|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
operator|)
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Move to right after this alternative, including the 		     jump_past_alt.  */
name|p1
operator|+=
name|mcnt
expr_stmt|;
comment|/* Break if it's the beginning of an n-th alternative                      that doesn't begin with an on_failure_jump.  */
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|!=
name|on_failure_jump
condition|)
break|break;
comment|/* Still have to check that it's not an n-th 		     alternative that starts with an on_failure_jump.  */
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re_opcode_t
operator|)
name|p1
index|[
name|mcnt
operator|-
operator|(
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
operator|)
index|]
operator|!=
name|jump_past_alt
condition|)
block|{
comment|/* Get to the beginning of the n-th alternative.  */
name|p1
operator|-=
literal|1
operator|+
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Deal with the last alternative: go back and get number                  of the `jump_past_alt' just before it.  `mcnt' contains                  the length of the alternative.  */
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p1
operator|-
name|OFFSET_ADDRESS_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|alt_match_null_string_p
argument_list|)
argument_list|(
name|p1
argument_list|,
name|p1
operator|+
name|mcnt
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
comment|/* Get past the n-th alternative.  */
block|}
comment|/* if mcnt> 0 */
break|break;
case|case
name|stop_memory
case|:
name|assert
argument_list|(
name|p1
index|[
literal|1
index|]
operator|==
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|p1
operator|+
literal|2
expr_stmt|;
return|return
name|true
return|;
default|default:
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|common_op_match_null_string_p
argument_list|)
argument_list|(
operator|&
name|p1
argument_list|,
name|end
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* while p1< end */
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* group_match_null_string_p */
end_comment

begin_comment
comment|/* Similar to group_match_null_string_p, but doesn't deal with alternatives:    It expects P to be the first byte of a single alternative and END one    byte past the last. The alternative can contain groups.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|PREFIX
argument_list|(
name|alt_match_null_string_p
argument_list|)
argument_list|(
name|UCHAR_T
operator|*
name|p
argument_list|,
name|UCHAR_T
operator|*
name|end
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info
argument_list|)
block|{
name|int
name|mcnt
decl_stmt|;
name|UCHAR_T
modifier|*
name|p1
init|=
name|p
decl_stmt|;
while|while
condition|(
name|p1
operator|<
name|end
condition|)
block|{
comment|/* Skip over opcodes that can match nothing, and break when we get          to one that can't.  */
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
condition|)
block|{
comment|/* It's a loop.  */
case|case
name|on_failure_jump
case|:
name|p1
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|common_op_match_null_string_p
argument_list|)
argument_list|(
operator|&
name|p1
argument_list|,
name|end
argument_list|,
name|reg_info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* while p1< end */
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* alt_match_null_string_p */
end_comment

begin_comment
comment|/* Deals with the ops common to group_match_null_string_p and    alt_match_null_string_p.     Sets P to one after the op and its arguments, if any.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|PREFIX
argument_list|(
name|common_op_match_null_string_p
argument_list|)
argument_list|(
name|UCHAR_T
operator|*
operator|*
name|p
argument_list|,
name|UCHAR_T
operator|*
name|end
argument_list|,
name|PREFIX
argument_list|(
name|register_info_type
argument_list|)
operator|*
name|reg_info
argument_list|)
block|{
name|int
name|mcnt
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
name|int
name|reg_no
decl_stmt|;
name|UCHAR_T
modifier|*
name|p1
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
operator|(
name|re_opcode_t
operator|)
operator|*
name|p1
operator|++
condition|)
block|{
case|case
name|no_op
case|:
case|case
name|begline
case|:
case|case
name|endline
case|:
case|case
name|begbuf
case|:
case|case
name|endbuf
case|:
case|case
name|wordbeg
case|:
case|case
name|wordend
case|:
case|case
name|wordbound
case|:
case|case
name|notwordbound
case|:
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
case|case
name|at_dot
case|:
case|case
name|after_dot
case|:
endif|#
directive|endif
break|break;
case|case
name|start_memory
case|:
name|reg_no
operator|=
operator|*
name|p1
expr_stmt|;
name|assert
argument_list|(
name|reg_no
operator|>
literal|0
operator|&&
name|reg_no
operator|<=
name|MAX_REGNUM
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PREFIX
argument_list|(
name|group_match_null_string_p
argument_list|)
argument_list|(
operator|&
name|p1
argument_list|,
name|end
argument_list|,
name|reg_info
argument_list|)
expr_stmt|;
comment|/* Have to set this here in case we're checking a group which          contains a group and a back reference to it.  */
if|if
condition|(
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
name|reg_no
index|]
argument_list|)
operator|==
name|MATCH_NULL_UNSET_VALUE
condition|)
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
name|reg_no
index|]
argument_list|)
operator|=
name|ret
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|false
return|;
break|break;
comment|/* If this is an optimized succeed_n for zero times, make the jump.  */
case|case
name|jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>=
literal|0
condition|)
name|p1
operator|+=
name|mcnt
expr_stmt|;
else|else
return|return
name|false
return|;
break|break;
case|case
name|succeed_n
case|:
comment|/* Get to the number of times to succeed.  */
name|p1
operator|+=
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|==
literal|0
condition|)
block|{
name|p1
operator|-=
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|mcnt
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
break|break;
case|case
name|duplicate
case|:
if|if
condition|(
operator|!
name|REG_MATCH_NULL_STRING_P
argument_list|(
name|reg_info
index|[
operator|*
name|p1
index|]
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|set_number_at
case|:
name|p1
operator|+=
literal|2
operator|*
name|OFFSET_ADDRESS_SIZE
expr_stmt|;
default|default:
comment|/* All other opcodes mean we cannot match the empty string.  */
return|return
name|false
return|;
block|}
operator|*
name|p
operator|=
name|p1
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* common_op_match_null_string_p */
end_comment

begin_comment
comment|/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN    bytes; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|PREFIX
function|(
name|bcmp_translate
function|)
parameter_list|(
specifier|const
name|CHAR_T
modifier|*
name|s1
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|s2
parameter_list|,
specifier|register
name|int
name|len
parameter_list|,
name|RE_TRANSLATE_TYPE
name|translate
parameter_list|)
block|{
specifier|register
specifier|const
name|UCHAR_T
modifier|*
name|p1
init|=
operator|(
specifier|const
name|UCHAR_T
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
specifier|const
name|UCHAR_T
modifier|*
name|p2
init|=
operator|(
specifier|const
name|UCHAR_T
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
ifdef|#
directive|ifdef
name|WCHAR
if|if
condition|(
operator|(
operator|(
operator|*
name|p1
operator|<=
literal|0xff
operator|)
condition|?
name|translate
index|[
operator|*
name|p1
operator|++
index|]
else|:
operator|*
name|p1
operator|++
operator|)
operator|!=
operator|(
operator|(
operator|*
name|p2
operator|<=
literal|0xff
operator|)
condition|?
name|translate
index|[
operator|*
name|p2
operator|++
index|]
else|:
operator|*
name|p2
operator|++
operator|)
condition|)
return|return
literal|1
return|;
else|#
directive|else
comment|/* BYTE */
if|if
condition|(
name|translate
index|[
operator|*
name|p1
operator|++
index|]
operator|!=
name|translate
index|[
operator|*
name|p2
operator|++
index|]
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* WCHAR */
name|len
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_comment
comment|/* Entry points for GNU code.  */
end_comment

begin_comment
comment|/* re_compile_pattern is the GNU regular expression compiler: it    compiles PATTERN (of length SIZE) and puts the result in BUFP.    Returns 0 if the pattern was valid, otherwise an error string.     Assumes the `allocated' (and perhaps `buffer') and `translate' fields    are set in BUFP on entry.     We call regex_compile to do the actual compilation.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|re_compile_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|)
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* GNU code is written to assume at least RE_NREGS registers will be set      (and at least one extra will be -1).  */
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
comment|/* And GNU code determines whether or not to get register information      by passing null for the REGS argument to re_match, etc., not by      setting no_sub.  */
name|bufp
operator|->
name|no_sub
operator|=
literal|0
expr_stmt|;
comment|/* Match anchors at newline.  */
name|bufp
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
condition|)
name|ret
operator|=
name|wcs_regex_compile
argument_list|(
name|pattern
argument_list|,
name|length
argument_list|,
name|re_syntax_options
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ret
operator|=
name|byte_regex_compile
argument_list|(
name|pattern
argument_list|,
name|length
argument_list|,
name|re_syntax_options
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
return|return
name|gettext
argument_list|(
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|ret
index|]
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_compile_pattern
argument_list|,
argument|re_compile_pattern
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Entry points compatible with 4.2 BSD regex library.  We don't define    them unless specifically requested.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_REGEX_RE_COMP
operator|||
name|defined
name|_LIBC
end_if

begin_comment
comment|/* BSD has one and only one pattern buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|re_comp_buf
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|_LIBC
comment|/* Make these definitions weak in libc, so POSIX programs can redefine    these names if they don't use our functions, and still use    regcomp/regexec below without link errors.  */
name|weak_function
endif|#
directive|endif
name|re_comp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|gettext
argument_list|(
literal|"No previous regular expression"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
block|{
name|re_comp_buf
operator|.
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_comp_buf
operator|.
name|buffer
operator|==
name|NULL
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|gettext
argument_list|(
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|REG_ESPACE
index|]
argument_list|)
return|;
name|re_comp_buf
operator|.
name|allocated
operator|=
literal|200
expr_stmt|;
name|re_comp_buf
operator|.
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_comp_buf
operator|.
name|fastmap
operator|==
name|NULL
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|gettext
argument_list|(
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|REG_ESPACE
index|]
argument_list|)
return|;
block|}
comment|/* Since `re_exec' always passes NULL for the `regs' argument, we      don't need to initialize the pattern buffer fields which affect it.  */
comment|/* Match anchors at newlines.  */
name|re_comp_buf
operator|.
name|newline_anchor
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
condition|)
name|ret
operator|=
name|wcs_regex_compile
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|re_syntax_options
argument_list|,
operator|&
name|re_comp_buf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ret
operator|=
name|byte_regex_compile
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|re_syntax_options
argument_list|,
operator|&
name|re_comp_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
comment|/* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
return|return
operator|(
name|char
operator|*
operator|)
name|gettext
argument_list|(
name|re_error_msgid
index|[
operator|(
name|int
operator|)
name|ret
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|_LIBC
name|weak_function
endif|#
directive|endif
name|re_exec
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|re_comp_buf
argument_list|,
name|s
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _REGEX_RE_COMP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* POSIX.2 functions.  Don't define these for Emacs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* regcomp takes a regular expression as a string and compiles it.     PREG is a regex_t *.  We do not expect any fields to be initialized,    since POSIX says we shouldn't.  Thus, we set       `buffer' to the compiled pattern;      `used' to the length of the compiled pattern;      `syntax' to RE_SYNTAX_POSIX_EXTENDED if the        REG_EXTENDED bit in CFLAGS is set; otherwise, to        RE_SYNTAX_POSIX_BASIC;      `newline_anchor' to REG_NEWLINE being set in CFLAGS;      `fastmap' to an allocated space for the fastmap;      `fastmap_accurate' to zero;      `re_nsub' to the number of subexpressions in PATTERN.     PATTERN is the address of the pattern string.     CFLAGS is a series of bits which affect compilation.       If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we      use POSIX basic syntax.       If REG_NEWLINE is set, then . and [^...] don't match newline.      Also, regexec will try a match beginning after every newline.       If REG_ICASE is set, then we considers upper- and lowercase      versions of letters to be equivalent when matching.       If REG_NOSUB is set, then when PREG is passed to regexec, that      routine will report only success or failure, and nothing about the      registers.     It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for    the return codes and their meanings.)  */
end_comment

begin_function
name|int
name|regcomp
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|cflags
parameter_list|)
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|reg_syntax_t
name|syntax
init|=
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
condition|?
name|RE_SYNTAX_POSIX_EXTENDED
else|:
name|RE_SYNTAX_POSIX_BASIC
decl_stmt|;
comment|/* regex_compile will allocate the space for the compiled pattern.  */
name|preg
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* Try to allocate space for the fastmap.  */
name|preg
operator|->
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflags
operator|&
name|REG_ICASE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|preg
operator|->
name|translate
operator|=
operator|(
name|RE_TRANSLATE_TYPE
operator|)
name|malloc
argument_list|(
name|CHAR_SET_SIZE
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|RE_TRANSLATE_TYPE
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|translate
operator|==
name|NULL
condition|)
return|return
operator|(
name|int
operator|)
name|REG_ESPACE
return|;
comment|/* Map uppercase characters to corresponding lowercase ones.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHAR_SET_SIZE
condition|;
name|i
operator|++
control|)
name|preg
operator|->
name|translate
index|[
name|i
index|]
operator|=
name|ISUPPER
argument_list|(
name|i
argument_list|)
condition|?
name|TOLOWER
argument_list|(
name|i
argument_list|)
else|:
name|i
expr_stmt|;
block|}
else|else
name|preg
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
comment|/* If REG_NEWLINE is set, newlines are treated differently.  */
if|if
condition|(
name|cflags
operator|&
name|REG_NEWLINE
condition|)
block|{
comment|/* REG_NEWLINE implies neither . nor [^...] match newline.  */
name|syntax
operator|&=
operator|~
name|RE_DOT_NEWLINE
expr_stmt|;
name|syntax
operator||=
name|RE_HAT_LISTS_NOT_NEWLINE
expr_stmt|;
comment|/* It also changes the matching behavior.  */
name|preg
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|preg
operator|->
name|newline_anchor
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|no_sub
operator|=
operator|!
operator|!
operator|(
name|cflags
operator|&
name|REG_NOSUB
operator|)
expr_stmt|;
comment|/* POSIX says a null character in the pattern terminates it, so we      can use strlen here in compiling the pattern.  */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
condition|)
name|ret
operator|=
name|wcs_regex_compile
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|syntax
argument_list|,
name|preg
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ret
operator|=
name|byte_regex_compile
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|syntax
argument_list|,
name|preg
argument_list|)
expr_stmt|;
comment|/* POSIX doesn't distinguish between an unmatched open-group and an      unmatched close-group: both are REG_EPAREN.  */
if|if
condition|(
name|ret
operator|==
name|REG_ERPAREN
condition|)
name|ret
operator|=
name|REG_EPAREN
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|REG_NOERROR
operator|&&
name|preg
operator|->
name|fastmap
condition|)
block|{
comment|/* Compute the fastmap now, since regexec cannot modify the pattern 	 buffer.  */
if|if
condition|(
name|re_compile_fastmap
argument_list|(
name|preg
argument_list|)
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* Some error occurred while computing the fastmap, just forget 	     about it.  */
name|free
argument_list|(
name|preg
operator|->
name|fastmap
argument_list|)
expr_stmt|;
name|preg
operator|->
name|fastmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|int
operator|)
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__regcomp
argument_list|,
argument|regcomp
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* regexec searches for a given pattern, specified by PREG, in the    string STRING.     If NMATCH is zero or REG_NOSUB was set in the cflags argument to    `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at    least NMATCH elements, and we set them to the offsets of the    corresponding matched substrings.     EFLAGS specifies `execution flags' which affect matching: if    REG_NOTBOL is set, then ^ does not match at the beginning of the    string; if REG_NOTEOL is set, then $ does not match at the end.     We return 0 if we find a match and REG_NOMATCH if not.  */
end_comment

begin_function
name|int
name|regexec
parameter_list|(
specifier|const
name|regex_t
modifier|*
name|preg
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|nmatch
parameter_list|,
name|regmatch_t
name|pmatch
index|[]
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
name|regex_t
name|private_preg
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|boolean
name|want_reg_info
init|=
operator|!
name|preg
operator|->
name|no_sub
operator|&&
name|nmatch
operator|>
literal|0
decl_stmt|;
name|private_preg
operator|=
operator|*
name|preg
expr_stmt|;
name|private_preg
operator|.
name|not_bol
operator|=
operator|!
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTBOL
operator|)
expr_stmt|;
name|private_preg
operator|.
name|not_eol
operator|=
operator|!
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTEOL
operator|)
expr_stmt|;
comment|/* The user has told us exactly how many registers to return      information about, via `nmatch'.  We have to pass that on to the      matching routines.  */
name|private_preg
operator|.
name|regs_allocated
operator|=
name|REGS_FIXED
expr_stmt|;
if|if
condition|(
name|want_reg_info
condition|)
block|{
name|regs
operator|.
name|num_regs
operator|=
name|nmatch
expr_stmt|;
name|regs
operator|.
name|start
operator|=
name|TALLOC
argument_list|(
name|nmatch
operator|*
literal|2
argument_list|,
name|regoff_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
operator|==
name|NULL
condition|)
return|return
operator|(
name|int
operator|)
name|REG_NOMATCH
return|;
name|regs
operator|.
name|end
operator|=
name|regs
operator|.
name|start
operator|+
name|nmatch
expr_stmt|;
block|}
comment|/* Perform the searching operation.  */
name|ret
operator|=
name|re_search
argument_list|(
operator|&
name|private_preg
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
comment|/* start: */
literal|0
argument_list|,
comment|/* range: */
name|len
argument_list|,
name|want_reg_info
condition|?
operator|&
name|regs
else|:
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the register information to the POSIX structure.  */
if|if
condition|(
name|want_reg_info
condition|)
block|{
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|nmatch
condition|;
name|r
operator|++
control|)
block|{
name|pmatch
index|[
name|r
index|]
operator|.
name|rm_so
operator|=
name|regs
operator|.
name|start
index|[
name|r
index|]
expr_stmt|;
name|pmatch
index|[
name|r
index|]
operator|.
name|rm_eo
operator|=
name|regs
operator|.
name|end
index|[
name|r
index|]
expr_stmt|;
block|}
block|}
comment|/* If we needed the temporary register info, free the space now.  */
name|free
argument_list|(
name|regs
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
comment|/* We want zero return to mean success, unlike `re_search'.  */
return|return
name|ret
operator|>=
literal|0
condition|?
operator|(
name|int
operator|)
name|REG_NOERROR
else|:
operator|(
name|int
operator|)
name|REG_NOMATCH
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__regexec
argument_list|,
argument|regexec
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Returns a message corresponding to an error code, ERRCODE, returned    from either regcomp or regexec.   We don't use PREG here.  */
end_comment

begin_function
name|size_t
name|regerror
parameter_list|(
name|int
name|errcode
parameter_list|,
specifier|const
name|regex_t
modifier|*
name|preg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|size_t
name|errbuf_size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|msg_size
decl_stmt|;
if|if
condition|(
name|errcode
operator|<
literal|0
operator|||
name|errcode
operator|>=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|re_error_msgid
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|re_error_msgid
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
comment|/* Only error codes returned by the rest of the code should be passed        to this routine.  If we are given anything else, or if other regex        code generates an invalid error code, then the program has a bug.        Dump core so we can fix it.  */
name|abort
argument_list|()
expr_stmt|;
name|msg
operator|=
name|gettext
argument_list|(
name|re_error_msgid
index|[
name|errcode
index|]
argument_list|)
expr_stmt|;
name|msg_size
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Includes the null.  */
if|if
condition|(
name|errbuf_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|msg_size
operator|>
name|errbuf_size
condition|)
block|{
if|#
directive|if
name|defined
name|HAVE_MEMPCPY
operator|||
name|defined
name|_LIBC
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|mempcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|errbuf_size
operator|-
literal|1
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|errbuf_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|errbuf
index|[
name|errbuf_size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|memcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
block|}
return|return
name|msg_size
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__regerror
argument_list|,
argument|regerror
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Free dynamically allocated space used by PREG.  */
end_comment

begin_function
name|void
name|regfree
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|)
block|{
if|if
condition|(
name|preg
operator|->
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|preg
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|fastmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|preg
operator|->
name|fastmap
argument_list|)
expr_stmt|;
name|preg
operator|->
name|fastmap
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|translate
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|preg
operator|->
name|translate
argument_list|)
expr_stmt|;
name|preg
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__regfree
argument_list|,
argument|regfree
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not INSIDE_RECURSION */
end_comment

begin_escape
end_escape

begin_undef
undef|#
directive|undef
name|STORE_NUMBER
end_undef

begin_undef
undef|#
directive|undef
name|STORE_NUMBER_AND_INCR
end_undef

begin_undef
undef|#
directive|undef
name|EXTRACT_NUMBER
end_undef

begin_undef
undef|#
directive|undef
name|EXTRACT_NUMBER_AND_INCR
end_undef

begin_undef
undef|#
directive|undef
name|DEBUG_PRINT_COMPILED_PATTERN
end_undef

begin_undef
undef|#
directive|undef
name|DEBUG_PRINT_DOUBLE_STRING
end_undef

begin_undef
undef|#
directive|undef
name|INIT_FAIL_STACK
end_undef

begin_undef
undef|#
directive|undef
name|RESET_FAIL_STACK
end_undef

begin_undef
undef|#
directive|undef
name|DOUBLE_FAIL_STACK
end_undef

begin_undef
undef|#
directive|undef
name|PUSH_PATTERN_OP
end_undef

begin_undef
undef|#
directive|undef
name|PUSH_FAILURE_POINTER
end_undef

begin_undef
undef|#
directive|undef
name|PUSH_FAILURE_INT
end_undef

begin_undef
undef|#
directive|undef
name|PUSH_FAILURE_ELT
end_undef

begin_undef
undef|#
directive|undef
name|POP_FAILURE_POINTER
end_undef

begin_undef
undef|#
directive|undef
name|POP_FAILURE_INT
end_undef

begin_undef
undef|#
directive|undef
name|POP_FAILURE_ELT
end_undef

begin_undef
undef|#
directive|undef
name|DEBUG_PUSH
end_undef

begin_undef
undef|#
directive|undef
name|DEBUG_POP
end_undef

begin_undef
undef|#
directive|undef
name|PUSH_FAILURE_POINT
end_undef

begin_undef
undef|#
directive|undef
name|POP_FAILURE_POINT
end_undef

begin_undef
undef|#
directive|undef
name|REG_UNSET_VALUE
end_undef

begin_undef
undef|#
directive|undef
name|REG_UNSET
end_undef

begin_undef
undef|#
directive|undef
name|PATFETCH
end_undef

begin_undef
undef|#
directive|undef
name|PATFETCH_RAW
end_undef

begin_undef
undef|#
directive|undef
name|PATUNFETCH
end_undef

begin_undef
undef|#
directive|undef
name|TRANSLATE
end_undef

begin_undef
undef|#
directive|undef
name|INIT_BUF_SIZE
end_undef

begin_undef
undef|#
directive|undef
name|GET_BUFFER_SPACE
end_undef

begin_undef
undef|#
directive|undef
name|BUF_PUSH
end_undef

begin_undef
undef|#
directive|undef
name|BUF_PUSH_2
end_undef

begin_undef
undef|#
directive|undef
name|BUF_PUSH_3
end_undef

begin_undef
undef|#
directive|undef
name|STORE_JUMP
end_undef

begin_undef
undef|#
directive|undef
name|STORE_JUMP2
end_undef

begin_undef
undef|#
directive|undef
name|INSERT_JUMP
end_undef

begin_undef
undef|#
directive|undef
name|INSERT_JUMP2
end_undef

begin_undef
undef|#
directive|undef
name|EXTEND_BUFFER
end_undef

begin_undef
undef|#
directive|undef
name|GET_UNSIGNED_NUMBER
end_undef

begin_undef
undef|#
directive|undef
name|FREE_STACK_RETURN
end_undef

begin_undef
undef|#
directive|undef
name|POINTER_TO_OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|MATCHING_IN_FRST_STRING
end_undef

begin_undef
undef|#
directive|undef
name|PREFETCH
end_undef

begin_undef
undef|#
directive|undef
name|AT_STRINGS_BEG
end_undef

begin_undef
undef|#
directive|undef
name|AT_STRINGS_END
end_undef

begin_undef
undef|#
directive|undef
name|WORDCHAR_P
end_undef

begin_undef
undef|#
directive|undef
name|FREE_VAR
end_undef

begin_undef
undef|#
directive|undef
name|FREE_VARIABLES
end_undef

begin_undef
undef|#
directive|undef
name|NO_HIGHEST_ACTIVE_REG
end_undef

begin_undef
undef|#
directive|undef
name|NO_LOWEST_ACTIVE_REG
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_T
end_undef

begin_undef
undef|#
directive|undef
name|UCHAR_T
end_undef

begin_undef
undef|#
directive|undef
name|COMPILED_BUFFER_VAR
end_undef

begin_undef
undef|#
directive|undef
name|OFFSET_ADDRESS_SIZE
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_CLASS_SIZE
end_undef

begin_undef
undef|#
directive|undef
name|PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|ARG_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|PUT_CHAR
end_undef

begin_undef
undef|#
directive|undef
name|BYTE
end_undef

begin_undef
undef|#
directive|undef
name|WCHAR
end_undef

begin_define
define|#
directive|define
name|DEFINED_ONCE
end_define

end_unit

