begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for National Semiconductor's CR16 ELF    Copyright 2007 Free Software Foundation, Inc.    Written by M R Swami Reddy.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/cr16.h"
end_include

begin_comment
comment|/* cr16_reloc_map array maps BFD relocation enum into a CRGAS relocation type.  */
end_comment

begin_struct
struct|struct
name|cr16_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_enum
decl_stmt|;
comment|/* BFD relocation enum.  */
name|unsigned
name|short
name|cr16_reloc_type
decl_stmt|;
comment|/* CR16 relocation type.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cr16_reloc_map
name|cr16_reloc_map
index|[
name|R_CR16_MAX
index|]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_CR16_NONE
block|}
block|,
block|{
name|BFD_RELOC_CR16_NUM8
block|,
name|R_CR16_NUM8
block|}
block|,
block|{
name|BFD_RELOC_CR16_NUM16
block|,
name|R_CR16_NUM16
block|}
block|,
block|{
name|BFD_RELOC_CR16_NUM32
block|,
name|R_CR16_NUM32
block|}
block|,
block|{
name|BFD_RELOC_CR16_NUM32a
block|,
name|R_CR16_NUM32a
block|}
block|,
block|{
name|BFD_RELOC_CR16_REGREL4
block|,
name|R_CR16_REGREL4
block|}
block|,
block|{
name|BFD_RELOC_CR16_REGREL4a
block|,
name|R_CR16_REGREL4a
block|}
block|,
block|{
name|BFD_RELOC_CR16_REGREL14
block|,
name|R_CR16_REGREL14
block|}
block|,
block|{
name|BFD_RELOC_CR16_REGREL14a
block|,
name|R_CR16_REGREL14a
block|}
block|,
block|{
name|BFD_RELOC_CR16_REGREL16
block|,
name|R_CR16_REGREL16
block|}
block|,
block|{
name|BFD_RELOC_CR16_REGREL20
block|,
name|R_CR16_REGREL20
block|}
block|,
block|{
name|BFD_RELOC_CR16_REGREL20a
block|,
name|R_CR16_REGREL20a
block|}
block|,
block|{
name|BFD_RELOC_CR16_ABS20
block|,
name|R_CR16_ABS20
block|}
block|,
block|{
name|BFD_RELOC_CR16_ABS24
block|,
name|R_CR16_ABS24
block|}
block|,
block|{
name|BFD_RELOC_CR16_IMM4
block|,
name|R_CR16_IMM4
block|}
block|,
block|{
name|BFD_RELOC_CR16_IMM8
block|,
name|R_CR16_IMM8
block|}
block|,
block|{
name|BFD_RELOC_CR16_IMM16
block|,
name|R_CR16_IMM16
block|}
block|,
block|{
name|BFD_RELOC_CR16_IMM20
block|,
name|R_CR16_IMM20
block|}
block|,
block|{
name|BFD_RELOC_CR16_IMM24
block|,
name|R_CR16_IMM24
block|}
block|,
block|{
name|BFD_RELOC_CR16_IMM32
block|,
name|R_CR16_IMM32
block|}
block|,
block|{
name|BFD_RELOC_CR16_IMM32a
block|,
name|R_CR16_IMM32a
block|}
block|,
block|{
name|BFD_RELOC_CR16_DISP4
block|,
name|R_CR16_DISP4
block|}
block|,
block|{
name|BFD_RELOC_CR16_DISP8
block|,
name|R_CR16_DISP8
block|}
block|,
block|{
name|BFD_RELOC_CR16_DISP16
block|,
name|R_CR16_DISP16
block|}
block|,
block|{
name|BFD_RELOC_CR16_DISP24
block|,
name|R_CR16_DISP24
block|}
block|,
block|{
name|BFD_RELOC_CR16_DISP24a
block|,
name|R_CR16_DISP24a
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|cr16_elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_CR16_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_NUM8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_NUM8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_NUM16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_NUM16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_NUM32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_NUM32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_NUM32a
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_NUM32a"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_REGREL4
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|4
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_REGREL4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xf
argument_list|,
comment|/* src_mask */
literal|0xf
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_REGREL4a
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|4
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_REGREL4a"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xf
argument_list|,
comment|/* src_mask */
literal|0xf
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_REGREL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|14
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_REGREL14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x3fff
argument_list|,
comment|/* src_mask */
literal|0x3fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_REGREL14a
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|14
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_REGREL14a"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x3fff
argument_list|,
comment|/* src_mask */
literal|0x3fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_REGREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_REGREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_REGREL20
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|20
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_REGREL20"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfffff
argument_list|,
comment|/* src_mask */
literal|0xfffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_REGREL20a
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|20
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_REGREL20a"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfffff
argument_list|,
comment|/* src_mask */
literal|0xfffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_ABS20
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|20
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_ABS20"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfffff
argument_list|,
comment|/* src_mask */
literal|0xfffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_ABS24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_ABS24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_IMM4
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|4
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_IMM4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xf
argument_list|,
comment|/* src_mask */
literal|0xf
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_IMM8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_IMM8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_IMM16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_IMM16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_IMM20
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|20
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_IMM20"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfffff
argument_list|,
comment|/* src_mask */
literal|0xfffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_IMM24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_IMM24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_IMM32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_IMM32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_IMM32a
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_IMM32a"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_DISP4
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|4
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_DISP4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xf
argument_list|,
comment|/* src_mask */
literal|0xf
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_DISP8
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_DISP8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x1ff
argument_list|,
comment|/* src_mask */
literal|0x1ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CR16_DISP16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift REVIITS: To sync with WinIDEA*/
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_DISP16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x1ffff
argument_list|,
comment|/* src_mask */
literal|0x1ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* REVISIT: DISP24 should be left-shift by 2 as per ISA doc      but its not done, to sync with WinIDEA and CR16 4.1 tools */
name|HOWTO
argument_list|(
name|R_CR16_DISP24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_DISP24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x1ffffff
argument_list|,
comment|/* src_mask */
literal|0x1ffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
argument|R_CR16_DISP24a
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
argument|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
argument|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CR16_DISP24a"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
argument|FALSE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Retrieve a howto ptr using a BFD reloc_code.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_cr16_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|R_CR16_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|code
operator|==
name|cr16_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_enum
condition|)
return|return
operator|&
name|cr16_elf_howto_table
index|[
name|cr16_reloc_map
index|[
name|i
index|]
operator|.
name|cr16_reloc_type
index|]
return|;
name|_bfd_error_handler
argument_list|(
literal|"Unsupported CR16 relocation type: 0x%x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_cr16_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ARRAY_SIZE
argument_list|(
name|cr16_elf_howto_table
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cr16_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|cr16_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cr16_elf_howto_table
operator|+
name|i
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a howto ptr using an internal relocation entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf_cr16_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_CR16_MAX
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|cr16_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|cr16_elf_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|Rvalue
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|is_local
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|short
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
name|bfd_vma
name|reloc_bits
decl_stmt|,
name|check
decl_stmt|,
name|Rvalue1
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_CR16_IMM4
case|:
case|case
name|R_CR16_IMM8
case|:
case|case
name|R_CR16_IMM16
case|:
case|case
name|R_CR16_IMM20
case|:
case|case
name|R_CR16_IMM32
case|:
case|case
name|R_CR16_IMM32a
case|:
case|case
name|R_CR16_REGREL4
case|:
case|case
name|R_CR16_REGREL4a
case|:
case|case
name|R_CR16_REGREL14
case|:
case|case
name|R_CR16_REGREL14a
case|:
case|case
name|R_CR16_REGREL16
case|:
case|case
name|R_CR16_REGREL20
case|:
case|case
name|R_CR16_ABS20
case|:
case|case
name|R_CR16_ABS24
case|:
case|case
name|R_CR16_DISP16
case|:
case|case
name|R_CR16_DISP24
case|:
comment|/* 'hit_data' is relative to the start of the instruction, not the            relocation offset. Advance it to account for the exact offset.  */
name|hit_data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|R_CR16_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
break|break;
case|case
name|R_CR16_DISP4
case|:
case|case
name|R_CR16_DISP8
case|:
case|case
name|R_CR16_DISP24a
case|:
comment|/* We only care about the addend, where the difference between           expressions is kept.  */
if|if
condition|(
name|is_local
condition|)
name|Rvalue
operator|-=
operator|-
literal|1
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
comment|/* Subtract the address of the section containing the location.  */
name|Rvalue
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Subtract the position of the location within the section.  */
name|Rvalue
operator|-=
name|offset
expr_stmt|;
block|}
comment|/* Add in supplied addend.  */
name|Rvalue
operator|+=
name|addend
expr_stmt|;
comment|/* Complain if the bitfield overflows, whether it is considered      as signed or unsigned.  */
name|check
operator|=
name|Rvalue
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Assumes two's complement.  This expression avoids      overflow if howto->bitsize is the number of bits in      bfd_vma.  */
name|reloc_bits
operator|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
operator|)
condition|)
block|{
comment|/* The above right shift is incorrect for a signed          value.  See if turning on the upper bits fixes the          overflow.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|Rvalue
operator|<
literal|0
condition|)
block|{
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
block|}
else|else
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* Drop unwanted bits from the value we are relocating to.  */
name|Rvalue
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Apply dst_mask to select only relocatable part of the insn.  */
name|Rvalue
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_CR16_IMM4
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_CR16_DISP4
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_CR16_DISP8
operator|)
condition|)
block|{
name|Rvalue1
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|Rvalue
operator|=
operator|(
operator|(
name|Rvalue1
operator|&
literal|0xf000
operator|)
operator||
operator|(
operator|(
name|Rvalue
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
operator||
operator|(
name|Rvalue1
operator|&
literal|0x00f0
operator|)
operator||
operator|(
name|Rvalue
operator|&
literal|0xf
operator|)
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|r_type
operator|==
name|R_CR16_DISP16
condition|)
block|{
name|Rvalue
operator||=
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|)
expr_stmt|;
name|Rvalue
operator|=
operator|(
operator|(
name|Rvalue
operator|&
literal|0xfffe
operator|)
operator||
operator|(
operator|(
name|Rvalue
operator|>>
literal|16
operator|)
operator|&
literal|0x1
operator|)
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|r_type
operator|==
name|R_CR16_ABS20
condition|)
block|{
name|Rvalue
operator||=
operator|(
operator|(
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
operator|)
operator|)
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|Rvalue
operator||=
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* Relocation on INSTRUCTIONS is different : Instructions are                word-addressable, that is, each word itself is arranged according                to little-endian convention, whereas the words are arranged with                respect to one another in BIG ENDIAN fashion.                When there is an immediate value that spans a word boundary,                it is split in a big-endian way with respect to the words.  */
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|Rvalue
operator|)
operator|&
literal|0xffff
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|Rvalue
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_CR16_ABS24
condition|)
block|{
name|Rvalue
operator|=
operator|(
operator|(
operator|(
operator|(
name|Rvalue
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
operator|(
name|Rvalue
operator|>>
literal|16
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|)
operator|)
operator||
operator|(
operator|(
name|Rvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_CR16_DISP24
condition|)
block|{
name|Rvalue
operator|=
operator|(
operator|(
operator|(
operator|(
name|Rvalue
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
operator|(
name|Rvalue
operator|>>
literal|16
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|Rvalue
operator|&
literal|0xfffE
operator|)
operator||
operator|(
operator|(
name|Rvalue
operator|>>
literal|24
operator|)
operator|&
literal|0x1
operator|)
operator|)
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_CR16_IMM32
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_CR16_IMM32a
operator|)
condition|)
block|{
name|Rvalue
operator|=
operator|(
operator|(
operator|(
name|Rvalue
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|)
operator|)
operator||
operator|(
operator|(
name|Rvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_CR16_DISP24a
condition|)
block|{
name|Rvalue
operator|=
operator|(
operator|(
operator|(
name|Rvalue
operator|&
literal|0xfffffe
operator|)
operator||
operator|(
name|Rvalue
operator|>>
literal|23
operator|)
operator|)
operator|)
expr_stmt|;
name|Rvalue
operator|=
operator|(
operator|(
name|Rvalue
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|Rvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_CR16_NUM32
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_CR16_NUM32a
operator|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_cr16_relax_delete_bytes
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|start_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
comment|/* Adjust the local symbols defined in this section.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
block|{
comment|/* Adjust the addend of SWITCH relocations in this section,              which reference this local symbol.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|rsym
decl_stmt|;
name|bfd_vma
name|addsym
decl_stmt|,
name|subsym
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|rsym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
operator|+
name|r_symndx
expr_stmt|;
comment|/* Skip if not the local adjusted symbol.  */
if|if
condition|(
name|rsym
operator|!=
name|isym
condition|)
continue|continue;
name|addsym
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
name|subsym
operator|=
name|addsym
operator|-
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* Fix the addend only when -->> (addsym> addr>= subsym).  */
if|if
condition|(
name|subsym
operator|<=
name|addr
condition|)
name|irel
operator|->
name|r_addend
operator|-=
name|count
expr_stmt|;
else|else
continue|continue;
block|}
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|start_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
comment|/* The '--wrap SYMBOL' option is causing a pain when the object file,          containing the definition of __wrap_SYMBOL, includes a direct          call to SYMBOL as well. Since both __wrap_SYMBOL and SYMBOL reference          the same symbol (which is __wrap_SYMBOL), but still exist as two          different symbols in 'sym_hashes', we don't want to adjust          the global symbol __wrap_SYMBOL twice.          This check is only relevant when symbols are being wrapped.  */
if|if
condition|(
name|link_info
operator|->
name|wrap_hash
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|cur_sym_hashes
decl_stmt|;
comment|/* Loop only over the symbols whom been already checked.  */
for|for
control|(
name|cur_sym_hashes
operator|=
name|start_hashes
init|;
name|cur_sym_hashes
operator|<
name|sym_hashes
condition|;
name|cur_sym_hashes
operator|++
control|)
comment|/* If the current symbol is identical to 'sym_hash', that means 	       the symbol was already adjusted (or at least checked).  */
if|if
condition|(
operator|*
name|cur_sym_hashes
operator|==
name|sym_hash
condition|)
break|break;
comment|/* Don't adjust the symbol again.  */
if|if
condition|(
name|cur_sym_hashes
operator|<
name|sym_hashes
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Relocate a CR16 ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_cr16_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|cr16_elf_howto_table
operator|+
operator|(
name|r_type
operator|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|cr16_elf_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses elf32_cr16_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|elf32_cr16_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf32_cr16_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the CR16.     There's quite a few relaxing opportunites available on the CR16:          * bcond:24 -> bcond:16                                2 bytes         * bcond:16 -> bcond:8                                2 bytes         * arithmetic imm32 -> arithmetic imm16                2 bytes     Symbol- and reloc-reading infrastructure copied from elf-m10200.c.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_cr16_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
comment|/* If this isn't something that can be relaxed, then ignore          this reloc.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CR16_DISP16
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CR16_DISP24
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* Go get them off disk.  */
elseif|else
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
comment|/* This appears to be a reference to an undefined                symbol.  Just ignore it--it will be caught by the                regular reloc processing.  */
continue|continue;
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section          contents, the section relocs, and the BFD symbol table.  We          must tell the rest of the code not to free up this          information.  It would be possible to instead create a table          of changes which have to be made, as is done in coff-mips.c;          that would be more work, but would require less memory when          the linker is run.  */
comment|/* Try to turn a 24  branch/call into a 16bit relative        * branch/call.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_CR16_DISP24
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 16 bits, note the high value is              0xfffe + 2 as the target will be two bytes closer if we are              able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x10000
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x10002
condition|)
block|{
name|unsigned
name|int
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
operator|(
name|unsigned
name|int
operator|)
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Verify it's a 'bcond' and fix the opcode.  */
if|if
condition|(
operator|(
name|code
operator|&
literal|0xffff
operator|)
operator|==
literal|0x0010
condition|)
block|{
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0x1800
operator||
operator|(
operator|(
literal|0xf
operator|&
operator|(
name|code
operator|>>
literal|20
operator|)
operator|)
operator|<<
literal|4
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_CR16_DISP16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_cr16_relax_delete_bytes
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again.                  Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to turn a 16bit pc-relative branch into an          8bit pc-relative branch.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_CR16_DISP16
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 8 bits, note the high value is              0xfc + 2 as the target will be two bytes closer if we are              able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0xfe
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x100
condition|)
block|{
name|unsigned
name|short
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Verify it's a 'bcond' opcode.  */
if|if
condition|(
operator|(
name|code
operator|&
literal|0xff00
operator|)
operator|==
literal|0x1800
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x1
operator||
operator|(
operator|(
literal|0xf
operator|&
operator|(
name|code
operator|>>
literal|4
operator|)
operator|)
operator|<<
literal|4
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_CR16_DISP8
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_cr16_relax_delete_bytes
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again.                  Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|// REVISIT: To support IMM relaxation in CR16 target
comment|/* Try to turn a 32bit immediate address into          a 20bit immediate address.  */
block|if (ELF32_R_TYPE (irel->r_info) == (int) R_CR16_IMM32)         {           bfd_vma value = symval;
comment|/* See if the value will fit in 20 bits.  */
block|if ((long) value< 0x7ffff&& (long) value> -0x80000)             {               unsigned short code;
comment|/* Get the opcode.  */
block|code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);
comment|/* Verify it's a 'arithmetic double'.  */
block|if ((code& 0xfff0) != 0x0070)                 continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
block|elf_section_data (sec)->relocs = internal_relocs;               elf_section_data (sec)->this_hdr.contents = contents;               symtab_hdr->contents = (unsigned char *) isymbuf;
comment|/* Fix the opcode.  */
block|bfd_put_8 (abfd, (code& 0xff) - 0x10, contents + irel->r_offset);
comment|/* Fix the relocation's type.  */
block|irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),                                            R_CR16_IMM20);
comment|/* Delete two bytes of data.  */
block|if (!elf32_cr16_relax_delete_bytes (link_info, abfd, sec,                                                    irel->r_offset + 2, 2))                 goto error_return;
comment|/* That will change things, so, we should relax again.                  Note that this is not required, and it may be slow.  */
block|*again = TRUE;             }         }
comment|/* Try to turn a 20bit/16bit immediate address into          a 4bit immediate address.  */
block|if ((ELF32_R_TYPE (irel->r_info) == (int) R_CR16_IMM20) 	  || (ELF32_R_TYPE (irel->r_info) == (int) R_CR16_IMM16))         {           bfd_vma value = symval;
comment|/* See if the value will fit in 4 bits.  */
block|if ((long) value< 0x7&& (long) value> -0x8)             {               unsigned short code;
comment|/* Get the opcode.  */
block|code = (unsigned short) bfd_get_8 (abfd, contents + irel->r_offset);
comment|/* Verify it's a 'arithmetic double'.  */
block|if (((code& 0xff) != 0x50) || ((code& 0xff) != 0x45))                 continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
block|elf_section_data (sec)->relocs = internal_relocs;               elf_section_data (sec)->this_hdr.contents = contents;               symtab_hdr->contents = (unsigned char *) isymbuf;
comment|/* Fix the opcode.  */
block|bfd_put_8 (abfd, (code& 0xff) - 0x10, contents + irel->r_offset);
comment|/* Fix the relocation's type.  */
block|irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),                                            R_CR16_IMM4);
comment|/* Delete two bytes of data.  */
block|if (!elf32_cr16_relax_delete_bytes (link_info, abfd, sec,                                                    irel->r_offset + 2, 2))                 goto error_return;
comment|/* That will change things, so, we should relax again.                  Note that this is not required, and it may be slow.  */
block|*again = TRUE;             }         }
endif|#
directive|endif
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|elf32_cr16_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_cr16_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We don't support garbage collection of GOT and PLT relocs yet.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Definitions for setting CR16 target vector.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_cr16_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-cr16"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_cr16
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_CR16
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_cr16_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
value|elf_cr16_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_cr16_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_cr16_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|elf32_cr16_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|elf32_cr16_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_cr16_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_cr16_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

