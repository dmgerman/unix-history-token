begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD backend for SunOS binaries.    Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Written by Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|TARGETNAME
value|"a.out-sunos-big"
end_define

begin_comment
comment|/* Do not "beautify" the CONCAT* macro args.  Traditional C will not    remove whitespace added here, and thus will fail to concatenate    the tokens.  */
end_comment

begin_define
define|#
directive|define
name|MY
parameter_list|(
name|OP
parameter_list|)
value|CONCAT2 (sunos_big_,OP)
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* ??? Where should this go?  */
end_comment

begin_define
define|#
directive|define
name|MACHTYPE_OK
parameter_list|(
name|mtype
parameter_list|)
define|\
value|(((mtype) == M_SPARC&& bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \    || ((mtype) == M_SPARCLET \&& bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \    || ((mtype) == M_SPARCLITE_LE \&& bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \    || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \&& bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))
end_define

begin_define
define|#
directive|define
name|MY_get_dynamic_symtab_upper_bound
value|sunos_get_dynamic_symtab_upper_bound
end_define

begin_define
define|#
directive|define
name|MY_canonicalize_dynamic_symtab
value|sunos_canonicalize_dynamic_symtab
end_define

begin_define
define|#
directive|define
name|MY_get_synthetic_symtab
value|_bfd_nodynamic_get_synthetic_symtab
end_define

begin_define
define|#
directive|define
name|MY_get_dynamic_reloc_upper_bound
value|sunos_get_dynamic_reloc_upper_bound
end_define

begin_define
define|#
directive|define
name|MY_canonicalize_dynamic_reloc
value|sunos_canonicalize_dynamic_reloc
end_define

begin_define
define|#
directive|define
name|MY_bfd_link_hash_table_create
value|sunos_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|MY_add_dynamic_symbols
value|sunos_add_dynamic_symbols
end_define

begin_define
define|#
directive|define
name|MY_add_one_symbol
value|sunos_add_one_symbol
end_define

begin_define
define|#
directive|define
name|MY_link_dynamic_object
value|sunos_link_dynamic_object
end_define

begin_define
define|#
directive|define
name|MY_write_dynamic_symbol
value|sunos_write_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|MY_check_dynamic_reloc
value|sunos_check_dynamic_reloc
end_define

begin_define
define|#
directive|define
name|MY_finish_dynamic_link
value|sunos_finish_dynamic_link
end_define

begin_function_decl
specifier|static
name|bfd_boolean
name|sunos_add_dynamic_symbols
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|external_nlist
modifier|*
modifier|*
parameter_list|,
name|bfd_size_type
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sunos_add_one_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|flagword
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|bfd_boolean
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sunos_link_dynamic_object
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sunos_write_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|aout_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sunos_check_dynamic_reloc
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|aout_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sunos_finish_dynamic_link
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sunos_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|sunos_get_dynamic_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|sunos_canonicalize_dynamic_symtab
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|sunos_get_dynamic_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|sunos_canonicalize_dynamic_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
modifier|*
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Include the usual a.out support.  */
end_comment

begin_include
include|#
directive|include
file|"aoutf1.h"
end_include

begin_comment
comment|/* The SunOS 4.1.4 /usr/include/locale.h defines valid as a macro.  */
end_comment

begin_undef
undef|#
directive|undef
name|valid
end_undef

begin_comment
comment|/* SunOS shared library support.  We store a pointer to this structure    in obj_aout_dynamic_info (abfd).  */
end_comment

begin_struct
struct|struct
name|sunos_dynamic_info
block|{
comment|/* Whether we found any dynamic information.  */
name|bfd_boolean
name|valid
decl_stmt|;
comment|/* Dynamic information.  */
name|struct
name|internal_sun4_dynamic_link
name|dyninfo
decl_stmt|;
comment|/* Number of dynamic symbols.  */
name|unsigned
name|long
name|dynsym_count
decl_stmt|;
comment|/* Read in nlists for dynamic symbols.  */
name|struct
name|external_nlist
modifier|*
name|dynsym
decl_stmt|;
comment|/* asymbol structures for dynamic symbols.  */
name|aout_symbol_type
modifier|*
name|canonical_dynsym
decl_stmt|;
comment|/* Read in dynamic string table.  */
name|char
modifier|*
name|dynstr
decl_stmt|;
comment|/* Number of dynamic relocs.  */
name|unsigned
name|long
name|dynrel_count
decl_stmt|;
comment|/* Read in dynamic relocs.  This may be reloc_std_external or      reloc_ext_external.  */
name|void
modifier|*
name|dynrel
decl_stmt|;
comment|/* arelent structures for dynamic relocs.  */
name|arelent
modifier|*
name|canonical_dynrel
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The hash table of dynamic symbols is composed of two word entries.    See include/aout/sun4.h for details.  */
end_comment

begin_define
define|#
directive|define
name|HASH_ENTRY_SIZE
value|(2 * BYTES_IN_WORD)
end_define

begin_comment
comment|/* Read in the basic dynamic information.  This locates the __DYNAMIC    structure and uses it to find the dynamic_link structure.  It    creates and saves a sunos_dynamic_info structure.  If it can't find    __DYNAMIC, it sets the valid field of the sunos_dynamic_info    structure to FALSE to avoid doing this work again.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_read_dynamic_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|sunos_dynamic_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|dynsec
decl_stmt|;
name|bfd_vma
name|dynoff
decl_stmt|;
name|struct
name|external_sun4_dynamic
name|dyninfo
decl_stmt|;
name|unsigned
name|long
name|dynver
decl_stmt|;
name|struct
name|external_sun4_dynamic_link
name|linkinfo
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sunos_dynamic_info
argument_list|)
expr_stmt|;
name|info
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
name|info
operator|->
name|dynsym
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|dynstr
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|canonical_dynsym
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|dynrel
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|canonical_dynrel
operator|=
name|NULL
expr_stmt|;
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|info
expr_stmt|;
comment|/* This code used to look for the __DYNAMIC symbol to locate the dynamic      linking information.      However this inhibits recovering the dynamic symbols from a      stripped object file, so blindly assume that the dynamic linking      information is located at the start of the data section.      We could verify this assumption later by looking through the dynamic      symbols for the __DYNAMIC symbol.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|dyninfo
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|dyninfo
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|dynver
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|dyninfo
operator|.
name|ld_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynver
operator|!=
literal|2
operator|&&
name|dynver
operator|!=
literal|3
condition|)
return|return
name|TRUE
return|;
name|dynoff
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|dyninfo
operator|.
name|ld
argument_list|)
expr_stmt|;
comment|/* dynoff is a virtual address.  It is probably always in the .data      section, but this code should work even if it moves.  */
if|if
condition|(
name|dynoff
operator|<
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
name|dynsec
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|dynsec
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|dynoff
operator|-=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|dynsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynoff
operator|>
name|dynsec
operator|->
name|size
condition|)
return|return
name|TRUE
return|;
comment|/* This executable appears to be dynamically linked in a way that we      can understand.  */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|dynsec
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|linkinfo
argument_list|,
operator|(
name|file_ptr
operator|)
name|dynoff
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|linkinfo
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Swap in the dynamic link information.  */
name|info
operator|->
name|dyninfo
operator|.
name|ld_loaded
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_loaded
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_need
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_need
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_rules
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_rules
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_got
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_got
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_plt
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_plt
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_rel
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_rel
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_hash
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_hash
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_stab
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_stab
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_stab_hash
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_stab_hash
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_buckets
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_buckets
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_symbols
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_symbols
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_symb_size
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_symb_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_text
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_text
argument_list|)
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_plt_sz
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|linkinfo
operator|.
name|ld_plt_sz
argument_list|)
expr_stmt|;
comment|/* Reportedly the addresses need to be offset by the size of the      exec header in an NMAGIC file.  */
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|==
name|n_magic
condition|)
block|{
name|unsigned
name|long
name|exec_bytes_size
init|=
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
decl_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_need
operator|+=
name|exec_bytes_size
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_rules
operator|+=
name|exec_bytes_size
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_rel
operator|+=
name|exec_bytes_size
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_hash
operator|+=
name|exec_bytes_size
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_stab
operator|+=
name|exec_bytes_size
expr_stmt|;
name|info
operator|->
name|dyninfo
operator|.
name|ld_symbols
operator|+=
name|exec_bytes_size
expr_stmt|;
block|}
comment|/* The only way to get the size of the symbol information appears to      be to determine the distance between it and the string table.  */
name|info
operator|->
name|dynsym_count
operator|=
operator|(
operator|(
name|info
operator|->
name|dyninfo
operator|.
name|ld_symbols
operator|-
name|info
operator|->
name|dyninfo
operator|.
name|ld_stab
operator|)
operator|/
name|EXTERNAL_NLIST_SIZE
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|info
operator|->
name|dynsym_count
operator|*
name|EXTERNAL_NLIST_SIZE
operator|==
call|(
name|unsigned
name|long
call|)
argument_list|(
name|info
operator|->
name|dyninfo
operator|.
name|ld_symbols
operator|-
name|info
operator|->
name|dyninfo
operator|.
name|ld_stab
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Similarly, the relocs end at the hash table.  */
name|info
operator|->
name|dynrel_count
operator|=
operator|(
operator|(
name|info
operator|->
name|dyninfo
operator|.
name|ld_hash
operator|-
name|info
operator|->
name|dyninfo
operator|.
name|ld_rel
operator|)
operator|/
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|info
operator|->
name|dynrel_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|==
call|(
name|unsigned
name|long
call|)
argument_list|(
name|info
operator|->
name|dyninfo
operator|.
name|ld_hash
operator|-
name|info
operator|->
name|dyninfo
operator|.
name|ld_rel
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of memory required for the dynamic symbols.  */
end_comment

begin_function
specifier|static
name|long
name|sunos_get_dynamic_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|sunos_dynamic_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
operator|!
name|sunos_read_dynamic_info
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|info
operator|=
operator|(
expr|struct
name|sunos_dynamic_info
operator|*
operator|)
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|valid
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|info
operator|->
name|dynsym_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the external dynamic symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_slurp_dynamic_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|sunos_dynamic_info
modifier|*
name|info
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Get the general dynamic information.  */
if|if
condition|(
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_read_dynamic_info
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|info
operator|=
operator|(
expr|struct
name|sunos_dynamic_info
operator|*
operator|)
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|valid
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Get the dynamic nlist structures.  */
if|if
condition|(
name|info
operator|->
name|dynsym
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|info
operator|->
name|dynsym_count
operator|*
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
name|info
operator|->
name|dynsym
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|dynsym
operator|==
name|NULL
operator|&&
name|info
operator|->
name|dynsym_count
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|info
operator|->
name|dyninfo
operator|.
name|ld_stab
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|info
operator|->
name|dynsym
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|dynsym
operator|!=
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|dynsym
argument_list|)
expr_stmt|;
name|info
operator|->
name|dynsym
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Get the dynamic strings.  */
if|if
condition|(
name|info
operator|->
name|dynstr
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
name|info
operator|->
name|dyninfo
operator|.
name|ld_symb_size
expr_stmt|;
name|info
operator|->
name|dynstr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|dynstr
operator|==
name|NULL
operator|&&
name|info
operator|->
name|dyninfo
operator|.
name|ld_symb_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|info
operator|->
name|dyninfo
operator|.
name|ld_symbols
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|info
operator|->
name|dynstr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|dynstr
operator|!=
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|dynstr
argument_list|)
expr_stmt|;
name|info
operator|->
name|dynstr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read in the dynamic symbols.  */
end_comment

begin_function
specifier|static
name|long
name|sunos_canonicalize_dynamic_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|storage
parameter_list|)
block|{
name|struct
name|sunos_dynamic_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sunos_slurp_dynamic_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|info
operator|=
operator|(
expr|struct
name|sunos_dynamic_info
operator|*
operator|)
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHECK_DYNAMIC_HASH
comment|/* Check my understanding of the dynamic hash table by making sure      that each symbol can be located in the hash table.  */
block|{
name|bfd_size_type
name|table_size
decl_stmt|;
name|bfd_byte
modifier|*
name|table
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|dyninfo
operator|.
name|ld_buckets
operator|>
name|info
operator|->
name|dynsym_count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|table_size
operator|=
name|info
operator|->
name|dyninfo
operator|.
name|ld_stab
operator|-
name|info
operator|->
name|dyninfo
operator|.
name|ld_hash
expr_stmt|;
name|table
operator|=
name|bfd_malloc
argument_list|(
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
operator|&&
name|table_size
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|info
operator|->
name|dyninfo
operator|.
name|ld_hash
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|table
argument_list|,
name|table_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|table_size
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|dynsym_count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|name
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|info
operator|->
name|dynstr
operator|+
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|dynsym
index|[
name|i
index|]
operator|.
name|e_strx
argument_list|)
operator|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
name|hash
operator|=
operator|(
name|hash
operator|<<
literal|1
operator|)
operator|+
operator|*
name|name
operator|++
expr_stmt|;
name|hash
operator|&=
literal|0x7fffffff
expr_stmt|;
name|hash
operator|%=
name|info
operator|->
name|dyninfo
operator|.
name|ld_buckets
expr_stmt|;
while|while
condition|(
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|table
operator|+
name|hash
operator|*
name|HASH_ENTRY_SIZE
argument_list|)
operator|!=
name|i
condition|)
block|{
name|hash
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|table
operator|+
name|hash
operator|*
name|HASH_ENTRY_SIZE
operator|+
name|BYTES_IN_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
literal|0
operator|||
name|hash
operator|>=
name|table_size
operator|/
name|HASH_ENTRY_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CHECK_DYNAMIC_HASH */
comment|/* Get the asymbol structures corresponding to the dynamic nlist      structures.  */
if|if
condition|(
name|info
operator|->
name|canonical_dynsym
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|strsize
init|=
name|info
operator|->
name|dyninfo
operator|.
name|ld_symb_size
decl_stmt|;
name|size
operator|=
operator|(
name|bfd_size_type
operator|)
name|info
operator|->
name|dynsym_count
operator|*
sizeof|sizeof
argument_list|(
name|aout_symbol_type
argument_list|)
expr_stmt|;
name|info
operator|->
name|canonical_dynsym
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|canonical_dynsym
operator|==
name|NULL
operator|&&
name|info
operator|->
name|dynsym_count
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|aout_32_translate_symbol_table
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|canonical_dynsym
argument_list|,
name|info
operator|->
name|dynsym
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|info
operator|->
name|dynsym_count
argument_list|,
name|info
operator|->
name|dynstr
argument_list|,
name|strsize
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|canonical_dynsym
operator|!=
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|canonical_dynsym
argument_list|)
expr_stmt|;
name|info
operator|->
name|canonical_dynsym
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Return pointers to the dynamic asymbol structures.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|dynsym_count
condition|;
name|i
operator|++
control|)
operator|*
name|storage
operator|++
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|(
name|info
operator|->
name|canonical_dynsym
operator|+
name|i
operator|)
expr_stmt|;
operator|*
name|storage
operator|=
name|NULL
expr_stmt|;
return|return
name|info
operator|->
name|dynsym_count
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of memory required for the dynamic relocs.  */
end_comment

begin_function
specifier|static
name|long
name|sunos_get_dynamic_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|sunos_dynamic_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
operator|!
name|sunos_read_dynamic_info
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|info
operator|=
operator|(
expr|struct
name|sunos_dynamic_info
operator|*
operator|)
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|valid
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|info
operator|->
name|dynrel_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read in the dynamic relocs.  */
end_comment

begin_function
specifier|static
name|long
name|sunos_canonicalize_dynamic_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
modifier|*
name|storage
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|syms
parameter_list|)
block|{
name|struct
name|sunos_dynamic_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Get the general dynamic information.  */
if|if
condition|(
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_read_dynamic_info
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|info
operator|=
operator|(
expr|struct
name|sunos_dynamic_info
operator|*
operator|)
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|valid
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the dynamic reloc information.  */
if|if
condition|(
name|info
operator|->
name|dynrel
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
operator|(
name|bfd_size_type
operator|)
name|info
operator|->
name|dynrel_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|info
operator|->
name|dynrel
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|dynrel
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|info
operator|->
name|dyninfo
operator|.
name|ld_rel
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|info
operator|->
name|dynrel
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|dynrel
operator|!=
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|dynrel
argument_list|)
expr_stmt|;
name|info
operator|->
name|dynrel
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Get the arelent structures corresponding to the dynamic reloc      information.  */
if|if
condition|(
name|info
operator|->
name|canonical_dynrel
operator|==
name|NULL
condition|)
block|{
name|arelent
modifier|*
name|to
decl_stmt|;
name|size
operator|=
operator|(
name|bfd_size_type
operator|)
name|info
operator|->
name|dynrel_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|info
operator|->
name|canonical_dynrel
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|canonical_dynrel
operator|==
name|NULL
operator|&&
name|info
operator|->
name|dynrel_count
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|to
operator|=
name|info
operator|->
name|canonical_dynrel
expr_stmt|;
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|==
name|RELOC_EXT_SIZE
condition|)
block|{
name|struct
name|reloc_ext_external
modifier|*
name|p
decl_stmt|;
name|struct
name|reloc_ext_external
modifier|*
name|pend
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|info
operator|->
name|dynrel
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|info
operator|->
name|dynrel_count
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
condition|;
name|p
operator|++
operator|,
name|to
operator|++
control|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_ext_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|to
argument_list|,
name|syms
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|info
operator|->
name|dynsym_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|reloc_std_external
modifier|*
name|p
decl_stmt|;
name|struct
name|reloc_std_external
modifier|*
name|pend
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|info
operator|->
name|dynrel
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|info
operator|->
name|dynrel_count
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
condition|;
name|p
operator|++
operator|,
name|to
operator|++
control|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_std_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|to
argument_list|,
name|syms
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|info
operator|->
name|dynsym_count
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return pointers to the dynamic arelent structures.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|dynrel_count
condition|;
name|i
operator|++
control|)
operator|*
name|storage
operator|++
operator|=
name|info
operator|->
name|canonical_dynrel
operator|+
name|i
expr_stmt|;
operator|*
name|storage
operator|=
name|NULL
expr_stmt|;
return|return
name|info
operator|->
name|dynrel_count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code to handle linking of SunOS shared libraries.  */
end_comment

begin_comment
comment|/* A SPARC procedure linkage table entry is 12 bytes.  The first entry    in the table is a jump which is filled in by the runtime linker.    The remaining entries are branches back to the first entry,    followed by an index into the relocation table encoded to look like    a sethi of %g0.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_PLT_ENTRY_SIZE
value|(12)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|sparc_plt_first_entry
index|[
name|SPARC_PLT_ENTRY_SIZE
index|]
init|=
block|{
comment|/* sethi %hi(0),%g1; address filled in by runtime linker.  */
literal|0x3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* jmp %g1; offset filled in by runtime linker.  */
literal|0x81
block|,
literal|0xc0
block|,
literal|0x60
block|,
literal|0
block|,
comment|/* nop */
literal|0x1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save %sp, -96, %sp */
end_comment

begin_define
define|#
directive|define
name|SPARC_PLT_ENTRY_WORD0
value|((bfd_vma) 0x9de3bfa0)
end_define

begin_comment
comment|/* call; address filled in later.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_PLT_ENTRY_WORD1
value|((bfd_vma) 0x40000000)
end_define

begin_comment
comment|/* sethi; reloc index filled in later.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_PLT_ENTRY_WORD2
value|((bfd_vma) 0x01000000)
end_define

begin_comment
comment|/* This sequence is used when for the jump table entry to a defined    symbol in a complete executable.  It is used when linking PIC    compiled code which is not being put into a shared library.  */
end_comment

begin_comment
comment|/* sethi<address to be filled in later>, %g1 */
end_comment

begin_define
define|#
directive|define
name|SPARC_PLT_PIC_WORD0
value|((bfd_vma) 0x03000000)
end_define

begin_comment
comment|/* jmp %g1 +<address to be filled in later> */
end_comment

begin_define
define|#
directive|define
name|SPARC_PLT_PIC_WORD1
value|((bfd_vma) 0x81c06000)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|SPARC_PLT_PIC_WORD2
value|((bfd_vma) 0x01000000)
end_define

begin_comment
comment|/* An m68k procedure linkage table entry is 8 bytes.  The first entry    in the table is a jump which is filled in the by the runtime    linker.  The remaining entries are branches back to the first    entry, followed by a two byte index into the relocation table.  */
end_comment

begin_define
define|#
directive|define
name|M68K_PLT_ENTRY_SIZE
value|(8)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|m68k_plt_first_entry
index|[
name|M68K_PLT_ENTRY_SIZE
index|]
init|=
block|{
comment|/* jmps @# */
literal|0x4e
block|,
literal|0xf9
block|,
comment|/* Filled in by runtime linker with a magic address.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Not used?  */
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bsrl */
end_comment

begin_define
define|#
directive|define
name|M68K_PLT_ENTRY_WORD0
value|((bfd_vma) 0x61ff)
end_define

begin_comment
comment|/* Remaining words filled in later.  */
end_comment

begin_comment
comment|/* An entry in the SunOS linker hash table.  */
end_comment

begin_struct
struct|struct
name|sunos_link_hash_entry
block|{
name|struct
name|aout_link_hash_entry
name|root
decl_stmt|;
comment|/* If this is a dynamic symbol, this is its index into the dynamic      symbol table.  This is initialized to -1.  As the linker looks at      the input files, it changes this to -2 if it will be added to the      dynamic symbol table.  After all the input files have been seen,      the linker will know whether to build a dynamic symbol table; if      it does build one, this becomes the index into the table.  */
name|long
name|dynindx
decl_stmt|;
comment|/* If this is a dynamic symbol, this is the index of the name in the      dynamic symbol string table.  */
name|long
name|dynstr_index
decl_stmt|;
comment|/* The offset into the global offset table used for this symbol.  If      the symbol does not require a GOT entry, this is 0.  */
name|bfd_vma
name|got_offset
decl_stmt|;
comment|/* The offset into the procedure linkage table used for this symbol.      If the symbol does not require a PLT entry, this is 0.  */
name|bfd_vma
name|plt_offset
decl_stmt|;
comment|/* Some linker flags.  */
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* Symbol is referenced by a regular object.  */
define|#
directive|define
name|SUNOS_REF_REGULAR
value|01
comment|/* Symbol is defined by a regular object.  */
define|#
directive|define
name|SUNOS_DEF_REGULAR
value|02
comment|/* Symbol is referenced by a dynamic object.  */
define|#
directive|define
name|SUNOS_REF_DYNAMIC
value|04
comment|/* Symbol is defined by a dynamic object.  */
define|#
directive|define
name|SUNOS_DEF_DYNAMIC
value|010
comment|/* Symbol is a constructor symbol in a regular object.  */
define|#
directive|define
name|SUNOS_CONSTRUCTOR
value|020
block|}
struct|;
end_struct

begin_comment
comment|/* The SunOS linker hash table.  */
end_comment

begin_struct
struct|struct
name|sunos_link_hash_table
block|{
name|struct
name|aout_link_hash_table
name|root
decl_stmt|;
comment|/* The object which holds the dynamic sections.  */
name|bfd
modifier|*
name|dynobj
decl_stmt|;
comment|/* Whether we have created the dynamic sections.  */
name|bfd_boolean
name|dynamic_sections_created
decl_stmt|;
comment|/* Whether we need the dynamic sections.  */
name|bfd_boolean
name|dynamic_sections_needed
decl_stmt|;
comment|/* Whether we need the .got table.  */
name|bfd_boolean
name|got_needed
decl_stmt|;
comment|/* The number of dynamic symbols.  */
name|size_t
name|dynsymcount
decl_stmt|;
comment|/* The number of buckets in the hash table.  */
name|size_t
name|bucketcount
decl_stmt|;
comment|/* The list of dynamic objects needed by dynamic objects included in      the link.  */
name|struct
name|bfd_link_needed_list
modifier|*
name|needed
decl_stmt|;
comment|/* The offset of __GLOBAL_OFFSET_TABLE_ into the .got section.  */
name|bfd_vma
name|got_base
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Routine to create an entry in an SunOS link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|sunos_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|sunos_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_newfunc
argument_list|)
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|dynstr_index
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|got_offset
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|plt_offset
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a SunOS link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sunos_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|sunos_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|sunos_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_table_init
argument_list|)
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|sunos_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sunos_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|dynobj
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|dynamic_sections_created
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|dynamic_sections_needed
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|got_needed
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|dynsymcount
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|bucketcount
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|needed
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|got_base
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in an SunOS link hash table.  */
end_comment

begin_define
define|#
directive|define
name|sunos_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct sunos_link_hash_entry *) \    aout_link_hash_lookup (&(table)->root, (string), (create), (copy),\ 			  (follow)))
end_define

begin_comment
comment|/* Traverse a SunOS link hash table.  */
end_comment

begin_define
define|#
directive|define
name|sunos_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(aout_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) (struct aout_link_hash_entry *, void *)) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the SunOS link hash table from the info structure.  This is    just a cast.  */
end_comment

begin_define
define|#
directive|define
name|sunos_hash_table
parameter_list|(
name|p
parameter_list|)
value|((struct sunos_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create the dynamic sections needed if we are linking against a    dynamic object, or if we are linking PIC compiled code.  ABFD is a    bfd we can attach the dynamic sections to.  The linker script will    look for these special sections names and put them in the right    place in the output file.  See include/aout/sun4.h for more details    of the dynamic linking information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|needed
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
comment|/* The .dynamic section holds the basic dynamic information: the 	 sun4_dynamic structure, the dynamic debugger information, and 	 the sun4_dynamic_link structure.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .got section holds the global offset table.  The address 	 is put in the ld_got field.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .plt section holds the procedure linkage table.  The 	 address is put in the ld_plt field.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .dynrel section holds the dynamic relocs.  The address is 	 put in the ld_rel field.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynrel"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .hash section holds the dynamic hash table.  The address 	 is put in the ld_hash field.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .dynsym section holds the dynamic symbols.  The address 	 is put in the ld_stab field.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .dynstr section holds the dynamic symbol string table. 	 The address is put in the ld_symbols field.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|needed
operator|&&
operator|!
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_needed
operator|)
operator|||
name|info
operator|->
name|shared
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|=
name|BYTES_IN_WORD
expr_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_needed
operator|=
name|TRUE
expr_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_needed
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add dynamic symbols during a link.  This is called by the a.out    backend linker for each object it encounters.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_add_dynamic_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|external_nlist
modifier|*
modifier|*
name|symsp
parameter_list|,
name|bfd_size_type
modifier|*
name|sym_countp
parameter_list|,
name|char
modifier|*
modifier|*
name|stringsp
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|sunos_dynamic_info
modifier|*
name|dinfo
decl_stmt|;
name|unsigned
name|long
name|need
decl_stmt|;
comment|/* Make sure we have all the required sections.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* There is nothing else to do for a normal object.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* We do not want to include the sections in a dynamic object in the      output file.  We hack by simply clobbering the list of sections      in the BFD.  This could be handled more cleanly by, say, a new      section flag; the existing SEC_NEVER_LOAD flag is not the one we      want, because that one still implies that the section takes up      space in the output file.  If this is the first object we have      seen, we must preserve the dynamic sections we just created.  */
if|if
condition|(
name|abfd
operator|!=
name|dynobj
condition|)
name|abfd
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The native linker seems to just ignore dynamic objects when -r is      used.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* There's no hope of using a dynamic object which does not exactly      match the format of the output file.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make sure we have a .need and a .rules sections.  These are only      needed if there really is a dynamic object in the link, so they      are not added by sunos_create_dynamic_sections.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".need"
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* The .need section holds the list of names of shared objets 	 which must be included at runtime.  The address of this 	 section is put in the ld_need field.  */
name|flagword
name|flags
init|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator|)
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".need"
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rules"
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* The .rules section holds the path to search for shared 	 objects.  The address of this section is put in the ld_rules 	 field.  */
name|flagword
name|flags
init|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator|)
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rules"
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Pick up the dynamic symbols and return them to the caller.  */
if|if
condition|(
operator|!
name|sunos_slurp_dynamic_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dinfo
operator|=
operator|(
expr|struct
name|sunos_dynamic_info
operator|*
operator|)
name|obj_aout_dynamic_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|*
name|symsp
operator|=
name|dinfo
operator|->
name|dynsym
expr_stmt|;
operator|*
name|sym_countp
operator|=
name|dinfo
operator|->
name|dynsym_count
expr_stmt|;
operator|*
name|stringsp
operator|=
name|dinfo
operator|->
name|dynstr
expr_stmt|;
comment|/* Record information about any other objects needed by this one.  */
name|need
operator|=
name|dinfo
operator|->
name|dyninfo
operator|.
name|ld_need
expr_stmt|;
while|while
condition|(
name|need
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|long
name|name
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|short
name|major_vno
decl_stmt|,
name|minor_vno
decl_stmt|;
name|struct
name|bfd_link_needed_list
modifier|*
name|needed
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|alc
decl_stmt|;
name|bfd_byte
name|b
decl_stmt|;
name|char
modifier|*
name|namecopy
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|need
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|16
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|16
condition|)
return|return
name|FALSE
return|;
comment|/* For the format of an ld_need entry, see aout/sun4.h.  We 	 should probably define structs for this manipulation.  */
name|name
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|major_vno
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
operator|+
literal|8
argument_list|)
expr_stmt|;
name|minor_vno
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
operator|+
literal|10
argument_list|)
expr_stmt|;
name|need
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
operator|+
literal|12
argument_list|)
expr_stmt|;
name|alc
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
expr_stmt|;
name|needed
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|needed
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
comment|/* We return the name as [-l]name[.maj][.min].  */
name|alc
operator|=
literal|30
expr_stmt|;
name|namebuf
operator|=
name|bfd_malloc
argument_list|(
name|alc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|namebuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|namebuf
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'l'
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|name
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
do|do
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|namebuf
argument_list|)
operator|>=
name|alc
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|alc
operator|*=
literal|2
expr_stmt|;
name|n
operator|=
name|bfd_realloc
argument_list|(
name|namebuf
argument_list|,
name|alc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|=
name|n
operator|+
operator|(
name|p
operator|-
name|namebuf
operator|)
expr_stmt|;
name|namebuf
operator|=
name|n
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|b
expr_stmt|;
block|}
do|while
condition|(
name|b
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|major_vno
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|char
name|majbuf
index|[
literal|30
index|]
decl_stmt|;
name|char
name|minbuf
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|majbuf
argument_list|,
literal|".%d"
argument_list|,
name|major_vno
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor_vno
operator|==
literal|0
condition|)
name|minbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|minbuf
argument_list|,
literal|".%d"
argument_list|,
name|minor_vno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|-
name|namebuf
operator|)
operator|+
name|strlen
argument_list|(
name|majbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|minbuf
argument_list|)
operator|>=
name|alc
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|alc
operator|=
operator|(
name|p
operator|-
name|namebuf
operator|)
operator|+
name|strlen
argument_list|(
name|majbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|minbuf
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_realloc
argument_list|(
name|namebuf
argument_list|,
name|alc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|=
name|n
operator|+
operator|(
name|p
operator|-
name|namebuf
operator|)
expr_stmt|;
name|namebuf
operator|=
name|n
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|majbuf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|minbuf
argument_list|)
expr_stmt|;
block|}
name|namecopy
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|namecopy
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|strcpy
argument_list|(
name|namecopy
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|needed
operator|->
name|name
operator|=
name|namecopy
expr_stmt|;
name|needed
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|needed
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|needed
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to add a single symbol to the linker hash table.  This is    a wrapper around _bfd_generic_link_add_one_symbol which handles the    tweaking needed for dynamic linking support.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_add_one_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|flagword
name|flags
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|bfd_boolean
name|copy
parameter_list|,
name|bfd_boolean
name|collect
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
modifier|*
name|hashp
parameter_list|)
block|{
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|new_flag
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|BSF_INDIRECT
operator||
name|BSF_WARNING
operator||
name|BSF_CONSTRUCTOR
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
name|h
operator|=
name|sunos_link_hash_lookup
argument_list|(
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
operator|(
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|*
name|hashp
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Treat a common symbol in a dynamic object as defined in the .bss      section of the dynamic object.  We don't want to allocate space      for it in our process image.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_new
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* We are defining the symbol, and it is already defined.  This 	 is a potential multiple definition error.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The definition we are adding is from a dynamic object. 	     We do not want this new definition to override the 	     existing definition, so we pretend it is just a 	     reference.  */
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The existing definition is from a dynamic object.  We 	     want to override it with the definition we just found. 	     Clobber the existing definition.  */
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The existing definition is from a dynamic object.  We 	     want to override it with the definition we just found. 	     Clobber the existing definition.  We can't set it to new, 	     because it is on the undefined list.  */
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_CONSTRUCTOR
operator|)
operator|!=
literal|0
condition|)
comment|/* The existing symbol is a constructor symbol, and this symbol        is from a dynamic object.  A constructor symbol is actually a        definition, although the type will be bfd_link_hash_undefined        at this point.  We want to ignore the definition from the        dynamic object.  */
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
comment|/* The existing symbol is defined by a dynamic object, and this        is a constructor symbol.  As above, we want to force the use        of the constructor symbol from the regular object.  */
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_new
expr_stmt|;
comment|/* Do the usual procedure for adding a symbol.  */
if|if
condition|(
operator|!
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|section
argument_list|,
name|value
argument_list|,
name|string
argument_list|,
name|copy
argument_list|,
name|collect
argument_list|,
name|hashp
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
block|{
comment|/* Set a flag in the hash table entry indicating the type of 	 reference or definition we just found.  Keep a count of the 	 number of dynamic symbols we find.  A dynamic symbol is one 	 which is referenced or defined by both a regular object and a 	 shared object.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
name|new_flag
operator|=
name|SUNOS_REF_REGULAR
expr_stmt|;
else|else
name|new_flag
operator|=
name|SUNOS_DEF_REGULAR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
name|new_flag
operator|=
name|SUNOS_REF_DYNAMIC
expr_stmt|;
else|else
name|new_flag
operator|=
name|SUNOS_DEF_DYNAMIC
expr_stmt|;
block|}
name|h
operator|->
name|flags
operator||=
name|new_flag
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
operator|(
name|SUNOS_DEF_REGULAR
operator||
name|SUNOS_REF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|h
operator|->
name|dynindx
operator|=
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
name|h
operator|->
name|flags
operator||=
name|SUNOS_CONSTRUCTOR
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function_decl
specifier|extern
specifier|const
name|bfd_target
name|MY
parameter_list|(
name|vec
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the list of objects needed by BFD.  */
end_comment

begin_function
name|struct
name|bfd_link_needed_list
modifier|*
name|bfd_sunos_get_needed_list
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
operator|&
name|MY
argument_list|(
name|vec
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|needed
return|;
block|}
end_function

begin_comment
comment|/* Record an assignment made to a symbol by a linker script.  We need    this in case some dynamic object refers to this symbol.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_sunos_record_link_assignment
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|->
name|xvec
operator|!=
operator|&
name|MY
argument_list|(
name|vec
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* This is called after we have examined all the input objects.  If      the symbol does not exist, it merely means that no object refers      to it, and we can just ignore it at this point.  */
name|h
operator|=
name|sunos_link_hash_lookup
argument_list|(
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In a shared library, the __DYNAMIC symbol does not appear in the      dynamic symbol table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__DYNAMIC"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|->
name|flags
operator||=
name|SUNOS_DEF_REGULAR
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|h
operator|->
name|dynindx
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Scan the relocs for an input section using standard relocs.  We    need to figure out what to do for each reloc against a dynamic    symbol.  If the symbol is in the .text section, an entry is made in    the procedure linkage table.  Note that this will do the wrong    thing if the symbol is actually data; I don't think the Sun 3    native linker handles this case correctly either.  If the symbol is    not in the .text section, we must preserve the reloc as a dynamic    reloc.  FIXME: We should also handle the PIC relocs here by    building global offset table entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_scan_std_relocs
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|struct
name|reloc_std_external
modifier|*
name|relocs
parameter_list|,
name|bfd_size_type
name|rel_size
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|srel
init|=
name|NULL
decl_stmt|;
name|struct
name|sunos_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|struct
name|reloc_std_external
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
comment|/* We only know how to handle m68k plt entries.  */
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_arch_m68k
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_target
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dynobj
operator|=
name|NULL
expr_stmt|;
name|sym_hashes
operator|=
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|*
operator|)
name|obj_aout_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|rel_size
operator|/
name|RELOC_STD_SIZE
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_index
decl_stmt|;
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* We only want relocs against external symbols.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_BIG
operator|)
operator|==
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_LITTLE
operator|)
operator|==
literal|0
condition|)
continue|continue;
block|}
comment|/* Get the symbol index.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|)
expr_stmt|;
else|else
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* Get the hash table entry.  */
name|h
operator|=
name|sym_hashes
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
comment|/* This should not normally happen, but it will in any case 	   be caught in the relocation phase.  */
continue|continue;
comment|/* At this point common symbols have already been allocated, so 	 we don't have to worry about them.  We need to consider that 	 we may have already seen this symbol and marked it undefined; 	 if the symbol is really undefined, then SUNOS_DEF_DYNAMIC 	 will be zero.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
continue|continue;
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
if|if
condition|(
operator|!
name|sunos_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|->
name|size
operator|==
literal|0
condition|)
name|sgot
operator|->
name|size
operator|=
name|BYTES_IN_WORD
expr_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_needed
operator|=
name|TRUE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_REF_REGULAR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt_offset
operator|!=
literal|0
operator|||
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|?
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
else|:
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* This reloc is against a symbol defined only by a dynamic 	 object.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
comment|/* Presumably this symbol was marked as being undefined by 	   an earlier reloc.  */
name|srel
operator|->
name|size
operator|+=
name|RELOC_STD_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
comment|/* This reloc is not in the .text section.  It must be 	     copied into the dynamic relocs.  We mark the symbol as 	     being undefined.  */
name|srel
operator|->
name|size
operator|+=
name|RELOC_STD_SIZE
expr_stmt|;
name|sub
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|sub
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol is in the .text section.  We must give it an 	     entry in the procedure linkage table, if we have not 	     already done so.  We change the definition of the symbol 	     to the .plt section; this will cause relocs against it to 	     be handled correctly.  */
if|if
condition|(
name|h
operator|->
name|plt_offset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|splt
operator|->
name|size
operator|==
literal|0
condition|)
name|splt
operator|->
name|size
operator|=
name|M68K_PLT_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt_offset
operator|=
name|splt
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|splt
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|splt
operator|->
name|size
expr_stmt|;
block|}
name|splt
operator|->
name|size
operator|+=
name|M68K_PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We may also need a dynamic reloc entry.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|srel
operator|->
name|size
operator|+=
name|RELOC_STD_SIZE
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Scan the relocs for an input section using extended relocs.  We    need to figure out what to do for each reloc against a dynamic    symbol.  If the reloc is a WDISP30, and the symbol is in the .text    section, an entry is made in the procedure linkage table.    Otherwise, we must preserve the reloc as a dynamic reloc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_scan_ext_relocs
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|struct
name|reloc_ext_external
modifier|*
name|relocs
parameter_list|,
name|bfd_size_type
name|rel_size
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|sunos_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|struct
name|reloc_ext_external
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|asection
modifier|*
name|splt
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|srel
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* We only know how to handle SPARC plt entries.  */
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_arch_sparc
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_target
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dynobj
operator|=
name|NULL
expr_stmt|;
name|sym_hashes
operator|=
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|*
operator|)
name|obj_aout_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|rel_size
operator|/
name|RELOC_EXT_SIZE
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
comment|/* Swap in the reloc information.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_BIG
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rel
operator|->
name|r_index
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
operator|(
name|rel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|r_extern
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_index
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* This should not normally happen, but it will in any 		 case be caught in the relocation phase.  */
continue|continue;
block|}
block|}
comment|/* If this is a base relative reloc, we need to make an entry in 	 the .got section.  */
if|if
condition|(
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|r_type
operator|==
name|RELOC_BASE22
condition|)
block|{
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure we have an initial entry in the .got table.  */
if|if
condition|(
name|sgot
operator|->
name|size
operator|==
literal|0
condition|)
name|sgot
operator|->
name|size
operator|=
name|BYTES_IN_WORD
expr_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_needed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|r_extern
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got_offset
operator|!=
literal|0
condition|)
continue|continue;
name|h
operator|->
name|got_offset
operator|=
name|sgot
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r_index
operator|>=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|)
comment|/* This is abnormal, but should be caught in the 		   relocation phase.  */
continue|continue;
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|local_got_offsets
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|local_got_offsets
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|local_got_offsets
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|local_got_offsets
index|[
name|r_index
index|]
operator|!=
literal|0
condition|)
continue|continue;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|local_got_offsets
index|[
name|r_index
index|]
operator|=
name|sgot
operator|->
name|size
expr_stmt|;
block|}
name|sgot
operator|->
name|size
operator|+=
name|BYTES_IN_WORD
expr_stmt|;
comment|/* If we are making a shared library, or if the symbol is 	     defined by a dynamic object, we will need a dynamic reloc 	     entry.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
name|srel
operator|->
name|size
operator|+=
name|RELOC_EXT_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* Otherwise, we are only interested in relocs against symbols 	 defined in dynamic objects but not in regular objects.  We 	 only need to consider relocs against external symbols.  */
if|if
condition|(
operator|!
name|r_extern
condition|)
block|{
comment|/* But, if we are creating a shared library, we need to 	     generate an absolute reloc.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|srel
operator|->
name|size
operator|+=
name|RELOC_EXT_SIZE
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* At this point common symbols have already been allocated, so 	 we don't have to worry about them.  We need to consider that 	 we may have already seen this symbol and marked it undefined; 	 if the symbol is really undefined, then SUNOS_DEF_DYNAMIC 	 will be zero.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|!=
name|RELOC_JMP_TBL
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|==
name|RELOC_JMP_TBL
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This symbol is apparently undefined.  Don't do anything 	     here; just let the relocation routine report an undefined 	     symbol.  */
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure we have an initial entry in the .got table.  */
if|if
condition|(
name|sgot
operator|->
name|size
operator|==
literal|0
condition|)
name|sgot
operator|->
name|size
operator|=
name|BYTES_IN_WORD
expr_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_needed
operator|=
name|TRUE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|r_type
operator|==
name|RELOC_JMP_TBL
operator|||
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_REF_REGULAR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|==
name|RELOC_JMP_TBL
operator|||
name|info
operator|->
name|shared
operator|||
name|h
operator|->
name|plt_offset
operator|!=
literal|0
operator|||
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|?
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
else|:
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* This reloc is against a symbol defined only by a dynamic 	 object, or it is a jump table reloc from PIC compiled code.  */
if|if
condition|(
name|r_type
operator|!=
name|RELOC_JMP_TBL
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
comment|/* Presumably this symbol was marked as being undefined by 	   an earlier reloc.  */
name|srel
operator|->
name|size
operator|+=
name|RELOC_EXT_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|!=
name|RELOC_JMP_TBL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
comment|/* This reloc is not in the .text section.  It must be 	     copied into the dynamic relocs.  We mark the symbol as 	     being undefined.  */
name|srel
operator|->
name|size
operator|+=
name|RELOC_EXT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|sub
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|sub
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This symbol is in the .text section.  We must give it an 	     entry in the procedure linkage table, if we have not 	     already done so.  We change the definition of the symbol 	     to the .plt section; this will cause relocs against it to 	     be handled correctly.  */
if|if
condition|(
name|h
operator|->
name|plt_offset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|splt
operator|->
name|size
operator|==
literal|0
condition|)
name|splt
operator|->
name|size
operator|=
name|SPARC_PLT_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt_offset
operator|=
name|splt
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|splt
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|splt
operator|->
name|size
expr_stmt|;
block|}
name|splt
operator|->
name|size
operator|+=
name|SPARC_PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We will also need a dynamic reloc entry, unless this 		 is a JMP_TBL reloc produced by linking PIC compiled 		 code, and we are not making a shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|srel
operator|->
name|size
operator|+=
name|RELOC_EXT_SIZE
expr_stmt|;
block|}
comment|/* If we are creating a shared library, we need to copy over 	     any reloc other than a jump table reloc.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|r_type
operator|!=
name|RELOC_JMP_TBL
condition|)
name|srel
operator|->
name|size
operator|+=
name|RELOC_EXT_SIZE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Scan the relocs for an input section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_scan_relocs
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_size_type
name|rel_size
parameter_list|)
block|{
name|void
modifier|*
name|relocs
decl_stmt|;
name|void
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rel_size
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|relocs
operator|=
name|free_relocs
operator|=
name|bfd_malloc
argument_list|(
name|rel_size
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|aout_section_data_struct
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|aout_section_data_struct
argument_list|)
decl_stmt|;
name|n
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|relocs
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|set_aout_section_data
argument_list|(
name|sec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|bfd_malloc
argument_list|(
name|rel_size
argument_list|)
expr_stmt|;
name|aout_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|relocs
expr_stmt|;
block|}
block|}
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|relocs
argument_list|,
name|rel_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|rel_size
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_scan_std_relocs
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|relocs
argument_list|,
name|rel_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sunos_scan_ext_relocs
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|relocs
argument_list|,
name|rel_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Build the hash table of dynamic symbols, and to mark as written all    symbols from dynamic objects which we do not plan to write out.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_scan_dynamic_symbol
parameter_list|(
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Set the written flag for symbols we do not want to write out as      part of the regular symbol table.  This is all symbols which are      not defined in a regular object file.  For some reason symbols      which are referenced by a regular object and defined by a dynamic      object do not seem to show up in the regular symbol table.  It is      possible for a symbol to have only SUNOS_REF_REGULAR set here, it      is an undefined symbol which was turned into a common symbol      because it was found in an archive object which was not included      in the link.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__DYNAMIC"
argument_list|)
operator|!=
literal|0
condition|)
name|h
operator|->
name|root
operator|.
name|written
operator|=
name|TRUE
expr_stmt|;
comment|/* If this symbol is defined by a dynamic object and referenced by a      regular object, see whether we gave it a reasonable value while      scanning the relocs.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_REF_REGULAR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
comment|/* This symbol is currently defined in a dynamic section 	     which is not being put into the output file.  This 	     implies that there is no reloc against the symbol.  I'm 	     not sure why this case would ever occur.  In any case, we 	     change the symbol to be undefined.  */
name|sub
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|sub
expr_stmt|;
block|}
block|}
comment|/* If this symbol is defined or referenced by a regular file, add it      to the dynamic symbols.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
operator|(
name|SUNOS_DEF_REGULAR
operator||
name|SUNOS_REF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|2
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|h
operator|->
name|dynindx
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
operator|++
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* We don't bother to construct a BFD hash table for the strings 	 which are the names of the dynamic symbols.  Using a hash 	 table for the regular symbols is beneficial, because the 	 regular symbols includes the debugging symbols, which have 	 long names and are often duplicated in several object files. 	 There are no debugging symbols in the dynamic symbols.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|contents
operator|=
name|bfd_realloc
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|s
operator|->
name|size
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|s
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|h
operator|->
name|dynstr_index
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|contents
operator|+
name|s
operator|->
name|size
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* Add it to the dynamic hash table.  */
name|name
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
name|hash
operator|=
operator|(
name|hash
operator|<<
literal|1
operator|)
operator|+
operator|*
name|name
operator|++
expr_stmt|;
name|hash
operator|&=
literal|0x7fffffff
expr_stmt|;
name|hash
operator|%=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_SWORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|contents
operator|+
name|hash
operator|*
name|HASH_ENTRY_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|s
operator|->
name|contents
operator|+
name|hash
operator|*
name|HASH_ENTRY_SIZE
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_vma
name|next
decl_stmt|;
name|next
operator|=
name|GET_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|s
operator|->
name|contents
operator|+
name|hash
operator|*
name|HASH_ENTRY_SIZE
operator|+
name|BYTES_IN_WORD
operator|)
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
operator|/
name|HASH_ENTRY_SIZE
argument_list|,
name|s
operator|->
name|contents
operator|+
name|hash
operator|*
name|HASH_ENTRY_SIZE
operator|+
name|BYTES_IN_WORD
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|next
argument_list|,
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|size
operator|+
name|BYTES_IN_WORD
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|HASH_ENTRY_SIZE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set up the sizes and contents of the dynamic sections created in    sunos_add_dynamic_symbols.  This is called by the SunOS linker    emulation before_allocation routine.  We must set the sizes of the    sections before the linker sets the addresses of the various    sections.  This unfortunately requires reading all the relocs so    that we can work out which ones need to become dynamic relocs.  If    info->keep_memory is TRUE, we keep the relocs in memory; otherwise,    we discard them, and will read them again later.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_sunos_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
modifier|*
name|sdynptr
parameter_list|,
name|asection
modifier|*
modifier|*
name|sneedptr
parameter_list|,
name|asection
modifier|*
modifier|*
name|srulesptr
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_size_type
name|dynsymcount
decl_stmt|;
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|size_t
name|bucketcount
decl_stmt|;
name|bfd_size_type
name|hashalloc
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
operator|*
name|sdynptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|sneedptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|srulesptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|output_bfd
operator|->
name|xvec
operator|!=
operator|&
name|MY
argument_list|(
name|vec
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Look through all the input BFD's and read their relocs.  It would      be better if we didn't have to do this, but there is no other way      to determine the number of dynamic relocs we need, and, more      importantly, there is no other way to know which symbols should      get an entry in the procedure linkage table.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
if|if
condition|(
operator|(
name|sub
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|&&
name|sub
operator|->
name|xvec
operator|==
name|output_bfd
operator|->
name|xvec
condition|)
block|{
if|if
condition|(
operator|!
name|sunos_scan_relocs
argument_list|(
name|info
argument_list|,
name|sub
argument_list|,
name|obj_textsec
argument_list|(
name|sub
argument_list|)
argument_list|,
name|exec_hdr
argument_list|(
name|sub
argument_list|)
operator|->
name|a_trsize
argument_list|)
operator|||
operator|!
name|sunos_scan_relocs
argument_list|(
name|info
argument_list|,
name|sub
argument_list|,
name|obj_datasec
argument_list|(
name|sub
argument_list|)
argument_list|,
name|exec_hdr
argument_list|(
name|sub
argument_list|)
operator|->
name|a_drsize
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|dynsymcount
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
comment|/* If there were no dynamic objects in the link, and we don't need      to build a global offset table, there is nothing to do here.  */
if|if
condition|(
operator|!
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_needed
operator|&&
operator|!
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_needed
condition|)
return|return
name|TRUE
return|;
comment|/* If __GLOBAL_OFFSET_TABLE_ was mentioned, define it.  */
name|h
operator|=
name|sunos_link_hash_lookup
argument_list|(
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_REF_REGULAR
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|->
name|flags
operator||=
name|SUNOS_DEF_REGULAR
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|h
operator|->
name|dynindx
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
comment|/* If the .got section is more than 0x1000 bytes, we set 	 __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section, 	 so that 13 bit relocations have a greater chance of working.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|>=
literal|0x1000
condition|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0x1000
expr_stmt|;
else|else
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_base
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
comment|/* If there are any shared objects in the link, then we need to set      up the dynamic linking information.  */
if|if
condition|(
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_needed
condition|)
block|{
operator|*
name|sdynptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
comment|/* The .dynamic section is always the same size.  */
name|s
operator|=
operator|*
name|sdynptr
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|external_sun4_dynamic
argument_list|)
operator|+
name|EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|external_sun4_dynamic_link
argument_list|)
operator|)
expr_stmt|;
comment|/* Set the size of the .dynsym and .hash sections.  We counted 	 the number of dynamic symbols as we read the input files.  We 	 will build the dynamic symbol table (.dynsym) and the hash 	 table (.hash) when we build the final symbol table, because 	 until then we do not know the correct value to give the 	 symbols.  We build the dynamic symbol string table (.dynstr) 	 in a traversal of the symbol table using 	 sunos_scan_dynamic_symbol.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* The number of buckets is just the number of symbols divided 	 by four.  To compute the final size of the hash table, we 	 must actually compute the hash table.  Normally we need 	 exactly as many entries in the hash table as there are 	 dynamic symbols, but if some of the buckets are not used we 	 will need additional entries.  In the worst case, every 	 symbol will hash to the same bucket, and we will need 	 BUCKETCOUNT - 1 extra entries.  */
if|if
condition|(
name|dynsymcount
operator|>=
literal|4
condition|)
name|bucketcount
operator|=
name|dynsymcount
operator|/
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|dynsymcount
operator|>
literal|0
condition|)
name|bucketcount
operator|=
name|dynsymcount
expr_stmt|;
else|else
name|bucketcount
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hashalloc
operator|=
operator|(
name|dynsymcount
operator|+
name|bucketcount
operator|-
literal|1
operator|)
operator|*
name|HASH_ENTRY_SIZE
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|hashalloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|dynsymcount
operator|>
literal|0
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bucketcount
condition|;
name|i
operator|++
control|)
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|,
name|s
operator|->
name|contents
operator|+
name|i
operator|*
name|HASH_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|bucketcount
operator|*
name|HASH_ENTRY_SIZE
expr_stmt|;
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
operator|=
name|bucketcount
expr_stmt|;
comment|/* Scan all the symbols, place them in the dynamic symbol table, 	 and build the dynamic hash table.  We reuse dynsymcount as a 	 counter for the number of symbols we have added so far.  */
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|=
literal|0
expr_stmt|;
name|sunos_link_hash_traverse
argument_list|(
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|sunos_scan_dynamic_symbol
argument_list|,
operator|(
name|void
operator|*
operator|)
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|==
name|dynsymcount
argument_list|)
expr_stmt|;
comment|/* The SunOS native linker seems to align the total size of the 	 symbol strings to a multiple of 8.  I don't know if this is 	 important, but it can't hurt much.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|size
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|add
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|add
operator|=
literal|8
operator|-
operator|(
name|s
operator|->
name|size
operator|&
literal|7
operator|)
expr_stmt|;
name|contents
operator|=
name|bfd_realloc
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|s
operator|->
name|size
operator|+
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memset
argument_list|(
name|contents
operator|+
name|s
operator|->
name|size
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|add
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|add
expr_stmt|;
block|}
block|}
comment|/* Now that we have worked out the sizes of the procedure linkage      table and the dynamic relocs, allocate storage for them.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Fill in the first entry in the table.  */
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|dynobj
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
name|memcpy
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|sparc_plt_first_entry
argument_list|,
name|SPARC_PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_m68k
case|:
name|memcpy
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|m68k_plt_first_entry
argument_list|,
name|M68K_PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We use the reloc_count field to keep track of how many of the      relocs we have output so far.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
comment|/* Make space for the global offset table.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|sneedptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".need"
argument_list|)
expr_stmt|;
operator|*
name|srulesptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rules"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Link a dynamic object.  We actually don't have anything to do at    this point.  This entry point exists to prevent the regular linker    code from doing anything with the object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_link_dynamic_object
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out a dynamic symbol.  This is called by the final traversal    over the symbol table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_write_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|aout_link_hash_entry
modifier|*
name|harg
parameter_list|)
block|{
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|)
name|harg
decl_stmt|;
name|int
name|type
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|outsym
decl_stmt|;
comment|/* If this symbol is in the procedure linkage table, fill in the      table entry.  */
if|if
condition|(
name|h
operator|->
name|plt_offset
operator|!=
literal|0
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|r_address
decl_stmt|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|p
operator|=
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt_offset
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|r_address
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_PLT_ENTRY_WORD0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|SPARC_PLT_ENTRY_WORD1
operator|+
operator|(
operator|(
operator|(
operator|-
operator|(
name|h
operator|->
name|plt_offset
operator|+
literal|4
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x3fffffff
operator|)
operator|)
operator|)
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_PLT_ENTRY_WORD2
operator|+
name|s
operator|->
name|reloc_count
argument_list|,
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_PLT_PIC_WORD0
operator|+
operator|(
operator|(
name|val
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_PLT_PIC_WORD1
operator|+
operator|(
name|val
operator|&
literal|0x3ff
operator|)
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_PLT_PIC_WORD2
argument_list|,
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bfd_arch_m68k
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|M68K_PLT_ENTRY_WORD0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
operator|-
operator|(
name|h
operator|->
name|plt_offset
operator|+
literal|2
operator|)
operator|)
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|s
operator|->
name|reloc_count
argument_list|,
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|r_address
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We also need to add a jump table reloc, unless this is the 	 result of a JMP_TBL reloc from PIC compiled code.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|reloc_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
operator|<
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
name|struct
name|reloc_std_external
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|p
expr_stmt|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|r_address
argument_list|,
name|srel
operator|->
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_STD_BITS_EXTERN_BIG
operator||
name|RELOC_STD_BITS_JMPTABLE_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|h
operator|->
name|dynindx
expr_stmt|;
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_STD_BITS_EXTERN_LITTLE
operator||
name|RELOC_STD_BITS_JMPTABLE_LITTLE
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|reloc_ext_external
modifier|*
name|erel
decl_stmt|;
name|erel
operator|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|p
expr_stmt|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|r_address
argument_list|,
name|erel
operator|->
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|h
operator|->
name|dynindx
expr_stmt|;
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_EXT_BITS_EXTERN_BIG
operator||
operator|(
name|RELOC_JMP_SLOT
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|h
operator|->
name|dynindx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|h
operator|->
name|dynindx
expr_stmt|;
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_EXT_BITS_EXTERN_LITTLE
operator||
operator|(
name|RELOC_JMP_SLOT
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|erel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* If this is not a dynamic symbol, we don't have to do anything      else.  We only check this after handling the PLT entry, because      we can have a PLT entry for a nondynamic symbol when linking PIC      compiled code from a regular object.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|<
literal|0
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_new
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Avoid variable not initialized warnings.  */
return|return
name|TRUE
return|;
case|case
name|bfd_link_hash_undefined
case|:
name|type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_is_abs_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt_offset
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|output_section
operator|==
name|obj_textsec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_TEXT
else|:
name|N_WEAKT
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_datasec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_DATA
else|:
name|N_WEAKD
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|output_section
operator|==
name|obj_bsssec
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|type
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_BSS
else|:
name|N_WEAKB
operator|)
expr_stmt|;
else|else
name|type
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|?
name|N_ABS
else|:
name|N_WEAKA
operator|)
expr_stmt|;
name|type
operator||=
name|N_EXT
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|bfd_link_hash_common
case|:
name|type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|val
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefweak
case|:
name|type
operator|=
name|N_WEAKU
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
comment|/* FIXME: Ignore these for now.  The circumstances under which 	 they should be written out are not clear to me.  */
return|return
name|TRUE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outsym
operator|=
operator|(
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
operator|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|dynindx
operator|*
name|EXTERNAL_NLIST_SIZE
operator|)
operator|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|output_bfd
argument_list|,
name|type
argument_list|,
name|outsym
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|outsym
operator|->
name|e_other
argument_list|)
expr_stmt|;
comment|/* FIXME: The native linker doesn't use 0 for desc.  It seems to use      one less than the desc value in the shared library, although that      seems unlikely.  */
name|H_PUT_16
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|outsym
operator|->
name|e_desc
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|,
name|outsym
operator|->
name|e_strx
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|outsym
operator|->
name|e_value
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called for each reloc against an external symbol.  If this    is a reloc which are are going to copy as a dynamic reloc, then    copy it over, and tell the caller to not bother processing this    reloc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_check_dynamic_reloc
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|struct
name|aout_link_hash_entry
modifier|*
name|harg
parameter_list|,
name|void
modifier|*
name|reloc
parameter_list|,
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
modifier|*
name|skip
parameter_list|,
name|bfd_vma
modifier|*
name|relocationp
parameter_list|)
block|{
name|struct
name|sunos_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|sunos_link_hash_entry
operator|*
operator|)
name|harg
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_boolean
name|baserel
decl_stmt|;
name|bfd_boolean
name|jmptbl
decl_stmt|;
name|bfd_boolean
name|pcrel
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|long
name|indx
decl_stmt|;
operator|*
name|skip
operator|=
name|FALSE
expr_stmt|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt_offset
operator|!=
literal|0
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
comment|/* Redirect the relocation to the PLT entry.  */
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
operator|*
name|relocationp
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt_offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
name|struct
name|reloc_std_external
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|reloc
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_BIG
operator|)
operator|)
expr_stmt|;
name|jmptbl
operator|=
operator|(
literal|0
operator|!=
operator|(
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_BIG
operator|)
operator|)
expr_stmt|;
name|pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_LITTLE
operator|)
operator|)
expr_stmt|;
name|jmptbl
operator|=
operator|(
literal|0
operator|!=
operator|(
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_LITTLE
operator|)
operator|)
expr_stmt|;
name|pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|reloc_ext_external
modifier|*
name|erel
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|erel
operator|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|reloc
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|r_type
operator|=
operator|(
operator|(
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_BIG
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
expr_stmt|;
else|else
name|r_type
operator|=
operator|(
operator|(
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
expr_stmt|;
name|baserel
operator|=
operator|(
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|r_type
operator|==
name|RELOC_BASE22
operator|)
expr_stmt|;
name|jmptbl
operator|=
name|r_type
operator|==
name|RELOC_JMP_TBL
expr_stmt|;
name|pcrel
operator|=
operator|(
name|r_type
operator|==
name|RELOC_DISP8
operator|||
name|r_type
operator|==
name|RELOC_DISP16
operator|||
name|r_type
operator|==
name|RELOC_DISP32
operator|||
name|r_type
operator|==
name|RELOC_WDISP30
operator|||
name|r_type
operator|==
name|RELOC_WDISP22
operator|)
expr_stmt|;
comment|/* We don't consider the PC10 and PC22 types to be PC relative, 	 because they are pcrel_offset.  */
block|}
if|if
condition|(
name|baserel
condition|)
block|{
name|bfd_vma
modifier|*
name|got_offsetp
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|got_offsetp
operator|=
operator|&
name|h
operator|->
name|got_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|adata
argument_list|(
name|input_bfd
argument_list|)
operator|.
name|local_got_offsets
operator|==
name|NULL
condition|)
name|got_offsetp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|struct
name|reloc_std_external
modifier|*
name|srel
decl_stmt|;
name|int
name|r_index
decl_stmt|;
name|srel
operator|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|reloc
expr_stmt|;
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|r_index
operator|=
operator|(
operator|(
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|)
expr_stmt|;
else|else
name|r_index
operator|=
operator|(
operator|(
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|reloc_ext_external
modifier|*
name|erel
decl_stmt|;
name|erel
operator|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|reloc
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|r_index
operator|=
operator|(
operator|(
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|)
expr_stmt|;
else|else
name|r_index
operator|=
operator|(
operator|(
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
name|got_offsetp
operator|=
name|adata
argument_list|(
name|input_bfd
argument_list|)
operator|.
name|local_got_offsets
operator|+
name|r_index
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|got_offsetp
operator|!=
name|NULL
operator|&&
operator|*
name|got_offsetp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
comment|/* We set the least significant bit to indicate whether we have 	 already initialized the GOT entry.  */
if|if
condition|(
operator|(
operator|*
name|got_offsetp
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|*
name|relocationp
argument_list|,
name|sgot
operator|->
name|contents
operator|+
operator|*
name|got_offsetp
argument_list|)
expr_stmt|;
else|else
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
operator|*
name|got_offsetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We need to create a GLOB_DAT or 32 reloc to tell the 		 dynamic linker to fill in this entry in the table.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|reloc_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
operator|<
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
name|struct
name|reloc_std_external
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|p
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
operator|*
name|got_offsetp
operator|+
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|)
argument_list|,
name|srel
operator|->
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|dynobj
argument_list|)
condition|)
block|{
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
literal|2
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_BIG
expr_stmt|;
else|else
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_STD_BITS_EXTERN_BIG
operator||
name|RELOC_STD_BITS_BASEREL_BIG
operator||
name|RELOC_STD_BITS_RELATIVE_BIG
operator||
operator|(
literal|2
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
literal|2
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
expr_stmt|;
else|else
name|srel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_STD_BITS_EXTERN_LITTLE
operator||
name|RELOC_STD_BITS_BASEREL_LITTLE
operator||
name|RELOC_STD_BITS_RELATIVE_LITTLE
operator||
operator|(
literal|2
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|reloc_ext_external
modifier|*
name|erel
decl_stmt|;
name|erel
operator|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|p
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
operator|*
name|got_offsetp
operator|+
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|)
argument_list|,
name|erel
operator|->
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|dynobj
argument_list|)
condition|)
block|{
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
name|RELOC_32
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_BIG
expr_stmt|;
else|else
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_EXT_BITS_EXTERN_BIG
operator||
operator|(
name|RELOC_GLOB_DAT
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
name|RELOC_32
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
expr_stmt|;
else|else
name|erel
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|RELOC_EXT_BITS_EXTERN_LITTLE
operator||
operator|(
name|RELOC_GLOB_DAT
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
literal|0
argument_list|,
name|erel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
operator|*
name|got_offsetp
operator||=
literal|1
expr_stmt|;
block|}
operator|*
name|relocationp
operator|=
operator|(
name|sgot
operator|->
name|vma
operator|+
operator|(
operator|*
name|got_offsetp
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|-
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_base
operator|)
expr_stmt|;
comment|/* There is nothing else to do for a base relative reloc.  */
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_needed
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|SUNOS_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|jmptbl
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* It looks like this is a reloc we are supposed to copy.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|reloc_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
operator|<
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
comment|/* Copy the reloc over.  */
name|memcpy
argument_list|(
name|p
argument_list|,
name|reloc
argument_list|,
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|indx
operator|=
literal|0
expr_stmt|;
comment|/* Adjust the address and symbol index.  */
if|if
condition|(
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
operator|==
name|RELOC_STD_SIZE
condition|)
block|{
name|struct
name|reloc_std_external
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|p
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|GET_WORD
argument_list|(
name|dynobj
argument_list|,
name|srel
operator|->
name|r_address
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
argument_list|,
name|srel
operator|->
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|dynobj
argument_list|)
condition|)
block|{
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
block|}
else|else
block|{
name|srel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|srel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
block|}
comment|/* FIXME: We may have to change the addend for a PC relative 	 reloc.  */
block|}
else|else
block|{
name|struct
name|reloc_ext_external
modifier|*
name|erel
decl_stmt|;
name|erel
operator|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|p
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|GET_WORD
argument_list|(
name|dynobj
argument_list|,
name|erel
operator|->
name|r_address
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
argument_list|,
name|erel
operator|->
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|dynobj
argument_list|)
condition|)
block|{
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
block|}
else|else
block|{
name|erel
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|indx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|erel
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|indx
expr_stmt|;
block|}
if|if
condition|(
name|pcrel
operator|&&
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Adjust the addend for the change in address.  */
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|GET_WORD
argument_list|(
name|dynobj
argument_list|,
name|erel
operator|->
name|r_addend
argument_list|)
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|)
argument_list|,
name|erel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic linking information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sunos_finish_dynamic_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
if|if
condition|(
operator|!
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_needed
operator|&&
operator|!
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_needed
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Finish up the .need section.  The linker emulation code filled it      in, but with offsets from the start of the section instead of      real addresses.  Now that we know the section location, we can      fill in the final values.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".need"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|file_ptr
name|filepos
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|filepos
operator|=
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|contents
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|GET_WORD
argument_list|(
name|dynobj
argument_list|,
name|p
argument_list|)
operator|+
name|filepos
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|val
operator|=
name|GET_WORD
argument_list|(
name|dynobj
argument_list|,
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
break|break;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|val
operator|+
name|filepos
argument_list|,
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|16
expr_stmt|;
block|}
block|}
comment|/* The first entry in the .got section is the address of the      dynamic information, unless this is a shared library.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|sdyn
operator|->
name|size
operator|==
literal|0
condition|)
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
name|o
operator|->
name|contents
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|o
operator|->
name|output_section
operator|->
name|owner
operator|==
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|sdyn
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|struct
name|external_sun4_dynamic
name|esd
decl_stmt|;
name|struct
name|external_sun4_dynamic_link
name|esdl
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
comment|/* Finish up the dynamic link information.  */
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|3
argument_list|,
name|esd
operator|.
name|ld_version
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
operator|+
sizeof|sizeof
name|esd
argument_list|,
name|esd
operator|.
name|ldd
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
operator|+
sizeof|sizeof
name|esd
operator|+
name|EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
operator|)
argument_list|,
name|esd
operator|.
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sdyn
operator|->
name|output_section
argument_list|,
operator|&
name|esd
argument_list|,
operator|(
name|file_ptr
operator|)
name|sdyn
operator|->
name|output_offset
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|esd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|esdl
operator|.
name|ld_loaded
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".need"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|esdl
operator|.
name|ld_need
argument_list|)
expr_stmt|;
else|else
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_need
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rules"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|esdl
operator|.
name|ld_rules
argument_list|)
expr_stmt|;
else|else
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_rules
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_got
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_plt
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|,
name|esdl
operator|.
name|ld_plt_sz
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynrel"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|reloc_count
operator|*
name|obj_reloc_entry_size
argument_list|(
name|dynobj
argument_list|)
operator|==
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_rel
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_hash
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_stab
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|esdl
operator|.
name|ld_stab_hash
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sunos_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
argument_list|,
name|esdl
operator|.
name|ld_buckets
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|esdl
operator|.
name|ld_symbols
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|,
name|esdl
operator|.
name|ld_symb_size
argument_list|)
expr_stmt|;
comment|/* The size of the text area is the size of the .text section 	 rounded up to a page boundary.  FIXME: Should the page size be 	 conditional on something?  */
name|PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|BFD_ALIGN
argument_list|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
argument_list|,
literal|0x2000
argument_list|)
argument_list|,
name|esdl
operator|.
name|ld_text
argument_list|)
expr_stmt|;
name|pos
operator|=
name|sdyn
operator|->
name|output_offset
expr_stmt|;
name|pos
operator|+=
sizeof|sizeof
name|esd
operator|+
name|EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sdyn
operator|->
name|output_section
argument_list|,
operator|&
name|esdl
argument_list|,
name|pos
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|esdl
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

