begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* -*- mode: c; c-file-style: "k&r" -*-    strnatcmp.c -- Perform 'natural order' comparisons of strings in C.   Copyright (C) 2000 by Martin Pool<mbp@humbug.org.au>    This software is provided 'as-is', without any express or implied   warranty.  In no event will the authors be held liable for any damages   arising from the use of this software.    Permission is granted to anyone to use this software for any purpose,   including commercial applications, and to alter it and redistribute it   freely, subject to the following restrictions:    1. The origin of this software must not be misrepresented; you must not      claim that you wrote the original software. If you use this software      in a product, an acknowledgment in the product documentation would be      appreciated but is not required.   2. Altered source versions must be plainly marked as such, and must not be      misrepresented as being the original software.   3. This notice may not be removed or altered from any source distribution. */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_comment
comment|/* for apr_is*() */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|UNUSED
value|__attribute__((__unused__))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UNUSED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* based on "strnatcmp.c,v 1.6 2000/04/20 07:30:11 mbp Exp $" */
end_comment

begin_function
specifier|static
name|int
name|compare_right
parameter_list|(
name|char
specifier|const
modifier|*
name|a
parameter_list|,
name|char
specifier|const
modifier|*
name|b
parameter_list|)
block|{
name|int
name|bias
init|=
literal|0
decl_stmt|;
comment|/* The longest run of digits wins.  That aside, the greatest 	value wins, but we can't know that it will until we've scanned 	both numbers to know that they have the same magnitude, so we 	remember it in BIAS. */
for|for
control|(
init|;
condition|;
name|a
operator|++
operator|,
name|b
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|a
argument_list|)
operator|&&
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|b
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|a
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|b
argument_list|)
condition|)
return|return
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|<
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|!
name|bias
condition|)
name|bias
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|!
name|bias
condition|)
name|bias
operator|=
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|a
operator|&&
operator|!
operator|*
name|b
condition|)
break|break;
block|}
return|return
name|bias
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_left
parameter_list|(
name|char
specifier|const
modifier|*
name|a
parameter_list|,
name|char
specifier|const
modifier|*
name|b
parameter_list|)
block|{
comment|/* Compare two left-aligned numbers: the first to have a         different value wins. */
for|for
control|(
init|;
condition|;
name|a
operator|++
operator|,
name|b
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|a
argument_list|)
operator|&&
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|b
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|a
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|b
argument_list|)
condition|)
return|return
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|<
operator|*
name|b
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|b
condition|)
return|return
operator|+
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strnatcmp0
parameter_list|(
name|char
specifier|const
modifier|*
name|a
parameter_list|,
name|char
specifier|const
modifier|*
name|b
parameter_list|,
name|int
name|fold_case
parameter_list|)
block|{
name|int
name|ai
decl_stmt|,
name|bi
decl_stmt|;
name|char
name|ca
decl_stmt|,
name|cb
decl_stmt|;
name|int
name|fractional
decl_stmt|,
name|result
decl_stmt|;
name|ai
operator|=
name|bi
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ca
operator|=
name|a
index|[
name|ai
index|]
expr_stmt|;
name|cb
operator|=
name|b
index|[
name|bi
index|]
expr_stmt|;
comment|/* skip over leading spaces or zeros */
while|while
condition|(
name|apr_isspace
argument_list|(
name|ca
argument_list|)
condition|)
name|ca
operator|=
name|a
index|[
operator|++
name|ai
index|]
expr_stmt|;
while|while
condition|(
name|apr_isspace
argument_list|(
name|cb
argument_list|)
condition|)
name|cb
operator|=
name|b
index|[
operator|++
name|bi
index|]
expr_stmt|;
comment|/* process run of digits */
if|if
condition|(
name|apr_isdigit
argument_list|(
name|ca
argument_list|)
operator|&&
name|apr_isdigit
argument_list|(
name|cb
argument_list|)
condition|)
block|{
name|fractional
operator|=
operator|(
name|ca
operator|==
literal|'0'
operator|||
name|cb
operator|==
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|fractional
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|compare_left
argument_list|(
name|a
operator|+
name|ai
argument_list|,
name|b
operator|+
name|bi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|compare_right
argument_list|(
name|a
operator|+
name|ai
argument_list|,
name|b
operator|+
name|bi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ca
operator|&&
operator|!
name|cb
condition|)
block|{
comment|/* The strings compare the same.  Perhaps the caller                   will want to call strcmp to break the tie. */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fold_case
condition|)
block|{
name|ca
operator|=
name|apr_toupper
argument_list|(
name|ca
argument_list|)
expr_stmt|;
name|cb
operator|=
name|apr_toupper
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ca
operator|<
name|cb
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|ca
operator|>
name|cb
condition|)
return|return
operator|+
literal|1
return|;
operator|++
name|ai
expr_stmt|;
operator|++
name|bi
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_strnatcmp
argument_list|(
argument|char const *a
argument_list|,
argument|char const *b
argument_list|)
end_macro

begin_block
block|{
return|return
name|strnatcmp0
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Compare, recognizing numeric string and ignoring case. */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_strnatcasecmp
argument_list|(
argument|char const *a
argument_list|,
argument|char const *b
argument_list|)
end_macro

begin_block
block|{
return|return
name|strnatcmp0
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

end_unit

