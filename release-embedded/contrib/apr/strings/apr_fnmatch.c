begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/* Derived from The Open Group Base Specifications Issue 7, IEEE Std 1003.1-2008  * as described in;  *   http://pubs.opengroup.org/onlinepubs/9699919799/functions/fnmatch.html  *  * Filename pattern matches defined in section 2.13, "Pattern Matching Notation"  * from chapter 2. "Shell Command Language"  *   http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13  * where; 1. A bracket expression starting with an unquoted<circumflex> '^'   * character CONTINUES to specify a non-matching list; 2. an explicit<period> '.'   * in a bracket expression matching list, e.g. "[.abc]" does NOT match a leading   *<period> in a filename; 3. a<left-square-bracket> '[' which does not introduce  * a valid bracket expression is treated as an ordinary character; 4. a differing  * number of consecutive slashes within pattern and string will NOT match;  * 5. a trailing '\' in FNM_ESCAPE mode is treated as an ordinary '\' character.  *  * Bracket expansion defined in section 9.3.5, "RE Bracket Expression",  * from chapter 9, "Regular Expressions"  *   http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05  * with no support for collating symbols, equivalence class expressions or   * character class expressions.  A partial range expression with a leading   * hyphen following a valid range expression will match only the ordinary  *<hyphen> and the ending character (e.g. "[a-m-z]" will match characters   * 'a' through 'm', a<hyphen> '-', or a 'z').  *  * NOTE: Only POSIX/C single byte locales are correctly supported at this time.  * Notably, non-POSIX locales with FNM_CASEFOLD produce undefined results,  * particularly in ranges of mixed case (e.g. "[A-z]") or spanning alpha and  * nonalpha characters within a range.  *  * XXX comments below indicate porting required for multi-byte character sets  * and non-POSIX locale collation orders; requires mbr* APIs to track shift  * state of pattern and string (rewinding pattern and string repeatedly).  *  * Certain parts of the code assume 0x00-0x3F are unique with any MBCS (e.g.  * UTF-8, SHIFT-JIS, etc).  Any implementation allowing '\' as an alternate  * path delimiter must be aware that 0x5C is NOT unique within SHIFT-JIS.  */
end_comment

begin_include
include|#
directive|include
file|"apr_file_info.h"
end_include

begin_include
include|#
directive|include
file|"apr_fnmatch.h"
end_include

begin_include
include|#
directive|include
file|"apr_tables.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|APR_HAVE_CTYPE_H
end_if

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Most MBCS/collation/case issues handled here.  Wildcard '*' is not handled.  * EOS '\0' and the FNM_PATHNAME '/' delimiters are not advanced over,   * however the "\/" sequence is advanced to '/'.  *  * Both pattern and string are **char to support pointer increment of arbitrary  * multibyte characters for the given locale, in a later iteration of this code  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|int
name|fnmatch_ch
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|string
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|mismatch
init|=
operator|*
name|pattern
decl_stmt|;
specifier|const
name|int
name|nocase
init|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|APR_FNM_CASE_BLIND
operator|)
decl_stmt|;
specifier|const
name|int
name|escape
init|=
operator|!
operator|(
name|flags
operator|&
name|APR_FNM_NOESCAPE
operator|)
decl_stmt|;
specifier|const
name|int
name|slash
init|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|APR_FNM_PATHNAME
operator|)
decl_stmt|;
name|int
name|result
init|=
name|APR_FNM_NOMATCH
decl_stmt|;
specifier|const
name|char
modifier|*
name|startch
decl_stmt|;
name|int
name|negate
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pattern
operator|==
literal|'['
condition|)
block|{
operator|++
operator|*
name|pattern
expr_stmt|;
comment|/* Handle negation, either leading ! or ^ operators (never both) */
name|negate
operator|=
operator|(
operator|(
operator|*
operator|*
name|pattern
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
operator|*
name|pattern
operator|==
literal|'^'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|negate
condition|)
operator|++
operator|*
name|pattern
expr_stmt|;
comment|/* ']' is an ordinary character at the start of the range pattern */
if|if
condition|(
operator|*
operator|*
name|pattern
operator|==
literal|']'
condition|)
goto|goto
name|leadingclosebrace
goto|;
while|while
condition|(
operator|*
operator|*
name|pattern
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pattern
operator|==
literal|']'
condition|)
block|{
operator|++
operator|*
name|pattern
expr_stmt|;
comment|/* XXX: Fix for MBCS character width */
operator|++
operator|*
name|string
expr_stmt|;
return|return
operator|(
name|result
operator|^
name|negate
operator|)
return|;
block|}
if|if
condition|(
name|escape
operator|&&
operator|(
operator|*
operator|*
name|pattern
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|++
operator|*
name|pattern
expr_stmt|;
comment|/* Patterns must be terminated with ']', not EOS */
if|if
condition|(
operator|!
operator|*
operator|*
name|pattern
condition|)
break|break;
block|}
comment|/* Patterns must be terminated with ']' not '/' */
if|if
condition|(
name|slash
operator|&&
operator|(
operator|*
operator|*
name|pattern
operator|==
literal|'/'
operator|)
condition|)
break|break;
name|leadingclosebrace
label|:
comment|/* Look at only well-formed range patterns;               * "x-]" is not allowed unless escaped ("x-\]")              * XXX: Fix for locale/MBCS character width              */
if|if
condition|(
operator|(
operator|(
operator|*
name|pattern
operator|)
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
operator|(
operator|*
name|pattern
operator|)
index|[
literal|2
index|]
operator|!=
literal|']'
operator|)
condition|)
block|{
name|startch
operator|=
operator|*
name|pattern
expr_stmt|;
operator|*
name|pattern
operator|+=
operator|(
name|escape
operator|&&
operator|(
operator|(
operator|*
name|pattern
operator|)
index|[
literal|2
index|]
operator|==
literal|'\\'
operator|)
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
comment|/* NOT a properly balanced [expr] pattern, EOS terminated                   * or ranges containing a slash in FNM_PATHNAME mode pattern                  * fall out to to the rewind and test '[' literal code path                  */
if|if
condition|(
operator|!
operator|*
operator|*
name|pattern
operator|||
operator|(
name|slash
operator|&&
operator|(
operator|*
operator|*
name|pattern
operator|==
literal|'/'
operator|)
operator|)
condition|)
break|break;
comment|/* XXX: handle locale/MBCS comparison, advance by MBCS char width */
if|if
condition|(
operator|(
operator|*
operator|*
name|string
operator|>=
operator|*
name|startch
operator|)
operator|&&
operator|(
operator|*
operator|*
name|string
operator|<=
operator|*
operator|*
name|pattern
operator|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nocase
operator|&&
operator|(
name|isupper
argument_list|(
operator|*
operator|*
name|string
argument_list|)
operator|||
name|isupper
argument_list|(
operator|*
name|startch
argument_list|)
operator|||
name|isupper
argument_list|(
operator|*
operator|*
name|pattern
argument_list|)
operator|)
operator|&&
operator|(
name|tolower
argument_list|(
operator|*
operator|*
name|string
argument_list|)
operator|>=
name|tolower
argument_list|(
operator|*
name|startch
argument_list|)
operator|)
operator|&&
operator|(
name|tolower
argument_list|(
operator|*
operator|*
name|string
argument_list|)
operator|<=
name|tolower
argument_list|(
operator|*
operator|*
name|pattern
argument_list|)
operator|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
operator|++
operator|*
name|pattern
expr_stmt|;
continue|continue;
block|}
comment|/* XXX: handle locale/MBCS comparison, advance by MBCS char width */
if|if
condition|(
operator|(
operator|*
operator|*
name|string
operator|==
operator|*
operator|*
name|pattern
operator|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nocase
operator|&&
operator|(
name|isupper
argument_list|(
operator|*
operator|*
name|string
argument_list|)
operator|||
name|isupper
argument_list|(
operator|*
operator|*
name|pattern
argument_list|)
operator|)
operator|&&
operator|(
name|tolower
argument_list|(
operator|*
operator|*
name|string
argument_list|)
operator|==
name|tolower
argument_list|(
operator|*
operator|*
name|pattern
argument_list|)
operator|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
operator|++
operator|*
name|pattern
expr_stmt|;
block|}
comment|/* NOT a properly balanced [expr] pattern; Rewind          * and reset result to test '[' literal          */
operator|*
name|pattern
operator|=
name|mismatch
expr_stmt|;
name|result
operator|=
name|APR_FNM_NOMATCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pattern
operator|==
literal|'?'
condition|)
block|{
comment|/* Optimize '?' match before unescaping **pattern */
if|if
condition|(
operator|!
operator|*
operator|*
name|string
operator|||
operator|(
name|slash
operator|&&
operator|(
operator|*
operator|*
name|string
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
name|APR_FNM_NOMATCH
return|;
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|fnmatch_ch_success
goto|;
block|}
elseif|else
if|if
condition|(
name|escape
operator|&&
operator|(
operator|*
operator|*
name|pattern
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|*
name|pattern
operator|)
index|[
literal|1
index|]
condition|)
block|{
operator|++
operator|*
name|pattern
expr_stmt|;
block|}
comment|/* XXX: handle locale/MBCS comparison, advance by the MBCS char width */
if|if
condition|(
operator|*
operator|*
name|string
operator|==
operator|*
operator|*
name|pattern
condition|)
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nocase
operator|&&
operator|(
name|isupper
argument_list|(
operator|*
operator|*
name|string
argument_list|)
operator|||
name|isupper
argument_list|(
operator|*
operator|*
name|pattern
argument_list|)
operator|)
operator|&&
operator|(
name|tolower
argument_list|(
operator|*
operator|*
name|string
argument_list|)
operator|==
name|tolower
argument_list|(
operator|*
operator|*
name|pattern
argument_list|)
operator|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Refuse to advance over trailing slash or nulls      */
if|if
condition|(
operator|!
operator|*
operator|*
name|string
operator|||
operator|!
operator|*
operator|*
name|pattern
operator|||
operator|(
name|slash
operator|&&
operator|(
operator|(
operator|*
operator|*
name|string
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
operator|*
name|pattern
operator|==
literal|'/'
operator|)
operator|)
operator|)
condition|)
return|return
name|result
return|;
name|fnmatch_ch_success
label|:
operator|++
operator|*
name|pattern
expr_stmt|;
operator|++
operator|*
name|string
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_fnmatch
argument_list|(
argument|const char *pattern
argument_list|,
argument|const char *string
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
specifier|static
specifier|const
name|char
name|dummystring
index|[
literal|2
index|]
init|=
block|{
literal|' '
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|int
name|escape
init|=
operator|!
operator|(
name|flags
operator|&
name|APR_FNM_NOESCAPE
operator|)
decl_stmt|;
specifier|const
name|int
name|slash
init|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|APR_FNM_PATHNAME
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|strendseg
decl_stmt|;
specifier|const
name|char
modifier|*
name|dummyptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|matchptr
decl_stmt|;
name|int
name|wild
decl_stmt|;
comment|/* For '*' wild processing only; surpress 'used before initialization'      * warnings with dummy initialization values;      */
specifier|const
name|char
modifier|*
name|strstartseg
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|mismatch
init|=
name|NULL
decl_stmt|;
name|int
name|matchlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'*'
condition|)
goto|goto
name|firstsegment
goto|;
while|while
condition|(
operator|*
name|pattern
operator|&&
operator|*
name|string
condition|)
block|{
comment|/* Pre-decode "\/" which has no special significance, and          * match balanced slashes, starting a new segment pattern          */
if|if
condition|(
name|slash
operator|&&
name|escape
operator|&&
operator|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
operator|++
name|pattern
expr_stmt|;
if|if
condition|(
name|slash
operator|&&
operator|(
operator|*
name|pattern
operator|==
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|string
operator|==
literal|'/'
operator|)
condition|)
block|{
operator|++
name|pattern
expr_stmt|;
operator|++
name|string
expr_stmt|;
block|}
name|firstsegment
label|:
comment|/* At the beginning of each segment, validate leading period behavior.          */
if|if
condition|(
operator|(
name|flags
operator|&
name|APR_FNM_PERIOD
operator|)
operator|&&
operator|(
operator|*
name|string
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'.'
condition|)
operator|++
name|pattern
expr_stmt|;
elseif|else
if|if
condition|(
name|escape
operator|&&
operator|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|pattern
operator|+=
literal|2
expr_stmt|;
else|else
return|return
name|APR_FNM_NOMATCH
return|;
operator|++
name|string
expr_stmt|;
block|}
comment|/* Determine the end of string segment          *          * Presumes '/' character is unique, not composite in any MBCS encoding          */
if|if
condition|(
name|slash
condition|)
block|{
name|strendseg
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strendseg
condition|)
name|strendseg
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strendseg
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
comment|/* Allow pattern '*' to be consumed even with no remaining string to match          */
while|while
condition|(
operator|*
name|pattern
condition|)
block|{
if|if
condition|(
operator|(
name|string
operator|>
name|strendseg
operator|)
operator|||
operator|(
operator|(
name|string
operator|==
name|strendseg
operator|)
operator|&&
operator|(
operator|*
name|pattern
operator|!=
literal|'*'
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|slash
operator|&&
operator|(
operator|(
operator|*
name|pattern
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|escape
operator|&&
operator|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Reduce groups of '*' and '?' to n '?' matches              * followed by one '*' test for simplicity              */
for|for
control|(
name|wild
operator|=
literal|0
init|;
operator|(
operator|(
operator|*
name|pattern
operator|==
literal|'*'
operator|)
operator|||
operator|(
operator|*
name|pattern
operator|==
literal|'?'
operator|)
operator|)
condition|;
operator|++
name|pattern
control|)
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'*'
condition|)
block|{
name|wild
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
operator|<
name|strendseg
condition|)
block|{
comment|/*&& (*pattern == '?') */
comment|/* XXX: Advance 1 char for MBCS locale */
operator|++
name|string
expr_stmt|;
block|}
else|else
block|{
comment|/* (string>= strendseg)&& (*pattern == '?') */
return|return
name|APR_FNM_NOMATCH
return|;
block|}
block|}
if|if
condition|(
name|wild
condition|)
block|{
name|strstartseg
operator|=
name|string
expr_stmt|;
name|mismatch
operator|=
name|pattern
expr_stmt|;
comment|/* Count fixed (non '*') char matches remaining in pattern                  * excluding '/' (or "\/") and '*'                  */
for|for
control|(
name|matchptr
operator|=
name|pattern
operator|,
name|matchlen
operator|=
literal|0
init|;
literal|1
condition|;
operator|++
name|matchlen
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|matchptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|slash
operator|&&
operator|(
operator|(
operator|*
name|matchptr
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|escape
operator|&&
operator|(
operator|*
name|matchptr
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|matchptr
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Compare precisely this many trailing string chars,                          * the resulting match needs no wildcard loop                          */
comment|/* XXX: Adjust for MBCS */
if|if
condition|(
name|string
operator|+
name|matchlen
operator|>
name|strendseg
condition|)
return|return
name|APR_FNM_NOMATCH
return|;
name|string
operator|=
name|strendseg
operator|-
name|matchlen
expr_stmt|;
name|wild
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|matchptr
operator|==
literal|'*'
condition|)
block|{
comment|/* Ensure at least this many trailing string chars remain                          * for the first comparison                          */
comment|/* XXX: Adjust for MBCS */
if|if
condition|(
name|string
operator|+
name|matchlen
operator|>
name|strendseg
condition|)
return|return
name|APR_FNM_NOMATCH
return|;
comment|/* Begin first wild comparison at the current position */
break|break;
block|}
comment|/* Skip forward in pattern by a single character match                      * Use a dummy fnmatch_ch() test to count one "[range]" escape                      */
comment|/* XXX: Adjust for MBCS */
if|if
condition|(
name|escape
operator|&&
operator|(
operator|*
name|matchptr
operator|==
literal|'\\'
operator|)
operator|&&
name|matchptr
index|[
literal|1
index|]
condition|)
block|{
name|matchptr
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|matchptr
operator|==
literal|'['
condition|)
block|{
name|dummyptr
operator|=
name|dummystring
expr_stmt|;
name|fnmatch_ch
argument_list|(
operator|&
name|matchptr
argument_list|,
operator|&
name|dummyptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|matchptr
expr_stmt|;
block|}
block|}
block|}
comment|/* Incrementally match string against the pattern              */
while|while
condition|(
operator|*
name|pattern
operator|&&
operator|(
name|string
operator|<
name|strendseg
operator|)
condition|)
block|{
comment|/* Success; begin a new wild pattern search                  */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'*'
condition|)
break|break;
if|if
condition|(
name|slash
operator|&&
operator|(
operator|(
operator|*
name|string
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|pattern
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|escape
operator|&&
operator|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Compare ch's (the pattern is advanced over "\/" to the '/',                  * but slashes will mismatch, and are not consumed)                  */
if|if
condition|(
operator|!
name|fnmatch_ch
argument_list|(
operator|&
name|pattern
argument_list|,
operator|&
name|string
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
comment|/* Failed to match, loop against next char offset of string segment                   * until not enough string chars remain to match the fixed pattern                  */
if|if
condition|(
name|wild
condition|)
block|{
comment|/* XXX: Advance 1 char for MBCS locale */
name|string
operator|=
operator|++
name|strstartseg
expr_stmt|;
if|if
condition|(
name|string
operator|+
name|matchlen
operator|>
name|strendseg
condition|)
return|return
name|APR_FNM_NOMATCH
return|;
name|pattern
operator|=
name|mismatch
expr_stmt|;
continue|continue;
block|}
else|else
return|return
name|APR_FNM_NOMATCH
return|;
block|}
block|}
if|if
condition|(
operator|*
name|string
operator|&&
operator|!
operator|(
name|slash
operator|&&
operator|(
operator|*
name|string
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
name|APR_FNM_NOMATCH
return|;
if|if
condition|(
operator|*
name|pattern
operator|&&
operator|!
operator|(
name|slash
operator|&&
operator|(
operator|(
operator|*
name|pattern
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|escape
operator|&&
operator|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
operator|)
condition|)
return|return
name|APR_FNM_NOMATCH
return|;
block|}
comment|/* Where both pattern and string are at EOS, declare success      */
if|if
condition|(
operator|!
operator|*
name|string
operator|&&
operator|!
operator|*
name|pattern
condition|)
return|return
literal|0
return|;
comment|/* pattern didn't match to the end of string */
return|return
name|APR_FNM_NOMATCH
return|;
block|}
end_block

begin_comment
comment|/* This function is an Apache addition  * return non-zero if pattern has any glob chars in it  * @bug Function does not distinguish for FNM_PATHNAME mode, which renders  * a false positive for test[/]this (which is not a range, but   * seperate test[ and ]this segments and no glob.)  * @bug Function does not distinguish for non-FNM_ESCAPE mode.  * @bug Function does not parse []] correctly  * Solution may be to use fnmatch_ch() to walk the patterns?  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_fnmatch_test
argument_list|(
argument|const char *pattern
argument_list|)
end_macro

begin_block
block|{
name|int
name|nesting
decl_stmt|;
name|nesting
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pattern
condition|)
block|{
switch|switch
condition|(
operator|*
name|pattern
condition|)
block|{
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
return|return
literal|1
return|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
operator|++
name|pattern
operator|==
literal|'\0'
condition|)
block|{
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'['
case|:
comment|/* '[' is only a glob if it has a matching ']' */
operator|++
name|nesting
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
name|nesting
condition|)
block|{
return|return
literal|1
return|;
block|}
break|break;
block|}
operator|++
name|pattern
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Find all files matching the specified pattern */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_match_glob
argument_list|(
argument|const char *pattern
argument_list|,
argument|apr_array_header_t **result
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
name|apr_dir_t
modifier|*
name|dir
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
comment|/* XXX So, this is kind of bogus.  Basically, I need to strip any leading      * directories off the pattern, but there is no portable way to do that.      * So, for now we just find the last occurance of '/' and if that doesn't      * return anything, then we look for '\'.  This means that we could      * screw up on unix if the pattern is something like "foo\.*"  That '\'      * isn't a directory delimiter, it is a part of the filename.  To fix this,      * we really need apr_filepath_basename, which will be coming as soon as      * I get to it.  rbb      */
name|char
modifier|*
name|idx
init|=
name|strrchr
argument_list|(
name|pattern
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
name|NULL
condition|)
block|{
name|idx
operator|=
name|strrchr
argument_list|(
name|pattern
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
literal|"."
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|apr_pstrndup
argument_list|(
name|p
argument_list|,
name|pattern
argument_list|,
name|idx
operator|-
name|pattern
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|apr_array_make
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_dir_open
argument_list|(
operator|&
name|dir
argument_list|,
name|path
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
while|while
condition|(
name|apr_dir_read
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_NAME
argument_list|,
name|dir
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
block|{
if|if
condition|(
name|apr_fnmatch
argument_list|(
name|pattern
argument_list|,
name|finfo
operator|.
name|name
argument_list|,
literal|0
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
block|{
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|apr_array_push
argument_list|(
operator|*
name|result
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|p
argument_list|,
name|finfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|apr_dir_close
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

end_unit

