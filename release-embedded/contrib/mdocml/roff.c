begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: roff.c,v 1.172 2011/10/24 21:41:45 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010, 2011 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"libroff.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_comment
comment|/* Maximum number of nested if-else conditionals. */
end_comment

begin_define
define|#
directive|define
name|RSTACK_MAX
value|128
end_define

begin_comment
comment|/* Maximum number of string expansions per line, to break infinite loops. */
end_comment

begin_define
define|#
directive|define
name|EXPAND_LIMIT
value|1000
end_define

begin_enum
enum|enum
name|rofft
block|{
name|ROFF_ad
block|,
name|ROFF_am
block|,
name|ROFF_ami
block|,
name|ROFF_am1
block|,
name|ROFF_de
block|,
name|ROFF_dei
block|,
name|ROFF_de1
block|,
name|ROFF_ds
block|,
name|ROFF_el
block|,
name|ROFF_hy
block|,
name|ROFF_ie
block|,
name|ROFF_if
block|,
name|ROFF_ig
block|,
name|ROFF_it
block|,
name|ROFF_ne
block|,
name|ROFF_nh
block|,
name|ROFF_nr
block|,
name|ROFF_ns
block|,
name|ROFF_ps
block|,
name|ROFF_rm
block|,
name|ROFF_so
block|,
name|ROFF_ta
block|,
name|ROFF_tr
block|,
name|ROFF_TS
block|,
name|ROFF_TE
block|,
name|ROFF_T_
block|,
name|ROFF_EQ
block|,
name|ROFF_EN
block|,
name|ROFF_cblock
block|,
name|ROFF_ccond
block|,
name|ROFF_USERDEF
block|,
name|ROFF_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|roffrule
block|{
name|ROFFRULE_ALLOW
block|,
name|ROFFRULE_DENY
block|}
enum|;
end_enum

begin_comment
comment|/*  * A single register entity.  If "set" is zero, the value of the  * register should be the default one, which is per-register.  * Registers are assumed to be unsigned ints for now.  */
end_comment

begin_struct
struct|struct
name|reg
block|{
name|int
name|set
decl_stmt|;
comment|/* whether set or not */
name|unsigned
name|int
name|u
decl_stmt|;
comment|/* unsigned integer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * An incredibly-simple string buffer.  */
end_comment

begin_struct
struct|struct
name|roffstr
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* nil-terminated buffer */
name|size_t
name|sz
decl_stmt|;
comment|/* saved strlen(p) */
block|}
struct|;
end_struct

begin_comment
comment|/*  * A key-value roffstr pair as part of a singly-linked list.  */
end_comment

begin_struct
struct|struct
name|roffkv
block|{
name|struct
name|roffstr
name|key
decl_stmt|;
name|struct
name|roffstr
name|val
decl_stmt|;
name|struct
name|roffkv
modifier|*
name|next
decl_stmt|;
comment|/* next in list */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|roff
block|{
name|struct
name|mparse
modifier|*
name|parse
decl_stmt|;
comment|/* parse point */
name|struct
name|roffnode
modifier|*
name|last
decl_stmt|;
comment|/* leaf of stack */
name|enum
name|roffrule
name|rstack
index|[
name|RSTACK_MAX
index|]
decl_stmt|;
comment|/* stack of !`ie' rules */
name|int
name|rstackpos
decl_stmt|;
comment|/* position in rstack */
name|struct
name|reg
name|regs
index|[
name|REG__MAX
index|]
decl_stmt|;
name|struct
name|roffkv
modifier|*
name|strtab
decl_stmt|;
comment|/* user-defined strings& macros */
name|struct
name|roffkv
modifier|*
name|xmbtab
decl_stmt|;
comment|/* multi-byte trans table (`tr') */
name|struct
name|roffstr
modifier|*
name|xtab
decl_stmt|;
comment|/* single-byte trans table (`tr') */
specifier|const
name|char
modifier|*
name|current_string
decl_stmt|;
comment|/* value of last called user macro */
name|struct
name|tbl_node
modifier|*
name|first_tbl
decl_stmt|;
comment|/* first table parsed */
name|struct
name|tbl_node
modifier|*
name|last_tbl
decl_stmt|;
comment|/* last table parsed */
name|struct
name|tbl_node
modifier|*
name|tbl
decl_stmt|;
comment|/* current table being parsed */
name|struct
name|eqn_node
modifier|*
name|last_eqn
decl_stmt|;
comment|/* last equation parsed */
name|struct
name|eqn_node
modifier|*
name|first_eqn
decl_stmt|;
comment|/* first equation parsed */
name|struct
name|eqn_node
modifier|*
name|eqn
decl_stmt|;
comment|/* current equation being parsed */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|roffnode
block|{
name|enum
name|rofft
name|tok
decl_stmt|;
comment|/* type of node */
name|struct
name|roffnode
modifier|*
name|parent
decl_stmt|;
comment|/* up one in stack */
name|int
name|line
decl_stmt|;
comment|/* parse line */
name|int
name|col
decl_stmt|;
comment|/* parse col */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* node name, e.g. macro name */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* end-rules: custom token */
name|int
name|endspan
decl_stmt|;
comment|/* end-rules: next-line or infty */
name|enum
name|roffrule
name|rule
decl_stmt|;
comment|/* current evaluation rule */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ROFF_ARGS
value|struct roff *r,
comment|/* parse ctx */
value|\ 			 enum rofft tok,
comment|/* tok of macro */
value|\ 		 	 char **bufp,
comment|/* input buffer */
value|\ 			 size_t *szp,
comment|/* size of input buffer */
value|\ 			 int ln,
comment|/* parse line */
value|\ 			 int ppos,
comment|/* original pos in buffer */
value|\ 			 int pos,
comment|/* current pos in buffer */
value|\ 			 int *offs
end_define

begin_comment
comment|/* reset offset of buffer data */
end_comment

begin_typedef
typedef|typedef
name|enum
name|rofferr
function_decl|(
modifier|*
name|roffproc
function_decl|)
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|roffmac
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* macro name */
name|roffproc
name|proc
decl_stmt|;
comment|/* process new macro */
name|roffproc
name|text
decl_stmt|;
comment|/* process as child text of macro */
name|roffproc
name|sub
decl_stmt|;
comment|/* process as child of macro */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|ROFFMAC_STRUCT
value|(1<< 0)
comment|/* always interpret */
name|struct
name|roffmac
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|predef
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* predefined input name */
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* replacement symbol */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PREDEF
parameter_list|(
name|__name
parameter_list|,
name|__str
parameter_list|)
define|\
value|{ (__name), (__str) },
end_define

begin_function_decl
specifier|static
name|enum
name|rofft
name|roffhash_find
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffhash_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffnode_cleanscope
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffnode_pop
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffnode_push
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|enum
name|rofft
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_block
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_block_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_block_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cblock
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_ccond
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cond
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cond_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cond_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_ds
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|roffrule
name|roff_evalcond
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_free1
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_freestr
parameter_list|(
name|struct
name|roffkv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|roff_getname
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|roff_getstrn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_line_ignore
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_nr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_openeqn
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofft
name|roff_parse
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_parsetext
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_res
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_rm
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_setstr
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_setstrn
parameter_list|(
name|struct
name|roffkv
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_so
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_tr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_TE
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_TS
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_EQ
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_EN
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_T_
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_userdef
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* See roffhash_find() */
end_comment

begin_define
define|#
directive|define
name|ASCII_HI
value|126
end_define

begin_define
define|#
directive|define
name|ASCII_LO
value|33
end_define

begin_define
define|#
directive|define
name|HASHWIDTH
value|(ASCII_HI - ASCII_LO + 1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|roffmac
modifier|*
name|hash
index|[
name|HASHWIDTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|roffmac
name|roffs
index|[
name|ROFF_MAX
index|]
init|=
block|{
block|{
literal|"ad"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"am"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ami"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"am1"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"de"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dei"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"de1"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ds"
block|,
name|roff_ds
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"el"
block|,
name|roff_cond
block|,
name|roff_cond_text
block|,
name|roff_cond_sub
block|,
name|ROFFMAC_STRUCT
block|,
name|NULL
block|}
block|,
block|{
literal|"hy"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ie"
block|,
name|roff_cond
block|,
name|roff_cond_text
block|,
name|roff_cond_sub
block|,
name|ROFFMAC_STRUCT
block|,
name|NULL
block|}
block|,
block|{
literal|"if"
block|,
name|roff_cond
block|,
name|roff_cond_text
block|,
name|roff_cond_sub
block|,
name|ROFFMAC_STRUCT
block|,
name|NULL
block|}
block|,
block|{
literal|"ig"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"it"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ne"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nh"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nr"
block|,
name|roff_nr
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ns"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ps"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rm"
block|,
name|roff_rm
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"so"
block|,
name|roff_so
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ta"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tr"
block|,
name|roff_tr
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"TS"
block|,
name|roff_TS
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"TE"
block|,
name|roff_TE
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"T&"
block|,
name|roff_T_
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"EQ"
block|,
name|roff_EQ
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"EN"
block|,
name|roff_EN
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"."
block|,
name|roff_cblock
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"\\}"
block|,
name|roff_ccond
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|roff_userdef
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of injected predefined strings. */
end_comment

begin_define
define|#
directive|define
name|PREDEFS_MAX
value|38
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|predef
name|predefs
index|[
name|PREDEFS_MAX
index|]
init|=
block|{
include|#
directive|include
file|"predefs.in"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See roffhash_find() */
end_comment

begin_define
define|#
directive|define
name|ROFF_HASH
parameter_list|(
name|p
parameter_list|)
value|(p[0] - ASCII_LO)
end_define

begin_function
specifier|static
name|void
name|roffhash_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|roffmac
modifier|*
name|n
decl_stmt|;
name|int
name|buc
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ROFF_USERDEF
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|roffs
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|>=
name|ASCII_LO
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|roffs
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|<=
name|ASCII_HI
argument_list|)
expr_stmt|;
name|buc
operator|=
name|ROFF_HASH
argument_list|(
name|roffs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|n
operator|=
name|hash
index|[
name|buc
index|]
operator|)
condition|)
block|{
for|for
control|(
init|;
name|n
operator|->
name|next
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
comment|/* Do nothing. */
empty_stmt|;
name|n
operator|->
name|next
operator|=
operator|&
name|roffs
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|hash
index|[
name|buc
index|]
operator|=
operator|&
name|roffs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up a roff token by its name.  Returns ROFF_MAX if no macro by  * the nil-terminated string name could be found.  */
end_comment

begin_function
specifier|static
name|enum
name|rofft
name|roffhash_find
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|int
name|buc
decl_stmt|;
name|struct
name|roffmac
modifier|*
name|n
decl_stmt|;
comment|/* 	 * libroff has an extremely simple hashtable, for the time 	 * being, which simply keys on the first character, which must 	 * be printable, then walks a chain.  It works well enough until 	 * optimised. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|<
name|ASCII_LO
operator|||
name|p
index|[
literal|0
index|]
operator|>
name|ASCII_HI
condition|)
return|return
operator|(
name|ROFF_MAX
operator|)
return|;
name|buc
operator|=
name|ROFF_HASH
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|hash
index|[
name|buc
index|]
operator|)
condition|)
return|return
operator|(
name|ROFF_MAX
operator|)
return|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|n
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
operator|&&
literal|'\0'
operator|==
name|n
operator|->
name|name
index|[
operator|(
name|int
operator|)
name|s
index|]
condition|)
return|return
operator|(
operator|(
expr|enum
name|rofft
operator|)
operator|(
name|n
operator|-
name|roffs
operator|)
operator|)
return|;
return|return
operator|(
name|ROFF_MAX
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pop the current node off of the stack of roff instructions currently  * pending.  */
end_comment

begin_function
specifier|static
name|void
name|roffnode_pop
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|roffnode
modifier|*
name|p
decl_stmt|;
name|assert
argument_list|(
name|r
operator|->
name|last
argument_list|)
expr_stmt|;
name|p
operator|=
name|r
operator|->
name|last
expr_stmt|;
name|r
operator|->
name|last
operator|=
name|r
operator|->
name|last
operator|->
name|parent
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Push a roff node onto the instruction stack.  This must later be  * removed with roffnode_pop().  */
end_comment

begin_function
specifier|static
name|void
name|roffnode_push
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|enum
name|rofft
name|tok
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|struct
name|roffnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roffnode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|tok
operator|=
name|tok
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|p
operator|->
name|name
operator|=
name|mandoc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
operator|->
name|last
expr_stmt|;
name|p
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|p
operator|->
name|rule
operator|=
name|p
operator|->
name|parent
condition|?
name|p
operator|->
name|parent
operator|->
name|rule
else|:
name|ROFFRULE_DENY
expr_stmt|;
name|r
operator|->
name|last
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|roff_free1
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|tbl_node
modifier|*
name|t
decl_stmt|;
name|struct
name|eqn_node
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|t
operator|=
name|r
operator|->
name|first_tbl
operator|)
condition|)
block|{
name|r
operator|->
name|first_tbl
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|tbl_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|first_tbl
operator|=
name|r
operator|->
name|last_tbl
operator|=
name|r
operator|->
name|tbl
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|e
operator|=
name|r
operator|->
name|first_eqn
operator|)
condition|)
block|{
name|r
operator|->
name|first_eqn
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|eqn_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|first_eqn
operator|=
name|r
operator|->
name|last_eqn
operator|=
name|r
operator|->
name|eqn
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|last
condition|)
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|roff_freestr
argument_list|(
name|r
operator|->
name|strtab
argument_list|)
expr_stmt|;
name|roff_freestr
argument_list|(
name|r
operator|->
name|xmbtab
argument_list|)
expr_stmt|;
name|r
operator|->
name|strtab
operator|=
name|r
operator|->
name|xmbtab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|xtab
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|r
operator|->
name|xtab
index|[
name|i
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|xtab
argument_list|)
expr_stmt|;
name|r
operator|->
name|xtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_reset
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|roff_free1
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r
operator|->
name|regs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg
argument_list|)
operator|*
name|REG__MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PREDEFS_MAX
condition|;
name|i
operator|++
control|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|predefs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|predefs
index|[
name|i
index|]
operator|.
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_free
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|roff_free1
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|roff
modifier|*
name|roff_alloc
parameter_list|(
name|struct
name|mparse
modifier|*
name|parse
parameter_list|)
block|{
name|struct
name|roff
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|r
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roff
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|parse
operator|=
name|parse
expr_stmt|;
name|r
operator|->
name|rstackpos
operator|=
operator|-
literal|1
expr_stmt|;
name|roffhash_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PREDEFS_MAX
condition|;
name|i
operator|++
control|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|predefs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|predefs
index|[
name|i
index|]
operator|.
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-filter each and every line for reserved words (one beginning with  * `\*', e.g., `\*(ab').  These must be handled before the actual line  * is processed.   * This also checks the syntax of regular escapes.  */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_res
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|char
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|szp
parameter_list|,
name|int
name|ln
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
specifier|const
name|char
modifier|*
name|stesc
decl_stmt|;
comment|/* start of an escape sequence ('\\') */
specifier|const
name|char
modifier|*
name|stnam
decl_stmt|;
comment|/* start of the name, after "[(*" */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* end of the name, e.g. before ']' */
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
comment|/* the string to be substituted */
name|int
name|i
decl_stmt|,
name|maxl
decl_stmt|,
name|expand_count
decl_stmt|;
name|size_t
name|nsz
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|expand_count
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|cp
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\\'
argument_list|)
operator|)
condition|)
block|{
name|stesc
operator|=
name|cp
operator|++
expr_stmt|;
comment|/* 		 * The second character must be an asterisk. 		 * If it isn't, skip it anyway:  It is escaped, 		 * so it can't start another escape sequence. 		 */
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|cp
condition|)
return|return
operator|(
name|ROFF_CONT
operator|)
return|;
if|if
condition|(
literal|'*'
operator|!=
operator|*
name|cp
condition|)
block|{
name|res
operator|=
name|cp
expr_stmt|;
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|cp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESCAPE_ERROR
operator|!=
name|esc
condition|)
continue|continue;
name|cp
operator|=
name|res
expr_stmt|;
name|mandoc_msg
argument_list|(
name|MANDOCERR_BADESCAPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
operator|*
name|bufp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_CONT
operator|)
return|;
block|}
name|cp
operator|++
expr_stmt|;
comment|/* 		 * The third character decides the length 		 * of the name of the string. 		 * Save a pointer to the name. 		 */
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
operator|(
literal|'\0'
operator|)
case|:
return|return
operator|(
name|ROFF_CONT
operator|)
return|;
case|case
operator|(
literal|'('
operator|)
case|:
name|cp
operator|++
expr_stmt|;
name|maxl
operator|=
literal|2
expr_stmt|;
break|break;
case|case
operator|(
literal|'['
operator|)
case|:
name|cp
operator|++
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|maxl
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|stnam
operator|=
name|cp
expr_stmt|;
comment|/* Advance to the end of the name. */
for|for
control|(
name|i
operator|=
literal|0
init|;
literal|0
operator|==
name|maxl
operator|||
name|i
operator|<
name|maxl
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
block|{
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|cp
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BADESCAPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
operator|*
name|bufp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_CONT
operator|)
return|;
block|}
if|if
condition|(
literal|0
operator|==
name|maxl
operator|&&
literal|']'
operator|==
operator|*
name|cp
condition|)
break|break;
block|}
comment|/* 		 * Retrieve the replacement string; if it is 		 * undefined, resume searching for escapes. 		 */
name|res
operator|=
name|roff_getstrn
argument_list|(
name|r
argument_list|,
name|stnam
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|res
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BADESCAPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
operator|*
name|bufp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|=
literal|""
expr_stmt|;
block|}
comment|/* Replace the escape sequence by the string. */
name|pos
operator|=
name|stesc
operator|-
operator|*
name|bufp
expr_stmt|;
name|nsz
operator|=
operator|*
name|szp
operator|+
name|strlen
argument_list|(
name|res
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|mandoc_malloc
argument_list|(
name|nsz
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|n
argument_list|,
operator|*
name|bufp
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|stesc
operator|-
operator|*
name|bufp
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|n
argument_list|,
name|res
argument_list|,
name|nsz
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|n
argument_list|,
name|cp
operator|+
operator|(
name|maxl
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|,
name|nsz
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|bufp
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|n
expr_stmt|;
operator|*
name|szp
operator|=
name|nsz
expr_stmt|;
if|if
condition|(
name|EXPAND_LIMIT
operator|>=
operator|++
name|expand_count
condition|)
goto|goto
name|again
goto|;
comment|/* Just leave the string unexpanded. */
name|mandoc_msg
argument_list|(
name|MANDOCERR_ROFFLOOP
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
return|return
operator|(
name|ROFF_CONT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process text streams: convert all breakable hyphens into ASCII_HYPH.  */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_parsetext
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
name|start
operator|=
name|p
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
block|{
name|sz
operator|=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|"-\\"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
break|break;
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|p
condition|)
block|{
comment|/* Skip over escapes. */
name|p
operator|++
expr_stmt|;
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESCAPE_ERROR
operator|==
name|esc
condition|)
break|break;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|start
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|p
operator|=
name|ASCII_HYPH
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ROFF_CONT
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|rofferr
name|roff_parseln
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|int
name|ln
parameter_list|,
name|char
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|szp
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
modifier|*
name|offs
parameter_list|)
block|{
name|enum
name|rofft
name|t
decl_stmt|;
name|enum
name|rofferr
name|e
decl_stmt|;
name|int
name|ppos
decl_stmt|,
name|ctl
decl_stmt|;
comment|/* 	 * Run the reserved-word filter only if we have some reserved 	 * words to fill in. 	 */
name|e
operator|=
name|roff_res
argument_list|(
name|r
argument_list|,
name|bufp
argument_list|,
name|szp
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ROFF_IGN
operator|==
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|assert
argument_list|(
name|ROFF_CONT
operator|==
name|e
argument_list|)
expr_stmt|;
name|ppos
operator|=
name|pos
expr_stmt|;
name|ctl
operator|=
name|mandoc_getcontrol
argument_list|(
operator|*
name|bufp
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* 	 * First, if a scope is open and we're not a macro, pass the 	 * text through the macro's filter.  If a scope isn't open and 	 * we're not a macro, just let it through. 	 * Finally, if there's an equation scope open, divert it into it 	 * no matter our state. 	 */
if|if
condition|(
name|r
operator|->
name|last
operator|&&
operator|!
name|ctl
condition|)
block|{
name|t
operator|=
name|r
operator|->
name|last
operator|->
name|tok
expr_stmt|;
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|text
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|bufp
operator|,
name|szp
operator|,
name|ln
operator|,
name|pos
operator|,
name|pos
operator|,
name|offs
operator|)
expr_stmt|;
name|assert
argument_list|(
name|ROFF_IGN
operator|==
name|e
operator|||
name|ROFF_CONT
operator|==
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ROFF_CONT
operator|!=
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
if|if
condition|(
name|r
operator|->
name|eqn
condition|)
return|return
operator|(
name|eqn_read
argument_list|(
operator|&
name|r
operator|->
name|eqn
argument_list|,
name|ln
argument_list|,
operator|*
name|bufp
argument_list|,
name|pos
argument_list|,
name|offs
argument_list|)
operator|)
return|;
if|if
condition|(
name|r
operator|->
name|tbl
condition|)
return|return
operator|(
name|tbl_read
argument_list|(
name|r
operator|->
name|tbl
argument_list|,
name|ln
argument_list|,
operator|*
name|bufp
argument_list|,
name|pos
argument_list|)
operator|)
return|;
return|return
operator|(
name|roff_parsetext
argument_list|(
operator|*
name|bufp
operator|+
name|pos
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ctl
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|eqn
condition|)
return|return
operator|(
name|eqn_read
argument_list|(
operator|&
name|r
operator|->
name|eqn
argument_list|,
name|ln
argument_list|,
operator|*
name|bufp
argument_list|,
name|pos
argument_list|,
name|offs
argument_list|)
operator|)
return|;
if|if
condition|(
name|r
operator|->
name|tbl
condition|)
return|return
operator|(
name|tbl_read
argument_list|(
name|r
operator|->
name|tbl
argument_list|,
name|ln
argument_list|,
operator|*
name|bufp
argument_list|,
name|pos
argument_list|)
operator|)
return|;
return|return
operator|(
name|roff_parsetext
argument_list|(
operator|*
name|bufp
operator|+
name|pos
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|eqn
condition|)
return|return
operator|(
name|eqn_read
argument_list|(
operator|&
name|r
operator|->
name|eqn
argument_list|,
name|ln
argument_list|,
operator|*
name|bufp
argument_list|,
name|ppos
argument_list|,
name|offs
argument_list|)
operator|)
return|;
comment|/* 	 * If a scope is open, go to the child handler for that macro, 	 * as it may want to preprocess before doing anything with it. 	 * Don't do so if an equation is open. 	 */
if|if
condition|(
name|r
operator|->
name|last
condition|)
block|{
name|t
operator|=
name|r
operator|->
name|last
operator|->
name|tok
expr_stmt|;
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|sub
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|sub
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|bufp
operator|,
name|szp
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
operator|)
return|;
block|}
comment|/* 	 * Lastly, as we've no scope open, try to look up and execute 	 * the new macro.  If no macro is found, simply return and let 	 * the compilers handle it. 	 */
if|if
condition|(
name|ROFF_MAX
operator|==
operator|(
name|t
operator|=
name|roff_parse
argument_list|(
name|r
argument_list|,
operator|*
name|bufp
argument_list|,
operator|&
name|pos
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ROFF_CONT
operator|)
return|;
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|proc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|proc
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|bufp
operator|,
name|szp
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|roff_endparse
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|->
name|last
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_SCOPEEXIT
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|r
operator|->
name|last
operator|->
name|line
argument_list|,
name|r
operator|->
name|last
operator|->
name|col
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|eqn
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_SCOPEEXIT
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|r
operator|->
name|eqn
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|r
operator|->
name|eqn
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eqn_end
argument_list|(
operator|&
name|r
operator|->
name|eqn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|tbl
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_SCOPEEXIT
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|r
operator|->
name|tbl
operator|->
name|line
argument_list|,
name|r
operator|->
name|tbl
operator|->
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tbl_end
argument_list|(
operator|&
name|r
operator|->
name|tbl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse a roff node's type from the input buffer.  This must be in the  * form of ".foo xxx" in the usual way.  */
end_comment

begin_function
specifier|static
name|enum
name|rofft
name|roff_parse
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mac
decl_stmt|;
name|size_t
name|maclen
decl_stmt|;
name|enum
name|rofft
name|t
decl_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|buf
index|[
operator|*
name|pos
index|]
operator|||
literal|'"'
operator|==
name|buf
index|[
operator|*
name|pos
index|]
operator|||
literal|'\t'
operator|==
name|buf
index|[
operator|*
name|pos
index|]
operator|||
literal|' '
operator|==
name|buf
index|[
operator|*
name|pos
index|]
condition|)
return|return
operator|(
name|ROFF_MAX
operator|)
return|;
comment|/* 	 * We stop the macro parse at an escape, tab, space, or nil. 	 * However, `\}' is also a valid macro, so make sure we don't 	 * clobber it by seeing the `\' as the end of token. 	 */
name|mac
operator|=
name|buf
operator|+
operator|*
name|pos
expr_stmt|;
name|maclen
operator|=
name|strcspn
argument_list|(
name|mac
operator|+
literal|1
argument_list|,
literal|" \\\t\0"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|t
operator|=
operator|(
name|r
operator|->
name|current_string
operator|=
name|roff_getstrn
argument_list|(
name|r
argument_list|,
name|mac
argument_list|,
name|maclen
argument_list|)
operator|)
condition|?
name|ROFF_USERDEF
else|:
name|roffhash_find
argument_list|(
name|mac
argument_list|,
name|maclen
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|+=
operator|(
name|int
operator|)
name|maclen
expr_stmt|;
while|while
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|&&
literal|' '
operator|==
name|buf
index|[
operator|*
name|pos
index|]
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cblock
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
comment|/* 	 * A block-close `..' should only be invoked as a child of an 	 * ignore macro, otherwise raise a warning and just ignore it. 	 */
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|last
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
switch|switch
condition|(
name|r
operator|->
name|last
operator|->
name|tok
condition|)
block|{
case|case
operator|(
name|ROFF_am
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|ROFF_ami
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|ROFF_am1
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|ROFF_de
operator|)
case|:
comment|/* ROFF_de1 is remapped to ROFF_de in roff_block(). */
comment|/* FALLTHROUGH */
case|case
operator|(
name|ROFF_dei
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|ROFF_ig
operator|)
case|:
break|break;
default|default:
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARGSLOST
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|roffnode_cleanscope
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
while|while
condition|(
name|r
operator|->
name|last
condition|)
block|{
if|if
condition|(
operator|--
name|r
operator|->
name|last
operator|->
name|endspan
operator|<
literal|0
condition|)
break|break;
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_ccond
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|last
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
switch|switch
condition|(
name|r
operator|->
name|last
operator|->
name|tok
condition|)
block|{
case|case
operator|(
name|ROFF_el
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|ROFF_ie
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|ROFF_if
operator|)
case|:
break|break;
default|default:
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
if|if
condition|(
name|r
operator|->
name|last
operator|->
name|endspan
operator|>
operator|-
literal|1
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARGSLOST
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_block
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|int
name|sv
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ROFF_ig
operator|!=
name|tok
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOARGS
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
comment|/* 		 * Re-write `de1', since we don't really care about 		 * groff's strange compatibility mode, into `de'. 		 */
if|if
condition|(
name|ROFF_de1
operator|==
name|tok
condition|)
name|tok
operator|=
name|ROFF_de
expr_stmt|;
if|if
condition|(
name|ROFF_de
operator|==
name|tok
condition|)
name|name
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
else|else
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQUEST
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|roffs
index|[
name|tok
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
operator|&&
operator|!
name|isspace
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|bufp
argument_list|)
index|[
name|pos
index|]
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|bufp
argument_list|)
index|[
name|pos
index|]
argument_list|)
condition|)
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|roffnode_push
argument_list|(
name|r
argument_list|,
name|tok
argument_list|,
name|name
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* 	 * At the beginning of a `de' macro, clear the existing string 	 * with the same name, if there is one.  New content will be 	 * added from roff_block_text() in multiline mode. 	 */
if|if
condition|(
name|ROFF_de
operator|==
name|tok
condition|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|name
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
condition|)
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
comment|/* If present, process the custom end-of-line marker. */
name|sv
operator|=
name|pos
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
operator|&&
operator|!
name|isspace
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|bufp
argument_list|)
index|[
name|pos
index|]
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
comment|/* 	 * Note: groff does NOT like escape characters in the input. 	 * Instead of detecting this, we're just going to let it fly and 	 * to hell with it. 	 */
name|assert
argument_list|(
name|pos
operator|>
name|sv
argument_list|)
expr_stmt|;
name|sz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|pos
operator|-
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|sz
operator|&&
literal|'.'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|sv
index|]
condition|)
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
name|r
operator|->
name|last
operator|->
name|end
operator|=
name|mandoc_malloc
argument_list|(
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|last
operator|->
name|end
argument_list|,
operator|*
name|bufp
operator|+
name|sv
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|r
operator|->
name|last
operator|->
name|end
index|[
operator|(
name|int
operator|)
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARGSLOST
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_block_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|enum
name|rofft
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * First check whether a custom macro exists at this level.  If 	 * it does, then check against it.  This is some of groff's 	 * stranger behaviours.  If we encountered a custom end-scope 	 * tag and that tag also happens to be a "real" macro, then we 	 * need to try interpreting it again as a real macro.  If it's 	 * not, then return ignore.  Else continue. 	 */
if|if
condition|(
name|r
operator|->
name|last
operator|->
name|end
condition|)
block|{
for|for
control|(
name|i
operator|=
name|pos
operator|,
name|j
operator|=
literal|0
init|;
name|r
operator|->
name|last
operator|->
name|end
index|[
name|j
index|]
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|bufp
operator|)
index|[
name|i
index|]
operator|!=
name|r
operator|->
name|last
operator|->
name|end
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
literal|'\0'
operator|==
name|r
operator|->
name|last
operator|->
name|end
index|[
name|j
index|]
operator|&&
operator|(
literal|'\0'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|i
index|]
operator|||
literal|' '
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|i
index|]
operator|||
literal|'\t'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|i
index|]
operator|)
condition|)
block|{
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|i
index|]
operator|||
literal|'\t'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
name|pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ROFF_MAX
operator|!=
name|roff_parse
argument_list|(
name|r
argument_list|,
operator|*
name|bufp
argument_list|,
operator|&
name|pos
argument_list|)
condition|)
return|return
operator|(
name|ROFF_RERUN
operator|)
return|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
block|}
comment|/* 	 * If we have no custom end-query or lookup failed, then try 	 * pulling it out of the hashtable. 	 */
name|t
operator|=
name|roff_parse
argument_list|(
name|r
argument_list|,
operator|*
name|bufp
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* 	 * Macros other than block-end are only significant 	 * in `de' blocks; elsewhere, simply throw them away. 	 */
if|if
condition|(
name|ROFF_cblock
operator|!=
name|t
condition|)
block|{
if|if
condition|(
name|ROFF_de
operator|==
name|tok
condition|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|last
operator|->
name|name
argument_list|,
operator|*
name|bufp
operator|+
name|ppos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|proc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|proc
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|bufp
operator|,
name|szp
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_block_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|ROFF_de
operator|==
name|tok
condition|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|last
operator|->
name|name
argument_list|,
operator|*
name|bufp
operator|+
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cond_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|enum
name|rofft
name|t
decl_stmt|;
name|enum
name|roffrule
name|rr
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|rr
operator|=
name|r
operator|->
name|last
operator|->
name|rule
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 	 * If the macro is unknown, first check if it contains a closing 	 * delimiter `\}'.  If it does, close out our scope and return 	 * the currently-scoped rule (ignore or continue).  Else, drop 	 * into the currently-scoped rule. 	 */
if|if
condition|(
name|ROFF_MAX
operator|==
operator|(
name|t
operator|=
name|roff_parse
argument_list|(
name|r
argument_list|,
operator|*
name|bufp
argument_list|,
operator|&
name|pos
argument_list|)
operator|)
condition|)
block|{
name|ep
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
expr_stmt|;
for|for
control|(
init|;
name|NULL
operator|!=
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|ep
argument_list|,
literal|'\\'
argument_list|)
operator|)
condition|;
name|ep
operator|++
control|)
block|{
name|ep
operator|++
expr_stmt|;
if|if
condition|(
literal|'}'
operator|!=
operator|*
name|ep
condition|)
continue|continue;
comment|/* 			 * Make the \} go away. 			 * This is a little haphazard, as it's not quite 			 * clear how nroff does this. 			 * If we're at the end of line, then just chop 			 * off the \} and resize the buffer. 			 * If we aren't, then conver it to spaces. 			 */
if|if
condition|(
literal|'\0'
operator|==
operator|*
operator|(
name|ep
operator|+
literal|1
operator|)
condition|)
block|{
operator|*
operator|--
name|ep
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|szp
operator|-=
literal|2
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|ep
operator|-
literal|1
operator|)
operator|=
operator|*
name|ep
operator|=
literal|' '
expr_stmt|;
name|roff_ccond
argument_list|(
name|r
argument_list|,
name|ROFF_ccond
argument_list|,
name|bufp
argument_list|,
name|szp
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
literal|2
argument_list|,
name|offs
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ROFFRULE_DENY
operator|==
name|rr
condition|?
name|ROFF_IGN
else|:
name|ROFF_CONT
operator|)
return|;
block|}
comment|/* 	 * A denied conditional must evaluate its children if and only 	 * if they're either structurally required (such as loops and 	 * conditionals) or a closing macro. 	 */
if|if
condition|(
name|ROFFRULE_DENY
operator|==
name|rr
condition|)
if|if
condition|(
operator|!
operator|(
name|ROFFMAC_STRUCT
operator|&
name|roffs
index|[
name|t
index|]
operator|.
name|flags
operator|)
condition|)
if|if
condition|(
name|ROFF_ccond
operator|!=
name|t
condition|)
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|proc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|proc
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|bufp
operator|,
name|szp
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cond_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|enum
name|roffrule
name|rr
decl_stmt|;
name|rr
operator|=
name|r
operator|->
name|last
operator|->
name|rule
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|ep
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
expr_stmt|;
for|for
control|(
init|;
name|NULL
operator|!=
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|ep
argument_list|,
literal|'\\'
argument_list|)
operator|)
condition|;
name|ep
operator|++
control|)
block|{
name|ep
operator|++
expr_stmt|;
if|if
condition|(
literal|'}'
operator|!=
operator|*
name|ep
condition|)
continue|continue;
operator|*
name|ep
operator|=
literal|'&'
expr_stmt|;
name|roff_ccond
argument_list|(
name|r
argument_list|,
name|ROFF_ccond
argument_list|,
name|bufp
argument_list|,
name|szp
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
literal|2
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ROFFRULE_DENY
operator|==
name|rr
condition|?
name|ROFF_IGN
else|:
name|ROFF_CONT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|roffrule
name|roff_evalcond
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|)
block|{
switch|switch
condition|(
name|v
index|[
operator|*
name|pos
index|]
condition|)
block|{
case|case
operator|(
literal|'n'
operator|)
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|ROFFRULE_ALLOW
operator|)
return|;
case|case
operator|(
literal|'e'
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
literal|'o'
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
literal|'t'
operator|)
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|ROFFRULE_DENY
operator|)
return|;
default|default:
break|break;
block|}
while|while
condition|(
name|v
index|[
operator|*
name|pos
index|]
operator|&&
literal|' '
operator|!=
name|v
index|[
operator|*
name|pos
index|]
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|ROFFRULE_DENY
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_line_ignore
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|ROFF_it
operator|==
name|tok
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQUEST
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"it"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cond
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|int
name|sv
decl_stmt|;
name|enum
name|roffrule
name|rule
decl_stmt|;
comment|/*  	 * An `.el' has no conditional body: it will consume the value 	 * of the current rstack entry set in prior `ie' calls or 	 * defaults to DENY.   	 * 	 * If we're not an `el', however, then evaluate the conditional. 	 */
name|rule
operator|=
name|ROFF_el
operator|==
name|tok
condition|?
operator|(
name|r
operator|->
name|rstackpos
operator|<
literal|0
condition|?
name|ROFFRULE_DENY
else|:
name|r
operator|->
name|rstack
index|[
name|r
operator|->
name|rstackpos
operator|--
index|]
operator|)
else|:
name|roff_evalcond
argument_list|(
operator|*
name|bufp
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|sv
operator|=
name|pos
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
condition|)
name|pos
operator|++
expr_stmt|;
comment|/* 	 * Roff is weird.  If we have just white-space after the 	 * conditional, it's considered the BODY and we exit without 	 * really doing anything.  Warn about this.  It's probably 	 * wrong. 	 */
if|if
condition|(
literal|'\0'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
operator|&&
name|sv
operator|!=
name|pos
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOARGS
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
name|roffnode_push
argument_list|(
name|r
argument_list|,
name|tok
argument_list|,
name|NULL
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|r
operator|->
name|last
operator|->
name|rule
operator|=
name|rule
expr_stmt|;
comment|/* 	 * An if-else will put the NEGATION of the current evaluated 	 * conditional into the stack of rules. 	 */
if|if
condition|(
name|ROFF_ie
operator|==
name|tok
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|rstackpos
operator|==
name|RSTACK_MAX
operator|-
literal|1
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_MEM
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_ERR
operator|)
return|;
block|}
name|r
operator|->
name|rstack
index|[
operator|++
name|r
operator|->
name|rstackpos
index|]
operator|=
name|ROFFRULE_DENY
operator|==
name|r
operator|->
name|last
operator|->
name|rule
condition|?
name|ROFFRULE_ALLOW
else|:
name|ROFFRULE_DENY
expr_stmt|;
block|}
comment|/* If the parent has false as its rule, then so do we. */
if|if
condition|(
name|r
operator|->
name|last
operator|->
name|parent
operator|&&
name|ROFFRULE_DENY
operator|==
name|r
operator|->
name|last
operator|->
name|parent
operator|->
name|rule
condition|)
name|r
operator|->
name|last
operator|->
name|rule
operator|=
name|ROFFRULE_DENY
expr_stmt|;
comment|/* 	 * Determine scope.  If we're invoked with "\{" trailing the 	 * conditional, then we're in a multiline scope.  Else our scope 	 * expires on the next line. 	 */
name|r
operator|->
name|last
operator|->
name|endspan
operator|=
literal|1
expr_stmt|;
if|if
condition|(
literal|'\\'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
operator|&&
literal|'{'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
operator|+
literal|1
index|]
condition|)
block|{
name|r
operator|->
name|last
operator|->
name|endspan
operator|=
operator|-
literal|1
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 	 * If there are no arguments on the line, the next-line scope is 	 * assumed. 	 */
if|if
condition|(
literal|'\0'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
name|pos
index|]
condition|)
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
comment|/* Otherwise re-run the roff parser after recalculating. */
operator|*
name|offs
operator|=
name|pos
expr_stmt|;
return|return
operator|(
name|ROFF_RERUN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_ds
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|string
decl_stmt|;
comment|/* 	 * A symbol is named by the first word following the macro 	 * invocation up to a space.  Its value is anything after the 	 * name's trailing whitespace and optional double-quote.  Thus, 	 * 	 *  [.ds foo "bar  "     ] 	 * 	 * will have `bar  "     ' as its value. 	 */
name|string
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
name|name
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|string
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|name
condition|)
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
comment|/* Read past initial double-quote. */
if|if
condition|(
literal|'"'
operator|==
operator|*
name|string
condition|)
name|string
operator|++
expr_stmt|;
comment|/* The rest is the value. */
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|name
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|roff_regisset
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|enum
name|regs
name|reg
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|regs
index|[
operator|(
name|int
operator|)
name|reg
index|]
operator|.
name|set
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|roff_regget
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|enum
name|regs
name|reg
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|regs
index|[
operator|(
name|int
operator|)
name|reg
index|]
operator|.
name|u
operator|)
return|;
block|}
end_function

begin_function
name|void
name|roff_regunset
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|enum
name|regs
name|reg
parameter_list|)
block|{
name|r
operator|->
name|regs
index|[
operator|(
name|int
operator|)
name|reg
index|]
operator|.
name|set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_nr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|iv
decl_stmt|;
name|val
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
name|key
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|val
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"nS"
argument_list|)
condition|)
block|{
name|r
operator|->
name|regs
index|[
operator|(
name|int
operator|)
name|REG_nS
index|]
operator|.
name|set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|iv
operator|=
name|mandoc_strntoi
argument_list|(
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
literal|10
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|r
operator|->
name|regs
index|[
operator|(
name|int
operator|)
name|REG_nS
index|]
operator|.
name|u
operator|=
operator|(
name|unsigned
operator|)
name|iv
expr_stmt|;
else|else
name|r
operator|->
name|regs
index|[
operator|(
name|int
operator|)
name|REG_nS
index|]
operator|.
name|u
operator|=
literal|0u
expr_stmt|;
block|}
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_rm
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|cp
condition|)
block|{
name|name
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
operator|*
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|name
condition|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_TE
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|tbl
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|tbl_end
argument_list|(
operator|&
name|r
operator|->
name|tbl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_T_
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|tbl
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|tbl_restart
argument_list|(
name|ppos
argument_list|,
name|ln
argument_list|,
name|r
operator|->
name|tbl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int roff_closeeqn(struct roff *r) {  	return(r->eqn&& ROFF_EQN == eqn_end(&r->eqn) ? 1 : 0); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|roff_openeqn
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|offs
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|eqn_node
modifier|*
name|e
decl_stmt|;
name|int
name|poff
decl_stmt|;
name|assert
argument_list|(
name|NULL
operator|==
name|r
operator|->
name|eqn
argument_list|)
expr_stmt|;
name|e
operator|=
name|eqn_alloc
argument_list|(
name|name
argument_list|,
name|offs
argument_list|,
name|line
argument_list|,
name|r
operator|->
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|last_eqn
condition|)
name|r
operator|->
name|last_eqn
operator|->
name|next
operator|=
name|e
expr_stmt|;
else|else
name|r
operator|->
name|first_eqn
operator|=
name|r
operator|->
name|last_eqn
operator|=
name|e
expr_stmt|;
name|r
operator|->
name|eqn
operator|=
name|r
operator|->
name|last_eqn
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|poff
operator|=
literal|0
expr_stmt|;
name|eqn_read
argument_list|(
operator|&
name|r
operator|->
name|eqn
argument_list|,
name|line
argument_list|,
name|buf
argument_list|,
name|offs
argument_list|,
operator|&
name|poff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_EQ
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|roff_openeqn
argument_list|(
name|r
argument_list|,
operator|*
name|bufp
operator|+
name|pos
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_EN
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_NOSCOPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_TS
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|struct
name|tbl_node
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|tbl
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_SCOPEBROKEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tbl_end
argument_list|(
operator|&
name|r
operator|->
name|tbl
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|tbl_alloc
argument_list|(
name|ppos
argument_list|,
name|ln
argument_list|,
name|r
operator|->
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|last_tbl
condition|)
name|r
operator|->
name|last_tbl
operator|->
name|next
operator|=
name|t
expr_stmt|;
else|else
name|r
operator|->
name|first_tbl
operator|=
name|r
operator|->
name|last_tbl
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|tbl
operator|=
name|r
operator|->
name|last_tbl
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_tr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|second
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|ssz
decl_stmt|;
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
name|p
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARGCOUNT
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
block|{
name|fsz
operator|=
name|ssz
operator|=
literal|1
expr_stmt|;
name|first
operator|=
name|p
operator|++
expr_stmt|;
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|first
condition|)
block|{
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESCAPE_ERROR
operator|==
name|esc
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BADESCAPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
operator|*
name|bufp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
name|fsz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
name|second
operator|=
name|p
operator|++
expr_stmt|;
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|second
condition|)
block|{
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESCAPE_ERROR
operator|==
name|esc
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BADESCAPE
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
operator|*
name|bufp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
name|ssz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|second
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|second
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARGCOUNT
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
operator|*
name|bufp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|second
operator|=
literal|" "
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|fsz
operator|>
literal|1
condition|)
block|{
name|roff_setstrn
argument_list|(
operator|&
name|r
operator|->
name|xmbtab
argument_list|,
name|first
argument_list|,
name|fsz
argument_list|,
name|second
argument_list|,
name|ssz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|xtab
condition|)
name|r
operator|->
name|xtab
operator|=
name|mandoc_calloc
argument_list|(
literal|128
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roffstr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|first
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|first
index|]
operator|.
name|p
operator|=
name|mandoc_strndup
argument_list|(
name|second
argument_list|,
name|ssz
argument_list|)
expr_stmt|;
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|first
index|]
operator|.
name|sz
operator|=
name|ssz
expr_stmt|;
block|}
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_so
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|mandoc_msg
argument_list|(
name|MANDOCERR_SO
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Handle `so'.  Be EXTREMELY careful, as we shouldn't be 	 * opening anything that's not in our cwd or anything beneath 	 * it.  Thus, explicitly disallow traversing up the file-system 	 * or using absolute paths. 	 */
name|name
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
if|if
condition|(
literal|'/'
operator|==
operator|*
name|name
operator|||
name|strstr
argument_list|(
name|name
argument_list|,
literal|"../"
argument_list|)
operator|||
name|strstr
argument_list|(
name|name
argument_list|,
literal|"/.."
argument_list|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_SOPATH
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_ERR
operator|)
return|;
block|}
operator|*
name|offs
operator|=
name|pos
expr_stmt|;
return|return
operator|(
name|ROFF_SO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_userdef
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|arg
index|[
literal|9
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Collect pointers to macro argument strings 	 * and null-terminate them. 	 */
name|cp
operator|=
operator|*
name|bufp
operator|+
name|pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|arg
index|[
name|i
index|]
operator|=
literal|'\0'
operator|==
operator|*
name|cp
condition|?
literal|""
else|:
name|mandoc_getarg
argument_list|(
name|r
operator|->
name|parse
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* 	 * Expand macro arguments. 	 */
operator|*
name|szp
operator|=
literal|0
expr_stmt|;
name|n1
operator|=
name|cp
operator|=
name|mandoc_strdup
argument_list|(
name|r
operator|->
name|current_string
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|cp
argument_list|,
literal|"\\$"
argument_list|)
operator|)
condition|)
block|{
name|i
operator|=
name|cp
index|[
literal|2
index|]
operator|-
literal|'1'
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|i
operator|||
literal|8
operator|<
name|i
condition|)
block|{
comment|/* Not an argument invocation. */
name|cp
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
operator|*
name|szp
operator|=
name|strlen
argument_list|(
name|n1
argument_list|)
operator|-
literal|3
operator|+
name|strlen
argument_list|(
name|arg
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n2
operator|=
name|mandoc_malloc
argument_list|(
operator|*
name|szp
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|n2
argument_list|,
name|n1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|cp
operator|-
name|n1
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|n2
argument_list|,
name|arg
index|[
name|i
index|]
argument_list|,
operator|*
name|szp
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|n2
argument_list|,
name|cp
operator|+
literal|3
argument_list|,
operator|*
name|szp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|n2
operator|+
operator|(
name|cp
operator|-
name|n1
operator|)
expr_stmt|;
name|free
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|n1
operator|=
name|n2
expr_stmt|;
block|}
comment|/* 	 * Replace the macro invocation 	 * by the expanded macro. 	 */
name|free
argument_list|(
operator|*
name|bufp
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|n1
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|*
name|szp
condition|)
operator|*
name|szp
operator|=
name|strlen
argument_list|(
operator|*
name|bufp
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
operator|*
name|szp
operator|>
literal|1
operator|&&
literal|'\n'
operator|==
operator|(
operator|*
name|bufp
operator|)
index|[
operator|(
name|int
operator|)
operator|*
name|szp
operator|-
literal|2
index|]
condition|?
name|ROFF_REPARSE
else|:
name|ROFF_APPEND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|roff_getname
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|int
name|ln
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|name
operator|=
operator|*
name|cpp
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|name
condition|)
return|return
operator|(
name|name
operator|)
return|;
comment|/* Read until end of name. */
for|for
control|(
name|cp
operator|=
name|name
init|;
literal|'\0'
operator|!=
operator|*
name|cp
operator|&&
literal|' '
operator|!=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
literal|'\\'
operator|!=
operator|*
name|cp
condition|)
continue|continue;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|cp
condition|)
continue|continue;
name|mandoc_msg
argument_list|(
name|MANDOCERR_NAMESC
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
comment|/* Nil-terminate name. */
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|cp
condition|)
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Read past spaces. */
while|while
condition|(
literal|' '
operator|==
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Store *string into the user-defined string called *name.  * In multiline mode, append to an existing entry and append '\n';  * else replace the existing entry, if there is one.  * To clear an existing entry, call with (*r, *name, NULL, 0).  */
end_comment

begin_function
specifier|static
name|void
name|roff_setstr
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|multiline
parameter_list|)
block|{
name|roff_setstrn
argument_list|(
operator|&
name|r
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|string
argument_list|,
name|string
condition|?
name|strlen
argument_list|(
name|string
argument_list|)
else|:
literal|0
argument_list|,
name|multiline
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|roff_setstrn
parameter_list|(
name|struct
name|roffkv
modifier|*
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|namesz
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|stringsz
parameter_list|,
name|int
name|multiline
parameter_list|)
block|{
name|struct
name|roffkv
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|oldch
decl_stmt|,
name|newch
decl_stmt|;
comment|/* Search for an existing string with the same name. */
name|n
operator|=
operator|*
name|r
expr_stmt|;
while|while
condition|(
name|n
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|n
operator|->
name|key
operator|.
name|p
argument_list|)
condition|)
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
block|{
comment|/* Create a new string table entry. */
name|n
operator|=
name|mandoc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|roffkv
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|key
operator|.
name|p
operator|=
name|mandoc_strndup
argument_list|(
name|name
argument_list|,
name|namesz
argument_list|)
expr_stmt|;
name|n
operator|->
name|key
operator|.
name|sz
operator|=
name|namesz
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|sz
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|next
operator|=
operator|*
name|r
expr_stmt|;
operator|*
name|r
operator|=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|multiline
condition|)
block|{
comment|/* In multiline mode, append; else replace. */
name|free
argument_list|(
name|n
operator|->
name|val
operator|.
name|p
argument_list|)
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|sz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|string
condition|)
return|return;
comment|/* 	 * One additional byte for the '\n' in multiline mode, 	 * and one for the terminating '\0'. 	 */
name|newch
operator|=
name|stringsz
operator|+
operator|(
name|multiline
condition|?
literal|2u
else|:
literal|1u
operator|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|val
operator|.
name|p
condition|)
block|{
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|mandoc_malloc
argument_list|(
name|newch
argument_list|)
expr_stmt|;
operator|*
name|n
operator|->
name|val
operator|.
name|p
operator|=
literal|'\0'
expr_stmt|;
name|oldch
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|oldch
operator|=
name|n
operator|->
name|val
operator|.
name|sz
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|mandoc_realloc
argument_list|(
name|n
operator|->
name|val
operator|.
name|p
argument_list|,
name|oldch
operator|+
name|newch
argument_list|)
expr_stmt|;
block|}
comment|/* Skip existing content in the destination buffer. */
name|c
operator|=
name|n
operator|->
name|val
operator|.
name|p
operator|+
operator|(
name|int
operator|)
name|oldch
expr_stmt|;
comment|/* Append new content to the destination buffer. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|stringsz
condition|)
block|{
comment|/* 		 * Rudimentary roff copy mode: 		 * Handle escaped backslashes. 		 */
if|if
condition|(
literal|'\\'
operator|==
name|string
index|[
name|i
index|]
operator|&&
literal|'\\'
operator|==
name|string
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|c
operator|++
operator|=
name|string
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
comment|/* Append terminating bytes. */
if|if
condition|(
name|multiline
condition|)
operator|*
name|c
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|sz
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|-
name|n
operator|->
name|val
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|roff_getstrn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|roffkv
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|r
operator|->
name|strtab
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|name
argument_list|,
name|n
operator|->
name|key
operator|.
name|p
argument_list|,
name|len
argument_list|)
operator|&&
literal|'\0'
operator|==
name|n
operator|->
name|key
operator|.
name|p
index|[
operator|(
name|int
operator|)
name|len
index|]
condition|)
return|return
operator|(
name|n
operator|->
name|val
operator|.
name|p
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|roff_freestr
parameter_list|(
name|struct
name|roffkv
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|roffkv
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
for|for
control|(
name|n
operator|=
name|r
init|;
name|n
condition|;
name|n
operator|=
name|nn
control|)
block|{
name|free
argument_list|(
name|n
operator|->
name|key
operator|.
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
operator|->
name|val
operator|.
name|p
argument_list|)
expr_stmt|;
name|nn
operator|=
name|n
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|struct
name|tbl_span
modifier|*
name|roff_span
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|tbl
condition|?
name|tbl_span
argument_list|(
name|r
operator|->
name|tbl
argument_list|)
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|eqn
modifier|*
name|roff_eqn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|last_eqn
condition|?
operator|&
name|r
operator|->
name|last_eqn
operator|->
name|eqn
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Duplicate an input string, making the appropriate character  * conversations (as stipulated by `tr') along the way.  * Returns a heap-allocated string with all the replacements made.  */
end_comment

begin_function
name|char
modifier|*
name|roff_strdup
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|roffkv
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|pp
decl_stmt|;
name|size_t
name|ssz
decl_stmt|,
name|sz
decl_stmt|;
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|xmbtab
operator|&&
name|NULL
operator|==
name|r
operator|->
name|xtab
condition|)
return|return
operator|(
name|mandoc_strdup
argument_list|(
name|p
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
return|return
operator|(
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
operator|)
return|;
comment|/* 	 * Step through each character looking for term matches 	 * (remember that a `tr' can be invoked with an escape, which is 	 * a glyph but the escape is multi-character). 	 * We only do this if the character hash has been initialised 	 * and the string is>0 length. 	 */
name|res
operator|=
name|NULL
expr_stmt|;
name|ssz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
block|{
if|if
condition|(
literal|'\\'
operator|!=
operator|*
name|p
operator|&&
name|r
operator|->
name|xtab
operator|&&
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|.
name|p
condition|)
block|{
name|sz
operator|=
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|.
name|sz
expr_stmt|;
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|.
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ssz
operator|+=
name|sz
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|'\\'
operator|!=
operator|*
name|p
condition|)
block|{
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
literal|2
argument_list|)
expr_stmt|;
name|res
index|[
name|ssz
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Search for term matches. */
for|for
control|(
name|cp
operator|=
name|r
operator|->
name|xmbtab
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|p
argument_list|,
name|cp
operator|->
name|key
operator|.
name|p
argument_list|,
name|cp
operator|->
name|key
operator|.
name|sz
argument_list|)
condition|)
break|break;
if|if
condition|(
name|NULL
operator|!=
name|cp
condition|)
block|{
comment|/* 			 * A match has been found. 			 * Append the match to the array and move 			 * forward by its keysize. 			 */
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|cp
operator|->
name|val
operator|.
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|cp
operator|->
name|val
operator|.
name|p
argument_list|,
name|cp
operator|->
name|val
operator|.
name|sz
argument_list|)
expr_stmt|;
name|ssz
operator|+=
name|cp
operator|->
name|val
operator|.
name|sz
expr_stmt|;
name|p
operator|+=
operator|(
name|int
operator|)
name|cp
operator|->
name|key
operator|.
name|sz
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Handle escapes carefully: we need to copy 		 * over just the escape itself, or else we might 		 * do replacements within the escape itself. 		 * Make sure to pass along the bogus string. 		 */
name|pp
operator|=
name|p
operator|++
expr_stmt|;
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESCAPE_ERROR
operator|==
name|esc
condition|)
block|{
name|sz
operator|=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|pp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  		 * We bail out on bad escapes.  		 * No need to warn: we already did so when 		 * roff_res() was called. 		 */
name|sz
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|pp
argument_list|)
expr_stmt|;
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|pp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ssz
operator|+=
name|sz
expr_stmt|;
block|}
name|res
index|[
operator|(
name|int
operator|)
name|ssz
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

end_unit

