begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===---- ADT/SCCIterator.h - Strongly Connected Comp. Iter. ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This builds on the llvm/ADT/GraphTraits.h file to find the strongly connected
end_comment

begin_comment
comment|// components (SCCs) of a graph in O(N+E) time using Tarjan's DFS algorithm.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The SCC iterator has the important property that if a node in SCC S1 has an
end_comment

begin_comment
comment|// edge to a node in SCC S2, then it visits S1 *after* S2.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// To visit S1 *before* S2, use the scc_iterator on the Inverse graph.
end_comment

begin_comment
comment|// (NOTE: This requires some simple wrappers and is not supported yet.)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SCCITERATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SCCITERATOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/GraphTraits.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//===----------------------------------------------------------------------===//
comment|///
comment|/// scc_iterator - Enumerate the SCCs of a directed graph, in
comment|/// reverse topological order of the SCC DAG.
comment|///
name|template
operator|<
name|class
name|GraphT
operator|,
name|class
name|GT
operator|=
name|GraphTraits
operator|<
name|GraphT
operator|>
expr|>
name|class
name|scc_iterator
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
operator|,
name|std
operator|::
name|vector
operator|<
name|typename
name|GT
operator|::
name|NodeType
operator|>
operator|,
name|ptrdiff_t
operator|>
block|{
typedef|typedef
name|typename
name|GT
operator|::
name|NodeType
name|NodeType
expr_stmt|;
typedef|typedef
name|typename
name|GT
operator|::
name|ChildIteratorType
name|ChildItTy
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|NodeType
operator|*
operator|>
name|SccTy
expr_stmt|;
typedef|typedef
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|forward_iterator_tag
operator|,
name|std
operator|::
name|vector
operator|<
name|typename
name|GT
operator|::
name|NodeType
operator|>
operator|,
name|ptrdiff_t
operator|>
name|super
expr_stmt|;
typedef|typedef
name|typename
name|super
operator|::
name|reference
name|reference
expr_stmt|;
typedef|typedef
name|typename
name|super
operator|::
name|pointer
name|pointer
expr_stmt|;
comment|// The visit counters used to detect when a complete SCC is on the stack.
comment|// visitNum is the global counter.
comment|// nodeVisitNumbers are per-node visit numbers, also used as DFS flags.
name|unsigned
name|visitNum
decl_stmt|;
name|DenseMap
operator|<
name|NodeType
operator|*
operator|,
name|unsigned
operator|>
name|nodeVisitNumbers
expr_stmt|;
comment|// SCCNodeStack - Stack holding nodes of the SCC.
name|std
operator|::
name|vector
operator|<
name|NodeType
operator|*
operator|>
name|SCCNodeStack
expr_stmt|;
comment|// CurrentSCC - The current SCC, retrieved using operator*().
name|SccTy
name|CurrentSCC
decl_stmt|;
comment|// VisitStack - Used to maintain the ordering.  Top = current block
comment|// First element is basic block pointer, second is the 'next child' to visit
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|NodeType
operator|*
operator|,
name|ChildItTy
operator|>
expr|>
name|VisitStack
expr_stmt|;
comment|// MinVisitNumStack - Stack holding the "min" values for each node in the DFS.
comment|// This is used to track the minimum uplink values for all children of
comment|// the corresponding node on the VisitStack.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|MinVisitNumStack
expr_stmt|;
comment|// A single "visit" within the non-recursive DFS traversal.
name|void
name|DFSVisitOne
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
operator|++
name|visitNum
expr_stmt|;
comment|// Global counter for the visit order
name|nodeVisitNumbers
index|[
name|N
index|]
operator|=
name|visitNum
expr_stmt|;
name|SCCNodeStack
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|MinVisitNumStack
operator|.
name|push_back
argument_list|(
name|visitNum
argument_list|)
expr_stmt|;
name|VisitStack
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|N
argument_list|,
name|GT
operator|::
name|child_begin
argument_list|(
name|N
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//dbgs()<< "TarjanSCC: Node "<< N<<
comment|//      " : visitNum = "<< visitNum<< "\n";
block|}
comment|// The stack-based DFS traversal; defined below.
name|void
name|DFSVisitChildren
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|VisitStack
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|VisitStack
operator|.
name|back
argument_list|()
operator|.
name|second
operator|!=
name|GT
operator|::
name|child_end
argument_list|(
name|VisitStack
operator|.
name|back
argument_list|()
operator|.
name|first
argument_list|)
condition|)
block|{
comment|// TOS has at least one more child so continue DFS
name|NodeType
modifier|*
name|childN
init|=
operator|*
name|VisitStack
operator|.
name|back
argument_list|()
operator|.
name|second
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|nodeVisitNumbers
operator|.
name|count
argument_list|(
name|childN
argument_list|)
condition|)
block|{
comment|// this node has never been seen.
name|DFSVisitOne
argument_list|(
name|childN
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unsigned
name|childNum
init|=
name|nodeVisitNumbers
index|[
name|childN
index|]
decl_stmt|;
if|if
condition|(
name|MinVisitNumStack
operator|.
name|back
argument_list|()
operator|>
name|childNum
condition|)
name|MinVisitNumStack
operator|.
name|back
argument_list|()
operator|=
name|childNum
expr_stmt|;
block|}
block|}
comment|// Compute the next SCC using the DFS traversal.
name|void
name|GetNextSCC
parameter_list|()
block|{
name|assert
argument_list|(
name|VisitStack
operator|.
name|size
argument_list|()
operator|==
name|MinVisitNumStack
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CurrentSCC
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Prepare to compute the next SCC
while|while
condition|(
operator|!
name|VisitStack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|DFSVisitChildren
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|VisitStack
operator|.
name|back
argument_list|()
operator|.
name|second
operator|==
name|GT
operator|::
name|child_end
argument_list|(
name|VisitStack
operator|.
name|back
argument_list|()
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|NodeType
modifier|*
name|visitingN
init|=
name|VisitStack
operator|.
name|back
argument_list|()
operator|.
name|first
decl_stmt|;
name|unsigned
name|minVisitNum
init|=
name|MinVisitNumStack
operator|.
name|back
argument_list|()
decl_stmt|;
name|VisitStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|MinVisitNumStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|MinVisitNumStack
operator|.
name|empty
argument_list|()
operator|&&
name|MinVisitNumStack
operator|.
name|back
argument_list|()
operator|>
name|minVisitNum
condition|)
name|MinVisitNumStack
operator|.
name|back
argument_list|()
operator|=
name|minVisitNum
expr_stmt|;
comment|//dbgs()<< "TarjanSCC: Popped node "<< visitingN<<
comment|//      " : minVisitNum = "<< minVisitNum<< "; Node visit num = "<<
comment|//      nodeVisitNumbers[visitingN]<< "\n";
if|if
condition|(
name|minVisitNum
operator|!=
name|nodeVisitNumbers
index|[
name|visitingN
index|]
condition|)
continue|continue;
comment|// A full SCC is on the SCCNodeStack!  It includes all nodes below
comment|// visitingN on the stack.  Copy those nodes to CurrentSCC,
comment|// reset their minVisit values, and return (this suspends
comment|// the DFS traversal till the next ++).
do|do
block|{
name|CurrentSCC
operator|.
name|push_back
argument_list|(
name|SCCNodeStack
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|SCCNodeStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|nodeVisitNumbers
index|[
name|CurrentSCC
operator|.
name|back
argument_list|()
index|]
operator|=
operator|~
literal|0U
expr_stmt|;
block|}
do|while
condition|(
name|CurrentSCC
operator|.
name|back
argument_list|()
operator|!=
name|visitingN
condition|)
do|;
return|return;
block|}
block|}
specifier|inline
name|scc_iterator
argument_list|(
name|NodeType
operator|*
name|entryN
argument_list|)
operator|:
name|visitNum
argument_list|(
literal|0
argument_list|)
block|{
name|DFSVisitOne
argument_list|(
name|entryN
argument_list|)
block|;
name|GetNextSCC
argument_list|()
block|;   }
specifier|inline
name|scc_iterator
argument_list|()
block|{
comment|/* End is when DFS stack is empty */
block|}
name|public
operator|:
typedef|typedef
name|scc_iterator
operator|<
name|GraphT
operator|,
name|GT
operator|>
name|_Self
expr_stmt|;
comment|// Provide static "constructors"...
specifier|static
specifier|inline
name|_Self
name|begin
parameter_list|(
specifier|const
name|GraphT
modifier|&
name|G
parameter_list|)
block|{
return|return
name|_Self
argument_list|(
name|GT
operator|::
name|getEntryNode
argument_list|(
name|G
argument_list|)
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|_Self
name|end
parameter_list|(
specifier|const
name|GraphT
modifier|&
parameter_list|)
block|{
return|return
name|_Self
argument_list|()
return|;
block|}
comment|// Direct loop termination test: I.isAtEnd() is more efficient than I == end()
specifier|inline
name|bool
name|isAtEnd
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|CurrentSCC
operator|.
name|empty
argument_list|()
operator|||
name|VisitStack
operator|.
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|CurrentSCC
operator|.
name|empty
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|VisitStack
operator|==
name|x
operator|.
name|VisitStack
operator|&&
name|CurrentSCC
operator|==
name|x
operator|.
name|CurrentSCC
return|;
block|}
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Self
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|x
operator|)
return|;
block|}
comment|// Iterator traversal: forward iteration only
specifier|inline
name|_Self
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
name|GetNextSCC
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
specifier|inline
name|_Self
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|_Self
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
comment|// Retrieve a reference to the current SCC
specifier|inline
specifier|const
name|SccTy
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|CurrentSCC
operator|.
name|empty
argument_list|()
operator|&&
literal|"Dereferencing END SCC iterator!"
argument_list|)
block|;
return|return
name|CurrentSCC
return|;
block|}
specifier|inline
name|SccTy
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|CurrentSCC
operator|.
name|empty
argument_list|()
operator|&&
literal|"Dereferencing END SCC iterator!"
argument_list|)
expr_stmt|;
return|return
name|CurrentSCC
return|;
block|}
comment|// hasLoop() -- Test if the current SCC has a loop.  If it has more than one
comment|// node, this is trivially true.  If not, it may still contain a loop if the
comment|// node has an edge back to itself.
name|bool
name|hasLoop
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|CurrentSCC
operator|.
name|empty
argument_list|()
operator|&&
literal|"Dereferencing END SCC iterator!"
argument_list|)
block|;
if|if
condition|(
name|CurrentSCC
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
return|return
name|true
return|;
name|NodeType
operator|*
name|N
operator|=
name|CurrentSCC
operator|.
name|front
argument_list|()
expr_stmt|;
for|for
control|(
name|ChildItTy
name|CI
init|=
name|GT
operator|::
name|child_begin
argument_list|(
name|N
argument_list|)
init|,
name|CE
init|=
name|GT
operator|::
name|child_end
argument_list|(
name|N
argument_list|)
init|;
name|CI
operator|!=
name|CE
condition|;
operator|++
name|CI
control|)
if|if
condition|(
operator|*
name|CI
operator|==
name|N
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/// ReplaceNode - This informs the scc_iterator that the specified Old node
end_comment

begin_comment
comment|/// has been deleted, and New is to be used in its place.
end_comment

begin_function
name|void
name|ReplaceNode
parameter_list|(
name|NodeType
modifier|*
name|Old
parameter_list|,
name|NodeType
modifier|*
name|New
parameter_list|)
block|{
name|assert
argument_list|(
name|nodeVisitNumbers
operator|.
name|count
argument_list|(
name|Old
argument_list|)
operator|&&
literal|"Old not in scc_iterator?"
argument_list|)
expr_stmt|;
name|nodeVisitNumbers
index|[
name|New
index|]
operator|=
name|nodeVisitNumbers
index|[
name|Old
index|]
expr_stmt|;
name|nodeVisitNumbers
operator|.
name|erase
argument_list|(
name|Old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|// Global constructor for the SCC iterator.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|scc_iterator
operator|<
name|T
operator|>
name|scc_begin
argument_list|(
argument|const T&G
argument_list|)
block|{
return|return
name|scc_iterator
operator|<
name|T
operator|>
operator|::
name|begin
argument_list|(
name|G
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|scc_iterator
operator|<
name|T
operator|>
name|scc_end
argument_list|(
argument|const T&G
argument_list|)
block|{
return|return
name|scc_iterator
operator|<
name|T
operator|>
operator|::
name|end
argument_list|(
name|G
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|scc_iterator
operator|<
name|Inverse
operator|<
name|T
operator|>
expr|>
name|scc_begin
argument_list|(
argument|const Inverse<T>&G
argument_list|)
block|{
return|return
name|scc_iterator
operator|<
name|Inverse
operator|<
name|T
operator|>
expr|>
operator|::
name|begin
argument_list|(
name|G
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|scc_iterator
operator|<
name|Inverse
operator|<
name|T
operator|>
expr|>
name|scc_end
argument_list|(
argument|const Inverse<T>&G
argument_list|)
block|{
return|return
name|scc_iterator
operator|<
name|Inverse
operator|<
name|T
operator|>
expr|>
operator|::
name|end
argument_list|(
name|G
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

