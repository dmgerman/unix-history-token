begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ELFObjectFile.h - ELF object file implementation ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the ELFObjectFile template class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_OBJECT_ELF_OBJECT_FILE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_OBJECT_ELF_OBJECT_FILE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSwitch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ObjectFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cctype>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|object
block|{
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFObjectFile
operator|:
name|public
name|ObjectFile
block|{
name|public
operator|:
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|uintX_t
name|uintX_t
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym
name|Elf_Sym
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Shdr
name|Elf_Shdr
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rel
name|Elf_Rel
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rela
name|Elf_Rela
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Dyn
name|Elf_Dyn
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym_Iter
name|Elf_Sym_Iter
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Shdr_Iter
name|Elf_Shdr_Iter
expr_stmt|;
typedef|typedef
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Dyn_Iter
name|Elf_Dyn_Iter
expr_stmt|;
name|protected
label|:
name|ELFFile
operator|<
name|ELFT
operator|>
name|EF
expr_stmt|;
name|virtual
name|error_code
name|getSymbolNext
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|SymbolRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolName
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolFileOffset
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolAddress
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolAlignment
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint32_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolSize
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolFlags
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint32_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolType
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|SymbolRef
operator|::
name|Type
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolSection
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|section_iterator
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSymbolValue
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Val
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getLibraryNext
argument_list|(
name|DataRefImpl
name|Data
argument_list|,
name|LibraryRef
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getLibraryPath
argument_list|(
name|DataRefImpl
name|Data
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSectionNext
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|SectionRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSectionName
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSectionAddress
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSectionSize
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSectionContents
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getSectionAlignment
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|isSectionText
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|isSectionData
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|isSectionBSS
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|isSectionRequiredForExecution
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|isSectionVirtual
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|isSectionZeroInit
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|isSectionReadOnlyData
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|sectionContainsSymbol
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|DataRefImpl
name|Symb
argument_list|,
name|bool
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|relocation_iterator
name|section_rel_begin
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|relocation_iterator
name|section_rel_end
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|section_iterator
name|getRelocatedSection
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getRelocationNext
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|RelocationRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getRelocationAddress
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getRelocationOffset
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|symbol_iterator
name|getRelocationSymbol
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getRelocationType
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getRelocationTypeName
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|error_code
name|getRelocationValueString
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
name|uint64_t
name|getROffset
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
name|StringRef
name|getRelocationTypeName
argument_list|(
name|uint32_t
name|Type
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Get the relocation section that contains \a Rel.
specifier|const
name|Elf_Shdr
modifier|*
name|getRelSection
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
block|{
return|return
name|EF
operator|.
name|getSection
argument_list|(
name|Rel
operator|.
name|d
operator|.
name|a
argument_list|)
return|;
block|}
specifier|const
name|Elf_Rel
modifier|*
name|getRel
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|getRela
argument_list|(
name|DataRefImpl
name|Rela
argument_list|)
decl|const
decl_stmt|;
name|Elf_Sym_Iter
name|toELFSymIter
argument_list|(
name|DataRefImpl
name|Symb
argument_list|)
decl|const
block|{
name|bool
name|IsDynamic
init|=
name|Symb
operator|.
name|p
operator|&
literal|1
decl_stmt|;
if|if
condition|(
name|IsDynamic
condition|)
return|return
name|Elf_Sym_Iter
argument_list|(
name|EF
operator|.
name|begin_dynamic_symbols
argument_list|()
operator|.
name|getEntSize
argument_list|()
argument_list|,
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|Symb
operator|.
name|p
operator|&
operator|~
name|uintptr_t
argument_list|(
literal|1
argument_list|)
operator|)
argument_list|,
name|IsDynamic
argument_list|)
return|;
return|return
name|Elf_Sym_Iter
argument_list|(
name|EF
operator|.
name|begin_symbols
argument_list|()
operator|.
name|getEntSize
argument_list|()
argument_list|,
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|Symb
operator|.
name|p
operator|)
argument_list|,
name|IsDynamic
argument_list|)
return|;
block|}
name|DataRefImpl
name|toDRI
argument_list|(
name|Elf_Sym_Iter
name|Symb
argument_list|)
decl|const
block|{
name|DataRefImpl
name|DRI
decl_stmt|;
name|DRI
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Symb
operator|.
name|get
argument_list|()
operator|)
operator||
name|static_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Symb
operator|.
name|isDynamic
argument_list|()
operator|)
expr_stmt|;
return|return
name|DRI
return|;
block|}
name|Elf_Shdr_Iter
name|toELFShdrIter
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
block|{
return|return
name|Elf_Shdr_Iter
argument_list|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_shentsize
argument_list|,
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
argument_list|)
return|;
block|}
name|DataRefImpl
name|toDRI
argument_list|(
name|Elf_Shdr_Iter
name|Sec
argument_list|)
decl|const
block|{
name|DataRefImpl
name|DRI
decl_stmt|;
name|DRI
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Sec
operator|.
name|get
argument_list|()
operator|)
expr_stmt|;
return|return
name|DRI
return|;
block|}
name|DataRefImpl
name|toDRI
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|Sec
argument_list|)
decl|const
block|{
name|DataRefImpl
name|DRI
decl_stmt|;
name|DRI
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Sec
operator|)
expr_stmt|;
return|return
name|DRI
return|;
block|}
name|Elf_Dyn_Iter
name|toELFDynIter
argument_list|(
name|DataRefImpl
name|Dyn
argument_list|)
decl|const
block|{
return|return
name|Elf_Dyn_Iter
argument_list|(
name|EF
operator|.
name|begin_dynamic_table
argument_list|()
operator|.
name|getEntSize
argument_list|()
argument_list|,
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|Dyn
operator|.
name|p
operator|)
argument_list|)
return|;
block|}
name|DataRefImpl
name|toDRI
argument_list|(
name|Elf_Dyn_Iter
name|Dyn
argument_list|)
decl|const
block|{
name|DataRefImpl
name|DRI
decl_stmt|;
name|DRI
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Dyn
operator|.
name|get
argument_list|()
operator|)
expr_stmt|;
return|return
name|DRI
return|;
block|}
comment|// This flag is used for classof, to distinguish ELFObjectFile from
comment|// its subclass. If more subclasses will be created, this flag will
comment|// have to become an enum.
name|bool
name|isDyldELFObject
decl_stmt|;
name|public
label|:
name|ELFObjectFile
argument_list|(
name|MemoryBuffer
operator|*
name|Object
argument_list|,
name|error_code
operator|&
name|ec
argument_list|)
expr_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|getSymbol
argument_list|(
name|DataRefImpl
name|Symb
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|symbol_iterator
name|begin_symbols
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|symbol_iterator
name|end_symbols
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|symbol_iterator
name|begin_dynamic_symbols
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|symbol_iterator
name|end_dynamic_symbols
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|section_iterator
name|begin_sections
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|section_iterator
name|end_sections
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|library_iterator
name|begin_libraries_needed
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|library_iterator
name|end_libraries_needed
argument_list|()
specifier|const
expr_stmt|;
name|error_code
name|getRelocationAddend
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|int64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
name|error_code
name|getSymbolVersion
argument_list|(
name|SymbolRef
name|Symb
argument_list|,
name|StringRef
operator|&
name|Version
argument_list|,
name|bool
operator|&
name|IsDefault
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|uint8_t
name|getBytesInAddress
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|StringRef
name|getFileFormatName
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|StringRef
name|getObjectType
argument_list|()
specifier|const
block|{
return|return
literal|"ELF"
return|;
block|}
name|virtual
name|unsigned
name|getArch
argument_list|()
specifier|const
expr_stmt|;
name|virtual
name|StringRef
name|getLoadName
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|*
name|getELFFile
argument_list|()
specifier|const
block|{
return|return
operator|&
name|EF
return|;
block|}
name|bool
name|isDyldType
argument_list|()
specifier|const
block|{
return|return
name|isDyldELFObject
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Binary
modifier|*
name|v
parameter_list|)
block|{
return|return
name|v
operator|->
name|getType
argument_list|()
operator|==
name|getELFType
argument_list|(
name|ELFT
operator|::
name|TargetEndianness
operator|==
name|support
operator|::
name|little
argument_list|,
name|ELFT
operator|::
name|Is64Bits
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|// Use an alignment of 2 for the typedefs since that is the worst case for
comment|// ELF files in archives.
typedef|typedef
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|little
operator|,
literal|2
operator|,
name|false
operator|>
expr|>
name|ELF32LEObjectFile
expr_stmt|;
typedef|typedef
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|little
operator|,
literal|2
operator|,
name|true
operator|>
expr|>
name|ELF64LEObjectFile
expr_stmt|;
typedef|typedef
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|big
operator|,
literal|2
operator|,
name|false
operator|>
expr|>
name|ELF32BEObjectFile
expr_stmt|;
typedef|typedef
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|big
operator|,
literal|2
operator|,
name|true
operator|>
expr|>
name|ELF64BEObjectFile
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolNext
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|SymbolRef&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|SymbolRef
argument_list|(
name|toDRI
argument_list|(
operator|++
name|toELFSymIter
argument_list|(
name|Symb
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolName
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
name|ErrorOr
operator|<
name|StringRef
operator|>
name|Name
operator|=
name|EF
operator|.
name|getSymbolName
argument_list|(
name|toELFSymIter
argument_list|(
name|Symb
argument_list|)
argument_list|)
block|;
if|if
condition|(
operator|!
name|Name
condition|)
return|return
name|Name
return|;
name|Result
operator|=
operator|*
name|Name
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolVersion
argument_list|(
argument|SymbolRef SymRef
argument_list|,
argument|StringRef&Version
argument_list|,
argument|bool&IsDefault
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|Symb
operator|=
name|SymRef
operator|.
name|getRawDataRefImpl
argument_list|()
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
name|ErrorOr
operator|<
name|StringRef
operator|>
name|Ver
operator|=
name|EF
operator|.
name|getSymbolVersion
argument_list|(
name|EF
operator|.
name|getSection
argument_list|(
name|Symb
operator|.
name|d
operator|.
name|b
argument_list|)
argument_list|,
name|symb
argument_list|,
name|IsDefault
argument_list|)
block|;
if|if
condition|(
operator|!
name|Ver
condition|)
return|return
name|Ver
return|;
name|Version
operator|=
operator|*
name|Ver
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolFileOffset
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Sym
operator|*
name|ESym
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|ESec
block|;
switch|switch
condition|(
name|EF
operator|.
name|getSymbolTableIndex
argument_list|(
name|ESym
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
comment|// Unintialized symbols have no offset in the object file
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|Result
operator|=
name|ESym
operator|->
name|st_value
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|ESec
operator|=
name|EF
operator|.
name|getSection
argument_list|(
name|ESym
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|ESym
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|ESec
condition|?
name|ESec
operator|->
name|sh_offset
else|:
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|Result
operator|=
name|ESym
operator|->
name|st_value
operator|+
operator|(
name|ESec
condition|?
name|ESec
operator|->
name|sh_offset
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_switch

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolAddress
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Sym
operator|*
name|ESym
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|ESec
block|;
switch|switch
condition|(
name|EF
operator|.
name|getSymbolTableIndex
argument_list|(
name|ESym
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|Result
operator|=
name|ESym
operator|->
name|st_value
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|ESec
operator|=
name|EF
operator|.
name|getSection
argument_list|(
name|ESym
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|ESym
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|ESec
condition|?
name|ESec
operator|->
name|sh_addr
else|:
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|bool
name|IsRelocatable
decl_stmt|;
switch|switch
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_type
condition|)
block|{
case|case
name|ELF
operator|::
name|ET_EXEC
case|:
case|case
name|ELF
operator|::
name|ET_DYN
case|:
name|IsRelocatable
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|IsRelocatable
operator|=
name|true
expr_stmt|;
block|}
name|Result
operator|=
name|ESym
operator|->
name|st_value
expr_stmt|;
comment|// Clear the ARM/Thumb indicator flag.
if|if
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_machine
operator|==
name|ELF
operator|::
name|EM_ARM
condition|)
name|Result
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|IsRelocatable
operator|&&
name|ESec
operator|!=
literal|0
condition|)
name|Result
operator|+=
name|ESec
operator|->
name|sh_addr
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_switch

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolAlignment
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint32_t&Res
argument_list|)
specifier|const
block|{
name|Elf_Sym_Iter
name|Sym
operator|=
name|toELFSymIter
argument_list|(
name|Symb
argument_list|)
block|;
if|if
condition|(
name|Sym
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_COMMON
condition|)
name|Res
operator|=
name|Sym
operator|->
name|st_value
expr_stmt|;
else|else
name|Res
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolSize
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFSymIter
argument_list|(
name|Symb
argument_list|)
operator|->
name|st_size
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolType
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|SymbolRef::Type&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Sym
operator|*
name|ESym
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
switch|switch
condition|(
name|ESym
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Unknown
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Debug
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_FILE
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_File
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Function
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_COMMON
case|:
case|case
name|ELF
operator|::
name|STT_TLS
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Data
expr_stmt|;
break|break;
default|default:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Other
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolFlags
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint32_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Sym
operator|*
name|ESym
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
name|Result
operator|=
name|SymbolRef
operator|::
name|SF_None
block|;
if|if
condition|(
name|ESym
operator|->
name|getBinding
argument_list|()
operator|!=
name|ELF
operator|::
name|STB_LOCAL
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Global
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ESym
operator|->
name|getBinding
argument_list|()
operator|==
name|ELF
operator|::
name|STB_WEAK
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Weak
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ESym
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_ABS
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Absolute
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ESym
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_FILE
operator|||
name|ESym
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_SECTION
operator|||
name|ESym
operator|==
operator|&
operator|*
name|EF
operator|.
name|begin_symbols
argument_list|()
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_FormatSpecific
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|EF
operator|.
name|getSymbolTableIndex
argument_list|(
name|ESym
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Undefined
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ESym
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_COMMON
operator|||
name|EF
operator|.
name|getSymbolTableIndex
argument_list|(
name|ESym
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_COMMON
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Common
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ESym
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_TLS
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_ThreadLocal
expr_stmt|;
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolSection
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|section_iterator&Res
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Sym
operator|*
name|ESym
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|ESec
operator|=
name|EF
operator|.
name|getSection
argument_list|(
name|ESym
argument_list|)
block|;
if|if
condition|(
operator|!
name|ESec
condition|)
name|Res
operator|=
name|end_sections
argument_list|()
expr_stmt|;
else|else
block|{
name|DataRefImpl
name|Sec
decl_stmt|;
name|Sec
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|ESec
operator|)
expr_stmt|;
name|Res
operator|=
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|Sec
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolValue
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Val
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Sym
operator|*
name|ESym
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
name|Val
operator|=
name|ESym
operator|->
name|st_value
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionNext
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|SectionRef&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|SectionRef
argument_list|(
name|toDRI
argument_list|(
operator|++
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionName
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
name|ErrorOr
operator|<
name|StringRef
operator|>
name|Name
operator|=
name|EF
operator|.
name|getSectionName
argument_list|(
operator|&
operator|*
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
argument_list|)
block|;
if|if
condition|(
operator|!
name|Name
condition|)
return|return
name|Name
return|;
name|Result
operator|=
operator|*
name|Name
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionAddress
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|->
name|sh_addr
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionSize
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|->
name|sh_size
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionContents
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
name|Elf_Shdr_Iter
name|EShdr
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
block|;
name|Result
operator|=
name|StringRef
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|EShdr
operator|->
name|sh_offset
argument_list|,
name|EShdr
operator|->
name|sh_size
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionAlignment
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|->
name|sh_addralign
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionText
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_EXECINSTR
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionData
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Elf_Shdr_Iter
name|EShdr
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
block|;
name|Result
operator|=
name|EShdr
operator|->
name|sh_flags
operator|&
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
operator|&&
name|EShdr
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_PROGBITS
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionBSS
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Elf_Shdr_Iter
name|EShdr
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
block|;
name|Result
operator|=
name|EShdr
operator|->
name|sh_flags
operator|&
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
operator|&&
name|EShdr
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionRequiredForExecution
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_ALLOC
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionVirtual
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionZeroInit
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionReadOnlyData
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Elf_Shdr_Iter
name|EShdr
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
block|;
name|Result
operator|=
operator|!
operator|(
name|EShdr
operator|->
name|sh_flags
operator|&
operator|(
name|ELF
operator|::
name|SHF_WRITE
operator||
name|ELF
operator|::
name|SHF_EXECINSTR
operator|)
operator|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|sectionContainsSymbol
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|DataRefImpl Symb
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|Elf_Sym_Iter
name|ESym
operator|=
name|toELFSymIter
argument_list|(
name|Symb
argument_list|)
block|;
name|uintX_t
name|Index
operator|=
name|ESym
operator|->
name|st_shndx
block|;
name|bool
name|Reserved
operator|=
name|Index
operator|>=
name|ELF
operator|::
name|SHN_LORESERVE
operator|&&
name|Index
operator|<=
name|ELF
operator|::
name|SHN_HIRESERVE
block|;
name|Result
operator|=
operator|!
name|Reserved
operator|&&
operator|(
operator|&
operator|*
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
operator|==
name|EF
operator|.
name|getSection
argument_list|(
name|ESym
operator|->
name|st_shndx
argument_list|)
operator|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|relocation_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|section_rel_begin
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|RelData
block|;
name|uintptr_t
name|SHT
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|EF
operator|.
name|begin_sections
argument_list|()
operator|.
name|get
argument_list|()
operator|)
block|;
name|RelData
operator|.
name|d
operator|.
name|a
operator|=
operator|(
name|Sec
operator|.
name|p
operator|-
name|SHT
operator|)
operator|/
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_shentsize
block|;
name|RelData
operator|.
name|d
operator|.
name|b
operator|=
literal|0
block|;
return|return
name|relocation_iterator
argument_list|(
name|RelocationRef
argument_list|(
name|RelData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|relocation_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|section_rel_end
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|RelData
block|;
name|uintptr_t
name|SHT
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|EF
operator|.
name|begin_sections
argument_list|()
operator|.
name|get
argument_list|()
operator|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|S
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|RelData
operator|.
name|d
operator|.
name|a
operator|=
operator|(
name|Sec
operator|.
name|p
operator|-
name|SHT
operator|)
operator|/
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_shentsize
block|;
if|if
condition|(
name|S
operator|->
name|sh_type
operator|!=
name|ELF
operator|::
name|SHT_RELA
operator|&&
name|S
operator|->
name|sh_type
operator|!=
name|ELF
operator|::
name|SHT_REL
condition|)
name|RelData
operator|.
name|d
operator|.
name|b
operator|=
literal|0
expr_stmt|;
else|else
name|RelData
operator|.
name|d
operator|.
name|b
operator|=
name|S
operator|->
name|sh_size
operator|/
name|S
operator|->
name|sh_entsize
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|relocation_iterator
argument_list|(
name|RelocationRef
argument_list|(
name|RelData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|section_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocatedSection
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|{
if|if
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_type
operator|!=
name|ELF
operator|::
name|ET_REL
condition|)
return|return
name|end_sections
argument_list|()
return|;
name|Elf_Shdr_Iter
name|EShdr
operator|=
name|toELFShdrIter
argument_list|(
name|Sec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uintX_t
name|Type
init|=
name|EShdr
operator|->
name|sh_type
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Type
operator|!=
name|ELF
operator|::
name|SHT_REL
operator|&&
name|Type
operator|!=
name|ELF
operator|::
name|SHT_RELA
condition|)
return|return
name|end_sections
argument_list|()
return|;
end_if

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|R
init|=
name|EF
operator|.
name|getSection
argument_list|(
name|EShdr
operator|->
name|sh_info
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|toDRI
argument_list|(
name|R
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Relocations
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationNext
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|RelocationRef&Result
argument_list|)
specifier|const
block|{
operator|++
name|Rel
operator|.
name|d
operator|.
name|b
block|;
name|Result
operator|=
name|RelocationRef
argument_list|(
name|Rel
argument_list|,
name|this
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationSymbol
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
block|{
name|uint32_t
name|symbolIdx
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getRelSection
argument_list|(
name|Rel
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|symbolIdx
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|symbolIdx
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}   if
operator|(
operator|!
name|symbolIdx
operator|)
end_expr_stmt

begin_return
return|return
name|end_symbols
argument_list|()
return|;
end_return

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|SymSec
init|=
name|EF
operator|.
name|getSection
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DataRefImpl
name|SymbolData
decl_stmt|;
end_decl_stmt

begin_switch
switch|switch
condition|(
name|SymSec
operator|->
name|sh_type
condition|)
block|{
default|default:
name|report_fatal_error
argument_list|(
literal|"Invalid symbol table section type!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_SYMTAB
case|:
name|SymbolData
operator|=
name|toDRI
argument_list|(
name|EF
operator|.
name|begin_symbols
argument_list|()
operator|+
name|symbolIdx
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|SHT_DYNSYM
case|:
name|SymbolData
operator|=
name|toDRI
argument_list|(
name|EF
operator|.
name|begin_dynamic_symbols
argument_list|()
operator|+
name|symbolIdx
argument_list|)
expr_stmt|;
break|break;
block|}
end_switch

begin_return
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationAddress
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|getROffset
argument_list|(
name|Rel
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationOffset
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|getROffset
argument_list|(
name|Rel
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getROffset
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getRelSection
argument_list|(
name|Rel
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
return|return
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
return|;
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
return|return
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationType
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getRelSection
argument_list|(
name|Rel
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|Result
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|Result
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}   return
name|object_error
operator|::
name|success
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationTypeName
argument_list|(
argument|uint32_t Type
argument_list|)
specifier|const
block|{
return|return
name|getELFRelocationTypeName
argument_list|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_machine
argument_list|,
name|Type
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationTypeName
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getRelSection
argument_list|(
name|Rel
argument_list|)
block|;
name|uint32_t
name|type
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
return|return
name|object_error
operator|::
name|parse_failed
return|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|type
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|type
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}    EF
operator|.
name|getRelocationTypeName
argument_list|(
name|type
argument_list|,
name|Result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationAddend
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|int64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getRelSection
argument_list|(
name|Rel
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|Result
operator|=
literal|0
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|Result
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_addend
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_block

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationValueString
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getRelSection
argument_list|(
name|Rel
argument_list|)
block|;
name|uint8_t
name|type
block|;
name|StringRef
name|res
block|;
name|int64_t
name|addend
operator|=
literal|0
block|;
name|uint16_t
name|symbol_index
operator|=
literal|0
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
return|return
name|object_error
operator|::
name|parse_failed
return|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|type
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_index
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Read implicit addend from section data.
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|type
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_index
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|EF
operator|.
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
name|addend
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_addend
expr_stmt|;
break|break;
block|}
end_block

begin_decl_stmt
unit|}   const
name|Elf_Sym
modifier|*
name|symb
init|=
name|EF
operator|.
name|template
name|getEntry
operator|<
name|Elf_Sym
operator|>
operator|(
name|sec
operator|->
name|sh_link
expr|,
name|symbol_index
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ErrorOr
operator|<
name|StringRef
operator|>
name|SymName
operator|=
name|EF
operator|.
name|getSymbolName
argument_list|(
name|EF
operator|.
name|getSection
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
argument_list|,
name|symb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|SymName
condition|)
return|return
name|SymName
return|;
end_if

begin_switch
switch|switch
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ELF
operator|::
name|R_X86_64_PC8
case|:
case|case
name|ELF
operator|::
name|R_X86_64_PC16
case|:
case|case
name|ELF
operator|::
name|R_X86_64_PC32
case|:
block|{
name|std
operator|::
name|string
name|fmtbuf
expr_stmt|;
name|raw_string_ostream
name|fmt
parameter_list|(
name|fmtbuf
parameter_list|)
function_decl|;
name|fmt
operator|<<
operator|*
name|SymName
operator|<<
operator|(
name|addend
operator|<
literal|0
condition|?
literal|""
else|:
literal|"+"
operator|)
operator|<<
name|addend
operator|<<
literal|"-P"
expr_stmt|;
name|fmt
operator|.
name|flush
argument_list|()
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|fmtbuf
operator|.
name|begin
argument_list|()
argument_list|,
name|fmtbuf
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELF
operator|::
name|R_X86_64_8
case|:
case|case
name|ELF
operator|::
name|R_X86_64_16
case|:
case|case
name|ELF
operator|::
name|R_X86_64_32
case|:
case|case
name|ELF
operator|::
name|R_X86_64_32S
case|:
case|case
name|ELF
operator|::
name|R_X86_64_64
case|:
block|{
name|std
operator|::
name|string
name|fmtbuf
expr_stmt|;
name|raw_string_ostream
name|fmt
parameter_list|(
name|fmtbuf
parameter_list|)
function_decl|;
name|fmt
operator|<<
operator|*
name|SymName
operator|<<
operator|(
name|addend
operator|<
literal|0
condition|?
literal|""
else|:
literal|"+"
operator|)
operator|<<
name|addend
expr_stmt|;
name|fmt
operator|.
name|flush
argument_list|()
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|fmtbuf
operator|.
name|begin
argument_list|()
argument_list|,
name|fmtbuf
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
break|break;
case|case
name|ELF
operator|::
name|EM_AARCH64
case|:
block|{
name|std
operator|::
name|string
name|fmtbuf
expr_stmt|;
name|raw_string_ostream
name|fmt
parameter_list|(
name|fmtbuf
parameter_list|)
function_decl|;
name|fmt
operator|<<
operator|*
name|SymName
expr_stmt|;
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
name|fmt
operator|<<
operator|(
name|addend
operator|<
literal|0
condition|?
literal|""
else|:
literal|"+"
operator|)
operator|<<
name|addend
expr_stmt|;
name|fmt
operator|.
name|flush
argument_list|()
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|fmtbuf
operator|.
name|begin
argument_list|()
argument_list|,
name|fmtbuf
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|EM_ARM
case|:
case|case
name|ELF
operator|::
name|EM_HEXAGON
case|:
name|res
operator|=
operator|*
name|SymName
expr_stmt|;
break|break;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
end_switch

begin_if
if|if
condition|(
name|Result
operator|.
name|empty
argument_list|()
condition|)
name|Result
operator|.
name|append
argument_list|(
name|res
operator|.
name|begin
argument_list|()
argument_list|,
name|res
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbol
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
return|return
operator|&
operator|*
name|toELFSymIter
argument_list|(
name|Symb
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rel
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRel
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
block|{
return|return
name|EF
operator|.
name|template
name|getEntry
operator|<
name|Elf_Rel
operator|>
operator|(
name|Rel
operator|.
name|d
operator|.
name|a
operator|,
name|Rel
operator|.
name|d
operator|.
name|b
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rela
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRela
argument_list|(
argument|DataRefImpl Rela
argument_list|)
specifier|const
block|{
return|return
name|EF
operator|.
name|template
name|getEntry
operator|<
name|Elf_Rela
operator|>
operator|(
name|Rela
operator|.
name|d
operator|.
name|a
operator|,
name|Rela
operator|.
name|d
operator|.
name|b
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|ELFObjectFile
argument_list|(
name|MemoryBuffer
operator|*
name|Object
argument_list|,
name|error_code
operator|&
name|ec
argument_list|)
operator|:
name|ObjectFile
argument_list|(
name|getELFType
argument_list|(
name|static_cast
operator|<
name|endianness
operator|>
operator|(
name|ELFT
operator|::
name|TargetEndianness
operator|)
operator|==
name|support
operator|::
name|little
argument_list|,
name|ELFT
operator|::
name|Is64Bits
argument_list|)
argument_list|,
name|Object
argument_list|)
operator|,
name|EF
argument_list|(
argument|Object
argument_list|,
argument|ec
argument_list|)
block|{}
name|template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_symbols
argument_list|()
specifier|const
block|{
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|toDRI
argument_list|(
name|EF
operator|.
name|begin_symbols
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_symbols
argument_list|()
specifier|const
block|{
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|toDRI
argument_list|(
name|EF
operator|.
name|end_symbols
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_dynamic_symbols
argument_list|()
specifier|const
block|{
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|toDRI
argument_list|(
name|EF
operator|.
name|begin_dynamic_symbols
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_dynamic_symbols
argument_list|()
specifier|const
block|{
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|toDRI
argument_list|(
name|EF
operator|.
name|end_dynamic_symbols
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|section_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_sections
argument_list|()
specifier|const
block|{
return|return
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|toDRI
argument_list|(
name|EF
operator|.
name|begin_sections
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|section_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_sections
argument_list|()
specifier|const
block|{
return|return
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|toDRI
argument_list|(
name|EF
operator|.
name|end_sections
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getLoadName
argument_list|()
specifier|const
block|{
name|Elf_Dyn_Iter
name|DI
operator|=
name|EF
operator|.
name|begin_dynamic_table
argument_list|()
block|;
name|Elf_Dyn_Iter
name|DE
operator|=
name|EF
operator|.
name|end_dynamic_table
argument_list|()
block|;
while|while
condition|(
name|DI
operator|!=
name|DE
operator|&&
name|DI
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_SONAME
condition|)
operator|++
name|DI
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|DI
operator|!=
name|DE
condition|)
return|return
name|EF
operator|.
name|getDynamicString
argument_list|(
name|DI
operator|->
name|getVal
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
literal|""
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|library_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_libraries_needed
argument_list|()
specifier|const
block|{
name|Elf_Dyn_Iter
name|DI
operator|=
name|EF
operator|.
name|begin_dynamic_table
argument_list|()
block|;
name|Elf_Dyn_Iter
name|DE
operator|=
name|EF
operator|.
name|end_dynamic_table
argument_list|()
block|;
while|while
condition|(
name|DI
operator|!=
name|DE
operator|&&
name|DI
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_SONAME
condition|)
operator|++
name|DI
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|library_iterator
argument_list|(
name|LibraryRef
argument_list|(
name|toDRI
argument_list|(
name|DI
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getLibraryNext
argument_list|(
argument|DataRefImpl Data
argument_list|,
argument|LibraryRef&Result
argument_list|)
specifier|const
block|{
name|Elf_Dyn_Iter
name|DI
operator|=
name|toELFDynIter
argument_list|(
name|Data
argument_list|)
block|;
name|Elf_Dyn_Iter
name|DE
operator|=
name|EF
operator|.
name|end_dynamic_table
argument_list|()
block|;
comment|// Skip to the next DT_NEEDED entry.
do|do
operator|++
name|DI
expr_stmt|;
do|while
condition|(
name|DI
operator|!=
name|DE
operator|&&
name|DI
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_NEEDED
condition|)
do|;
name|Result
operator|=
name|LibraryRef
argument_list|(
name|toDRI
argument_list|(
name|DI
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getLibraryPath
argument_list|(
argument|DataRefImpl Data
argument_list|,
argument|StringRef&Res
argument_list|)
specifier|const
block|{
name|Res
operator|=
name|EF
operator|.
name|getDynamicString
argument_list|(
name|toELFDynIter
argument_list|(
name|Data
argument_list|)
operator|->
name|getVal
argument_list|()
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|library_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_libraries_needed
argument_list|()
specifier|const
block|{
return|return
name|library_iterator
argument_list|(
name|LibraryRef
argument_list|(
name|toDRI
argument_list|(
name|EF
operator|.
name|end_dynamic_table
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|uint8_t
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getBytesInAddress
argument_list|()
specifier|const
block|{
return|return
name|ELFT
operator|::
name|Is64Bits
operator|?
literal|8
operator|:
literal|4
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getFileFormatName
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_ident
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELF
operator|::
name|ELFCLASS32
case|:
switch|switch
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
literal|"ELF32-i386"
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
literal|"ELF32-x86-64"
return|;
case|case
name|ELF
operator|::
name|EM_ARM
case|:
return|return
literal|"ELF32-arm"
return|;
case|case
name|ELF
operator|::
name|EM_HEXAGON
case|:
return|return
literal|"ELF32-hexagon"
return|;
case|case
name|ELF
operator|::
name|EM_MIPS
case|:
return|return
literal|"ELF32-mips"
return|;
case|case
name|ELF
operator|::
name|EM_PPC
case|:
return|return
literal|"ELF32-ppc"
return|;
default|default:
return|return
literal|"ELF32-unknown"
return|;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|ELFCLASS64
case|:
end_case

begin_switch
switch|switch
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
literal|"ELF64-i386"
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
literal|"ELF64-x86-64"
return|;
case|case
name|ELF
operator|::
name|EM_AARCH64
case|:
return|return
literal|"ELF64-aarch64"
return|;
case|case
name|ELF
operator|::
name|EM_PPC64
case|:
return|return
literal|"ELF64-ppc64"
return|;
case|case
name|ELF
operator|::
name|EM_S390
case|:
return|return
literal|"ELF64-s390"
return|;
default|default:
return|return
literal|"ELF64-unknown"
return|;
block|}
end_switch

begin_default
default|default:
end_default

begin_comment
comment|// FIXME: Proper error handling.
end_comment

begin_expr_stmt
name|report_fatal_error
argument_list|(
literal|"Invalid ELFCLASS!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|ELFT
operator|>
name|unsigned
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getArch
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|EF
operator|.
name|getHeader
argument_list|()
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
name|Triple
operator|::
name|x86
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
name|Triple
operator|::
name|x86_64
return|;
case|case
name|ELF
operator|::
name|EM_AARCH64
case|:
return|return
name|Triple
operator|::
name|aarch64
return|;
case|case
name|ELF
operator|::
name|EM_ARM
case|:
return|return
name|Triple
operator|::
name|arm
return|;
case|case
name|ELF
operator|::
name|EM_HEXAGON
case|:
return|return
name|Triple
operator|::
name|hexagon
return|;
case|case
name|ELF
operator|::
name|EM_MIPS
case|:
return|return
operator|(
name|ELFT
operator|::
name|TargetEndianness
operator|==
name|support
operator|::
name|little
operator|)
condition|?
name|Triple
operator|::
name|mipsel
else|:
name|Triple
operator|::
name|mips
return|;
case|case
name|ELF
operator|::
name|EM_PPC64
case|:
return|return
operator|(
name|ELFT
operator|::
name|TargetEndianness
operator|==
name|support
operator|::
name|little
operator|)
condition|?
name|Triple
operator|::
name|ppc64le
else|:
name|Triple
operator|::
name|ppc64
return|;
case|case
name|ELF
operator|::
name|EM_S390
case|:
return|return
name|Triple
operator|::
name|systemz
return|;
default|default:
return|return
name|Triple
operator|::
name|UnknownArch
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/// FIXME: Maybe we should have a base ElfObjectFile that is not a template
end_comment

begin_comment
comment|/// and make these member functions?
end_comment

begin_function
unit|static
specifier|inline
name|error_code
name|getELFRelocationAddend
parameter_list|(
specifier|const
name|RelocationRef
name|R
parameter_list|,
name|int64_t
modifier|&
name|Addend
parameter_list|)
block|{
specifier|const
name|ObjectFile
modifier|*
name|Obj
init|=
name|R
operator|.
name|getObjectFile
argument_list|()
decl_stmt|;
name|DataRefImpl
name|DRI
init|=
name|R
operator|.
name|getRawDataRefImpl
argument_list|()
decl_stmt|;
comment|// Little-endian 32-bit
if|if
condition|(
specifier|const
name|ELF32LEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF32LEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getRelocationAddend
argument_list|(
name|DRI
argument_list|,
name|Addend
argument_list|)
return|;
comment|// Big-endian 32-bit
if|if
condition|(
specifier|const
name|ELF32BEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF32BEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getRelocationAddend
argument_list|(
name|DRI
argument_list|,
name|Addend
argument_list|)
return|;
comment|// Little-endian 64-bit
if|if
condition|(
specifier|const
name|ELF64LEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF64LEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getRelocationAddend
argument_list|(
name|DRI
argument_list|,
name|Addend
argument_list|)
return|;
comment|// Big-endian 64-bit
if|if
condition|(
specifier|const
name|ELF64BEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF64BEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getRelocationAddend
argument_list|(
name|DRI
argument_list|,
name|Addend
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Object passed to getELFRelocationAddend() is not ELF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// This is a generic interface for retrieving GNU symbol version
end_comment

begin_comment
comment|/// information from an ELFObjectFile.
end_comment

begin_function
specifier|static
specifier|inline
name|error_code
name|GetELFSymbolVersion
parameter_list|(
specifier|const
name|ObjectFile
modifier|*
name|Obj
parameter_list|,
specifier|const
name|SymbolRef
modifier|&
name|Sym
parameter_list|,
name|StringRef
modifier|&
name|Version
parameter_list|,
name|bool
modifier|&
name|IsDefault
parameter_list|)
block|{
comment|// Little-endian 32-bit
if|if
condition|(
specifier|const
name|ELF32LEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF32LEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Big-endian 32-bit
if|if
condition|(
specifier|const
name|ELF32BEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF32BEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Little-endian 64-bit
if|if
condition|(
specifier|const
name|ELF64LEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF64LEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Big-endian 64-bit
if|if
condition|(
specifier|const
name|ELF64BEObjectFile
modifier|*
name|ELFObj
init|=
name|dyn_cast
operator|<
name|ELF64BEObjectFile
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Object passed to GetELFSymbolVersion() is not ELF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
unit|} }
endif|#
directive|endif
end_endif

end_unit

