begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/IntegersSubset.h - The subset of integers ----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// @file
end_comment

begin_comment
comment|/// This file contains class that implements constant set of ranges:
end_comment

begin_comment
comment|/// [<Low0,High0>,...,<LowN,HighN>]. Initially, this class was created for
end_comment

begin_comment
comment|/// SwitchInst and was used for case value representation that may contain
end_comment

begin_comment
comment|/// multiple ranges for a single successor.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_INTEGERSSUBSET_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_INTEGERSSUBSET_H
end_define

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DerivedTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|// The IntItem is a wrapper for APInt.
comment|// 1. It determines sign of integer, it allows to use
comment|//    comparison operators>,<,>=,<=, and as result we got shorter and cleaner
comment|//    constructions.
comment|// 2. It helps to implement PR1255 (case ranges) as a series of small patches.
comment|// 3. Currently we can interpret IntItem both as ConstantInt and as APInt.
comment|//    It allows to provide SwitchInst methods that works with ConstantInt for
comment|//    non-updated passes. And it allows to use APInt interface for new methods.
comment|// 4. IntItem can be easily replaced with APInt.
comment|// The set of macros that allows to propagate APInt operators to the IntItem.
define|#
directive|define
name|INT_ITEM_DEFINE_COMPARISON
parameter_list|(
name|op
parameter_list|,
name|func
parameter_list|)
define|\
value|bool operator op (const APInt& RHS) const { \     return getAPIntValue().func(RHS); \   }
define|#
directive|define
name|INT_ITEM_DEFINE_UNARY_OP
parameter_list|(
name|op
parameter_list|)
define|\
value|IntItem operator op () const { \     APInt res = op(getAPIntValue()); \     Constant *NewVal = ConstantInt::get(ConstantIntVal->getContext(), res); \     return IntItem(cast<ConstantInt>(NewVal)); \   }
define|#
directive|define
name|INT_ITEM_DEFINE_BINARY_OP
parameter_list|(
name|op
parameter_list|)
define|\
value|IntItem operator op (const APInt& RHS) const { \     APInt res = getAPIntValue() op RHS; \     Constant *NewVal = ConstantInt::get(ConstantIntVal->getContext(), res); \     return IntItem(cast<ConstantInt>(NewVal)); \   }
define|#
directive|define
name|INT_ITEM_DEFINE_ASSIGNMENT_BY_OP
parameter_list|(
name|op
parameter_list|)
define|\
value|IntItem& operator op (const APInt& RHS) {\     APInt res = getAPIntValue();\     res op RHS; \     Constant *NewVal = ConstantInt::get(ConstantIntVal->getContext(), res); \     ConstantIntVal = cast<ConstantInt>(NewVal); \     return *this; \   }
define|#
directive|define
name|INT_ITEM_DEFINE_PREINCDEC
parameter_list|(
name|op
parameter_list|)
define|\
value|IntItem& operator op () { \       APInt res = getAPIntValue(); \       op(res); \       Constant *NewVal = ConstantInt::get(ConstantIntVal->getContext(), res); \       ConstantIntVal = cast<ConstantInt>(NewVal); \       return *this; \     }
define|#
directive|define
name|INT_ITEM_DEFINE_POSTINCDEC
parameter_list|(
name|op
parameter_list|)
define|\
value|IntItem& operator op (int) { \       APInt res = getAPIntValue();\       op(res); \       Constant *NewVal = ConstantInt::get(ConstantIntVal->getContext(), res); \       OldConstantIntVal = ConstantIntVal; \       ConstantIntVal = cast<ConstantInt>(NewVal); \       return IntItem(OldConstantIntVal); \     }
define|#
directive|define
name|INT_ITEM_DEFINE_OP_STANDARD_INT
parameter_list|(
name|RetTy
parameter_list|,
name|op
parameter_list|,
name|IntTy
parameter_list|)
define|\
value|RetTy operator op (IntTy RHS) const { \     return (*this) op APInt(getAPIntValue().getBitWidth(), RHS); \   }
name|class
name|IntItem
block|{
name|ConstantInt
modifier|*
name|ConstantIntVal
decl_stmt|;
specifier|const
name|APInt
modifier|*
name|APIntVal
decl_stmt|;
name|IntItem
argument_list|(
specifier|const
name|ConstantInt
operator|*
name|V
argument_list|)
operator|:
name|ConstantIntVal
argument_list|(
name|const_cast
operator|<
name|ConstantInt
operator|*
operator|>
operator|(
name|V
operator|)
argument_list|)
operator|,
name|APIntVal
argument_list|(
argument|&ConstantIntVal->getValue()
argument_list|)
block|{}
specifier|const
name|APInt
operator|&
name|getAPIntValue
argument_list|()
specifier|const
block|{
return|return
operator|*
name|APIntVal
return|;
block|}
name|public
label|:
name|IntItem
argument_list|()
block|{}
name|operator
specifier|const
name|APInt
operator|&
operator|(
operator|)
specifier|const
block|{
return|return
name|getAPIntValue
argument_list|()
return|;
block|}
comment|// Propagate APInt operators.
comment|// Note, that
comment|// /,/=,>>,>>= are not implemented in APInt.
comment|//<<= is implemented for unsigned RHS, but not implemented for APInt RHS.
name|INT_ITEM_DEFINE_COMPARISON
argument_list|(
argument|<
argument_list|,
argument|ult
argument_list|)
name|INT_ITEM_DEFINE_COMPARISON
argument_list|(
argument|>
argument_list|,
argument|ugt
argument_list|)
name|INT_ITEM_DEFINE_COMPARISON
argument_list|(
argument|<=
argument_list|,
argument|ule
argument_list|)
name|INT_ITEM_DEFINE_COMPARISON
argument_list|(
argument|>=
argument_list|,
argument|uge
argument_list|)
name|INT_ITEM_DEFINE_COMPARISON
argument_list|(
argument|==
argument_list|,
argument|eq
argument_list|)
name|INT_ITEM_DEFINE_OP_STANDARD_INT
argument_list|(
argument|bool
argument_list|,
argument|==
argument_list|,
argument|uint64_t
argument_list|)
name|INT_ITEM_DEFINE_COMPARISON
argument_list|(
argument|!=
argument_list|,
argument|ne
argument_list|)
name|INT_ITEM_DEFINE_OP_STANDARD_INT
argument_list|(
argument|bool
argument_list|,
argument|!=
argument_list|,
argument|uint64_t
argument_list|)
name|INT_ITEM_DEFINE_BINARY_OP
argument_list|(
argument|*
argument_list|)
name|INT_ITEM_DEFINE_BINARY_OP
argument_list|(
argument|+
argument_list|)
name|INT_ITEM_DEFINE_OP_STANDARD_INT
argument_list|(
argument|IntItem
argument_list|,
argument|+
argument_list|,
argument|uint64_t
argument_list|)
name|INT_ITEM_DEFINE_BINARY_OP
argument_list|(
argument|-
argument_list|)
name|INT_ITEM_DEFINE_OP_STANDARD_INT
argument_list|(
argument|IntItem
argument_list|,
argument|-
argument_list|,
argument|uint64_t
argument_list|)
name|INT_ITEM_DEFINE_BINARY_OP
argument_list|(
argument|<<
argument_list|)
name|INT_ITEM_DEFINE_OP_STANDARD_INT
argument_list|(
argument|IntItem
argument_list|,
argument|<<
argument_list|,
argument|unsigned
argument_list|)
name|INT_ITEM_DEFINE_BINARY_OP
argument_list|(
argument|&
argument_list|)
name|INT_ITEM_DEFINE_BINARY_OP
argument_list|(
argument|^
argument_list|)
name|INT_ITEM_DEFINE_BINARY_OP
argument_list|(
argument||
argument_list|)
name|INT_ITEM_DEFINE_ASSIGNMENT_BY_OP
argument_list|(
argument|*=
argument_list|)
name|INT_ITEM_DEFINE_ASSIGNMENT_BY_OP
argument_list|(
argument|+=
argument_list|)
name|INT_ITEM_DEFINE_ASSIGNMENT_BY_OP
argument_list|(
argument|-=
argument_list|)
name|INT_ITEM_DEFINE_ASSIGNMENT_BY_OP
argument_list|(
argument|&=
argument_list|)
name|INT_ITEM_DEFINE_ASSIGNMENT_BY_OP
argument_list|(
argument|^=
argument_list|)
name|INT_ITEM_DEFINE_ASSIGNMENT_BY_OP
argument_list|(
argument||=
argument_list|)
comment|// Special case for<<=
name|IntItem
operator|&
name|operator
operator|<<=
operator|(
name|unsigned
name|RHS
operator|)
block|{
name|APInt
name|res
operator|=
name|getAPIntValue
argument_list|()
block|;
name|res
operator|<<=
name|RHS
block|;
name|Constant
operator|*
name|NewVal
operator|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|ConstantIntVal
operator|->
name|getContext
argument_list|()
argument_list|,
name|res
argument_list|)
block|;
name|ConstantIntVal
operator|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|NewVal
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|INT_ITEM_DEFINE_UNARY_OP
argument_list|(
argument|-
argument_list|)
name|INT_ITEM_DEFINE_UNARY_OP
argument_list|(
argument|~
argument_list|)
name|INT_ITEM_DEFINE_PREINCDEC
argument_list|(
argument|++
argument_list|)
name|INT_ITEM_DEFINE_PREINCDEC
argument_list|(
argument|--
argument_list|)
comment|// The set of workarounds, since currently we use ConstantInt implemented
comment|// integer.
specifier|static
name|IntItem
name|fromConstantInt
parameter_list|(
specifier|const
name|ConstantInt
modifier|*
name|V
parameter_list|)
block|{
return|return
name|IntItem
argument_list|(
name|V
argument_list|)
return|;
block|}
specifier|static
name|IntItem
name|fromType
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
specifier|const
name|APInt
modifier|&
name|V
parameter_list|)
block|{
name|ConstantInt
modifier|*
name|C
init|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|ConstantInt
operator|::
name|get
argument_list|(
name|Ty
argument_list|,
name|V
argument_list|)
operator|)
decl_stmt|;
return|return
name|fromConstantInt
argument_list|(
name|C
argument_list|)
return|;
block|}
specifier|static
name|IntItem
name|withImplLikeThis
parameter_list|(
specifier|const
name|IntItem
modifier|&
name|LikeThis
parameter_list|,
specifier|const
name|APInt
modifier|&
name|V
parameter_list|)
block|{
name|ConstantInt
modifier|*
name|C
init|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|ConstantInt
operator|::
name|get
argument_list|(
name|LikeThis
operator|.
name|ConstantIntVal
operator|->
name|getContext
argument_list|()
argument_list|,
name|V
argument_list|)
operator|)
decl_stmt|;
return|return
name|fromConstantInt
argument_list|(
name|C
argument_list|)
return|;
block|}
name|ConstantInt
operator|*
name|toConstantInt
argument_list|()
specifier|const
block|{
return|return
name|ConstantIntVal
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|IntType
operator|>
name|class
name|IntRange
block|{
name|protected
operator|:
name|IntType
name|Low
block|;
name|IntType
name|High
block|;
name|bool
name|IsEmpty
operator|:
literal|1
block|;
name|bool
name|IsSingleNumber
operator|:
literal|1
block|;
name|public
operator|:
typedef|typedef
name|IntRange
operator|<
name|IntType
operator|>
name|self
expr_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|self
operator|,
name|self
operator|>
name|SubRes
expr_stmt|;
name|IntRange
argument_list|()
operator|:
name|IsEmpty
argument_list|(
argument|true
argument_list|)
block|{}
name|IntRange
argument_list|(
specifier|const
name|self
operator|&
name|RHS
argument_list|)
operator|:
name|Low
argument_list|(
name|RHS
operator|.
name|Low
argument_list|)
operator|,
name|High
argument_list|(
name|RHS
operator|.
name|High
argument_list|)
operator|,
name|IsEmpty
argument_list|(
name|RHS
operator|.
name|IsEmpty
argument_list|)
operator|,
name|IsSingleNumber
argument_list|(
argument|RHS.IsSingleNumber
argument_list|)
block|{}
name|IntRange
argument_list|(
specifier|const
name|IntType
operator|&
name|C
argument_list|)
operator|:
name|Low
argument_list|(
name|C
argument_list|)
operator|,
name|High
argument_list|(
name|C
argument_list|)
operator|,
name|IsEmpty
argument_list|(
name|false
argument_list|)
operator|,
name|IsSingleNumber
argument_list|(
argument|true
argument_list|)
block|{}
name|IntRange
argument_list|(
specifier|const
name|IntType
operator|&
name|L
argument_list|,
specifier|const
name|IntType
operator|&
name|H
argument_list|)
operator|:
name|Low
argument_list|(
name|L
argument_list|)
operator|,
name|High
argument_list|(
name|H
argument_list|)
operator|,
name|IsEmpty
argument_list|(
name|false
argument_list|)
operator|,
name|IsSingleNumber
argument_list|(
argument|Low == High
argument_list|)
block|{}
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
name|IsEmpty
return|;
block|}
name|bool
name|isSingleNumber
argument_list|()
specifier|const
block|{
return|return
name|IsSingleNumber
return|;
block|}
specifier|const
name|IntType
operator|&
name|getLow
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|IsEmpty
operator|&&
literal|"Range is empty."
argument_list|)
block|;
return|return
name|Low
return|;
block|}
specifier|const
name|IntType
operator|&
name|getHigh
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|IsEmpty
operator|&&
literal|"Range is empty."
argument_list|)
block|;
return|return
name|High
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|self
operator|&
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|IsEmpty
operator|&&
literal|"Left range is empty."
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|RHS
operator|.
name|IsEmpty
operator|&&
literal|"Right range is empty."
argument_list|)
block|;
if|if
condition|(
name|Low
operator|==
name|RHS
operator|.
name|Low
condition|)
block|{
if|if
condition|(
name|High
operator|>
name|RHS
operator|.
name|High
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|Low
operator|<
name|RHS
operator|.
name|Low
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|self
operator|&
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|IsEmpty
operator|&&
literal|"Left range is empty."
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|RHS
operator|.
name|IsEmpty
operator|&&
literal|"Right range is empty."
argument_list|)
block|;
return|return
name|Low
operator|==
name|RHS
operator|.
name|Low
operator|&&
name|High
operator|==
name|RHS
operator|.
name|High
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|self
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|LessBySize
parameter_list|(
specifier|const
name|self
modifier|&
name|LHS
parameter_list|,
specifier|const
name|self
modifier|&
name|RHS
parameter_list|)
block|{
return|return
operator|(
name|LHS
operator|.
name|High
operator|-
name|LHS
operator|.
name|Low
operator|)
operator|<
operator|(
name|RHS
operator|.
name|High
operator|-
name|RHS
operator|.
name|Low
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|isInRange
argument_list|(
specifier|const
name|IntType
operator|&
name|IntVal
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|!
name|IsEmpty
operator|&&
literal|"Range is empty."
argument_list|)
expr_stmt|;
return|return
name|IntVal
operator|>=
name|Low
operator|&&
name|IntVal
operator|<=
name|High
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|SubRes
name|sub
argument_list|(
specifier|const
name|self
operator|&
name|RHS
argument_list|)
decl|const
block|{
name|SubRes
name|Res
decl_stmt|;
comment|// RHS is either more global and includes this range or
comment|// if it doesn't intersected with this range.
if|if
condition|(
operator|!
name|isInRange
argument_list|(
name|RHS
operator|.
name|Low
argument_list|)
operator|&&
operator|!
name|isInRange
argument_list|(
name|RHS
operator|.
name|High
argument_list|)
condition|)
block|{
comment|// If RHS more global (it is enough to check
comment|// only one border in this case.
if|if
condition|(
name|RHS
operator|.
name|isInRange
argument_list|(
name|Low
argument_list|)
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|self
argument_list|(
name|Low
argument_list|,
name|High
argument_list|)
argument_list|,
name|self
argument_list|()
argument_list|)
return|;
return|return
name|Res
return|;
block|}
if|if
condition|(
name|Low
operator|<
name|RHS
operator|.
name|Low
condition|)
block|{
name|Res
operator|.
name|first
operator|.
name|Low
operator|=
name|Low
expr_stmt|;
name|IntType
name|NewHigh
init|=
name|RHS
operator|.
name|Low
decl_stmt|;
operator|--
name|NewHigh
expr_stmt|;
name|Res
operator|.
name|first
operator|.
name|High
operator|=
name|NewHigh
expr_stmt|;
block|}
if|if
condition|(
name|High
operator|>
name|RHS
operator|.
name|High
condition|)
block|{
name|IntType
name|NewLow
init|=
name|RHS
operator|.
name|High
decl_stmt|;
operator|++
name|NewLow
expr_stmt|;
name|Res
operator|.
name|second
operator|.
name|Low
operator|=
name|NewLow
expr_stmt|;
name|Res
operator|.
name|second
operator|.
name|High
operator|=
name|High
expr_stmt|;
block|}
return|return
name|Res
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// IntegersSubsetGeneric - class that implements the subset of integers. It
end_comment

begin_comment
comment|/// consists from ranges and single numbers.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|IntTy
operator|>
name|class
name|IntegersSubsetGeneric
block|{
name|public
operator|:
comment|// Use Chris Lattner idea, that was initially described here:
comment|// http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20120213/136954.html
comment|// In short, for more compact memory consumption we can store flat
comment|// numbers collection, and define range as pair of indices.
comment|// In that case we can safe some memory on 32 bit machines.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|IntTy
operator|>
name|FlatCollectionTy
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|IntTy
operator|*
operator|,
name|IntTy
operator|*
operator|>
name|RangeLinkTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|RangeLinkTy
operator|>
name|RangeLinksTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|RangeLinksTy
operator|::
name|const_iterator
name|RangeLinksConstIt
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|IntegersSubsetGeneric
operator|<
name|IntTy
operator|>
name|self
expr_stmt|;
end_typedef

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|FlatCollectionTy
name|FlatCollection
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RangeLinksTy
name|RangeLinks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|IsSingleNumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|IsSingleNumbersOnly
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|class
name|RangesCollectionTy
operator|>
name|explicit
name|IntegersSubsetGeneric
argument_list|(
argument|const RangesCollectionTy& Links
argument_list|)
block|{
name|assert
argument_list|(
name|Links
operator|.
name|size
argument_list|()
operator|&&
literal|"Empty ranges are not allowed."
argument_list|)
block|;
comment|// In case of big set of single numbers consumes additional RAM space,
comment|// but allows to avoid additional reallocation.
name|FlatCollection
operator|.
name|reserve
argument_list|(
name|Links
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
block|;
name|RangeLinks
operator|.
name|reserve
argument_list|(
name|Links
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|IsSingleNumbersOnly
operator|=
name|true
block|;
for|for
control|(
name|typename
name|RangesCollectionTy
operator|::
name|const_iterator
name|i
operator|=
name|Links
operator|.
name|begin
argument_list|()
operator|,
name|e
operator|=
name|Links
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|RangeLinkTy
name|RangeLink
decl_stmt|;
name|FlatCollection
operator|.
name|push_back
argument_list|(
name|i
operator|->
name|getLow
argument_list|()
argument_list|)
expr_stmt|;
name|RangeLink
operator|.
name|first
operator|=
operator|&
name|FlatCollection
operator|.
name|back
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|getLow
argument_list|()
operator|!=
name|i
operator|->
name|getHigh
argument_list|()
condition|)
block|{
name|FlatCollection
operator|.
name|push_back
argument_list|(
name|i
operator|->
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
name|IsSingleNumbersOnly
operator|=
name|false
expr_stmt|;
block|}
name|RangeLink
operator|.
name|second
operator|=
operator|&
name|FlatCollection
operator|.
name|back
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RangeLinks
operator|.
name|push_back
argument_list|(
name|RangeLink
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     IsSingleNumber
operator|=
name|IsSingleNumbersOnly
operator|&&
name|RangeLinks
operator|.
name|size
argument_list|()
operator|==
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    IntegersSubsetGeneric
operator|(
specifier|const
name|self
operator|&
name|RHS
operator|)
block|{
operator|*
name|this
operator|=
name|RHS
block|;   }
name|self
operator|&
name|operator
operator|=
operator|(
specifier|const
name|self
operator|&
name|RHS
operator|)
block|{
name|FlatCollection
operator|.
name|clear
argument_list|()
block|;
name|RangeLinks
operator|.
name|clear
argument_list|()
block|;
name|FlatCollection
operator|.
name|reserve
argument_list|(
name|RHS
operator|.
name|RangeLinks
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
block|;
name|RangeLinks
operator|.
name|reserve
argument_list|(
name|RHS
operator|.
name|RangeLinks
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|RangeLinksConstIt
name|i
init|=
name|RHS
operator|.
name|RangeLinks
operator|.
name|begin
argument_list|()
init|,
name|e
init|=
name|RHS
operator|.
name|RangeLinks
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|RangeLinkTy
name|RangeLink
decl_stmt|;
name|FlatCollection
operator|.
name|push_back
argument_list|(
operator|*
operator|(
name|i
operator|->
name|first
operator|)
argument_list|)
expr_stmt|;
name|RangeLink
operator|.
name|first
operator|=
operator|&
name|FlatCollection
operator|.
name|back
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|first
operator|!=
name|i
operator|->
name|second
condition|)
name|FlatCollection
operator|.
name|push_back
argument_list|(
operator|*
operator|(
name|i
operator|->
name|second
operator|)
argument_list|)
expr_stmt|;
name|RangeLink
operator|.
name|second
operator|=
operator|&
name|FlatCollection
operator|.
name|back
argument_list|()
expr_stmt|;
name|RangeLinks
operator|.
name|push_back
argument_list|(
name|RangeLink
argument_list|)
expr_stmt|;
block|}
name|IsSingleNumber
operator|=
name|RHS
operator|.
name|IsSingleNumber
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IsSingleNumbersOnly
operator|=
name|RHS
operator|.
name|IsSingleNumbersOnly
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    typedef
name|IntRange
operator|<
name|IntTy
operator|>
name|Range
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Checks is the given constant satisfies this case. Returns
end_comment

begin_comment
comment|/// true if it equals to one of contained values or belongs to the one of
end_comment

begin_comment
comment|/// contained ranges.
end_comment

begin_decl_stmt
name|bool
name|isSatisfies
argument_list|(
specifier|const
name|IntTy
operator|&
name|CheckingVal
argument_list|)
decl|const
block|{
if|if
condition|(
name|IsSingleNumber
condition|)
return|return
name|FlatCollection
operator|.
name|front
argument_list|()
operator|==
name|CheckingVal
return|;
if|if
condition|(
name|IsSingleNumbersOnly
condition|)
return|return
name|std
operator|::
name|find
argument_list|(
name|FlatCollection
operator|.
name|begin
argument_list|()
argument_list|,
name|FlatCollection
operator|.
name|end
argument_list|()
argument_list|,
name|CheckingVal
argument_list|)
operator|!=
name|FlatCollection
operator|.
name|end
argument_list|()
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumItems
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|RangeLinks
index|[
name|i
index|]
operator|.
name|first
operator|==
name|RangeLinks
index|[
name|i
index|]
operator|.
name|second
condition|)
block|{
if|if
condition|(
operator|*
name|RangeLinks
index|[
name|i
index|]
operator|.
name|first
operator|==
name|CheckingVal
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|RangeLinks
index|[
name|i
index|]
operator|.
name|first
operator|<=
name|CheckingVal
operator|&&
operator|*
name|RangeLinks
index|[
name|i
index|]
operator|.
name|second
operator|>=
name|CheckingVal
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns set's item with given index.
end_comment

begin_decl_stmt
name|Range
name|getItem
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
specifier|const
name|RangeLinkTy
modifier|&
name|Link
init|=
name|RangeLinks
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|Link
operator|.
name|first
operator|!=
name|Link
operator|.
name|second
condition|)
return|return
name|Range
argument_list|(
operator|*
name|Link
operator|.
name|first
argument_list|,
operator|*
name|Link
operator|.
name|second
argument_list|)
return|;
else|else
return|return
name|Range
argument_list|(
operator|*
name|Link
operator|.
name|first
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Return number of items (ranges) stored in set.
end_comment

begin_expr_stmt
name|unsigned
name|getNumItems
argument_list|()
specifier|const
block|{
return|return
name|RangeLinks
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns true if whole subset contains single element.
end_comment

begin_expr_stmt
name|bool
name|isSingleNumber
argument_list|()
specifier|const
block|{
return|return
name|IsSingleNumber
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns true if whole subset contains only single numbers, no ranges.
end_comment

begin_expr_stmt
name|bool
name|isSingleNumbersOnly
argument_list|()
specifier|const
block|{
return|return
name|IsSingleNumbersOnly
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Does the same like getItem(idx).isSingleNumber(), but
end_comment

begin_comment
comment|/// works faster, since we avoid creation of temporary range object.
end_comment

begin_decl_stmt
name|bool
name|isSingleNumber
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
return|return
name|RangeLinks
index|[
name|idx
index|]
operator|.
name|first
operator|==
name|RangeLinks
index|[
name|idx
index|]
operator|.
name|second
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns set the size, that equals number of all values + sizes of all
end_comment

begin_comment
comment|/// ranges.
end_comment

begin_comment
comment|/// Ranges set is considered as flat numbers collection.
end_comment

begin_comment
comment|/// E.g.: for range [<0>,<1>,<4,8>] the size will 7;
end_comment

begin_comment
comment|///       for range [<0>,<1>,<5>] the size will 3
end_comment

begin_expr_stmt
name|unsigned
name|getSize
argument_list|()
specifier|const
block|{
name|APInt
name|sz
argument_list|(
operator|(
operator|(
specifier|const
name|APInt
operator|&
operator|)
name|getItem
argument_list|(
literal|0
argument_list|)
operator|.
name|getLow
argument_list|()
operator|)
operator|.
name|getBitWidth
argument_list|()
argument_list|,
literal|0
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumItems
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|APInt
name|Low
init|=
name|getItem
argument_list|(
name|i
argument_list|)
operator|.
name|getLow
argument_list|()
decl_stmt|;
specifier|const
name|APInt
name|High
init|=
name|getItem
argument_list|(
name|i
argument_list|)
operator|.
name|getHigh
argument_list|()
decl_stmt|;
name|APInt
name|S
init|=
name|High
operator|-
name|Low
operator|+
literal|1
decl_stmt|;
name|sz
operator|+=
name|S
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|sz
operator|.
name|getZExtValue
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// Allows to access single value even if it belongs to some range.
end_comment

begin_comment
comment|/// Ranges set is considered as flat numbers collection.
end_comment

begin_comment
comment|/// [<1>,<4,8>] is considered as [1,4,5,6,7,8]
end_comment

begin_comment
comment|/// For range [<1>,<4,8>] getSingleValue(3) returns 6.
end_comment

begin_macro
unit|APInt
name|getSingleValue
argument_list|(
argument|unsigned idx
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
name|APInt
name|sz
argument_list|(
operator|(
operator|(
specifier|const
name|APInt
operator|&
operator|)
name|getItem
argument_list|(
literal|0
argument_list|)
operator|.
name|getLow
argument_list|()
operator|)
operator|.
name|getBitWidth
argument_list|()
argument_list|,
literal|0
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumItems
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|APInt
name|Low
init|=
name|getItem
argument_list|(
name|i
argument_list|)
operator|.
name|getLow
argument_list|()
decl_stmt|;
specifier|const
name|APInt
name|High
init|=
name|getItem
argument_list|(
name|i
argument_list|)
operator|.
name|getHigh
argument_list|()
decl_stmt|;
name|APInt
name|S
init|=
name|High
operator|-
name|Low
operator|+
literal|1
decl_stmt|;
name|APInt
name|oldSz
init|=
name|sz
decl_stmt|;
name|sz
operator|+=
name|S
expr_stmt|;
if|if
condition|(
name|sz
operator|.
name|ugt
argument_list|(
name|idx
argument_list|)
condition|)
block|{
name|APInt
name|Res
init|=
name|Low
decl_stmt|;
name|APInt
name|Offset
argument_list|(
name|oldSz
operator|.
name|getBitWidth
argument_list|()
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|Offset
operator|-=
name|oldSz
expr_stmt|;
name|Res
operator|+=
name|Offset
expr_stmt|;
return|return
name|Res
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     assert
operator|(
literal|0
operator|&&
literal|"Index exceeds high border."
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|sz
return|;
end_return

begin_comment
unit|}
comment|/// Does the same as getSingleValue, but works only if subset contains
end_comment

begin_comment
comment|/// single numbers only.
end_comment

begin_decl_stmt
unit|const
name|IntTy
modifier|&
name|getSingleNumber
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|IsSingleNumbersOnly
operator|&&
literal|"This method works properly if subset "
literal|"contains single numbers only."
argument_list|)
expr_stmt|;
return|return
name|FlatCollection
index|[
name|idx
index|]
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// IntegersSubset - currently is extension of IntegersSubsetGeneric
end_comment

begin_comment
comment|/// that also supports conversion to/from Constant* object.
end_comment

begin_decl_stmt
name|class
name|IntegersSubset
range|:
name|public
name|IntegersSubsetGeneric
operator|<
name|IntItem
operator|>
block|{
typedef|typedef
name|IntegersSubsetGeneric
operator|<
name|IntItem
operator|>
name|ParentTy
expr_stmt|;
name|Constant
operator|*
name|Holder
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|getNumItemsFromConstant
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|cast
operator|<
name|ArrayType
operator|>
operator|(
name|C
operator|->
name|getType
argument_list|()
operator|)
operator|->
name|getNumElements
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|Range
name|getItemFromConstant
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|,
name|unsigned
name|idx
parameter_list|)
block|{
specifier|const
name|Constant
modifier|*
name|CV
init|=
name|C
operator|->
name|getAggregateElement
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|unsigned
name|NumEls
init|=
name|cast
operator|<
name|VectorType
operator|>
operator|(
name|CV
operator|->
name|getType
argument_list|()
operator|)
operator|->
name|getNumElements
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|NumEls
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Range
argument_list|(
name|IntItem
operator|::
name|fromConstantInt
argument_list|(
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getAggregateElement
argument_list|(
literal|0U
argument_list|)
operator|)
argument_list|)
argument_list|,
name|IntItem
operator|::
name|fromConstantInt
argument_list|(
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getAggregateElement
argument_list|(
literal|0U
argument_list|)
operator|)
operator|)
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Range
argument_list|(
name|IntItem
operator|::
name|fromConstantInt
argument_list|(
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getAggregateElement
argument_list|(
literal|0U
argument_list|)
operator|)
argument_list|)
argument_list|,
name|IntItem
operator|::
name|fromConstantInt
argument_list|(
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getAggregateElement
argument_list|(
literal|1
argument_list|)
operator|)
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Only pairs and single numbers are allowed here."
argument_list|)
expr_stmt|;
return|return
name|Range
argument_list|()
return|;
block|}
block|}
end_function

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|Range
operator|>
name|rangesFromConstant
argument_list|(
argument|Constant *C
argument_list|)
block|{
name|unsigned
name|NumItems
operator|=
name|getNumItemsFromConstant
argument_list|(
name|C
argument_list|)
block|;
name|std
operator|::
name|vector
operator|<
name|Range
operator|>
name|r
block|;
name|r
operator|.
name|reserve
argument_list|(
name|NumItems
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NumItems
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|r
operator|.
name|push_back
argument_list|(
name|getItemFromConstant
argument_list|(
name|C
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|r
return|;
end_return

begin_macro
unit|}  public:
name|explicit
end_macro

begin_expr_stmt
name|IntegersSubset
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
operator|:
name|ParentTy
argument_list|(
name|rangesFromConstant
argument_list|(
name|C
argument_list|)
argument_list|)
operator|,
name|Holder
argument_list|(
argument|C
argument_list|)
block|{}
name|IntegersSubset
argument_list|(
specifier|const
name|IntegersSubset
operator|&
name|RHS
argument_list|)
operator|:
name|ParentTy
argument_list|(
operator|*
operator|(
specifier|const
name|ParentTy
operator|*
operator|)
operator|&
name|RHS
argument_list|)
operator|,
comment|// FIXME: tweak for msvc.
name|Holder
argument_list|(
argument|RHS.Holder
argument_list|)
block|{}
name|template
operator|<
name|class
name|RangesCollectionTy
operator|>
name|explicit
name|IntegersSubset
argument_list|(
specifier|const
name|RangesCollectionTy
operator|&
name|Src
argument_list|)
operator|:
name|ParentTy
argument_list|(
argument|Src
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|Constant
operator|*
operator|>
name|Elts
block|;
name|Elts
operator|.
name|reserve
argument_list|(
name|Src
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|typename
name|RangesCollectionTy
operator|::
name|const_iterator
name|i
operator|=
name|Src
operator|.
name|begin
argument_list|()
operator|,
name|e
operator|=
name|Src
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Range
modifier|&
name|R
init|=
operator|*
name|i
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|Constant
operator|*
operator|>
name|r
expr_stmt|;
if|if
condition|(
name|R
operator|.
name|isSingleNumber
argument_list|()
condition|)
block|{
name|r
operator|.
name|reserve
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// FIXME: Since currently we have ConstantInt based numbers
comment|// use hack-conversion of IntItem to ConstantInt
name|r
operator|.
name|push_back
argument_list|(
name|R
operator|.
name|getLow
argument_list|()
operator|.
name|toConstantInt
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|push_back
argument_list|(
name|R
operator|.
name|getHigh
argument_list|()
operator|.
name|toConstantInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|r
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|r
operator|.
name|push_back
argument_list|(
name|R
operator|.
name|getLow
argument_list|()
operator|.
name|toConstantInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_decl_stmt
name|Constant
modifier|*
name|CV
init|=
name|ConstantVector
operator|::
name|get
argument_list|(
name|r
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Elts
operator|.
name|push_back
argument_list|(
name|CV
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     ArrayType
operator|*
name|ArrTy
operator|=
name|ArrayType
operator|::
name|get
argument_list|(
name|Elts
operator|.
name|front
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|,
operator|(
name|uint64_t
operator|)
name|Elts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Holder
operator|=
name|ConstantArray
operator|::
name|get
argument_list|(
name|ArrTy
argument_list|,
name|Elts
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    operator
name|Constant
end_macro

begin_expr_stmt
operator|*
operator|(
operator|)
block|{
return|return
name|Holder
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|operator
specifier|const
name|Constant
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Holder
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Constant
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|Holder
return|;
block|}
end_block

begin_expr_stmt
specifier|const
name|Constant
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
name|Holder
return|;
block|}
end_expr_stmt

begin_endif
unit|};  }
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLLVM_SUPPORT_INTEGERSSUBSET_H */
end_comment

end_unit

