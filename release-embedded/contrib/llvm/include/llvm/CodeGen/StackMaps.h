begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------------------- StackMaps.h - StackMaps ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_STACKMAPS
end_ifndef

begin_define
define|#
directive|define
name|LLVM_STACKMAPS
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstr.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AsmPrinter
decl_stmt|;
name|class
name|MCExpr
decl_stmt|;
comment|/// \brief MI-level patchpoint operands.
comment|///
comment|/// MI patchpoint operations take the form:
comment|/// [<def>],<id>,<numBytes>,<target>,<numArgs>,<cc>, ...
comment|///
comment|/// IR patchpoint intrinsics do not have the<cc> operand because calling
comment|/// convention is part of the subclass data.
comment|///
comment|/// SD patchpoint nodes do not have a def operand because it is part of the
comment|/// SDValue.
comment|///
comment|/// Patchpoints following the anyregcc convention are handled specially. For
comment|/// these, the stack map also records the location of the return value and
comment|/// arguments.
name|class
name|PatchPointOpers
block|{
name|public
label|:
comment|/// Enumerate the meta operands.
enum|enum
block|{
name|IDPos
block|,
name|NBytesPos
block|,
name|TargetPos
block|,
name|NArgPos
block|,
name|CCPos
block|,
name|MetaEnd
block|}
enum|;
name|private
label|:
specifier|const
name|MachineInstr
modifier|*
name|MI
decl_stmt|;
name|bool
name|HasDef
decl_stmt|;
name|bool
name|IsAnyReg
decl_stmt|;
name|public
label|:
name|explicit
name|PatchPointOpers
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
name|bool
name|isAnyReg
argument_list|()
specifier|const
block|{
return|return
name|IsAnyReg
return|;
block|}
name|bool
name|hasDef
argument_list|()
specifier|const
block|{
return|return
name|HasDef
return|;
block|}
name|unsigned
name|getMetaIdx
argument_list|(
name|unsigned
name|Pos
operator|=
literal|0
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Pos
operator|<
name|MetaEnd
operator|&&
literal|"Meta operand index out of range."
argument_list|)
expr_stmt|;
return|return
operator|(
name|HasDef
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|Pos
return|;
block|}
specifier|const
name|MachineOperand
modifier|&
name|getMetaOper
parameter_list|(
name|unsigned
name|Pos
parameter_list|)
block|{
return|return
name|MI
operator|->
name|getOperand
argument_list|(
name|getMetaIdx
argument_list|(
name|Pos
argument_list|)
argument_list|)
return|;
block|}
name|unsigned
name|getArgIdx
argument_list|()
specifier|const
block|{
return|return
name|getMetaIdx
argument_list|()
operator|+
name|MetaEnd
return|;
block|}
comment|/// Get the operand index of the variable list of non-argument operands.
comment|/// These hold the "live state".
name|unsigned
name|getVarIdx
argument_list|()
specifier|const
block|{
return|return
name|getMetaIdx
argument_list|()
operator|+
name|MetaEnd
operator|+
name|MI
operator|->
name|getOperand
argument_list|(
name|getMetaIdx
argument_list|(
name|NArgPos
argument_list|)
argument_list|)
operator|.
name|getImm
argument_list|()
return|;
block|}
comment|/// Get the index at which stack map locations will be recorded.
comment|/// Arguments are not recorded unless the anyregcc convention is used.
name|unsigned
name|getStackMapStartIdx
argument_list|()
specifier|const
block|{
if|if
condition|(
name|IsAnyReg
condition|)
return|return
name|getArgIdx
argument_list|()
return|;
return|return
name|getVarIdx
argument_list|()
return|;
block|}
comment|/// \brief Get the next scratch register operand index.
name|unsigned
name|getNextScratchIdx
argument_list|(
name|unsigned
name|StartIdx
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|StackMaps
block|{
name|public
label|:
struct|struct
name|Location
block|{
enum|enum
name|LocationType
block|{
name|Unprocessed
block|,
name|Register
block|,
name|Direct
block|,
name|Indirect
block|,
name|Constant
block|,
name|ConstantIndex
block|}
enum|;
name|LocationType
name|LocType
decl_stmt|;
name|unsigned
name|Size
decl_stmt|;
name|unsigned
name|Reg
decl_stmt|;
name|int64_t
name|Offset
decl_stmt|;
name|Location
argument_list|()
operator|:
name|LocType
argument_list|(
name|Unprocessed
argument_list|)
operator|,
name|Size
argument_list|(
literal|0
argument_list|)
operator|,
name|Reg
argument_list|(
literal|0
argument_list|)
operator|,
name|Offset
argument_list|(
literal|0
argument_list|)
block|{}
name|Location
argument_list|(
argument|LocationType LocType
argument_list|,
argument|unsigned Size
argument_list|,
argument|unsigned Reg
argument_list|,
argument|int64_t Offset
argument_list|)
operator|:
name|LocType
argument_list|(
name|LocType
argument_list|)
operator|,
name|Size
argument_list|(
name|Size
argument_list|)
operator|,
name|Reg
argument_list|(
name|Reg
argument_list|)
operator|,
name|Offset
argument_list|(
argument|Offset
argument_list|)
block|{}
block|}
struct|;
comment|// Typedef a function pointer for functions that parse sequences of operands
comment|// and return a Location, plus a new "next" operand iterator.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|Location
operator|,
name|MachineInstr
operator|::
name|const_mop_iterator
operator|>
call|(
modifier|*
name|OperandParser
call|)
argument_list|(
name|MachineInstr
operator|::
name|const_mop_iterator
argument_list|,
name|MachineInstr
operator|::
name|const_mop_iterator
argument_list|,
specifier|const
name|TargetMachine
operator|&
argument_list|)
expr_stmt|;
comment|// OpTypes are used to encode information about the following logical
comment|// operand (which may consist of several MachineOperands) for the
comment|// OpParser.
typedef|typedef
enum|enum
block|{
name|DirectMemRefOp
block|,
name|IndirectMemRefOp
block|,
name|ConstantOp
block|}
name|OpType
typedef|;
name|StackMaps
argument_list|(
argument|AsmPrinter&AP
argument_list|,
argument|OperandParser OpParser
argument_list|)
block|:
name|AP
argument_list|(
name|AP
argument_list|)
operator|,
name|OpParser
argument_list|(
argument|OpParser
argument_list|)
block|{}
comment|/// \brief Generate a stackmap record for a stackmap instruction.
comment|///
comment|/// MI must be a raw STACKMAP, not a PATCHPOINT.
name|void
name|recordStackMap
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
expr_stmt|;
comment|/// \brief Generate a stackmap record for a patchpoint instruction.
name|void
name|recordPatchPoint
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
name|MI
parameter_list|)
function_decl|;
comment|/// If there is any stack map data, create a stack map section and serialize
comment|/// the map info into it. This clears the stack map data structures
comment|/// afterwards.
name|void
name|serializeToStackMapSection
parameter_list|()
function_decl|;
name|private
label|:
typedef|typedef
name|SmallVector
operator|<
name|Location
operator|,
literal|8
operator|>
name|LocationVec
expr_stmt|;
struct|struct
name|CallsiteInfo
block|{
specifier|const
name|MCExpr
modifier|*
name|CSOffsetExpr
decl_stmt|;
name|unsigned
name|ID
decl_stmt|;
name|LocationVec
name|Locations
decl_stmt|;
name|CallsiteInfo
argument_list|()
operator|:
name|CSOffsetExpr
argument_list|(
literal|0
argument_list|)
operator|,
name|ID
argument_list|(
literal|0
argument_list|)
block|{}
name|CallsiteInfo
argument_list|(
argument|const MCExpr *CSOffsetExpr
argument_list|,
argument|unsigned ID
argument_list|,
argument|LocationVec Locations
argument_list|)
operator|:
name|CSOffsetExpr
argument_list|(
name|CSOffsetExpr
argument_list|)
operator|,
name|ID
argument_list|(
name|ID
argument_list|)
operator|,
name|Locations
argument_list|(
argument|Locations
argument_list|)
block|{}
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|CallsiteInfo
operator|>
name|CallsiteInfoList
expr_stmt|;
struct|struct
name|ConstantPool
block|{
name|private
label|:
typedef|typedef
name|std
operator|::
name|map
operator|<
name|int64_t
operator|,
name|size_t
operator|>
name|ConstantsMap
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int64_t
operator|>
name|ConstantsList
expr_stmt|;
name|ConstantsMap
name|ConstantIndexes
decl_stmt|;
name|public
label|:
name|size_t
name|getNumConstants
argument_list|()
specifier|const
block|{
return|return
name|ConstantsList
operator|.
name|size
argument_list|()
return|;
block|}
name|int64_t
name|getConstant
argument_list|(
name|size_t
name|Idx
argument_list|)
decl|const
block|{
return|return
name|ConstantsList
index|[
name|Idx
index|]
return|;
block|}
name|size_t
name|getConstantIndex
parameter_list|(
name|int64_t
name|ConstVal
parameter_list|)
block|{
name|size_t
name|NextIdx
init|=
name|ConstantsList
operator|.
name|size
argument_list|()
decl_stmt|;
name|ConstantsMap
operator|::
name|const_iterator
name|I
operator|=
name|ConstantIndexes
operator|.
name|insert
argument_list|(
name|ConstantIndexes
operator|.
name|end
argument_list|()
argument_list|,
name|std
operator|::
name|make_pair
argument_list|(
name|ConstVal
argument_list|,
name|NextIdx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|->
name|second
operator|==
name|NextIdx
condition|)
name|ConstantsList
operator|.
name|push_back
argument_list|(
name|ConstVal
argument_list|)
expr_stmt|;
return|return
name|I
operator|->
name|second
return|;
block|}
block|}
struct|;
name|AsmPrinter
modifier|&
name|AP
decl_stmt|;
name|OperandParser
name|OpParser
decl_stmt|;
name|CallsiteInfoList
name|CSInfos
decl_stmt|;
name|ConstantPool
name|ConstPool
decl_stmt|;
comment|/// This should be called by the MC lowering code _immediately_ before
comment|/// lowering the MI to an MCInst. It records where the operands for the
comment|/// instruction are stored, and outputs a label to record the offset of
comment|/// the call from the start of the text section. In special cases (e.g. AnyReg
comment|/// calling convention) the return register is also recorded if requested.
name|void
name|recordStackMapOpers
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|uint32_t
name|ID
argument_list|,
name|MachineInstr
operator|::
name|const_mop_iterator
name|MOI
argument_list|,
name|MachineInstr
operator|::
name|const_mop_iterator
name|MOE
argument_list|,
name|bool
name|recordResult
operator|=
name|false
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_STACKMAPS
end_comment

end_unit

