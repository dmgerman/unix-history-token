begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-------------------- Graph.h - PBQP Graph ------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// PBQP Graph class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_GRAPH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_GRAPH_H
end_define

begin_include
include|#
directive|include
file|"Math.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
comment|/// PBQP Graph class.
comment|/// Instances of this class describe PBQP problems.
name|class
name|Graph
block|{
name|private
label|:
comment|// ----- TYPEDEFS -----
name|class
name|NodeEntry
decl_stmt|;
name|class
name|EdgeEntry
decl_stmt|;
typedef|typedef
name|llvm
operator|::
name|ilist
operator|<
name|NodeEntry
operator|>
name|NodeList
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|ilist
operator|<
name|EdgeEntry
operator|>
name|EdgeList
expr_stmt|;
name|public
label|:
typedef|typedef
name|NodeEntry
modifier|*
name|NodeItr
typedef|;
typedef|typedef
specifier|const
name|NodeEntry
modifier|*
name|ConstNodeItr
typedef|;
typedef|typedef
name|EdgeEntry
modifier|*
name|EdgeItr
typedef|;
typedef|typedef
specifier|const
name|EdgeEntry
modifier|*
name|ConstEdgeItr
typedef|;
name|private
label|:
typedef|typedef
name|std
operator|::
name|list
operator|<
name|EdgeItr
operator|>
name|AdjEdgeList
expr_stmt|;
name|public
label|:
typedef|typedef
name|AdjEdgeList
operator|::
name|iterator
name|AdjEdgeItr
expr_stmt|;
name|private
label|:
name|class
name|NodeEntry
range|:
name|public
name|llvm
operator|::
name|ilist_node
operator|<
name|NodeEntry
operator|>
block|{
name|friend
expr|struct
name|llvm
operator|::
name|ilist_sentinel_traits
operator|<
name|NodeEntry
operator|>
block|;
name|private
operator|:
name|Vector
name|costs
block|;
name|AdjEdgeList
name|adjEdges
block|;
name|unsigned
name|degree
block|;
name|void
operator|*
name|data
block|;
name|NodeEntry
argument_list|()
operator|:
name|costs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{}
name|public
operator|:
name|NodeEntry
argument_list|(
specifier|const
name|Vector
operator|&
name|costs
argument_list|)
operator|:
name|costs
argument_list|(
name|costs
argument_list|)
block|,
name|degree
argument_list|(
literal|0
argument_list|)
block|{}
name|Vector
operator|&
name|getCosts
argument_list|()
block|{
return|return
name|costs
return|;
block|}
specifier|const
name|Vector
operator|&
name|getCosts
argument_list|()
specifier|const
block|{
return|return
name|costs
return|;
block|}
name|unsigned
name|getDegree
argument_list|()
specifier|const
block|{
return|return
name|degree
return|;
block|}
name|AdjEdgeItr
name|edgesBegin
argument_list|()
block|{
return|return
name|adjEdges
operator|.
name|begin
argument_list|()
return|;
block|}
name|AdjEdgeItr
name|edgesEnd
argument_list|()
block|{
return|return
name|adjEdges
operator|.
name|end
argument_list|()
return|;
block|}
name|AdjEdgeItr
name|addEdge
argument_list|(
argument|EdgeItr e
argument_list|)
block|{
operator|++
name|degree
block|;
return|return
name|adjEdges
operator|.
name|insert
argument_list|(
name|adjEdges
operator|.
name|end
argument_list|()
argument_list|,
name|e
argument_list|)
return|;
block|}
name|void
name|removeEdge
argument_list|(
argument|AdjEdgeItr ae
argument_list|)
block|{
operator|--
name|degree
block|;
name|adjEdges
operator|.
name|erase
argument_list|(
name|ae
argument_list|)
block|;       }
name|void
name|setData
argument_list|(
argument|void *data
argument_list|)
block|{
name|this
operator|->
name|data
operator|=
name|data
block|; }
name|void
operator|*
name|getData
argument_list|()
block|{
return|return
name|data
return|;
block|}
expr|}
block|;
name|class
name|EdgeEntry
operator|:
name|public
name|llvm
operator|::
name|ilist_node
operator|<
name|EdgeEntry
operator|>
block|{
name|friend
expr|struct
name|llvm
operator|::
name|ilist_sentinel_traits
operator|<
name|EdgeEntry
operator|>
block|;
name|private
operator|:
name|NodeItr
name|node1
block|,
name|node2
block|;
name|Matrix
name|costs
block|;
name|AdjEdgeItr
name|node1AEItr
block|,
name|node2AEItr
block|;
name|void
operator|*
name|data
block|;
name|EdgeEntry
argument_list|()
operator|:
name|costs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|{}
name|public
operator|:
name|EdgeEntry
argument_list|(
argument|NodeItr node1
argument_list|,
argument|NodeItr node2
argument_list|,
argument|const Matrix&costs
argument_list|)
operator|:
name|node1
argument_list|(
name|node1
argument_list|)
block|,
name|node2
argument_list|(
name|node2
argument_list|)
block|,
name|costs
argument_list|(
argument|costs
argument_list|)
block|{}
name|NodeItr
name|getNode1
argument_list|()
specifier|const
block|{
return|return
name|node1
return|;
block|}
name|NodeItr
name|getNode2
argument_list|()
specifier|const
block|{
return|return
name|node2
return|;
block|}
name|Matrix
operator|&
name|getCosts
argument_list|()
block|{
return|return
name|costs
return|;
block|}
specifier|const
name|Matrix
operator|&
name|getCosts
argument_list|()
specifier|const
block|{
return|return
name|costs
return|;
block|}
name|void
name|setNode1AEItr
argument_list|(
argument|AdjEdgeItr ae
argument_list|)
block|{
name|node1AEItr
operator|=
name|ae
block|; }
name|AdjEdgeItr
name|getNode1AEItr
argument_list|()
block|{
return|return
name|node1AEItr
return|;
block|}
name|void
name|setNode2AEItr
argument_list|(
argument|AdjEdgeItr ae
argument_list|)
block|{
name|node2AEItr
operator|=
name|ae
block|; }
name|AdjEdgeItr
name|getNode2AEItr
argument_list|()
block|{
return|return
name|node2AEItr
return|;
block|}
name|void
name|setData
argument_list|(
argument|void *data
argument_list|)
block|{
name|this
operator|->
name|data
operator|=
name|data
block|; }
name|void
operator|*
name|getData
argument_list|()
block|{
return|return
name|data
return|;
block|}
expr|}
block|;
comment|// ----- MEMBERS -----
name|NodeList
name|nodes
block|;
name|unsigned
name|numNodes
block|;
name|EdgeList
name|edges
block|;
name|unsigned
name|numEdges
block|;
comment|// ----- INTERNAL METHODS -----
name|NodeEntry
operator|&
name|getNode
argument_list|(
argument|NodeItr nItr
argument_list|)
block|{
return|return
operator|*
name|nItr
return|;
block|}
specifier|const
name|NodeEntry
operator|&
name|getNode
argument_list|(
argument|ConstNodeItr nItr
argument_list|)
specifier|const
block|{
return|return
operator|*
name|nItr
return|;
block|}
name|EdgeEntry
operator|&
name|getEdge
argument_list|(
argument|EdgeItr eItr
argument_list|)
block|{
return|return
operator|*
name|eItr
return|;
block|}
specifier|const
name|EdgeEntry
operator|&
name|getEdge
argument_list|(
argument|ConstEdgeItr eItr
argument_list|)
specifier|const
block|{
return|return
operator|*
name|eItr
return|;
block|}
name|NodeItr
name|addConstructedNode
argument_list|(
argument|const NodeEntry&n
argument_list|)
block|{
operator|++
name|numNodes
block|;
return|return
name|nodes
operator|.
name|insert
argument_list|(
name|nodes
operator|.
name|end
argument_list|()
argument_list|,
name|n
argument_list|)
return|;
block|}
name|EdgeItr
name|addConstructedEdge
argument_list|(
argument|const EdgeEntry&e
argument_list|)
block|{
name|assert
argument_list|(
name|findEdge
argument_list|(
name|e
operator|.
name|getNode1
argument_list|()
argument_list|,
name|e
operator|.
name|getNode2
argument_list|()
argument_list|)
operator|==
name|edges
operator|.
name|end
argument_list|()
operator|&&
literal|"Attempt to add duplicate edge."
argument_list|)
block|;
operator|++
name|numEdges
block|;
name|EdgeItr
name|edgeItr
operator|=
name|edges
operator|.
name|insert
argument_list|(
name|edges
operator|.
name|end
argument_list|()
argument_list|,
name|e
argument_list|)
block|;
name|EdgeEntry
operator|&
name|ne
operator|=
name|getEdge
argument_list|(
name|edgeItr
argument_list|)
block|;
name|NodeEntry
operator|&
name|n1
operator|=
name|getNode
argument_list|(
name|ne
operator|.
name|getNode1
argument_list|()
argument_list|)
block|;
name|NodeEntry
operator|&
name|n2
operator|=
name|getNode
argument_list|(
name|ne
operator|.
name|getNode2
argument_list|()
argument_list|)
block|;
comment|// Sanity check on matrix dimensions:
name|assert
argument_list|(
operator|(
name|n1
operator|.
name|getCosts
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
name|ne
operator|.
name|getCosts
argument_list|()
operator|.
name|getRows
argument_list|()
operator|)
operator|&&
operator|(
name|n2
operator|.
name|getCosts
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
name|ne
operator|.
name|getCosts
argument_list|()
operator|.
name|getCols
argument_list|()
operator|)
operator|&&
literal|"Edge cost dimensions do not match node costs dimensions."
argument_list|)
block|;
name|ne
operator|.
name|setNode1AEItr
argument_list|(
name|n1
operator|.
name|addEdge
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
block|;
name|ne
operator|.
name|setNode2AEItr
argument_list|(
name|n2
operator|.
name|addEdge
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
block|;
return|return
name|edgeItr
return|;
block|}
specifier|inline
name|void
name|copyFrom
argument_list|(
specifier|const
name|Graph
operator|&
name|other
argument_list|)
block|;
name|public
operator|:
comment|/// \brief Construct an empty PBQP graph.
name|Graph
argument_list|()
operator|:
name|numNodes
argument_list|(
literal|0
argument_list|)
block|,
name|numEdges
argument_list|(
literal|0
argument_list|)
block|{}
comment|/// \brief Copy construct this graph from "other". Note: Does not copy node
comment|///        and edge data, only graph structure and costs.
comment|/// @param other Source graph to copy from.
name|Graph
argument_list|(
specifier|const
name|Graph
operator|&
name|other
argument_list|)
operator|:
name|numNodes
argument_list|(
literal|0
argument_list|)
block|,
name|numEdges
argument_list|(
literal|0
argument_list|)
block|{
name|copyFrom
argument_list|(
name|other
argument_list|)
block|;     }
comment|/// \brief Make this graph a copy of "other". Note: Does not copy node and
comment|///        edge data, only graph structure and costs.
comment|/// @param other The graph to copy from.
comment|/// @return A reference to this graph.
comment|///
comment|/// This will clear the current graph, erasing any nodes and edges added,
comment|/// before copying from other.
name|Graph
operator|&
name|operator
operator|=
operator|(
specifier|const
name|Graph
operator|&
name|other
operator|)
block|{
name|clear
argument_list|()
block|;
name|copyFrom
argument_list|(
name|other
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Add a node with the given costs.
comment|/// @param costs Cost vector for the new node.
comment|/// @return Node iterator for the added node.
name|NodeItr
name|addNode
argument_list|(
argument|const Vector&costs
argument_list|)
block|{
return|return
name|addConstructedNode
argument_list|(
name|NodeEntry
argument_list|(
name|costs
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Add an edge between the given nodes with the given costs.
comment|/// @param n1Itr First node.
comment|/// @param n2Itr Second node.
comment|/// @return Edge iterator for the added edge.
name|EdgeItr
name|addEdge
argument_list|(
argument|Graph::NodeItr n1Itr
argument_list|,
argument|Graph::NodeItr n2Itr
argument_list|,
argument|const Matrix&costs
argument_list|)
block|{
name|assert
argument_list|(
name|getNodeCosts
argument_list|(
name|n1Itr
argument_list|)
operator|.
name|getLength
argument_list|()
operator|==
name|costs
operator|.
name|getRows
argument_list|()
operator|&&
name|getNodeCosts
argument_list|(
name|n2Itr
argument_list|)
operator|.
name|getLength
argument_list|()
operator|==
name|costs
operator|.
name|getCols
argument_list|()
operator|&&
literal|"Matrix dimensions mismatch."
argument_list|)
block|;
return|return
name|addConstructedEdge
argument_list|(
name|EdgeEntry
argument_list|(
name|n1Itr
argument_list|,
name|n2Itr
argument_list|,
name|costs
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Get the number of nodes in the graph.
comment|/// @return Number of nodes in the graph.
name|unsigned
name|getNumNodes
argument_list|()
specifier|const
block|{
return|return
name|numNodes
return|;
block|}
comment|/// \brief Get the number of edges in the graph.
comment|/// @return Number of edges in the graph.
name|unsigned
name|getNumEdges
argument_list|()
specifier|const
block|{
return|return
name|numEdges
return|;
block|}
comment|/// \brief Get a node's cost vector.
comment|/// @param nItr Node iterator.
comment|/// @return Node cost vector.
name|Vector
operator|&
name|getNodeCosts
argument_list|(
argument|NodeItr nItr
argument_list|)
block|{
return|return
name|getNode
argument_list|(
name|nItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Get a node's cost vector (const version).
comment|/// @param nItr Node iterator.
comment|/// @return Node cost vector.
specifier|const
name|Vector
operator|&
name|getNodeCosts
argument_list|(
argument|ConstNodeItr nItr
argument_list|)
specifier|const
block|{
return|return
name|getNode
argument_list|(
name|nItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Set a node's data pointer.
comment|/// @param nItr Node iterator.
comment|/// @param data Pointer to node data.
comment|///
comment|/// Typically used by a PBQP solver to attach data to aid in solution.
name|void
name|setNodeData
argument_list|(
argument|NodeItr nItr
argument_list|,
argument|void *data
argument_list|)
block|{
name|getNode
argument_list|(
name|nItr
argument_list|)
operator|.
name|setData
argument_list|(
name|data
argument_list|)
block|; }
comment|/// \brief Get the node's data pointer.
comment|/// @param nItr Node iterator.
comment|/// @return Pointer to node data.
name|void
operator|*
name|getNodeData
argument_list|(
argument|NodeItr nItr
argument_list|)
block|{
return|return
name|getNode
argument_list|(
name|nItr
argument_list|)
operator|.
name|getData
argument_list|()
return|;
block|}
comment|/// \brief Get an edge's cost matrix.
comment|/// @param eItr Edge iterator.
comment|/// @return Edge cost matrix.
name|Matrix
operator|&
name|getEdgeCosts
argument_list|(
argument|EdgeItr eItr
argument_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Get an edge's cost matrix (const version).
comment|/// @param eItr Edge iterator.
comment|/// @return Edge cost matrix.
specifier|const
name|Matrix
operator|&
name|getEdgeCosts
argument_list|(
argument|ConstEdgeItr eItr
argument_list|)
specifier|const
block|{
return|return
name|getEdge
argument_list|(
name|eItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Set an edge's data pointer.
comment|/// @param eItr Edge iterator.
comment|/// @param data Pointer to edge data.
comment|///
comment|/// Typically used by a PBQP solver to attach data to aid in solution.
name|void
name|setEdgeData
argument_list|(
argument|EdgeItr eItr
argument_list|,
argument|void *data
argument_list|)
block|{
name|getEdge
argument_list|(
name|eItr
argument_list|)
operator|.
name|setData
argument_list|(
name|data
argument_list|)
block|; }
comment|/// \brief Get an edge's data pointer.
comment|/// @param eItr Edge iterator.
comment|/// @return Pointer to edge data.
name|void
operator|*
name|getEdgeData
argument_list|(
argument|EdgeItr eItr
argument_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eItr
argument_list|)
operator|.
name|getData
argument_list|()
return|;
block|}
comment|/// \brief Get a node's degree.
comment|/// @param nItr Node iterator.
comment|/// @return The degree of the node.
name|unsigned
name|getNodeDegree
argument_list|(
argument|NodeItr nItr
argument_list|)
specifier|const
block|{
return|return
name|getNode
argument_list|(
name|nItr
argument_list|)
operator|.
name|getDegree
argument_list|()
return|;
block|}
comment|/// \brief Begin iterator for node set.
name|NodeItr
name|nodesBegin
argument_list|()
block|{
return|return
name|nodes
operator|.
name|begin
argument_list|()
return|;
block|}
comment|/// \brief Begin const iterator for node set.
name|ConstNodeItr
name|nodesBegin
argument_list|()
specifier|const
block|{
return|return
name|nodes
operator|.
name|begin
argument_list|()
return|;
block|}
comment|/// \brief End iterator for node set.
name|NodeItr
name|nodesEnd
argument_list|()
block|{
return|return
name|nodes
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// \brief End const iterator for node set.
name|ConstNodeItr
name|nodesEnd
argument_list|()
specifier|const
block|{
return|return
name|nodes
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// \brief Begin iterator for edge set.
name|EdgeItr
name|edgesBegin
argument_list|()
block|{
return|return
name|edges
operator|.
name|begin
argument_list|()
return|;
block|}
comment|/// \brief End iterator for edge set.
name|EdgeItr
name|edgesEnd
argument_list|()
block|{
return|return
name|edges
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// \brief Get begin iterator for adjacent edge set.
comment|/// @param nItr Node iterator.
comment|/// @return Begin iterator for the set of edges connected to the given node.
name|AdjEdgeItr
name|adjEdgesBegin
argument_list|(
argument|NodeItr nItr
argument_list|)
block|{
return|return
name|getNode
argument_list|(
name|nItr
argument_list|)
operator|.
name|edgesBegin
argument_list|()
return|;
block|}
comment|/// \brief Get end iterator for adjacent edge set.
comment|/// @param nItr Node iterator.
comment|/// @return End iterator for the set of edges connected to the given node.
name|AdjEdgeItr
name|adjEdgesEnd
argument_list|(
argument|NodeItr nItr
argument_list|)
block|{
return|return
name|getNode
argument_list|(
name|nItr
argument_list|)
operator|.
name|edgesEnd
argument_list|()
return|;
block|}
comment|/// \brief Get the first node connected to this edge.
comment|/// @param eItr Edge iterator.
comment|/// @return The first node connected to the given edge.
name|NodeItr
name|getEdgeNode1
argument_list|(
argument|EdgeItr eItr
argument_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eItr
argument_list|)
operator|.
name|getNode1
argument_list|()
return|;
block|}
comment|/// \brief Get the second node connected to this edge.
comment|/// @param eItr Edge iterator.
comment|/// @return The second node connected to the given edge.
name|NodeItr
name|getEdgeNode2
argument_list|(
argument|EdgeItr eItr
argument_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eItr
argument_list|)
operator|.
name|getNode2
argument_list|()
return|;
block|}
comment|/// \brief Get the "other" node connected to this edge.
comment|/// @param eItr Edge iterator.
comment|/// @param nItr Node iterator for the "given" node.
comment|/// @return The iterator for the "other" node connected to this edge.
name|NodeItr
name|getEdgeOtherNode
argument_list|(
argument|EdgeItr eItr
argument_list|,
argument|NodeItr nItr
argument_list|)
block|{
name|EdgeEntry
operator|&
name|e
operator|=
name|getEdge
argument_list|(
name|eItr
argument_list|)
block|;
if|if
condition|(
name|e
operator|.
name|getNode1
argument_list|()
operator|==
name|nItr
condition|)
block|{
return|return
name|e
operator|.
name|getNode2
argument_list|()
return|;
block|}
comment|// else
return|return
name|e
operator|.
name|getNode1
argument_list|()
return|;
block|}
comment|/// \brief Get the edge connecting two nodes.
comment|/// @param n1Itr First node iterator.
comment|/// @param n2Itr Second node iterator.
comment|/// @return An iterator for edge (n1Itr, n2Itr) if such an edge exists,
comment|///         otherwise returns edgesEnd().
name|EdgeItr
name|findEdge
argument_list|(
argument|NodeItr n1Itr
argument_list|,
argument|NodeItr n2Itr
argument_list|)
block|{
for|for
control|(
name|AdjEdgeItr
name|aeItr
init|=
name|adjEdgesBegin
argument_list|(
name|n1Itr
argument_list|)
init|,
name|aeEnd
init|=
name|adjEdgesEnd
argument_list|(
name|n1Itr
argument_list|)
init|;
name|aeItr
operator|!=
name|aeEnd
condition|;
operator|++
name|aeItr
control|)
block|{
if|if
condition|(
operator|(
name|getEdgeNode1
argument_list|(
operator|*
name|aeItr
argument_list|)
operator|==
name|n2Itr
operator|)
operator|||
operator|(
name|getEdgeNode2
argument_list|(
operator|*
name|aeItr
argument_list|)
operator|==
name|n2Itr
operator|)
condition|)
block|{
return|return
operator|*
name|aeItr
return|;
block|}
block|}
return|return
name|edges
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// \brief Remove a node from the graph.
comment|/// @param nItr Node iterator.
name|void
name|removeNode
argument_list|(
argument|NodeItr nItr
argument_list|)
block|{
name|NodeEntry
operator|&
name|n
operator|=
name|getNode
argument_list|(
name|nItr
argument_list|)
block|;
for|for
control|(
name|AdjEdgeItr
name|itr
init|=
name|n
operator|.
name|edgesBegin
argument_list|()
init|,
name|end
init|=
name|n
operator|.
name|edgesEnd
argument_list|()
init|;
name|itr
operator|!=
name|end
condition|;
control|)
block|{
name|EdgeItr
name|eItr
init|=
operator|*
name|itr
decl_stmt|;
operator|++
name|itr
expr_stmt|;
name|removeEdge
argument_list|(
name|eItr
argument_list|)
expr_stmt|;
block|}
name|nodes
operator|.
name|erase
argument_list|(
name|nItr
argument_list|)
expr_stmt|;
operator|--
name|numNodes
block|;     }
comment|/// \brief Remove an edge from the graph.
comment|/// @param eItr Edge iterator.
name|void
name|removeEdge
argument_list|(
argument|EdgeItr eItr
argument_list|)
block|{
name|EdgeEntry
operator|&
name|e
operator|=
name|getEdge
argument_list|(
name|eItr
argument_list|)
block|;
name|NodeEntry
operator|&
name|n1
operator|=
name|getNode
argument_list|(
name|e
operator|.
name|getNode1
argument_list|()
argument_list|)
block|;
name|NodeEntry
operator|&
name|n2
operator|=
name|getNode
argument_list|(
name|e
operator|.
name|getNode2
argument_list|()
argument_list|)
block|;
name|n1
operator|.
name|removeEdge
argument_list|(
name|e
operator|.
name|getNode1AEItr
argument_list|()
argument_list|)
block|;
name|n2
operator|.
name|removeEdge
argument_list|(
name|e
operator|.
name|getNode2AEItr
argument_list|()
argument_list|)
block|;
name|edges
operator|.
name|erase
argument_list|(
name|eItr
argument_list|)
block|;
operator|--
name|numEdges
block|;     }
comment|/// \brief Remove all nodes and edges from the graph.
name|void
name|clear
argument_list|()
block|{
name|nodes
operator|.
name|clear
argument_list|()
block|;
name|edges
operator|.
name|clear
argument_list|()
block|;
name|numNodes
operator|=
name|numEdges
operator|=
literal|0
block|;     }
comment|/// \brief Dump a graph to an output stream.
name|template
operator|<
name|typename
name|OStream
operator|>
name|void
name|dump
argument_list|(
argument|OStream&os
argument_list|)
block|{
name|os
operator|<<
name|getNumNodes
argument_list|()
operator|<<
literal|" "
operator|<<
name|getNumEdges
argument_list|()
operator|<<
literal|"\n"
block|;
for|for
control|(
name|NodeItr
name|nodeItr
init|=
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
specifier|const
name|Vector
modifier|&
name|v
init|=
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
name|os
operator|<<
literal|"\n"
operator|<<
name|v
operator|.
name|getLength
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
name|assert
argument_list|(
name|v
operator|.
name|getLength
argument_list|()
operator|!=
literal|0
operator|&&
literal|"Empty vector in graph."
argument_list|)
expr_stmt|;
name|os
operator|<<
name|v
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|v
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|os
operator|<<
literal|" "
operator|<<
name|v
index|[
name|i
index|]
expr_stmt|;
block|}
name|os
operator|<<
literal|"\n"
expr_stmt|;
block|}
for|for
control|(
name|EdgeItr
name|edgeItr
init|=
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|unsigned
name|n1
init|=
name|std
operator|::
name|distance
argument_list|(
name|nodesBegin
argument_list|()
argument_list|,
name|getEdgeNode1
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|n2
init|=
name|std
operator|::
name|distance
argument_list|(
name|nodesBegin
argument_list|()
argument_list|,
name|getEdgeNode2
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n1
operator|!=
name|n2
operator|&&
literal|"PBQP graphs shound not have self-edges."
argument_list|)
expr_stmt|;
specifier|const
name|Matrix
modifier|&
name|m
init|=
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|os
operator|<<
literal|"\n"
operator|<<
name|n1
operator|<<
literal|" "
operator|<<
name|n2
operator|<<
literal|"\n"
operator|<<
name|m
operator|.
name|getRows
argument_list|()
operator|<<
literal|" "
operator|<<
name|m
operator|.
name|getCols
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
name|assert
argument_list|(
name|m
operator|.
name|getRows
argument_list|()
operator|!=
literal|0
operator|&&
literal|"No rows in matrix."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|m
operator|.
name|getCols
argument_list|()
operator|!=
literal|0
operator|&&
literal|"No cols in matrix."
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|os
operator|<<
name|m
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|j
operator|<
name|m
operator|.
name|getCols
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|os
operator|<<
literal|" "
operator|<<
name|m
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|os
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
block|}
comment|/// \brief Print a representation of this graph in DOT format.
comment|/// @param os Output stream to print on.
name|template
operator|<
name|typename
name|OStream
operator|>
name|void
name|printDot
argument_list|(
argument|OStream&os
argument_list|)
block|{
name|os
operator|<<
literal|"graph {\n"
block|;
for|for
control|(
name|NodeItr
name|nodeItr
init|=
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|os
operator|<<
literal|"  node"
operator|<<
name|nodeItr
operator|<<
literal|" [ label=\""
operator|<<
name|nodeItr
operator|<<
literal|": "
operator|<<
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
operator|<<
literal|"\" ]\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"  edge [ len="
operator|<<
name|getNumNodes
argument_list|()
operator|<<
literal|" ]\n"
expr_stmt|;
for|for
control|(
name|EdgeItr
name|edgeItr
init|=
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|os
operator|<<
literal|"  node"
operator|<<
name|getEdgeNode1
argument_list|(
name|edgeItr
argument_list|)
operator|<<
literal|" -- node"
operator|<<
name|getEdgeNode2
argument_list|(
name|edgeItr
argument_list|)
operator|<<
literal|" [ label=\""
expr_stmt|;
specifier|const
name|Matrix
modifier|&
name|edgeCosts
init|=
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edgeCosts
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|os
operator|<<
name|edgeCosts
operator|.
name|getRowAsVector
argument_list|(
name|i
argument_list|)
operator|<<
literal|"\\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"\" ]\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"}\n"
expr_stmt|;
block|}
block|}
empty_stmt|;
name|class
name|NodeItrComparator
block|{
name|public
label|:
name|bool
name|operator
argument_list|()
operator|(
name|Graph
operator|::
name|NodeItr
name|n1
operator|,
name|Graph
operator|::
name|NodeItr
name|n2
operator|)
specifier|const
block|{
return|return
operator|&
operator|*
name|n1
operator|<
operator|&
operator|*
name|n2
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
name|Graph
operator|::
name|ConstNodeItr
name|n1
operator|,
name|Graph
operator|::
name|ConstNodeItr
name|n2
operator|)
specifier|const
block|{
return|return
operator|&
operator|*
name|n1
operator|<
operator|&
operator|*
name|n2
return|;
block|}
block|}
empty_stmt|;
name|class
name|EdgeItrCompartor
block|{
name|public
label|:
name|bool
name|operator
argument_list|()
operator|(
name|Graph
operator|::
name|EdgeItr
name|e1
operator|,
name|Graph
operator|::
name|EdgeItr
name|e2
operator|)
specifier|const
block|{
return|return
operator|&
operator|*
name|e1
operator|<
operator|&
operator|*
name|e2
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
name|Graph
operator|::
name|ConstEdgeItr
name|e1
operator|,
name|Graph
operator|::
name|ConstEdgeItr
name|e2
operator|)
specifier|const
block|{
return|return
operator|&
operator|*
name|e1
operator|<
operator|&
operator|*
name|e2
return|;
block|}
block|}
empty_stmt|;
name|void
name|Graph
operator|::
name|copyFrom
argument_list|(
argument|const Graph&other
argument_list|)
block|{
name|std
operator|::
name|map
operator|<
name|Graph
operator|::
name|ConstNodeItr
block|,
name|Graph
operator|::
name|NodeItr
block|,
name|NodeItrComparator
operator|>
name|nodeMap
block|;
for|for
control|(
name|Graph
operator|::
name|ConstNodeItr
name|nItr
operator|=
name|other
operator|.
name|nodesBegin
argument_list|()
operator|,
name|nEnd
operator|=
name|other
operator|.
name|nodesEnd
argument_list|()
init|;
name|nItr
operator|!=
name|nEnd
condition|;
operator|++
name|nItr
control|)
block|{
name|nodeMap
index|[
name|nItr
index|]
operator|=
name|addNode
argument_list|(
name|other
operator|.
name|getNodeCosts
argument_list|(
name|nItr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_GRAPH_HPP
end_comment

end_unit

