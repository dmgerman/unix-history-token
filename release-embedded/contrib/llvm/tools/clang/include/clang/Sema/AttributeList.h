begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- AttributeList.h - Parsed attribute sets ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the AttributeList class, which is used to collect
end_comment

begin_comment
comment|// parsed attributes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_ATTRLIST_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_ATTRLIST_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/VersionTuple.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|Expr
decl_stmt|;
comment|/// \brief Represents information about a change in availability for
comment|/// an entity, which is part of the encoding of the 'availability'
comment|/// attribute.
struct|struct
name|AvailabilityChange
block|{
comment|/// \brief The location of the keyword indicating the kind of change.
name|SourceLocation
name|KeywordLoc
decl_stmt|;
comment|/// \brief The version number at which the change occurred.
name|VersionTuple
name|Version
decl_stmt|;
comment|/// \brief The source range covering the version number.
name|SourceRange
name|VersionRange
decl_stmt|;
comment|/// \brief Determine whether this availability change is valid.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Version
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
struct|;
comment|/// AttributeList - Represents a syntactic attribute.
comment|///
comment|/// For a GNU attribute, there are four forms of this construct:
comment|///
comment|/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.
comment|/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.
comment|/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.
comment|/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.
comment|///
name|class
name|AttributeList
block|{
comment|// TODO: This should really be called ParsedAttribute
name|public
label|:
comment|/// The style used to specify an attribute.
enum|enum
name|Syntax
block|{
comment|/// __attribute__((...))
name|AS_GNU
block|,
comment|/// [[...]]
name|AS_CXX11
block|,
comment|/// __declspec(...)
name|AS_Declspec
block|,
comment|/// __ptr16, alignas(...), etc.
name|AS_Keyword
block|}
enum|;
name|private
label|:
name|IdentifierInfo
modifier|*
name|AttrName
decl_stmt|;
name|IdentifierInfo
modifier|*
name|ScopeName
decl_stmt|;
name|IdentifierInfo
modifier|*
name|ParmName
decl_stmt|;
name|SourceRange
name|AttrRange
decl_stmt|;
name|SourceLocation
name|ScopeLoc
decl_stmt|;
name|SourceLocation
name|ParmLoc
decl_stmt|;
name|SourceLocation
name|EllipsisLoc
decl_stmt|;
comment|/// The number of expression arguments this attribute has.
comment|/// The expressions themselves are stored after the object.
name|unsigned
name|NumArgs
range|:
literal|16
decl_stmt|;
comment|/// Corresponds to the Syntax enum.
name|unsigned
name|SyntaxUsed
range|:
literal|2
decl_stmt|;
comment|/// True if already diagnosed as invalid.
name|mutable
name|unsigned
name|Invalid
range|:
literal|1
decl_stmt|;
comment|/// True if this attribute was used as a type attribute.
name|mutable
name|unsigned
name|UsedAsTypeAttr
range|:
literal|1
decl_stmt|;
comment|/// True if this has the extra information associated with an
comment|/// availability attribute.
name|unsigned
name|IsAvailability
range|:
literal|1
decl_stmt|;
comment|/// True if this has extra information associated with a
comment|/// type_tag_for_datatype attribute.
name|unsigned
name|IsTypeTagForDatatype
range|:
literal|1
decl_stmt|;
comment|/// True if this has extra information associated with a
comment|/// Microsoft __delcspec(property) attribute.
name|unsigned
name|IsProperty
range|:
literal|1
decl_stmt|;
name|unsigned
name|AttrKind
range|:
literal|8
decl_stmt|;
comment|/// \brief The location of the 'unavailable' keyword in an
comment|/// availability attribute.
name|SourceLocation
name|UnavailableLoc
decl_stmt|;
specifier|const
name|Expr
modifier|*
name|MessageExpr
decl_stmt|;
comment|/// The next attribute in the current position.
name|AttributeList
modifier|*
name|NextInPosition
decl_stmt|;
comment|/// The next attribute allocated in the current Pool.
name|AttributeList
modifier|*
name|NextInPool
decl_stmt|;
name|Expr
modifier|*
modifier|*
name|getArgsBuffer
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|Expr
operator|*
specifier|const
operator|*
name|getArgsBuffer
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
specifier|const
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
enum|enum
name|AvailabilitySlot
block|{
name|IntroducedSlot
block|,
name|DeprecatedSlot
block|,
name|ObsoletedSlot
block|}
enum|;
name|AvailabilityChange
modifier|&
name|getAvailabilitySlot
parameter_list|(
name|AvailabilitySlot
name|index
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|AvailabilityChange
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
index|[
name|index
index|]
return|;
block|}
specifier|const
name|AvailabilityChange
modifier|&
name|getAvailabilitySlot
argument_list|(
name|AvailabilitySlot
name|index
argument_list|)
decl|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|AvailabilityChange
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
index|[
name|index
index|]
return|;
block|}
name|public
label|:
struct|struct
name|TypeTagForDatatypeData
block|{
name|ParsedType
modifier|*
name|MatchingCType
decl_stmt|;
name|unsigned
name|LayoutCompatible
range|:
literal|1
decl_stmt|;
name|unsigned
name|MustBeNull
range|:
literal|1
decl_stmt|;
block|}
struct|;
struct|struct
name|PropertyData
block|{
name|IdentifierInfo
modifier|*
name|GetterId
decl_stmt|,
modifier|*
name|SetterId
decl_stmt|;
name|PropertyData
argument_list|(
name|IdentifierInfo
operator|*
name|getterId
argument_list|,
name|IdentifierInfo
operator|*
name|setterId
argument_list|)
operator|:
name|GetterId
argument_list|(
name|getterId
argument_list|)
operator|,
name|SetterId
argument_list|(
argument|setterId
argument_list|)
block|{}
block|}
struct|;
name|private
label|:
name|TypeTagForDatatypeData
modifier|&
name|getTypeTagForDatatypeDataSlot
parameter_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|TypeTagForDatatypeData
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
specifier|const
name|TypeTagForDatatypeData
operator|&
name|getTypeTagForDatatypeDataSlot
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|TypeTagForDatatypeData
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|ParsedType
modifier|&
name|getTypeBuffer
parameter_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|ParsedType
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
specifier|const
name|ParsedType
operator|&
name|getTypeBuffer
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|ParsedType
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|PropertyData
modifier|&
name|getPropertyDataBuffer
parameter_list|()
block|{
name|assert
argument_list|(
name|IsProperty
argument_list|)
expr_stmt|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|PropertyData
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
specifier|const
name|PropertyData
operator|&
name|getPropertyDataBuffer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|IsProperty
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|PropertyData
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|AttributeList
argument_list|(
argument|const AttributeList&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|AttributeList
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
argument_list|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
operator|~
name|AttributeList
argument_list|()
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|size_t
name|allocated_size
argument_list|()
specifier|const
decl_stmt|;
comment|/// Constructor for attributes with expression arguments.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *parmName
argument_list|,
argument|SourceLocation parmLoc
argument_list|,
argument|Expr **args
argument_list|,
argument|unsigned numArgs
argument_list|,
argument|Syntax syntaxUsed
argument_list|,
argument|SourceLocation ellipsisLoc
argument_list|)
block|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|ParmName
argument_list|(
name|parmName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|ParmLoc
argument_list|(
name|parmLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|(
name|ellipsisLoc
argument_list|)
operator|,
name|NumArgs
argument_list|(
name|numArgs
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
literal|0
argument_list|)
operator|,
name|NextInPool
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|numArgs
condition|)
name|memcpy
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
name|args
argument_list|,
name|numArgs
operator|*
sizeof|sizeof
argument_list|(
name|Expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
expr_stmt|;
block|}
comment|/// Constructor for availability attributes.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *parmName
argument_list|,
argument|SourceLocation parmLoc
argument_list|,
argument|const AvailabilityChange&introduced
argument_list|,
argument|const AvailabilityChange&deprecated
argument_list|,
argument|const AvailabilityChange&obsoleted
argument_list|,
argument|SourceLocation unavailable
argument_list|,
argument|const Expr *messageExpr
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
block|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|ParmName
argument_list|(
name|parmName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|ParmLoc
argument_list|(
name|parmLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|0
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|true
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|UnavailableLoc
argument_list|(
name|unavailable
argument_list|)
operator|,
name|MessageExpr
argument_list|(
name|messageExpr
argument_list|)
operator|,
name|NextInPosition
argument_list|(
literal|0
argument_list|)
operator|,
name|NextInPool
argument_list|(
literal|0
argument_list|)
block|{
name|new
argument_list|(
argument|&getAvailabilitySlot(IntroducedSlot)
argument_list|)
name|AvailabilityChange
argument_list|(
name|introduced
argument_list|)
block|;
name|new
argument_list|(
argument|&getAvailabilitySlot(DeprecatedSlot)
argument_list|)
name|AvailabilityChange
argument_list|(
name|deprecated
argument_list|)
block|;
name|new
argument_list|(
argument|&getAvailabilitySlot(ObsoletedSlot)
argument_list|)
name|AvailabilityChange
argument_list|(
name|obsoleted
argument_list|)
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
comment|/// Constructor for type_tag_for_datatype attribute.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *argumentKindName
argument_list|,
argument|SourceLocation argumentKindLoc
argument_list|,
argument|ParsedType matchingCType
argument_list|,
argument|bool layoutCompatible
argument_list|,
argument|bool mustBeNull
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
operator|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|ParmName
argument_list|(
name|argumentKindName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|ParmLoc
argument_list|(
name|argumentKindLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|0
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|true
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
name|NULL
argument_list|)
operator|,
name|NextInPool
argument_list|(
argument|NULL
argument_list|)
block|{
name|TypeTagForDatatypeData
operator|&
name|ExtraData
operator|=
name|getTypeTagForDatatypeDataSlot
argument_list|()
block|;
name|new
argument_list|(
argument|&ExtraData.MatchingCType
argument_list|)
name|ParsedType
argument_list|(
name|matchingCType
argument_list|)
block|;
name|ExtraData
operator|.
name|LayoutCompatible
operator|=
name|layoutCompatible
block|;
name|ExtraData
operator|.
name|MustBeNull
operator|=
name|mustBeNull
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
comment|/// Constructor for attributes with a single type argument.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *parmName
argument_list|,
argument|SourceLocation parmLoc
argument_list|,
argument|ParsedType typeArg
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
operator|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|ParmName
argument_list|(
name|parmName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|ParmLoc
argument_list|(
name|parmLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|1
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
literal|0
argument_list|)
operator|,
name|NextInPool
argument_list|(
literal|0
argument_list|)
block|{
name|new
argument_list|(
argument|&getTypeBuffer()
argument_list|)
name|ParsedType
argument_list|(
name|typeArg
argument_list|)
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
comment|/// Constructor for microsoft __declspec(property) attribute.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *parmName
argument_list|,
argument|SourceLocation parmLoc
argument_list|,
argument|IdentifierInfo *getterId
argument_list|,
argument|IdentifierInfo *setterId
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
operator|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|ParmName
argument_list|(
name|parmName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|ParmLoc
argument_list|(
name|parmLoc
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|true
argument_list|)
operator|,
name|NextInPosition
argument_list|(
literal|0
argument_list|)
operator|,
name|NextInPool
argument_list|(
literal|0
argument_list|)
block|{
name|new
argument_list|(
argument|&getPropertyDataBuffer()
argument_list|)
name|PropertyData
argument_list|(
name|getterId
argument_list|,
name|setterId
argument_list|)
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
name|friend
name|class
name|AttributePool
expr_stmt|;
name|friend
name|class
name|AttributeFactory
decl_stmt|;
name|public
label|:
enum|enum
name|Kind
block|{
define|#
directive|define
name|PARSED_ATTR
parameter_list|(
name|NAME
parameter_list|)
value|AT_##NAME,
include|#
directive|include
file|"clang/Sema/AttrParsedAttrList.inc"
undef|#
directive|undef
name|PARSED_ATTR
name|IgnoredAttribute
block|,
name|UnknownAttribute
block|}
enum|;
name|IdentifierInfo
operator|*
name|getName
argument_list|()
specifier|const
block|{
return|return
name|AttrName
return|;
block|}
name|SourceLocation
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|AttrRange
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceRange
name|getRange
argument_list|()
specifier|const
block|{
return|return
name|AttrRange
return|;
block|}
name|bool
name|hasScope
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|IdentifierInfo
operator|*
name|getScopeName
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|SourceLocation
name|getScopeLoc
argument_list|()
specifier|const
block|{
return|return
name|ScopeLoc
return|;
block|}
name|IdentifierInfo
operator|*
name|getParameterName
argument_list|()
specifier|const
block|{
return|return
name|ParmName
return|;
block|}
name|SourceLocation
name|getParameterLoc
argument_list|()
specifier|const
block|{
return|return
name|ParmLoc
return|;
block|}
comment|/// Is this the Microsoft __declspec(property) attribute?
name|bool
name|isDeclspecPropertyAttribute
argument_list|()
specifier|const
block|{
return|return
name|IsProperty
return|;
block|}
name|bool
name|isAlignasAttribute
argument_list|()
specifier|const
block|{
comment|// FIXME: Use a better mechanism to determine this.
return|return
name|getKind
argument_list|()
operator|==
name|AT_Aligned
operator|&&
name|SyntaxUsed
operator|==
name|AS_Keyword
return|;
block|}
name|bool
name|isDeclspecAttribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_Declspec
return|;
block|}
name|bool
name|isCXX11Attribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_CXX11
operator|||
name|isAlignasAttribute
argument_list|()
return|;
block|}
name|bool
name|isKeywordAttribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_Keyword
return|;
block|}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|Invalid
return|;
block|}
name|void
name|setInvalid
argument_list|(
name|bool
name|b
operator|=
name|true
argument_list|)
decl|const
block|{
name|Invalid
operator|=
name|b
expr_stmt|;
block|}
name|bool
name|isUsedAsTypeAttr
argument_list|()
specifier|const
block|{
return|return
name|UsedAsTypeAttr
return|;
block|}
name|void
name|setUsedAsTypeAttr
parameter_list|()
block|{
name|UsedAsTypeAttr
operator|=
name|true
expr_stmt|;
block|}
name|bool
name|isPackExpansion
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
operator|.
name|isValid
argument_list|()
return|;
block|}
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
return|;
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
argument_list|(
name|AttrKind
argument_list|)
return|;
block|}
specifier|static
name|Kind
name|getKind
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
specifier|const
name|IdentifierInfo
modifier|*
name|Scope
parameter_list|,
name|Syntax
name|SyntaxUsed
parameter_list|)
function_decl|;
name|AttributeList
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|NextInPosition
return|;
block|}
name|void
name|setNext
parameter_list|(
name|AttributeList
modifier|*
name|N
parameter_list|)
block|{
name|NextInPosition
operator|=
name|N
expr_stmt|;
block|}
comment|/// getNumArgs - Return the number of actual arguments to this attribute.
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
comment|/// hasParameterOrArguments - Return true if this attribute has a parameter,
comment|/// or has a non empty argument expression list.
name|bool
name|hasParameterOrArguments
argument_list|()
specifier|const
block|{
return|return
name|ParmName
operator|||
name|NumArgs
return|;
block|}
comment|/// getArg - Return the specified argument.
name|Expr
modifier|*
name|getArg
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Arg
operator|<
name|NumArgs
operator|&&
literal|"Arg access out of range!"
argument_list|)
expr_stmt|;
return|return
name|getArgsBuffer
argument_list|()
index|[
name|Arg
index|]
return|;
block|}
name|class
name|arg_iterator
block|{
name|Expr
modifier|*
specifier|const
modifier|*
name|X
decl_stmt|;
name|unsigned
name|Idx
decl_stmt|;
name|public
label|:
name|arg_iterator
argument_list|(
argument|Expr * const *x
argument_list|,
argument|unsigned idx
argument_list|)
block|:
name|X
argument_list|(
name|x
argument_list|)
operator|,
name|Idx
argument_list|(
argument|idx
argument_list|)
block|{}
name|arg_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Idx
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|arg_iterator
operator|&
name|I
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|X
operator|==
name|I
operator|.
name|X
operator|&&
literal|"compared arg_iterators are for different argument lists"
argument_list|)
block|;
return|return
name|Idx
operator|==
name|I
operator|.
name|Idx
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|arg_iterator
operator|&
name|I
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|I
operator|)
return|;
block|}
name|Expr
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|X
index|[
name|Idx
index|]
return|;
block|}
name|unsigned
name|getArgNum
argument_list|()
specifier|const
block|{
return|return
name|Idx
operator|+
literal|1
return|;
block|}
block|}
empty_stmt|;
name|arg_iterator
name|arg_begin
argument_list|()
specifier|const
block|{
return|return
name|arg_iterator
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|arg_iterator
name|arg_end
argument_list|()
specifier|const
block|{
return|return
name|arg_iterator
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
name|NumArgs
argument_list|)
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityIntroduced
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilitySlot
argument_list|(
name|IntroducedSlot
argument_list|)
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityDeprecated
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilitySlot
argument_list|(
name|DeprecatedSlot
argument_list|)
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityObsoleted
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilitySlot
argument_list|(
name|ObsoletedSlot
argument_list|)
return|;
block|}
name|SourceLocation
name|getUnavailableLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|UnavailableLoc
return|;
block|}
specifier|const
name|Expr
operator|*
name|getMessageExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|MessageExpr
return|;
block|}
specifier|const
name|ParsedType
operator|&
name|getMatchingCType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_TypeTagForDatatype
operator|&&
literal|"Not a type_tag_for_datatype attribute"
argument_list|)
block|;
return|return
operator|*
name|getTypeTagForDatatypeDataSlot
argument_list|()
operator|.
name|MatchingCType
return|;
block|}
name|bool
name|getLayoutCompatible
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_TypeTagForDatatype
operator|&&
literal|"Not a type_tag_for_datatype attribute"
argument_list|)
block|;
return|return
name|getTypeTagForDatatypeDataSlot
argument_list|()
operator|.
name|LayoutCompatible
return|;
block|}
name|bool
name|getMustBeNull
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_TypeTagForDatatype
operator|&&
literal|"Not a type_tag_for_datatype attribute"
argument_list|)
block|;
return|return
name|getTypeTagForDatatypeDataSlot
argument_list|()
operator|.
name|MustBeNull
return|;
block|}
specifier|const
name|ParsedType
operator|&
name|getTypeArg
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_VecTypeHint
operator|&&
literal|"Not a type attribute"
argument_list|)
block|;
return|return
name|getTypeBuffer
argument_list|()
return|;
block|}
specifier|const
name|PropertyData
operator|&
name|getPropertyData
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDeclspecPropertyAttribute
argument_list|()
operator|&&
literal|"Not a __delcspec(property) attribute"
argument_list|)
block|;
return|return
name|getPropertyDataBuffer
argument_list|()
return|;
block|}
comment|/// \brief Get an index into the attribute spelling list
comment|/// defined in Attr.td. This index is used by an attribute
comment|/// to pretty print itself.
name|unsigned
name|getAttributeSpellingListIndex
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// A factory, from which one makes pools, from which one creates
end_comment

begin_comment
comment|/// individual attributes which are deallocated with the pool.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that it's tolerably cheap to create and destroy one of
end_comment

begin_comment
comment|/// these as long as you don't actually allocate anything in it.
end_comment

begin_decl_stmt
name|class
name|AttributeFactory
block|{
name|public
label|:
enum|enum
block|{
comment|/// The required allocation size of an availability attribute,
comment|/// which we want to ensure is a multiple of sizeof(void*).
name|AvailabilityAllocSize
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|AvailabilityChange
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
block|,
name|TypeTagForDatatypeAllocSize
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|AttributeList
operator|::
name|TypeTagForDatatypeData
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
block|,
name|PropertyAllocSize
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|AttributeList
operator|::
name|PropertyData
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
name|private
label|:
enum|enum
block|{
comment|/// The number of free lists we want to be sure to support
comment|/// inline.  This is just enough that availability attributes
comment|/// don't surpass it.  It's actually very unlikely we'll see an
comment|/// attribute that needs more than that; on x86-64 you'd need 10
comment|/// expression arguments, and on i386 you'd need 19.
name|InlineFreeListsCapacity
init|=
literal|1
operator|+
operator|(
name|AvailabilityAllocSize
operator|-
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|)
operator|/
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
name|llvm
operator|::
name|BumpPtrAllocator
name|Alloc
expr_stmt|;
comment|/// Free lists.  The index is determined by the following formula:
comment|///   (size - sizeof(AttributeList)) / sizeof(void*)
name|SmallVector
operator|<
name|AttributeList
operator|*
operator|,
name|InlineFreeListsCapacity
operator|>
name|FreeLists
expr_stmt|;
comment|// The following are the private interface used by AttributePool.
name|friend
name|class
name|AttributePool
decl_stmt|;
comment|/// Allocate an attribute of the given size.
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/// Reclaim all the attributes in the given pool chain, which is
comment|/// non-empty.  Note that the current implementation is safe
comment|/// against reclaiming things which were not actually allocated
comment|/// with the allocator, although of course it's important to make
comment|/// sure that their allocator lives at least as long as this one.
name|void
name|reclaimPool
parameter_list|(
name|AttributeList
modifier|*
name|head
parameter_list|)
function_decl|;
name|public
label|:
name|AttributeFactory
argument_list|()
expr_stmt|;
operator|~
name|AttributeFactory
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|AttributePool
block|{
name|AttributeFactory
modifier|&
name|Factory
decl_stmt|;
name|AttributeList
modifier|*
name|Head
decl_stmt|;
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|Factory
operator|.
name|allocate
argument_list|(
name|size
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|add
parameter_list|(
name|AttributeList
modifier|*
name|attr
parameter_list|)
block|{
comment|// We don't care about the order of the pool.
name|attr
operator|->
name|NextInPool
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
name|attr
expr_stmt|;
return|return
name|attr
return|;
block|}
name|void
name|takePool
parameter_list|(
name|AttributeList
modifier|*
name|pool
parameter_list|)
function_decl|;
name|public
label|:
comment|/// Create a new pool for a factory.
name|AttributePool
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|Factory
argument_list|(
name|factory
argument_list|)
operator|,
name|Head
argument_list|(
literal|0
argument_list|)
block|{}
comment|/// Move the given pool's allocations to this pool.
name|AttributePool
argument_list|(
name|AttributePool
operator|&
name|pool
argument_list|)
operator|:
name|Factory
argument_list|(
name|pool
operator|.
name|Factory
argument_list|)
operator|,
name|Head
argument_list|(
argument|pool.Head
argument_list|)
block|{
name|pool
operator|.
name|Head
operator|=
literal|0
block|;   }
name|AttributeFactory
operator|&
name|getFactory
argument_list|()
specifier|const
block|{
return|return
name|Factory
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|Head
condition|)
block|{
name|Factory
operator|.
name|reclaimPool
argument_list|(
name|Head
argument_list|)
expr_stmt|;
name|Head
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/// Take the given pool's allocations and add them to this pool.
name|void
name|takeAllFrom
parameter_list|(
name|AttributePool
modifier|&
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|.
name|Head
condition|)
block|{
name|takePool
argument_list|(
name|pool
operator|.
name|Head
argument_list|)
expr_stmt|;
name|pool
operator|.
name|Head
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|~
name|AttributePool
argument_list|()
block|{
if|if
condition|(
name|Head
condition|)
name|Factory
operator|.
name|reclaimPool
argument_list|(
name|Head
argument_list|)
expr_stmt|;
block|}
name|AttributeList
modifier|*
name|create
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
name|Expr
operator|*
operator|*
name|args
argument_list|,
name|unsigned
name|numArgs
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|,
name|SourceLocation
name|ellipsisLoc
operator|=
name|SourceLocation
argument_list|()
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
name|numArgs
operator|*
sizeof|sizeof
argument_list|(
name|Expr
operator|*
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|args
argument_list|,
name|numArgs
argument_list|,
name|syntax
argument_list|,
name|ellipsisLoc
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|create
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|introduced
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|deprecated
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|obsoleted
argument_list|,
name|SourceLocation
name|unavailable
argument_list|,
specifier|const
name|Expr
operator|*
name|MessageExpr
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|AttributeFactory
operator|::
name|AvailabilityAllocSize
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|introduced
argument_list|,
name|deprecated
argument_list|,
name|obsoleted
argument_list|,
name|unavailable
argument_list|,
name|MessageExpr
argument_list|,
name|syntax
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|createIntegerAttribute
parameter_list|(
name|ASTContext
modifier|&
name|C
parameter_list|,
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
name|SourceLocation
name|TokLoc
parameter_list|,
name|int
name|Arg
parameter_list|)
function_decl|;
name|AttributeList
modifier|*
name|createTypeTagForDatatype
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|argumentKindName
argument_list|,
name|SourceLocation
name|argumentKindLoc
argument_list|,
name|ParsedType
name|matchingCType
argument_list|,
name|bool
name|layoutCompatible
argument_list|,
name|bool
name|mustBeNull
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|AttributeFactory
operator|::
name|TypeTagForDatatypeAllocSize
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|argumentKindName
argument_list|,
name|argumentKindLoc
argument_list|,
name|matchingCType
argument_list|,
name|layoutCompatible
argument_list|,
name|mustBeNull
argument_list|,
name|syntax
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|createTypeAttribute
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
name|ParsedType
name|typeArg
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|typeArg
argument_list|,
name|syntaxUsed
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|createPropertyAttribute
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
name|IdentifierInfo
operator|*
name|getterId
argument_list|,
name|IdentifierInfo
operator|*
name|setterId
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|AttributeFactory
operator|::
name|PropertyAllocSize
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|getterId
argument_list|,
name|setterId
argument_list|,
name|syntaxUsed
argument_list|)
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// addAttributeLists - Add two AttributeLists together
end_comment

begin_comment
comment|/// The right-hand list is appended to the left-hand list, if any
end_comment

begin_comment
comment|/// A pointer to the joined list is returned.
end_comment

begin_comment
comment|/// Note: the lists are not left unmodified.
end_comment

begin_function
specifier|inline
name|AttributeList
modifier|*
name|addAttributeLists
parameter_list|(
name|AttributeList
modifier|*
name|Left
parameter_list|,
name|AttributeList
modifier|*
name|Right
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Left
condition|)
return|return
name|Right
return|;
name|AttributeList
modifier|*
name|next
init|=
name|Left
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|getNext
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
name|prev
operator|->
name|setNext
argument_list|(
name|Right
argument_list|)
expr_stmt|;
return|return
name|Left
return|;
block|}
end_function

begin_comment
comment|/// CXX11AttributeList - A wrapper around a C++11 attribute list.
end_comment

begin_comment
comment|/// Stores, in addition to the list proper, whether or not an actual list was
end_comment

begin_comment
comment|/// (as opposed to an empty list, which may be ill-formed in some places) and
end_comment

begin_comment
comment|/// the source range of the list.
end_comment

begin_struct
struct|struct
name|CXX11AttributeList
block|{
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
name|SourceRange
name|Range
decl_stmt|;
name|bool
name|HasAttr
decl_stmt|;
name|CXX11AttributeList
argument_list|(
argument|AttributeList *attrList
argument_list|,
argument|SourceRange range
argument_list|,
argument|bool hasAttr
argument_list|)
block|:
name|AttrList
argument_list|(
name|attrList
argument_list|)
operator|,
name|Range
argument_list|(
name|range
argument_list|)
operator|,
name|HasAttr
argument_list|(
argument|hasAttr
argument_list|)
block|{   }
name|CXX11AttributeList
argument_list|()
operator|:
name|AttrList
argument_list|(
literal|0
argument_list|)
operator|,
name|Range
argument_list|()
operator|,
name|HasAttr
argument_list|(
argument|false
argument_list|)
block|{   }
block|}
struct|;
end_struct

begin_comment
comment|/// ParsedAttributes - A collection of parsed attributes.  Currently
end_comment

begin_comment
comment|/// we don't differentiate between the various attribute syntaxes,
end_comment

begin_comment
comment|/// which is basically silly.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Right now this is a very lightweight container, but the expectation
end_comment

begin_comment
comment|/// is that this will become significantly more serious.
end_comment

begin_decl_stmt
name|class
name|ParsedAttributes
block|{
name|public
label|:
name|ParsedAttributes
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|pool
argument_list|(
name|factory
argument_list|)
operator|,
name|list
argument_list|(
literal|0
argument_list|)
block|{   }
name|ParsedAttributes
argument_list|(
name|ParsedAttributes
operator|&
name|attrs
argument_list|)
operator|:
name|pool
argument_list|(
name|attrs
operator|.
name|pool
argument_list|)
operator|,
name|list
argument_list|(
argument|attrs.list
argument_list|)
block|{
name|attrs
operator|.
name|list
operator|=
literal|0
block|;   }
name|AttributePool
operator|&
name|getPool
argument_list|()
specifier|const
block|{
return|return
name|pool
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|list
operator|==
literal|0
return|;
block|}
name|void
name|add
parameter_list|(
name|AttributeList
modifier|*
name|newAttr
parameter_list|)
block|{
name|assert
argument_list|(
name|newAttr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|newAttr
operator|->
name|getNext
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newAttr
operator|->
name|setNext
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|newAttr
expr_stmt|;
block|}
name|void
name|addAll
parameter_list|(
name|AttributeList
modifier|*
name|newList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|newList
condition|)
return|return;
name|AttributeList
modifier|*
name|lastInNewList
init|=
name|newList
decl_stmt|;
while|while
condition|(
name|AttributeList
modifier|*
name|next
init|=
name|lastInNewList
operator|->
name|getNext
argument_list|()
condition|)
name|lastInNewList
operator|=
name|next
expr_stmt|;
name|lastInNewList
operator|->
name|setNext
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|newList
expr_stmt|;
block|}
name|void
name|set
parameter_list|(
name|AttributeList
modifier|*
name|newList
parameter_list|)
block|{
name|list
operator|=
name|newList
expr_stmt|;
block|}
name|void
name|takeAllFrom
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
block|{
name|addAll
argument_list|(
name|attrs
operator|.
name|list
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|list
operator|=
literal|0
expr_stmt|;
name|pool
operator|.
name|takeAllFrom
argument_list|(
name|attrs
operator|.
name|pool
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|list
operator|=
literal|0
expr_stmt|;
name|pool
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|AttributeList
operator|*
name|getList
argument_list|()
specifier|const
block|{
return|return
name|list
return|;
block|}
comment|/// Returns a reference to the attribute list.  Try not to introduce
comment|/// dependencies on this method, it may not be long-lived.
name|AttributeList
modifier|*
modifier|&
name|getListRef
parameter_list|()
block|{
return|return
name|list
return|;
block|}
comment|/// Add attribute with expression arguments.
name|AttributeList
modifier|*
name|addNew
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
name|Expr
operator|*
operator|*
name|args
argument_list|,
name|unsigned
name|numArgs
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|,
name|SourceLocation
name|ellipsisLoc
operator|=
name|SourceLocation
argument_list|()
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|create
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|args
argument_list|,
name|numArgs
argument_list|,
name|syntax
argument_list|,
name|ellipsisLoc
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add availability attribute.
name|AttributeList
modifier|*
name|addNew
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|introduced
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|deprecated
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|obsoleted
argument_list|,
name|SourceLocation
name|unavailable
argument_list|,
specifier|const
name|Expr
operator|*
name|MessageExpr
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|create
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|introduced
argument_list|,
name|deprecated
argument_list|,
name|obsoleted
argument_list|,
name|unavailable
argument_list|,
name|MessageExpr
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add type_tag_for_datatype attribute.
name|AttributeList
modifier|*
name|addNewTypeTagForDatatype
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|argumentKindName
argument_list|,
name|SourceLocation
name|argumentKindLoc
argument_list|,
name|ParsedType
name|matchingCType
argument_list|,
name|bool
name|layoutCompatible
argument_list|,
name|bool
name|mustBeNull
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createTypeTagForDatatype
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|argumentKindName
argument_list|,
name|argumentKindLoc
argument_list|,
name|matchingCType
argument_list|,
name|layoutCompatible
argument_list|,
name|mustBeNull
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add an attribute with a single type argument.
name|AttributeList
modifier|*
name|addNewTypeAttr
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
name|ParsedType
name|typeArg
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createTypeAttribute
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|typeArg
argument_list|,
name|syntaxUsed
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add microsoft __delspec(property) attribute.
name|AttributeList
modifier|*
name|addNewPropertyAttr
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|parmName
argument_list|,
name|SourceLocation
name|parmLoc
argument_list|,
name|IdentifierInfo
operator|*
name|getterId
argument_list|,
name|IdentifierInfo
operator|*
name|setterId
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createPropertyAttribute
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|getterId
argument_list|,
name|setterId
argument_list|,
name|syntaxUsed
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
name|AttributeList
modifier|*
name|addNewInteger
parameter_list|(
name|ASTContext
modifier|&
name|C
parameter_list|,
name|IdentifierInfo
modifier|*
name|name
parameter_list|,
name|SourceLocation
name|loc
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createIntegerAttribute
argument_list|(
name|C
argument_list|,
name|name
argument_list|,
name|loc
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
name|private
label|:
name|mutable
name|AttributePool
name|pool
decl_stmt|;
name|AttributeList
modifier|*
name|list
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

