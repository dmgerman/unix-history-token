begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Marshallers.h - Generic matcher function marshallers -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Functions templates and classes to wrap matcher construct functions.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// A collection of template function and classes that provide a generic
end_comment

begin_comment
comment|/// marshalling layer on top of matcher construct functions.
end_comment

begin_comment
comment|/// These are used by the registry to export all marshaller constructors with
end_comment

begin_comment
comment|/// the same generic interface.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_MATCHERS_DYNAMIC_MARSHALLERS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_MATCHERS_DYNAMIC_MARSHALLERS_H
end_define

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchers.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/Dynamic/Diagnostics.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/Dynamic/VariantValue.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|ast_matchers
block|{
name|namespace
name|dynamic
block|{
name|namespace
name|internal
block|{
comment|/// \brief Helper template class to just from argument type to the right is/get
comment|///   functions in VariantValue.
comment|/// Used to verify and extract the matcher arguments below.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|ArgTypeTraits
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|ArgTypeTraits
operator|<
specifier|const
name|T
operator|&
operator|>
operator|:
name|public
name|ArgTypeTraits
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|std
operator|::
name|string
operator|>
block|{
specifier|static
name|StringRef
name|asString
argument_list|()
block|{
return|return
literal|"String"
return|;
block|}
specifier|static
name|bool
name|is
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|isString
argument_list|()
return|;
block|}
specifier|static
specifier|const
name|std
operator|::
name|string
operator|&
name|get
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|getString
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|StringRef
operator|>
operator|:
name|public
name|ArgTypeTraits
operator|<
name|std
operator|::
name|string
operator|>
block|{ }
block|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|ast_matchers
operator|::
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
expr|>
block|{
specifier|static
name|std
operator|::
name|string
name|asString
argument_list|()
block|{
return|return
operator|(
name|Twine
argument_list|(
literal|"Matcher<"
argument_list|)
operator|+
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
operator|.
name|asStringRef
argument_list|()
operator|+
literal|">"
operator|)
operator|.
name|str
argument_list|()
return|;
block|}
specifier|static
name|bool
name|is
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|isMatcher
argument_list|()
operator|&&
name|Value
operator|.
name|getMatcher
argument_list|()
operator|.
name|hasTypedMatcher
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
specifier|static
name|ast_matchers
operator|::
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
name|get
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|getMatcher
argument_list|()
operator|.
name|getTypedMatcher
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|unsigned
operator|>
block|{
specifier|static
name|std
operator|::
name|string
name|asString
argument_list|()
block|{
return|return
literal|"Unsigned"
return|;
block|}
specifier|static
name|bool
name|is
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|isUnsigned
argument_list|()
return|;
block|}
specifier|static
name|unsigned
name|get
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|getUnsigned
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Generic MatcherCreate interface.
comment|///
comment|/// Provides a \c run() method that constructs the matcher from the provided
comment|/// arguments.
name|class
name|MatcherCreateCallback
block|{
name|public
operator|:
name|virtual
operator|~
name|MatcherCreateCallback
argument_list|()
block|{}
name|virtual
name|VariantMatcher
name|run
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
operator|=
literal|0
block|; }
block|;
comment|/// \brief Simple callback implementation. Marshaller and function are provided.
comment|///
comment|/// This class wraps a function of arbitrary signature and a marshaller
comment|/// function into a MatcherCreateCallback.
comment|/// The marshaller is in charge of taking the VariantValue arguments, checking
comment|/// their types, unpacking them and calling the underlying function.
name|class
name|FixedArgCountMatcherCreateCallback
operator|:
name|public
name|MatcherCreateCallback
block|{
name|public
operator|:
typedef|typedef
name|VariantMatcher
argument_list|(
argument|*MarshallerType
argument_list|)
operator|(
name|void
argument_list|(
operator|*
name|Func
argument_list|)
argument_list|()
operator|,
name|StringRef
name|MatcherName
operator|,
specifier|const
name|SourceRange
operator|&
name|NameRange
operator|,
name|ArrayRef
operator|<
name|ParserValue
operator|>
name|Args
operator|,
name|Diagnostics
operator|*
name|Error
operator|)
expr_stmt|;
comment|/// \param Marshaller Function to unpack the arguments and call \c Func
comment|/// \param Func Matcher construct function. This is the function that
comment|///   compile-time matcher expressions would use to create the matcher.
name|FixedArgCountMatcherCreateCallback
argument_list|(
argument|MarshallerType Marshaller
argument_list|,
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|)
operator|:
name|Marshaller
argument_list|(
name|Marshaller
argument_list|)
operator|,
name|Func
argument_list|(
name|Func
argument_list|)
operator|,
name|MatcherName
argument_list|(
argument|MatcherName
argument_list|)
block|{}
name|VariantMatcher
name|run
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
block|{
return|return
name|Marshaller
argument_list|(
name|Func
argument_list|,
name|MatcherName
argument_list|,
name|NameRange
argument_list|,
name|Args
argument_list|,
name|Error
argument_list|)
return|;
block|}
name|private
operator|:
specifier|const
name|MarshallerType
name|Marshaller
block|;
name|void
argument_list|(
operator|*
specifier|const
name|Func
argument_list|)
argument_list|()
block|;
specifier|const
name|std
operator|::
name|string
name|MatcherName
block|; }
block|;
comment|/// \brief Simple callback implementation. Free function is wrapped.
comment|///
comment|/// This class simply wraps a free function with the right signature to export
comment|/// it as a MatcherCreateCallback.
comment|/// This allows us to have one implementation of the interface for as many free
comment|/// functions as we want, reducing the number of symbols and size of the
comment|/// object file.
name|class
name|FreeFuncMatcherCreateCallback
operator|:
name|public
name|MatcherCreateCallback
block|{
name|public
operator|:
typedef|typedef
name|VariantMatcher
argument_list|(
argument|*RunFunc
argument_list|)
operator|(
name|StringRef
name|MatcherName
operator|,
specifier|const
name|SourceRange
operator|&
name|NameRange
operator|,
name|ArrayRef
operator|<
name|ParserValue
operator|>
name|Args
operator|,
name|Diagnostics
operator|*
name|Error
operator|)
expr_stmt|;
name|FreeFuncMatcherCreateCallback
argument_list|(
argument|RunFunc Func
argument_list|,
argument|StringRef MatcherName
argument_list|)
operator|:
name|Func
argument_list|(
name|Func
argument_list|)
operator|,
name|MatcherName
argument_list|(
argument|MatcherName.str()
argument_list|)
block|{}
name|VariantMatcher
name|run
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
block|{
return|return
name|Func
argument_list|(
name|MatcherName
argument_list|,
name|NameRange
argument_list|,
name|Args
argument_list|,
name|Error
argument_list|)
return|;
block|}
name|private
operator|:
specifier|const
name|RunFunc
name|Func
block|;
specifier|const
name|std
operator|::
name|string
name|MatcherName
block|; }
block|;
comment|/// \brief Helper macros to check the arguments on all marshaller functions.
define|#
directive|define
name|CHECK_ARG_COUNT
parameter_list|(
name|count
parameter_list|)
define|\
value|if (Args.size() != count) {                                                  \     Error->addError(NameRange, Error->ET_RegistryWrongArgCount)                \<< count<< Args.size();                                               \     return VariantMatcher();                                                   \   }
define|#
directive|define
name|CHECK_ARG_TYPE
parameter_list|(
name|index
parameter_list|,
name|type
parameter_list|)
define|\
value|if (!ArgTypeTraits<type>::is(Args[index].Value)) {                           \     Error->addError(Args[index].Range, Error->ET_RegistryWrongArgType)         \<< (index + 1)<< ArgTypeTraits<type>::asString()                      \<< Args[index].Value.getTypeAsString();                                \     return VariantMatcher();                                                   \   }
comment|/// \brief Helper methods to extract and merge all possible typed matchers
comment|/// out of the polymorphic object.
name|template
operator|<
name|class
name|PolyMatcher
operator|>
specifier|static
name|void
name|mergePolyMatchers
argument_list|(
argument|const PolyMatcher&Poly
argument_list|,
argument|std::vector<DynTypedMatcher>&Out
argument_list|,
argument|ast_matchers::internal::EmptyTypeList
argument_list|)
block|{}
name|template
operator|<
name|class
name|PolyMatcher
block|,
name|class
name|TypeList
operator|>
specifier|static
name|void
name|mergePolyMatchers
argument_list|(
argument|const PolyMatcher&Poly
argument_list|,
argument|std::vector<DynTypedMatcher>&Out
argument_list|,
argument|TypeList
argument_list|)
block|{
name|Out
operator|.
name|push_back
argument_list|(
argument|ast_matchers::internal::Matcher<typename TypeList::head>(Poly)
argument_list|)
block|;
name|mergePolyMatchers
argument_list|(
argument|Poly
argument_list|,
argument|Out
argument_list|,
argument|typename TypeList::tail()
argument_list|)
block|; }
comment|/// \brief Convert the return values of the functions into a VariantMatcher.
comment|///
comment|/// There are 2 cases right now: The return value is a Matcher<T> or is a
comment|/// polymorphic matcher. For the former, we just construct the VariantMatcher.
comment|/// For the latter, we instantiate all the possible Matcher<T> of the poly
comment|/// matcher.
specifier|static
name|VariantMatcher
name|outvalueToVariantMatcher
argument_list|(
argument|const DynTypedMatcher&Matcher
argument_list|)
block|{
return|return
name|VariantMatcher
operator|::
name|SingleMatcher
argument_list|(
name|Matcher
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|VariantMatcher
name|outvalueToVariantMatcher
argument_list|(
argument|const T&PolyMatcher
argument_list|,
argument|typename T::ReturnTypes * =                                                    NULL
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|DynTypedMatcher
operator|>
name|Matchers
block|;
name|mergePolyMatchers
argument_list|(
argument|PolyMatcher
argument_list|,
argument|Matchers
argument_list|,
argument|typename T::ReturnTypes()
argument_list|)
block|;
name|VariantMatcher
name|Out
operator|=
name|VariantMatcher
operator|::
name|PolymorphicMatcher
argument_list|(
name|Matchers
argument_list|)
block|;
return|return
name|Out
return|;
block|}
comment|/// \brief 0-arg marshaller function.
name|template
operator|<
name|typename
name|ReturnType
operator|>
specifier|static
name|VariantMatcher
name|matcherMarshall0
argument_list|(
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
typedef|typedef
name|ReturnType
function_decl|(
modifier|*
name|FuncType
function_decl|)
parameter_list|()
function_decl|;
name|CHECK_ARG_COUNT
argument_list|(
literal|0
argument_list|)
block|;
return|return
name|outvalueToVariantMatcher
argument_list|(
name|reinterpret_cast
operator|<
name|FuncType
operator|>
call|(
name|Func
call|)
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief 1-arg marshaller function.
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|>
specifier|static
name|VariantMatcher
name|matcherMarshall1
argument_list|(
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
typedef|typedef
name|ReturnType
function_decl|(
modifier|*
name|FuncType
function_decl|)
parameter_list|(
name|ArgType1
parameter_list|)
function_decl|;
name|CHECK_ARG_COUNT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CHECK_ARG_TYPE
argument_list|(
literal|0
argument_list|,
name|ArgType1
argument_list|)
expr_stmt|;
return|return
name|outvalueToVariantMatcher
argument_list|(
name|reinterpret_cast
operator|<
name|FuncType
operator|>
call|(
name|Func
call|)
argument_list|(
name|ArgTypeTraits
operator|<
name|ArgType1
operator|>
operator|::
name|get
argument_list|(
name|Args
index|[
literal|0
index|]
operator|.
name|Value
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief 2-arg marshaller function.
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|,
name|typename
name|ArgType2
operator|>
specifier|static
name|VariantMatcher
name|matcherMarshall2
argument_list|(
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
typedef|typedef
name|ReturnType
function_decl|(
modifier|*
name|FuncType
function_decl|)
parameter_list|(
name|ArgType1
parameter_list|,
name|ArgType2
parameter_list|)
function_decl|;
name|CHECK_ARG_COUNT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|CHECK_ARG_TYPE
argument_list|(
literal|0
argument_list|,
name|ArgType1
argument_list|)
expr_stmt|;
name|CHECK_ARG_TYPE
argument_list|(
literal|1
argument_list|,
name|ArgType2
argument_list|)
expr_stmt|;
return|return
name|outvalueToVariantMatcher
argument_list|(
name|reinterpret_cast
operator|<
name|FuncType
operator|>
call|(
name|Func
call|)
argument_list|(
name|ArgTypeTraits
operator|<
name|ArgType1
operator|>
operator|::
name|get
argument_list|(
name|Args
index|[
literal|0
index|]
operator|.
name|Value
argument_list|)
argument_list|,
name|ArgTypeTraits
operator|<
name|ArgType2
operator|>
operator|::
name|get
argument_list|(
name|Args
index|[
literal|1
index|]
operator|.
name|Value
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
undef|#
directive|undef
name|CHECK_ARG_COUNT
undef|#
directive|undef
name|CHECK_ARG_TYPE
comment|/// \brief Variadic marshaller function.
name|template
operator|<
name|typename
name|ResultT
operator|,
name|typename
name|ArgT
operator|,
name|ResultT
argument_list|(
operator|*
name|Func
argument_list|)
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|ArgT
operator|*
operator|>
argument_list|)
operator|>
name|VariantMatcher
name|variadicMatcherCreateCallback
argument_list|(
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
name|ArgT
operator|*
operator|*
name|InnerArgs
operator|=
name|new
name|ArgT
operator|*
index|[
name|Args
operator|.
name|size
argument_list|()
index|]
operator|(
operator|)
block|;
name|bool
name|HasError
operator|=
name|false
block|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Args
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
typedef|typedef
name|ArgTypeTraits
operator|<
name|ArgT
operator|>
name|ArgTraits
expr_stmt|;
specifier|const
name|ParserValue
modifier|&
name|Arg
init|=
name|Args
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|VariantValue
modifier|&
name|Value
init|=
name|Arg
operator|.
name|Value
decl_stmt|;
if|if
condition|(
operator|!
name|ArgTraits
operator|::
name|is
argument_list|(
name|Value
argument_list|)
condition|)
block|{
name|Error
operator|->
name|addError
argument_list|(
name|Arg
operator|.
name|Range
argument_list|,
name|Error
operator|->
name|ET_RegistryWrongArgType
argument_list|)
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|ArgTraits
operator|::
name|asString
argument_list|()
operator|<<
name|Value
operator|.
name|getTypeAsString
argument_list|()
expr_stmt|;
name|HasError
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|InnerArgs
index|[
name|i
index|]
operator|=
name|new
name|ArgT
argument_list|(
name|ArgTraits
operator|::
name|get
argument_list|(
name|Value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VariantMatcher
name|Out
decl_stmt|;
if|if
condition|(
operator|!
name|HasError
condition|)
block|{
name|Out
operator|=
name|outvalueToVariantMatcher
argument_list|(
name|Func
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|ArgT
operator|*
operator|>
operator|(
name|InnerArgs
operator|,
name|Args
operator|.
name|size
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Args
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|delete
name|InnerArgs
index|[
name|i
index|]
decl_stmt|;
block|}
name|delete
index|[]
name|InnerArgs
decl_stmt|;
return|return
name|Out
return|;
block|}
comment|/// \brief Helper class used to collect all the possible overloads of an
comment|///   argument adaptative matcher function.
name|template
operator|<
name|template
operator|<
name|typename
name|ToArg
operator|,
name|typename
name|FromArg
operator|>
name|class
name|ArgumentAdapterT
operator|,
name|typename
name|FromTypes
operator|,
name|typename
name|ToTypes
operator|>
name|class
name|AdaptativeOverloadCollector
block|{
name|public
operator|:
name|AdaptativeOverloadCollector
argument_list|(
argument|StringRef Name
argument_list|,
argument|std::vector<MatcherCreateCallback *>&Out
argument_list|)
operator|:
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|Out
argument_list|(
argument|Out
argument_list|)
block|{
name|collect
argument_list|(
name|FromTypes
argument_list|()
argument_list|)
block|;   }
name|private
operator|:
typedef|typedef
name|ast_matchers
operator|::
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|ArgumentAdapterT
operator|,
name|FromTypes
operator|,
name|ToTypes
operator|>
name|AdaptativeFunc
expr_stmt|;
comment|/// \brief End case for the recursion
specifier|static
name|void
name|collect
argument_list|(
argument|ast_matchers::internal::EmptyTypeList
argument_list|)
block|{}
comment|/// \brief Recursive case. Get the overload for the head of the list, and
comment|///   recurse to the tail.
name|template
operator|<
name|typename
name|FromTypeList
operator|>
specifier|inline
name|void
name|collect
argument_list|(
name|FromTypeList
argument_list|)
expr_stmt|;
specifier|const
name|StringRef
name|Name
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|MatcherCreateCallback
operator|*
operator|>
operator|&
name|Out
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief MatcherCreateCallback that wraps multiple "overloads" of the same
end_comment

begin_comment
comment|///   matcher.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// It will try every overload and generate appropriate errors for when none or
end_comment

begin_comment
comment|/// more than one overloads match the arguments.
end_comment

begin_decl_stmt
name|class
name|OverloadedMatcherCreateCallback
range|:
name|public
name|MatcherCreateCallback
block|{
name|public
operator|:
name|OverloadedMatcherCreateCallback
argument_list|(
name|ArrayRef
operator|<
name|MatcherCreateCallback
operator|*
operator|>
name|Callbacks
argument_list|)
operator|:
name|Overloads
argument_list|(
argument|Callbacks
argument_list|)
block|{}
name|virtual
operator|~
name|OverloadedMatcherCreateCallback
argument_list|()
block|{
name|llvm
operator|::
name|DeleteContainerPointers
argument_list|(
name|Overloads
argument_list|)
block|;   }
name|virtual
name|VariantMatcher
name|run
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
block|{
name|std
operator|::
name|vector
operator|<
name|VariantMatcher
operator|>
name|Constructed
block|;
name|Diagnostics
operator|::
name|OverloadContext
name|Ctx
argument_list|(
name|Error
argument_list|)
block|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Overloads
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|VariantMatcher
name|SubMatcher
init|=
name|Overloads
index|[
name|i
index|]
operator|->
name|run
argument_list|(
name|NameRange
argument_list|,
name|Args
argument_list|,
name|Error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SubMatcher
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|Constructed
operator|.
name|push_back
argument_list|(
name|SubMatcher
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Constructed
operator|.
name|empty
argument_list|()
condition|)
return|return
name|VariantMatcher
argument_list|()
return|;
comment|// No overload matched.
comment|// We ignore the errors if any matcher succeeded.
name|Ctx
operator|.
name|revertErrors
argument_list|()
block|;
if|if
condition|(
name|Constructed
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// More than one constructed. It is ambiguous.
name|Error
operator|->
name|addError
argument_list|(
name|NameRange
argument_list|,
name|Error
operator|->
name|ET_RegistryAmbiguousOverload
argument_list|)
expr_stmt|;
return|return
name|VariantMatcher
argument_list|()
return|;
block|}
return|return
name|Constructed
index|[
literal|0
index|]
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|MatcherCreateCallback
operator|*
operator|>
name|Overloads
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// \brief Variadic operator marshaller function.
end_comment

begin_decl_stmt
name|class
name|VariadicOperatorMatcherCreateCallback
range|:
name|public
name|MatcherCreateCallback
block|{
name|public
operator|:
typedef|typedef
name|ast_matchers
operator|::
name|internal
operator|::
name|VariadicOperatorFunction
name|VarFunc
expr_stmt|;
name|VariadicOperatorMatcherCreateCallback
argument_list|(
argument|VarFunc Func
argument_list|,
argument|StringRef MatcherName
argument_list|)
operator|:
name|Func
argument_list|(
name|Func
argument_list|)
block|,
name|MatcherName
argument_list|(
argument|MatcherName
argument_list|)
block|{}
name|virtual
name|VariantMatcher
name|run
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
block|{
name|std
operator|::
name|vector
operator|<
name|VariantMatcher
operator|>
name|InnerArgs
block|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Args
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ParserValue
modifier|&
name|Arg
init|=
name|Args
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|VariantValue
modifier|&
name|Value
init|=
name|Arg
operator|.
name|Value
decl_stmt|;
if|if
condition|(
operator|!
name|Value
operator|.
name|isMatcher
argument_list|()
condition|)
block|{
name|Error
operator|->
name|addError
argument_list|(
name|Arg
operator|.
name|Range
argument_list|,
name|Error
operator|->
name|ET_RegistryWrongArgType
argument_list|)
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
literal|"Matcher<>"
operator|<<
name|Value
operator|.
name|getTypeAsString
argument_list|()
expr_stmt|;
return|return
name|VariantMatcher
argument_list|()
return|;
block|}
name|InnerArgs
operator|.
name|push_back
argument_list|(
name|Value
operator|.
name|getMatcher
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|VariantMatcher
operator|::
name|VariadicOperatorMatcher
argument_list|(
name|Func
argument_list|,
name|InnerArgs
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|const
name|VarFunc
name|Func
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|StringRef
name|MatcherName
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Helper functions to select the appropriate marshaller functions.
end_comment

begin_comment
comment|/// They detect the number of arguments, arguments types and return type.
end_comment

begin_comment
comment|/// \brief 0-arg overload
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ReturnType
operator|>
name|MatcherCreateCallback
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ReturnType (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|FixedArgCountMatcherCreateCallback
argument_list|(
name|matcherMarshall0
operator|<
name|ReturnType
operator|>
argument_list|,
name|reinterpret_cast
operator|<
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|>
operator|(
name|Func
operator|)
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief 1-arg overload
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|>
name|MatcherCreateCallback
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ReturnType (*Func)(ArgType1)
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|FixedArgCountMatcherCreateCallback
argument_list|(
name|matcherMarshall1
operator|<
name|ReturnType
argument_list|,
name|ArgType1
operator|>
argument_list|,
name|reinterpret_cast
operator|<
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|>
operator|(
name|Func
operator|)
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief 2-arg overload
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|,
name|typename
name|ArgType2
operator|>
name|MatcherCreateCallback
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ReturnType (*Func)(ArgType1,                                                                   ArgType2)
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|FixedArgCountMatcherCreateCallback
argument_list|(
name|matcherMarshall2
operator|<
name|ReturnType
argument_list|,
name|ArgType1
argument_list|,
name|ArgType2
operator|>
argument_list|,
name|reinterpret_cast
operator|<
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|>
operator|(
name|Func
operator|)
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Variadic overload.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ResultT
operator|,
name|typename
name|ArgT
operator|,
name|ResultT
argument_list|(
operator|*
name|Func
argument_list|)
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|ArgT
operator|*
operator|>
argument_list|)
operator|>
name|MatcherCreateCallback
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|llvm::VariadicFunction<ResultT
argument_list|,
argument|ArgT
argument_list|,
argument|Func> VarFunc
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|FreeFuncMatcherCreateCallback
argument_list|(
operator|&
name|variadicMatcherCreateCallback
operator|<
name|ResultT
argument_list|,
name|ArgT
argument_list|,
name|Func
operator|>
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Argument adaptative overload.
end_comment

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|typename
name|ToArg
operator|,
name|typename
name|FromArg
operator|>
name|class
name|ArgumentAdapterT
operator|,
name|typename
name|FromTypes
operator|,
name|typename
name|ToTypes
operator|>
name|MatcherCreateCallback
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ast_matchers::internal::ArgumentAdaptingMatcherFunc<                             ArgumentAdapterT
argument_list|,
argument|FromTypes
argument_list|,
argument|ToTypes>
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|MatcherCreateCallback
operator|*
operator|>
name|Overloads
block|;
name|AdaptativeOverloadCollector
operator|<
name|ArgumentAdapterT
block|,
name|FromTypes
block|,
name|ToTypes
operator|>
operator|(
name|MatcherName
operator|,
name|Overloads
operator|)
block|;
return|return
name|new
name|OverloadedMatcherCreateCallback
argument_list|(
name|Overloads
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|typename
name|ToArg
operator|,
name|typename
name|FromArg
operator|>
name|class
name|ArgumentAdapterT
operator|,
name|typename
name|FromTypes
operator|,
name|typename
name|ToTypes
operator|>
name|template
operator|<
name|typename
name|FromTypeList
operator|>
specifier|inline
name|void
name|AdaptativeOverloadCollector
operator|<
name|ArgumentAdapterT
operator|,
name|FromTypes
operator|,
name|ToTypes
operator|>
operator|::
name|collect
argument_list|(
argument|FromTypeList
argument_list|)
block|{
name|Out
operator|.
name|push_back
argument_list|(
name|makeMatcherAutoMarshall
argument_list|(
argument|&AdaptativeFunc::template create<typename FromTypeList::head>
argument_list|,
argument|Name
argument_list|)
argument_list|)
block|;
name|collect
argument_list|(
argument|typename FromTypeList::tail()
argument_list|)
block|; }
comment|/// \brief Variadic operator overload.
name|MatcherCreateCallback
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ast_matchers::internal::VariadicOperatorMatcherFunc Func
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|VariadicOperatorMatcherCreateCallback
argument_list|(
name|Func
operator|.
name|Func
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace internal
end_comment

begin_comment
unit|}
comment|// namespace dynamic
end_comment

begin_comment
unit|}
comment|// namespace ast_matchers
end_comment

begin_comment
unit|}
comment|// namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_AST_MATCHERS_DYNAMIC_MARSHALLERS_H
end_comment

end_unit

