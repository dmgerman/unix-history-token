begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- BreakableToken.h - Format C++ code -------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Declares BreakableToken, BreakableStringLiteral, and
end_comment

begin_comment
comment|/// BreakableBlockComment classes, that contain token type-specific logic to
end_comment

begin_comment
comment|/// break long lines in tokens.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_FORMAT_BREAKABLETOKEN_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_FORMAT_BREAKABLETOKEN_H
end_define

begin_include
include|#
directive|include
file|"TokenAnnotator.h"
end_include

begin_include
include|#
directive|include
file|"WhitespaceManager.h"
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|format
block|{
name|class
name|BreakableToken
block|{
name|public
label|:
name|BreakableToken
argument_list|(
argument|const SourceManager&SourceMgr
argument_list|,
argument|const FormatToken&Tok
argument_list|,
argument|unsigned StartColumn
argument_list|)
block|:
name|Tok
argument_list|(
name|Tok
argument_list|)
operator|,
name|StartColumn
argument_list|(
name|StartColumn
argument_list|)
operator|,
name|TokenText
argument_list|(
argument|SourceMgr.getCharacterData(Tok.getStartOfNonWhitespace())
argument_list|,
argument|Tok.TokenLength
argument_list|)
block|{}
name|virtual
operator|~
name|BreakableToken
argument_list|()
block|{}
name|virtual
name|unsigned
name|getLineCount
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
name|unsigned
name|getLineSize
argument_list|(
name|unsigned
name|Index
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
name|unsigned
name|getLineLengthAfterSplit
argument_list|(
name|unsigned
name|LineIndex
argument_list|,
name|unsigned
name|TailOffset
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
comment|// Contains starting character index and length of split.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|StringRef
operator|::
name|size_type
operator|,
name|unsigned
operator|>
name|Split
expr_stmt|;
name|virtual
name|Split
name|getSplit
argument_list|(
name|unsigned
name|LineIndex
argument_list|,
name|unsigned
name|TailOffset
argument_list|,
name|unsigned
name|ColumnLimit
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|insertBreak
parameter_list|(
name|unsigned
name|LineIndex
parameter_list|,
name|unsigned
name|TailOffset
parameter_list|,
name|Split
name|Split
parameter_list|,
name|bool
name|InPPDirective
parameter_list|,
name|WhitespaceManager
modifier|&
name|Whitespaces
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|trimLine
parameter_list|(
name|unsigned
name|LineIndex
parameter_list|,
name|unsigned
name|TailOffset
parameter_list|,
name|unsigned
name|InPPDirective
parameter_list|,
name|WhitespaceManager
modifier|&
name|Whitespaces
parameter_list|)
block|{}
name|protected
label|:
specifier|const
name|FormatToken
modifier|&
name|Tok
decl_stmt|;
name|unsigned
name|StartColumn
decl_stmt|;
name|StringRef
name|TokenText
decl_stmt|;
block|}
empty_stmt|;
name|class
name|BreakableStringLiteral
range|:
name|public
name|BreakableToken
block|{
name|public
operator|:
name|BreakableStringLiteral
argument_list|(
argument|const SourceManager&SourceMgr
argument_list|,
argument|const FormatToken&Tok
argument_list|,
argument|unsigned StartColumn
argument_list|)
operator|:
name|BreakableToken
argument_list|(
argument|SourceMgr
argument_list|,
argument|Tok
argument_list|,
argument|StartColumn
argument_list|)
block|{
name|assert
argument_list|(
name|TokenText
operator|.
name|startswith
argument_list|(
literal|"\""
argument_list|)
operator|&&
name|TokenText
operator|.
name|endswith
argument_list|(
literal|"\""
argument_list|)
argument_list|)
block|;   }
name|virtual
name|unsigned
name|getLineCount
argument_list|()
specifier|const
block|{
return|return
literal|1
return|;
block|}
name|virtual
name|unsigned
name|getLineSize
argument_list|(
argument|unsigned Index
argument_list|)
specifier|const
block|{
return|return
name|Tok
operator|.
name|TokenLength
operator|-
literal|2
return|;
comment|// Should be in sync with getLine
block|}
name|virtual
name|unsigned
name|getLineLengthAfterSplit
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|)
specifier|const
block|{
return|return
name|getDecorationLength
argument_list|()
operator|+
name|getLine
argument_list|()
operator|.
name|size
argument_list|()
operator|-
name|TailOffset
return|;
block|}
name|virtual
name|Split
name|getSplit
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|,
argument|unsigned ColumnLimit
argument_list|)
specifier|const
block|{
name|StringRef
name|Text
operator|=
name|getLine
argument_list|()
operator|.
name|substr
argument_list|(
name|TailOffset
argument_list|)
block|;
if|if
condition|(
name|ColumnLimit
operator|<=
name|getDecorationLength
argument_list|()
condition|)
return|return
name|Split
argument_list|(
name|StringRef
operator|::
name|npos
argument_list|,
literal|0
argument_list|)
return|;
name|unsigned
name|MaxSplit
operator|=
name|ColumnLimit
operator|-
name|getDecorationLength
argument_list|()
block|;
name|assert
argument_list|(
name|MaxSplit
operator|<
name|Text
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|StringRef
operator|::
name|size_type
name|SpaceOffset
operator|=
name|Text
operator|.
name|rfind
argument_list|(
literal|' '
argument_list|,
name|MaxSplit
argument_list|)
block|;
if|if
condition|(
name|SpaceOffset
operator|!=
name|StringRef
operator|::
name|npos
operator|&&
name|SpaceOffset
operator|!=
literal|0
condition|)
return|return
name|Split
argument_list|(
name|SpaceOffset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
return|;
name|StringRef
operator|::
name|size_type
name|SlashOffset
operator|=
name|Text
operator|.
name|rfind
argument_list|(
literal|'/'
argument_list|,
name|MaxSplit
argument_list|)
decl_stmt|;
if|if
condition|(
name|SlashOffset
operator|!=
name|StringRef
operator|::
name|npos
operator|&&
name|SlashOffset
operator|!=
literal|0
condition|)
return|return
name|Split
argument_list|(
name|SlashOffset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
return|;
name|StringRef
operator|::
name|size_type
name|SplitPoint
operator|=
name|getStartOfCharacter
argument_list|(
name|Text
argument_list|,
name|MaxSplit
argument_list|)
expr_stmt|;
if|if
condition|(
name|SplitPoint
operator|!=
name|StringRef
operator|::
name|npos
operator|&&
name|SplitPoint
operator|>
literal|1
condition|)
comment|// Do not split at 0.
return|return
name|Split
argument_list|(
name|SplitPoint
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|Split
argument_list|(
name|StringRef
operator|::
name|npos
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|virtual
name|void
name|insertBreak
parameter_list|(
name|unsigned
name|LineIndex
parameter_list|,
name|unsigned
name|TailOffset
parameter_list|,
name|Split
name|Split
parameter_list|,
name|bool
name|InPPDirective
parameter_list|,
name|WhitespaceManager
modifier|&
name|Whitespaces
parameter_list|)
block|{
name|unsigned
name|WhitespaceStartColumn
init|=
name|StartColumn
operator|+
name|Split
operator|.
name|first
operator|+
literal|2
decl_stmt|;
name|Whitespaces
operator|.
name|breakToken
argument_list|(
name|Tok
argument_list|,
literal|1
operator|+
name|TailOffset
operator|+
name|Split
operator|.
name|first
argument_list|,
name|Split
operator|.
name|second
argument_list|,
literal|"\""
argument_list|,
literal|"\""
argument_list|,
name|InPPDirective
argument_list|,
name|StartColumn
argument_list|,
name|WhitespaceStartColumn
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|StringRef
name|getLine
argument_list|()
specifier|const
block|{
comment|// Get string without quotes.
comment|// FIXME: Handle string prefixes.
return|return
name|TokenText
operator|.
name|substr
argument_list|(
literal|1
argument_list|,
name|TokenText
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
return|;
block|}
name|unsigned
name|getDecorationLength
argument_list|()
specifier|const
block|{
return|return
name|StartColumn
operator|+
literal|2
return|;
block|}
specifier|static
name|StringRef
operator|::
name|size_type
name|getStartOfCharacter
argument_list|(
argument|StringRef Text
argument_list|,
argument|StringRef::size_type Offset
argument_list|)
block|{
name|StringRef
operator|::
name|size_type
name|NextEscape
operator|=
name|Text
operator|.
name|find
argument_list|(
literal|'\\'
argument_list|)
block|;
while|while
condition|(
name|NextEscape
operator|!=
name|StringRef
operator|::
name|npos
operator|&&
name|NextEscape
operator|<
name|Offset
condition|)
block|{
name|StringRef
operator|::
name|size_type
name|SequenceLength
operator|=
name|getEscapeSequenceLength
argument_list|(
name|Text
operator|.
name|substr
argument_list|(
name|NextEscape
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Offset
operator|<
name|NextEscape
operator|+
name|SequenceLength
condition|)
return|return
name|NextEscape
return|;
name|NextEscape
operator|=
name|Text
operator|.
name|find
argument_list|(
literal|'\\'
argument_list|,
name|NextEscape
operator|+
name|SequenceLength
argument_list|)
expr_stmt|;
block|}
return|return
name|Offset
return|;
block|}
specifier|static
name|unsigned
name|getEscapeSequenceLength
parameter_list|(
name|StringRef
name|Text
parameter_list|)
block|{
name|assert
argument_list|(
name|Text
index|[
literal|0
index|]
operator|==
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|Text
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|Text
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'u'
case|:
return|return
literal|6
return|;
case|case
literal|'U'
case|:
return|return
literal|10
return|;
case|case
literal|'x'
case|:
return|return
name|getHexLength
argument_list|(
name|Text
argument_list|)
return|;
default|default:
if|if
condition|(
name|Text
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|Text
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
return|return
name|getOctalLength
argument_list|(
name|Text
argument_list|)
return|;
return|return
literal|2
return|;
block|}
block|}
specifier|static
name|unsigned
name|getHexLength
parameter_list|(
name|StringRef
name|Text
parameter_list|)
block|{
name|unsigned
name|I
init|=
literal|2
decl_stmt|;
comment|// Point after '\x'.
while|while
condition|(
name|I
operator|<
name|Text
operator|.
name|size
argument_list|()
operator|&&
operator|(
operator|(
name|Text
index|[
name|I
index|]
operator|>=
literal|'0'
operator|&&
name|Text
index|[
name|I
index|]
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|Text
index|[
name|I
index|]
operator|>=
literal|'a'
operator|&&
name|Text
index|[
name|I
index|]
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|Text
index|[
name|I
index|]
operator|>=
literal|'A'
operator|&&
name|Text
index|[
name|I
index|]
operator|<=
literal|'F'
operator|)
operator|)
condition|)
block|{
operator|++
name|I
expr_stmt|;
block|}
return|return
name|I
return|;
block|}
specifier|static
name|unsigned
name|getOctalLength
parameter_list|(
name|StringRef
name|Text
parameter_list|)
block|{
name|unsigned
name|I
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|I
operator|<
name|Text
operator|.
name|size
argument_list|()
operator|&&
name|I
operator|<
literal|4
operator|&&
operator|(
name|Text
index|[
name|I
index|]
operator|>=
literal|'0'
operator|&&
name|Text
index|[
name|I
index|]
operator|<=
literal|'7'
operator|)
condition|)
block|{
operator|++
name|I
expr_stmt|;
block|}
return|return
name|I
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|BreakableComment
range|:
name|public
name|BreakableToken
block|{
name|public
operator|:
name|virtual
name|unsigned
name|getLineSize
argument_list|(
argument|unsigned Index
argument_list|)
specifier|const
block|{
return|return
name|getLine
argument_list|(
name|Index
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
name|virtual
name|unsigned
name|getLineCount
argument_list|()
specifier|const
block|{
return|return
name|Lines
operator|.
name|size
argument_list|()
return|;
block|}
name|virtual
name|unsigned
name|getLineLengthAfterSplit
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|)
specifier|const
block|{
return|return
name|getContentStartColumn
argument_list|(
name|LineIndex
argument_list|,
name|TailOffset
argument_list|)
operator|+
name|getLine
argument_list|(
name|LineIndex
argument_list|)
operator|.
name|size
argument_list|()
operator|-
name|TailOffset
return|;
block|}
name|virtual
name|Split
name|getSplit
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|,
argument|unsigned ColumnLimit
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|insertBreak
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|,
argument|Split Split
argument_list|,
argument|bool InPPDirective
argument_list|,
argument|WhitespaceManager&Whitespaces
argument_list|)
block|;
name|protected
operator|:
name|BreakableComment
argument_list|(
argument|const SourceManager&SourceMgr
argument_list|,
argument|const FormatToken&Tok
argument_list|,
argument|unsigned StartColumn
argument_list|)
operator|:
name|BreakableToken
argument_list|(
argument|SourceMgr
argument_list|,
argument|Tok
argument_list|,
argument|StartColumn
argument_list|)
block|{}
comment|// Get comment lines without /* */, common prefix and trailing whitespace.
comment|// Last line is not trimmed, as it is terminated by */, so its trailing
comment|// whitespace is not really trailing.
name|StringRef
name|getLine
argument_list|(
argument|unsigned Index
argument_list|)
specifier|const
block|{
return|return
name|Index
operator|<
name|Lines
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|?
name|Lines
index|[
name|Index
index|]
operator|.
name|rtrim
argument_list|()
operator|:
name|Lines
index|[
name|Index
index|]
return|;
block|}
name|unsigned
name|getContentStartColumn
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|)
specifier|const
block|{
return|return
operator|(
name|TailOffset
operator|==
literal|0
operator|&&
name|LineIndex
operator|==
literal|0
operator|)
condition|?
name|StartColumn
else|:
name|IndentAtLineBreak
operator|+
name|Decoration
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|IndentAtLineBreak
block|;
name|StringRef
name|Decoration
block|;
name|SmallVector
operator|<
name|StringRef
block|,
literal|16
operator|>
name|Lines
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|BreakableBlockComment
range|:
name|public
name|BreakableComment
block|{
name|public
operator|:
name|BreakableBlockComment
argument_list|(
argument|const SourceManager&SourceMgr
argument_list|,
argument|const AnnotatedToken&Token
argument_list|,
argument|unsigned StartColumn
argument_list|)
block|;
name|void
name|alignLines
argument_list|(
name|WhitespaceManager
operator|&
name|Whitespaces
argument_list|)
block|;
name|virtual
name|unsigned
name|getLineLengthAfterSplit
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|)
specifier|const
block|{
return|return
name|BreakableComment
operator|::
name|getLineLengthAfterSplit
argument_list|(
name|LineIndex
argument_list|,
name|TailOffset
argument_list|)
operator|+
operator|(
name|LineIndex
operator|+
literal|1
operator|<
name|Lines
operator|.
name|size
argument_list|()
operator|?
literal|0
operator|:
literal|2
operator|)
return|;
block|}
name|virtual
name|void
name|trimLine
argument_list|(
argument|unsigned LineIndex
argument_list|,
argument|unsigned TailOffset
argument_list|,
argument|unsigned InPPDirective
argument_list|,
argument|WhitespaceManager&Whitespaces
argument_list|)
block|;
name|private
operator|:
name|unsigned
name|OriginalStartColumn
block|;
name|unsigned
name|CommonPrefixLength
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|BreakableLineComment
range|:
name|public
name|BreakableComment
block|{
name|public
operator|:
name|BreakableLineComment
argument_list|(
argument|const SourceManager&SourceMgr
argument_list|,
argument|const AnnotatedToken&Token
argument_list|,
argument|unsigned StartColumn
argument_list|)
block|;
name|private
operator|:
specifier|static
name|StringRef
name|getLineCommentPrefix
argument_list|(
argument|StringRef Comment
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// namespace format
end_comment

begin_comment
unit|}
comment|// namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_FORMAT_BREAKABLETOKEN_H
end_comment

end_unit

