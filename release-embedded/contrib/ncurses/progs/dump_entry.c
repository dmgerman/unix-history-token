begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996 on                 *  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|__INTERNAL_CAPS_VISIBLE
end_define

begin_include
include|#
directive|include
file|<progs.priv.h>
end_include

begin_include
include|#
directive|include
file|"dump_entry.h"
end_include

begin_include
include|#
directive|include
file|"termsort.c"
end_include

begin_comment
comment|/* this C file is generated */
end_comment

begin_include
include|#
directive|include
file|<parametrized.h>
end_include

begin_comment
comment|/* so is this */
end_comment

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: dump_entry.c,v 1.88 2008/08/04 12:36:12 tom Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|INDENT
value|8
end_define

begin_define
define|#
directive|define
name|DISCARD
parameter_list|(
name|string
parameter_list|)
value|string = ABSENT_STRING
end_define

begin_define
define|#
directive|define
name|PRINTF
value|(void) printf
end_define

begin_define
define|#
directive|define
name|OkIndex
parameter_list|(
name|index
parameter_list|,
name|array
parameter_list|)
value|((int)(index)>= 0&& (int)(index)< (int) SIZEOF(array))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|used
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|}
name|DYNBUF
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|tversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminfo version */
end_comment

begin_decl_stmt
specifier|static
name|int
name|outform
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output format to use */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sortmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sort mode to use */
end_comment

begin_decl_stmt
specifier|static
name|int
name|width
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max line width for listings */
end_comment

begin_decl_stmt
specifier|static
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current column, limited by 'width' */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldcol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last value of column before wrap */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|pretty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we format if-then-else strings */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_sgr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DYNBUF
name|outbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DYNBUF
name|tmpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indirection pointers for implementing sort and display modes */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|PredIdx
modifier|*
name|bool_indirect
decl_stmt|,
modifier|*
name|num_indirect
decl_stmt|,
modifier|*
name|str_indirect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CONST
name|char
modifier|*
specifier|const
modifier|*
name|bool_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CONST
name|char
modifier|*
specifier|const
modifier|*
name|num_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CONST
name|char
modifier|*
specifier|const
modifier|*
name|str_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|separator
decl_stmt|,
modifier|*
name|trailer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cover various ports and variants of terminfo */
end_comment

begin_define
define|#
directive|define
name|V_ALLCAPS
value|0
end_define

begin_comment
comment|/* all capabilities (SVr4, XSI, ncurses) */
end_comment

begin_define
define|#
directive|define
name|V_SVR1
value|1
end_define

begin_comment
comment|/* SVR1, Ultrix */
end_comment

begin_define
define|#
directive|define
name|V_HPUX
value|2
end_define

begin_comment
comment|/* HP/UX */
end_comment

begin_define
define|#
directive|define
name|V_AIX
value|3
end_define

begin_comment
comment|/* AIX */
end_comment

begin_define
define|#
directive|define
name|V_BSD
value|4
end_define

begin_comment
comment|/* BSD */
end_comment

begin_if
if|#
directive|if
name|NCURSES_XNAMES
end_if

begin_define
define|#
directive|define
name|OBSOLETE
parameter_list|(
name|n
parameter_list|)
value|(!_nc_user_definable&& (n[0] == 'O'&& n[1] == 'T'))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OBSOLETE
parameter_list|(
name|n
parameter_list|)
value|(n[0] == 'O'&& n[1] == 'T')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|isObsolete
parameter_list|(
name|f
parameter_list|,
name|n
parameter_list|)
value|((f == F_TERMINFO || f == F_VARIABLE)&& OBSOLETE(n))
end_define

begin_if
if|#
directive|if
name|NCURSES_XNAMES
end_if

begin_define
define|#
directive|define
name|BoolIndirect
parameter_list|(
name|j
parameter_list|)
value|((j>= BOOLCOUNT) ? (j) : ((sortmode == S_NOSORT) ? j : bool_indirect[j]))
end_define

begin_define
define|#
directive|define
name|NumIndirect
parameter_list|(
name|j
parameter_list|)
value|((j>= NUMCOUNT)  ? (j) : ((sortmode == S_NOSORT) ? j : num_indirect[j]))
end_define

begin_define
define|#
directive|define
name|StrIndirect
parameter_list|(
name|j
parameter_list|)
value|((j>= STRCOUNT)  ? (j) : ((sortmode == S_NOSORT) ? j : str_indirect[j]))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BoolIndirect
parameter_list|(
name|j
parameter_list|)
value|((sortmode == S_NOSORT) ? (j) : bool_indirect[j])
end_define

begin_define
define|#
directive|define
name|NumIndirect
parameter_list|(
name|j
parameter_list|)
value|((sortmode == S_NOSORT) ? (j) : num_indirect[j])
end_define

begin_define
define|#
directive|define
name|StrIndirect
parameter_list|(
name|j
parameter_list|)
value|((sortmode == S_NOSORT) ? (j) : str_indirect[j])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|strncpy_DYN
parameter_list|(
name|DYNBUF
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|need
parameter_list|)
block|{
name|size_t
name|want
init|=
name|need
operator|+
name|dst
operator|->
name|used
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|want
operator|>
name|dst
operator|->
name|size
condition|)
block|{
name|dst
operator|->
name|size
operator|+=
operator|(
name|want
operator|+
literal|1024
operator|)
expr_stmt|;
comment|/* be generous */
name|dst
operator|->
name|text
operator|=
name|typeRealloc
argument_list|(
name|char
argument_list|,
name|dst
operator|->
name|size
argument_list|,
name|dst
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dst
operator|->
name|text
operator|+
name|dst
operator|->
name|used
argument_list|,
name|src
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|dst
operator|->
name|used
operator|+=
name|need
expr_stmt|;
name|dst
operator|->
name|text
index|[
name|dst
operator|->
name|used
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strcpy_DYN
parameter_list|(
name|DYNBUF
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|==
literal|0
condition|)
block|{
name|dst
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|strcpy_DYN
argument_list|(
name|dst
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy_DYN
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|NO_LEAKS
end_if

begin_function
specifier|static
name|void
name|free_DYN
parameter_list|(
name|DYNBUF
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|text
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
name|p
operator|->
name|text
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_nc_leaks_dump_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|free_DYN
argument_list|(
operator|&
name|outbuf
argument_list|)
expr_stmt|;
name|free_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NameTrans
parameter_list|(
name|check
parameter_list|,
name|result
parameter_list|)
define|\
value|if (OkIndex(np->nte_index, check) \&& check[np->nte_index]) \ 		return (result[np->nte_index])
end_define

begin_function
name|NCURSES_CONST
name|char
modifier|*
name|nametrans
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
comment|/* translate a capability name from termcap to terminfo */
block|{
specifier|const
name|struct
name|name_table_entry
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|_nc_find_entry
argument_list|(
name|name
argument_list|,
name|_nc_get_hash_table
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|np
operator|->
name|nte_type
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|NameTrans
argument_list|(
name|bool_from_termcap
argument_list|,
name|boolcodes
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|NameTrans
argument_list|(
name|num_from_termcap
argument_list|,
name|numcodes
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|NameTrans
argument_list|(
name|str_from_termcap
argument_list|,
name|strcodes
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dump_init
parameter_list|(
specifier|const
name|char
modifier|*
name|version
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|sort
parameter_list|,
name|int
name|twidth
parameter_list|,
name|int
name|traceval
parameter_list|,
name|bool
name|formatted
parameter_list|)
comment|/* set up for entry display */
block|{
name|width
operator|=
name|twidth
expr_stmt|;
name|pretty
operator|=
name|formatted
expr_stmt|;
comment|/* versions */
if|if
condition|(
name|version
operator|==
literal|0
condition|)
name|tversion
operator|=
name|V_ALLCAPS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"SVr1"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"SVR1"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"Ultrix"
argument_list|)
condition|)
name|tversion
operator|=
name|V_SVR1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"HP"
argument_list|)
condition|)
name|tversion
operator|=
name|V_HPUX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"AIX"
argument_list|)
condition|)
name|tversion
operator|=
name|V_AIX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"BSD"
argument_list|)
condition|)
name|tversion
operator|=
name|V_BSD
expr_stmt|;
else|else
name|tversion
operator|=
name|V_ALLCAPS
expr_stmt|;
comment|/* implement display modes */
switch|switch
condition|(
name|outform
operator|=
name|mode
condition|)
block|{
case|case
name|F_LITERAL
case|:
case|case
name|F_TERMINFO
case|:
name|bool_names
operator|=
name|boolnames
expr_stmt|;
name|num_names
operator|=
name|numnames
expr_stmt|;
name|str_names
operator|=
name|strnames
expr_stmt|;
name|separator
operator|=
name|twidth
condition|?
literal|", "
else|:
literal|","
expr_stmt|;
name|trailer
operator|=
literal|"\n\t"
expr_stmt|;
break|break;
case|case
name|F_VARIABLE
case|:
name|bool_names
operator|=
name|boolfnames
expr_stmt|;
name|num_names
operator|=
name|numfnames
expr_stmt|;
name|str_names
operator|=
name|strfnames
expr_stmt|;
name|separator
operator|=
name|twidth
condition|?
literal|", "
else|:
literal|","
expr_stmt|;
name|trailer
operator|=
literal|"\n\t"
expr_stmt|;
break|break;
case|case
name|F_TERMCAP
case|:
case|case
name|F_TCONVERR
case|:
name|bool_names
operator|=
name|boolcodes
expr_stmt|;
name|num_names
operator|=
name|numcodes
expr_stmt|;
name|str_names
operator|=
name|strcodes
expr_stmt|;
name|separator
operator|=
literal|":"
expr_stmt|;
name|trailer
operator|=
literal|"\\\n\t:"
expr_stmt|;
break|break;
block|}
comment|/* implement sort modes */
switch|switch
condition|(
name|sortmode
operator|=
name|sort
condition|)
block|{
case|case
name|S_NOSORT
case|:
if|if
condition|(
name|traceval
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: sorting by term structure order\n"
argument_list|,
name|_nc_progname
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_TERMINFO
case|:
if|if
condition|(
name|traceval
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: sorting by terminfo name order\n"
argument_list|,
name|_nc_progname
argument_list|)
expr_stmt|;
name|bool_indirect
operator|=
name|bool_terminfo_sort
expr_stmt|;
name|num_indirect
operator|=
name|num_terminfo_sort
expr_stmt|;
name|str_indirect
operator|=
name|str_terminfo_sort
expr_stmt|;
break|break;
case|case
name|S_VARIABLE
case|:
if|if
condition|(
name|traceval
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: sorting by C variable order\n"
argument_list|,
name|_nc_progname
argument_list|)
expr_stmt|;
name|bool_indirect
operator|=
name|bool_variable_sort
expr_stmt|;
name|num_indirect
operator|=
name|num_variable_sort
expr_stmt|;
name|str_indirect
operator|=
name|str_variable_sort
expr_stmt|;
break|break;
case|case
name|S_TERMCAP
case|:
if|if
condition|(
name|traceval
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: sorting by termcap name order\n"
argument_list|,
name|_nc_progname
argument_list|)
expr_stmt|;
name|bool_indirect
operator|=
name|bool_termcap_sort
expr_stmt|;
name|num_indirect
operator|=
name|num_termcap_sort
expr_stmt|;
name|str_indirect
operator|=
name|str_termcap_sort
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|traceval
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: width = %d, tversion = %d, outform = %d\n"
argument_list|,
name|_nc_progname
argument_list|,
name|width
argument_list|,
name|tversion
argument_list|,
name|outform
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|TERMTYPE
modifier|*
name|cur_type
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dump_predicate
parameter_list|(
name|PredType
name|type
parameter_list|,
name|PredIdx
name|idx
parameter_list|)
comment|/* predicate function to use for ordinary decompilation */
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
operator|(
name|cur_type
operator|->
name|Booleans
index|[
name|idx
index|]
operator|==
name|FALSE
operator|)
condition|?
name|FAIL
else|:
name|cur_type
operator|->
name|Booleans
index|[
name|idx
index|]
return|;
case|case
name|NUMBER
case|:
return|return
operator|(
name|cur_type
operator|->
name|Numbers
index|[
name|idx
index|]
operator|==
name|ABSENT_NUMERIC
operator|)
condition|?
name|FAIL
else|:
name|cur_type
operator|->
name|Numbers
index|[
name|idx
index|]
return|;
case|case
name|STRING
case|:
return|return
operator|(
name|cur_type
operator|->
name|Strings
index|[
name|idx
index|]
operator|!=
name|ABSENT_STRING
operator|)
condition|?
operator|(
name|int
operator|)
name|TRUE
else|:
name|FAIL
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* pacify compiler */
block|}
end_function

begin_function_decl
specifier|static
name|void
name|set_obsolete_termcaps
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* is this the index of a function key string? */
end_comment

begin_define
define|#
directive|define
name|FNKEY
parameter_list|(
name|i
parameter_list|)
value|(((i)<= 65&& (i)>= 75) || ((i)<= 216&& (i)>= 268))
end_define

begin_comment
comment|/*  * If we configure with a different Caps file, the offsets into the arrays  * will change.  So we use an address expression.  */
end_comment

begin_define
define|#
directive|define
name|BOOL_IDX
parameter_list|(
name|name
parameter_list|)
value|(PredType) (&(name) -&(CUR Booleans[0]))
end_define

begin_define
define|#
directive|define
name|NUM_IDX
parameter_list|(
name|name
parameter_list|)
value|(PredType) (&(name) -&(CUR Numbers[0]))
end_define

begin_define
define|#
directive|define
name|STR_IDX
parameter_list|(
name|name
parameter_list|)
value|(PredType) (&(name) -&(CUR Strings[0]))
end_define

begin_function
specifier|static
name|bool
name|version_filter
parameter_list|(
name|PredType
name|type
parameter_list|,
name|PredIdx
name|idx
parameter_list|)
comment|/* filter out capabilities we may want to suppress */
block|{
switch|switch
condition|(
name|tversion
condition|)
block|{
case|case
name|V_ALLCAPS
case|:
comment|/* SVr4, XSI Curses */
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|V_SVR1
case|:
comment|/* System V Release 1, Ultrix */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
operator|(
operator|(
name|idx
operator|<=
name|BOOL_IDX
argument_list|(
name|xon_xoff
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
case|case
name|NUMBER
case|:
return|return
operator|(
operator|(
name|idx
operator|<=
name|NUM_IDX
argument_list|(
name|width_status_line
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
case|case
name|STRING
case|:
return|return
operator|(
operator|(
name|idx
operator|<=
name|STR_IDX
argument_list|(
name|prtr_non
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
break|break;
case|case
name|V_HPUX
case|:
comment|/* Hewlett-Packard */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
operator|(
operator|(
name|idx
operator|<=
name|BOOL_IDX
argument_list|(
name|xon_xoff
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
case|case
name|NUMBER
case|:
return|return
operator|(
operator|(
name|idx
operator|<=
name|NUM_IDX
argument_list|(
name|label_width
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
case|case
name|STRING
case|:
if|if
condition|(
name|idx
operator|<=
name|STR_IDX
argument_list|(
name|prtr_non
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
name|FNKEY
argument_list|(
name|idx
argument_list|)
condition|)
comment|/* function keys */
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|STR_IDX
argument_list|(
name|plab_norm
argument_list|)
operator|||
name|idx
operator|==
name|STR_IDX
argument_list|(
name|label_on
argument_list|)
operator|||
name|idx
operator|==
name|STR_IDX
argument_list|(
name|label_off
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
break|break;
case|case
name|V_AIX
case|:
comment|/* AIX */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
operator|(
operator|(
name|idx
operator|<=
name|BOOL_IDX
argument_list|(
name|xon_xoff
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
case|case
name|NUMBER
case|:
return|return
operator|(
operator|(
name|idx
operator|<=
name|NUM_IDX
argument_list|(
name|width_status_line
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
case|case
name|STRING
case|:
if|if
condition|(
name|idx
operator|<=
name|STR_IDX
argument_list|(
name|prtr_non
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
name|FNKEY
argument_list|(
name|idx
argument_list|)
condition|)
comment|/* function keys */
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
break|break;
define|#
directive|define
name|is_termcap
parameter_list|(
name|type
parameter_list|)
value|(OkIndex(idx, type##_from_termcap)&& \ 			  type##_from_termcap[idx])
case|case
name|V_BSD
case|:
comment|/* BSD */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
name|is_termcap
argument_list|(
name|bool
argument_list|)
return|;
case|case
name|NUMBER
case|:
return|return
name|is_termcap
argument_list|(
name|num
argument_list|)
return|;
case|case
name|STRING
case|:
return|return
name|is_termcap
argument_list|(
name|str
argument_list|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* pacify the compiler */
block|}
end_function

begin_function
specifier|static
name|void
name|trim_trailing
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|outbuf
operator|.
name|used
operator|>
literal|0
operator|&&
name|outbuf
operator|.
name|text
index|[
name|outbuf
operator|.
name|used
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|outbuf
operator|.
name|text
index|[
operator|--
name|outbuf
operator|.
name|used
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|force_wrap
parameter_list|(
name|void
parameter_list|)
block|{
name|oldcol
operator|=
name|column
expr_stmt|;
name|trim_trailing
argument_list|()
expr_stmt|;
name|strcpy_DYN
argument_list|(
operator|&
name|outbuf
argument_list|,
name|trailer
argument_list|)
expr_stmt|;
name|column
operator|=
name|INDENT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wrap_concat
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|unsigned
name|need
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|unsigned
name|want
init|=
name|strlen
argument_list|(
name|separator
argument_list|)
operator|+
name|need
decl_stmt|;
if|if
condition|(
name|column
operator|>
name|INDENT
operator|&&
name|column
operator|+
operator|(
name|int
operator|)
name|want
operator|>
name|width
condition|)
block|{
name|force_wrap
argument_list|()
expr_stmt|;
block|}
name|strcpy_DYN
argument_list|(
operator|&
name|outbuf
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|strcpy_DYN
argument_list|(
operator|&
name|outbuf
argument_list|,
name|separator
argument_list|)
expr_stmt|;
name|column
operator|+=
operator|(
name|int
operator|)
name|need
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IGNORE_SEP_TRAIL
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|,
name|sep_trail
parameter_list|)
define|\
value|if ((size_t)(last - first)> sizeof(sep_trail)-1 \&& !strncmp(first, sep_trail, sizeof(sep_trail)-1)) \ 		first += sizeof(sep_trail)-2
end_define

begin_comment
comment|/* Returns the nominal length of the buffer assuming it is termcap format,  * i.e., the continuation sequence is treated as a single character ":".  *  * There are several implementations of termcap which read the text into a  * fixed-size buffer.  Generally they strip the newlines from the text, but may  * not do it until after the buffer is read.  Also, "tc=" resolution may be  * expanded in the same buffer.  This function is useful for measuring the size  * of the best fixed-buffer implementation; the worst case may be much worse.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_TERMCAP_LENGTH
end_ifdef

begin_function
specifier|static
name|int
name|termcap_length
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|pattern
index|[]
init|=
literal|":\\\n\t:"
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|t
init|=
name|src
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\0'
condition|)
block|{
name|IGNORE_SEP_TRAIL
argument_list|(
name|src
argument_list|,
name|t
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|termcap_length
parameter_list|(
name|src
parameter_list|)
value|strlen(src)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|indent_DYN
parameter_list|(
name|DYNBUF
modifier|*
name|buffer
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|level
condition|;
name|n
operator|++
control|)
name|strncpy_DYN
argument_list|(
name|buffer
argument_list|,
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|has_params
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|int
name|len
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bool
name|ifthen
init|=
name|FALSE
decl_stmt|;
name|bool
name|params
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
operator|-
literal|1
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|src
operator|+
name|n
argument_list|,
literal|"%p"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|params
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|src
operator|+
name|n
argument_list|,
literal|"%;"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|ifthen
operator|=
name|TRUE
expr_stmt|;
name|result
operator|=
name|params
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ifthen
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|len
operator|>
literal|50
operator|)
operator|&&
name|params
operator|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fmt_complex
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|bool
name|percent
init|=
name|FALSE
decl_stmt|;
name|bool
name|params
init|=
name|has_params
argument_list|(
name|src
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'\\'
case|:
name|percent
operator|=
name|FALSE
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|src
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|percent
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* "if" */
case|case
literal|'t'
case|:
comment|/* "then" */
case|case
literal|'e'
case|:
comment|/* "else" */
if|if
condition|(
name|percent
condition|)
block|{
name|percent
operator|=
name|FALSE
expr_stmt|;
name|tmpbuf
operator|.
name|text
index|[
name|tmpbuf
operator|.
name|used
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* treat a "%e" as else-if, on the same level */
if|if
condition|(
operator|*
name|src
operator|==
literal|'e'
condition|)
block|{
name|indent_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"%"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|params
operator|=
name|has_params
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
operator|&&
operator|*
name|src
operator|!=
literal|'\0'
operator|&&
operator|*
name|src
operator|!=
literal|'%'
condition|)
block|{
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indent_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|indent_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"%"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|++
operator|==
literal|'?'
condition|)
block|{
name|src
operator|=
name|fmt_complex
argument_list|(
name|src
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|'\0'
operator|&&
operator|*
name|src
operator|!=
literal|'%'
condition|)
block|{
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indent_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|level
operator|==
literal|1
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"%%%c without %%?"
argument_list|,
operator|*
name|src
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
break|break;
case|case
literal|';'
case|:
comment|/* "endif" */
if|if
condition|(
name|percent
condition|)
block|{
name|percent
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|1
condition|)
block|{
name|tmpbuf
operator|.
name|text
index|[
name|tmpbuf
operator|.
name|used
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|indent_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"%"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|src
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
name|_nc_warning
argument_list|(
literal|"%%; without %%?"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|percent
operator|&&
name|params
condition|)
block|{
name|tmpbuf
operator|.
name|text
index|[
name|tmpbuf
operator|.
name|used
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|indent_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"%"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|params
operator|=
name|FALSE
expr_stmt|;
name|percent
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"\\s"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|++
name|src
expr_stmt|;
continue|continue;
default|default:
name|percent
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|strncpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|src
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SAME_CAP
parameter_list|(
name|n
parameter_list|,
name|cap
parameter_list|)
value|(&tterm->Strings[n] ==&cap)
end_define

begin_define
define|#
directive|define
name|EXTRA_CAP
value|20
end_define

begin_function
name|int
name|fmt_entry
parameter_list|(
name|TERMTYPE
modifier|*
name|tterm
parameter_list|,
name|PredFunc
name|pred
parameter_list|,
name|bool
name|content_only
parameter_list|,
name|bool
name|suppress_untranslatable
parameter_list|,
name|bool
name|infodump
parameter_list|,
name|int
name|numbers
parameter_list|)
block|{
name|PredIdx
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|buffer
index|[
name|MAX_TERMINFO_LENGTH
operator|+
name|EXTRA_CAP
index|]
decl_stmt|;
name|char
modifier|*
name|capability
decl_stmt|;
name|NCURSES_CONST
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|predval
decl_stmt|,
name|len
decl_stmt|;
name|PredIdx
name|num_bools
init|=
literal|0
decl_stmt|;
name|PredIdx
name|num_values
init|=
literal|0
decl_stmt|;
name|PredIdx
name|num_strings
init|=
literal|0
decl_stmt|;
name|bool
name|outcount
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|WRAP_CONCAT
define|\
value|wrap_concat(buffer); \ 	outcount = TRUE
name|len
operator|=
literal|12
expr_stmt|;
comment|/* terminfo file-header */
if|if
condition|(
name|pred
operator|==
literal|0
condition|)
block|{
name|cur_type
operator|=
name|tterm
expr_stmt|;
name|pred
operator|=
name|dump_predicate
expr_stmt|;
block|}
name|strcpy_DYN
argument_list|(
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_only
condition|)
block|{
name|column
operator|=
name|INDENT
expr_stmt|;
comment|/* FIXME: workaround to prevent empty lines */
block|}
else|else
block|{
name|strcpy_DYN
argument_list|(
operator|&
name|outbuf
argument_list|,
name|tterm
operator|->
name|term_names
argument_list|)
expr_stmt|;
name|strcpy_DYN
argument_list|(
operator|&
name|outbuf
argument_list|,
name|separator
argument_list|)
expr_stmt|;
name|column
operator|=
operator|(
name|int
operator|)
name|outbuf
operator|.
name|used
expr_stmt|;
name|force_wrap
argument_list|()
expr_stmt|;
block|}
name|for_each_boolean
argument_list|(
argument|j
argument_list|,
argument|tterm
argument_list|)
block|{
name|i
operator|=
name|BoolIndirect
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|name
operator|=
name|ExtBoolname
argument_list|(
name|tterm
argument_list|,
name|i
argument_list|,
name|bool_names
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
name|EXTRA_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|version_filter
argument_list|(
name|BOOLEAN
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isObsolete
argument_list|(
name|outform
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
name|predval
operator|=
name|pred
argument_list|(
name|BOOLEAN
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|predval
operator|!=
name|FAIL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|predval
operator|<=
literal|0
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|num_bools
condition|)
name|num_bools
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|column
operator|!=
name|INDENT
condition|)
name|force_wrap
argument_list|()
expr_stmt|;
name|for_each_number
argument_list|(
argument|j
argument_list|,
argument|tterm
argument_list|)
block|{
name|i
operator|=
name|NumIndirect
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|name
operator|=
name|ExtNumname
argument_list|(
name|tterm
argument_list|,
name|i
argument_list|,
name|num_names
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
name|EXTRA_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|version_filter
argument_list|(
name|NUMBER
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isObsolete
argument_list|(
name|outform
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
name|predval
operator|=
name|pred
argument_list|(
name|NUMBER
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|predval
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|tterm
operator|->
name|Numbers
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s@"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s#%d"
argument_list|,
name|name
argument_list|,
name|tterm
operator|->
name|Numbers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|num_values
condition|)
name|num_values
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|WRAP_CONCAT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|column
operator|!=
name|INDENT
condition|)
name|force_wrap
argument_list|()
expr_stmt|;
name|len
operator|+=
call|(
name|int
call|)
argument_list|(
name|num_bools
operator|+
name|num_values
operator|*
literal|2
operator|+
name|strlen
argument_list|(
name|tterm
operator|->
name|term_names
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|++
expr_stmt|;
undef|#
directive|undef
name|CUR
define|#
directive|define
name|CUR
value|tterm->
if|if
condition|(
name|outform
operator|==
name|F_TERMCAP
condition|)
block|{
if|if
condition|(
name|termcap_reset
operator|!=
name|ABSENT_STRING
condition|)
block|{
if|if
condition|(
name|init_3string
operator|!=
name|ABSENT_STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|init_3string
argument_list|,
name|termcap_reset
argument_list|)
condition|)
name|DISCARD
argument_list|(
name|init_3string
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_2string
operator|!=
name|ABSENT_STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|reset_2string
argument_list|,
name|termcap_reset
argument_list|)
condition|)
name|DISCARD
argument_list|(
name|reset_2string
argument_list|)
expr_stmt|;
block|}
block|}
name|for_each_string
argument_list|(
argument|j
argument_list|,
argument|tterm
argument_list|)
block|{
name|i
operator|=
name|StrIndirect
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|name
operator|=
name|ExtStrname
argument_list|(
name|tterm
argument_list|,
name|i
argument_list|,
name|str_names
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
name|EXTRA_CAP
argument_list|)
expr_stmt|;
name|capability
operator|=
name|tterm
operator|->
name|Strings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|version_filter
argument_list|(
name|STRING
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isObsolete
argument_list|(
name|outform
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
if|#
directive|if
name|NCURSES_XNAMES
comment|/* 	 * Extended names can be longer than 2 characters, but termcap programs 	 * cannot read those (filter them out). 	 */
if|if
condition|(
name|outform
operator|==
name|F_TERMCAP
operator|&&
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
literal|2
operator|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|outform
operator|==
name|F_TERMCAP
condition|)
block|{
comment|/* 	     * Some older versions of vi want rmir/smir to be defined 	     * for ich/ich1 to work.  If they're not defined, force 	     * them to be output as defined and empty. 	     */
if|if
condition|(
name|PRESENT
argument_list|(
name|insert_character
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|parm_ich
argument_list|)
condition|)
block|{
if|if
condition|(
name|SAME_CAP
argument_list|(
name|i
argument_list|,
name|enter_insert_mode
argument_list|)
operator|&&
name|enter_insert_mode
operator|==
name|ABSENT_STRING
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"im="
argument_list|)
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SAME_CAP
argument_list|(
name|i
argument_list|,
name|exit_insert_mode
argument_list|)
operator|&&
name|exit_insert_mode
operator|==
name|ABSENT_STRING
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"ei="
argument_list|)
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 	     * termcap applications such as screen will be confused if sgr0 	     * is translated to a string containing rmacs.  Filter that out. 	     */
if|if
condition|(
name|PRESENT
argument_list|(
name|exit_attribute_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|SAME_CAP
argument_list|(
name|i
argument_list|,
name|exit_attribute_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|trimmed_sgr0
decl_stmt|;
name|char
modifier|*
name|my_sgr
init|=
name|set_attributes
decl_stmt|;
name|set_attributes
operator|=
name|save_sgr
expr_stmt|;
name|trimmed_sgr0
operator|=
name|_nc_trim_sgr0
argument_list|(
name|tterm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|capability
argument_list|,
name|trimmed_sgr0
argument_list|)
condition|)
name|capability
operator|=
name|trimmed_sgr0
expr_stmt|;
name|set_attributes
operator|=
name|my_sgr
expr_stmt|;
block|}
block|}
block|}
name|predval
operator|=
name|pred
argument_list|(
name|STRING
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|predval
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|capability
operator|!=
name|ABSENT_STRING
operator|&&
name|i
operator|+
literal|1
operator|>
name|num_strings
condition|)
name|num_strings
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_STRING
argument_list|(
name|capability
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s@"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outform
operator|==
name|F_TERMCAP
operator|||
name|outform
operator|==
name|F_TCONVERR
condition|)
block|{
name|int
name|params
init|=
operator|(
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|SIZEOF
argument_list|(
name|parametrized
argument_list|)
operator|)
condition|?
name|parametrized
index|[
name|i
index|]
else|:
literal|0
operator|)
decl_stmt|;
name|char
modifier|*
name|srccap
init|=
name|_nc_tic_expand
argument_list|(
name|capability
argument_list|,
name|TRUE
argument_list|,
name|numbers
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cv
init|=
name|_nc_infotocap
argument_list|(
name|name
argument_list|,
name|srccap
argument_list|,
name|params
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|outform
operator|==
name|F_TCONVERR
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s=!!! %s WILL NOT CONVERT !!!"
argument_list|,
name|name
argument_list|,
name|srccap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suppress_untranslatable
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|char
modifier|*
name|s
init|=
name|srccap
decl_stmt|,
modifier|*
name|d
init|=
name|buffer
decl_stmt|;
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"..%s="
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|d
operator|+=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|d
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|':'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|=
literal|':'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'\\'
condition|)
block|{
operator|*
operator|++
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s=%s"
argument_list|,
name|name
argument_list|,
name|cv
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|capability
argument_list|)
operator|+
literal|1
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|src
init|=
name|_nc_tic_expand
argument_list|(
name|capability
argument_list|,
name|outform
operator|==
name|F_TERMINFO
argument_list|,
name|numbers
argument_list|)
decl_stmt|;
name|strcpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
operator|&&
operator|(
name|outform
operator|==
name|F_TERMINFO
operator|||
name|outform
operator|==
name|F_VARIABLE
operator|)
condition|)
block|{
name|fmt_complex
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy_DYN
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|capability
argument_list|)
operator|+
literal|1
expr_stmt|;
name|wrap_concat
argument_list|(
name|tmpbuf
operator|.
name|text
argument_list|)
expr_stmt|;
name|outcount
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* e.g., trimmed_sgr0 */
if|if
condition|(
name|capability
operator|!=
name|tterm
operator|->
name|Strings
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|capability
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
call|(
name|int
call|)
argument_list|(
name|num_strings
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/*      * This piece of code should be an effective inverse of the functions      * postprocess_terminfo() and postprocess_terminfo() in parse_entry.c.      * Much more work should be done on this to support dumping termcaps.      */
if|if
condition|(
name|tversion
operator|==
name|V_HPUX
condition|)
block|{
if|if
condition|(
name|VALID_STRING
argument_list|(
name|memory_lock
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"meml=%s"
argument_list|,
name|memory_lock
argument_list|)
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
block|}
if|if
condition|(
name|VALID_STRING
argument_list|(
name|memory_unlock
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"memu=%s"
argument_list|,
name|memory_unlock
argument_list|)
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tversion
operator|==
name|V_AIX
condition|)
block|{
if|if
condition|(
name|VALID_STRING
argument_list|(
name|acs_chars
argument_list|)
condition|)
block|{
name|bool
name|box_ok
init|=
name|TRUE
decl_stmt|;
specifier|const
name|char
modifier|*
name|acstrans
init|=
literal|"lqkxjmwuvtn"
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
name|boxchars
index|[
literal|11
index|]
decl_stmt|;
name|tp
operator|=
name|boxchars
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|acstrans
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|sp
operator|=
name|strchr
argument_list|(
name|acs_chars
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
operator|*
name|tp
operator|++
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
else|else
block|{
name|box_ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
name|tp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|box_ok
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"box1="
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buffer
argument_list|,
name|_nc_tic_expand
argument_list|(
name|boxchars
argument_list|,
name|outform
operator|==
name|F_TERMINFO
argument_list|,
name|numbers
argument_list|)
argument_list|)
expr_stmt|;
name|WRAP_CONCAT
expr_stmt|;
block|}
block|}
block|}
comment|/*      * kludge: trim off trailer to avoid an extra blank line      * in infocmp -u output when there are no string differences      */
if|if
condition|(
name|outcount
condition|)
block|{
name|bool
name|trimmed
init|=
name|FALSE
decl_stmt|;
name|j
operator|=
name|outbuf
operator|.
name|used
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|2
operator|&&
name|outbuf
operator|.
name|text
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|&&
name|outbuf
operator|.
name|text
index|[
name|j
operator|-
literal|2
index|]
operator|==
literal|'\n'
condition|)
block|{
name|outbuf
operator|.
name|used
operator|-=
literal|2
expr_stmt|;
name|trimmed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>=
literal|4
operator|&&
name|outbuf
operator|.
name|text
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
name|outbuf
operator|.
name|text
index|[
name|j
operator|-
literal|2
index|]
operator|==
literal|'\t'
operator|&&
name|outbuf
operator|.
name|text
index|[
name|j
operator|-
literal|3
index|]
operator|==
literal|'\n'
operator|&&
name|outbuf
operator|.
name|text
index|[
name|j
operator|-
literal|4
index|]
operator|==
literal|'\\'
condition|)
block|{
name|outbuf
operator|.
name|used
operator|-=
literal|4
expr_stmt|;
name|trimmed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|trimmed
condition|)
block|{
name|outbuf
operator|.
name|text
index|[
name|outbuf
operator|.
name|used
index|]
operator|=
literal|'\0'
expr_stmt|;
name|column
operator|=
name|oldcol
expr_stmt|;
name|strcpy_DYN
argument_list|(
operator|&
name|outbuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|fprintf(stderr, "num_bools = %d\n", num_bools);     fprintf(stderr, "num_values = %d\n", num_values);     fprintf(stderr, "num_strings = %d\n", num_strings);     fprintf(stderr, "term_names=%s, len=%d, strlen(outbuf)=%d, outbuf=%s\n", 	    tterm->term_names, len, outbuf.used, outbuf.text);
endif|#
directive|endif
comment|/*      * Here's where we use infodump to trigger a more stringent length check      * for termcap-translation purposes.      * Return the length of the raw entry, without tc= expansions,      * It gives an idea of which entries are deadly to even *scan past*,      * as opposed to *use*.      */
return|return
operator|(
name|infodump
operator|?
name|len
operator|:
operator|(
name|int
operator|)
name|termcap_length
argument_list|(
name|outbuf
operator|.
name|text
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|kill_string
parameter_list|(
name|TERMTYPE
modifier|*
name|tterm
parameter_list|,
name|char
modifier|*
name|cap
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NUM_STRINGS
argument_list|(
name|tterm
argument_list|)
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|cap
operator|==
name|tterm
operator|->
name|Strings
index|[
name|n
index|]
condition|)
block|{
name|tterm
operator|->
name|Strings
index|[
name|n
index|]
operator|=
name|ABSENT_STRING
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|find_string
parameter_list|(
name|TERMTYPE
modifier|*
name|tterm
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|PredIdx
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NUM_STRINGS
argument_list|(
name|tterm
argument_list|)
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|version_filter
argument_list|(
name|STRING
argument_list|,
name|n
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|strnames
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|cap
init|=
name|tterm
operator|->
name|Strings
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|cap
argument_list|)
condition|)
block|{
return|return
name|cap
return|;
block|}
break|break;
block|}
block|}
return|return
name|ABSENT_STRING
return|;
block|}
end_function

begin_comment
comment|/*  * This is used to remove function-key labels from a termcap entry to  * make it smaller.  */
end_comment

begin_function
specifier|static
name|int
name|kill_labels
parameter_list|(
name|TERMTYPE
modifier|*
name|tterm
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cap
decl_stmt|;
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
literal|10
condition|;
operator|++
name|n
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"lf%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cap
operator|=
name|find_string
argument_list|(
name|tterm
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|ABSENT_STRING
operator|&&
name|kill_string
argument_list|(
name|tterm
argument_list|,
name|cap
argument_list|)
condition|)
block|{
name|target
operator|-=
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|cap
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|++
name|result
expr_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * This is used to remove function-key definitions from a termcap entry to  * make it smaller.  */
end_comment

begin_function
specifier|static
name|int
name|kill_fkeys
parameter_list|(
name|TERMTYPE
modifier|*
name|tterm
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cap
decl_stmt|;
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|60
init|;
name|n
operator|>=
literal|0
condition|;
operator|--
name|n
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"kf%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cap
operator|=
name|find_string
argument_list|(
name|tterm
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|ABSENT_STRING
operator|&&
name|kill_string
argument_list|(
name|tterm
argument_list|,
name|cap
argument_list|)
condition|)
block|{
name|target
operator|-=
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|cap
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|++
name|result
expr_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given acsc string is a 1-1 mapping, i.e., just-like-vt100.  * Also, since this is for termcap, we only care about the line-drawing map.  */
end_comment

begin_define
define|#
directive|define
name|isLine
parameter_list|(
name|c
parameter_list|)
value|(strchr("lmkjtuvwqxn", c) != 0)
end_define

begin_function
specifier|static
name|bool
name|one_one_mapping
parameter_list|(
specifier|const
name|char
modifier|*
name|mapping
parameter_list|)
block|{
name|bool
name|result
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|mapping
operator|!=
name|ABSENT_STRING
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|mapping
index|[
name|n
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isLine
argument_list|(
name|mapping
index|[
name|n
index|]
argument_list|)
operator|&&
name|mapping
index|[
name|n
index|]
operator|!=
name|mapping
index|[
name|n
operator|+
literal|1
index|]
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|n
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FMT_ENTRY
parameter_list|()
define|\
value|fmt_entry(tterm, pred, \ 			0, \ 			suppress_untranslatable, \ 			infodump, numbers)
end_define

begin_define
define|#
directive|define
name|SHOW_WHY
value|PRINTF
end_define

begin_function
specifier|static
name|bool
name|purged_acs
parameter_list|(
name|TERMTYPE
modifier|*
name|tterm
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|acs_chars
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|one_one_mapping
argument_list|(
name|acs_chars
argument_list|)
condition|)
block|{
name|enter_alt_charset_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|exit_alt_charset_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|SHOW_WHY
argument_list|(
literal|"# (rmacs/smacs removed for consistency)\n"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Dump a single entry.  */
end_comment

begin_function
name|void
name|dump_entry
parameter_list|(
name|TERMTYPE
modifier|*
name|tterm
parameter_list|,
name|bool
name|suppress_untranslatable
parameter_list|,
name|bool
name|limited
parameter_list|,
name|int
name|numbers
parameter_list|,
name|PredFunc
name|pred
parameter_list|)
block|{
name|TERMTYPE
name|save_tterm
decl_stmt|;
name|int
name|len
decl_stmt|,
name|critlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|legend
decl_stmt|;
name|bool
name|infodump
decl_stmt|;
if|if
condition|(
name|outform
operator|==
name|F_TERMCAP
operator|||
name|outform
operator|==
name|F_TCONVERR
condition|)
block|{
name|critlen
operator|=
name|MAX_TERMCAP_LENGTH
expr_stmt|;
name|legend
operator|=
literal|"older termcap"
expr_stmt|;
name|infodump
operator|=
name|FALSE
expr_stmt|;
name|set_obsolete_termcaps
argument_list|(
name|tterm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|critlen
operator|=
name|MAX_TERMINFO_LENGTH
expr_stmt|;
name|legend
operator|=
literal|"terminfo"
expr_stmt|;
name|infodump
operator|=
name|TRUE
expr_stmt|;
block|}
name|save_sgr
operator|=
name|set_attributes
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|len
operator|=
name|FMT_ENTRY
argument_list|()
operator|)
operator|>
name|critlen
operator|)
operator|&&
name|limited
condition|)
block|{
name|save_tterm
operator|=
operator|*
name|tterm
expr_stmt|;
if|if
condition|(
operator|!
name|suppress_untranslatable
condition|)
block|{
name|SHOW_WHY
argument_list|(
literal|"# (untranslatable capabilities removed to fit entry within %d bytes)\n"
argument_list|,
name|critlen
argument_list|)
expr_stmt|;
name|suppress_untranslatable
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|FMT_ENTRY
argument_list|()
operator|)
operator|>
name|critlen
condition|)
block|{
comment|/* 	     * We pick on sgr because it's a nice long string capability that 	     * is really just an optimization hack.  Another good candidate is 	     * acsc since it is both long and unused by BSD termcap. 	     */
name|bool
name|changed
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|NCURSES_XNAMES
comment|/* 	     * Extended names are most likely function-key definitions.  Drop 	     * those first. 	     */
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|STRCOUNT
init|;
name|n
operator|<
name|NUM_STRINGS
argument_list|(
name|tterm
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ExtStrname
argument_list|(
name|tterm
argument_list|,
name|n
argument_list|,
name|strnames
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|tterm
operator|->
name|Strings
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|set_attributes
operator|=
name|ABSENT_STRING
expr_stmt|;
comment|/* we remove long names anyway - only report the short */
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<=
literal|2
condition|)
block|{
name|SHOW_WHY
argument_list|(
literal|"# (%s removed to fit entry within %d bytes)\n"
argument_list|,
name|name
argument_list|,
name|critlen
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|FMT_ENTRY
argument_list|()
operator|)
operator|<=
name|critlen
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|VALID_STRING
argument_list|(
name|set_attributes
argument_list|)
condition|)
block|{
name|set_attributes
operator|=
name|ABSENT_STRING
expr_stmt|;
name|SHOW_WHY
argument_list|(
literal|"# (sgr removed to fit entry within %d bytes)\n"
argument_list|,
name|critlen
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|changed
operator|||
operator|(
operator|(
name|len
operator|=
name|FMT_ENTRY
argument_list|()
operator|)
operator|>
name|critlen
operator|)
condition|)
block|{
if|if
condition|(
name|purged_acs
argument_list|(
name|tterm
argument_list|)
condition|)
block|{
name|acs_chars
operator|=
name|ABSENT_STRING
expr_stmt|;
name|SHOW_WHY
argument_list|(
literal|"# (acsc removed to fit entry within %d bytes)\n"
argument_list|,
name|critlen
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|changed
operator|||
operator|(
operator|(
name|len
operator|=
name|FMT_ENTRY
argument_list|()
operator|)
operator|>
name|critlen
operator|)
condition|)
block|{
name|int
name|oldversion
init|=
name|tversion
decl_stmt|;
name|tversion
operator|=
name|V_BSD
expr_stmt|;
name|SHOW_WHY
argument_list|(
literal|"# (terminfo-only capabilities suppressed to fit entry within %d bytes)\n"
argument_list|,
name|critlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|FMT_ENTRY
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|critlen
operator|&&
name|kill_labels
argument_list|(
name|tterm
argument_list|,
name|len
operator|-
name|critlen
argument_list|)
condition|)
block|{
name|SHOW_WHY
argument_list|(
literal|"# (some labels capabilities suppressed to fit entry within %d bytes)\n"
argument_list|,
name|critlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|FMT_ENTRY
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|critlen
operator|&&
name|kill_fkeys
argument_list|(
name|tterm
argument_list|,
name|len
operator|-
name|critlen
argument_list|)
condition|)
block|{
name|SHOW_WHY
argument_list|(
literal|"# (some function-key capabilities suppressed to fit entry within %d bytes)\n"
argument_list|,
name|critlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|FMT_ENTRY
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|critlen
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: %s entry is %d bytes long\n"
argument_list|,
name|_nc_first_name
argument_list|(
name|tterm
operator|->
name|term_names
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SHOW_WHY
argument_list|(
literal|"# WARNING: this entry, %d bytes long, may core-dump %s libraries!\n"
argument_list|,
name|len
argument_list|,
name|legend
argument_list|)
expr_stmt|;
block|}
name|tversion
operator|=
name|oldversion
expr_stmt|;
block|}
name|set_attributes
operator|=
name|save_sgr
expr_stmt|;
operator|*
name|tterm
operator|=
name|save_tterm
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|version_filter
argument_list|(
name|STRING
argument_list|,
name|STR_IDX
argument_list|(
name|acs_chars
argument_list|)
argument_list|)
condition|)
block|{
name|save_tterm
operator|=
operator|*
name|tterm
expr_stmt|;
if|if
condition|(
name|purged_acs
argument_list|(
name|tterm
argument_list|)
condition|)
block|{
name|len
operator|=
name|FMT_ENTRY
argument_list|()
expr_stmt|;
block|}
operator|*
name|tterm
operator|=
name|save_tterm
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_uses
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|infodump
parameter_list|)
comment|/* dump "use=" clauses in the appropriate format */
block|{
name|char
name|buffer
index|[
name|MAX_TERMINFO_LENGTH
index|]
decl_stmt|;
if|if
condition|(
name|outform
operator|==
name|F_TERMCAP
operator|||
name|outform
operator|==
name|F_TCONVERR
condition|)
name|trim_trailing
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s"
argument_list|,
name|infodump
condition|?
literal|"use="
else|:
literal|"tc="
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_concat
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|show_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|trim_trailing
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|outbuf
operator|.
name|text
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|outbuf
operator|.
name|used
return|;
block|}
end_function

begin_function
name|void
name|compare_entry
parameter_list|(
name|void
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|PredType
name|t
parameter_list|,
name|PredIdx
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
parameter_list|,
name|TERMTYPE
modifier|*
name|tp
name|GCC_UNUSED
parameter_list|,
name|bool
name|quiet
parameter_list|)
comment|/* compare two entries */
block|{
name|PredIdx
name|i
decl_stmt|,
name|j
decl_stmt|;
name|NCURSES_CONST
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fputs
argument_list|(
literal|"    comparing booleans.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|for_each_boolean
argument_list|(
argument|j
argument_list|,
argument|tp
argument_list|)
block|{
name|i
operator|=
name|BoolIndirect
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|name
operator|=
name|ExtBoolname
argument_list|(
name|tp
argument_list|,
name|i
argument_list|,
name|bool_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObsolete
argument_list|(
name|outform
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
call|(
modifier|*
name|hook
call|)
argument_list|(
name|CMP_BOOLEAN
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fputs
argument_list|(
literal|"    comparing numbers.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|for_each_number
argument_list|(
argument|j
argument_list|,
argument|tp
argument_list|)
block|{
name|i
operator|=
name|NumIndirect
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|name
operator|=
name|ExtNumname
argument_list|(
name|tp
argument_list|,
name|i
argument_list|,
name|num_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObsolete
argument_list|(
name|outform
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
call|(
modifier|*
name|hook
call|)
argument_list|(
name|CMP_NUMBER
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fputs
argument_list|(
literal|"    comparing strings.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|for_each_string
argument_list|(
argument|j
argument_list|,
argument|tp
argument_list|)
block|{
name|i
operator|=
name|StrIndirect
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|name
operator|=
name|ExtStrname
argument_list|(
name|tp
argument_list|,
name|i
argument_list|,
name|str_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObsolete
argument_list|(
name|outform
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
call|(
modifier|*
name|hook
call|)
argument_list|(
name|CMP_STRING
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* (void) fputs("    comparing use entries.\n", stdout); */
call|(
modifier|*
name|hook
call|)
argument_list|(
name|CMP_USE
argument_list|,
literal|0
argument_list|,
literal|"use"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NOTSET
parameter_list|(
name|s
parameter_list|)
value|((s) == 0)
end_define

begin_comment
comment|/*  * This bit of legerdemain turns all the terminfo variable names into  * references to locations in the arrays Booleans, Numbers, and Strings ---  * precisely what's needed.  */
end_comment

begin_undef
undef|#
directive|undef
name|CUR
end_undef

begin_define
define|#
directive|define
name|CUR
value|tp->
end_define

begin_function
specifier|static
name|void
name|set_obsolete_termcaps
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
include|#
directive|include
file|"capdefaults.c"
block|}
end_function

begin_comment
comment|/*  * Convert an alternate-character-set string to canonical form: sorted and  * unique.  */
end_comment

begin_function
name|void
name|repair_acsc
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|VALID_STRING
argument_list|(
name|acs_chars
argument_list|)
condition|)
block|{
name|size_t
name|n
decl_stmt|,
name|m
decl_stmt|;
name|char
name|mapped
index|[
literal|256
index|]
decl_stmt|;
name|char
name|extra
init|=
literal|0
decl_stmt|;
name|unsigned
name|source
decl_stmt|;
name|unsigned
name|target
decl_stmt|;
name|bool
name|fix_needed
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|source
operator|=
literal|0
init|;
name|acs_chars
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
name|target
operator|=
name|UChar
argument_list|(
name|acs_chars
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|>=
name|target
condition|)
block|{
name|fix_needed
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|source
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|acs_chars
index|[
name|n
operator|+
literal|1
index|]
condition|)
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fix_needed
condition|)
block|{
name|memset
argument_list|(
name|mapped
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mapped
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|acs_chars
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
name|source
operator|=
name|UChar
argument_list|(
name|acs_chars
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|=
operator|(
name|unsigned
name|char
operator|)
name|acs_chars
index|[
name|n
operator|+
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|mapped
index|[
name|source
index|]
operator|=
operator|(
name|char
operator|)
name|target
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
else|else
block|{
name|extra
operator|=
operator|(
name|char
operator|)
name|source
expr_stmt|;
block|}
block|}
for|for
control|(
name|n
operator|=
name|m
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|mapped
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|mapped
index|[
name|n
index|]
condition|)
block|{
name|acs_chars
index|[
name|m
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|n
expr_stmt|;
name|acs_chars
index|[
name|m
operator|++
index|]
operator|=
name|mapped
index|[
name|n
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|extra
condition|)
name|acs_chars
index|[
name|m
operator|++
index|]
operator|=
name|extra
expr_stmt|;
comment|/* garbage in, garbage out */
name|acs_chars
index|[
name|m
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

