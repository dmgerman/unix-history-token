begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Debug-mode error formatting implementation -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/** @file debug/formatter.h  *  This file is a GNU debug extension to the Standard C++ Library.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GLIBCXX_DEBUG_FORMATTER_H
end_ifndef

begin_define
define|#
directive|define
name|_GLIBCXX_DEBUG_FORMATTER_H
value|1
end_define

begin_include
include|#
directive|include
file|<typeinfo>
end_include

begin_include
include|#
directive|include
file|<debug/debug.h>
end_include

begin_decl_stmt
name|namespace
name|__gnu_debug
block|{
name|using
name|std
operator|::
name|type_info
expr_stmt|;
comment|/** Determine if the two types are the same. */
name|template
operator|<
name|typename
name|_Type1
operator|,
name|typename
name|_Type2
operator|>
expr|struct
name|__is_same
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|;     }
expr_stmt|;
name|template
operator|<
name|typename
name|_Type
operator|>
expr|struct
name|__is_same
operator|<
name|_Type
operator|,
name|_Type
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|;     }
expr_stmt|;
name|template
operator|<
name|bool
operator|>
expr|struct
name|__truth
block|{ }
expr_stmt|;
name|class
name|_Safe_sequence_base
decl_stmt|;
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Sequence
operator|>
name|class
name|_Safe_iterator
expr_stmt|;
name|template
operator|<
name|typename
name|_Sequence
operator|>
name|class
name|_Safe_sequence
expr_stmt|;
enum|enum
name|_Debug_msg_id
block|{
comment|// General checks
name|__msg_valid_range
block|,
name|__msg_insert_singular
block|,
name|__msg_insert_different
block|,
name|__msg_erase_bad
block|,
name|__msg_erase_different
block|,
name|__msg_subscript_oob
block|,
name|__msg_empty
block|,
name|__msg_unpartitioned
block|,
name|__msg_unpartitioned_pred
block|,
name|__msg_unsorted
block|,
name|__msg_unsorted_pred
block|,
name|__msg_not_heap
block|,
name|__msg_not_heap_pred
block|,
comment|// std::bitset checks
name|__msg_bad_bitset_write
block|,
name|__msg_bad_bitset_read
block|,
name|__msg_bad_bitset_flip
block|,
comment|// std::list checks
name|__msg_self_splice
block|,
name|__msg_splice_alloc
block|,
name|__msg_splice_bad
block|,
name|__msg_splice_other
block|,
name|__msg_splice_overlap
block|,
comment|// iterator checks
name|__msg_init_singular
block|,
name|__msg_init_copy_singular
block|,
name|__msg_init_const_singular
block|,
name|__msg_copy_singular
block|,
name|__msg_bad_deref
block|,
name|__msg_bad_inc
block|,
name|__msg_bad_dec
block|,
name|__msg_iter_subscript_oob
block|,
name|__msg_advance_oob
block|,
name|__msg_retreat_oob
block|,
name|__msg_iter_compare_bad
block|,
name|__msg_compare_different
block|,
name|__msg_iter_order_bad
block|,
name|__msg_order_different
block|,
name|__msg_distance_bad
block|,
name|__msg_distance_different
block|,
comment|// istream_iterator
name|__msg_deref_istream
block|,
name|__msg_inc_istream
block|,
comment|// ostream_iterator
name|__msg_output_ostream
block|,
comment|// istreambuf_iterator
name|__msg_deref_istreambuf
block|,
name|__msg_inc_istreambuf
block|}
enum|;
name|class
name|_Error_formatter
block|{
comment|/// Whether an iterator is constant, mutable, or unknown
enum|enum
name|_Constness
block|{
name|__unknown_constness
block|,
name|__const_iterator
block|,
name|__mutable_iterator
block|,
name|__last_constness
block|}
enum|;
comment|// The state of the iterator (fine-grained), if we know it.
enum|enum
name|_Iterator_state
block|{
name|__unknown_state
block|,
name|__singular
block|,
comment|// singular, may still be attached to a sequence
name|__begin
block|,
comment|// dereferenceable, and at the beginning
name|__middle
block|,
comment|// dereferenceable, not at the beginning
name|__end
block|,
comment|// past-the-end, may be at beginning if sequence empty
name|__last_state
block|}
enum|;
comment|// Tags denoting the type of parameter for construction
struct|struct
name|_Is_iterator
block|{ }
struct|;
struct|struct
name|_Is_sequence
block|{ }
struct|;
comment|// A parameter that may be referenced by an error message
struct|struct
name|_Parameter
block|{
enum|enum
block|{
name|__unused_param
block|,
name|__iterator
block|,
name|__sequence
block|,
name|__integer
block|,
name|__string
block|}
name|_M_kind
enum|;
union|union
block|{
comment|// When _M_kind == __iterator
struct|struct
block|{
specifier|const
name|char
modifier|*
name|_M_name
decl_stmt|;
specifier|const
name|void
modifier|*
name|_M_address
decl_stmt|;
specifier|const
name|type_info
modifier|*
name|_M_type
decl_stmt|;
name|_Constness
name|_M_constness
decl_stmt|;
name|_Iterator_state
name|_M_state
decl_stmt|;
specifier|const
name|void
modifier|*
name|_M_sequence
decl_stmt|;
specifier|const
name|type_info
modifier|*
name|_M_seq_type
decl_stmt|;
block|}
name|_M_iterator
struct|;
comment|// When _M_kind == __sequence
struct|struct
block|{
specifier|const
name|char
modifier|*
name|_M_name
decl_stmt|;
specifier|const
name|void
modifier|*
name|_M_address
decl_stmt|;
specifier|const
name|type_info
modifier|*
name|_M_type
decl_stmt|;
block|}
name|_M_sequence
struct|;
comment|// When _M_kind == __integer
struct|struct
block|{
specifier|const
name|char
modifier|*
name|_M_name
decl_stmt|;
name|long
name|_M_value
decl_stmt|;
block|}
name|_M_integer
struct|;
comment|// When _M_kind == __string
struct|struct
block|{
specifier|const
name|char
modifier|*
name|_M_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|_M_value
decl_stmt|;
block|}
name|_M_string
struct|;
block|}
name|_M_variant
union|;
name|_Parameter
argument_list|()
operator|:
name|_M_kind
argument_list|(
name|__unused_param
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{ }
name|_Parameter
argument_list|(
argument|long __value
argument_list|,
argument|const char* __name
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__integer
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_integer
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_integer
operator|.
name|_M_value
operator|=
name|__value
block|;       }
name|_Parameter
argument_list|(
specifier|const
name|char
operator|*
name|__value
argument_list|,
specifier|const
name|char
operator|*
name|__name
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__string
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_string
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_string
operator|.
name|_M_value
operator|=
name|__value
block|;       }
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Sequence
operator|>
name|_Parameter
argument_list|(
specifier|const
name|_Safe_iterator
operator|<
name|_Iterator
argument_list|,
name|_Sequence
operator|>
operator|&
name|__it
argument_list|,
specifier|const
name|char
operator|*
name|__name
argument_list|,
name|_Is_iterator
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__iterator
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_address
operator|=
operator|&
name|__it
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_type
operator|=
operator|&
name|typeid
argument_list|(
name|__it
argument_list|)
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_constness
operator|=
name|__is_same
operator|<
name|_Safe_iterator
operator|<
name|_Iterator
block|,
name|_Sequence
operator|>
block|,
name|typename
name|_Sequence
operator|::
name|iterator
operator|>
operator|::
name|value
condition|?
name|__mutable_iterator
else|:
name|__const_iterator
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_sequence
operator|=
name|__it
operator|.
name|_M_get_sequence
argument_list|()
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_seq_type
operator|=
operator|&
name|typeid
argument_list|(
name|_Sequence
argument_list|)
block|;
if|if
condition|(
name|__it
operator|.
name|_M_singular
argument_list|()
condition|)
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_state
operator|=
name|__singular
expr_stmt|;
else|else
block|{
name|bool
name|__is_begin
init|=
name|__it
operator|.
name|_M_is_begin
argument_list|()
decl_stmt|;
name|bool
name|__is_end
init|=
name|__it
operator|.
name|_M_is_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|__is_end
condition|)
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_state
operator|=
name|__end
expr_stmt|;
elseif|else
if|if
condition|(
name|__is_begin
condition|)
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_state
operator|=
name|__begin
expr_stmt|;
else|else
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_state
operator|=
name|__middle
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|_Type
operator|>
name|_Parameter
argument_list|(
specifier|const
name|_Type
operator|*
operator|&
name|__it
argument_list|,
specifier|const
name|char
operator|*
name|__name
argument_list|,
name|_Is_iterator
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__iterator
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_address
operator|=
operator|&
name|__it
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_type
operator|=
operator|&
name|typeid
argument_list|(
name|__it
argument_list|)
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_constness
operator|=
name|__mutable_iterator
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_state
operator|=
name|__it
condition|?
name|__unknown_state
else|:
name|__singular
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_sequence
operator|=
literal|0
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_seq_type
operator|=
literal|0
block|; 	}
name|template
operator|<
name|typename
name|_Type
operator|>
name|_Parameter
argument_list|(
name|_Type
operator|*
operator|&
name|__it
argument_list|,
specifier|const
name|char
operator|*
name|__name
argument_list|,
name|_Is_iterator
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__iterator
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_address
operator|=
operator|&
name|__it
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_type
operator|=
operator|&
name|typeid
argument_list|(
name|__it
argument_list|)
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_constness
operator|=
name|__const_iterator
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_state
operator|=
name|__it
condition|?
name|__unknown_state
else|:
name|__singular
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_sequence
operator|=
literal|0
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_seq_type
operator|=
literal|0
block|; 	}
name|template
operator|<
name|typename
name|_Iterator
operator|>
name|_Parameter
argument_list|(
specifier|const
name|_Iterator
operator|&
name|__it
argument_list|,
specifier|const
name|char
operator|*
name|__name
argument_list|,
name|_Is_iterator
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__iterator
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_address
operator|=
operator|&
name|__it
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_type
operator|=
operator|&
name|typeid
argument_list|(
name|__it
argument_list|)
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_constness
operator|=
name|__unknown_constness
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_state
operator|=
name|__gnu_debug
operator|::
name|__check_singular
argument_list|(
name|__it
argument_list|)
condition|?
name|__singular
else|:
name|__unknown_state
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_sequence
operator|=
literal|0
block|;
name|_M_variant
operator|.
name|_M_iterator
operator|.
name|_M_seq_type
operator|=
literal|0
block|; 	}
name|template
operator|<
name|typename
name|_Sequence
operator|>
name|_Parameter
argument_list|(
specifier|const
name|_Safe_sequence
operator|<
name|_Sequence
operator|>
operator|&
name|__seq
argument_list|,
specifier|const
name|char
operator|*
name|__name
argument_list|,
name|_Is_sequence
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__sequence
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_sequence
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_sequence
operator|.
name|_M_address
operator|=
name|static_cast
operator|<
specifier|const
name|_Sequence
operator|*
operator|>
operator|(
operator|&
name|__seq
operator|)
block|;
name|_M_variant
operator|.
name|_M_sequence
operator|.
name|_M_type
operator|=
operator|&
name|typeid
argument_list|(
name|_Sequence
argument_list|)
block|; 	}
name|template
operator|<
name|typename
name|_Sequence
operator|>
name|_Parameter
argument_list|(
specifier|const
name|_Sequence
operator|&
name|__seq
argument_list|,
specifier|const
name|char
operator|*
name|__name
argument_list|,
name|_Is_sequence
argument_list|)
operator|:
name|_M_kind
argument_list|(
name|__sequence
argument_list|)
operator|,
name|_M_variant
argument_list|()
block|{
name|_M_variant
operator|.
name|_M_sequence
operator|.
name|_M_name
operator|=
name|__name
block|;
name|_M_variant
operator|.
name|_M_sequence
operator|.
name|_M_address
operator|=
operator|&
name|__seq
block|;
name|_M_variant
operator|.
name|_M_sequence
operator|.
name|_M_type
operator|=
operator|&
name|typeid
argument_list|(
name|_Sequence
argument_list|)
block|; 	}
name|void
name|_M_print_field
argument_list|(
argument|const _Error_formatter* __formatter
argument_list|,
argument|const char* __name
argument_list|)
specifier|const
expr_stmt|;
name|void
name|_M_print_description
argument_list|(
specifier|const
name|_Error_formatter
operator|*
name|__formatter
argument_list|)
decl|const
decl_stmt|;
block|}
struct|;
name|friend
struct_decl|struct
name|_Parameter
struct_decl|;
name|public
label|:
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|const
name|_Error_formatter
operator|&
name|_M_iterator
argument_list|(
argument|const _Iterator& __it
argument_list|,
argument|const char* __name =
literal|0
argument_list|)
specifier|const
block|{
if|if
condition|(
name|_M_num_parameters
operator|<
name|size_t
argument_list|(
name|__max_parameters
argument_list|)
condition|)
name|_M_parameters
index|[
name|_M_num_parameters
operator|++
index|]
operator|=
name|_Parameter
argument_list|(
name|__it
argument_list|,
name|__name
argument_list|,
name|_Is_iterator
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|_Error_formatter
modifier|&
name|_M_integer
argument_list|(
name|long
name|__value
argument_list|,
specifier|const
name|char
operator|*
name|__name
operator|=
literal|0
argument_list|)
decl|const
block|{
if|if
condition|(
name|_M_num_parameters
operator|<
name|size_t
argument_list|(
name|__max_parameters
argument_list|)
condition|)
name|_M_parameters
index|[
name|_M_num_parameters
operator|++
index|]
operator|=
name|_Parameter
argument_list|(
name|__value
argument_list|,
name|__name
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|_Error_formatter
modifier|&
name|_M_string
argument_list|(
specifier|const
name|char
operator|*
name|__value
argument_list|,
specifier|const
name|char
operator|*
name|__name
operator|=
literal|0
argument_list|)
decl|const
block|{
if|if
condition|(
name|_M_num_parameters
operator|<
name|size_t
argument_list|(
name|__max_parameters
argument_list|)
condition|)
name|_M_parameters
index|[
name|_M_num_parameters
operator|++
index|]
operator|=
name|_Parameter
argument_list|(
name|__value
argument_list|,
name|__name
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|template
operator|<
name|typename
name|_Sequence
operator|>
specifier|const
name|_Error_formatter
operator|&
name|_M_sequence
argument_list|(
argument|const _Sequence& __seq
argument_list|,
argument|const char* __name =
literal|0
argument_list|)
specifier|const
block|{
if|if
condition|(
name|_M_num_parameters
operator|<
name|size_t
argument_list|(
name|__max_parameters
argument_list|)
condition|)
name|_M_parameters
index|[
name|_M_num_parameters
operator|++
index|]
operator|=
name|_Parameter
argument_list|(
name|__seq
argument_list|,
name|__name
argument_list|,
name|_Is_sequence
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|_Error_formatter
modifier|&
name|_M_message
argument_list|(
specifier|const
name|char
operator|*
name|__text
argument_list|)
decl|const
block|{
name|_M_text
operator|=
name|__text
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|_Error_formatter
modifier|&
name|_M_message
argument_list|(
name|_Debug_msg_id
name|__id
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|void
name|_M_error
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_macro
name|_Error_formatter
argument_list|(
argument|const char* __file
argument_list|,
argument|size_t __line
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|_M_file
argument_list|(
name|__file
argument_list|)
operator|,
name|_M_line
argument_list|(
name|__line
argument_list|)
operator|,
name|_M_num_parameters
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_text
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_max_length
argument_list|(
literal|78
argument_list|)
operator|,
name|_M_column
argument_list|(
literal|1
argument_list|)
operator|,
name|_M_first_line
argument_list|(
name|true
argument_list|)
operator|,
name|_M_wordwrap
argument_list|(
argument|false
argument_list|)
block|{ }
name|template
operator|<
name|typename
name|_Tp
operator|>
name|void
name|_M_format_word
argument_list|(
argument|char*
argument_list|,
argument|int
argument_list|,
argument|const char*
argument_list|,
argument|_Tp
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|_M_print_word
argument_list|(
specifier|const
name|char
operator|*
name|__word
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_M_print_string
argument_list|(
specifier|const
name|char
operator|*
name|__string
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|__max_parameters
init|=
literal|9
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_M_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|_M_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
name|_Parameter
name|_M_parameters
index|[
name|__max_parameters
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
name|size_t
name|_M_num_parameters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
specifier|const
name|char
modifier|*
name|_M_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
name|size_t
name|_M_max_length
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|_M_indent
init|=
literal|4
block|}
enum|;
end_enum

begin_decl_stmt
name|mutable
name|size_t
name|_M_column
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
name|bool
name|_M_first_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
name|bool
name|_M_wordwrap
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_function
specifier|static
name|_Error_formatter
name|_M_at
parameter_list|(
specifier|const
name|char
modifier|*
name|__file
parameter_list|,
name|size_t
name|__line
parameter_list|)
block|{
return|return
name|_Error_formatter
argument_list|(
name|__file
argument_list|,
name|__line
argument_list|)
return|;
block|}
end_function

begin_comment
unit|}; }
comment|// namespace __gnu_debug
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

