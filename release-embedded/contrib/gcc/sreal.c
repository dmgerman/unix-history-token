begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simple data type for positive real numbers for the GNU compiler.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This library supports positive real numbers and 0;    inf and nan are NOT supported.    It is written to be simple and fast.     Value of sreal is 	x = sig * 2 ^ exp    where 	sig = significant 	  (for< 64-bit machines sig = sig_lo + sig_hi * 2 ^ SREAL_PART_BITS) 	exp = exponent     One HOST_WIDE_INT is used for the significant on 64-bit (and more than    64-bit) machines,    otherwise two HOST_WIDE_INTs are used for the significant.    Only a half of significant bits is used (in normalized sreals) so that we do    not have problems with overflow, for example when c->sig = a->sig * b->sig.    So the precision for 64-bit and 32-bit machines is 32-bit.     Invariant: The numbers are normalized before and after each call of sreal_*.     Normalized sreals:    All numbers (except zero) meet following conditions: 	 SREAL_MIN_SIG<= sig&& sig<= SREAL_MAX_SIG 	-SREAL_MAX_EXP<= exp&& exp<= SREAL_MAX_EXP     If the number would be too large, it is set to upper bounds of these    conditions.     If the number is zero or would be too small it meets following conditions: 	sig == 0&& exp == -SREAL_MAX_EXP */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"sreal.h"
end_include

begin_function_decl
specifier|static
specifier|inline
name|void
name|copy
parameter_list|(
name|sreal
modifier|*
parameter_list|,
name|sreal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|shift_right
parameter_list|(
name|sreal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|normalize
parameter_list|(
name|sreal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the content of struct sreal.  */
end_comment

begin_function
name|void
name|dump_sreal
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|sreal
modifier|*
name|x
parameter_list|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(("
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|" * 2^16 + "
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|") * 2^%d)"
argument_list|,
name|x
operator|->
name|sig_hi
argument_list|,
name|x
operator|->
name|sig_lo
argument_list|,
name|x
operator|->
name|exp
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"("
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|" * 2^%d)"
argument_list|,
name|x
operator|->
name|sig
argument_list|,
name|x
operator|->
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy the sreal number.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|copy
parameter_list|(
name|sreal
modifier|*
name|r
parameter_list|,
name|sreal
modifier|*
name|a
parameter_list|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|r
operator|->
name|sig_lo
operator|=
name|a
operator|->
name|sig_lo
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|=
name|a
operator|->
name|sig_hi
expr_stmt|;
else|#
directive|else
name|r
operator|->
name|sig
operator|=
name|a
operator|->
name|sig
expr_stmt|;
endif|#
directive|endif
name|r
operator|->
name|exp
operator|=
name|a
operator|->
name|exp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift X right by S bits.  Needed: 0< S<= SREAL_BITS.    When the most significant bit shifted out is 1, add 1 to X (rounding).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|shift_right
parameter_list|(
name|sreal
modifier|*
name|x
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|s
operator|>
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|s
operator|<=
name|SREAL_BITS
argument_list|)
expr_stmt|;
comment|/* Exponent should never be so large because shift_right is used only by      sreal_add and sreal_sub ant thus the number cannot be shifted out from      exponent range.  */
name|gcc_assert
argument_list|(
name|x
operator|->
name|exp
operator|+
name|s
operator|<=
name|SREAL_MAX_EXP
argument_list|)
expr_stmt|;
name|x
operator|->
name|exp
operator|+=
name|s
expr_stmt|;
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
if|if
condition|(
name|s
operator|>
name|SREAL_PART_BITS
condition|)
block|{
name|s
operator|-=
name|SREAL_PART_BITS
expr_stmt|;
name|x
operator|->
name|sig_hi
operator|+=
operator|(
name|uhwi
operator|)
literal|1
operator|<<
operator|(
name|s
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|=
name|x
operator|->
name|sig_hi
operator|>>
name|s
expr_stmt|;
name|x
operator|->
name|sig_hi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x
operator|->
name|sig_lo
operator|+=
operator|(
name|uhwi
operator|)
literal|1
operator|<<
operator|(
name|s
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sig_lo
operator|&
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
condition|)
block|{
name|x
operator|->
name|sig_hi
operator|++
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|-=
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
expr_stmt|;
block|}
name|x
operator|->
name|sig_lo
operator|>>=
name|s
expr_stmt|;
name|x
operator|->
name|sig_lo
operator||=
operator|(
name|x
operator|->
name|sig_hi
operator|&
operator|(
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|s
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|SREAL_PART_BITS
operator|-
name|s
operator|)
expr_stmt|;
name|x
operator|->
name|sig_hi
operator|>>=
name|s
expr_stmt|;
block|}
else|#
directive|else
name|x
operator|->
name|sig
operator|+=
operator|(
name|uhwi
operator|)
literal|1
operator|<<
operator|(
name|s
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|->
name|sig
operator|>>=
name|s
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Normalize *X.  */
end_comment

begin_function
specifier|static
name|void
name|normalize
parameter_list|(
name|sreal
modifier|*
name|x
parameter_list|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|int
name|shift
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|sig_lo
operator|==
literal|0
operator|&&
name|x
operator|->
name|sig_hi
operator|==
literal|0
condition|)
block|{
name|x
operator|->
name|exp
operator|=
operator|-
name|SREAL_MAX_EXP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|sig_hi
operator|<
name|SREAL_MIN_SIG
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|sig_hi
operator|==
literal|0
condition|)
block|{
comment|/* Move lower part of significant to higher part.  */
name|x
operator|->
name|sig_hi
operator|=
name|x
operator|->
name|sig_lo
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|exp
operator|-=
name|SREAL_PART_BITS
expr_stmt|;
block|}
name|shift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|x
operator|->
name|sig_hi
operator|<
name|SREAL_MIN_SIG
condition|)
block|{
name|x
operator|->
name|sig_hi
operator|<<=
literal|1
expr_stmt|;
name|x
operator|->
name|exp
operator|--
expr_stmt|;
name|shift
operator|++
expr_stmt|;
block|}
comment|/* Check underflow.  */
if|if
condition|(
name|x
operator|->
name|exp
operator|<
operator|-
name|SREAL_MAX_EXP
condition|)
block|{
name|x
operator|->
name|exp
operator|=
operator|-
name|SREAL_MAX_EXP
expr_stmt|;
name|x
operator|->
name|sig_hi
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
condition|)
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SREAL_PART_BITS
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
name|x
operator|->
name|sig_hi
operator||=
operator|(
name|x
operator|->
name|sig_lo
operator|&
name|mask
operator|)
operator|>>
operator|(
name|SREAL_PART_BITS
operator|-
name|shift
operator|)
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|=
operator|(
name|x
operator|->
name|sig_lo
operator|<<
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|sig_hi
operator|>
name|SREAL_MAX_SIG
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|tmp
init|=
name|x
operator|->
name|sig_hi
decl_stmt|;
comment|/* Find out how many bits will be shifted.  */
name|shift
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|tmp
operator|>>=
literal|1
expr_stmt|;
name|shift
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|>
name|SREAL_MAX_SIG
condition|)
do|;
comment|/* Round the number.  */
name|x
operator|->
name|sig_lo
operator|+=
operator|(
name|uhwi
operator|)
literal|1
operator|<<
operator|(
name|shift
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|>>=
name|shift
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|+=
operator|(
operator|(
name|x
operator|->
name|sig_hi
operator|&
operator|(
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|SREAL_PART_BITS
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
name|x
operator|->
name|sig_hi
operator|>>=
name|shift
expr_stmt|;
name|x
operator|->
name|exp
operator|+=
name|shift
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sig_lo
operator|&
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
condition|)
block|{
name|x
operator|->
name|sig_lo
operator|-=
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
expr_stmt|;
name|x
operator|->
name|sig_hi
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sig_hi
operator|>
name|SREAL_MAX_SIG
condition|)
block|{
comment|/* x->sig_hi was SREAL_MAX_SIG before increment 		 so now last bit is zero.  */
name|x
operator|->
name|sig_hi
operator|>>=
literal|1
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|>>=
literal|1
expr_stmt|;
name|x
operator|->
name|exp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Check overflow.  */
if|if
condition|(
name|x
operator|->
name|exp
operator|>
name|SREAL_MAX_EXP
condition|)
block|{
name|x
operator|->
name|exp
operator|=
name|SREAL_MAX_EXP
expr_stmt|;
name|x
operator|->
name|sig_hi
operator|=
name|SREAL_MAX_SIG
expr_stmt|;
name|x
operator|->
name|sig_lo
operator|=
name|SREAL_MAX_SIG
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|x
operator|->
name|sig
operator|==
literal|0
condition|)
block|{
name|x
operator|->
name|exp
operator|=
operator|-
name|SREAL_MAX_EXP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|sig
operator|<
name|SREAL_MIN_SIG
condition|)
block|{
do|do
block|{
name|x
operator|->
name|sig
operator|<<=
literal|1
expr_stmt|;
name|x
operator|->
name|exp
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|->
name|sig
operator|<
name|SREAL_MIN_SIG
condition|)
do|;
comment|/* Check underflow.  */
if|if
condition|(
name|x
operator|->
name|exp
operator|<
operator|-
name|SREAL_MAX_EXP
condition|)
block|{
name|x
operator|->
name|exp
operator|=
operator|-
name|SREAL_MAX_EXP
expr_stmt|;
name|x
operator|->
name|sig
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|sig
operator|>
name|SREAL_MAX_SIG
condition|)
block|{
name|int
name|last_bit
decl_stmt|;
do|do
block|{
name|last_bit
operator|=
name|x
operator|->
name|sig
operator|&
literal|1
expr_stmt|;
name|x
operator|->
name|sig
operator|>>=
literal|1
expr_stmt|;
name|x
operator|->
name|exp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|->
name|sig
operator|>
name|SREAL_MAX_SIG
condition|)
do|;
comment|/* Round the number.  */
name|x
operator|->
name|sig
operator|+=
name|last_bit
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sig
operator|>
name|SREAL_MAX_SIG
condition|)
block|{
name|x
operator|->
name|sig
operator|>>=
literal|1
expr_stmt|;
name|x
operator|->
name|exp
operator|++
expr_stmt|;
block|}
comment|/* Check overflow.  */
if|if
condition|(
name|x
operator|->
name|exp
operator|>
name|SREAL_MAX_EXP
condition|)
block|{
name|x
operator|->
name|exp
operator|=
name|SREAL_MAX_EXP
expr_stmt|;
name|x
operator|->
name|sig
operator|=
name|SREAL_MAX_SIG
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set *R to SIG * 2 ^ EXP.  Return R.  */
end_comment

begin_function
name|sreal
modifier|*
name|sreal_init
parameter_list|(
name|sreal
modifier|*
name|r
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|sig
parameter_list|,
name|signed
name|int
name|exp
parameter_list|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|r
operator|->
name|sig_lo
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|=
name|sig
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|16
expr_stmt|;
else|#
directive|else
name|r
operator|->
name|sig
operator|=
name|sig
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
endif|#
directive|endif
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return integer value of *R.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|sreal_to_int
parameter_list|(
name|sreal
modifier|*
name|r
parameter_list|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
if|if
condition|(
name|r
operator|->
name|exp
operator|<=
operator|-
name|SREAL_BITS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|->
name|exp
operator|>=
literal|0
condition|)
return|return
name|MAX_HOST_WIDE_INT
return|;
return|return
operator|(
operator|(
name|r
operator|->
name|sig_hi
operator|<<
name|SREAL_PART_BITS
operator|)
operator|+
name|r
operator|->
name|sig_lo
operator|)
operator|>>
operator|-
name|r
operator|->
name|exp
return|;
else|#
directive|else
if|if
condition|(
name|r
operator|->
name|exp
operator|<=
operator|-
name|SREAL_BITS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|->
name|exp
operator|>=
name|SREAL_PART_BITS
condition|)
return|return
name|MAX_HOST_WIDE_INT
return|;
if|if
condition|(
name|r
operator|->
name|exp
operator|>
literal|0
condition|)
return|return
name|r
operator|->
name|sig
operator|<<
name|r
operator|->
name|exp
return|;
if|if
condition|(
name|r
operator|->
name|exp
operator|<
literal|0
condition|)
return|return
name|r
operator|->
name|sig
operator|>>
operator|-
name|r
operator|->
name|exp
return|;
return|return
name|r
operator|->
name|sig
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Compare *A and *B. Return -1 if *A< *B, 1 if *A> *B and 0 if *A == *B.  */
end_comment

begin_function
name|int
name|sreal_compare
parameter_list|(
name|sreal
modifier|*
name|a
parameter_list|,
name|sreal
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|exp
operator|>
name|b
operator|->
name|exp
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|exp
operator|<
name|b
operator|->
name|exp
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
if|if
condition|(
name|a
operator|->
name|sig_hi
operator|>
name|b
operator|->
name|sig_hi
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|sig_hi
operator|<
name|b
operator|->
name|sig_hi
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|sig_lo
operator|>
name|b
operator|->
name|sig_lo
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|sig_lo
operator|<
name|b
operator|->
name|sig_lo
condition|)
return|return
operator|-
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|a
operator|->
name|sig
operator|>
name|b
operator|->
name|sig
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|sig
operator|<
name|b
operator|->
name|sig
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* *R = *A + *B.  Return R.  */
end_comment

begin_function
name|sreal
modifier|*
name|sreal_add
parameter_list|(
name|sreal
modifier|*
name|r
parameter_list|,
name|sreal
modifier|*
name|a
parameter_list|,
name|sreal
modifier|*
name|b
parameter_list|)
block|{
name|int
name|dexp
decl_stmt|;
name|sreal
name|tmp
decl_stmt|;
name|sreal
modifier|*
name|bb
decl_stmt|;
if|if
condition|(
name|sreal_compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sreal
modifier|*
name|swap
decl_stmt|;
name|swap
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|swap
expr_stmt|;
block|}
name|dexp
operator|=
name|a
operator|->
name|exp
operator|-
name|b
operator|->
name|exp
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|a
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|dexp
operator|>
name|SREAL_BITS
condition|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|r
operator|->
name|sig_hi
operator|=
name|a
operator|->
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
name|a
operator|->
name|sig_lo
expr_stmt|;
else|#
directive|else
name|r
operator|->
name|sig
operator|=
name|a
operator|->
name|sig
expr_stmt|;
endif|#
directive|endif
return|return
name|r
return|;
block|}
if|if
condition|(
name|dexp
operator|==
literal|0
condition|)
name|bb
operator|=
name|b
expr_stmt|;
else|else
block|{
name|copy
argument_list|(
operator|&
name|tmp
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|shift_right
argument_list|(
operator|&
name|tmp
argument_list|,
name|dexp
argument_list|)
expr_stmt|;
name|bb
operator|=
operator|&
name|tmp
expr_stmt|;
block|}
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|r
operator|->
name|sig_hi
operator|=
name|a
operator|->
name|sig_hi
operator|+
name|bb
operator|->
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
name|a
operator|->
name|sig_lo
operator|+
name|bb
operator|->
name|sig_lo
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sig_lo
operator|&
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
condition|)
block|{
name|r
operator|->
name|sig_hi
operator|++
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|-=
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
expr_stmt|;
block|}
else|#
directive|else
name|r
operator|->
name|sig
operator|=
name|a
operator|->
name|sig
operator|+
name|bb
operator|->
name|sig
expr_stmt|;
endif|#
directive|endif
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* *R = *A - *B.  Return R.  */
end_comment

begin_function
name|sreal
modifier|*
name|sreal_sub
parameter_list|(
name|sreal
modifier|*
name|r
parameter_list|,
name|sreal
modifier|*
name|a
parameter_list|,
name|sreal
modifier|*
name|b
parameter_list|)
block|{
name|int
name|dexp
decl_stmt|;
name|sreal
name|tmp
decl_stmt|;
name|sreal
modifier|*
name|bb
decl_stmt|;
name|gcc_assert
argument_list|(
name|sreal_compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|dexp
operator|=
name|a
operator|->
name|exp
operator|-
name|b
operator|->
name|exp
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|a
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|dexp
operator|>
name|SREAL_BITS
condition|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|r
operator|->
name|sig_hi
operator|=
name|a
operator|->
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
name|a
operator|->
name|sig_lo
expr_stmt|;
else|#
directive|else
name|r
operator|->
name|sig
operator|=
name|a
operator|->
name|sig
expr_stmt|;
endif|#
directive|endif
return|return
name|r
return|;
block|}
if|if
condition|(
name|dexp
operator|==
literal|0
condition|)
name|bb
operator|=
name|b
expr_stmt|;
else|else
block|{
name|copy
argument_list|(
operator|&
name|tmp
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|shift_right
argument_list|(
operator|&
name|tmp
argument_list|,
name|dexp
argument_list|)
expr_stmt|;
name|bb
operator|=
operator|&
name|tmp
expr_stmt|;
block|}
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
if|if
condition|(
name|a
operator|->
name|sig_lo
operator|<
name|bb
operator|->
name|sig_lo
condition|)
block|{
name|r
operator|->
name|sig_hi
operator|=
name|a
operator|->
name|sig_hi
operator|-
name|bb
operator|->
name|sig_hi
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
name|a
operator|->
name|sig_lo
operator|+
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
operator|-
name|bb
operator|->
name|sig_lo
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|sig_hi
operator|=
name|a
operator|->
name|sig_hi
operator|-
name|bb
operator|->
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
name|a
operator|->
name|sig_lo
operator|-
name|bb
operator|->
name|sig_lo
expr_stmt|;
block|}
else|#
directive|else
name|r
operator|->
name|sig
operator|=
name|a
operator|->
name|sig
operator|-
name|bb
operator|->
name|sig
expr_stmt|;
endif|#
directive|endif
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* *R = *A * *B.  Return R.  */
end_comment

begin_function
name|sreal
modifier|*
name|sreal_mul
parameter_list|(
name|sreal
modifier|*
name|r
parameter_list|,
name|sreal
modifier|*
name|a
parameter_list|,
name|sreal
modifier|*
name|b
parameter_list|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
if|if
condition|(
name|a
operator|->
name|sig_hi
operator|<
name|SREAL_MIN_SIG
operator|||
name|b
operator|->
name|sig_hi
operator|<
name|SREAL_MIN_SIG
condition|)
block|{
name|r
operator|->
name|sig_lo
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|-
name|SREAL_MAX_EXP
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
if|if
condition|(
name|sreal_compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sreal
modifier|*
name|swap
decl_stmt|;
name|swap
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|swap
expr_stmt|;
block|}
name|r
operator|->
name|exp
operator|=
name|a
operator|->
name|exp
operator|+
name|b
operator|->
name|exp
operator|+
name|SREAL_PART_BITS
expr_stmt|;
name|tmp1
operator|=
name|a
operator|->
name|sig_lo
operator|*
name|b
operator|->
name|sig_lo
expr_stmt|;
name|tmp2
operator|=
name|a
operator|->
name|sig_lo
operator|*
name|b
operator|->
name|sig_hi
expr_stmt|;
name|tmp3
operator|=
name|a
operator|->
name|sig_hi
operator|*
name|b
operator|->
name|sig_lo
operator|+
operator|(
name|tmp1
operator|>>
name|SREAL_PART_BITS
operator|)
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|=
name|a
operator|->
name|sig_hi
operator|*
name|b
operator|->
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|+=
operator|(
name|tmp2
operator|>>
name|SREAL_PART_BITS
operator|)
operator|+
operator|(
name|tmp3
operator|>>
name|SREAL_PART_BITS
operator|)
expr_stmt|;
name|tmp2
operator|&=
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
operator|-
literal|1
expr_stmt|;
name|tmp3
operator|&=
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
operator|-
literal|1
expr_stmt|;
name|tmp1
operator|=
name|tmp2
operator|+
name|tmp3
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
name|tmp1
operator|&
operator|(
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
name|SREAL_PART_BITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|+=
name|tmp1
operator|>>
name|SREAL_PART_BITS
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|a
operator|->
name|sig
operator|<
name|SREAL_MIN_SIG
operator|||
name|b
operator|->
name|sig
operator|<
name|SREAL_MIN_SIG
condition|)
block|{
name|r
operator|->
name|sig
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|-
name|SREAL_MAX_EXP
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|sig
operator|=
name|a
operator|->
name|sig
operator|*
name|b
operator|->
name|sig
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|a
operator|->
name|exp
operator|+
name|b
operator|->
name|exp
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* *R = *A / *B.  Return R.  */
end_comment

begin_function
name|sreal
modifier|*
name|sreal_div
parameter_list|(
name|sreal
modifier|*
name|r
parameter_list|,
name|sreal
modifier|*
name|a
parameter_list|,
name|sreal
modifier|*
name|b
parameter_list|)
block|{
if|#
directive|if
name|SREAL_PART_BITS
operator|<
literal|32
name|unsigned
name|HOST_WIDE_INT
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|gcc_assert
argument_list|(
name|b
operator|->
name|sig_hi
operator|>=
name|SREAL_MIN_SIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|sig_hi
operator|<
name|SREAL_MIN_SIG
condition|)
block|{
name|r
operator|->
name|sig_hi
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|-
name|SREAL_MAX_EXP
expr_stmt|;
block|}
else|else
block|{
comment|/* Since division by the whole number is pretty ugly to write 	 we are dividing by first 3/4 of bits of number.  */
name|tmp1
operator|=
operator|(
name|a
operator|->
name|sig_hi
operator|<<
name|SREAL_PART_BITS
operator|)
operator|+
name|a
operator|->
name|sig_lo
expr_stmt|;
name|tmp2
operator|=
operator|(
operator|(
name|b
operator|->
name|sig_hi
operator|<<
operator|(
name|SREAL_PART_BITS
operator|/
literal|2
operator|)
operator|)
operator|+
operator|(
name|b
operator|->
name|sig_lo
operator|>>
operator|(
name|SREAL_PART_BITS
operator|/
literal|2
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|sig_lo
operator|&
operator|(
operator|(
name|uhwi
operator|)
literal|1
operator|<<
operator|(
operator|(
name|SREAL_PART_BITS
operator|/
literal|2
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|tmp2
operator|++
expr_stmt|;
name|r
operator|->
name|sig_lo
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|tmp1
operator|/
name|tmp2
expr_stmt|;
name|tmp1
operator|=
operator|(
name|tmp1
operator|%
name|tmp2
operator|)
operator|<<
operator|(
name|SREAL_PART_BITS
operator|/
literal|2
operator|)
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|=
name|tmp
operator|<<
name|SREAL_PART_BITS
expr_stmt|;
name|tmp
operator|=
name|tmp1
operator|/
name|tmp2
expr_stmt|;
name|tmp1
operator|=
operator|(
name|tmp1
operator|%
name|tmp2
operator|)
operator|<<
operator|(
name|SREAL_PART_BITS
operator|/
literal|2
operator|)
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|+=
name|tmp
operator|<<
operator|(
name|SREAL_PART_BITS
operator|/
literal|2
operator|)
expr_stmt|;
name|tmp
operator|=
name|tmp1
operator|/
name|tmp2
expr_stmt|;
name|r
operator|->
name|sig_hi
operator|+=
name|tmp
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|a
operator|->
name|exp
operator|-
name|b
operator|->
name|exp
operator|-
name|SREAL_BITS
operator|-
name|SREAL_PART_BITS
operator|/
literal|2
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gcc_assert
argument_list|(
name|b
operator|->
name|sig
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|sig
operator|=
operator|(
name|a
operator|->
name|sig
operator|<<
name|SREAL_PART_BITS
operator|)
operator|/
name|b
operator|->
name|sig
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|a
operator|->
name|exp
operator|-
name|b
operator|->
name|exp
operator|-
name|SREAL_PART_BITS
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|r
return|;
block|}
end_function

end_unit

