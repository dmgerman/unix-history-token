begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fold a constant sub-tree into a single node for C-compiler    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*@@ This file should be rewritten to use an arbitrary precision   @@ representation for "struct tree_int_cst" and "struct tree_real_cst".   @@ Perhaps the routines could also be used for bc/dc, and made a lib.   @@ The routines that translate from the ap rep should   @@ warn if precision et. al. is lost.   @@ This would also make life easier when this technology is used   @@ for cross-compilers.  */
end_comment

begin_comment
comment|/* The entry points in this file are fold, size_int_wide, size_binop    and force_fit_type.     fold takes a tree as argument and returns a simplified tree.     size_binop takes a tree code for an arithmetic operation    and two operands that are trees, and produces a tree for the    result, assuming the type comes from `sizetype'.     size_int takes an integer value, and creates a tree constant    with type from `sizetype'.     force_fit_type takes a constant, an overflowable flag and prior    overflow indicators.  It forces the value to fit the type and sets    TREE_OVERFLOW and TREE_CONSTANT_OVERFLOW as appropriate.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_comment
comment|/* Non-zero if we are folding constants inside an initializer; zero    otherwise.  */
end_comment

begin_decl_stmt
name|int
name|folding_initializer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following constants represent a bit based encoding of GCC's    comparison operators.  This encoding simplifies transformations    on relational comparison operators, such as AND and OR.  */
end_comment

begin_enum
enum|enum
name|comparison_code
block|{
name|COMPCODE_FALSE
init|=
literal|0
block|,
name|COMPCODE_LT
init|=
literal|1
block|,
name|COMPCODE_EQ
init|=
literal|2
block|,
name|COMPCODE_LE
init|=
literal|3
block|,
name|COMPCODE_GT
init|=
literal|4
block|,
name|COMPCODE_LTGT
init|=
literal|5
block|,
name|COMPCODE_GE
init|=
literal|6
block|,
name|COMPCODE_ORD
init|=
literal|7
block|,
name|COMPCODE_UNORD
init|=
literal|8
block|,
name|COMPCODE_UNLT
init|=
literal|9
block|,
name|COMPCODE_UNEQ
init|=
literal|10
block|,
name|COMPCODE_UNLE
init|=
literal|11
block|,
name|COMPCODE_UNGT
init|=
literal|12
block|,
name|COMPCODE_NE
init|=
literal|13
block|,
name|COMPCODE_UNGE
init|=
literal|14
block|,
name|COMPCODE_TRUE
init|=
literal|15
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|encode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|negate_mathfn_p
parameter_list|(
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|negate_expr_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|negate_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|split_tree
parameter_list|(
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|associate_trees
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|const_binop
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|comparison_code
name|comparison_to_compcode
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|compcode_to_comparison
parameter_list|(
name|enum
name|comparison_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|combine_comparisons
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|truth_value_p
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|operand_equal_for_comparison_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twoval_comparison_p
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|eval_subst
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pedantic_omit_one_operand
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|distribute_bit_expr
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|make_bit_field_ref
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|optimize_bit_field_compare
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|decode_field_reference
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|all_ones_mask_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|sign_bit_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|simple_operand_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|range_binop
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|range_predecessor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|range_successor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|make_range
parameter_list|(
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_range_check
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|merge_ranges
parameter_list|(
name|int
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_range_test
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_cond_expr_with_comparison
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|unextend
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_truthop
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|optimize_minmax_comparison
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|extract_muldiv
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|extract_muldiv_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|multiple_of_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_binary_op_with_conditional_arg
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|fold_real_zero_addition_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_mathfn_compare
parameter_list|(
name|enum
name|built_in_function
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_inf_compare
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_div_compare
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|reorder_operands_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_negate_const
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_not_const
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_relational_const
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_encode_expr
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|native_interpret_expr
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,    and SUM1.  Then this yields nonzero if overflow occurred during the    addition.     Overflow occurs if A and B have the same sign, but A and SUM differ in    sign.  Use `^' to test whether signs differ, and `< 0' to isolate the    sign.  */
end_comment

begin_define
define|#
directive|define
name|OVERFLOW_SUM_SIGN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|sum
parameter_list|)
value|((~((a) ^ (b))& ((a) ^ (sum)))< 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.    We do that by representing the two-word integer in 4 words, with only    HOST_BITS_PER_WIDE_INT / 2 bits stored in each word, as a positive    number.  The value of the word is LOWPART + HIGHPART * BASE.  */
end_comment

begin_define
define|#
directive|define
name|LOWPART
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)& (((unsigned HOST_WIDE_INT) 1<< (HOST_BITS_PER_WIDE_INT / 2)) - 1))
end_define

begin_define
define|#
directive|define
name|HIGHPART
parameter_list|(
name|x
parameter_list|)
define|\
value|((unsigned HOST_WIDE_INT) (x)>> HOST_BITS_PER_WIDE_INT / 2)
end_define

begin_define
define|#
directive|define
name|BASE
value|((unsigned HOST_WIDE_INT) 1<< HOST_BITS_PER_WIDE_INT / 2)
end_define

begin_comment
comment|/* Unpack a two-word integer into 4 words.    LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.    WORDS points to the array of HOST_WIDE_INTs.  */
end_comment

begin_function
specifier|static
name|void
name|encode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
name|words
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low
parameter_list|,
name|HOST_WIDE_INT
name|hi
parameter_list|)
block|{
name|words
index|[
literal|0
index|]
operator|=
name|LOWPART
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
name|HIGHPART
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
name|LOWPART
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
name|HIGHPART
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pack an array of 4 words into a two-word integer.    WORDS points to the array of words.    The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */
end_comment

begin_function
specifier|static
name|void
name|decode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
name|words
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|low
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hi
parameter_list|)
block|{
operator|*
name|low
operator|=
name|words
index|[
literal|0
index|]
operator|+
name|words
index|[
literal|1
index|]
operator|*
name|BASE
expr_stmt|;
operator|*
name|hi
operator|=
name|words
index|[
literal|2
index|]
operator|+
name|words
index|[
literal|3
index|]
operator|*
name|BASE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* T is an INT_CST node.  OVERFLOWABLE indicates if we are interested    in overflow of the value, when>0 we are only interested in signed    overflow, for<0 we are interested in any overflow.  OVERFLOWED    indicates whether overflow has already occurred.  CONST_OVERFLOWED    indicates whether constant overflow has already occurred.  We force    T's value to be within range of T's type (by setting to 0 or 1 all    the bits outside the type's range).  We set TREE_OVERFLOWED if,   	OVERFLOWED is nonzero, 	or OVERFLOWABLE is>0 and signed overflow occurs 	or OVERFLOWABLE is<0 and any overflow occurs    We set TREE_CONSTANT_OVERFLOWED if,         CONST_OVERFLOWED is nonzero 	or we set TREE_OVERFLOWED.   We return either the original T, or a copy.  */
end_comment

begin_function
name|tree
name|force_fit_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|overflowable
parameter_list|,
name|bool
name|overflowed
parameter_list|,
name|bool
name|overflowed_const
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
name|int
name|sign_extended_type
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|prec
operator|=
name|POINTER_SIZE
expr_stmt|;
else|else
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Size types *are* sign extended.  */
name|sign_extended_type
operator|=
operator|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision.  */
if|if
condition|(
name|prec
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sign_extended_type
condition|)
comment|/* No sign extension */
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Correct width already.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Sign extend top half? */
if|if
condition|(
name|high
operator|&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
condition|)
name|high
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
operator|(
name|HOST_WIDE_INT
operator|)
name|low
operator|<
literal|0
condition|)
name|high
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Sign extend bottom half? */
if|if
condition|(
name|low
operator|&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|high
operator|=
operator|-
literal|1
expr_stmt|;
name|low
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
expr_stmt|;
block|}
block|}
comment|/* If the value changed, return a new node.  */
if|if
condition|(
name|overflowed
operator|||
name|overflowed_const
operator|||
name|low
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|||
name|high
operator|!=
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflowed
operator|||
name|overflowable
operator|<
literal|0
operator|||
operator|(
name|overflowable
operator|>
literal|0
operator|&&
name|sign_extended_type
operator|)
condition|)
block|{
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overflowed_const
condition|)
block|{
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add two doubleword integers with doubleword result.    Return nonzero if the operation overflows according to UNSIGNED_P.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|add_double_with_sign
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|l2
parameter_list|,
name|HOST_WIDE_INT
name|h2
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|,
name|bool
name|unsigned_p
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|l
operator|=
name|l1
operator|+
name|l2
expr_stmt|;
name|h
operator|=
name|h1
operator|+
name|h2
operator|+
operator|(
name|l
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|l
expr_stmt|;
operator|*
name|hv
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|unsigned_p
condition|)
return|return
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
return|;
else|else
return|return
name|OVERFLOW_SUM_SIGN
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Negate a doubleword integer with doubleword result.    Return nonzero if the operation overflows, assuming it's signed.    The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|neg_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
block|{
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
operator|*
name|hv
operator|=
operator|-
name|h1
expr_stmt|;
return|return
operator|(
operator|*
name|hv
operator|&
name|h1
operator|)
operator|<
literal|0
return|;
block|}
else|else
block|{
operator|*
name|lv
operator|=
operator|-
name|l1
expr_stmt|;
operator|*
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Multiply two doubleword integers with doubleword result.    Return nonzero if the operation overflows according to UNSIGNED_P.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|mul_double_with_sign
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|l2
parameter_list|,
name|HOST_WIDE_INT
name|h2
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|,
name|bool
name|unsigned_p
parameter_list|)
block|{
name|HOST_WIDE_INT
name|arg1
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|arg2
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|prod
index|[
literal|4
operator|*
literal|2
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|carry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|toplow
decl_stmt|,
name|neglow
decl_stmt|;
name|HOST_WIDE_INT
name|tophigh
decl_stmt|,
name|neghigh
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|arg2
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|prod
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|prod
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|+
name|j
expr_stmt|;
comment|/* This product is<= 0xFFFE0001, the sum<= 0xFFFF0000.  */
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|*
name|arg2
index|[
name|j
index|]
expr_stmt|;
comment|/* Since prod[p]< 0xFFFF, this sum<= 0xFFFFFFFF.  */
name|carry
operator|+=
name|prod
index|[
name|k
index|]
expr_stmt|;
name|prod
index|[
name|k
index|]
operator|=
name|LOWPART
argument_list|(
name|carry
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|carry
argument_list|)
expr_stmt|;
block|}
name|prod
index|[
name|i
operator|+
literal|4
index|]
operator|=
name|carry
expr_stmt|;
block|}
name|decode
argument_list|(
name|prod
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|prod
operator|+
literal|4
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
comment|/* Unsigned overflow is immediate.  */
if|if
condition|(
name|unsigned_p
condition|)
return|return
operator|(
name|toplow
operator||
name|tophigh
operator|)
operator|!=
literal|0
return|;
comment|/* Check for signed overflow by calculating the signed representation of the      top half of the result; it should agree with the low half's sign bit.  */
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h2
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|hv
operator|<
literal|0
condition|?
operator|~
operator|(
name|toplow
operator|&
name|tophigh
operator|)
else|:
name|toplow
operator||
name|tophigh
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shift the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Shift right if COUNT is negative.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|lshift_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|,
name|int
name|arith
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|signmask
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|-
name|count
argument_list|,
name|prec
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|arith
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Shifting by the host word size is undefined according to the 	 ANSI standard, so we must handle this as a special case.  */
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|=
name|l1
operator|<<
operator|(
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<<
name|count
operator|)
operator||
operator|(
name|l1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|count
operator|-
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|l1
operator|<<
name|count
expr_stmt|;
block|}
comment|/* Sign extend all bits that are beyond the precision.  */
name|signmask
operator|=
operator|-
operator|(
operator|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|*
name|hv
operator|>>
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
else|:
operator|(
operator|*
name|lv
operator|>>
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
operator|*
name|hv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
operator|*
name|lv
operator||=
name|signmask
operator|<<
name|prec
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift the doubleword integer in L1, H1 right by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rshift_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|,
name|int
name|arith
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|signmask
decl_stmt|;
name|signmask
operator|=
operator|(
name|arith
condition|?
operator|-
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Shifting by the host word size is undefined according to the 	 ANSI standard, so we must handle this as a special case.  */
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
operator|(
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
name|count
expr_stmt|;
operator|*
name|lv
operator|=
operator|(
operator|(
name|l1
operator|>>
name|count
operator|)
operator||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|count
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Zero / sign extend all bits that are beyond the precision.  */
if|if
condition|(
name|count
operator|>=
operator|(
name|HOST_WIDE_INT
operator|)
name|prec
condition|)
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|=
name|signmask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prec
operator|-
name|count
operator|)
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prec
operator|-
name|count
operator|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
operator|*
name|hv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|count
operator|)
operator|)
expr_stmt|;
operator|*
name|lv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|count
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Rotate the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Rotate right if COUNT is negative.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|lrotate_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|s1l
decl_stmt|,
name|s2l
decl_stmt|;
name|HOST_WIDE_INT
name|s1h
decl_stmt|,
name|s2h
decl_stmt|;
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|+=
name|prec
expr_stmt|;
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s1l
argument_list|,
operator|&
name|s1h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|prec
operator|-
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s2l
argument_list|,
operator|&
name|s2h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lv
operator|=
name|s1l
operator||
name|s2l
expr_stmt|;
operator|*
name|hv
operator|=
name|s1h
operator||
name|s2h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rotate the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rrotate_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|s1l
decl_stmt|,
name|s2l
decl_stmt|;
name|HOST_WIDE_INT
name|s1h
decl_stmt|,
name|s2h
decl_stmt|;
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|+=
name|prec
expr_stmt|;
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s1l
argument_list|,
operator|&
name|s1h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|prec
operator|-
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s2l
argument_list|,
operator|&
name|s2h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lv
operator|=
name|s1l
operator||
name|s2l
expr_stmt|;
operator|*
name|hv
operator|=
name|s1h
operator||
name|s2h
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN    for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).    CODE is a tree code for a kind of division, one of    TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR    or EXACT_DIV_EXPR    It controls how the quotient is rounded to an integer.    Return nonzero if the operation overflows.    UNS nonzero says do unsigned division.  */
end_comment

begin_function
name|int
name|div_and_round_double
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|int
name|uns
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|lnum_orig
parameter_list|,
comment|/* num == numerator == dividend */
name|HOST_WIDE_INT
name|hnum_orig
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|lden_orig
parameter_list|,
comment|/* den == denominator == divisor */
name|HOST_WIDE_INT
name|hden_orig
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lquo
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hquo
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lrem
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hrem
parameter_list|)
block|{
name|int
name|quo_neg
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|num
index|[
literal|4
operator|+
literal|1
index|]
decl_stmt|;
comment|/* extra element for scaling.  */
name|HOST_WIDE_INT
name|den
index|[
literal|4
index|]
decl_stmt|,
name|quo
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|work
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|carry
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lnum
init|=
name|lnum_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hnum
init|=
name|hnum_orig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lden
init|=
name|lden_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hden
init|=
name|hden_orig
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hden
operator|==
literal|0
operator|&&
name|lden
operator|==
literal|0
condition|)
name|overflow
operator|=
literal|1
operator|,
name|lden
operator|=
literal|1
expr_stmt|;
comment|/* Calculate quotient sign and convert operands to unsigned.  */
if|if
condition|(
operator|!
name|uns
condition|)
block|{
if|if
condition|(
name|hnum
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
comment|/* (minimum integer) / (-1) is the only overflow case.  */
if|if
condition|(
name|neg_double
argument_list|(
name|lnum
argument_list|,
name|hnum
argument_list|,
operator|&
name|lnum
argument_list|,
operator|&
name|hnum
argument_list|)
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|lden
operator|&
name|hden
operator|)
operator|==
operator|-
literal|1
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|lden
argument_list|,
operator|&
name|hden
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
operator|&&
name|hden
operator|==
literal|0
condition|)
block|{
comment|/* single precision */
operator|*
name|hquo
operator|=
operator|*
name|hrem
operator|=
literal|0
expr_stmt|;
comment|/* This unsigned division rounds toward zero.  */
operator|*
name|lquo
operator|=
name|lnum
operator|/
name|lden
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
condition|)
block|{
comment|/* trivial case: dividend< divisor */
comment|/* hden != 0 already checked.  */
operator|*
name|hquo
operator|=
operator|*
name|lquo
operator|=
literal|0
expr_stmt|;
operator|*
name|hrem
operator|=
name|hnum
expr_stmt|;
operator|*
name|lrem
operator|=
name|lnum
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
name|memset
argument_list|(
name|quo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|quo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|num
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|num
argument_list|)
expr_stmt|;
comment|/* to zero 9th element */
name|memset
argument_list|(
name|den
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|den
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|num
argument_list|,
name|lnum
argument_list|,
name|hnum
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|den
argument_list|,
name|lden
argument_list|,
name|hden
argument_list|)
expr_stmt|;
comment|/* Special code for when the divisor< BASE.  */
if|if
condition|(
name|hden
operator|==
literal|0
operator|&&
name|lden
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|BASE
condition|)
block|{
comment|/* hnum != 0 already checked.  */
for|for
control|(
name|i
operator|=
literal|4
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
index|]
operator|+
name|carry
operator|*
name|BASE
expr_stmt|;
name|quo
index|[
name|i
index|]
operator|=
name|work
operator|/
name|lden
expr_stmt|;
name|carry
operator|=
name|work
operator|%
name|lden
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Full double precision division, 	 with thanks to Don Knuth's "Seminumerical Algorithms".  */
name|int
name|num_hi_sig
decl_stmt|,
name|den_hi_sig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|quo_est
decl_stmt|,
name|scale
decl_stmt|;
comment|/* Find the highest nonzero divisor digit.  */
for|for
control|(
name|i
operator|=
literal|4
operator|-
literal|1
init|;
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|den_hi_sig
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* Insure that the first digit of the divisor is at least BASE/2. 	 This is required by the quotient digit estimation algorithm.  */
name|scale
operator|=
name|BASE
operator|/
operator|(
name|den
index|[
name|den_hi_sig
index|]
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|1
condition|)
block|{
comment|/* scale divisor and dividend */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|num
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|num
index|[
name|i
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|num
index|[
literal|4
index|]
operator|=
name|carry
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|den
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|den
index|[
name|i
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|den_hi_sig
operator|=
name|i
expr_stmt|;
block|}
block|}
name|num_hi_sig
operator|=
literal|4
expr_stmt|;
comment|/* Main loop */
for|for
control|(
name|i
operator|=
name|num_hi_sig
operator|-
name|den_hi_sig
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Guess the next quotient digit, quo_est, by dividing the first 	     two remaining dividend digits by the high order quotient digit. 	     quo_est is never low and is at most 2 high.  */
name|unsigned
name|HOST_WIDE_INT
name|tmp
decl_stmt|;
name|num_hi_sig
operator|=
name|i
operator|+
name|den_hi_sig
operator|+
literal|1
expr_stmt|;
name|work
operator|=
name|num
index|[
name|num_hi_sig
index|]
operator|*
name|BASE
operator|+
name|num
index|[
name|num_hi_sig
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|num
index|[
name|num_hi_sig
index|]
operator|!=
name|den
index|[
name|den_hi_sig
index|]
condition|)
name|quo_est
operator|=
name|work
operator|/
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
else|else
name|quo_est
operator|=
name|BASE
operator|-
literal|1
expr_stmt|;
comment|/* Refine quo_est so it's usually correct, and at most one high.  */
name|tmp
operator|=
name|work
operator|-
name|quo_est
operator|*
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|BASE
operator|&&
operator|(
name|den
index|[
name|den_hi_sig
operator|-
literal|1
index|]
operator|*
name|quo_est
operator|>
operator|(
name|tmp
operator|*
name|BASE
operator|+
name|num
index|[
name|num_hi_sig
operator|-
literal|2
index|]
operator|)
operator|)
condition|)
name|quo_est
operator|--
expr_stmt|;
comment|/* Try QUO_EST as the quotient digit, by multiplying the 	     divisor by QUO_EST and subtracting from the remaining dividend. 	     Keep in mind that QUO_EST is the I - 1st digit.  */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|quo_est
operator|*
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|-
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|+=
name|HIGHPART
argument_list|(
name|work
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
comment|/* If quo_est was high by one, then num[i] went negative and 	     we need to correct things.  */
if|if
condition|(
name|num
index|[
name|num_hi_sig
index|]
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|carry
condition|)
block|{
name|quo_est
operator|--
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
comment|/* add divisor back in */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|+
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|num
index|[
name|num_hi_sig
index|]
operator|+=
name|carry
expr_stmt|;
block|}
comment|/* Store the quotient digit.  */
name|quo
index|[
name|i
index|]
operator|=
name|quo_est
expr_stmt|;
block|}
block|}
name|decode
argument_list|(
name|quo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
name|finish_up
label|:
comment|/* If result is negative, make it so.  */
if|if
condition|(
name|quo_neg
condition|)
name|neg_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
comment|/* Compute trial remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
comment|/* round toward zero */
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* for this one, it shouldn't matter */
return|return
name|overflow
return|;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
comment|/* round toward negative infinity */
if|if
condition|(
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio< 0&& rem != 0 */
block|{
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* round toward positive infinity */
if|if
condition|(
operator|!
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio> 0&& rem != 0 */
block|{
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
comment|/* round to closest integer */
block|{
name|unsigned
name|HOST_WIDE_INT
name|labs_rem
init|=
operator|*
name|lrem
decl_stmt|;
name|HOST_WIDE_INT
name|habs_rem
init|=
operator|*
name|hrem
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|labs_den
init|=
name|lden
decl_stmt|,
name|ltwice
decl_stmt|;
name|HOST_WIDE_INT
name|habs_den
init|=
name|hden
decl_stmt|,
name|htwice
decl_stmt|;
comment|/* Get absolute values.  */
if|if
condition|(
operator|*
name|hrem
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
operator|&
name|labs_rem
argument_list|,
operator|&
name|habs_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|labs_den
argument_list|,
operator|&
name|habs_den
argument_list|)
expr_stmt|;
comment|/* If (2 * abs (lrem)>= abs (lden)) */
name|mul_double
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|labs_rem
argument_list|,
name|habs_rem
argument_list|,
operator|&
name|ltwice
argument_list|,
operator|&
name|htwice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|&&
operator|(
name|labs_den
operator|<
name|ltwice
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|hquo
operator|<
literal|0
condition|)
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
else|else
comment|/* quo = quo + 1; */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Compute true remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
return|return
name|overflow
return|;
block|}
end_function

begin_comment
comment|/* If ARG2 divides ARG1 with zero remainder, carries out the division    of type CODE and returns the quotient.    Otherwise returns NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|div_if_zero_remainder
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|int1l
decl_stmt|,
name|int2l
decl_stmt|;
name|HOST_WIDE_INT
name|int1h
decl_stmt|,
name|int2h
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|quol
decl_stmt|,
name|reml
decl_stmt|;
name|HOST_WIDE_INT
name|quoh
decl_stmt|,
name|remh
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|uns
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int1l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int1h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int2l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|int2h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|quol
argument_list|,
operator|&
name|quoh
argument_list|,
operator|&
name|reml
argument_list|,
operator|&
name|remh
argument_list|)
expr_stmt|;
if|if
condition|(
name|remh
operator|!=
literal|0
operator|||
name|reml
operator|!=
literal|0
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|quol
argument_list|,
name|quoh
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is non-zero if we should defer warnings about undefined    overflow.  This facility exists because these warnings are a    special case.  The code to estimate loop iterations does not want    to issue any warnings, since it works with expressions which do not    occur in user code.  Various bits of cleanup code call fold(), but    only use the result if it has certain characteristics (e.g., is a    constant); that code only wants to issue a warning if the result is    used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fold_deferring_overflow_warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a warning about undefined overflow is deferred, this is the    warning.  Note that this may cause us to turn two warnings into    one, but that is fine since it is sufficient to only give one    warning per expression.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fold_deferred_overflow_warning
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a warning about undefined overflow is deferred, this is the    level at which the warning should be emitted.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|warn_strict_overflow_code
name|fold_deferred_overflow_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start deferring overflow warnings.  We could use a stack here to    permit nested calls, but at present it is not necessary.  */
end_comment

begin_function
name|void
name|fold_defer_overflow_warnings
parameter_list|(
name|void
parameter_list|)
block|{
operator|++
name|fold_deferring_overflow_warnings
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop deferring overflow warnings.  If there is a pending warning,    and ISSUE is true, then issue the warning if appropriate.  STMT is    the statement with which the warning should be associated (used for    location information); STMT may be NULL.  CODE is the level of the    warning--a warn_strict_overflow_code value.  This function will use    the smaller of CODE and the deferred code when deciding whether to    issue the warning.  CODE may be zero to mean to always use the    deferred code.  */
end_comment

begin_function
name|void
name|fold_undefer_overflow_warnings
parameter_list|(
name|bool
name|issue
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|int
name|code
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|warnmsg
decl_stmt|;
name|location_t
name|locus
decl_stmt|;
name|gcc_assert
argument_list|(
name|fold_deferring_overflow_warnings
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|--
name|fold_deferring_overflow_warnings
expr_stmt|;
if|if
condition|(
name|fold_deferring_overflow_warnings
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fold_deferred_overflow_warning
operator|!=
name|NULL
operator|&&
name|code
operator|!=
literal|0
operator|&&
name|code
operator|<
operator|(
name|int
operator|)
name|fold_deferred_overflow_code
condition|)
name|fold_deferred_overflow_code
operator|=
name|code
expr_stmt|;
return|return;
block|}
name|warnmsg
operator|=
name|fold_deferred_overflow_warning
expr_stmt|;
name|fold_deferred_overflow_warning
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|issue
operator|||
name|warnmsg
operator|==
name|NULL
condition|)
return|return;
comment|/* Use the smallest code level when deciding to issue the      warning.  */
if|if
condition|(
name|code
operator|==
literal|0
operator|||
name|code
operator|>
operator|(
name|int
operator|)
name|fold_deferred_overflow_code
condition|)
name|code
operator|=
name|fold_deferred_overflow_code
expr_stmt|;
if|if
condition|(
operator|!
name|issue_strict_overflow_warning
argument_list|(
name|code
argument_list|)
condition|)
return|return;
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
operator|||
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|locus
operator|=
name|input_location
expr_stmt|;
else|else
name|locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wstrict_overflow
argument_list|,
literal|"%H%s"
argument_list|,
operator|&
name|locus
argument_list|,
name|warnmsg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop deferring overflow warnings, ignoring any deferred    warnings.  */
end_comment

begin_function
name|void
name|fold_undefer_and_ignore_overflow_warnings
parameter_list|(
name|void
parameter_list|)
block|{
name|fold_undefer_overflow_warnings
argument_list|(
name|false
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Whether we are deferring overflow warnings.  */
end_comment

begin_function
name|bool
name|fold_deferring_overflow_warnings_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|fold_deferring_overflow_warnings
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is called when we fold something based on the fact that signed    overflow is undefined.  */
end_comment

begin_function
specifier|static
name|void
name|fold_overflow_warning
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
name|enum
name|warn_strict_overflow_code
name|wc
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|flag_wrapv
operator|&&
operator|!
name|flag_trapv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fold_deferring_overflow_warnings
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fold_deferred_overflow_warning
operator|==
name|NULL
operator|||
name|wc
operator|<
name|fold_deferred_overflow_code
condition|)
block|{
name|fold_deferred_overflow_warning
operator|=
name|gmsgid
expr_stmt|;
name|fold_deferred_overflow_code
operator|=
name|wc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|issue_strict_overflow_warning
argument_list|(
name|wc
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wstrict_overflow
argument_list|,
literal|"%s"
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the built-in mathematical function specified by CODE    is odd, i.e. -f(x) == f(-x).  */
end_comment

begin_function
specifier|static
name|bool
name|negate_mathfn_p
parameter_list|(
name|enum
name|built_in_function
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ASIN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ASINH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATAN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATANH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CBRT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SINH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TAN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TANH
argument_list|)
operator|:
return|return
name|true
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check whether we may negate an integer constant T without causing    overflow.  */
end_comment

begin_function
name|bool
name|may_negate_without_overflow_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
name|prec
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|val
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|val
operator|!=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether an expression T can be cheaply negated using    the function negate_expr without introducing undefined overflow.  */
end_comment

begin_function
specifier|static
name|bool
name|negate_expr_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Check that -CST will not overflow type.  */
return|return
name|may_negate_without_overflow_p
argument_list|(
name|t
argument_list|)
return|;
case|case
name|BIT_NOT_EXPR
case|:
return|return
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|type
argument_list|)
operator|)
return|;
case|case
name|REAL_CST
case|:
case|case
name|NEGATE_EXPR
case|:
return|return
name|true
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|negate_expr_p
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|negate_expr_p
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
condition|)
return|return
name|false
return|;
comment|/* -(A + B) -> (-B) - A.  */
if|if
condition|(
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* -(A + B) -> (-A) - B.  */
return|return
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* We can't turn -(A-B) into B-A when we honor signed zeros.  */
return|return
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* In general we can't negate A / B, because if A is INT_MIN and 	 B is 1, we may turn this into INT_MIN / -1 which is undefined 	 and actually traps on some architectures.  But if overflow is 	 undefined, we can negate, because - (INT_MIN / 1) is an 	 overflow.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
break|break;
return|return
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
comment|/* Negate -((double)float) as (double)(-float).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tree
name|tem
init|=
name|strip_float_extensions
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
name|t
condition|)
return|return
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
return|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Negate -f(x) as f(-x).  */
if|if
condition|(
name|negate_mathfn_p
argument_list|(
name|builtin_mathfn_code
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|negate_expr_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
comment|/* Optimize -((int)x>> 31) into (unsigned)x>> 31.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|true
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given T, an expression, return a folded tree for -T or NULL_TREE, if no    simplification is possible.    If negate_expr_p would return true for T, NULL_TREE will never be    returned.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_negate_expr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Convert - (~A) to A + 1.  */
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|INTEGER_CST
case|:
name|tem
operator|=
name|fold_negate_const
argument_list|(
name|t
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|tem
argument_list|)
operator|||
operator|!
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|REAL_CST
case|:
name|tem
operator|=
name|fold_negate_const
argument_list|(
name|t
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Two's complement FP formats, such as c4x, may overflow.  */
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|tem
argument_list|)
operator|||
operator|!
name|flag_trapping_math
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|COMPLEX_CST
case|:
block|{
name|tree
name|rpart
init|=
name|negate_expr
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ipart
init|=
name|negate_expr
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rpart
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|ipart
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rpart
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|ipart
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|rpart
argument_list|,
name|ipart
argument_list|)
return|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
condition|)
block|{
comment|/* -(A + B) -> (-B) - A.  */
if|if
condition|(
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|negate_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* -(A + B) -> (-A) - B.  */
if|if
condition|(
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|negate_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* - (A - B) -> B - A  */
if|if
condition|(
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* In general we can't negate A / B, because if A is INT_MIN and 	 B is 1, we may turn this into INT_MIN / -1 which is undefined 	 and actually traps on some architectures.  But if overflow is 	 undefined, we can negate, because - (INT_MIN / 1) is an 	 overflow.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|type
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|warnmsg
init|=
name|G_
argument_list|(
literal|"assuming signed overflow does not "
literal|"occur when negating a division"
argument_list|)
decl_stmt|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|integer_onep
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
name|fold_overflow_warning
argument_list|(
name|warnmsg
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|tree_int_cst_equal
argument_list|(
name|tem
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|fold_overflow_warning
argument_list|(
name|warnmsg
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|NOP_EXPR
case|:
comment|/* Convert -((double)float) into (double)(-float).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tem
operator|=
name|strip_float_extensions
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|t
operator|&&
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|negate_expr
argument_list|(
name|tem
argument_list|)
return|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Negate -f(x) as f(-x).  */
if|if
condition|(
name|negate_mathfn_p
argument_list|(
name|builtin_mathfn_code
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|negate_expr_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fndecl
decl_stmt|,
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|arg
operator|=
name|negate_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
break|break;
case|case
name|RSHIFT_EXPR
case|:
comment|/* Optimize -((int)x>> 31) into (unsigned)x>> 31.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|tree
name|ntype
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|type
argument_list|)
else|:
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|temp
init|=
name|fold_convert
argument_list|(
name|ntype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|=
name|fold_build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|ntype
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like fold_negate_expr, but return a NEGATE_EXPR tree, if T can not be    negated in a simpler way.  Also allow for T to be NULL_TREE, in which case    return NULL_TREE. */
end_comment

begin_function
specifier|static
name|tree
name|negate_expr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|tem
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_negate_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|tem
operator|=
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a tree IN into a constant, literal and variable parts that could be    combined with CODE to make IN.  "constant" means an expression with    TREE_CONSTANT but that isn't an actual constant.  CODE must be a    commutative arithmetic operation.  Store the constant part into *CONP,    the literal in *LITP and return the variable part.  If a part isn't    present, set it to null.  If the tree does not decompose in this way,    return the entire tree as the variable part and the other parts as null.     If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.  In that    case, we negate an operand that was subtracted.  Except if it is a    literal for which we use *MINUS_LITP instead.     If NEGATE_P is true, we are negating all of IN, again except a literal    for which we use *MINUS_LITP instead.     If IN is itself a literal or constant, return it as appropriate.     Note that we do not guarantee that any of the three values will be the    same type as IN, but they will have the same signedness and mode.  */
end_comment

begin_function
specifier|static
name|tree
name|split_tree
parameter_list|(
name|tree
name|in
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
modifier|*
name|conp
parameter_list|,
name|tree
modifier|*
name|litp
parameter_list|,
name|tree
modifier|*
name|minus_litp
parameter_list|,
name|int
name|negate_p
parameter_list|)
block|{
name|tree
name|var
init|=
literal|0
decl_stmt|;
operator|*
name|conp
operator|=
literal|0
expr_stmt|;
operator|*
name|litp
operator|=
literal|0
expr_stmt|;
operator|*
name|minus_litp
operator|=
literal|0
expr_stmt|;
comment|/* Strip any conversions that don't change the machine mode or signedness.  */
name|STRIP_SIGN_NOPS
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|code
operator|||
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
argument_list|)
comment|/* We can associate addition and subtraction together (even 		  though the C standard doesn't say so) for integers because 		  the value is not affected.  For reals, the value might be 		  affected, so we can't.  */
operator|&&
operator|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|neg1_p
init|=
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
decl_stmt|;
name|int
name|neg_litp_p
init|=
literal|0
decl_stmt|,
name|neg_conp_p
init|=
literal|0
decl_stmt|,
name|neg_var_p
init|=
literal|0
decl_stmt|;
comment|/* First see if either of the operands is a literal, then a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|op0
operator|,
name|op0
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|op1
operator|,
name|neg_litp_p
operator|=
name|neg1_p
operator|,
name|op1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|op0
operator|,
name|op0
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|op1
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|op1
operator|,
name|neg_conp_p
operator|=
name|neg1_p
operator|,
name|op1
operator|=
literal|0
expr_stmt|;
comment|/* If we haven't dealt with either operand, this is not a case we can 	 decompose.  Otherwise, VAR is either of the ones remaining, if any.  */
if|if
condition|(
name|op0
operator|!=
literal|0
operator|&&
name|op1
operator|!=
literal|0
condition|)
name|var
operator|=
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|op0
operator|!=
literal|0
condition|)
name|var
operator|=
name|op0
expr_stmt|;
else|else
name|var
operator|=
name|op1
operator|,
name|neg_var_p
operator|=
name|neg1_p
expr_stmt|;
comment|/* Now do any needed negations.  */
if|if
condition|(
name|neg_litp_p
condition|)
operator|*
name|minus_litp
operator|=
operator|*
name|litp
operator|,
operator|*
name|litp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|neg_conp_p
condition|)
operator|*
name|conp
operator|=
name|negate_expr
argument_list|(
operator|*
name|conp
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg_var_p
condition|)
name|var
operator|=
name|negate_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|in
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|in
expr_stmt|;
else|else
name|var
operator|=
name|in
expr_stmt|;
if|if
condition|(
name|negate_p
condition|)
block|{
if|if
condition|(
operator|*
name|litp
condition|)
operator|*
name|minus_litp
operator|=
operator|*
name|litp
operator|,
operator|*
name|litp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|minus_litp
condition|)
operator|*
name|litp
operator|=
operator|*
name|minus_litp
operator|,
operator|*
name|minus_litp
operator|=
literal|0
expr_stmt|;
operator|*
name|conp
operator|=
name|negate_expr
argument_list|(
operator|*
name|conp
argument_list|)
expr_stmt|;
name|var
operator|=
name|negate_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Re-associate trees split by the above function.  T1 and T2 are either    expressions to associate or null.  Return the new expression, if any.  If    we build an operation, do it in TYPE and with CODE.  */
end_comment

begin_function
specifier|static
name|tree
name|associate_trees
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
name|t2
return|;
elseif|else
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|t1
return|;
comment|/* If either input is CODE, a PLUS_EXPR, or a MINUS_EXPR, don't      try to fold this since we will have infinite recursion.  But do      deal with any NEGATE_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|code
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|code
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|MINUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
return|;
block|}
return|return
name|build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|)
return|;
block|}
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Combine two integer constants ARG1 and ARG2 under operation CODE    to produce a new constant.  Return NULL_TREE if we don't know how    to evaluate CODE at compile-time.     If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */
end_comment

begin_function
name|tree
name|int_const_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|int
name|notrunc
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|int1l
decl_stmt|,
name|int2l
decl_stmt|;
name|HOST_WIDE_INT
name|int1h
decl_stmt|,
name|int2h
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|garbagel
decl_stmt|;
name|HOST_WIDE_INT
name|garbageh
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|uns
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_sizetype
init|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|int1l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int1h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int2l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|int2h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BIT_IOR_EXPR
case|:
name|low
operator|=
name|int1l
operator||
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator||
name|int2h
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|low
operator|=
name|int1l
operator|^
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator|^
name|int2h
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|low
operator|=
name|int1l
operator|&
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator|&
name|int2h
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LSHIFT_EXPR
case|:
comment|/* It's unclear from the C standard whether shifts can overflow. 	 The following code ignores overflow; perhaps a C standard 	 interpretation ruling is needed.  */
name|lshift_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|!
name|uns
argument_list|)
expr_stmt|;
break|break;
case|case
name|RROTATE_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LROTATE_EXPR
case|:
name|lrotate_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|overflow
operator|=
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|neg_double
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|low
argument_list|,
name|hi
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|OVERFLOW_SUM_SIGN
argument_list|(
name|hi
argument_list|,
name|int2h
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|overflow
operator|=
name|mul_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* This is a shortcut for a common special case.  */
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int2l
operator|>
literal|0
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|&&
name|int1h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int1l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_DIV_EXPR
condition|)
name|int1l
operator|+=
name|int2l
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|int1l
operator|/
name|int2l
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ...  */
case|case
name|ROUND_DIV_EXPR
case|:
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|1
condition|)
block|{
name|low
operator|=
name|int1l
operator|,
name|hi
operator|=
name|int1h
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int1l
operator|==
name|int2l
operator|&&
name|int1h
operator|==
name|int2h
operator|&&
operator|!
operator|(
name|int1l
operator|==
literal|0
operator|&&
name|int1h
operator|==
literal|0
operator|)
condition|)
block|{
name|low
operator|=
literal|1
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* This is a shortcut for a common special case.  */
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int2l
operator|>
literal|0
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|&&
name|int1h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int1l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_MOD_EXPR
condition|)
name|int1l
operator|+=
name|int2l
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|int1l
operator|%
name|int2l
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ...  */
case|case
name|ROUND_MOD_EXPR
case|:
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|uns
condition|)
name|low
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|&&
name|int1l
operator|<
name|int2l
operator|)
operator|)
expr_stmt|;
else|else
name|low
operator|=
operator|(
name|int1h
operator|<
name|int2h
operator|||
operator|(
name|int1h
operator|==
name|int2h
operator|&&
name|int1l
operator|<
name|int2l
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
operator|(
name|code
operator|==
name|MIN_EXPR
operator|)
condition|)
name|low
operator|=
name|int1l
operator|,
name|hi
operator|=
name|int1h
expr_stmt|;
else|else
name|low
operator|=
name|int2l
operator|,
name|hi
operator|=
name|int2h
expr_stmt|;
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
name|t
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|notrunc
condition|)
block|{
comment|/* Propagate overflow flags ourselves.  */
if|if
condition|(
operator|(
operator|(
operator|!
name|uns
operator|||
name|is_sizetype
operator|)
operator|&&
name|overflow
operator|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
operator|(
operator|(
operator|!
name|uns
operator|||
name|is_sizetype
operator|)
operator|&&
name|overflow
operator|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Combine two constants ARG1 and ARG2 under operation CODE to produce a new    constant.  We assume ARG1 and ARG2 have the same data type, or at least    are the same kind of constant and the same machine mode.  Return zero if    combining the constants is not allowed in the current operating mode.     If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */
end_comment

begin_function
specifier|static
name|tree
name|const_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|int
name|notrunc
parameter_list|)
block|{
comment|/* Sanity check for the recursive cases.  */
if|if
condition|(
operator|!
name|arg1
operator|||
operator|!
name|arg2
condition|)
return|return
name|NULL_TREE
return|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|notrunc
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|d1
decl_stmt|;
name|REAL_VALUE_TYPE
name|d2
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|REAL_VALUE_TYPE
name|result
decl_stmt|;
name|bool
name|inexact
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
comment|/* The following codes are handled by real_arithmetic.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
name|d1
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't perform operation if we honor signaling NaNs and 	 either operand is a NaN.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|d2
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't perform operation if it would raise a division 	 by zero exception.  */
if|if
condition|(
name|code
operator|==
name|RDIV_EXPR
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|d2
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|(
name|flag_trapping_math
operator|||
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If either operand is a NaN, just return it.  Otherwise, set up 	 for floating-point trap; we return an overflow.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d2
argument_list|)
condition|)
return|return
name|arg2
return|;
name|inexact
operator|=
name|real_arithmetic
argument_list|(
operator|&
name|value
argument_list|,
name|code
argument_list|,
operator|&
name|d1
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|result
argument_list|,
name|mode
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Don't constant fold this floating point operation if 	 the result has overflowed and flag_trapping_math.  */
if|if
condition|(
name|flag_trapping_math
operator|&&
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_ISINF
argument_list|(
name|d1
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_ISINF
argument_list|(
name|d2
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't constant fold this floating point operation if the 	 result may dependent upon the run-time rounding mode and 	 flag_rounding_math is set, or if GCC's software emulation 	 is unable to accurately represent the result.  */
if|if
condition|(
operator|(
name|flag_rounding_math
operator|||
operator|(
name|REAL_MODE_FORMAT_COMPOSITE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
operator|)
operator|)
operator|&&
operator|(
name|inexact
operator|||
operator|!
name|real_identical
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|value
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|r1
init|=
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|i1
init|=
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|r2
init|=
name|TREE_REALPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|tree
name|i2
init|=
name|TREE_IMAGPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|real
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
expr_stmt|;
name|imag
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|real
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
expr_stmt|;
name|imag
operator|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
block|{
name|tree
name|magsquared
init|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r2
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i2
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
decl_stmt|;
name|tree
name|t1
init|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|r1
argument_list|)
argument_list|)
condition|)
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
name|real
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|t1
argument_list|,
name|magsquared
argument_list|,
name|notrunc
argument_list|)
expr_stmt|;
name|imag
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|t2
argument_list|,
name|magsquared
argument_list|,
name|notrunc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|real
operator|&&
name|imag
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|real
argument_list|,
name|imag
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Create a size type INT_CST node with NUMBER sign extended.  KIND    indicates which particular sizetype to create.  */
end_comment

begin_function
name|tree
name|size_int_kind
parameter_list|(
name|HOST_WIDE_INT
name|number
parameter_list|,
name|enum
name|size_type_kind
name|kind
parameter_list|)
block|{
return|return
name|build_int_cst
argument_list|(
name|sizetype_tab
index|[
operator|(
name|int
operator|)
name|kind
index|]
argument_list|,
name|number
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Combine operands OP1 and OP2 with arithmetic operation CODE.  CODE    is a tree code.  The type of the result is taken from the operands.    Both must be the same type integer type and it must be a size type.    If the operands are constant, so is the result.  */
end_comment

begin_function
name|tree
name|size_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the special case of two integer constants faster.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* And some specific cases even faster than that.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|||
name|code
operator|==
name|PLUS_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|arg0
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
comment|/* Handle general case of two integer constants.  */
return|return
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given two values, either both of sizetype or both of bitsizetype,    compute the difference between the two values.  Return the value    in signed type corresponding to the type of the operands.  */
end_comment

begin_function
name|tree
name|size_diffop
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|ctype
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the type is already signed, just do the simple thing.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
name|ctype
operator|=
name|type
operator|==
name|bitsizetype
condition|?
name|sbitsizetype
else|:
name|ssizetype
expr_stmt|;
comment|/* If either operand is not a constant, do the conversions to the signed      type and subtract.  The hardware will do the right thing with any      overflow in the subtraction.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* If ARG0 is larger than ARG1, subtract and return the result in CTYPE.      Otherwise, subtract the other way, convert to CTYPE (we know that can't      overflow) and negate (which can't either).  Special-case a result      of zero while we're here.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|build_int_cst
argument_list|(
name|ctype
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|arg1
argument_list|,
name|arg0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_int_cst
argument_list|(
name|ctype
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of fold_convert_const handling conversions of an    INTEGER_CST to another integer type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert_const_int_from_int
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Given an integer constant, make new constant with new type,      appropriately sign-extended or truncated.  */
name|t
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
comment|/* Don't set the overflow when 		      	 converting a pointer  */
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_convert_const handling conversions a REAL_CST    to an integer type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert_const_int_from_real
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* The following code implements the floating point to integer      conversion rules required by the Java Language Specification,      that IEEE NaNs are mapped to zero and values that overflow      the target precision saturate, i.e. values greater than      INT_MAX are mapped to INT_MAX, and values less than INT_MIN      are mapped to INT_MIN.  These semantics are allowed by the      C and C++ standards that simply state that the behavior of      FP-to-integer conversion is unspecified upon overflow.  */
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|REAL_VALUE_TYPE
name|x
init|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIX_TRUNC_EXPR
case|:
name|real_trunc
argument_list|(
operator|&
name|r
argument_list|,
name|VOIDmode
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIX_CEIL_EXPR
case|:
name|real_ceil
argument_list|(
operator|&
name|r
argument_list|,
name|VOIDmode
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIX_FLOOR_EXPR
case|:
name|real_floor
argument_list|(
operator|&
name|r
argument_list|,
name|VOIDmode
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIX_ROUND_EXPR
case|:
name|real_round
argument_list|(
operator|&
name|r
argument_list|,
name|VOIDmode
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If R is NaN, return zero and show we have an overflow.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if R is less than the lower bound or greater than the      upper bound.  */
if|if
condition|(
operator|!
name|overflow
condition|)
block|{
name|tree
name|lt
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|l
init|=
name|real_value_from_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|lt
argument_list|)
decl_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|lt
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|lt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|overflow
condition|)
block|{
name|tree
name|ut
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ut
condition|)
block|{
name|REAL_VALUE_TYPE
name|u
init|=
name|real_value_from_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|ut
argument_list|)
decl_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|u
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|ut
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|overflow
condition|)
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
operator|-
literal|1
argument_list|,
name|overflow
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_convert_const handling conversions a REAL_CST    to another floating point type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert_const_real_from_real
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|real_convert
argument_list|(
operator|&
name|value
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Attempt to fold type conversion operation CODE of expression ARG1 to    type TYPE.  If no simplification can be done return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert_const
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|==
name|type
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold_convert_const_int_from_int
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|fold_convert_const_int_from_real
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|build_real_from_int_cst
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|fold_convert_const_real_from_real
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Construct a vector of zero elements of vector type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_zero_vector
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
name|elem
operator|=
name|fold_convert_const
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|units
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|list
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
name|list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|elem
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|build_vector
argument_list|(
name|type
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert expression ARG to type TYPE.  Used by the middle-end for    simple conversions in preference to calling the front-end's convert.  */
end_comment

begin_function
name|tree
name|fold_convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|orig
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|orig
condition|)
return|return
name|arg
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|orig
argument_list|)
operator|||
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|orig
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* APPLE LOCAL blocks 5862465 */
case|case
name|BLOCK_POINTER_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tem
operator|=
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|fold_build1
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
name|tem
operator|=
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|COMPLEX_TYPE
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|REAL_TYPE
case|:
return|return
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
block|{
name|tree
name|rpart
decl_stmt|,
name|ipart
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
block|{
name|rpart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|rpart
argument_list|,
name|ipart
argument_list|)
return|;
block|}
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|rpart
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ipart
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|rpart
argument_list|,
name|ipart
argument_list|)
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_zero_vector
argument_list|(
name|type
argument_list|)
return|;
name|gcc_assert
argument_list|(
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|VECTOR_TYPE
argument_list|)
expr_stmt|;
return|return
name|fold_build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|VOID_TYPE
case|:
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|fold_ignored_result
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return false if expr can be assumed not to be an lvalue, true    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|maybe_lvalue_p
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
comment|/* We only need to wrap lvalue tree codes.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|SSA_NAME
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|OBJ_TYPE_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|COND_EXPR
case|:
case|case
name|BIND_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
break|break;
default|default:
comment|/* Assume the worst for front-end tree codes.  */
if|if
condition|(
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|>=
name|NUM_TREE_CODES
condition|)
break|break;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return an expr equal to X but certainly not valid as an lvalue.  */
end_comment

begin_function
name|tree
name|non_lvalue
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
comment|/* While we are in GIMPLE, NON_LVALUE_EXPR doesn't mean anything to      us.  */
if|if
condition|(
name|in_gimple_form
condition|)
return|return
name|x
return|;
if|if
condition|(
operator|!
name|maybe_lvalue_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero means lvalues are limited to those valid in pedantic ANSI C.    Zero means allow extended lvalues.  */
end_comment

begin_decl_stmt
name|int
name|pedantic_lvalues
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When pedantic, return an expr equal to X but certainly not valid as a    pedantic lvalue.  Otherwise, return X.  */
end_comment

begin_function
specifier|static
name|tree
name|pedantic_non_lvalue
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
if|if
condition|(
name|pedantic_lvalues
condition|)
return|return
name|non_lvalue
argument_list|(
name|x
argument_list|)
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree comparison code, return the code that is the logical inverse    of the given code.  It is not safe to do this for floating-point    comparisons, except for NE_EXPR and EQ_EXPR, so we receive a machine mode    as well: if reversing the comparison is unsafe, return ERROR_MARK.  */
end_comment

begin_function
name|enum
name|tree_code
name|invert_tree_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|bool
name|honor_nans
parameter_list|)
block|{
if|if
condition|(
name|honor_nans
operator|&&
name|flag_trapping_math
condition|)
return|return
name|ERROR_MARK
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|NE_EXPR
return|;
case|case
name|NE_EXPR
case|:
return|return
name|EQ_EXPR
return|;
case|case
name|GT_EXPR
case|:
return|return
name|honor_nans
condition|?
name|UNLE_EXPR
else|:
name|LE_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|honor_nans
condition|?
name|UNLT_EXPR
else|:
name|LT_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|honor_nans
condition|?
name|UNGE_EXPR
else|:
name|GE_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|honor_nans
condition|?
name|UNGT_EXPR
else|:
name|GT_EXPR
return|;
case|case
name|LTGT_EXPR
case|:
return|return
name|UNEQ_EXPR
return|;
case|case
name|UNEQ_EXPR
case|:
return|return
name|LTGT_EXPR
return|;
case|case
name|UNGT_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|UNGE_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|UNLT_EXPR
case|:
return|return
name|GE_EXPR
return|;
case|case
name|UNLE_EXPR
case|:
return|return
name|GT_EXPR
return|;
case|case
name|ORDERED_EXPR
case|:
return|return
name|UNORDERED_EXPR
return|;
case|case
name|UNORDERED_EXPR
case|:
return|return
name|ORDERED_EXPR
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but return the comparison that results if the operands are    swapped.  This is safe for floating-point.  */
end_comment

begin_function
name|enum
name|tree_code
name|swap_tree_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
return|return
name|code
return|;
case|case
name|GT_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|GT_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|GE_EXPR
return|;
case|case
name|UNGT_EXPR
case|:
return|return
name|UNLT_EXPR
return|;
case|case
name|UNGE_EXPR
case|:
return|return
name|UNLE_EXPR
return|;
case|case
name|UNLT_EXPR
case|:
return|return
name|UNGT_EXPR
return|;
case|case
name|UNLE_EXPR
case|:
return|return
name|UNGE_EXPR
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a comparison tree code from an enum tree_code representation    into a compcode bit-based encoding.  This function is the inverse of    compcode_to_comparison.  */
end_comment

begin_function
specifier|static
name|enum
name|comparison_code
name|comparison_to_compcode
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
return|return
name|COMPCODE_LT
return|;
case|case
name|EQ_EXPR
case|:
return|return
name|COMPCODE_EQ
return|;
case|case
name|LE_EXPR
case|:
return|return
name|COMPCODE_LE
return|;
case|case
name|GT_EXPR
case|:
return|return
name|COMPCODE_GT
return|;
case|case
name|NE_EXPR
case|:
return|return
name|COMPCODE_NE
return|;
case|case
name|GE_EXPR
case|:
return|return
name|COMPCODE_GE
return|;
case|case
name|ORDERED_EXPR
case|:
return|return
name|COMPCODE_ORD
return|;
case|case
name|UNORDERED_EXPR
case|:
return|return
name|COMPCODE_UNORD
return|;
case|case
name|UNLT_EXPR
case|:
return|return
name|COMPCODE_UNLT
return|;
case|case
name|UNEQ_EXPR
case|:
return|return
name|COMPCODE_UNEQ
return|;
case|case
name|UNLE_EXPR
case|:
return|return
name|COMPCODE_UNLE
return|;
case|case
name|UNGT_EXPR
case|:
return|return
name|COMPCODE_UNGT
return|;
case|case
name|LTGT_EXPR
case|:
return|return
name|COMPCODE_LTGT
return|;
case|case
name|UNGE_EXPR
case|:
return|return
name|COMPCODE_UNGE
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a compcode bit-based encoding of a comparison operator back    to GCC's enum tree_code representation.  This function is the    inverse of comparison_to_compcode.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|compcode_to_comparison
parameter_list|(
name|enum
name|comparison_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPCODE_LT
case|:
return|return
name|LT_EXPR
return|;
case|case
name|COMPCODE_EQ
case|:
return|return
name|EQ_EXPR
return|;
case|case
name|COMPCODE_LE
case|:
return|return
name|LE_EXPR
return|;
case|case
name|COMPCODE_GT
case|:
return|return
name|GT_EXPR
return|;
case|case
name|COMPCODE_NE
case|:
return|return
name|NE_EXPR
return|;
case|case
name|COMPCODE_GE
case|:
return|return
name|GE_EXPR
return|;
case|case
name|COMPCODE_ORD
case|:
return|return
name|ORDERED_EXPR
return|;
case|case
name|COMPCODE_UNORD
case|:
return|return
name|UNORDERED_EXPR
return|;
case|case
name|COMPCODE_UNLT
case|:
return|return
name|UNLT_EXPR
return|;
case|case
name|COMPCODE_UNEQ
case|:
return|return
name|UNEQ_EXPR
return|;
case|case
name|COMPCODE_UNLE
case|:
return|return
name|UNLE_EXPR
return|;
case|case
name|COMPCODE_UNGT
case|:
return|return
name|UNGT_EXPR
return|;
case|case
name|COMPCODE_LTGT
case|:
return|return
name|LTGT_EXPR
return|;
case|case
name|COMPCODE_UNGE
case|:
return|return
name|UNGE_EXPR
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a tree for the comparison which is the combination of    doing the AND or OR (depending on CODE) of the two operations LCODE    and RCODE on the identical operands LL_ARG and LR_ARG.  Take into account    the possibility of trapping if the mode has NaNs, and return NULL_TREE    if this makes the transformation invalid.  */
end_comment

begin_function
name|tree
name|combine_comparisons
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|enum
name|tree_code
name|lcode
parameter_list|,
name|enum
name|tree_code
name|rcode
parameter_list|,
name|tree
name|truth_type
parameter_list|,
name|tree
name|ll_arg
parameter_list|,
name|tree
name|lr_arg
parameter_list|)
block|{
name|bool
name|honor_nans
init|=
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|comparison_code
name|lcompcode
init|=
name|comparison_to_compcode
argument_list|(
name|lcode
argument_list|)
decl_stmt|;
name|enum
name|comparison_code
name|rcompcode
init|=
name|comparison_to_compcode
argument_list|(
name|rcode
argument_list|)
decl_stmt|;
name|enum
name|comparison_code
name|compcode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|compcode
operator|=
name|lcompcode
operator|&
name|rcompcode
expr_stmt|;
break|break;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
name|compcode
operator|=
name|lcompcode
operator||
name|rcompcode
expr_stmt|;
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|honor_nans
condition|)
block|{
comment|/* Eliminate unordered comparisons, as well as LTGT and ORD 	 which are not used unless the mode has NaNs.  */
name|compcode
operator|&=
operator|~
name|COMPCODE_UNORD
expr_stmt|;
if|if
condition|(
name|compcode
operator|==
name|COMPCODE_LTGT
condition|)
name|compcode
operator|=
name|COMPCODE_NE
expr_stmt|;
elseif|else
if|if
condition|(
name|compcode
operator|==
name|COMPCODE_ORD
condition|)
name|compcode
operator|=
name|COMPCODE_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_trapping_math
condition|)
block|{
comment|/* Check that the original operation and the optimized ones will trap 	   under the same condition.  */
name|bool
name|ltrap
init|=
operator|(
name|lcompcode
operator|&
name|COMPCODE_UNORD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lcompcode
operator|!=
name|COMPCODE_EQ
operator|)
operator|&&
operator|(
name|lcompcode
operator|!=
name|COMPCODE_ORD
operator|)
decl_stmt|;
name|bool
name|rtrap
init|=
operator|(
name|rcompcode
operator|&
name|COMPCODE_UNORD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|rcompcode
operator|!=
name|COMPCODE_EQ
operator|)
operator|&&
operator|(
name|rcompcode
operator|!=
name|COMPCODE_ORD
operator|)
decl_stmt|;
name|bool
name|trap
init|=
operator|(
name|compcode
operator|&
name|COMPCODE_UNORD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|compcode
operator|!=
name|COMPCODE_EQ
operator|)
operator|&&
operator|(
name|compcode
operator|!=
name|COMPCODE_ORD
operator|)
decl_stmt|;
comment|/* In a short-circuited boolean expression the LHS might be 	   such that the RHS, if evaluated, will never trap.  For 	   example, in ORD (x, y)&& (x< y), we evaluate the RHS only 	   if neither x nor y is NaN.  (This is a mixed blessing: for 	   example, the expression above will never trap, hence 	   optimizing it to x< y would be invalid).  */
if|if
condition|(
operator|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|&&
operator|(
name|lcompcode
operator|&
name|COMPCODE_UNORD
operator|)
operator|)
operator|||
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|&&
operator|!
operator|(
name|lcompcode
operator|&
name|COMPCODE_UNORD
operator|)
operator|)
condition|)
name|rtrap
operator|=
name|false
expr_stmt|;
comment|/* If the comparison was short-circuited, and only the RHS 	   trapped, we may now generate a spurious trap.  */
if|if
condition|(
name|rtrap
operator|&&
operator|!
name|ltrap
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we changed the conditions that cause a trap, we lose.  */
if|if
condition|(
operator|(
name|ltrap
operator|||
name|rtrap
operator|)
operator|!=
name|trap
condition|)
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|compcode
operator|==
name|COMPCODE_TRUE
condition|)
return|return
name|constant_boolean_node
argument_list|(
name|true
argument_list|,
name|truth_type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|compcode
operator|==
name|COMPCODE_FALSE
condition|)
return|return
name|constant_boolean_node
argument_list|(
name|false
argument_list|,
name|truth_type
argument_list|)
return|;
else|else
return|return
name|fold_build2
argument_list|(
name|compcode_to_comparison
argument_list|(
name|compcode
argument_list|)
argument_list|,
name|truth_type
argument_list|,
name|ll_arg
argument_list|,
name|lr_arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if CODE is a tree code that represents a truth value.  */
end_comment

begin_function
specifier|static
name|int
name|truth_value_p
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
operator|||
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if two operands (typically of the same tree node)    are necessarily equal.  If either argument has side-effects this    function returns zero.  FLAGS modifies behavior as follows:     If OEP_ONLY_CONST is set, only return nonzero for constants.    This function tests whether the operands are indistinguishable;    it does not test whether they are equal using C's == operation.    The distinction is important for IEEE floating point, because    (1) -0.0 and 0.0 are distinguishable, but -0.0==0.0, and    (2) two NaNs may be indistinguishable, but NaN!=NaN.     If OEP_ONLY_CONST is unset, a VAR_DECL is considered equal to itself    even though it may hold multiple values during a function.    This is because a GCC tree node guarantees that nothing else is    executed between the evaluation of its "operands" (which may often    be evaluated in arbitrary order).  Hence if the operands themselves    don't side-effect, the VAR_DECLs, PARM_DECLs etc... must hold the    same value in each operand/subexpression.  Hence leaving OEP_ONLY_CONST    unset means assuming isochronic (or instantaneous) tree equivalence.    Unless comparing arbitrary expression trees, such as from different    statements, this flag can usually be left unset.     If OEP_PURE_SAME is set, then pure functions with identical arguments    are considered the same.  It is used when the caller has other ways    to ensure that global memory is unchanged in between.  */
end_comment

begin_function
name|int
name|operand_equal_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
comment|/* If either is ERROR_MARK, they aren't equal.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
comment|/* If both types don't have the same signedness, then we can't consider      them equal.  We must check this before the STRIP_NOPS calls      because they may change the signedness of the arguments.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If both types don't have the same precision, then it is not safe      to strip NOPs.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* In case both args are comparisons but with different comparison      code, try to swap the comparison operands of one arg to produce      a match and compare that variant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
name|COMPARISON_CLASS_P
argument_list|(
name|arg0
argument_list|)
operator|&&
name|COMPARISON_CLASS_P
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|swap_code
init|=
name|swap_tree_comparison
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|swap_code
condition|)
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
comment|/* This is needed for conversions and for COMPONENT_REF. 	 Might as well play it safe and always test this.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.      We don't care about side effects in that case because the SAVE_EXPR      takes care of that for us. In all other cases, two expressions are      equal if they have no side effects.  If we have two identical      expressions with side effects that should be treated the same due      to the only side effects being identical SAVE_EXPR's, that will      be detected in the recursive calls below.  */
if|if
condition|(
name|arg0
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|OEP_ONLY_CONST
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SAVE_EXPR
operator|||
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Next handle constant cases, those for which we can return 1 even      if ONLY_CONST is set.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
operator|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
return|;
case|case
name|REAL_CST
case|:
return|return
operator|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|VECTOR_CST
case|:
block|{
name|tree
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
name|v1
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|v2
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
while|while
condition|(
name|v1
operator|&&
name|v2
condition|)
block|{
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|v1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|v2
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
name|v1
operator|=
name|TREE_CHAIN
argument_list|(
name|v1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|TREE_CHAIN
argument_list|(
name|v2
argument_list|)
expr_stmt|;
block|}
return|return
name|v1
operator|==
name|v2
return|;
block|}
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|STRING_CST
case|:
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|OEP_ONLY_CONST
condition|)
return|return
literal|0
return|;
comment|/* Define macros to test an operand from arg0 and arg1 for equality and a    variant that allows null and views null as being different from any    non-null value.  In the latter case, if either is null, the both    must be; otherwise, do the normal comparison.  */
define|#
directive|define
name|OP_SAME
parameter_list|(
name|N
parameter_list|)
value|operand_equal_p (TREE_OPERAND (arg0, N),	\ 				    TREE_OPERAND (arg1, N), flags)
define|#
directive|define
name|OP_SAME_WITH_NULL
parameter_list|(
name|N
parameter_list|)
define|\
value|((!TREE_OPERAND (arg0, N) || !TREE_OPERAND (arg1, N))	\    ? TREE_OPERAND (arg0, N) == TREE_OPERAND (arg1, N) : OP_SAME (N))
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_unary
case|:
comment|/* Two conversions are equal only if signedness and modes match.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|OP_SAME
argument_list|(
literal|0
argument_list|)
return|;
case|case
name|tcc_comparison
case|:
case|case
name|tcc_binary
case|:
if|if
condition|(
name|OP_SAME
argument_list|(
literal|0
argument_list|)
operator|&&
name|OP_SAME
argument_list|(
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* For commutative ops, allow the other order.  */
return|return
operator|(
name|commutative_tree_code
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|tcc_reference
case|:
comment|/* If either of the pointer (or reference) expressions we are 	 dereferencing contain a side effect, these cannot be equal.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|OP_SAME
argument_list|(
literal|0
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
comment|/* Operands 2 and 3 may be null. 	     Compare the array index by value if it is constant first as we 	     may have different types but same value here.  */
return|return
operator|(
name|OP_SAME
argument_list|(
literal|0
argument_list|)
operator|&&
operator|(
name|tree_int_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|OP_SAME
argument_list|(
literal|1
argument_list|)
operator|)
operator|&&
name|OP_SAME_WITH_NULL
argument_list|(
literal|2
argument_list|)
operator|&&
name|OP_SAME_WITH_NULL
argument_list|(
literal|3
argument_list|)
operator|)
return|;
case|case
name|COMPONENT_REF
case|:
comment|/* Handle operand 2 the same as for ARRAY_REF.  Operand 0 	     may be NULL when we're called to compare MEM_EXPRs.  */
return|return
name|OP_SAME_WITH_NULL
argument_list|(
literal|0
argument_list|)
operator|&&
name|OP_SAME
argument_list|(
literal|1
argument_list|)
operator|&&
name|OP_SAME_WITH_NULL
argument_list|(
literal|2
argument_list|)
return|;
case|case
name|BIT_FIELD_REF
case|:
return|return
name|OP_SAME
argument_list|(
literal|0
argument_list|)
operator|&&
name|OP_SAME
argument_list|(
literal|1
argument_list|)
operator|&&
name|OP_SAME
argument_list|(
literal|2
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|OP_SAME
argument_list|(
literal|0
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|OP_SAME
argument_list|(
literal|0
argument_list|)
operator|&&
name|OP_SAME
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
if|if
condition|(
name|OP_SAME
argument_list|(
literal|0
argument_list|)
operator|&&
name|OP_SAME
argument_list|(
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise take into account this is a commutative operation.  */
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* If the CALL_EXPRs call different functions, then they 	     clearly can not be equal.  */
if|if
condition|(
operator|!
name|OP_SAME
argument_list|(
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|{
name|unsigned
name|int
name|cef
init|=
name|call_expr_flags
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|OEP_PURE_SAME
condition|)
name|cef
operator|&=
name|ECF_CONST
operator||
name|ECF_PURE
expr_stmt|;
else|else
name|cef
operator|&=
name|ECF_CONST
expr_stmt|;
if|if
condition|(
operator|!
name|cef
condition|)
return|return
literal|0
return|;
block|}
comment|/* Now see if all the arguments are the same.  operand_equal_p 	     does not handle TREE_LIST, so we walk the operands here 	     feeding them to operand_equal_p.  */
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg0
operator|&&
name|arg1
condition|)
block|{
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|TREE_CHAIN
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_CHAIN
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* If we get here and both argument lists are exhausted 	     then the CALL_EXPRs are equal.  */
return|return
operator|!
operator|(
name|arg0
operator|||
name|arg1
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
name|tcc_declaration
case|:
comment|/* Consider __builtin_sqrt equal to sqrt.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|arg0
argument_list|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|arg1
argument_list|)
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|arg0
argument_list|)
operator|==
name|DECL_BUILT_IN_CLASS
argument_list|(
name|arg1
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|DECL_FUNCTION_CODE
argument_list|(
name|arg1
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
undef|#
directive|undef
name|OP_SAME
undef|#
directive|undef
name|OP_SAME_WITH_NULL
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to operand_equal_p, but see if ARG0 might have been made by    shorten_compare from ARG1 when ARG1 was being compared with OTHER.     When in doubt, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|operand_equal_for_comparison_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|other
parameter_list|)
block|{
name|int
name|unsignedp1
decl_stmt|,
name|unsignedpo
decl_stmt|;
name|tree
name|primarg0
decl_stmt|,
name|primarg1
decl_stmt|,
name|primother
decl_stmt|;
name|unsigned
name|int
name|correct_width
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Discard any conversions that don't change the modes of ARG0 and ARG1      and see if the inner values are the same.  This removes any      signedness comparison, which doesn't matter here.  */
name|primarg0
operator|=
name|arg0
operator|,
name|primarg1
operator|=
name|arg1
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|primarg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|primarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|primarg0
argument_list|,
name|primarg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Duplicate what shorten_compare does to ARG1 and see if that gives the      actual comparison operand, ARG0.       First throw away any conversions to wider types      already present in the operands.  */
name|primarg1
operator|=
name|get_narrower
argument_list|(
name|arg1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
name|primother
operator|=
name|get_narrower
argument_list|(
name|other
argument_list|,
operator|&
name|unsignedpo
argument_list|)
expr_stmt|;
name|correct_width
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp1
operator|==
name|unsignedpo
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
operator|<
name|correct_width
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primother
argument_list|)
argument_list|)
operator|<
name|correct_width
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primarg1
operator|=
name|fold_convert
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
argument_list|,
name|primarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|primarg1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if ARG is an expression that is either a comparison or is performing    arithmetic on comparisons.  The comparisons must only be comparing    two different values, which will be stored in *CVAL1 and *CVAL2; if    they are nonzero it means that some operands have already been found.    No variables may be used anywhere else in the expression except in the    comparisons.  If SAVE_P is true it means we removed a SAVE_EXPR around    the expression and save_expr needs to be called with CVAL1 and CVAL2.     If this is true, return 1.  Otherwise, return zero.  */
end_comment

begin_function
specifier|static
name|int
name|twoval_comparison_p
parameter_list|(
name|tree
name|arg
parameter_list|,
name|tree
modifier|*
name|cval1
parameter_list|,
name|tree
modifier|*
name|cval2
parameter_list|,
name|int
modifier|*
name|save_p
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code_class
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the tcc_expression cases here.  */
if|if
condition|(
name|class
operator|==
name|tcc_expression
operator|&&
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|class
operator|=
name|tcc_unary
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
name|tcc_expression
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|COMPOUND_EXPR
operator|)
condition|)
name|class
operator|=
name|tcc_binary
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
name|tcc_expression
operator|&&
name|code
operator|==
name|SAVE_EXPR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If we've already found a CVAL1 or CVAL2, this expression is 	 two complex to handle.  */
if|if
condition|(
operator|*
name|cval1
operator|||
operator|*
name|cval2
condition|)
return|return
literal|0
return|;
name|class
operator|=
name|tcc_unary
expr_stmt|;
operator|*
name|save_p
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|tcc_unary
case|:
return|return
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
return|;
case|case
name|tcc_binary
case|:
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|)
return|;
case|case
name|tcc_constant
case|:
return|return
literal|1
return|;
case|case
name|tcc_expression
case|:
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
case|case
name|tcc_comparison
case|:
comment|/* First see if we can handle the first operand, then the second.  For 	 the second operand, we know *CVAL1 can't be zero.  It must be that 	 one side of the comparison is each of the values; test for the 	 case where this isn't true by failing if the two operands 	 are the same.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|cval1
operator|==
literal|0
condition|)
operator|*
name|cval1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARG is a tree that is known to contain just arithmetic operations and    comparisons.  Evaluate the operations in the tree substituting NEW0 for    any occurrence of OLD0 as an operand of a comparison and likewise for    NEW1 and OLD1.  */
end_comment

begin_function
specifier|static
name|tree
name|eval_subst
parameter_list|(
name|tree
name|arg
parameter_list|,
name|tree
name|old0
parameter_list|,
name|tree
name|new0
parameter_list|,
name|tree
name|old1
parameter_list|,
name|tree
name|new1
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code_class
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the tcc_expression cases here.  */
if|if
condition|(
name|class
operator|==
name|tcc_expression
operator|&&
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|class
operator|=
name|tcc_unary
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
name|tcc_expression
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
condition|)
name|class
operator|=
name|tcc_binary
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|tcc_unary
case|:
return|return
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
return|;
case|case
name|tcc_binary
case|:
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
return|;
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|fold_build3
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* Fall through - ???  */
case|case
name|tcc_comparison
case|:
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We need to check both for exact equality and tree equality.  The 	   former will be true if the operand has a side-effect.  In that 	   case, we know the operand occurred exactly once.  */
if|if
condition|(
name|arg0
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg0
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new1
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg1
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new1
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
default|default:
return|return
name|arg
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the case when the result of an expression is RESULT    converted to TYPE and OMITTED was previously an operand of the expression    but is now not needed (e.g., we folded OMITTED * 0).     If OMITTED has side effects, we must evaluate it.  Otherwise, just do    the conversion of RESULT to TYPE.  */
end_comment

begin_function
name|tree
name|omit_one_operand
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|result
parameter_list|,
name|tree
name|omitted
parameter_list|)
block|{
name|tree
name|t
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_ignored_result
argument_list|(
name|omitted
argument_list|)
argument_list|,
name|t
argument_list|)
return|;
return|return
name|non_lvalue
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but call pedantic_non_lvalue instead of non_lvalue.  */
end_comment

begin_function
specifier|static
name|tree
name|pedantic_omit_one_operand
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|result
parameter_list|,
name|tree
name|omitted
parameter_list|)
block|{
name|tree
name|t
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_ignored_result
argument_list|(
name|omitted
argument_list|)
argument_list|,
name|t
argument_list|)
return|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the case when the result of an expression is RESULT    converted to TYPE and OMITTED1 and OMITTED2 were previously operands    of the expression but are now not needed.     If OMITTED1 or OMITTED2 has side effects, they must be evaluated.    If both OMITTED1 and OMITTED2 have side effects, OMITTED1 is    evaluated before OMITTED2.  Otherwise, if neither has side effects,    just do the conversion of RESULT to TYPE.  */
end_comment

begin_function
name|tree
name|omit_two_operands
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|result
parameter_list|,
name|tree
name|omitted1
parameter_list|,
name|tree
name|omitted2
parameter_list|)
block|{
name|tree
name|t
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted2
argument_list|)
condition|)
name|t
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|omitted2
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted1
argument_list|)
condition|)
name|t
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|omitted1
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|COMPOUND_EXPR
condition|?
name|non_lvalue
argument_list|(
name|t
argument_list|)
else|:
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a simplified tree node for the truth-negation of ARG.  This    never alters ARG itself.  We assume that ARG is an operation that    returns a truth value (0 or 1).     FIXME: one would think we would fold the result, but it causes    problems with the dominator optimizer.  */
end_comment

begin_function
name|tree
name|fold_truth_not_expr
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* If this is a comparison, we can simply invert it, except for      floating-point non-equality comparisons, in which case we just      enclose a TRUTH_NOT_EXPR around what we have.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
condition|)
block|{
name|tree
name|op_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|op_type
argument_list|)
operator|&&
name|flag_trapping_math
operator|&&
name|code
operator|!=
name|ORDERED_EXPR
operator|&&
name|code
operator|!=
name|UNORDERED_EXPR
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|&&
name|code
operator|!=
name|EQ_EXPR
condition|)
return|return
name|NULL_TREE
return|;
else|else
block|{
name|code
operator|=
name|invert_tree_comparison
argument_list|(
name|code
argument_list|,
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|op_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|constant_boolean_node
argument_list|(
name|integer_zerop
argument_list|(
name|arg
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
return|return
name|build2
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
return|return
name|build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_XOR_EXPR
case|:
comment|/* Here we can invert either operand.  We invert the first operand 	 unless the second operand is a TRUTH_NOT_EXPR in which case our 	 result is the XOR of the first operand with the inside of the 	 negation of the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
return|return
name|build2
argument_list|(
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build2
argument_list|(
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|build2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
block|{
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* A COND_EXPR may have a throw as one operand, which 	   then has void type.  Just leave void operands 	   as they are.  */
return|return
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|?
name|arg1
else|:
name|invert_truthvalue
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|?
name|arg2
else|:
name|invert_truthvalue
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|COMPOUND_EXPR
case|:
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
operator|!
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
break|break;
return|return
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a simplified tree node for the truth-negation of ARG.  This    never alters ARG itself.  We assume that ARG is an operation that    returns a truth value (0 or 1).     FIXME: one would think we would fold the result, but it causes    problems with the dominator optimizer.  */
end_comment

begin_function
name|tree
name|invert_truthvalue
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|arg
return|;
name|tem
operator|=
name|fold_truth_not_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|tem
operator|=
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Given a bit-wise operation CODE applied to ARG0 and ARG1, see if both    operands are another bit-wise operation with a common input.  If so,    distribute the bit operations to save an operation and possibly two if    constants are involved.  For example, convert 	(A | B)& (A | C) into A | (B& C)    Further simplification will occur if B and C are constants.     If this optimization cannot be done, 0 will be returned.  */
end_comment

begin_function
specifier|static
name|tree
name|distribute_bit_expr
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|common
decl_stmt|;
name|tree
name|left
decl_stmt|,
name|right
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_IOR_EXPR
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|common
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Knowing that ARG0 and ARG1 are both RDIV_EXPRs, simplify a binary operation    with code CODE.  This optimization is unsafe.  */
end_comment

begin_function
specifier|static
name|tree
name|distribute_real_division
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|bool
name|mul0
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
decl_stmt|;
name|bool
name|mul1
init|=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
decl_stmt|;
comment|/* (A / C) +- (B / C) -> (A +- B) / C.  */
if|if
condition|(
name|mul0
operator|==
name|mul1
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|mul0
condition|?
name|MULT_EXPR
else|:
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (A / C1) +- (A / C2) -> A * (1 / C1 +- 1 / C2).  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|REAL_VALUE_TYPE
name|r0
decl_stmt|,
name|r1
decl_stmt|;
name|r0
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|r1
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mul0
condition|)
name|real_arithmetic
argument_list|(
operator|&
name|r0
argument_list|,
name|RDIV_EXPR
argument_list|,
operator|&
name|dconst1
argument_list|,
operator|&
name|r0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mul1
condition|)
name|real_arithmetic
argument_list|(
operator|&
name|r1
argument_list|,
name|RDIV_EXPR
argument_list|,
operator|&
name|dconst1
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|r0
argument_list|,
name|code
argument_list|,
operator|&
name|r0
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|r0
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER    starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero.  */
end_comment

begin_function
specifier|static
name|tree
name|make_bit_field_ref
parameter_list|(
name|tree
name|inner
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|bitsize
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|bitpos
operator|==
literal|0
condition|)
block|{
name|tree
name|size
init|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|)
operator|&&
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
operator|==
name|bitsize
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|inner
argument_list|)
return|;
block|}
name|result
operator|=
name|build3
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|size_int
argument_list|(
name|bitsize
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|bitpos
argument_list|)
argument_list|)
expr_stmt|;
name|BIT_FIELD_REF_UNSIGNED
argument_list|(
name|result
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Optimize a bit-field compare.     There are two cases:  First is a compare against a constant and the    second is a comparison of two items where the fields are at the same    bit position relative to the start of a chunk (byte, halfword, word)    large enough to contain it.  In these cases we can avoid the shift    implicit in bitfield extractions.     For constants, we emit a compare of the shifted constant with the    BIT_AND_EXPR of a mask and a byte, halfword, or word of the operand being    compared.  For two fields at the same position, we do the ANDs with the    similar mask and compare the result of the ANDs.     CODE is the comparison code, known to be either NE_EXPR or EQ_EXPR.    COMPARE_TYPE is the type of the comparison, and LHS and RHS    are the left and right operands of the comparison, respectively.     If the optimization described above can be done, we return the resulting    tree.  Otherwise we return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|optimize_bit_field_compare
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|compare_type
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|HOST_WIDE_INT
name|lbitpos
decl_stmt|,
name|lbitsize
decl_stmt|,
name|rbitpos
decl_stmt|,
name|rbitsize
decl_stmt|,
name|nbitpos
decl_stmt|,
name|nbitsize
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|signed_type
decl_stmt|,
name|unsigned_type
decl_stmt|;
name|int
name|const_p
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
decl_stmt|;
name|enum
name|machine_mode
name|lmode
decl_stmt|,
name|rmode
decl_stmt|,
name|nmode
decl_stmt|;
name|int
name|lunsignedp
decl_stmt|,
name|runsignedp
decl_stmt|;
name|int
name|lvolatilep
init|=
literal|0
decl_stmt|,
name|rvolatilep
init|=
literal|0
decl_stmt|;
name|tree
name|linner
decl_stmt|,
name|rinner
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|mask
decl_stmt|;
name|tree
name|offset
decl_stmt|;
comment|/* Get all the information about the extractions being done.  If the bit size      if the same as the size of the underlying object, we aren't doing an      extraction at all and so can do nothing.  We also don't want to      do anything if the inner expression is a PLACEHOLDER_EXPR since we      then will no longer be able to replace it.  */
name|linner
operator|=
name|get_inner_reference
argument_list|(
name|lhs
argument_list|,
operator|&
name|lbitsize
argument_list|,
operator|&
name|lbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|lmode
argument_list|,
operator|&
name|lunsignedp
argument_list|,
operator|&
name|lvolatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|linner
operator|==
name|lhs
operator|||
name|lbitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|lmode
argument_list|)
operator|||
name|lbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|linner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|const_p
condition|)
block|{
comment|/* If this is not a constant, we can only do something if bit positions, 	sizes, and signedness are the same.  */
name|rinner
operator|=
name|get_inner_reference
argument_list|(
name|rhs
argument_list|,
operator|&
name|rbitsize
argument_list|,
operator|&
name|rbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|rmode
argument_list|,
operator|&
name|runsignedp
argument_list|,
operator|&
name|rvolatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rinner
operator|==
name|rhs
operator|||
name|lbitpos
operator|!=
name|rbitpos
operator|||
name|lbitsize
operator|!=
name|rbitsize
operator|||
name|lunsignedp
operator|!=
name|runsignedp
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|rinner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
block|}
comment|/* See if we can find a mode to refer to this field.  We should be able to,      but fail if we can't.  */
name|nmode
operator|=
name|get_best_mode
argument_list|(
name|lbitsize
argument_list|,
name|lbitpos
argument_list|,
name|const_p
condition|?
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|linner
argument_list|)
argument_list|)
else|:
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|linner
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|rinner
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|lvolatilep
operator|||
name|rvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Set signed and unsigned types of the precision of this mode for the      shifts below.  */
name|signed_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|nmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsigned_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|nmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the bit position and size for the new reference and our offset      within it. If the new reference is the same size as the original, we      won't optimize anything, so return zero.  */
name|nbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|nmode
argument_list|)
expr_stmt|;
name|nbitpos
operator|=
name|lbitpos
operator|&
operator|~
operator|(
name|nbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|lbitpos
operator|-=
name|nbitpos
expr_stmt|;
if|if
condition|(
name|nbitsize
operator|==
name|lbitsize
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|lbitpos
operator|=
name|nbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
expr_stmt|;
comment|/* Make the mask to be used against the extracted field.  */
name|mask
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mask
operator|=
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|mask
operator|=
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|nbitsize
operator|-
name|lbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|nbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|const_p
condition|)
comment|/* If not comparing with constant, just rework the comparison        and return.  */
return|return
name|build2
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|rinner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
return|;
comment|/* Otherwise, we are handling the constant case. See if the constant is too      big for the field.  Warn and return a tree of for 0 (false) if so.  We do      this not only for its own sake, but to avoid having to test for this      error case below.  If we didn't, we might generate wrong code.       For unsigned fields, the constant shifted right by the field length should      be all zero.  For signed fields, the high-order bits should agree with      the sign bit.  */
if|if
condition|(
name|lunsignedp
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison is always %d due to width of bit-field"
argument_list|,
name|code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|code
operator|==
name|NE_EXPR
argument_list|,
name|compare_type
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|signed_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison is always %d due to width of bit-field"
argument_list|,
name|code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|code
operator|==
name|NE_EXPR
argument_list|,
name|compare_type
argument_list|)
return|;
block|}
block|}
comment|/* Single-bit compares should always be against zero.  */
if|if
condition|(
name|lbitsize
operator|==
literal|1
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|code
operator|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
expr_stmt|;
name|rhs
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Make a new bitfield reference, shift the constant over the      appropriate number of bits and mask it with the computed mask      (in case this was a signed field).  If we changed it, make a new one.  */
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvolatilep
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|lhs
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|rhs
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|lhs
argument_list|,
name|mask
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: decode a field reference.     If EXP is a comparison reference, we return the innermost reference.     *PBITSIZE is set to the number of bits in the reference, *PBITPOS is    set to the starting bit number.     If the innermost field can be completely contained in a mode-sized    unit, *PMODE is set to that mode.  Otherwise, it is set to VOIDmode.     *PVOLATILEP is set to 1 if the any expression encountered is volatile;    otherwise it is not changed.     *PUNSIGNEDP is set to the signedness of the field.     *PMASK is set to the mask used.  This is either contained in a    BIT_AND_EXPR or derived from the width of the field.     *PAND_MASK is set to the mask found in a BIT_AND_EXPR, if any.     Return 0 if this is not a component reference or is one that we can't    do anything with.  */
end_comment

begin_function
specifier|static
name|tree
name|decode_field_reference
parameter_list|(
name|tree
name|exp
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pbitsize
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pbitpos
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode
parameter_list|,
name|int
modifier|*
name|punsignedp
parameter_list|,
name|int
modifier|*
name|pvolatilep
parameter_list|,
name|tree
modifier|*
name|pmask
parameter_list|,
name|tree
modifier|*
name|pand_mask
parameter_list|)
block|{
name|tree
name|outer_type
init|=
literal|0
decl_stmt|;
name|tree
name|and_mask
init|=
literal|0
decl_stmt|;
name|tree
name|mask
decl_stmt|,
name|inner
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|unsigned_type
decl_stmt|;
name|unsigned
name|int
name|precision
decl_stmt|;
comment|/* All the optimizations using this function assume integer fields.      There are problems with FP fields since the type_for_size call      below can fail for, e.g., XFmode.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We are interested in the bare arrangement of bits, so strip everything      that doesn't affect the machine mode.  However, record the type of the      outermost expression if it may matter below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|outer_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
name|and_mask
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|and_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|and_mask
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
block|}
name|inner
operator|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
name|pbitsize
argument_list|,
name|pbitpos
argument_list|,
operator|&
name|offset
argument_list|,
name|pmode
argument_list|,
name|punsignedp
argument_list|,
name|pvolatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inner
operator|==
name|exp
operator|&&
name|and_mask
operator|==
literal|0
operator|)
operator|||
operator|*
name|pbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
comment|/* If the number of bits in the reference is the same as the bitsize of      the outer type, then the outer type gives the signedness. Otherwise      (in case of a small bitfield) the signedness is unchanged.  */
if|if
condition|(
name|outer_type
operator|&&
operator|*
name|pbitsize
operator|==
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
condition|)
operator|*
name|punsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|outer_type
argument_list|)
expr_stmt|;
comment|/* Compute the mask to access the bitfield.  */
name|unsigned_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
operator|*
name|pbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type
argument_list|)
expr_stmt|;
name|mask
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mask
operator|=
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge it with the mask we found in the BIT_AND_EXPR, if any.  */
if|if
condition|(
name|and_mask
operator|!=
literal|0
condition|)
name|mask
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|and_mask
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|pmask
operator|=
name|mask
expr_stmt|;
operator|*
name|pand_mask
operator|=
name|and_mask
expr_stmt|;
return|return
name|inner
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if MASK represents a mask of SIZE ones in the low-order    bit positions.  */
end_comment

begin_function
specifier|static
name|int
name|all_ones_mask_p
parameter_list|(
name|tree
name|mask
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|tmask
decl_stmt|;
name|tmask
operator|=
name|build_int_cst
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tmask
operator|=
name|force_fit_type
argument_list|(
name|tmask
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|tree_int_cst_equal
argument_list|(
name|mask
argument_list|,
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tmask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for fold: determine if VAL is the INTEGER_CONST that    represents the sign bit of EXP's type.  If EXP represents a sign    or zero extension, also test VAL against the unextended type.    The return value is the (sub)expression whose sign bit is VAL,    or NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|sign_bit_p
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask_lo
decl_stmt|,
name|lo
decl_stmt|;
name|HOST_WIDE_INT
name|mask_hi
decl_stmt|,
name|hi
decl_stmt|;
name|int
name|width
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Tree EXP must have an integral type.  */
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Tree VAL must be an integer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|width
operator|=
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|mask_hi
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
operator|)
expr_stmt|;
name|mask_lo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
expr_stmt|;
name|mask_hi
operator|=
literal|0
expr_stmt|;
name|mask_lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
operator|)
expr_stmt|;
block|}
comment|/* We mask off those bits beyond TREE_TYPE (exp) so that we can      treat VAL as if it were unsigned.  */
if|if
condition|(
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|&
name|mask_hi
operator|)
operator|==
name|hi
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|&
name|mask_lo
operator|)
operator|==
name|lo
condition|)
return|return
name|exp
return|;
comment|/* Handle extension from a narrower type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|width
condition|)
return|return
name|sign_bit_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for fold_truthop: determine if an operand is simple enough    to be evaluated unconditionally.  */
end_comment

begin_function
specifier|static
name|int
name|simple_operand_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
comment|/* Strip any conversions that don't change the machine mode.  */
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
operator|(
name|CONSTANT_CLASS_P
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SSA_NAME
operator|||
operator|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_NONLOCAL
argument_list|(
name|exp
argument_list|)
comment|/* Don't regard global variables as simple.  They may be 		 allocated in ways unknown to the compiler (shared memory, 		 #pragma weak, etc).  */
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
comment|/* Loading a static variable is unduly expensive, but global 		 registers aren't expensive.  */
operator|&&
operator|(
operator|!
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_REGISTER
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are subroutines to fold_range_test and allow it to    try to change a logical combination of comparisons into a range test.     For example, both 	X == 2 || X == 3 || X == 4 || X == 5    and 	X>= 2&& X<= 5    are converted to 	(unsigned) (X - 2)<= 3     We describe each set of comparisons as being either inside or outside    a range, using a variable named like IN_P, and then describe the    range with a lower and upper bound.  If one of the bounds is omitted,    it represents either the highest or lowest value of the type.     In the comments below, we represent a range by two numbers in brackets    preceded by a "+" to designate being inside that range, or a "-" to    designate being outside that range, so the condition can be inverted by    flipping the prefix.  An omitted bound is represented by a "-".  For    example, "- [-, 10]" means being outside the range starting at the lowest    possible value and ending at 10, in other words, being greater than 10.    The range "+ [-, -]" is always true and hence the range "- [-, -]" is    always false.     We set up things so that the missing bounds are handled in a consistent    manner so neither a missing bound nor "true" and "false" need to be    handled using a special case.  */
end_comment

begin_comment
comment|/* Return the result of applying CODE to ARG0 and ARG1, but handle the case    of ARG0 and/or ARG1 being omitted, meaning an unlimited range. UPPER0_P    and UPPER1_P are nonzero if the respective argument is an upper bound    and zero for a lower.  TYPE, if nonzero, is the type of the result; it    must be specified for a comparison.  ARG1 will be converted to ARG0's    type if both are specified.  */
end_comment

begin_function
specifier|static
name|tree
name|range_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|int
name|upper0_p
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|int
name|upper1_p
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|sgn0
decl_stmt|,
name|sgn1
decl_stmt|;
comment|/* If neither arg represents infinity, do the normal operation.      Else, if not a comparison, return infinity.  Else handle the special      comparison rules. Note that most of the cases below won't occur, but      are handled for consistency.  */
if|if
condition|(
name|arg0
operator|!=
literal|0
operator|&&
name|arg1
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
operator|!=
literal|0
condition|?
name|type
else|:
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
condition|?
name|tem
else|:
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|tcc_comparison
condition|)
return|return
literal|0
return|;
comment|/* Set SGN[01] to -1 if ARG[01] is a lower bound, 1 for upper, and 0      for neither.  In real maths, we cannot assume open ended ranges are      the same. But, this is computer arithmetic, where numbers are finite.      We can therefore make the transformation of any unbounded range with      the value Z, Z being greater than any representable number. This permits      us to treat unbounded ranges as equal.  */
name|sgn0
operator|=
name|arg0
operator|!=
literal|0
condition|?
literal|0
else|:
operator|(
name|upper0_p
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|sgn1
operator|=
name|arg1
operator|!=
literal|0
condition|?
literal|0
else|:
operator|(
name|upper1_p
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|result
operator|=
name|sgn0
operator|==
name|sgn1
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|!=
name|sgn1
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|result
operator|=
name|sgn0
operator|<
name|sgn1
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|<=
name|sgn1
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|result
operator|=
name|sgn0
operator|>
name|sgn1
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|>=
name|sgn1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|constant_boolean_node
argument_list|(
name|result
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given EXP, a logical expression, set the range it is testing into    variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression    actually being tested.  *PLOW and *PHIGH will be made of the same    type as the returned expression.  If EXP is not a comparison, we    will most likely not be returning a useful value and range.  Set    *STRICT_OVERFLOW_P to true if the return value is only valid    because signed overflow is undefined; otherwise, do not change    *STRICT_OVERFLOW_P.  */
end_comment

begin_function
specifier|static
name|tree
name|make_range
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
modifier|*
name|pin_p
parameter_list|,
name|tree
modifier|*
name|plow
parameter_list|,
name|tree
modifier|*
name|phigh
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg0
init|=
name|NULL_TREE
decl_stmt|,
name|arg1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|exp_type
init|=
name|NULL_TREE
decl_stmt|,
name|arg0_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|in_p
decl_stmt|,
name|n_in_p
decl_stmt|;
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|,
name|n_low
decl_stmt|,
name|n_high
decl_stmt|;
comment|/* Start with simply saying "EXP != 0" and then look at the code of EXP      and see if we can refine the range.  Some of the cases below may not      happen, but it doesn't seem worth worrying about this.  We "continue"      the outer loop when we've changed something; otherwise we "break"      the switch, which will "break" the while.  */
name|in_p
operator|=
literal|0
expr_stmt|;
name|low
operator|=
name|high
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|>
literal|0
condition|)
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
condition|)
name|arg0_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_expression
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|>
literal|1
operator|)
condition|)
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUTH_NOT_EXPR
case|:
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
comment|/* We can only do something if the range is testing for zero 	     and if the second operand is an integer constant.  Note that 	     saying something is "in" the range we make is done by 	     complementing IN_P since it will set in the initial case of 	     being not equal to zero; "out" is leaving it alone.  */
if|if
condition|(
name|low
operator|==
literal|0
operator|||
name|high
operator|==
literal|0
operator|||
operator|!
name|integer_zerop
argument_list|(
name|low
argument_list|)
operator|||
operator|!
name|integer_zerop
argument_list|(
name|high
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE_EXPR
case|:
comment|/* - [c, c]  */
name|low
operator|=
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
comment|/* + [c, c]  */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
comment|/* - [-, c] */
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
comment|/* + [c, -] */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
name|arg1
operator|,
name|high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
comment|/* - [c, -] */
name|low
operator|=
name|arg1
operator|,
name|high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
comment|/* + [-, c] */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If this is an unsigned comparison, we also know that EXP is 	     greater than or equal to zero.  We base the range tests we make 	     on that fact, so we record it here so we can parse existing 	     range tests.  We test arg0_type since often the return type 	     of, e.g. EQ_EXPR, is boolean.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|arg0_type
argument_list|)
operator|&&
operator|(
name|low
operator|==
literal|0
operator|||
name|high
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
name|in_p
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|build_int_cst
argument_list|(
name|arg0_type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
break|break;
name|in_p
operator|=
name|n_in_p
operator|,
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
comment|/* If the high bound is missing, but we have a nonzero low 		 bound, reverse the range so it goes from zero to the low bound 		 minus 1.  */
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|in_p
operator|=
operator|!
name|in_p
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|low
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|low
operator|=
name|build_int_cst
argument_list|(
name|arg0_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|NEGATE_EXPR
case|:
comment|/* (-x) IN [a,b] -> x in [-b, -a]  */
name|n_low
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|exp_type
argument_list|,
name|build_int_cst
argument_list|(
name|exp_type
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|high
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n_high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|exp_type
argument_list|,
name|build_int_cst
argument_list|(
name|exp_type
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* ~ X -> -X - 1  */
name|exp
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|exp_type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|exp_type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
comment|/* If flag_wrapv and ARG0_TYPE is signed, then we cannot 	     move a constant to the other side.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|arg0_type
argument_list|)
operator|&&
operator|!
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|arg0_type
argument_list|)
condition|)
break|break;
comment|/* If EXP is signed, any overflow in the computation is undefined, 	     so we don't worry about it so long as our computations on 	     the bounds don't overflow.  For unsigned, overflow is defined 	     and this is exactly the right thing.  */
name|n_low
operator|=
name|range_binop
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|,
name|arg0_type
argument_list|,
name|low
argument_list|,
literal|0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_high
operator|=
name|range_binop
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|,
name|arg0_type
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_low
operator|!=
literal|0
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|n_low
argument_list|)
operator|)
operator|||
operator|(
name|n_high
operator|!=
literal|0
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|n_high
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|arg0_type
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
comment|/* Check for an unsigned range which has wrapped around the maximum 	     value thus making n_high< n_low, and normalize it.  */
if|if
condition|(
name|n_low
operator|&&
name|n_high
operator|&&
name|tree_int_cst_lt
argument_list|(
name|n_high
argument_list|,
name|n_low
argument_list|)
condition|)
block|{
name|low
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg0_type
argument_list|,
name|n_high
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0_type
argument_list|,
name|n_low
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the range is of the form +/- [ x+1, x ], we won't 		 be able to normalize it.  But then, it represents the 		 whole range or the empty set, so make it 		 +/- [ -, - ].  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|n_low
argument_list|,
name|low
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|n_high
argument_list|,
name|high
argument_list|)
condition|)
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
else|else
name|in_p
operator|=
operator|!
name|in_p
expr_stmt|;
block|}
else|else
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|arg0_type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|exp_type
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|arg0_type
argument_list|)
operator|||
operator|(
name|low
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|low
argument_list|,
name|arg0_type
argument_list|)
operator|)
operator|||
operator|(
name|high
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|high
argument_list|,
name|arg0_type
argument_list|)
operator|)
condition|)
break|break;
name|n_low
operator|=
name|low
operator|,
name|n_high
operator|=
name|high
expr_stmt|;
if|if
condition|(
name|n_low
operator|!=
literal|0
condition|)
name|n_low
operator|=
name|fold_convert
argument_list|(
name|arg0_type
argument_list|,
name|n_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_high
operator|!=
literal|0
condition|)
name|n_high
operator|=
name|fold_convert
argument_list|(
name|arg0_type
argument_list|,
name|n_high
argument_list|)
expr_stmt|;
comment|/* If we're converting arg0 from an unsigned type, to exp, 	     a signed type,  we will be doing the comparison as unsigned. 	     The tests above have already verified that LOW and HIGH 	     are both positive.  	     So we have to ensure that we will handle large unsigned 	     values the same way that the current signed bounds treat 	     negative values.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|exp_type
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|arg0_type
argument_list|)
condition|)
block|{
name|tree
name|high_positive
decl_stmt|;
name|tree
name|equiv_type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|arg0_type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* A range without an upper bound is, naturally, unbounded. 		 Since convert would have cropped a very large value, use 		 the max value for the destination type.  */
name|high_positive
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|equiv_type
argument_list|)
condition|?
name|TYPE_MAX_VALUE
argument_list|(
name|equiv_type
argument_list|)
else|:
name|TYPE_MAX_VALUE
argument_list|(
name|arg0_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|exp_type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|arg0_type
argument_list|)
condition|)
name|high_positive
operator|=
name|fold_build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|arg0_type
argument_list|,
name|fold_convert
argument_list|(
name|arg0_type
argument_list|,
name|high_positive
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|arg0_type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the low bound is specified, "and" the range with the 		 range for which the original unsigned value will be 		 positive.  */
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
literal|1
argument_list|,
name|n_low
argument_list|,
name|n_high
argument_list|,
literal|1
argument_list|,
name|fold_convert
argument_list|(
name|arg0_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|high_positive
argument_list|)
condition|)
break|break;
name|in_p
operator|=
operator|(
name|n_in_p
operator|==
name|in_p
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, "or" the range with the range of the input 		     that will be interpreted as negative.  */
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
literal|0
argument_list|,
name|n_low
argument_list|,
name|n_high
argument_list|,
literal|1
argument_list|,
name|fold_convert
argument_list|(
name|arg0_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|high_positive
argument_list|)
condition|)
break|break;
name|in_p
operator|=
operator|(
name|in_p
operator|!=
name|n_in_p
operator|)
expr_stmt|;
block|}
block|}
name|exp
operator|=
name|arg0
expr_stmt|;
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* If EXP is a constant, we can evaluate whether this is true or false.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|in_p
operator|=
name|in_p
operator|==
operator|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
name|high
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|pin_p
operator|=
name|in_p
operator|,
operator|*
name|plow
operator|=
name|low
operator|,
operator|*
name|phigh
operator|=
name|high
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a range, LOW, HIGH, and IN_P, an expression, EXP, and a result    type, TYPE, return an expression to test if EXP is in (or out of, depending    on IN_P) the range.  Return 0 if the test couldn't be created.  */
end_comment

begin_function
specifier|static
name|tree
name|build_range_check
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|exp
parameter_list|,
name|int
name|in_p
parameter_list|,
name|tree
name|low
parameter_list|,
name|tree
name|high
parameter_list|)
block|{
name|tree
name|etype
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
comment|/* Disable this optimization for function pointer expressions      on targets that require function pointer canonicalization.  */
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|etype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|etype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|NULL_TREE
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|in_p
condition|)
block|{
name|value
operator|=
name|build_range_check
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|invert_truthvalue
argument_list|(
name|value
argument_list|)
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
name|high
operator|==
literal|0
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|high
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|high
operator|==
literal|0
condition|)
return|return
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|low
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|low
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|low
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|etype
argument_list|)
condition|)
block|{
name|etype
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|etype
argument_list|)
expr_stmt|;
name|high
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|high
argument_list|)
return|;
block|}
comment|/* Optimize (c>=1)&& (c<=127) into (signed char)c> 0.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|low
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|high
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|etype
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|lo
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|high
argument_list|)
operator|==
name|hi
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|high
argument_list|)
operator|==
name|lo
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|etype
argument_list|)
condition|)
block|{
name|etype
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|etype
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|build_int_cst
argument_list|(
name|etype
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Optimize (c>=low)&& (c<=high) into (c-low>=0)&& (c-low<=high-low).      This requires wrap-around arithmetics for the type of the expression.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|etype
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
comment|/* There is no requirement that LOW be within the range of ETYPE 	 if the latter is a subtype.  It must, however, be within the base 	 type of ETYPE.  So be sure we do the subtraction in that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|etype
argument_list|)
condition|)
name|etype
operator|=
name|TREE_TYPE
argument_list|(
name|etype
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
name|etype
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|etype
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|etype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If we don't have wrap-around arithmetics upfront, try to force it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|etype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|!
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|etype
argument_list|)
condition|)
block|{
name|tree
name|utype
decl_stmt|,
name|minv
decl_stmt|,
name|maxv
decl_stmt|;
comment|/* Check if (unsigned) INT_MAX + 1 == (unsigned) INT_MIN 	 for the type in question, as we rely on this here.  */
name|utype
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|etype
argument_list|)
expr_stmt|;
name|maxv
operator|=
name|fold_convert
argument_list|(
name|utype
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|etype
argument_list|)
argument_list|)
expr_stmt|;
name|maxv
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|maxv
argument_list|,
literal|1
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|minv
operator|=
name|fold_convert
argument_list|(
name|utype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|etype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|range_binop
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|minv
argument_list|,
literal|1
argument_list|,
name|maxv
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|etype
operator|=
name|utype
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|high
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|low
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|value
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|etype
argument_list|,
name|exp
argument_list|,
name|low
argument_list|)
argument_list|,
literal|1
argument_list|,
name|build_int_cst
argument_list|(
name|etype
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the predecessor of VAL in its type, handling the infinite case.  */
end_comment

begin_function
specifier|static
name|tree
name|range_predecessor
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the successor of VAL in its type, handling the infinite case.  */
end_comment

begin_function
specifier|static
name|tree
name|range_successor
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given two ranges, see if we can merge them into one.  Return 1 if we    can, 0 if we can't.  Set the output range into the specified parameters.  */
end_comment

begin_function
specifier|static
name|int
name|merge_ranges
parameter_list|(
name|int
modifier|*
name|pin_p
parameter_list|,
name|tree
modifier|*
name|plow
parameter_list|,
name|tree
modifier|*
name|phigh
parameter_list|,
name|int
name|in0_p
parameter_list|,
name|tree
name|low0
parameter_list|,
name|tree
name|high0
parameter_list|,
name|int
name|in1_p
parameter_list|,
name|tree
name|low1
parameter_list|,
name|tree
name|high1
parameter_list|)
block|{
name|int
name|no_overlap
decl_stmt|;
name|int
name|subset
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|int
name|in_p
decl_stmt|;
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|lowequal
init|=
operator|(
operator|(
name|low0
operator|==
literal|0
operator|&&
name|low1
operator|==
literal|0
operator|)
operator|||
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low0
argument_list|,
literal|0
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|highequal
init|=
operator|(
operator|(
name|high0
operator|==
literal|0
operator|&&
name|high1
operator|==
literal|0
operator|)
operator|||
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Make range 0 be the range that starts first, or ends last if they      start at the same value.  Swap them if it isn't.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low0
argument_list|,
literal|0
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|lowequal
operator|&&
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|in0_p
operator|,
name|in0_p
operator|=
name|in1_p
operator|,
name|in1_p
operator|=
name|temp
expr_stmt|;
name|tem
operator|=
name|low0
operator|,
name|low0
operator|=
name|low1
operator|,
name|low1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|high0
operator|,
name|high0
operator|=
name|high1
operator|,
name|high1
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Now flag two cases, whether the ranges are disjoint or whether the      second range is totally subsumed in the first.  Note that the tests      below are simplified by the ones above.  */
name|no_overlap
operator|=
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|subset
operator|=
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We now have four cases, depending on whether we are including or      excluding the two ranges.  */
if|if
condition|(
name|in0_p
operator|&&
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is false.  If the second range 	 is a subset it is the result.  Otherwise, the range is from the start 	 of the second to the end of the first.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
else|else
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in0_p
operator|&&
operator|!
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is the first range.  If they are 	 equal, the result is false.  If the second range is a subset of the 	 first, and the ranges begin at the same place, we go from just after 	 the end of the second range to the end of the first.  If the second 	 range is not a subset of the first, or if it is a subset and both 	 ranges end at the same place, the range starts at the start of the 	 first range and ends just before the second range. 	 Otherwise, we can't describe this as a single range.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high0
expr_stmt|;
elseif|else
if|if
condition|(
name|lowequal
operator|&&
name|highequal
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
operator|&&
name|lowequal
condition|)
block|{
name|low
operator|=
name|range_successor
argument_list|(
name|high1
argument_list|)
expr_stmt|;
name|high
operator|=
name|high0
expr_stmt|;
name|in_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
block|{
comment|/* We are in the weird situation where high0> high1 but 		 high1 has no successor.  Punt.  */
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|subset
operator|||
name|highequal
condition|)
block|{
name|low
operator|=
name|low0
expr_stmt|;
name|high
operator|=
name|range_predecessor
argument_list|(
name|low1
argument_list|)
expr_stmt|;
name|in_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
condition|)
block|{
comment|/* low0< low1 but low1 has no predecessor.  Punt.  */
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|in0_p
operator|&&
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is the second range.  If the second 	 is a subset of the first, the result is false.  Otherwise, 	 the range starts just after the first range and ends at the 	 end of the second.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
operator|||
name|highequal
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|low
operator|=
name|range_successor
argument_list|(
name|high0
argument_list|)
expr_stmt|;
name|high
operator|=
name|high1
expr_stmt|;
name|in_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
block|{
comment|/* high1> high0 but high0 has no successor.  Punt.  */
return|return
literal|0
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* The case where we are excluding both ranges.  Here the complex case 	 is if they don't overlap.  In that case, the only time we have a 	 range is if they are adjacent.  If the second is a subset of the 	 first, the result is the first.  Otherwise, the range to exclude 	 starts at the beginning of the first range and ends at the end of the 	 second.  */
if|if
condition|(
name|no_overlap
condition|)
block|{
if|if
condition|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|range_successor
argument_list|(
name|high0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high1
expr_stmt|;
else|else
block|{
comment|/* Canonicalize - [min, x] into - [-, x].  */
if|if
condition|(
name|low0
operator|&&
name|TREE_CODE
argument_list|(
name|low0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|low0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|low0
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|low0
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low0
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|low0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|low0
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|low0
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|low0
argument_list|)
condition|)
name|low0
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Canonicalize - [x, max] into - [x, -].  */
if|if
condition|(
name|high1
operator|&&
name|TREE_CODE
argument_list|(
name|high1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|high1
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|high1
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|high1
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|high1
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|high1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|high1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|high1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|high1
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* The ranges might be also adjacent between the maximum and 	         minimum values of the given type.  For 	         - [{min,-}, x] and - [y, {max,-}] ranges where x + 1< y 	         return + [x + 1, y - 1].  */
if|if
condition|(
name|low0
operator|==
literal|0
operator|&&
name|high1
operator|==
literal|0
condition|)
block|{
name|low
operator|=
name|range_successor
argument_list|(
name|high0
argument_list|)
expr_stmt|;
name|high
operator|=
name|range_predecessor
argument_list|(
name|low1
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
operator|||
name|high
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|in_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|subset
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high0
expr_stmt|;
else|else
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high1
expr_stmt|;
block|}
operator|*
name|pin_p
operator|=
name|in_p
operator|,
operator|*
name|plow
operator|=
name|low
operator|,
operator|*
name|phigh
operator|=
name|high
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of fold, looking inside expressions of the form    A op B ? A : C, where ARG0, ARG1 and ARG2 are the three operands    of the COND_EXPR.  This function is being used also to optimize    A op B ? C : A, by reversing the comparison first.     Return a folded expression whose code is not a COND_EXPR    anymore, or NULL_TREE if no folding opportunity is found.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_cond_expr_with_comparison
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|)
block|{
name|enum
name|tree_code
name|comp_code
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1_type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If we have A op 0 ? A : -A, consider applying the following      transformations:       A == 0? A : -A    same as -A      A != 0? A : -A    same as A      A>= 0? A : -A    same as abs (A)      A> 0?  A : -A    same as abs (A)      A<= 0? A : -A    same as -abs (A)      A< 0?  A : -A    same as -abs (A)       None of these transformations work for modes with signed      zeros.  If A is +/-0, the first two transformations will      change the sign of the result (from +0 to -0, or vice      versa).  The last four will fix the sign of the result,      even though the original expressions could be positive or      negative, depending on the sign of A.       Note that all these transformations are correct if A is      NaN, since the two alternatives (A and -A) are also NaNs.  */
if|if
condition|(
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg01
argument_list|)
argument_list|)
condition|?
name|real_zerop
argument_list|(
name|arg01
argument_list|)
else|:
name|integer_zerop
argument_list|(
name|arg01
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|)
comment|/* In the case that A is of the form X-Y, '-A' (arg2) may 	        have already been folded to Y-X, check for that. */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg2
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
name|tem
operator|=
name|fold_convert
argument_list|(
name|arg1_type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|UNGE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
if|if
condition|(
name|flag_trapping_math
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|fold_convert
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
case|case
name|UNLE_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
if|if
condition|(
name|flag_trapping_math
condition|)
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|fold_convert
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|negate_expr
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
default|default:
name|gcc_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|comp_code
argument_list|)
operator|==
name|tcc_comparison
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* A != 0 ? A : 0 is simply A, unless A is -0.  Likewise      A == 0 ? A : 0 is always 0 unless A is -0.  Note that      both transformations are correct when A is NaN: A != 0      is then true, and A == 0 is false.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg01
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
if|if
condition|(
name|comp_code
operator|==
name|NE_EXPR
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|comp_code
operator|==
name|EQ_EXPR
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Try some transformations of A op B ? A : B.       A == B? A : B    same as B      A != B? A : B    same as A      A>= B? A : B    same as max (A, B)      A> B?  A : B    same as max (B, A)      A<= B? A : B    same as min (A, B)      A< B?  A : B    same as min (B, A)       As above, these transformations don't work in the presence      of signed zeros.  For example, if A and B are zeros of      opposite sign, the first two transformations will change      the sign of the result.  In the last four, the original      expressions give different results for (A=+0, B=-0) and      (A=-0, B=+0), but the transformed expressions do not.       The first two transformations are correct if either A or B      is a NaN.  In the first transformation, the condition will      be false, and B will indeed be chosen.  In the case of the      second transformation, the condition A != B will be true,      and A will be chosen.       The conversions to max() and min() are not correct if B is      a number and A is not.  The conditions in the original      expressions will be false, so all four give B.  The min()      and max() versions would give a NaN instead.  */
if|if
condition|(
name|operand_equal_for_comparison_p
argument_list|(
name|arg01
argument_list|,
name|arg2
argument_list|,
name|arg00
argument_list|)
comment|/* Avoid these transformations if the COND_EXPR may be used 	 as an lvalue in the C++ front-end.  PR c++/19199.  */
operator|&&
operator|(
name|in_gimple_form
operator|||
operator|(
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU Objective-C++"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|!
name|maybe_lvalue_p
argument_list|(
name|arg1
argument_list|)
operator|||
operator|!
name|maybe_lvalue_p
argument_list|(
name|arg2
argument_list|)
operator|)
condition|)
block|{
name|tree
name|comp_op0
init|=
name|arg00
decl_stmt|;
name|tree
name|comp_op1
init|=
name|arg01
decl_stmt|;
name|tree
name|comp_type
init|=
name|TREE_TYPE
argument_list|(
name|comp_op0
argument_list|)
decl_stmt|;
comment|/* Avoid adding NOP_EXPRs in case this is an lvalue.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|comp_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|comp_type
operator|=
name|type
expr_stmt|;
name|comp_op0
operator|=
name|arg1
expr_stmt|;
name|comp_op1
operator|=
name|arg2
expr_stmt|;
block|}
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
comment|/* In C++ a ?: expression can be an lvalue, so put the 	     operand which will be used if they are equal first 	     so that we can convert this back to the 	     corresponding COND_EXPR.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|comp_op0
operator|=
name|fold_convert
argument_list|(
name|comp_type
argument_list|,
name|comp_op0
argument_list|)
expr_stmt|;
name|comp_op1
operator|=
name|fold_convert
argument_list|(
name|comp_type
argument_list|,
name|comp_op1
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|comp_code
operator|==
name|LE_EXPR
operator|||
name|comp_code
operator|==
name|UNLE_EXPR
operator|)
condition|?
name|fold_build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|comp_type
argument_list|,
name|comp_op0
argument_list|,
name|comp_op1
argument_list|)
else|:
name|fold_build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|comp_type
argument_list|,
name|comp_op1
argument_list|,
name|comp_op0
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|comp_op0
operator|=
name|fold_convert
argument_list|(
name|comp_type
argument_list|,
name|comp_op0
argument_list|)
expr_stmt|;
name|comp_op1
operator|=
name|fold_convert
argument_list|(
name|comp_type
argument_list|,
name|comp_op1
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|comp_code
operator|==
name|GE_EXPR
operator|||
name|comp_code
operator|==
name|UNGE_EXPR
operator|)
condition|?
name|fold_build2
argument_list|(
name|MAX_EXPR
argument_list|,
name|comp_type
argument_list|,
name|comp_op0
argument_list|,
name|comp_op1
argument_list|)
else|:
name|fold_build2
argument_list|(
name|MAX_EXPR
argument_list|,
name|comp_type
argument_list|,
name|comp_op1
argument_list|,
name|comp_op0
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|UNEQ_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|LTGT_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
break|break;
default|default:
name|gcc_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|comp_code
argument_list|)
operator|==
name|tcc_comparison
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this is A op C1 ? A : C2 with C1 and C2 constant integers,      we might still be able to simplify this.  For example,      if C1 is one less or one more than C2, this might have started      out as a MIN or MAX and been transformed by this function.      Only good for INTEGER_TYPEs, because we need TYPE_MAX_VALUE.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
comment|/* We can replace A with C1 in this case.  */
name|arg1
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg01
argument_list|)
expr_stmt|;
return|return
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
comment|/* If C1 is C2 + 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|LE_EXPR
case|:
comment|/* If C1 is C2 - 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GT_EXPR
case|:
comment|/* If C1 is C2 - 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_build2
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
comment|/* If C1 is C2 + 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_build2
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|NE_EXPR
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|LOGICAL_OP_NON_SHORT_CIRCUIT
end_ifndef

begin_define
define|#
directive|define
name|LOGICAL_OP_NON_SHORT_CIRCUIT
value|(BRANCH_COST>= 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXP is some logical combination of boolean tests.  See if we can    merge it into some range test.  Return the new tree if so.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_range_test
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|int
name|or_op
init|=
operator|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|)
decl_stmt|;
name|int
name|in0_p
decl_stmt|,
name|in1_p
decl_stmt|,
name|in_p
decl_stmt|;
name|tree
name|low0
decl_stmt|,
name|low1
decl_stmt|,
name|low
decl_stmt|,
name|high0
decl_stmt|,
name|high1
decl_stmt|,
name|high
decl_stmt|;
name|bool
name|strict_overflow_p
init|=
name|false
decl_stmt|;
name|tree
name|lhs
init|=
name|make_range
argument_list|(
name|op0
argument_list|,
operator|&
name|in0_p
argument_list|,
operator|&
name|low0
argument_list|,
operator|&
name|high0
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|make_range
argument_list|(
name|op1
argument_list|,
operator|&
name|in1_p
argument_list|,
operator|&
name|low1
argument_list|,
operator|&
name|high1
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|warnmsg
init|=
name|G_
argument_list|(
literal|"assuming signed overflow does not occur "
literal|"when simplifying range test"
argument_list|)
decl_stmt|;
comment|/* If this is an OR operation, invert both sides; we will invert      again at the end.  */
if|if
condition|(
name|or_op
condition|)
name|in0_p
operator|=
operator|!
name|in0_p
operator|,
name|in1_p
operator|=
operator|!
name|in1_p
expr_stmt|;
comment|/* If both expressions are the same, if we can merge the ranges, and we      can build the range test, return it or it inverted.  If one of the      ranges is always true or always false, consider it to be the same      expression as the other.  */
if|if
condition|(
operator|(
name|lhs
operator|==
literal|0
operator|||
name|rhs
operator|==
literal|0
operator|||
name|operand_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|merge_ranges
argument_list|(
operator|&
name|in_p
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|in0_p
argument_list|,
name|low0
argument_list|,
name|high0
argument_list|,
name|in1_p
argument_list|,
name|low1
argument_list|,
name|high1
argument_list|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
operator|(
name|build_range_check
argument_list|(
name|type
argument_list|,
name|lhs
operator|!=
literal|0
condition|?
name|lhs
else|:
name|rhs
operator|!=
literal|0
condition|?
name|rhs
else|:
name|integer_zero_node
argument_list|,
name|in_p
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
name|warnmsg
argument_list|,
name|WARN_STRICT_OVERFLOW_COMPARISON
argument_list|)
expr_stmt|;
return|return
name|or_op
condition|?
name|invert_truthvalue
argument_list|(
name|tem
argument_list|)
else|:
name|tem
return|;
block|}
comment|/* On machines where the branch cost is expensive, if this is a      short-circuited branch and the underlying object on both sides      is the same, make a non-short-circuit operation.  */
elseif|else
if|if
condition|(
name|LOGICAL_OP_NON_SHORT_CIRCUIT
operator|&&
name|lhs
operator|!=
literal|0
operator|&&
name|rhs
operator|!=
literal|0
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If simple enough, just rewrite.  Otherwise, make a SAVE_EXPR 	 unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in 	 which cases we can't do this.  */
if|if
condition|(
name|simple_operand_p
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|tree
name|common
init|=
name|save_expr
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|lhs
operator|=
name|build_range_check
argument_list|(
name|type
argument_list|,
name|common
argument_list|,
name|or_op
condition|?
operator|!
name|in0_p
else|:
name|in0_p
argument_list|,
name|low0
argument_list|,
name|high0
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|rhs
operator|=
name|build_range_check
argument_list|(
name|type
argument_list|,
name|common
argument_list|,
name|or_op
condition|?
operator|!
name|in1_p
else|:
name|in1_p
argument_list|,
name|low1
argument_list|,
name|high1
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
name|warnmsg
argument_list|,
name|WARN_STRICT_OVERFLOW_COMPARISON
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: C is an INTEGER_CST interpreted as a P    bit value.  Arrange things so the extra bits will be set to zero if and    only if C is signed-extended to its full width.  If MASK is nonzero,    it is an INTEGER_CST that should be AND'ed with the extra bits.  */
end_comment

begin_function
specifier|static
name|tree
name|unextend
parameter_list|(
name|tree
name|c
parameter_list|,
name|int
name|p
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|tree
name|mask
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|modesize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|modesize
operator|||
name|unsignedp
condition|)
return|return
name|c
return|;
comment|/* We work by getting just the sign bit into the low-order bit, then      into the high-order bit, then sign-extend.  We then XOR that value      with C.  */
name|temp
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|c
argument_list|,
name|size_int
argument_list|(
name|p
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must use a signed type in order to get an arithmetic right shift.      However, we must also avoid introducing accidental overflows, so that      a subsequent call to integer_zerop will work.  Hence we must      do the type conversion here.  At this point, the constant is either      zero or one, and the conversion to a signed type can never overflow.      We could get an overflow if this conversion is done anywhere else.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|temp
operator|=
name|fold_convert
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|modesize
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|modesize
operator|-
name|p
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|temp
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|temp
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If necessary, convert the type back to match the type of C.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|temp
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|c
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find ways of folding logical expressions of LHS and RHS:    Try to merge two comparisons to the same innermost item.    Look for range tests like "ch>= '0'&& ch<= '9'".    Look for combinations of simple terms on machines with expensive branches    and evaluate the RHS unconditionally.     For example, if we have p->a == 2&& p->b == 4 and we can make an    object large enough to span both A and B, we can do this with a comparison    against the object ANDed with the a mask.     If we have p->a == q->a&& p->b == q->b, we may be able to use bit masking    operations to do this with one comparison.     We check for both normal comparisons and the BIT_AND_EXPRs made this by    function and the one above.     CODE is the logical operation being done.  It can be TRUTH_ANDIF_EXPR,    TRUTH_AND_EXPR, TRUTH_ORIF_EXPR, or TRUTH_OR_EXPR.     TRUTH_TYPE is the type of the logical operand and LHS and RHS are its    two operands.     We return the simplified tree or 0 if no optimization is possible.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_truthop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|truth_type
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
comment|/* If this is the "or" of two comparisons, we can do something if      the comparisons are NE_EXPR.  If this is the "and", we can do something      if the comparisons are EQ_EXPR.  I.e., 	(a->b == 2&& a->c == 4) can become (a->new == NEW).       WANTED_CODE is this operation code.  For single bit fields, we can      convert EQ_EXPR to NE_EXPR so we need not reject the "wrong"      comparison for one-bit fields.  */
name|enum
name|tree_code
name|wanted_code
decl_stmt|;
name|enum
name|tree_code
name|lcode
decl_stmt|,
name|rcode
decl_stmt|;
name|tree
name|ll_arg
decl_stmt|,
name|lr_arg
decl_stmt|,
name|rl_arg
decl_stmt|,
name|rr_arg
decl_stmt|;
name|tree
name|ll_inner
decl_stmt|,
name|lr_inner
decl_stmt|,
name|rl_inner
decl_stmt|,
name|rr_inner
decl_stmt|;
name|HOST_WIDE_INT
name|ll_bitsize
decl_stmt|,
name|ll_bitpos
decl_stmt|,
name|lr_bitsize
decl_stmt|,
name|lr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|rl_bitsize
decl_stmt|,
name|rl_bitpos
decl_stmt|,
name|rr_bitsize
decl_stmt|,
name|rr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|xll_bitpos
decl_stmt|,
name|xlr_bitpos
decl_stmt|,
name|xrl_bitpos
decl_stmt|,
name|xrr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|lnbitsize
decl_stmt|,
name|lnbitpos
decl_stmt|,
name|rnbitsize
decl_stmt|,
name|rnbitpos
decl_stmt|;
name|int
name|ll_unsignedp
decl_stmt|,
name|lr_unsignedp
decl_stmt|,
name|rl_unsignedp
decl_stmt|,
name|rr_unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|ll_mode
decl_stmt|,
name|lr_mode
decl_stmt|,
name|rl_mode
decl_stmt|,
name|rr_mode
decl_stmt|;
name|enum
name|machine_mode
name|lnmode
decl_stmt|,
name|rnmode
decl_stmt|;
name|tree
name|ll_mask
decl_stmt|,
name|lr_mask
decl_stmt|,
name|rl_mask
decl_stmt|,
name|rr_mask
decl_stmt|;
name|tree
name|ll_and_mask
decl_stmt|,
name|lr_and_mask
decl_stmt|,
name|rl_and_mask
decl_stmt|,
name|rr_and_mask
decl_stmt|;
name|tree
name|l_const
decl_stmt|,
name|r_const
decl_stmt|;
name|tree
name|lntype
decl_stmt|,
name|rntype
decl_stmt|,
name|result
decl_stmt|;
name|int
name|first_bit
decl_stmt|,
name|end_bit
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|tree
name|orig_lhs
init|=
name|lhs
decl_stmt|,
name|orig_rhs
init|=
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|orig_code
init|=
name|code
decl_stmt|;
comment|/* Start by getting the comparison codes.  Fail if anything is volatile.      If one operand is a BIT_AND_EXPR with the constant one, treat it as if      it were surrounded with a NE_EXPR.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcode
operator|=
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcode
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lcode
operator|=
name|NE_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|rcode
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rhs
operator|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|rhs
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|NE_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|lcode
argument_list|)
operator|!=
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|rcode
argument_list|)
operator|!=
name|tcc_comparison
condition|)
return|return
literal|0
return|;
name|ll_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rl_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Simplify (x<y)&& (x==y) into (x<=y) and related optimizations.  */
if|if
condition|(
name|simple_operand_p
argument_list|(
name|ll_arg
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|lr_arg
argument_list|)
condition|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|ll_arg
argument_list|,
name|rl_arg
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|lr_arg
argument_list|,
name|rr_arg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|result
operator|=
name|combine_comparisons
argument_list|(
name|code
argument_list|,
name|lcode
argument_list|,
name|rcode
argument_list|,
name|truth_type
argument_list|,
name|ll_arg
argument_list|,
name|lr_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|ll_arg
argument_list|,
name|rr_arg
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|lr_arg
argument_list|,
name|rl_arg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|result
operator|=
name|combine_comparisons
argument_list|(
name|code
argument_list|,
name|lcode
argument_list|,
name|swap_tree_comparison
argument_list|(
name|rcode
argument_list|)
argument_list|,
name|truth_type
argument_list|,
name|ll_arg
argument_list|,
name|lr_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
block|}
name|code
operator|=
operator|(
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|)
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
operator|)
expr_stmt|;
comment|/* If the RHS can be evaluated unconditionally and its operands are      simple, it wins to evaluate the RHS unconditionally on machines      with expensive branches.  In this case, this isn't a comparison      that can be merged.  Avoid doing this if the RHS is a floating-point      comparison since those can trap.  */
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rl_arg
argument_list|)
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|rl_arg
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|rr_arg
argument_list|)
condition|)
block|{
comment|/* Convert (a != 0) || (b != 0) into (a | b) != 0.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_OR_EXPR
operator|&&
name|lcode
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|lr_arg
argument_list|)
operator|&&
name|rcode
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|rr_arg
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|rl_arg
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|,
name|ll_arg
argument_list|,
name|rl_arg
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Convert (a == 0)&& (b == 0) into (a | b) == 0.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|&&
name|lcode
operator|==
name|EQ_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|lr_arg
argument_list|)
operator|&&
name|rcode
operator|==
name|EQ_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|rr_arg
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|rl_arg
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|truth_type
argument_list|,
name|build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|,
name|ll_arg
argument_list|,
name|rl_arg
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|LOGICAL_OP_NON_SHORT_CIRCUIT
condition|)
block|{
if|if
condition|(
name|code
operator|!=
name|orig_code
operator|||
name|lhs
operator|!=
name|orig_lhs
operator|||
name|rhs
operator|!=
name|orig_rhs
condition|)
return|return
name|build2
argument_list|(
name|code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
block|}
comment|/* See if the comparisons can be merged.  Then get all the parameters for      each side.  */
if|if
condition|(
operator|(
name|lcode
operator|!=
name|EQ_EXPR
operator|&&
name|lcode
operator|!=
name|NE_EXPR
operator|)
operator|||
operator|(
name|rcode
operator|!=
name|EQ_EXPR
operator|&&
name|rcode
operator|!=
name|NE_EXPR
operator|)
condition|)
return|return
literal|0
return|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|ll_inner
operator|=
name|decode_field_reference
argument_list|(
name|ll_arg
argument_list|,
operator|&
name|ll_bitsize
argument_list|,
operator|&
name|ll_bitpos
argument_list|,
operator|&
name|ll_mode
argument_list|,
operator|&
name|ll_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|ll_mask
argument_list|,
operator|&
name|ll_and_mask
argument_list|)
expr_stmt|;
name|lr_inner
operator|=
name|decode_field_reference
argument_list|(
name|lr_arg
argument_list|,
operator|&
name|lr_bitsize
argument_list|,
operator|&
name|lr_bitpos
argument_list|,
operator|&
name|lr_mode
argument_list|,
operator|&
name|lr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|lr_mask
argument_list|,
operator|&
name|lr_and_mask
argument_list|)
expr_stmt|;
name|rl_inner
operator|=
name|decode_field_reference
argument_list|(
name|rl_arg
argument_list|,
operator|&
name|rl_bitsize
argument_list|,
operator|&
name|rl_bitpos
argument_list|,
operator|&
name|rl_mode
argument_list|,
operator|&
name|rl_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rl_mask
argument_list|,
operator|&
name|rl_and_mask
argument_list|)
expr_stmt|;
name|rr_inner
operator|=
name|decode_field_reference
argument_list|(
name|rr_arg
argument_list|,
operator|&
name|rr_bitsize
argument_list|,
operator|&
name|rr_bitpos
argument_list|,
operator|&
name|rr_mode
argument_list|,
operator|&
name|rr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rr_mask
argument_list|,
operator|&
name|rr_and_mask
argument_list|)
expr_stmt|;
comment|/* It must be true that the inner operation on the lhs of each      comparison must be the same if we are to be able to do anything.      Then see if we have constants.  If not, the same must be true for      the rhs's.  */
if|if
condition|(
name|volatilep
operator|||
name|ll_inner
operator|==
literal|0
operator|||
name|rl_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|ll_inner
argument_list|,
name|rl_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lr_arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|rr_arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|l_const
operator|=
name|lr_arg
operator|,
name|r_const
operator|=
name|rr_arg
expr_stmt|;
elseif|else
if|if
condition|(
name|lr_inner
operator|==
literal|0
operator|||
name|rr_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|lr_inner
argument_list|,
name|rr_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|l_const
operator|=
name|r_const
operator|=
literal|0
expr_stmt|;
comment|/* If either comparison code is not correct for our logical operation,      fail.  However, we can convert a one-bit comparison against zero into      the opposite comparison against that bit being set in the field.  */
name|wanted_code
operator|=
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|lcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|l_const
operator|&&
name|integer_zerop
argument_list|(
name|l_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|ll_mask
argument_list|)
condition|)
block|{
comment|/* Make the left operand unsigned, since we are only interested 	     in the value of one bit.  Otherwise we are doing the wrong 	     thing below.  */
name|ll_unsignedp
operator|=
literal|1
expr_stmt|;
name|l_const
operator|=
name|ll_mask
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* This is analogous to the code for l_const above.  */
if|if
condition|(
name|rcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|r_const
operator|&&
name|integer_zerop
argument_list|(
name|r_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|rl_mask
argument_list|)
condition|)
block|{
name|rl_unsignedp
operator|=
literal|1
expr_stmt|;
name|r_const
operator|=
name|rl_mask
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* After this point all optimizations will generate bit-field      references, which we might not want.  */
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|can_use_bit_fields_p
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* See if we can find a mode that contains both fields being compared on      the left.  If we can't, fail.  Otherwise, update all constants and masks      to be relative to a field of that size.  */
name|first_bit
operator|=
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|ll_bitpos
operator|+
name|ll_bitsize
argument_list|,
name|rl_bitpos
operator|+
name|rl_bitsize
argument_list|)
expr_stmt|;
name|lnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|lnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|lnmode
argument_list|)
expr_stmt|;
name|lnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|lnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|lntype
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|lnbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xll_bitpos
operator|=
name|ll_bitpos
operator|-
name|lnbitpos
operator|,
name|xrl_bitpos
operator|=
name|rl_bitpos
operator|-
name|lnbitpos
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|xll_bitpos
operator|=
name|lnbitsize
operator|-
name|xll_bitpos
operator|-
name|ll_bitsize
expr_stmt|;
name|xrl_bitpos
operator|=
name|lnbitsize
operator|-
name|xrl_bitpos
operator|-
name|rl_bitsize
expr_stmt|;
block|}
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|ll_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|rl_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_const
condition|)
block|{
name|l_const
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|l_const
argument_list|)
expr_stmt|;
name|l_const
operator|=
name|unextend
argument_list|(
name|l_const
argument_list|,
name|ll_bitsize
argument_list|,
name|ll_unsignedp
argument_list|,
name|ll_and_mask
argument_list|)
expr_stmt|;
name|l_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|l_const
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|l_const
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|lntype
argument_list|,
name|ll_mask
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison is always %d"
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|wanted_code
operator|==
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|r_const
condition|)
block|{
name|r_const
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|r_const
argument_list|)
expr_stmt|;
name|r_const
operator|=
name|unextend
argument_list|(
name|r_const
argument_list|,
name|rl_bitsize
argument_list|,
name|rl_unsignedp
argument_list|,
name|rl_and_mask
argument_list|)
expr_stmt|;
name|r_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|r_const
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|r_const
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|lntype
argument_list|,
name|rl_mask
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison is always %d"
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|wanted_code
operator|==
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|)
return|;
block|}
block|}
comment|/* If the right sides are not constant, do the same for it.  Also,      disallow this optimization if a size or signedness mismatch occurs      between the left and right sides.  */
if|if
condition|(
name|l_const
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ll_bitsize
operator|!=
name|lr_bitsize
operator|||
name|rl_bitsize
operator|!=
name|rr_bitsize
operator|||
name|ll_unsignedp
operator|!=
name|lr_unsignedp
operator|||
name|rl_unsignedp
operator|!=
name|rr_unsignedp
comment|/* Make sure the two fields on the right 	     correspond to the left without being swapped.  */
operator|||
name|ll_bitpos
operator|-
name|rl_bitpos
operator|!=
name|lr_bitpos
operator|-
name|rr_bitpos
condition|)
return|return
literal|0
return|;
name|first_bit
operator|=
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|lr_bitpos
operator|+
name|lr_bitsize
argument_list|,
name|rr_bitpos
operator|+
name|rr_bitsize
argument_list|)
expr_stmt|;
name|rnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|lr_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|rnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|rnmode
argument_list|)
expr_stmt|;
name|rnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|rnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|rntype
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|rnbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xlr_bitpos
operator|=
name|lr_bitpos
operator|-
name|rnbitpos
operator|,
name|xrr_bitpos
operator|=
name|rr_bitpos
operator|-
name|rnbitpos
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|xlr_bitpos
operator|=
name|rnbitsize
operator|-
name|xlr_bitpos
operator|-
name|lr_bitsize
expr_stmt|;
name|xrr_bitpos
operator|=
name|rnbitsize
operator|-
name|xrr_bitpos
operator|-
name|rr_bitsize
expr_stmt|;
block|}
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|lr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xlr_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|rr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrr_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a mask that corresponds to both fields being compared. 	 Do this for both items being compared.  If the operands are the 	 same size and the bits being compared are in the same position 	 then we can do this by masking both and comparing the masked 	 results.  */
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|lr_mask
argument_list|,
name|rr_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnbitsize
operator|==
name|rnbitsize
operator|&&
name|xll_bitpos
operator|==
name|xlr_bitpos
condition|)
block|{
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
name|lhs
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|lntype
argument_list|,
name|lhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|rntype
argument_list|,
name|rnbitsize
argument_list|,
name|rnbitpos
argument_list|,
name|lr_unsignedp
operator|||
name|rr_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|lr_mask
argument_list|,
name|rnbitsize
argument_list|)
condition|)
name|rhs
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|rntype
argument_list|,
name|rhs
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* There is still another way we can do something:  If both pairs of 	 fields being compared are adjacent, we may be able to make a wider 	 field containing them both.  	 Note that we still must mask the lhs/rhs expressions.  Furthermore, 	 the mask must be shifted to account for the shift done by 	 make_bit_field_ref.  */
if|if
condition|(
operator|(
name|ll_bitsize
operator|+
name|ll_bitpos
operator|==
name|rl_bitpos
operator|&&
name|lr_bitsize
operator|+
name|lr_bitpos
operator|==
name|rr_bitpos
operator|)
operator|||
operator|(
name|ll_bitpos
operator|==
name|rl_bitpos
operator|+
name|rl_bitsize
operator|&&
name|lr_bitpos
operator|==
name|rr_bitpos
operator|+
name|rr_bitsize
operator|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|ll_bitsize
operator|+
name|rl_bitsize
argument_list|,
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
argument_list|,
name|ll_unsignedp
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|rntype
argument_list|,
name|lr_bitsize
operator|+
name|rr_bitsize
argument_list|,
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
argument_list|,
name|lr_unsignedp
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|size_int
argument_list|(
name|MIN
argument_list|(
name|xll_bitpos
argument_list|,
name|xrl_bitpos
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|lr_mask
argument_list|,
name|size_int
argument_list|(
name|MIN
argument_list|(
name|xlr_bitpos
argument_list|,
name|xrr_bitpos
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert to the smaller type before masking out unwanted bits.  */
name|type
operator|=
name|lntype
expr_stmt|;
if|if
condition|(
name|lntype
operator|!=
name|rntype
condition|)
block|{
if|if
condition|(
name|lnbitsize
operator|>
name|rnbitsize
condition|)
block|{
name|lhs
operator|=
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
name|type
operator|=
name|rntype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lnbitsize
operator|<
name|rnbitsize
condition|)
block|{
name|rhs
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
name|type
operator|=
name|lntype
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|ll_bitsize
operator|+
name|rl_bitsize
argument_list|)
condition|)
name|lhs
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|lr_mask
argument_list|,
name|lr_bitsize
operator|+
name|rr_bitsize
argument_list|)
condition|)
name|rhs
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Handle the case of comparisons with constants.  If there is something in      common between the masks, those bits of the constants must be the same.      If not, the condition is always false.  Test for this to avoid generating      incorrect code below.  */
name|result
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|result
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|l_const
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|r_const
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|wanted_code
operator|==
name|NE_EXPR
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<or%> of unmatched not-equal tests is always 1"
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|true
argument_list|,
name|truth_type
argument_list|)
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<and%> of mutually exclusive equal-tests is always 0"
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|false
argument_list|,
name|truth_type
argument_list|)
return|;
block|}
block|}
comment|/* Construct the expression we will return.  First get the component      reference we will make.  Unless the mask is all ones the width of      that field, perform the mask operation.  Then compare with the      merged constant.  */
name|result
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
name|result
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|lntype
argument_list|,
name|result
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|result
argument_list|,
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|l_const
argument_list|,
name|r_const
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a    constant.  */
end_comment

begin_function
specifier|static
name|tree
name|optimize_minmax_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|tree
name|arg0
init|=
name|op0
decl_stmt|;
name|enum
name|tree_code
name|op_code
decl_stmt|;
name|tree
name|comp_const
init|=
name|op1
decl_stmt|;
name|tree
name|minmax_const
decl_stmt|;
name|int
name|consts_equal
decl_stmt|,
name|consts_lt
decl_stmt|;
name|tree
name|inner
decl_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op_code
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|minmax_const
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|consts_equal
operator|=
name|tree_int_cst_equal
argument_list|(
name|minmax_const
argument_list|,
name|comp_const
argument_list|)
expr_stmt|;
name|consts_lt
operator|=
name|tree_int_cst_lt
argument_list|(
name|minmax_const
argument_list|,
name|comp_const
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If something does not permit us to optimize, return the original tree.  */
if|if
condition|(
operator|(
name|op_code
operator|!=
name|MIN_EXPR
operator|&&
name|op_code
operator|!=
name|MAX_EXPR
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|comp_const
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|comp_const
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|minmax_const
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|minmax_const
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Now handle all the various comparison codes.  We only handle EQ_EXPR      and GT_EXPR, doing the rest with recursive calls using logical      simplifications.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
block|{
name|tree
name|tem
init|=
name|optimize_minmax_comparison
argument_list|(
name|invert_tree_comparison
argument_list|(
name|code
argument_list|,
name|false
argument_list|)
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|invert_truthvalue
argument_list|(
name|tem
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
case|case
name|GE_EXPR
case|:
return|return
name|fold_build2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|optimize_minmax_comparison
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|comp_const
argument_list|)
argument_list|,
name|optimize_minmax_comparison
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
name|consts_equal
condition|)
comment|/* MAX (X, 0) == 0  ->  X<= 0  */
return|return
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
name|consts_lt
condition|)
comment|/* MAX (X, 0) == 5  ->  X == 5   */
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
condition|)
comment|/* MAX (X, 0) == -1  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|consts_equal
condition|)
comment|/* MIN (X, 0) == 0  ->  X>= 0  */
return|return
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
return|;
elseif|else
if|if
condition|(
name|consts_lt
condition|)
comment|/* MIN (X, 0) == 5  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
else|else
comment|/* MIN (X, 0) == -1  ->  X == -1  */
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
operator|(
name|consts_equal
operator|||
name|consts_lt
operator|)
condition|)
comment|/* MAX (X, 0)> 0  ->  X> 0 	   MAX (X, 0)> 5  ->  X> 5  */
return|return
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
condition|)
comment|/* MAX (X, 0)> -1  ->  true  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|inner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MIN_EXPR
operator|&&
operator|(
name|consts_equal
operator|||
name|consts_lt
operator|)
condition|)
comment|/* MIN (X, 0)> 0  ->  false 	   MIN (X, 0)> 5  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
else|else
comment|/* MIN (X, 0)> -1  ->  X> -1  */
return|return
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* T is an integer expression that is being multiplied, divided, or taken a    modulus (CODE says which and what kind of divide or modulus) by a    constant C.  See if we can eliminate that operation by folding it with    other operations already in T.  WIDE_TYPE, if non-null, is a type that    should be used for the computation if wider than our type.     For example, if we are dividing (X * 8) + (Y * 16) by 4, we can return    (X * 2) + (Y * 4).  We must, however, be assured that either the original    expression would not overflow or that overflow is undefined for the type    in the language in question.     We also canonicalize (X + 7) * 4 into X * 4 + 28 in the hope that either    the machine has a multiply-accumulate insn or that this is part of an    addressing calculation.     If we return a non-null expression, it is an equivalent form of the    original computation, but need not be in the original type.     We set *STRICT_OVERFLOW_P to true if the return values depends on    signed overflow being undefined.  Otherwise we do not change    *STRICT_OVERFLOW_P.  */
end_comment

begin_function
specifier|static
name|tree
name|extract_muldiv
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|c
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|wide_type
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
comment|/* To avoid exponential search depth, refuse to allow recursion past      three levels.  Beyond that (1) it's highly unlikely that we'll find      something interesting and (2) we've probably processed it before      when we built the inner expression.  */
specifier|static
name|int
name|depth
decl_stmt|;
name|tree
name|ret
decl_stmt|;
if|if
condition|(
name|depth
operator|>
literal|3
condition|)
return|return
name|NULL
return|;
name|depth
operator|++
expr_stmt|;
name|ret
operator|=
name|extract_muldiv_1
argument_list|(
name|t
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
name|depth
operator|--
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|extract_muldiv_1
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|c
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|wide_type
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|tcode
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|ctype
init|=
operator|(
name|wide_type
operator|!=
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|wide_type
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|?
name|wide_type
else|:
name|type
operator|)
decl_stmt|;
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|same_p
init|=
name|tcode
operator|==
name|code
decl_stmt|;
name|tree
name|op0
init|=
name|NULL_TREE
decl_stmt|,
name|op1
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|sub_strict_overflow_p
decl_stmt|;
comment|/* Don't deal with constants of zero here; they confuse the code below.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|tcode
argument_list|)
operator|==
name|tcc_unary
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|tcode
argument_list|)
operator|==
name|tcc_binary
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that we need not handle conditional operations here since fold      already handles those cases.  So just do arithmetic here.  */
switch|switch
condition|(
name|tcode
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* For a constant, we can always simplify if we are a multiply 	 or (for divide and modulus) if it is a multiple of our constant.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|||
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|const_binop
argument_list|(
name|code
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* If op0 is an expression ...  */
if|if
condition|(
operator|(
name|COMPARISON_CLASS_P
argument_list|(
name|op0
argument_list|)
operator|||
name|UNARY_CLASS_P
argument_list|(
name|op0
argument_list|)
operator|||
name|BINARY_CLASS_P
argument_list|(
name|op0
argument_list|)
operator|||
name|EXPRESSION_CLASS_P
argument_list|(
name|op0
argument_list|)
operator|)
comment|/* ... and is unsigned, and its type is smaller than ctype, 	     then we cannot pass through as widening.  */
operator|&&
operator|(
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
comment|/* ... or this is a truncation (t is narrower than op0), 		 then we cannot pass through this narrowing.  */
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* ... or signedness changes for division or modulus, 		 then we cannot pass through this conversion.  */
operator|||
operator|(
name|code
operator|!=
name|MULT_EXPR
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Pass the constant down and see if we can make a simplification.  If 	 we can, replace this expression with the inner simplification for 	 possible later conversion to our or some other type.  */
if|if
condition|(
operator|(
name|t2
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t2
argument_list|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|t2
argument_list|,
name|code
argument_list|,
name|code
operator|==
name|MULT_EXPR
condition|?
name|ctype
else|:
name|NULL_TREE
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
operator|)
condition|)
return|return
name|t1
return|;
break|break;
case|case
name|ABS_EXPR
case|:
comment|/* If widening the type changes it from signed to unsigned, then we          must avoid building ABS_EXPR itself as unsigned.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|cstype
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|cstype
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|t1
operator|=
name|fold_build1
argument_list|(
name|tcode
argument_list|,
name|cstype
argument_list|,
name|fold_convert
argument_list|(
name|cstype
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
return|;
block|}
break|break;
block|}
comment|/* If the constant is negative, we cannot simplify this.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold_build1
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
comment|/* If widening the type changes the signedness, then we can't perform 	 this optimization as that changes the result.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
break|break;
comment|/* MIN (a, b) / 5 -> MIN (a / 5, b / 5)  */
name|sub_strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|t2
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
name|tcode
operator|=
operator|(
name|tcode
operator|==
name|MIN_EXPR
condition|?
name|MAX_EXPR
else|:
name|MIN_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|sub_strict_overflow_p
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t2
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
comment|/* If the second operand is constant, this is a multiplication 	 or floor division, by a power of two, so we can treat it that 	 way unless the multiplier or divisor overflows.  Signed 	 left-shift overflow is implementation-defined rather than 	 undefined in C90, so do not convert signed left shift into 	 multiplication.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|tcode
operator|==
name|RSHIFT_EXPR
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
comment|/* const_binop may not detect overflow correctly, 	     so check for it explicitly here.  */
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|extract_muldiv
argument_list|(
name|build2
argument_list|(
name|tcode
operator|==
name|LSHIFT_EXPR
condition|?
name|MULT_EXPR
else|:
name|FLOOR_DIV_EXPR
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|t1
argument_list|)
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* See if we can eliminate the operation on both sides.  If we can, we 	 can return a new PLUS or MINUS.  If we can't, the only remaining 	 cases where we can do anything are if the second operand is a 	 constant.  */
name|sub_strict_overflow_p
operator|=
name|false
expr_stmt|;
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
expr_stmt|;
name|t2
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
operator|&&
name|t2
operator|!=
literal|0
operator|&&
operator|(
name|code
operator|==
name|MULT_EXPR
comment|/* If not multiplication, we can only do this if both operands 		 are divisible by c.  */
operator|||
operator|(
name|multiple_of_p
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|,
name|c
argument_list|)
operator|&&
name|multiple_of_p
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sub_strict_overflow_p
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t2
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this was a subtraction, negate OP1 and set it to be an addition. 	 This simplifies the logic below.  */
if|if
condition|(
name|tcode
operator|==
name|MINUS_EXPR
condition|)
name|tcode
operator|=
name|PLUS_EXPR
operator|,
name|op1
operator|=
name|negate_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
comment|/* If either OP1 or C are negative, this optimization is not safe for 	 some of the division and remainder types while for others we need 	 to change the code.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|||
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_DIV_EXPR
condition|)
name|code
operator|=
name|FLOOR_DIV_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FLOOR_DIV_EXPR
condition|)
name|code
operator|=
name|CEIL_DIV_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
name|MULT_EXPR
operator|&&
name|code
operator|!=
name|CEIL_MOD_EXPR
operator|&&
name|code
operator|!=
name|FLOOR_MOD_EXPR
condition|)
break|break;
block|}
comment|/* If it's a multiply or a division/modulus operation of a multiple          of our constant, do the operation and verify it doesn't overflow.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|||
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We allow the constant to overflow with wrapping semantics.  */
if|if
condition|(
name|op1
operator|==
literal|0
operator|||
operator|(
name|TREE_OVERFLOW
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|ctype
argument_list|)
operator|)
condition|)
break|break;
block|}
else|else
break|break;
comment|/* If we have an unsigned type is not a sizetype, we cannot widen 	 the operation since it will change the result if the original 	 computation overflowed.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|&&
name|ctype
operator|!=
name|type
condition|)
break|break;
comment|/* If we were able to eliminate our operation from the first side, 	 apply our operation to the second side and reform the PLUS.  */
if|if
condition|(
name|t1
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|code
operator|||
name|code
operator|==
name|MULT_EXPR
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
comment|/* The last case is if we are a multiply.  In that case, we can 	 apply the distributive law to commute the multiply and addition 	 if the multiplication of the constants doesn't overflow.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
break|break;
case|case
name|MULT_EXPR
case|:
comment|/* We have a special case here if we are doing something like 	 (C * 8) % 4 since we know that's zero.  */
if|if
condition|(
operator|(
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|code
operator|==
name|CEIL_MOD_EXPR
operator|||
name|code
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|code
operator|==
name|ROUND_MOD_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|op0
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* If we can extract our operation from the LHS, do so and return a 	 new operation.  Likewise for the RHS from a MULT_EXPR.  Otherwise, 	 do something only if the second operand is a constant.  */
if|if
condition|(
name|same_p
operator|&&
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tcode
operator|==
name|MULT_EXPR
operator|&&
name|code
operator|==
name|MULT_EXPR
operator|&&
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
comment|/* If these are the same operation types, we can associate them 	 assuming no overflow.  */
if|if
condition|(
name|tcode
operator|==
name|code
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|t1
argument_list|)
return|;
comment|/* If these operations "cancel" each other, we have the main 	 optimizations of this pass, which occur when either constant is a 	 multiple of the other, in which case we replace this with either an 	 operation or CODE or TCODE.  	 If we have an unsigned type that is not a sizetype, we cannot do 	 this since it will change the result if the original computation 	 overflowed.  */
if|if
condition|(
operator|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|tcode
operator|==
name|EXACT_DIV_EXPR
operator|)
operator|||
operator|(
name|tcode
operator|==
name|MULT_EXPR
operator|&&
name|code
operator|!=
name|TRUNC_MOD_EXPR
operator|&&
name|code
operator|!=
name|CEIL_MOD_EXPR
operator|&&
name|code
operator|!=
name|FLOOR_MOD_EXPR
operator|&&
name|code
operator|!=
name|ROUND_MOD_EXPR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|c
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|c
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a node which has the indicated constant VALUE (either 0 or    1), and is of the indicated TYPE.  */
end_comment

begin_function
name|tree
name|constant_boolean_node
parameter_list|(
name|int
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
return|return
name|value
condition|?
name|integer_one_node
else|:
name|integer_zero_node
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
return|return
name|value
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
return|;
else|else
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if expr looks like an ARRAY_REF and set base and    offset to the appropriate trees.  If there is no offset,    offset is set to NULL_TREE.  Base will be canonicalized to    something you can get the element type from using    TREE_TYPE (TREE_TYPE (base)).  Offset will be the offset    in bytes to the base.  */
end_comment

begin_function
specifier|static
name|bool
name|extract_array_ref
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
modifier|*
name|base
parameter_list|,
name|tree
modifier|*
name|offset
parameter_list|)
block|{
comment|/* One canonical form is a PLUS_EXPR with the first      argument being an ADDR_EXPR with a possible NOP_EXPR      attached.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|inner_base
decl_stmt|,
name|dummy1
decl_stmt|;
comment|/* Strip NOP_EXPRs here because the C frontends and/or 	 folders present us (int *)&x.a + 4B possibly.  */
name|STRIP_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|extract_array_ref
argument_list|(
name|op0
argument_list|,
operator|&
name|inner_base
argument_list|,
operator|&
name|dummy1
argument_list|)
condition|)
block|{
operator|*
name|base
operator|=
name|inner_base
expr_stmt|;
if|if
condition|(
name|dummy1
operator|==
name|NULL_TREE
condition|)
operator|*
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|offset
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dummy1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* Other canonical form is an ADDR_EXPR of an ARRAY_REF,      which we transform into an ADDR_EXPR with appropriate      offset.  For other arguments to the ADDR_EXPR we assume      zero offset and as such do not care about the ADDR_EXPR      type and strip possible nops from it.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|idx
init|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
operator|*
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|,
name|idx
argument_list|,
name|array_ref_element_size
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle array-to-pointer decay as&a.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
operator|*
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|*
name|base
operator|=
name|expr
expr_stmt|;
operator|*
name|offset
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* The next canonical form is a VAR_DECL with POINTER_TYPE.  */
elseif|else
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
operator|*
name|base
operator|=
name|expr
expr_stmt|;
operator|*
name|offset
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Transform `a + (b ? x : y)' into `b ? (a + x) : (a + y)'.    Transform, `a + (x< y)' into `(x< y) ? (a + 1) : (a + 0)'.  Here    CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x< y)'    expression, and ARG to `a'.  If COND_FIRST_P is nonzero, then the    COND is the first argument to CODE; otherwise (as in the example    given here), it is the second argument.  TYPE is the type of the    original expression.  Return NULL_TREE if no simplification is    possible.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_binary_op_with_conditional_arg
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|arg
parameter_list|,
name|int
name|cond_first_p
parameter_list|)
block|{
name|tree
name|cond_type
init|=
name|cond_first_p
condition|?
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|tree
name|arg_type
init|=
name|cond_first_p
condition|?
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|test
decl_stmt|,
name|true_value
decl_stmt|,
name|false_value
decl_stmt|;
name|tree
name|lhs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rhs
init|=
name|NULL_TREE
decl_stmt|;
comment|/* This transformation is only worthwhile if we don't have to wrap      arg in a SAVE_EXPR, and the operation can be simplified on at least      one of the branches once its pushed inside the COND_EXPR.  */
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|test
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|true_value
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If this operand throws an expression, then it does not make 	 sense to try to perform a logical or arithmetic operation 	 involving it.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|true_value
argument_list|)
argument_list|)
condition|)
name|lhs
operator|=
name|true_value
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|false_value
argument_list|)
argument_list|)
condition|)
name|rhs
operator|=
name|false_value
expr_stmt|;
block|}
else|else
block|{
name|tree
name|testtype
init|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|test
operator|=
name|cond
expr_stmt|;
name|true_value
operator|=
name|constant_boolean_node
argument_list|(
name|true
argument_list|,
name|testtype
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|constant_boolean_node
argument_list|(
name|false
argument_list|,
name|testtype
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|fold_convert
argument_list|(
name|arg_type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
literal|0
condition|)
block|{
name|true_value
operator|=
name|fold_convert
argument_list|(
name|cond_type
argument_list|,
name|true_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_first_p
condition|)
name|lhs
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|true_value
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|lhs
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|true_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rhs
operator|==
literal|0
condition|)
block|{
name|false_value
operator|=
name|fold_convert
argument_list|(
name|cond_type
argument_list|,
name|false_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_first_p
condition|)
name|rhs
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|false_value
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|false_value
argument_list|)
expr_stmt|;
block|}
name|test
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|test
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|test
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of fold() that checks for the addition of +/- 0.0.     If !NEGATE, return true if ADDEND is +/-0.0 and, for all X of type    TYPE, X + ADDEND is the same as X.  If NEGATE, return true if X -    ADDEND is the same as X.     X + 0 and X - 0 both give X when X is NaN, infinite, or nonzero    and finite.  The problematic cases are when X is zero, and its mode    has signed zeros.  In the case of rounding towards -infinity,    X - 0 is not the same as X because 0 - 0 is -0.  In other rounding    modes, X + 0 is not the same as X because -0 + 0 is 0.  */
end_comment

begin_function
specifier|static
name|bool
name|fold_real_zero_addition_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|addend
parameter_list|,
name|int
name|negate
parameter_list|)
block|{
if|if
condition|(
operator|!
name|real_zerop
argument_list|(
name|addend
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Don't allow the fold with -fsignaling-nans.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Allow the fold if zeros aren't signed, or their sign isn't important.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Treat x + -0 as x - 0 and x - -0 as x + 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addend
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|addend
argument_list|)
argument_list|)
condition|)
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
comment|/* The mode has signed zeros, and we have to honor their sign.      In this situation, there is only one case we can return true for.      X - 0 is the same as X unless rounding towards -infinity is      supported.  */
return|return
name|negate
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold() that checks comparisons of built-in math    functions against real constants.     FCODE is the DECL_FUNCTION_CODE of the built-in, CODE is the comparison    operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR, GE_EXPR or LE_EXPR.  TYPE    is the type of the result and ARG0 and ARG1 are the operands of the    comparison.  ARG1 must be a TREE_REAL_CST.     The function returns the constant folded tree if a simplification    can be made, and NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_mathfn_compare
parameter_list|(
name|enum
name|built_in_function
name|fcode
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
if|if
condition|(
name|BUILTIN_SQRT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* sqrt(x)< y is always false, if y is negative.  */
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|LE_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg
argument_list|)
return|;
comment|/* sqrt(x)> y is always true, if y is negative and we 	     don't care about NaNs, i.e. negative values of x.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg
argument_list|)
return|;
comment|/* sqrt(x)> y is the same as x>= 0, if y is negative.  */
return|return
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|REAL_VALUE_TYPE
name|c2
decl_stmt|;
name|REAL_ARITHMETIC
argument_list|(
name|c2
argument_list|,
name|MULT_EXPR
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|c2
argument_list|,
name|mode
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|c2
argument_list|)
condition|)
block|{
comment|/* sqrt(x)> y is x == +Inf, when y is very large.  */
if|if
condition|(
name|HONOR_INFINITIES
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)> y is always false, when y is very large 		 and we don't care about infinities.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg
argument_list|)
return|;
block|}
comment|/* sqrt(x)> c is the same as x> c*c.  */
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|LE_EXPR
condition|)
block|{
name|REAL_VALUE_TYPE
name|c2
decl_stmt|;
name|REAL_ARITHMETIC
argument_list|(
name|c2
argument_list|,
name|MULT_EXPR
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|c2
argument_list|,
name|mode
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|c2
argument_list|)
condition|)
block|{
comment|/* sqrt(x)< y is always true, when y is a very large 		 value and we don't care about NaNs or Infinities.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_INFINITIES
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg
argument_list|)
return|;
comment|/* sqrt(x)< y is x != +Inf when y is very large and we 		 don't care about NaNs.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)< y is x>= 0 when y is very large and we 		 don't care about Infinities.  */
if|if
condition|(
operator|!
name|HONOR_INFINITIES
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)< y is x>= 0&& x != +Inf, when y is large.  */
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
argument_list|()
operator|!=
literal|0
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* sqrt(x)< c is the same as x< c*c, if we ignore NaNs.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)< c is the same as x>= 0&& x< c*c.  */
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold() that optimizes comparisons against Infinities,    either +Inf or -Inf.     CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,    GE_EXPR or LE_EXPR.  TYPE is the type of the result and ARG0 and ARG1    are the operands of the comparison.  ARG1 must be a TREE_REAL_CST.     The function returns the constant folded tree if a simplification    can be made, and NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_inf_compare
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|max
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|bool
name|neg
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For negative infinity swap the sense of the comparison.  */
name|neg
operator|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
comment|/* x> +Inf is always false, if with ignore sNANs.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
comment|/* x<= +Inf is always true, if we don't case about NaNs.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* x<= +Inf is the same as x == x, i.e. isfinite(x).  */
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|arg0
operator|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg0
argument_list|)
return|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|GE_EXPR
case|:
comment|/* x == +Inf and x>= +Inf are always equal to x> DBL_MAX.  */
name|real_maxval
argument_list|(
operator|&
name|max
argument_list|,
name|neg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|neg
condition|?
name|LT_EXPR
else|:
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
comment|/* x< +Inf is always equal to x<= DBL_MAX.  */
name|real_maxval
argument_list|(
operator|&
name|max
argument_list|,
name|neg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|neg
condition|?
name|GE_EXPR
else|:
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
comment|/* x != +Inf is always equal to !(x> DBL_MAX).  */
name|real_maxval
argument_list|(
operator|&
name|max
argument_list|,
name|neg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|neg
condition|?
name|GE_EXPR
else|:
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
return|;
comment|/* The transformation below creates non-gimple code and thus is 	 not appropriate if we are in gimple form.  */
if|if
condition|(
name|in_gimple_form
condition|)
return|return
name|NULL_TREE
return|;
name|temp
operator|=
name|fold_build2
argument_list|(
name|neg
condition|?
name|LT_EXPR
else|:
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|temp
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold() that optimizes comparisons of a division by    a nonzero integer constant against an integer constant, i.e.    X/C1 op C2.     CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,    GE_EXPR or LE_EXPR.  TYPE is the type of the result and ARG0 and ARG1    are the operands of the comparison.  ARG1 must be a TREE_REAL_CST.     The function returns the constant folded tree if a simplification    can be made, and NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_div_compare
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|prod
decl_stmt|,
name|tmp
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lpart
decl_stmt|;
name|HOST_WIDE_INT
name|hpart
decl_stmt|;
name|bool
name|unsigned_p
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|neg_overflow
decl_stmt|;
name|int
name|overflow
decl_stmt|;
comment|/* We have to do this the hard way to detect unsigned overflow.      prod = int_const_binop (MULT_EXPR, arg01, arg1, 0);  */
name|overflow
operator|=
name|mul_double_with_sign
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg01
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg01
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|lpart
argument_list|,
operator|&
name|hpart
argument_list|,
name|unsigned_p
argument_list|)
expr_stmt|;
name|prod
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|lpart
argument_list|,
name|hpart
argument_list|)
expr_stmt|;
name|prod
operator|=
name|force_fit_type
argument_list|(
name|prod
argument_list|,
operator|-
literal|1
argument_list|,
name|overflow
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|neg_overflow
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|unsigned_p
condition|)
block|{
name|tmp
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg01
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lo
operator|=
name|prod
expr_stmt|;
comment|/* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp, 0).  */
name|overflow
operator|=
name|add_double_with_sign
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|prod
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|prod
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|tmp
argument_list|)
argument_list|,
operator|&
name|lpart
argument_list|,
operator|&
name|hpart
argument_list|,
name|unsigned_p
argument_list|)
expr_stmt|;
name|hi
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|lpart
argument_list|,
name|hpart
argument_list|)
expr_stmt|;
name|hi
operator|=
name|force_fit_type
argument_list|(
name|hi
argument_list|,
operator|-
literal|1
argument_list|,
name|overflow
operator||
name|TREE_OVERFLOW
argument_list|(
name|prod
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|arg01
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg01
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|neg_overflow
operator|=
name|true
expr_stmt|;
name|lo
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|prod
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi
operator|=
name|prod
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|lo
operator|=
name|fold_negate_const
argument_list|(
name|tmp
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|hi
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|hi
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|prod
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lo
operator|=
name|prod
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A negative divisor reverses the relational operators.  */
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg01
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|hi
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|prod
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lo
operator|=
name|prod
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|hi
operator|=
name|fold_negate_const
argument_list|(
name|tmp
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|lo
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|neg_overflow
operator|=
name|true
expr_stmt|;
name|lo
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|prod
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi
operator|=
name|prod
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|lo
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|hi
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg00
argument_list|)
return|;
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|hi
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|lo
argument_list|)
return|;
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|lo
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|hi
argument_list|)
return|;
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|arg00
argument_list|,
literal|1
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|lo
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|hi
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg00
argument_list|)
return|;
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|hi
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|lo
argument_list|)
return|;
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|lo
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|hi
argument_list|)
return|;
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|arg00
argument_list|,
literal|0
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|lo
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|neg_overflow
condition|?
name|integer_zero_node
else|:
name|integer_one_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|,
name|arg00
argument_list|)
return|;
block|}
return|return
name|fold_build2
argument_list|(
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|lo
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|hi
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|neg_overflow
condition|?
name|integer_zero_node
else|:
name|integer_one_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|,
name|arg00
argument_list|)
return|;
block|}
return|return
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|hi
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|hi
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|neg_overflow
condition|?
name|integer_one_node
else|:
name|integer_zero_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|,
name|arg00
argument_list|)
return|;
block|}
return|return
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|hi
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|lo
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|neg_overflow
condition|?
name|integer_one_node
else|:
name|integer_zero_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|,
name|arg00
argument_list|)
return|;
block|}
return|return
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|lo
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If CODE with arguments ARG0 and ARG1 represents a single bit    equality/inequality test, then return a simplified form of the test    using a sign testing.  Otherwise return NULL.  TYPE is the desired    result type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_single_bit_test_into_sign_test
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|result_type
parameter_list|)
block|{
comment|/* If this is testing a single bit, we can optimize the test.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If we have (A& C) != 0 where C is the sign bit of A, convert 	 this into A< 0.  Similarly for (A& C) == 0 into A>= 0.  */
name|tree
name|arg00
init|=
name|sign_bit_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg00
operator|!=
name|NULL_TREE
comment|/* This is only a win if casting to a signed type is cheap, 	     i.e. when arg00's type is not a partial mode.  */
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|stype
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|GE_EXPR
else|:
name|LT_EXPR
argument_list|,
name|result_type
argument_list|,
name|fold_convert
argument_list|(
name|stype
argument_list|,
name|arg00
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|stype
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If CODE with arguments ARG0 and ARG1 represents a single bit    equality/inequality test, then return a simplified form of    the test using shifts and logical operations.  Otherwise return    NULL.  TYPE is the desired result type.  */
end_comment

begin_function
name|tree
name|fold_single_bit_test
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|result_type
parameter_list|)
block|{
comment|/* If this is testing a single bit, we can optimize the test.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|int
name|bitnum
init|=
name|tree_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|ops_unsigned
decl_stmt|;
name|tree
name|signed_type
decl_stmt|,
name|unsigned_type
decl_stmt|,
name|intermediate_type
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* First, see if we can fold the single bit test into a sign-bit 	 test.  */
name|tem
operator|=
name|fold_single_bit_test_into_sign_test
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|result_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* Otherwise we have (A& C) != 0 where C is a single bit, 	 convert that into ((A>> C2)& 1).  Where C2 = log2(C). 	 Similarly for (A& C) == 0.  */
comment|/* If INNER is a right shift of a constant and it plus BITNUM does 	 not overflow, adjust BITNUM and INNER.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|bitnum
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bitnum
operator|-
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|bitnum
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we are going to be able to omit the AND below, we must do our 	 operations as unsigned.  If we must use the AND, we have a choice. 	 Normally unsigned is faster, but for some machines signed is.  */
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
name|ops_unsigned
operator|=
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|operand_mode
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
operator|!
name|flag_syntax_only
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
else|#
directive|else
name|ops_unsigned
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|signed_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|operand_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsigned_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|operand_mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intermediate_type
operator|=
name|ops_unsigned
condition|?
name|unsigned_type
else|:
name|signed_type
expr_stmt|;
name|inner
operator|=
name|fold_convert
argument_list|(
name|intermediate_type
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitnum
operator|!=
literal|0
condition|)
name|inner
operator|=
name|build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|intermediate_type
argument_list|,
name|inner
argument_list|,
name|size_int
argument_list|(
name|bitnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|inner
operator|=
name|fold_build2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|intermediate_type
argument_list|,
name|inner
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* Put the AND last so it can combine with more things.  */
name|inner
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|intermediate_type
argument_list|,
name|inner
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* Make sure to return the proper type.  */
name|inner
operator|=
name|fold_convert
argument_list|(
name|result_type
argument_list|,
name|inner
argument_list|)
expr_stmt|;
return|return
name|inner
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check whether we are allowed to reorder operands arg0 and arg1,    such that the evaluation of arg1 occurs before arg0.  */
end_comment

begin_function
specifier|static
name|bool
name|reorder_operands_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_evaluation_order
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|true
return|;
return|return
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Test whether it is preferable two swap two operands, ARG0 and    ARG1, for example because ARG0 is an integer constant and ARG1    isn't.  If REORDER is true, only recommend swapping if we can    evaluate the operands in reverse order.  */
end_comment

begin_function
name|bool
name|tree_swap_operands_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|bool
name|reorder
parameter_list|)
block|{
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|optimize_size
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reorder
operator|&&
name|flag_evaluation_order
operator|&&
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* It is preferable to swap two SSA_NAME to ensure a canonical form      for commutative and comparison operators.  Ensuring a canonical      form allows the optimizers to find additional redundancies without      having to explicitly check for both orderings.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_VERSION
argument_list|(
name|arg0
argument_list|)
operator|>
name|SSA_NAME_VERSION
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold comparison ARG0 CODE ARG1 (with result in TYPE), where    ARG0 is extended to a wider type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_widened_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|arg0_unw
init|=
name|get_unwidened
argument_list|(
name|arg0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|arg1_unw
decl_stmt|;
name|tree
name|shorter_type
decl_stmt|,
name|outer_type
decl_stmt|;
name|tree
name|min
decl_stmt|,
name|max
decl_stmt|;
name|bool
name|above
decl_stmt|,
name|below
decl_stmt|;
if|if
condition|(
name|arg0_unw
operator|==
name|arg0
condition|)
return|return
name|NULL_TREE
return|;
name|shorter_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0_unw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
comment|/* Disable this optimization if we're casting a function pointer      type on targets that require function pointer canonicalization.  */
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|shorter_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|shorter_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|NULL_TREE
return|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|shorter_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg1_unw
operator|=
name|get_unwidened
argument_list|(
name|arg1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If possible, express the comparison in the shorter mode.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|shorter_type
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|arg1_unw
argument_list|)
operator|==
name|shorter_type
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|shorter_type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_unw
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg1_unw
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|shorter_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|shorter_type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|arg1_unw
argument_list|,
name|shorter_type
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0_unw
argument_list|,
name|fold_convert
argument_list|(
name|shorter_type
argument_list|,
name|arg1_unw
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1_unw
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|shorter_type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|arg1_unw
argument_list|,
name|shorter_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we are comparing with the integer that does not fit into the range      of the shorter type, the result is known.  */
name|outer_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg1_unw
argument_list|)
expr_stmt|;
name|min
operator|=
name|lower_bound_in_type
argument_list|(
name|outer_type
argument_list|,
name|shorter_type
argument_list|)
expr_stmt|;
name|max
operator|=
name|upper_bound_in_type
argument_list|(
name|outer_type
argument_list|,
name|shorter_type
argument_list|)
expr_stmt|;
name|above
operator|=
name|integer_nonzerop
argument_list|(
name|fold_relational_const
argument_list|(
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|max
argument_list|,
name|arg1_unw
argument_list|)
argument_list|)
expr_stmt|;
name|below
operator|=
name|integer_nonzerop
argument_list|(
name|fold_relational_const
argument_list|(
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1_unw
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|above
operator|||
name|below
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
break|break;
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|above
operator|||
name|below
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
break|break;
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
if|if
condition|(
name|above
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|below
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|above
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|below
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold comparison ARG0 CODE ARG1 (with result in TYPE), where for    ARG0 just the signedness is changed.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_sign_changed_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|arg0_inner
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|inner_type
decl_stmt|,
name|outer_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|CONVERT_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|outer_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|arg0_inner
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0_inner
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
comment|/* Disable this optimization if we're casting a function pointer      type on targets that require function pointer canonicalization.  */
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|NULL_TREE
return|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|inner_type
operator|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|&&
name|code
operator|!=
name|EQ_EXPR
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tmp
operator|=
name|build_int_cst_wide
argument_list|(
name|inner_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|force_fit_type
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|arg1
operator|=
name|fold_convert
argument_list|(
name|inner_type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0_inner
argument_list|,
name|arg1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Tries to replace&a[idx] CODE s * delta with&a[idx CODE delta], if s is    step of the array.  Reconstructs s and delta in the case of s * delta    being an integer constant (and thus already folded).    ADDR is the address. MULT is the multiplicative expression.    If the function succeeds, the new address expression is returned.  Otherwise    NULL_TREE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|try_move_mult_to_index
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|addr
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|tree
name|s
decl_stmt|,
name|delta
decl_stmt|,
name|step
decl_stmt|;
name|tree
name|ref
init|=
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|pref
decl_stmt|;
name|tree
name|ret
decl_stmt|,
name|pos
decl_stmt|;
name|tree
name|itype
decl_stmt|;
comment|/* Canonicalize op1 into a possibly non-constant delta      and an INTEGER_CST s.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|s
operator|=
name|arg0
expr_stmt|;
name|delta
operator|=
name|arg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|s
operator|=
name|arg1
expr_stmt|;
name|delta
operator|=
name|arg0
expr_stmt|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|delta
operator|=
name|op1
expr_stmt|;
name|s
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
comment|/* Simulate we are delta * 1.  */
name|delta
operator|=
name|op1
expr_stmt|;
name|s
operator|=
name|integer_one_node
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|itype
operator|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|itype
condition|)
continue|continue;
name|step
operator|=
name|array_ref_element_size
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
continue|continue;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|step
argument_list|,
name|s
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* Try if delta is a multiple of step.  */
name|tree
name|tmp
init|=
name|div_if_zero_remainder
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|delta
argument_list|,
name|step
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
continue|continue;
name|delta
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|handled_component_p
argument_list|(
name|ref
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
comment|/* We found the suitable array reference.  So copy everything up to it,      and replace the index.  */
name|pref
operator|=
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|copy_node
argument_list|(
name|pref
argument_list|)
expr_stmt|;
name|pos
operator|=
name|ret
expr_stmt|;
while|while
condition|(
name|pref
operator|!=
name|ref
condition|)
block|{
name|pref
operator|=
name|TREE_OPERAND
argument_list|(
name|pref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_node
argument_list|(
name|pref
argument_list|)
expr_stmt|;
name|pos
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|itype
argument_list|,
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold A< X&& A + 1> Y to A< X&& A>= Y.  Normally A + 1> Y    means A>= Y&& A != MAX, but in this case we know that    A< X<= MAX.  INEQ is A + 1> Y, BOUND is A< X.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_to_nonsharp_ineq_using_bound
parameter_list|(
name|tree
name|ineq
parameter_list|,
name|tree
name|bound
parameter_list|)
block|{
name|tree
name|a
decl_stmt|,
name|typea
decl_stmt|,
name|type
init|=
name|TREE_TYPE
argument_list|(
name|ineq
argument_list|)
decl_stmt|,
name|a1
decl_stmt|,
name|diff
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
operator|==
name|LT_EXPR
condition|)
name|a
operator|=
name|TREE_OPERAND
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
operator|==
name|GT_EXPR
condition|)
name|a
operator|=
name|TREE_OPERAND
argument_list|(
name|bound
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
name|typea
operator|=
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|typea
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|typea
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ineq
argument_list|)
operator|==
name|LT_EXPR
condition|)
block|{
name|a1
operator|=
name|TREE_OPERAND
argument_list|(
name|ineq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|TREE_OPERAND
argument_list|(
name|ineq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ineq
argument_list|)
operator|==
name|GT_EXPR
condition|)
block|{
name|a1
operator|=
name|TREE_OPERAND
argument_list|(
name|ineq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|TREE_OPERAND
argument_list|(
name|ineq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|a1
argument_list|)
operator|!=
name|typea
condition|)
return|return
name|NULL_TREE
return|;
name|diff
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|typea
argument_list|,
name|a1
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_onep
argument_list|(
name|diff
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|a
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a sum or difference of at least one multiplication.    Returns the folded tree or NULL if no simplification could be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_plusminus_mult_expr
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|arg00
decl_stmt|,
name|arg01
decl_stmt|,
name|arg10
decl_stmt|,
name|arg11
decl_stmt|;
name|tree
name|alt0
init|=
name|NULL_TREE
decl_stmt|,
name|alt1
init|=
name|NULL_TREE
decl_stmt|,
name|same
decl_stmt|;
comment|/* (A * C) +- (B * C) -> (A+-B) * C.      (A * C) +- A -> A * (C+-1).      We are most concerned about the case where C is a constant,      but other combinations show up during loop reduction.  Since      it is not difficult, try all four possibilities.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
condition|)
block|{
name|arg00
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg00
operator|=
name|arg0
expr_stmt|;
name|arg01
operator|=
name|build_one_cst
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
block|{
name|arg10
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg11
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg10
operator|=
name|arg1
expr_stmt|;
name|arg11
operator|=
name|build_one_cst
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|same
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg01
operator|,
name|alt0
operator|=
name|arg00
operator|,
name|alt1
operator|=
name|arg10
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg00
operator|,
name|alt0
operator|=
name|arg01
operator|,
name|alt1
operator|=
name|arg11
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg00
operator|,
name|alt0
operator|=
name|arg01
operator|,
name|alt1
operator|=
name|arg10
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg01
operator|,
name|alt0
operator|=
name|arg00
operator|,
name|alt1
operator|=
name|arg11
expr_stmt|;
comment|/* No identical multiplicands; see if we can find a common      power-of-two factor in non-power-of-two multiplies.  This      can help in multi-dimensional array access.  */
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|arg01
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|int01
decl_stmt|,
name|int11
decl_stmt|,
name|tmp
decl_stmt|;
name|bool
name|swap
init|=
name|false
decl_stmt|;
name|tree
name|maybe_same
decl_stmt|;
name|int01
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
name|int11
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg11
argument_list|)
expr_stmt|;
comment|/* Move min of absolute values to int11.  */
if|if
condition|(
operator|(
name|int01
operator|>=
literal|0
condition|?
name|int01
else|:
operator|-
name|int01
operator|)
operator|<
operator|(
name|int11
operator|>=
literal|0
condition|?
name|int11
else|:
operator|-
name|int11
operator|)
condition|)
block|{
name|tmp
operator|=
name|int01
operator|,
name|int01
operator|=
name|int11
operator|,
name|int11
operator|=
name|tmp
expr_stmt|;
name|alt0
operator|=
name|arg00
operator|,
name|arg00
operator|=
name|arg10
operator|,
name|arg10
operator|=
name|alt0
expr_stmt|;
name|maybe_same
operator|=
name|arg01
expr_stmt|;
name|swap
operator|=
name|true
expr_stmt|;
block|}
else|else
name|maybe_same
operator|=
name|arg11
expr_stmt|;
if|if
condition|(
name|exact_log2
argument_list|(
name|int11
argument_list|)
operator|>
literal|0
operator|&&
name|int01
operator|%
name|int11
operator|==
literal|0
condition|)
block|{
name|alt0
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|arg00
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|int01
operator|/
name|int11
argument_list|)
argument_list|)
expr_stmt|;
name|alt1
operator|=
name|arg10
expr_stmt|;
name|same
operator|=
name|maybe_same
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|maybe_same
operator|=
name|alt0
operator|,
name|alt0
operator|=
name|alt1
operator|,
name|alt1
operator|=
name|maybe_same
expr_stmt|;
block|}
block|}
if|if
condition|(
name|same
condition|)
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|alt0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|alt1
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|same
argument_list|)
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of native_encode_expr.  Encode the INTEGER_CST    specified by EXPR into the buffer PTR of length LEN bytes.    Return the number of bytes placed in the buffer, or zero    upon failure.  */
end_comment

begin_function
specifier|static
name|int
name|native_encode_int
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|int
name|total_bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|offset
decl_stmt|,
name|word
decl_stmt|,
name|words
decl_stmt|;
name|unsigned
name|char
name|value
decl_stmt|;
if|if
condition|(
name|total_bytes
operator|>
name|len
condition|)
return|return
literal|0
return|;
name|words
operator|=
name|total_bytes
operator|/
name|UNITS_PER_WORD
expr_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|total_bytes
condition|;
name|byte
operator|++
control|)
block|{
name|int
name|bitpos
init|=
name|byte
operator|*
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|>>
name|bitpos
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|>>
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_bytes
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|word
operator|=
name|byte
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|words
operator|-
literal|1
operator|)
operator|-
name|word
expr_stmt|;
name|offset
operator|=
name|word
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|-
operator|(
name|byte
operator|%
name|UNITS_PER_WORD
operator|)
expr_stmt|;
else|else
name|offset
operator|+=
name|byte
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BYTES_BIG_ENDIAN
condition|?
operator|(
name|total_bytes
operator|-
literal|1
operator|)
operator|-
name|byte
else|:
name|byte
expr_stmt|;
name|ptr
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
return|return
name|total_bytes
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of native_encode_expr.  Encode the REAL_CST    specified by EXPR into the buffer PTR of length LEN bytes.    Return the number of bytes placed in the buffer, or zero    upon failure.  */
end_comment

begin_function
specifier|static
name|int
name|native_encode_real
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|int
name|total_bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|offset
decl_stmt|,
name|word
decl_stmt|,
name|words
decl_stmt|,
name|bitpos
decl_stmt|;
name|unsigned
name|char
name|value
decl_stmt|;
comment|/* There are always 32 bits in each long, no matter the size of      the hosts long.  We handle floating point representations with      up to 192 bits.  */
name|long
name|tmp
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|total_bytes
operator|>
name|len
condition|)
return|return
literal|0
return|;
name|words
operator|=
literal|32
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|real_to_target
argument_list|(
name|tmp
argument_list|,
name|TREE_REAL_CST_PTR
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bitpos
operator|=
literal|0
init|;
name|bitpos
operator|<
name|total_bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|BITS_PER_UNIT
control|)
block|{
name|byte
operator|=
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
operator|&
literal|3
expr_stmt|;
name|value
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|tmp
index|[
name|bitpos
operator|/
literal|32
index|]
operator|>>
operator|(
name|bitpos
operator|&
literal|31
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNITS_PER_WORD
operator|<
literal|4
condition|)
block|{
name|word
operator|=
name|byte
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|words
operator|-
literal|1
operator|)
operator|-
name|word
expr_stmt|;
name|offset
operator|=
name|word
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|-
operator|(
name|byte
operator|%
name|UNITS_PER_WORD
operator|)
expr_stmt|;
else|else
name|offset
operator|+=
name|byte
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BYTES_BIG_ENDIAN
condition|?
literal|3
operator|-
name|byte
else|:
name|byte
expr_stmt|;
name|ptr
index|[
name|offset
operator|+
operator|(
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
operator|&
operator|~
literal|3
operator|)
index|]
operator|=
name|value
expr_stmt|;
block|}
return|return
name|total_bytes
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of native_encode_expr.  Encode the COMPLEX_CST    specified by EXPR into the buffer PTR of length LEN bytes.    Return the number of bytes placed in the buffer, or zero    upon failure.  */
end_comment

begin_function
specifier|static
name|int
name|native_encode_complex
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|rsize
decl_stmt|,
name|isize
decl_stmt|;
name|tree
name|part
decl_stmt|;
name|part
operator|=
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|native_encode_expr
argument_list|(
name|part
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|part
operator|=
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|isize
operator|=
name|native_encode_expr
argument_list|(
name|part
argument_list|,
name|ptr
operator|+
name|rsize
argument_list|,
name|len
operator|-
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|isize
operator|!=
name|rsize
condition|)
return|return
literal|0
return|;
return|return
name|rsize
operator|+
name|isize
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of native_encode_expr.  Encode the VECTOR_CST    specified by EXPR into the buffer PTR of length LEN bytes.    Return the number of bytes placed in the buffer, or zero    upon failure.  */
end_comment

begin_function
specifier|static
name|int
name|native_encode_vector
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|offset
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|itype
decl_stmt|,
name|elem
decl_stmt|,
name|elements
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|elements
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|count
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elements
condition|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|elements
argument_list|)
expr_stmt|;
name|elements
operator|=
name|TREE_CHAIN
argument_list|(
name|elements
argument_list|)
expr_stmt|;
block|}
else|else
name|elem
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|native_encode_expr
argument_list|(
name|elem
argument_list|,
name|ptr
operator|+
name|offset
argument_list|,
name|len
operator|-
name|offset
argument_list|)
operator|!=
name|size
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|len
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|ptr
operator|+
name|offset
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|size
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold_view_convert_expr.  Encode the INTEGER_CST,    REAL_CST, COMPLEX_CST or VECTOR_CST specified by EXPR into the    buffer PTR of length LEN bytes.  Return the number of bytes    placed in the buffer, or zero upon failure.  */
end_comment

begin_function
specifier|static
name|int
name|native_encode_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|native_encode_int
argument_list|(
name|expr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|native_encode_real
argument_list|(
name|expr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|native_encode_complex
argument_list|(
name|expr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|VECTOR_CST
case|:
return|return
name|native_encode_vector
argument_list|(
name|expr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of native_interpret_expr.  Interpret the contents of    the buffer PTR of length LEN as an INTEGER_CST of type TYPE.    If the buffer cannot be interpreted, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|native_interpret_int
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|total_bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|offset
decl_stmt|,
name|word
decl_stmt|,
name|words
decl_stmt|;
name|unsigned
name|char
name|value
decl_stmt|;
name|unsigned
name|int
name|HOST_WIDE_INT
name|lo
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|hi
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|total_bytes
operator|>
name|len
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|total_bytes
operator|*
name|BITS_PER_UNIT
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|NULL_TREE
return|;
name|words
operator|=
name|total_bytes
operator|/
name|UNITS_PER_WORD
expr_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|total_bytes
condition|;
name|byte
operator|++
control|)
block|{
name|int
name|bitpos
init|=
name|byte
operator|*
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|total_bytes
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|word
operator|=
name|byte
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|words
operator|-
literal|1
operator|)
operator|-
name|word
expr_stmt|;
name|offset
operator|=
name|word
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|-
operator|(
name|byte
operator|%
name|UNITS_PER_WORD
operator|)
expr_stmt|;
else|else
name|offset
operator|+=
name|byte
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BYTES_BIG_ENDIAN
condition|?
operator|(
name|total_bytes
operator|-
literal|1
operator|)
operator|-
name|byte
else|:
name|byte
expr_stmt|;
name|value
operator|=
name|ptr
index|[
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|lo
operator||=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|value
operator|<<
name|bitpos
expr_stmt|;
else|else
name|hi
operator||=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|value
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
return|return
name|force_fit_type
argument_list|(
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of native_interpret_expr.  Interpret the contents of    the buffer PTR of length LEN as a REAL_CST of type TYPE.    If the buffer cannot be interpreted, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|native_interpret_real
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|total_bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|offset
decl_stmt|,
name|word
decl_stmt|,
name|words
decl_stmt|,
name|bitpos
decl_stmt|;
name|unsigned
name|char
name|value
decl_stmt|;
comment|/* There are always 32 bits in each long, no matter the size of      the hosts long.  We handle floating point representations with      up to 192 bits.  */
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|tmp
index|[
literal|6
index|]
decl_stmt|;
name|total_bytes
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_bytes
operator|>
name|len
operator|||
name|total_bytes
operator|>
literal|24
condition|)
return|return
name|NULL_TREE
return|;
name|words
operator|=
literal|32
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bitpos
operator|=
literal|0
init|;
name|bitpos
operator|<
name|total_bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|BITS_PER_UNIT
control|)
block|{
name|byte
operator|=
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|UNITS_PER_WORD
operator|<
literal|4
condition|)
block|{
name|word
operator|=
name|byte
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|words
operator|-
literal|1
operator|)
operator|-
name|word
expr_stmt|;
name|offset
operator|=
name|word
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|-
operator|(
name|byte
operator|%
name|UNITS_PER_WORD
operator|)
expr_stmt|;
else|else
name|offset
operator|+=
name|byte
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BYTES_BIG_ENDIAN
condition|?
literal|3
operator|-
name|byte
else|:
name|byte
expr_stmt|;
name|value
operator|=
name|ptr
index|[
name|offset
operator|+
operator|(
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
operator|&
operator|~
literal|3
operator|)
index|]
expr_stmt|;
name|tmp
index|[
name|bitpos
operator|/
literal|32
index|]
operator||=
operator|(
name|unsigned
name|long
operator|)
name|value
operator|<<
operator|(
name|bitpos
operator|&
literal|31
operator|)
expr_stmt|;
block|}
name|real_from_target
argument_list|(
operator|&
name|r
argument_list|,
name|tmp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of native_interpret_expr.  Interpret the contents of    the buffer PTR of length LEN as a COMPLEX_CST of type TYPE.    If the buffer cannot be interpreted, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|native_interpret_complex
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|etype
decl_stmt|,
name|rpart
decl_stmt|,
name|ipart
decl_stmt|;
name|int
name|size
decl_stmt|;
name|etype
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|etype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|*
literal|2
operator|>
name|len
condition|)
return|return
name|NULL_TREE
return|;
name|rpart
operator|=
name|native_interpret_expr
argument_list|(
name|etype
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rpart
condition|)
return|return
name|NULL_TREE
return|;
name|ipart
operator|=
name|native_interpret_expr
argument_list|(
name|etype
argument_list|,
name|ptr
operator|+
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ipart
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|rpart
argument_list|,
name|ipart
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of native_interpret_expr.  Interpret the contents of    the buffer PTR of length LEN as a VECTOR_CST of type TYPE.    If the buffer cannot be interpreted, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|native_interpret_vector
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|etype
decl_stmt|,
name|elem
decl_stmt|,
name|elements
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|count
decl_stmt|;
name|etype
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|etype
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|*
name|count
operator|>
name|len
condition|)
return|return
name|NULL_TREE
return|;
name|elements
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|elem
operator|=
name|native_interpret_expr
argument_list|(
name|etype
argument_list|,
name|ptr
operator|+
operator|(
name|i
operator|*
name|size
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elem
condition|)
return|return
name|NULL_TREE
return|;
name|elements
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|elem
argument_list|,
name|elements
argument_list|)
expr_stmt|;
block|}
return|return
name|build_vector
argument_list|(
name|type
argument_list|,
name|elements
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold_view_convert_expr.  Interpret the contents of    the buffer PTR of length LEN as a constant of type TYPE.  For    INTEGRAL_TYPE_P we return an INTEGER_CST, for SCALAR_FLOAT_TYPE_P    we return a REAL_CST, etc...  If the buffer cannot be interpreted,    return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|native_interpret_expr
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|native_interpret_int
argument_list|(
name|type
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|native_interpret_real
argument_list|(
name|type
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|native_interpret_complex
argument_list|(
name|type
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|VECTOR_TYPE
case|:
return|return
name|native_interpret_vector
argument_list|(
name|type
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a VIEW_CONVERT_EXPR of a constant expression EXPR to type    TYPE at compile-time.  If we're unable to perform the conversion    return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_view_convert_expr
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
comment|/* We support up to 512-bit values (for V8DFmode).  */
name|unsigned
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Check that the host and target are sane.  */
if|if
condition|(
name|CHAR_BIT
operator|!=
literal|8
operator|||
name|BITS_PER_UNIT
operator|!=
literal|8
condition|)
return|return
name|NULL_TREE
return|;
name|len
operator|=
name|native_encode_expr
argument_list|(
name|expr
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|native_interpret_expr
argument_list|(
name|type
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a unary expression of code CODE and type TYPE with operand    OP0.  Return the folded expression if folding is successful.    Otherwise, return NULL_TREE.  */
end_comment

begin_function
name|tree
name|fold_unary
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|enum
name|tree_code_class
name|kind
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|kind
argument_list|)
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|arg0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|FLOAT_EXPR
operator|||
name|code
operator|==
name|ABS_EXPR
condition|)
block|{
comment|/* Don't use STRIP_NOPS, because signedness of argument type 	     matters.  */
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Strip any conversions that don't change the mode.  This 	     is safe for every expression, except for a comparison 	     expression because its signedness is derived from its 	     operands.  	     Note that this is done as an internal manipulation within 	     the constant folder, in order to find the simplest 	     representation of the arguments so that their form can be 	     studied.  In any cases, the appropriate type conversions 	     should be put back in the tree that will get out of the 	     constant folder.  */
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg02
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg01
argument_list|)
argument_list|)
condition|)
name|arg01
operator|=
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg01
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg02
argument_list|)
argument_list|)
condition|)
name|arg02
operator|=
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg02
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg01
argument_list|,
name|arg02
argument_list|)
expr_stmt|;
comment|/* If this was a conversion, and all we did was to move into 	     inside the COND_EXPR, bring it back out.  But leave it if 	     it is a conversion from integer to integer and the 	     result precision is no wider than a word since such a 	     conversion is cheap and may be optimized away by combine, 	     while it couldn't if it were outside the COND_EXPR.  Then return 	     so we don't get into an infinite recursion loop taking the 	     conversion out and then back in.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|)
operator|||
name|flag_syntax_only
operator|)
condition|)
name|tem
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
block|{
name|arg0
operator|=
name|copy_node
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|arg0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|==
name|type
condition|)
return|return
name|op0
return|;
comment|/* If we have (type) (a CMP b) and type is an integral type, return          new expression involving the new type.  */
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Handle cases of two conversions in a row.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|inside_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inter_type
init|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|int
name|inside_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_vec
init|=
name|TREE_CODE
argument_list|(
name|inside_type
argument_list|)
operator|==
name|VECTOR_TYPE
decl_stmt|;
name|unsigned
name|int
name|inside_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inter_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_vec
init|=
name|TREE_CODE
argument_list|(
name|inter_type
argument_list|)
operator|==
name|VECTOR_TYPE
decl_stmt|;
name|unsigned
name|int
name|inter_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|final_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|final_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|final_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|final_vec
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
decl_stmt|;
name|unsigned
name|int
name|final_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|final_unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* In addition to the cases of two conversions in a row 	     handled below, if we are converting something to its own 	     type via an object of identical or wider precision, neither 	     conversion is needed.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|inside_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|inter_int
operator|||
name|inter_ptr
operator|)
operator|&&
name|final_int
operator|)
operator|||
operator|(
name|inter_float
operator|&&
name|final_float
operator|)
operator|)
operator|&&
name|inter_prec
operator|>=
name|final_prec
condition|)
return|return
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Likewise, if the intermediate and final types are either both 	     float or both integer, we don't need the middle conversion if 	     it is wider than the final type and doesn't change the signedness 	     (for integers).  Avoid this if the final type is a pointer 	     since then we sometimes need the inner conversion.  Likewise if 	     the outer has a precision not equal to the size of its mode.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inter_int
operator|||
name|inter_ptr
operator|)
operator|&&
operator|(
name|inside_int
operator|||
name|inside_ptr
operator|)
operator|)
operator|||
operator|(
name|inter_float
operator|&&
name|inside_float
operator|)
operator|||
operator|(
name|inter_vec
operator|&&
name|inside_vec
operator|)
operator|)
operator|&&
name|inter_prec
operator|>=
name|inside_prec
operator|&&
operator|(
name|inter_float
operator|||
name|inter_vec
operator|||
name|inter_unsignedp
operator|==
name|inside_unsignedp
operator|)
operator|&&
operator|!
operator|(
name|final_prec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|inter_type
argument_list|)
operator|)
operator|&&
operator|!
name|final_ptr
operator|&&
operator|(
operator|!
name|final_vec
operator|||
name|inter_prec
operator|==
name|inside_prec
operator|)
condition|)
return|return
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If we have a sign-extension of a zero-extended value, we can 	     replace that by a single zero-extension.  */
if|if
condition|(
name|inside_int
operator|&&
name|inter_int
operator|&&
name|final_int
operator|&&
name|inside_prec
operator|<
name|inter_prec
operator|&&
name|inter_prec
operator|<
name|final_prec
operator|&&
name|inside_unsignedp
operator|&&
operator|!
name|inter_unsignedp
condition|)
return|return
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Two conversions in a row are not needed unless: 	     - some conversion is floating-point (overstrict for now), or 	     - some conversion is a vector (overstrict for now), or 	     - the intermediate type is narrower than both initial and 	       final, or 	     - the intermediate type and innermost type differ in signedness, 	       and the outermost type is wider than the intermediate, or 	     - the initial type is a pointer type and the precisions of the 	       intermediate and final types differ, or 	     - the final type is a pointer type and the precisions of the 	       initial and intermediate types differ. 	     - the final type is a pointer type and the initial type not 	     - the initial type is a pointer to an array and the final type 	       not.  */
comment|/* Java pointer type conversions generate checks in some 	     cases, so we explicitly disallow this optimization.  */
if|if
condition|(
operator|!
name|inside_float
operator|&&
operator|!
name|inter_float
operator|&&
operator|!
name|final_float
operator|&&
operator|!
name|inside_vec
operator|&&
operator|!
name|inter_vec
operator|&&
operator|!
name|final_vec
operator|&&
operator|(
name|inter_prec
operator|>=
name|inside_prec
operator|||
name|inter_prec
operator|>=
name|final_prec
operator|)
operator|&&
operator|!
operator|(
name|inside_int
operator|&&
name|inter_int
operator|&&
name|inter_unsignedp
operator|!=
name|inside_unsignedp
operator|&&
name|inter_prec
operator|<
name|final_prec
operator|)
operator|&&
operator|(
operator|(
name|inter_unsignedp
operator|&&
name|inter_prec
operator|>
name|inside_prec
operator|)
operator|==
operator|(
name|final_unsignedp
operator|&&
name|final_prec
operator|>
name|inter_prec
operator|)
operator|)
operator|&&
operator|!
operator|(
name|inside_ptr
operator|&&
name|inter_prec
operator|!=
name|final_prec
operator|)
operator|&&
operator|!
operator|(
name|final_ptr
operator|&&
name|inside_prec
operator|!=
name|inter_prec
operator|)
operator|&&
operator|!
operator|(
name|final_prec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|inter_type
argument_list|)
operator|)
operator|&&
name|final_ptr
operator|==
name|inside_ptr
operator|&&
operator|!
operator|(
name|inside_ptr
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_type
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
operator|&&
operator|!
operator|(
operator|(
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU Java"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|final_ptr
operator|)
condition|)
return|return
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Handle (T *)&A.B.C for A being of type T and B and C 	 living at offset zero.  This occurs frequently in 	 C++ upcasting and then accessing the base.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|handled_component_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|volatilep
decl_stmt|;
name|tree
name|base
init|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|base
operator|=
name|get_inner_reference
argument_list|(
name|base
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If the reference was to a (constant) zero offset, we can use 	     the address of the base if it has the same base type 	     as the result type.  */
if|if
condition|(
operator|!
name|offset
operator|&&
name|bitpos
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|base
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
comment|/* Detect assigning a bitfield.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't leave an assignment inside a conversion 	     unless assigning a bitfield.  */
name|tem
operator|=
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First do the assignment, then return converted constant.  */
name|tem
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|tem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|tem
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* Convert (T)(x& c) into (T)x& (T)c, if c is an integer 	 constants (if x has signed type, the sign bit cannot be set 	 in c).  This folds extension into the BIT_AND_EXPR.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|and
init|=
name|op0
decl_stmt|;
name|tree
name|and0
init|=
name|TREE_OPERAND
argument_list|(
name|and
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|and1
init|=
name|TREE_OPERAND
argument_list|(
name|and
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|change
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|and
argument_list|)
argument_list|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|and
argument_list|)
argument_list|)
operator|)
condition|)
name|change
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|and1
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|host_integerp
argument_list|(
name|and1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|cst
decl_stmt|;
name|cst
operator|=
name|tree_low_cst
argument_list|(
name|and1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cst
operator|&=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|and1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|change
operator|=
operator|(
name|cst
operator|==
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|change
operator|&&
operator|!
name|flag_syntax_only
operator|&&
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|and0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
condition|)
block|{
name|tree
name|uns
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|and0
argument_list|)
argument_list|)
decl_stmt|;
name|and0
operator|=
name|fold_convert
argument_list|(
name|uns
argument_list|,
name|and0
argument_list|)
expr_stmt|;
name|and1
operator|=
name|fold_convert
argument_list|(
name|uns
argument_list|,
name|and1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|change
condition|)
block|{
name|tem
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|and1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|and1
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|force_fit_type
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|,
name|TREE_OVERFLOW
argument_list|(
name|and1
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|and1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|and0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
comment|/* Convert (T1)((T2)X op Y) into (T1)X op Y, for pointer types T1 and 	 T2 being pointers to types of the same size.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|BINARY_CLASS_P
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|t0
init|=
name|type
decl_stmt|;
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
decl_stmt|;
name|tree
name|tt0
init|=
name|TREE_TYPE
argument_list|(
name|t0
argument_list|)
decl_stmt|;
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|s0
init|=
name|TYPE_SIZE
argument_list|(
name|tt0
argument_list|)
decl_stmt|;
name|tree
name|s1
init|=
name|TYPE_SIZE
argument_list|(
name|tt1
argument_list|)
decl_stmt|;
if|if
condition|(
name|s0
operator|&&
name|s1
operator|&&
name|operand_equal_p
argument_list|(
name|s0
argument_list|,
name|s1
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|t0
argument_list|,
name|fold_convert
argument_list|(
name|t0
argument_list|,
name|arg00
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert (T1)(~(T2)X) into ~(T1)X if T1 and T2 are integral types 	 of the same precision, and X is a integer type not narrower than 	 types T1 or T2, i.e. the cast (T2)X isn't an extension.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|tem
condition|?
name|tem
else|:
name|NULL_TREE
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
return|return
name|fold_build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|fold_view_convert_expr
argument_list|(
name|type
argument_list|,
name|op0
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
name|tem
operator|=
name|fold_negate_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|fold_abs_const
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Convert fabs((double)float) into (double)fabsf(float).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tree
name|targ0
init|=
name|strip_float_extensions
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|targ0
operator|!=
name|arg0
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|targ0
argument_list|)
argument_list|,
name|targ0
argument_list|)
argument_list|)
return|;
block|}
comment|/* ABS_EXPR<ABS_EXPR<x>> = ABS_EXPR<x> even if flag_wrapv is on.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ABS_EXPR
condition|)
return|return
name|arg0
return|;
elseif|else
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Strip sign ops from argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tem
operator|=
name|fold_strip_sign_ops
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|CONJ_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|rpart
init|=
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ipart
init|=
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|rpart
argument_list|,
name|negate_expr
argument_list|(
name|ipart
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|rpart
init|=
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ipart
init|=
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|rpart
argument_list|,
name|negate_expr
argument_list|(
name|ipart
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONJ_EXPR
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold_not_const
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Convert ~ (-A) to A - 1.  */
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Convert ~ (A - 1) or ~ (A + -1) to -A.  */
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|integer_all_onesp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Convert ~(X ^ Y) to ~X ^ Y or X ^ ~Y if ~X or ~Y simplify.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
operator|(
name|tem
operator|=
name|fold_unary
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
operator|(
name|tem
operator|=
name|fold_unary
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
comment|/* The argument to invert_truthvalue must have Boolean type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
name|arg0
operator|=
name|fold_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
comment|/* Note that the operand of this must be an int 	 and its values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language, 	 but we don't handle values other than 1 correctly yet.)  */
name|tem
operator|=
name|fold_truth_not_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|itype
argument_list|,
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONJ_EXPR
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|itype
argument_list|,
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONJ_EXPR
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|itype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* switch (code) */
block|}
end_function

begin_comment
comment|/* Fold a binary expression of code CODE and type TYPE with operands    OP0 and OP1, containing either a MIN-MAX or a MAX-MIN combination.    Return the folded expression if folding is successful.  Otherwise,    return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_minmax
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|enum
name|tree_code
name|compl_code
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MIN_EXPR
condition|)
name|compl_code
operator|=
name|MAX_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|compl_code
operator|=
name|MIN_EXPR
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* MIN (MAX (a, b), b) == b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|compl_code
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|op1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* MIN (MAX (b, a), b) == b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|compl_code
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|op1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* MIN (a, MAX (a, b)) == a.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|compl_code
operator|&&
name|operand_equal_p
argument_list|(
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* MIN (a, MAX (b, a)) == a.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|compl_code
operator|&&
name|operand_equal_p
argument_list|(
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold_binary.  This routine performs all of the    transformations that are common to the equality/inequality    operators (EQ_EXPR and NE_EXPR) and the ordering operators    (LT_EXPR, LE_EXPR, GE_EXPR and GT_EXPR).  Callers other than    fold_binary should call fold_binary.  Fold a comparison with    tree code CODE and type TYPE with operands OP0 and OP1.  Return    the folded comparison or NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|tem
decl_stmt|;
name|arg0
operator|=
name|op0
expr_stmt|;
name|arg1
operator|=
name|op1
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_relational_const
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
comment|/* If one arg is a real or integer constant, put it last.  */
if|if
condition|(
name|tree_swap_operands_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
comment|/* Transform comparisons of the form X +- C1 CMP C2 to X CMP C2 +- C1.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
block|{
name|tree
name|const1
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|const2
init|=
name|arg1
decl_stmt|;
name|tree
name|variable
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|lhs
decl_stmt|;
name|int
name|lhs_add
decl_stmt|;
name|lhs_add
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|PLUS_EXPR
expr_stmt|;
name|lhs
operator|=
name|fold_build2
argument_list|(
name|lhs_add
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|const2
argument_list|,
name|const1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|!
name|TREE_OVERFLOW
argument_list|(
name|lhs
argument_list|)
operator|)
condition|)
block|{
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur "
literal|"when changing X +- C1 cmp C2 to "
literal|"X cmp C1 +- C2"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_COMPARISON
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|variable
argument_list|,
name|lhs
argument_list|)
return|;
block|}
block|}
comment|/* If this is a comparison of two exprs that look like an ARRAY_REF of the      same object, then we can fold this to a comparison of the two offsets in      signed size type.  This is possible because pointer arithmetic is      restricted to retain within an object and overflow on pointer differences      is undefined as of 6.5.6/8 and /9 with respect to the signed ptrdiff_t.       We check flag_wrapv directly because pointers types are unsigned,      and therefore TYPE_OVERFLOW_WRAPS returns true for them.  That is      normally what we want to avoid certain odd overflow cases, but      not here.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_wrapv
operator|&&
operator|!
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|base0
decl_stmt|,
name|offset0
decl_stmt|,
name|base1
decl_stmt|,
name|offset1
decl_stmt|;
if|if
condition|(
name|extract_array_ref
argument_list|(
name|arg0
argument_list|,
operator|&
name|base0
argument_list|,
operator|&
name|offset0
argument_list|)
operator|&&
name|extract_array_ref
argument_list|(
name|arg1
argument_list|,
operator|&
name|base1
argument_list|,
operator|&
name|offset1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|base0
argument_list|,
name|base1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|signed_size_type_node
decl_stmt|;
name|signed_size_type_node
operator|=
name|signed_type_for
argument_list|(
name|size_type_node
argument_list|)
expr_stmt|;
comment|/* By converting to signed size type we cover middle-end pointer 	     arithmetic which operates on unsigned pointer types of size 	     type size and ARRAY_REF offsets which are properly sign or 	     zero extended from their type in case it is narrower than 	     size type.  */
if|if
condition|(
name|offset0
operator|==
name|NULL_TREE
condition|)
name|offset0
operator|=
name|build_int_cst
argument_list|(
name|signed_size_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|offset0
operator|=
name|fold_convert
argument_list|(
name|signed_size_type_node
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset1
operator|==
name|NULL_TREE
condition|)
name|offset1
operator|=
name|build_int_cst
argument_list|(
name|signed_size_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|offset1
operator|=
name|fold_convert
argument_list|(
name|signed_size_type_node
argument_list|,
name|offset1
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|offset0
argument_list|,
name|offset1
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|targ0
init|=
name|strip_float_extensions
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|targ1
init|=
name|strip_float_extensions
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|targ0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ1
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
condition|)
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|targ1
argument_list|)
expr_stmt|;
comment|/* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|targ0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|targ1
argument_list|)
argument_list|)
return|;
comment|/* (-a) CMP (-b) -> b CMP a  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|REAL_VALUE_TYPE
name|cst
decl_stmt|;
name|cst
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* (-a) CMP CST -> a swap(CMP) (-CST)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|cst
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* IEEE doesn't distinguish +0 and -0 in comparisons.  */
comment|/* a CMP (-0) -> a CMP 0  */
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|cst
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
return|;
comment|/* x != NaN is always true, other ops are always false.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|cst
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
operator|(
name|code
operator|==
name|NE_EXPR
operator|)
condition|?
name|integer_one_node
else|:
name|integer_zero_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|tem
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* Fold comparisons against infinity.  */
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_inf_compare
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
block|}
comment|/* If this is a comparison of a real constant with a PLUS_EXPR 	 or a MINUS_EXPR of a real constant, we can convert it into a 	 comparison with a revised real constant as long as no overflow 	 occurs when unsafe_math_optimizations are enabled.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
comment|/* Likewise, we can simplify a comparison of a real constant with          a MINUS_EXPR whose first operand is also a real constant, i.e.          (c1 - x)< c2 becomes x> c1-c2.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
comment|/* Fold comparisons against built-in math functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|flag_unsafe_math_optimizations
operator|&&
operator|!
name|flag_errno_math
condition|)
block|{
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fcode
operator|!=
name|END_BUILTINS
condition|)
block|{
name|tem
operator|=
name|fold_mathfn_compare
argument_list|(
name|fcode
argument_list|,
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
block|}
block|}
comment|/* Convert foo++ == CONST into ++foo == CONST + INCR.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|)
comment|/* This optimization is invalid for ordered comparisons          if CONST+INCR overflows or if foo+incr might overflow. 	 This optimization is invalid for floating point due to rounding. 	 For pointer types we assume overflow doesn't happen.  */
operator|&&
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|varop
decl_stmt|,
name|newconst
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
name|newconst
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|varop
operator|=
name|build2
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newconst
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|varop
operator|=
name|build2
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If VAROP is a reference to a bitfield, we must mask 	 the constant by the width of the field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|fielddecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|size
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|fielddecl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|folded_compare
decl_stmt|,
name|shift
decl_stmt|;
comment|/* First check whether the comparison would come out 	     always the same.  If we don't do that we would 	     change the meaning with the masking.  */
name|folded_compare
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|folded_compare
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|folded_compare
argument_list|,
name|varop
argument_list|)
return|;
name|shift
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|-
name|size
argument_list|)
expr_stmt|;
name|shift
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|newconst
operator|=
name|fold_build2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|newconst
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|newconst
operator|=
name|fold_build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|newconst
argument_list|,
name|shift
argument_list|)
expr_stmt|;
block|}
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|varop
argument_list|,
name|newconst
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
condition|)
block|{
comment|/* If we are widening one operand of an integer comparison, 	 see if the other operand is similarly being widened.  Perhaps we 	 can do the comparison in the narrower type.  */
name|tem
operator|=
name|fold_widened_comparison
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* Or if we are changing signedness.  */
name|tem
operator|=
name|fold_sign_changed_comparison
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
comment|/* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a      constant, we can simplify it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MAX_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|optimize_minmax_comparison
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
comment|/* Simplify comparison of something with itself.  (For IEEE      floating-point, we can only do some of these simplifications.)  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
comment|/* For NE, we can only do this simplification if integer 	     or we don't honor IEEE floating point NaNs.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* ... fall through ...  */
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we are comparing an expression that just has comparisons      of two integer values, arithmetic expressions of those comparisons,      and constants, we can simplify it.  There are only three cases      to check: the two values can either be equal, the first can be      greater, or the second can be greater.  Fold the expression for      those three values.  Since each value must be 0 or 1, we have      eight possibilities, each of which corresponds to the constant 0      or 1 or one of the six possible comparisons.       This handles common cases like (a> b) == 0 but also handles      expressions like  ((x> y) - (y> x))> 0, which supposedly      occur in macroized code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|tree
name|cval1
init|=
literal|0
decl_stmt|,
name|cval2
init|=
literal|0
decl_stmt|;
name|int
name|save_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|twoval_comparison_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|cval1
argument_list|,
operator|&
name|cval2
argument_list|,
operator|&
name|save_p
argument_list|)
comment|/* Don't handle degenerate cases here; they should already 	     have been handled anyway.  */
operator|&&
name|cval1
operator|!=
literal|0
operator|&&
name|cval2
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CONSTANT
argument_list|(
name|cval1
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|cval2
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
argument_list|)
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|maxval
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|minval
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We can't just pass T to eval_subst in case cval1 or cval2 	     was the same as ARG1.  */
name|tree
name|high_result
init|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|minval
argument_list|)
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|equal_result
init|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|low_result
init|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|minval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
comment|/* All three of these results should be 0 or 1.  Confirm they are. 	     Then use those values to select the proper code to use.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|high_result
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|equal_result
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|low_result
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Make a 3-bit mask with the high-order bit being the 		 value for `>', the next for '=', and the low for '<'.  */
switch|switch
condition|(
operator|(
name|integer_onep
argument_list|(
name|high_result
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|integer_onep
argument_list|(
name|equal_result
argument_list|)
operator|*
literal|2
operator|)
operator|+
name|integer_onep
argument_list|(
name|low_result
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Always false.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
literal|1
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|code
operator|=
name|NE_EXPR
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Always true.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
block|}
if|if
condition|(
name|save_p
condition|)
return|return
name|save_expr
argument_list|(
name|build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
argument_list|)
return|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Fold a comparison of the address of COMPONENT_REFs with the same      type and component to a comparison of the address of the base      object.  In short,&x->a OP&y->a to x OP y and&x->a OP&y.a to x OP&y  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|cref0
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cref1
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|cref0
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|cref1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cref0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cref1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|op0
argument_list|)
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* We can fold X/C1 op C2 where C1 and C2 are integer constants      into a single range test.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|EXACT_DIV_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_div_compare
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold_binary.  Optimize complex multiplications of the    form z * conj(z), as pow(realpart(z),2) + pow(imagpart(z),2).  The    argument EXPR represents the expression "z" of type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_mult_zconjz
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|rpart
decl_stmt|,
name|ipart
decl_stmt|,
name|tem
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
block|{
name|rpart
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
name|rpart
operator|=
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|itype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|itype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
name|rpart
operator|=
name|save_expr
argument_list|(
name|rpart
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|save_expr
argument_list|(
name|ipart
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|itype
argument_list|,
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|itype
argument_list|,
name|rpart
argument_list|,
name|rpart
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|itype
argument_list|,
name|ipart
argument_list|,
name|ipart
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a binary expression of code CODE and type TYPE with operands    OP0 and OP1.  Return the folded expression if folding is    successful.  Otherwise, return NULL_TREE.  */
end_comment

begin_function
name|tree
name|fold_binary
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|enum
name|tree_code_class
name|kind
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|t1
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|strict_overflow_p
decl_stmt|;
name|gcc_assert
argument_list|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|kind
argument_list|)
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|2
operator|&&
name|op0
operator|!=
name|NULL_TREE
operator|&&
name|op1
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|op0
expr_stmt|;
name|arg1
operator|=
name|op1
expr_stmt|;
comment|/* Strip any conversions that don't change the mode.  This is      safe for every expression, except for a comparison expression      because its signedness is derived from its operands.  So, in      the latter case, only strip conversions that don't change the      signedness.       Note that this is done as an internal manipulation within the      constant folder, in order to find the simplest representation      of the arguments so that their form can be studied.  In any      cases, the appropriate type conversions should be put back in      the tree that will get out of the constant folder.  */
if|if
condition|(
name|kind
operator|==
name|tcc_comparison
condition|)
block|{
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* Note that TREE_CONSTANT isn't enough: static var addresses are      constant but we can't do arithmetic on them.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|VECTOR_CST
operator|)
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|tcc_binary
condition|)
name|tem
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|tcc_comparison
condition|)
name|tem
operator|=
name|fold_relational_const
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|!=
name|type
condition|)
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
comment|/* If this is a commutative operation, and ARG0 is a constant, move it      to ARG1 to reduce the number of tests below.  */
if|if
condition|(
name|commutative_tree_code
argument_list|(
name|code
argument_list|)
operator|&&
name|tree_swap_operands_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
comment|/* ARG0 is the first operand of EXPR, and ARG1 is the second operand.       First check for cases where an arithmetic operation is applied to a      compound, conditional, or comparison operation.  Push the arithmetic      operation inside the compound or conditional to see if any folding      can then be done.  Convert comparison to conditional for this purpose.      The also optimizes non-constant cases that used to be done in      expand_expr.       Before we do that, see if this is a BIT_AND_EXPR or a BIT_IOR_EXPR,      one of the operands is a comparison and the other is a comparison, a      BIT_AND_EXPR with the constant 1, or a truth value.  In that case, the      code below would make the expression more complex.  Change it to a      TRUTH_{AND,OR}_EXPR.  Likewise, convert a similar NE_EXPR to      TRUTH_XOR_EXPR and an EQ_EXPR to the inversion of a TRUTH_XOR_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|BIT_AND_EXPR
operator|||
name|code
operator|==
name|BIT_IOR_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tem
operator|=
name|fold_build2
argument_list|(
name|code
operator|==
name|BIT_AND_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|code
operator|==
name|BIT_IOR_EXPR
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_XOR_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|fold_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|COMPARISON_CLASS_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_binary_op_with_conditional_arg
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
comment|/*cond_first_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|COMPARISON_CLASS_P
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_binary_op_with_conditional_arg
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|,
comment|/*cond_first_p=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* A + (-B) -> A - B */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (-A) + B -> B - A */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert ~A + 1 to -A.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Handle (A1 * C1) + (A2 * C2) with A1, A2 or C1, C2 being the 	 same or one.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|&&
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
block|{
name|tree
name|tem
init|=
name|fold_plusminus_mult_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If we are adding two BIT_AND_EXPR's, both of which are and'ing 	     with a constant, and the two constants have no bits in common, 	     we should treat this as a BIT_IOR_EXPR since this may produce more 	     simplifications.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
goto|goto
name|bit_ior
goto|;
block|}
comment|/* Reassociate (plus (plus (mult) (foo)) (mult)) as 	     (plus (plus (mult) (mult)) (foo)) so that we can 	     take advantage of the factoring cases below.  */
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|)
condition|)
block|{
name|tree
name|parg0
decl_stmt|,
name|parg1
decl_stmt|,
name|parg
decl_stmt|,
name|marg
decl_stmt|;
name|enum
name|tree_code
name|pcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
name|parg
operator|=
name|arg0
operator|,
name|marg
operator|=
name|arg1
expr_stmt|;
else|else
name|parg
operator|=
name|arg1
operator|,
name|marg
operator|=
name|arg0
expr_stmt|;
name|pcode
operator|=
name|TREE_CODE
argument_list|(
name|parg
argument_list|)
expr_stmt|;
name|parg0
operator|=
name|TREE_OPERAND
argument_list|(
name|parg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parg1
operator|=
name|TREE_OPERAND
argument_list|(
name|parg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|parg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|parg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|parg1
argument_list|)
operator|!=
name|MULT_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|pcode
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|marg
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parg0
argument_list|)
operator|!=
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|parg1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg0
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|pcode
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|marg
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Try replacing&a[i1] + c * i2 with&a[i1 + i2], if c is step 	     of the array.  Loop optimizer sometimes produce this type of 	     expressions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tem
operator|=
name|try_move_mult_to_index
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tem
operator|=
name|try_move_mult_to_index
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* See if ARG1 is zero and X + ARG1 reduces to X.  */
if|if
condition|(
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Likewise if the operands are reversed.  */
if|if
condition|(
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Convert X + -C into X - C.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_negate_const
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|||
operator|!
name|flag_trapping_math
condition|)
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RDIV_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|RDIV_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|&&
operator|(
name|tem
operator|=
name|distribute_real_division
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
comment|/* Convert x+x into x*2.0.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst2
argument_list|)
argument_list|)
return|;
comment|/* Convert a + (b*c + d*e) into (a + b*c) + d*e.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|MULT_EXPR
condition|)
block|{
name|tree
name|tree10
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|tree11
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree11
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|tree10
argument_list|)
operator|==
name|MULT_EXPR
condition|)
block|{
name|tree
name|tree0
decl_stmt|;
name|tree0
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tree10
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|tree0
argument_list|,
name|tree11
argument_list|)
return|;
block|}
block|}
comment|/* Convert (b*c + d*e) + a into b*c + (d*e +a).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|MULT_EXPR
condition|)
block|{
name|tree
name|tree00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|tree01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree01
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|tree00
argument_list|)
operator|==
name|MULT_EXPR
condition|)
block|{
name|tree
name|tree0
decl_stmt|;
name|tree0
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|tree01
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|tree00
argument_list|,
name|tree0
argument_list|)
return|;
block|}
block|}
block|}
name|bit_rotate
label|:
comment|/* (A<< C1) + (A>> C2) if A is unsigned and C1+C2 is the size of A 	 is a rotate of A by C1 bits.  */
comment|/* (A<< B) + (A>> (Z - B)) if A is unsigned and Z is the size of A 	 is a rotate of A by B bits.  */
block|{
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|code0
operator|==
name|RSHIFT_EXPR
operator|&&
name|code1
operator|==
name|LSHIFT_EXPR
operator|)
operator|||
operator|(
name|code1
operator|==
name|RSHIFT_EXPR
operator|&&
name|code0
operator|==
name|LSHIFT_EXPR
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tree01
decl_stmt|,
name|tree11
decl_stmt|;
name|enum
name|tree_code
name|code01
decl_stmt|,
name|code11
decl_stmt|;
name|tree01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tree11
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree01
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree11
argument_list|)
expr_stmt|;
name|code01
operator|=
name|TREE_CODE
argument_list|(
name|tree01
argument_list|)
expr_stmt|;
name|code11
operator|=
name|TREE_CODE
argument_list|(
name|tree11
argument_list|)
expr_stmt|;
if|if
condition|(
name|code01
operator|==
name|INTEGER_CST
operator|&&
name|code11
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|tree01
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|tree11
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|tree01
argument_list|)
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|tree11
argument_list|)
operator|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|build2
argument_list|(
name|LROTATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code0
operator|==
name|LSHIFT_EXPR
condition|?
name|tree01
else|:
name|tree11
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code11
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|tree110
decl_stmt|,
name|tree111
decl_stmt|;
name|tree110
operator|=
name|TREE_OPERAND
argument_list|(
name|tree11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree111
operator|=
name|TREE_OPERAND
argument_list|(
name|tree11
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree110
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree111
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree110
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|tree110
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|tree01
argument_list|,
name|tree111
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build2
argument_list|(
operator|(
name|code0
operator|==
name|LSHIFT_EXPR
condition|?
name|LROTATE_EXPR
else|:
name|RROTATE_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree01
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code01
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|tree010
decl_stmt|,
name|tree011
decl_stmt|;
name|tree010
operator|=
name|TREE_OPERAND
argument_list|(
name|tree01
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree011
operator|=
name|TREE_OPERAND
argument_list|(
name|tree01
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree010
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree011
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree010
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|tree010
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|tree11
argument_list|,
name|tree011
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build2
argument_list|(
operator|(
name|code0
operator|!=
name|LSHIFT_EXPR
condition|?
name|LROTATE_EXPR
else|:
name|RROTATE_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree11
argument_list|)
return|;
block|}
block|}
block|}
name|associate
label|:
comment|/* In most languages, can't associate operations on floats through 	 parentheses.  Rather than remember where the parentheses were, we 	 don't associate floats at all, unless the user has specified 	 -funsafe-math-optimizations.  */
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tree
name|var0
decl_stmt|,
name|con0
decl_stmt|,
name|lit0
decl_stmt|,
name|minus_lit0
decl_stmt|;
name|tree
name|var1
decl_stmt|,
name|con1
decl_stmt|,
name|lit1
decl_stmt|,
name|minus_lit1
decl_stmt|;
name|bool
name|ok
init|=
name|true
decl_stmt|;
comment|/* Split both trees into variables, constants, and literals.  Then 	     associate each group together, the constants with literals, 	     then the result with variables.  This increases the chances of 	     literals being recombined later and of generating relocatable 	     expressions for the sum of a constant and literal.  */
name|var0
operator|=
name|split_tree
argument_list|(
name|arg0
argument_list|,
name|code
argument_list|,
operator|&
name|con0
argument_list|,
operator|&
name|lit0
argument_list|,
operator|&
name|minus_lit0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|var1
operator|=
name|split_tree
argument_list|(
name|arg1
argument_list|,
name|code
argument_list|,
operator|&
name|con1
argument_list|,
operator|&
name|lit1
argument_list|,
operator|&
name|minus_lit1
argument_list|,
name|code
operator|==
name|MINUS_EXPR
argument_list|)
expr_stmt|;
comment|/* With undefined overflow we can only associate constants 	     with one variable.  */
if|if
condition|(
operator|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|flag_wrapv
operator|)
operator|)
operator|)
operator|&&
name|var0
operator|&&
name|var1
condition|)
block|{
name|tree
name|tmp0
init|=
name|var0
decl_stmt|;
name|tree
name|tmp1
init|=
name|var1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
name|tmp0
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
name|tmp1
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The only case we can still associate with two variables 		 is if they are the same, modulo negation.  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|tmp0
argument_list|,
name|tmp1
argument_list|,
literal|0
argument_list|)
condition|)
name|ok
operator|=
name|false
expr_stmt|;
block|}
comment|/* Only do something if we found more than two objects.  Otherwise, 	     nothing has changed and we risk infinite recursion.  */
if|if
condition|(
name|ok
operator|&&
operator|(
literal|2
operator|<
operator|(
operator|(
name|var0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|var1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|con0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|con1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|lit0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|lit1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|minus_lit0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|minus_lit1
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Recombine MINUS_EXPR operands by using PLUS_EXPR.  */
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
name|var0
operator|=
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|var1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|con1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|lit0
operator|=
name|associate_trees
argument_list|(
name|lit0
argument_list|,
name|lit1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|minus_lit0
operator|=
name|associate_trees
argument_list|(
name|minus_lit0
argument_list|,
name|minus_lit1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Preserve the MINUS_EXPR if the negative part of the literal is 		 greater than the positive part.  Otherwise, the multiplicative 		 folding code (i.e extract_muldiv) may be fooled in case 		 unsigned constants are subtracted, like in the following 		 example: ((X*2 + 4) - 8U)/2.  */
if|if
condition|(
name|minus_lit0
operator|&&
name|lit0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lit0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|minus_lit0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|lit0
argument_list|,
name|minus_lit0
argument_list|)
condition|)
block|{
name|minus_lit0
operator|=
name|associate_trees
argument_list|(
name|minus_lit0
argument_list|,
name|lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|lit0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lit0
operator|=
name|associate_trees
argument_list|(
name|lit0
argument_list|,
name|minus_lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|minus_lit0
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minus_lit0
condition|)
block|{
if|if
condition|(
name|con0
operator|==
literal|0
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|minus_lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
else|else
block|{
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|minus_lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|con0
argument_list|,
name|PLUS_EXPR
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
block|}
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|lit0
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|con0
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* A - (-B) -> A + B */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (-A) - B -> (-B) - A  where B is easily negated and we can swap.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|flag_wrapv
operator|&&
operator|!
name|flag_trapv
operator|)
operator|)
operator|&&
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Convert -A - 1 to ~A.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert -1 - A to ~A.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|negate_expr
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Fold A - (A& B) into ~B& A.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* Fold (A& ~B) - (A& B) into (A ^ B) - B, where B is 	     any power of 2 minus 1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|mask0
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|mask1
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|tem
init|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|mask0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|tem
argument_list|,
name|mask1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_build2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask1
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|mask1
argument_list|)
return|;
block|}
block|}
block|}
comment|/* See if ARG1 is zero and X - ARG1 reduces to X.  */
elseif|else
if|if
condition|(
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (ARG0 - ARG1) is the same as (-ARG1 + ARG0).  So check whether 	 ARG0 is zero and X + ARG0 reduces to X, since that would mean 	 (-ARG1 + ARG0) reduces to -ARG1.  */
elseif|else
if|if
condition|(
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|negate_expr
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Fold&x -&x.  This can happen from&x.foo -&x. 	 This is unsafe for certain floats even in non-IEEE formats. 	 In IEEE, it is unsafe because it does wrong for NaNs. 	 Also note that operand_equal_p is always false if an operand 	 is volatile.  */
if|if
condition|(
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
comment|/* A - B -> A + (-B) if B is easily negatable.  */
if|if
condition|(
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* Avoid this transformation if B is a positive REAL_CST.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|REAL_CST
operator|||
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|flag_wrapv
operator|&&
operator|!
name|flag_trapv
operator|)
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Try folding difference of addresses.  */
block|{
name|HOST_WIDE_INT
name|diff
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
operator|&&
name|ptr_difference_const
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
operator|&
name|diff
argument_list|)
condition|)
return|return
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|diff
argument_list|)
return|;
block|}
comment|/* Fold&a[i] -&a[j] to i-j.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|aref0
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|aref1
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|aref0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|aref1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|op0
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|aref0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|aref1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|esz
init|=
name|array_ref_element_size
argument_list|(
name|aref0
argument_list|)
decl_stmt|;
name|tree
name|diff
init|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|diff
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|esz
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Try replacing&a[i1] - c * i2 with&a[i1 - i2], if c is step 	 of the array.  Loop optimizer sometimes produce this type of 	 expressions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tem
operator|=
name|try_move_mult_to_index
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RDIV_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|RDIV_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|&&
operator|(
name|tem
operator|=
name|distribute_real_division
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
comment|/* Handle (A1 * C1) - (A2 * C2) with A1, A2 or C1, C2 being the 	 same or one.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|&&
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
block|{
name|tree
name|tem
init|=
name|fold_plusminus_mult_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
goto|goto
name|associate
goto|;
case|case
name|MULT_EXPR
case|:
comment|/* (-A) * (-B) -> A * B  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Transform x * -1 into -x.  */
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (a * (1<< b)) is (a<< b)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not "
literal|"occur when simplifying "
literal|"multiplication"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
comment|/* Optimize z * conj(z) for integer complex numbers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONJ_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_mult_zconjz
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONJ_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_mult_zconjz
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Maybe fold x * 0 to 0.  The expressions aren't the same 	     when x is NaN, since x * 0 is also NaN.  Nor are they the 	     same in modes with signed zeros, since multiplying a 	     negative value by 0 gives -0, not +0.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for snans.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Transform x * -1.0 into -x.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_minus_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Convert (C1/X)*C2 into (C1*C2)/X.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RDIV_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Strip sign operations from X in X*X, i.e. -Y*-Y -> Y*Y.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|fold_strip_sign_ops
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
comment|/* Optimize z * conj(z) for floating point complex numbers. 	     Guarded by flag_unsafe_math_optimizations as non-finite 	     imaginary components don't produce scalar results.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONJ_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_mult_zconjz
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONJ_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_mult_zconjz
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|enum
name|built_in_function
name|fcode0
init|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode1
init|=
name|builtin_mathfn_code
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Optimizations of root(...)*root(...).  */
if|if
condition|(
name|fcode0
operator|==
name|fcode1
operator|&&
name|BUILTIN_ROOT_P
argument_list|(
name|fcode0
argument_list|)
condition|)
block|{
name|tree
name|rootfn
decl_stmt|,
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Optimize sqrt(x)*sqrt(x) as x.  */
if|if
condition|(
name|BUILTIN_SQRT_P
argument_list|(
name|fcode0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|arg00
return|;
comment|/* Optimize root(x)*root(y) as root(x*y).  */
name|rootfn
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|arg10
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|rootfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize expN(x)*expN(y) as expN(x+y).  */
if|if
condition|(
name|fcode0
operator|==
name|fcode1
operator|&&
name|BUILTIN_EXPONENT_P
argument_list|(
name|fcode0
argument_list|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimizations of pow(...)*pow(...).  */
if|if
condition|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_POW
operator|&&
name|fcode1
operator|==
name|BUILT_IN_POW
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_POWF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_POWF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_POWL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_POWL
operator|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg11
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Optimize pow(x,y)*pow(z,y) as pow(x*z,y).  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|arg10
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg01
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize pow(x,y)*pow(x,z) as pow(x,y+z).  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg01
argument_list|,
name|arg11
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg00
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize tan(x)*cos(x) as sin(x).  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_TAN
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COS
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_TANF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_TANL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSL
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COS
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TAN
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TANF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TANL
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|sinfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_SIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|sinfn
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_function_call_expr
argument_list|(
name|sinfn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Optimize x*pow(x,c) as pow(x,c+1).  */
if|if
condition|(
name|fcode1
operator|==
name|BUILT_IN_POW
operator|||
name|fcode1
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode1
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg11
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg11
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg11
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg11
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize pow(x,c)*x as pow(x,c+1).  */
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_POW
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg01
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg00
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize x*x as pow(x,2.0), which is expanded as x*x.  */
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_POW
argument_list|)
decl_stmt|;
if|if
condition|(
name|powfn
condition|)
block|{
name|tree
name|arg
init|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst2
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
block|}
block|}
goto|goto
name|associate
goto|;
case|case
name|BIT_IOR_EXPR
case|:
name|bit_ior
label|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* ~X | X is -1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|t1
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_fit_type
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* X | ~X is -1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|t1
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_fit_type
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* Canonicalize (X& C1) | C2.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|hi1
decl_stmt|,
name|lo1
decl_stmt|,
name|hi2
decl_stmt|,
name|lo2
decl_stmt|,
name|mlo
decl_stmt|,
name|mhi
decl_stmt|;
name|int
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|hi1
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lo1
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|hi2
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|lo2
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* If (C1&C2) == C1, then (X&C1)|C2 becomes (X,C2).  */
if|if
condition|(
operator|(
name|hi1
operator|&
name|hi2
operator|)
operator|==
name|hi1
operator|&&
operator|(
name|lo1
operator|&
name|lo2
operator|)
operator|==
name|lo1
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|mhi
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
expr_stmt|;
name|mlo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mhi
operator|=
literal|0
expr_stmt|;
name|mlo
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
expr_stmt|;
block|}
comment|/* If (C1|C2) == ~0 then (X&C1)|C2 becomes X|C2.  */
if|if
condition|(
operator|(
operator|~
operator|(
name|hi1
operator||
name|hi2
operator|)
operator|&
name|mhi
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|~
operator|(
name|lo1
operator||
name|lo2
operator|)
operator|&
name|mlo
operator|)
operator|==
literal|0
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* Minimize the number of bits set in C1, i.e. C1 := C1& ~C2.  */
name|hi1
operator|&=
name|mhi
expr_stmt|;
name|lo1
operator|&=
name|mlo
expr_stmt|;
if|if
condition|(
operator|(
name|hi1
operator|&
operator|~
name|hi2
operator|)
operator|!=
name|hi1
operator|||
operator|(
name|lo1
operator|&
operator|~
name|lo2
operator|)
operator|!=
name|lo1
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|lo1
operator|&
operator|~
name|lo2
argument_list|,
name|hi1
operator|&
operator|~
name|hi2
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* (X& Y) | Y is (X, Y).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (X& Y) | X is (Y, X).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* X | (X& Y) is (Y, X).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* X | (Y& X) is (Y, X).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
comment|/* Convert (or (not arg0) (not arg1)) to (not (and (arg0) (arg1))).  	 This results in more efficient code for machines without a NAND 	 instruction.  Combine will canonicalize to the first form 	 which will allow use of NAND instructions provided by the 	 backend if they exist.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
return|return
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* See if this can be simplified into a rotate first.  If that 	 is unsuccessful continue in the association code.  */
goto|goto
name|bit_rotate
goto|;
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* ~X ^ X is -1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|t1
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_fit_type
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* X ^ ~X is -1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|t1
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_fit_type
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* If we are XORing two BIT_AND_EXPR's, both of which are and'ing          with a constant, and the two constants have no bits in common, 	 we should treat this as a BIT_IOR_EXPR since this may produce more 	 simplifications.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
goto|goto
name|bit_ior
goto|;
block|}
comment|/* (X | Y) ^ X -> Y& ~ X*/
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|t2
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|t1
operator|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|t1
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
comment|/* (Y | X) ^ X -> Y& ~ X*/
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|t2
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|t1
operator|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|t1
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
comment|/* X ^ (X | Y) -> Y& ~ X*/
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|t2
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|t1
operator|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|t1
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
comment|/* X ^ (Y | X) -> Y& ~ X*/
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|t2
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|t1
operator|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|t1
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
comment|/* Convert ~X ^ ~Y to X ^ Y.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Fold (X& 1) ^ 1 as (X& 1) == 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Fold (X& Y) ^ Y as ~X& Y.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold (X& Y) ^ X as ~Y& X.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold X ^ (X& Y) as X& ~Y.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold X ^ (Y& X) as ~Y& X.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
block|}
comment|/* See if this can be simplified into a rotate first.  If that 	 is unsuccessful continue in the association code.  */
goto|goto
name|bit_rotate
goto|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* ~X& X is always zero.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* X& ~X is always zero.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Canonicalize (X | C1)& C2 as (X& C2) | (C1& C2).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* (X | Y)& Y is (X, Y).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (X | Y)& X is (Y, X).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* X& (X | Y) is (Y, X).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* X& (Y | X) is (Y, X).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Fold (X ^ 1)& 1 as (X& 1) == 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold ~X& 1 as (X& 1) == 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold (X ^ Y)& Y as ~X& Y.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold (X ^ Y)& X as ~Y& X.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold X& (X ^ Y) as X& ~Y.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold X& (Y ^ X) as ~Y& X.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
block|}
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
comment|/* Simplify ((int)c& 0377) into (int)c, if c is unsigned char.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert (and (not arg0) (not arg1)) to (not (or (arg0) (arg1))).  	 This results in more efficient code for machines without a NOR 	 instruction.  Combine will canonicalize to the first form 	 which will allow use of NOR instructions provided by the 	 backend if they exist.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
return|return
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|associate
goto|;
case|case
name|RDIV_EXPR
case|:
comment|/* Don't touch a floating-point divide by zero unless the mode 	 of the constant can represent infinity.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize A / A to 1.0 if we don't care about 	 NaNs or Infinities.  Skip the transformation 	 for non-real operands.  */
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|r
init|=
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|dconst1
argument_list|)
decl_stmt|;
return|return
name|omit_two_operands
argument_list|(
name|type
argument_list|,
name|r
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* The complex version of the above A / A optimization.  */
if|if
condition|(
name|COMPLEX_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|elem_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|elem_type
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|elem_type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|r
init|=
name|build_real
argument_list|(
name|elem_type
argument_list|,
name|dconst1
argument_list|)
decl_stmt|;
comment|/* omit_two_operands will call fold_convert for us.  */
return|return
name|omit_two_operands
argument_list|(
name|type
argument_list|,
name|r
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
block|}
comment|/* (-A) / (-B) -> A / B  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* In IEEE floating point, x/1 is not equivalent to x for snans.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* In IEEE floating point, x/-1 is not equivalent to -x for snans.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_minus_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If ARG1 is a constant, we can convert this to a multiply by the 	 reciprocal.  This does not have the same rounding properties, 	 so only do this if -funsafe-math-optimizations.  We can actually 	 always safely do it if ARG1 is a power of two, but it's hard to 	 tell if it is or not in a portable manner.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
return|;
comment|/* Find the reciprocal if optimizing and the result is exact.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exact_real_inverse
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|tem
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Convert A/B/C to A/(B*C).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RDIV_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Convert A/(B/C) to (A/B)*C.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|RDIV_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Convert C1/(X*C2) into (C1/C2)/X.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|RDIV_EXPR
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|enum
name|built_in_function
name|fcode0
init|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode1
init|=
name|builtin_mathfn_code
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Optimize sin(x)/cos(x) as tan(x).  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_SIN
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COS
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SINF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SINL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSL
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|tanfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_TAN
argument_list|)
decl_stmt|;
if|if
condition|(
name|tanfn
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_function_call_expr
argument_list|(
name|tanfn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Optimize cos(x)/sin(x) as 1.0/tan(x).  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_COS
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SIN
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SINF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SINL
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|tanfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_TAN
argument_list|)
decl_stmt|;
if|if
condition|(
name|tanfn
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|build_function_call_expr
argument_list|(
name|tanfn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|tmp
argument_list|)
return|;
block|}
block|}
comment|/* Optimize sin(x)/tan(x) as cos(x) if we don't care about 	     NaNs or Infinities.  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_SIN
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TAN
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SINF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TANF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SINL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TANL
operator|)
operator|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg01
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|cosfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_COS
argument_list|)
decl_stmt|;
if|if
condition|(
name|cosfn
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_function_call_expr
argument_list|(
name|cosfn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Optimize tan(x)/sin(x) as 1.0/cos(x) if we don't care about 	     NaNs or Infinities.  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_TAN
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SIN
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_TANF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SINF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_TANL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SINL
operator|)
operator|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg01
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|cosfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_COS
argument_list|)
decl_stmt|;
if|if
condition|(
name|cosfn
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|build_function_call_expr
argument_list|(
name|cosfn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|tmp
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Optimize pow(x,c)/x as pow(x,c-1).  */
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_POW
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg01
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg00
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|MINUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize x/expN(y) into x*expN(-y).  */
if|if
condition|(
name|BUILTIN_EXPONENT_P
argument_list|(
name|fcode1
argument_list|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|negate_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* Optimize x/pow(y,z) into x*pow(y,-z).  */
if|if
condition|(
name|fcode1
operator|==
name|BUILT_IN_POW
operator|||
name|fcode1
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode1
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg11
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|neg11
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg11
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg10
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|neg11
argument_list|)
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
comment|/* Simplify A / (B<< N) where A and B are positive and B is 	 a power of 2, to A>> (N + log2(B)).  */
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
operator|)
condition|)
block|{
name|tree
name|sval
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_pow2p
argument_list|(
name|sval
argument_list|)
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|sval
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|sh_cnt
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|pow2
init|=
name|exact_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|sval
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not "
literal|"occur when simplifying A / (B<< N)"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
name|sh_cnt
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sh_cnt
argument_list|)
argument_list|,
name|sh_cnt
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|pow2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|sh_cnt
argument_list|)
return|;
block|}
block|}
comment|/* Fall thru */
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* X / -1 is -X.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Convert -A / -B to A / B when the type is signed and overflow is 	 undefined.  */
if|if
condition|(
operator|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur "
literal|"when distributing negation across "
literal|"division"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur "
literal|"when distributing negation across "
literal|"division"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* If arg0 is a multiple of arg1, then rewrite to the fastest div 	 operation, EXACT_DIV_EXPR.  	 Note that only CEIL_DIV_EXPR and FLOOR_DIV_EXPR are rewritten now. 	 At one time others generated faster code, it's not clear if they do 	 after the last round to changes to the DIV code in expmed.c.  */
if|if
condition|(
operator|(
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|)
operator|&&
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|arg1
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur "
literal|"when simplifying division"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
comment|/* X % 1 is always zero, but be sure to preserve any side 	 effects in X.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* X % 0, return X % 0 unchanged so that we can get the 	 proper warnings and errors.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* 0 % X is always zero, but be sure to preserve any side 	 effects in X.  Place this after checking for X == 0.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* X % -1 is zero.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Optimize TRUNC_MOD_EXPR by a power of two into a BIT_AND_EXPR,          i.e. "X % C" into "X& (C - 1)", if X and C are positive.  */
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|code
operator|==
name|FLOOR_MOD_EXPR
operator|)
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
operator|)
condition|)
block|{
name|tree
name|c
init|=
name|arg1
decl_stmt|;
comment|/* Also optimize A % (C<< N)  where C is a power of 2, 	     to A& ((C<< N) - 1).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
condition|)
name|c
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_pow2p
argument_list|(
name|c
argument_list|)
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|mask
init|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not "
literal|"occur when simplifying "
literal|"X % (power of two)"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|mask
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* X % -C is the same as X % C.  */
if|if
condition|(
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|type
argument_list|)
comment|/* Avoid this transformation if C is INT_MIN, i.e. C == -C.  */
operator|&&
operator|!
name|sign_bit_p
argument_list|(
name|arg1
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* X % -Y is the same as X % Y.  */
if|if
condition|(
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
operator|!
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|arg1
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur "
literal|"when simplifying modulos"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
goto|goto
name|shift
goto|;
case|case
name|RSHIFT_EXPR
case|:
comment|/* Optimize -1>> x for arithmetic right shifts.  */
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|LSHIFT_EXPR
case|:
name|shift
label|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* Since negative shift count is not well-defined, 	 don't try to compute it in the compiler.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Turn (a OP c1) OP c2 into a OP (c1+c2).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|code
operator|&&
name|host_integerp
argument_list|(
name|arg1
argument_list|,
name|false
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|)
decl_stmt|;
comment|/* Deal with a OP (c1 + c2) being undefined but (a OP c1) OP c2 	     being well defined.  */
if|if
condition|(
name|low
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LROTATE_EXPR
operator|||
name|code
operator|==
name|RROTATE_EXPR
condition|)
name|low
operator|=
name|low
operator|%
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|code
operator|==
name|LSHIFT_EXPR
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
else|else
name|low
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|low
argument_list|)
argument_list|)
return|;
block|}
comment|/* Transform (x>> c)<< c into x& (-1<<c), or transform (x<< c)>> c          into x& ((unsigned)-1>> c) for unsigned types.  */
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|LSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|)
operator|||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|code
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|)
operator|)
operator|&&
name|host_integerp
argument_list|(
name|arg1
argument_list|,
name|false
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|low0
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low1
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|lshift
decl_stmt|;
name|tree
name|arg00
decl_stmt|;
if|if
condition|(
name|low0
operator|==
name|low1
condition|)
block|{
name|arg00
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lshift
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lshift
operator|=
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|lshift
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|lshift
argument_list|)
return|;
block|}
block|}
comment|/* Rewrite an LROTATE_EXPR by a constant into an 	 RROTATE_EXPR by a new constant.  */
if|if
condition|(
name|code
operator|==
name|LROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|tem
init|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|tem
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|RROTATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
return|;
block|}
comment|/* If we have a rotate of a bit operation with the rotate count and 	 the second operand of the bit operation both constant, 	 permute the two operations.  */
if|if
condition|(
name|code
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Two consecutive rotates adding up to the width of the mode can 	 be ignored.  */
if|if
condition|(
name|code
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
name|tem
operator|=
name|fold_minmax
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
goto|goto
name|associate
goto|;
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
name|tem
operator|=
name|fold_minmax
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
goto|goto
name|associate
goto|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant zero, return it.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
comment|/* If either arg is constant true, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
comment|/* Preserve sequence points.  */
operator|&&
operator|(
name|code
operator|!=
name|TRUTH_ANDIF_EXPR
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If second arg is constant zero, result is zero, but first arg 	 must be evaluated.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Likewise for first arg, but note that only the TRUTH_AND_EXPR 	 case will be handled here.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* !X&& X is always false.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* X&& !X is always false.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* A< X&& A + 1> Y ==> A< X&& A>= Y.  Normally A + 1> Y 	 means A>= Y&& A != MAX, but in this case we know that 	 A< X<= MAX.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_to_nonsharp_ineq_using_bound
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|tem
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|arg1
argument_list|)
return|;
name|tem
operator|=
name|fold_to_nonsharp_ineq_using_bound
argument_list|(
name|arg1
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|tem
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
return|;
block|}
name|truth_andor
label|:
comment|/* We only do these simplifications if we are optimizing.  */
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Check for things like (A || B)&& (A || C).  We can convert this 	 to A || (B&& C).  Note that either operator can be any of the four 	 truth and/or operations and the transformation will still be 	 valid.   Also note that we only care about order for the 	 ANDIF and ORIF operators.  If B contains side effects, this 	 might change the truth-value of A.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|a00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|a01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|a10
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|a11
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|commutative
init|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_AND_EXPR
operator|)
operator|&&
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|a00
argument_list|,
name|a10
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|a11
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|commutative
operator|&&
name|operand_equal_p
argument_list|(
name|a00
argument_list|,
name|a11
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|a10
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|commutative
operator|&&
name|operand_equal_p
argument_list|(
name|a01
argument_list|,
name|a10
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|a11
argument_list|)
argument_list|)
return|;
comment|/* This case if tricky because we must either have commutative 	     operators or else A10 must not have side-effects.  */
elseif|else
if|if
condition|(
operator|(
name|commutative
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|a10
argument_list|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|a01
argument_list|,
name|a11
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|a10
argument_list|)
argument_list|,
name|a01
argument_list|)
return|;
block|}
comment|/* See if we can build a range comparison.  */
if|if
condition|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|fold_range_test
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
comment|/* Check for the possibility of merging component references.  If our 	 lhs is another similar operation, try to merge its rhs with our 	 rhs.  Then try to merge our lhs and rhs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
if|if
condition|(
operator|(
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
return|return
name|NULL_TREE
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or true. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant true, return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
comment|/* If either arg is constant zero, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
comment|/* Preserve sequence points.  */
operator|&&
operator|(
name|code
operator|!=
name|TRUTH_ORIF_EXPR
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If second arg is constant true, result is true, but we must 	 evaluate first arg.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Likewise for first arg, but note this only occurs here for 	 TRUTH_OR_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* !X || X is always true.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* X || !X is always true.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|truth_andor
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
comment|/* If the second arg is constant zero, drop it.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If the second arg is constant true, this is a logical inversion.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
comment|/* Only call invert_truthvalue if operand is a truth value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
name|tem
operator|=
name|fold_build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
comment|/* Identical arguments cancel to zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* !X ^ X is always true.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* X ^ !X is always true.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|tem
operator|=
name|fold_comparison
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
comment|/* bool_var != 0 becomes bool_var. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|code
operator|==
name|NE_EXPR
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* bool_var == 1 becomes bool_var. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|&&
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* bool_var != 1 becomes !bool_var. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|&&
name|code
operator|==
name|NE_EXPR
condition|)
return|return
name|fold_build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* bool_var == 0 becomes !bool_var. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|fold_build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
return|;
comment|/*  ~a != C becomes a != ~C where C is a constant.  Likewise for ==.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|cmp_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|cmp_type
argument_list|,
name|fold_convert
argument_list|(
name|cmp_type
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is an equality comparison of the address of a non-weak 	 object against zero, then we know the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
name|code
operator|!=
name|EQ_EXPR
argument_list|,
name|type
argument_list|)
return|;
comment|/* If this is an equality comparison of the address of two non-weak, 	 unaliased symbols neither of which are extern (since we do not 	 have access to attributes for externs), then we know the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"alias"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"alias"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We know that we're looking at the address of two 	     non-weak, unaliased, static _DECL nodes.  	     It is both wasteful and incorrect to call operand_equal_p 	     to compare the two ADDR_EXPR nodes.  It is wasteful in that 	     all we need to do is test pointer equality for the arguments 	     to the two ADDR_EXPR nodes.  It is incorrect to use 	     operand_equal_p as that function is NOT equivalent to a 	     C equality test.  It can in fact return false for two 	     objects which would test as equal using the C equality 	     operator.  */
name|bool
name|equal
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|equal
condition|?
name|code
operator|==
name|EQ_EXPR
else|:
name|code
operator|!=
name|EQ_EXPR
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or 	 a MINUS_EXPR of a constant, we can convert it into a comparison with 	 a revised constant as long as no overflow occurs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
comment|/* Similarly for a NEGATE_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|negate_expr
argument_list|(
name|arg1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
comment|/* If we have X - Y == 0, we can convert that to X == Y and similarly 	 for !=.  Don't do this for ordered comparisons due to overflow.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ABS_EXPR
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
name|real_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* If this is an EQ or NE comparison with zero and ARG0 is 	 (1<< foo)& bar, convert it to (bar>> foo)& 1.  Both require 	 two operations, but the latter can be done in one less insn 	 on machines that have only two-operand insns or on which a 	 constant cannot be the first operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg00
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg00
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|fold_build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|arg01
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg00
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|tem
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg01
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|fold_build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg01
argument_list|)
argument_list|,
name|arg00
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg01
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|tem
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
block|}
block|}
comment|/* If this is an NE or EQ comparison of zero against the result of a 	 signed MOD operation whose second operand is a power of 2, make 	 the MOD operation unsigned since it is simpler and equivalent.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CEIL_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ROUND_MOD_EXPR
operator|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|newtype
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newmod
init|=
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|newtype
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|newmod
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold ((X>> C1)& C2) == 0 and ((X>> C1)& C2) != 0 where 	 C1 is a valid shift constant, and C2 is a power of two, i.e. 	 a single bit.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
decl_stmt|;
name|tree
name|arg001
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check for a valid shift count.  */
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg001
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg001
argument_list|)
operator|<
name|prec
condition|)
block|{
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg000
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|log2
init|=
name|tree_log2
argument_list|(
name|arg01
argument_list|)
decl_stmt|;
comment|/* If (C2<< C1) doesn't overflow, then ((X>> C1)& C2) != 0 		 can be rewritten as (X& (C2<< C1)) != 0.  */
if|if
condition|(
operator|(
name|log2
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|arg001
argument_list|)
operator|)
operator|<
name|prec
condition|)
block|{
name|tem
operator|=
name|fold_build2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|itype
argument_list|,
name|arg01
argument_list|,
name|arg001
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|itype
argument_list|,
name|arg000
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* Otherwise, for signed (arithmetic) shifts, 		 ((X>> C1)& C2) != 0 is rewritten as X< 0, and 		 ((X>> C1)& C2) == 0 is rewritten as X>= 0.  */
elseif|else
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|itype
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|GE_EXPR
else|:
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|arg000
argument_list|,
name|build_int_cst
argument_list|(
name|itype
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Otherwise, of unsigned (logical) shifts, 		 ((X>> C1)& C2) != 0 is rewritten as (X,false), and 		 ((X>> C1)& C2) == 0 is rewritten as (X,true).  */
else|else
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|code
operator|==
name|EQ_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|,
name|arg000
argument_list|)
return|;
block|}
block|}
comment|/* If this is an NE comparison of zero with an AND of one, remove the 	 comparison since the AND will give the correct value.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If we have (A& C) == C where C is a power of 2, convert this into 	 (A& C) != 0.  Similarly for NE_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
comment|/* If we have (A& C) != 0 or (A& C) == 0 and C is the sign 	 bit, then fold the expression into A< 0 or A>= 0.  */
name|tem
operator|=
name|fold_single_bit_test_into_sign_test
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* If we have (A& C) == D where D& ~C != 0, convert this into 0. 	 Similarly for NE_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|notc
init|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|dandnotc
init|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|notc
argument_list|)
decl_stmt|;
name|tree
name|rslt
init|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|integer_zero_node
else|:
name|integer_one_node
decl_stmt|;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|dandnotc
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|rslt
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* If we have (A | C) == D where C& ~D != 0, convert this into 0. 	 Similarly for NE_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|notd
init|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|candnotd
init|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|notd
argument_list|)
decl_stmt|;
name|tree
name|rslt
init|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|integer_zero_node
else|:
name|integer_one_node
decl_stmt|;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|candnotd
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|rslt
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* If this is a comparison of a field, we may be able to simplify it.  */
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|lang_hooks
operator|.
name|can_use_bit_fields_p
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|)
comment|/* Handle the constant case even without -O 	     to make sure the warnings are given.  */
operator|&&
operator|(
name|optimize
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|t1
operator|=
name|optimize_bit_field_compare
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
condition|)
return|return
name|t1
return|;
block|}
comment|/* Optimize comparisons of strlen vs zero to a compare of the 	 first character of the string vs zero.  To wit, 		strlen(ptr) == 0   =>  *ptr == 0 		strlen(ptr) != 0   =>  *ptr != 0 	 Other cases should reduce to one of these two (or a constant) 	 due to the return value of strlen being unsigned.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
if|if
condition|(
name|fndecl
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_STRLEN
operator|&&
operator|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|tree
name|iref
init|=
name|build_fold_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|iref
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|iref
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Fold (X>> C) != 0 into X< 0 if C is one less than the width 	 of X.  Similarly fold (X>> C) == 0 into X>= 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg01
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg01
argument_list|)
operator|==
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|itype
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|arg00
operator|=
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|arg00
argument_list|)
expr_stmt|;
block|}
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|GE_EXPR
else|:
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|build_int_cst
argument_list|(
name|itype
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* (X ^ Y) == 0 becomes X == Y, and (X ^ Y) != 0 becomes X != Y.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (X ^ Y) == Y becomes X == 0.  We know that Y has no side-effects.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Likewise (X ^ Y) == X becomes Y == 0.  X has no side-effects.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (X ^ C1) op C2 can be rewritten as X op (C1 ^ C2).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Fold (~X& C) == 0 into (X& C) != 0 and (~X& C) != 0 into 	 (X& C) == 0 when C is a single bit.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* Fold ((X& C) ^ C) eq/ne 0 into (X& C) ne/eq 0, when the 	 constant C is a power of two, i.e. a single bit.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Likewise, fold ((X ^ C)& C) eq/ne 0 into (X& C) ne/eq 0, 	 when is C is a power of two, i.e. a single bit.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
block|{
name|tree
name|arg000
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg000
argument_list|)
argument_list|,
name|arg000
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|tree_expr_nonzero_p
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|tree
name|res
init|=
name|constant_boolean_node
argument_list|(
name|code
operator|==
name|NE_EXPR
argument_list|,
name|type
argument_list|)
decl_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|res
argument_list|,
name|arg0
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|tem
operator|=
name|fold_comparison
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
comment|/* Transform comparisons of the form X +- C CMP X.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code0
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|int
name|is_positive
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|REAL_CST
condition|)
name|is_positive
operator|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg01
argument_list|)
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
else|else
name|is_positive
operator|=
name|tree_int_cst_sgn
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
comment|/* (X - c)> X becomes false.  */
if|if
condition|(
name|code
operator|==
name|GT_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|>=
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not "
literal|"occur when assuming that (X - c)> X "
literal|"is always false"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/* Likewise (X + c)< X becomes false.  */
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|>=
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not "
literal|"occur when assuming that "
literal|"(X + c)< X is always false"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/* Convert (X - c)<= X to true.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|code
operator|==
name|LE_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|>=
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not "
literal|"occur when assuming that "
literal|"(X - c)<= X is always true"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/* Convert (X + c)>= X to true.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|code
operator|==
name|GE_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|>=
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not "
literal|"occur when assuming that "
literal|"(X + c)>= X is always true"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Convert X + c> X and X - c< X to true for integers.  */
if|if
condition|(
name|code
operator|==
name|GT_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|>
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does "
literal|"not occur when assuming that "
literal|"(X + c)> X is always true"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|>
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does "
literal|"not occur when assuming that "
literal|"(X - c)< X is always true"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/* Convert X + c<= X and X - c>= X to false for integers.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|>
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does "
literal|"not occur when assuming that "
literal|"(X + c)<= X is always false"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|GE_EXPR
operator|&&
operator|(
operator|(
name|code0
operator|==
name|MINUS_EXPR
operator|&&
name|is_positive
operator|>
literal|0
operator|)
operator|||
operator|(
name|code0
operator|==
name|PLUS_EXPR
operator|&&
name|is_positive
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does "
literal|"not occur when assuming that "
literal|"(X - c)>= X is always true"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_ALL
argument_list|)
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Change X>= C to X> (C - 1) and X< C to X<= (C - 1) if C> 0. 	 This transformation affects the cases which are handled in later 	 optimizations involving comparisons with non-negative constants.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Comparisons with the highest or lowest possible integer of 	 the specified size will have known values.  */
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|width
operator|<=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|signed_max_hi
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|signed_max_lo
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_hi
decl_stmt|,
name|max_lo
decl_stmt|,
name|min_hi
decl_stmt|,
name|min_lo
decl_stmt|;
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|signed_max_lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|signed_max_hi
operator|=
literal|0
expr_stmt|;
name|max_hi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|max_lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min_lo
operator|=
literal|0
expr_stmt|;
name|min_hi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|max_lo
operator|=
name|signed_max_lo
expr_stmt|;
name|min_lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|min_hi
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|width
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|signed_max_lo
operator|=
operator|-
literal|1
expr_stmt|;
name|signed_max_hi
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|max_lo
operator|=
operator|-
literal|1
expr_stmt|;
name|min_lo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|max_hi
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min_hi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|max_hi
operator|=
name|signed_max_hi
expr_stmt|;
name|min_hi
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
name|max_hi
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|max_lo
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
return|return
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* The GE_EXPR and LT_EXPR cases above are not normally 		   reached because of previous transformations.  */
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
name|max_hi
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|max_lo
operator|-
literal|1
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
name|min_hi
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|min_lo
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
return|return
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
name|min_hi
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|min_lo
operator|+
literal|1
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|in_gimple_form
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
name|signed_max_hi
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|signed_max_lo
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
comment|/* signed_type does not work on pointer types.  */
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The following case also applies to X< signed_max+1 		   and X>= signed_max+1 because previous transformations.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
condition|)
block|{
name|tree
name|st
decl_stmt|;
name|st
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
operator|==
name|LE_EXPR
condition|?
name|GE_EXPR
else|:
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|st
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|/* If we are comparing an ABS_EXPR with a constant, we can 	 convert all the cases into explicit comparisons, but they may 	 well not be faster than doing the ABS and one comparison. 	 But ABS (X)<= C is a range comparison, which becomes a subtraction 	 and a comparison, and is probably faster.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ABS_EXPR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|negate_expr
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|build2
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|,
name|build2
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Convert ABS_EXPR<x>>= 0 to true.  */
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|GE_EXPR
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
operator|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur "
literal|"when simplifying comparison of "
literal|"absolute value and zero"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_CONDITIONAL
argument_list|)
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* Convert ABS_EXPR<x>< 0 to false.  */
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
name|real_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur "
literal|"when simplifying comparison of "
literal|"absolute value and zero"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_CONDITIONAL
argument_list|)
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* If X is unsigned, convert X< (1<< Y) into X>> Y == 0 	 and similarly for>= into !=.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
operator|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|code
operator|==
name|LT_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
operator|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|code
operator|==
name|LT_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|t1
operator|=
name|fold_relational_const
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
block|}
comment|/* If the first operand is NaN, the result is constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|code
operator|!=
name|LTGT_EXPR
operator|||
operator|!
name|flag_trapping_math
operator|)
condition|)
block|{
name|t1
operator|=
operator|(
name|code
operator|==
name|ORDERED_EXPR
operator|||
name|code
operator|==
name|LTGT_EXPR
operator|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* If the second operand is NaN, the result is constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
operator|(
name|code
operator|!=
name|LTGT_EXPR
operator|||
operator|!
name|flag_trapping_math
operator|)
condition|)
block|{
name|t1
operator|=
operator|(
name|code
operator|==
name|ORDERED_EXPR
operator|||
name|code
operator|==
name|LTGT_EXPR
operator|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* Simplify unordered comparison of something with itself.  */
if|if
condition|(
operator|(
name|code
operator|==
name|UNLE_EXPR
operator|||
name|code
operator|==
name|UNGE_EXPR
operator|||
name|code
operator|==
name|UNEQ_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|LTGT_EXPR
operator|&&
operator|!
name|flag_trapping_math
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
comment|/* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */
block|{
name|tree
name|targ0
init|=
name|strip_float_extensions
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|targ1
init|=
name|strip_float_extensions
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|targ0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ1
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
condition|)
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|targ1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|targ0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|targ1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|COMPOUND_EXPR
case|:
comment|/* When pedantic, a compound expression can be neither an lvalue 	 nor an integer constant expression.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't let (0, 0) be null pointer constant.  */
name|tem
operator|=
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|?
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
else|:
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|tem
argument_list|)
return|;
case|case
name|COMPLEX_EXPR
case|:
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|ASSERT_EXPR
case|:
comment|/* An ASSERT_EXPR should never be passed to fold_binary.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* switch (code) */
block|}
end_function

begin_comment
comment|/* Callback for walk_tree, looking for LABEL_EXPR.    Returns tree TP if it is LABEL_EXPR. Otherwise it returns NULL_TREE.    Do not check the sub-tree of GOTO_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|contains_label_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
case|case
name|LABEL_EXPR
case|:
return|return
operator|*
name|tp
return|;
case|case
name|GOTO_EXPR
case|:
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* no break */
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Checks whether the sub-tree ST contains a label LABEL_EXPR which is    accessible from outside the sub-tree. Returns NULL_TREE if no    addressable label is found.  */
end_comment

begin_function
specifier|static
name|bool
name|contains_label_p
parameter_list|(
name|tree
name|st
parameter_list|)
block|{
return|return
operator|(
name|walk_tree
argument_list|(
operator|&
name|st
argument_list|,
name|contains_label_1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a ternary expression of code CODE and type TYPE with operands    OP0, OP1, and OP2.  Return the folded expression if folding is    successful.  Otherwise, return NULL_TREE.  */
end_comment

begin_function
name|tree
name|fold_ternary
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
name|tree
name|arg0
init|=
name|NULL_TREE
decl_stmt|,
name|arg1
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|tree_code_class
name|kind
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|kind
argument_list|)
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|3
argument_list|)
expr_stmt|;
comment|/* Strip any conversions that don't change the mode.  This is safe      for every expression, except for a comparison expression because      its signedness is derived from its operands.  So, in the latter      case, only strip conversions that don't change the signedness.       Note that this is done as an internal manipulation within the      constant folder, in order to find the simplest representation of      the arguments so that their form can be studied.  In any cases,      the appropriate type conversions should be put back in the tree      that will get out of the constant folder.  */
if|if
condition|(
name|op0
condition|)
block|{
name|arg0
operator|=
name|op0
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op1
condition|)
block|{
name|arg1
operator|=
name|op1
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|type_contains_placeholder_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (arg0)
argument_list|,
argument|idx
argument_list|,
argument|field
argument_list|,
argument|value
argument_list|)
if|if
condition|(
name|field
operator|==
name|arg1
condition|)
return|return
name|value
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|COND_EXPR
case|:
comment|/* Pedantic ANSI C says that a conditional expression is never an lvalue, 	 so all simple results must be passed through pedantic_non_lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|unused_op
init|=
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|?
name|op1
else|:
name|op2
decl_stmt|;
name|tem
operator|=
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|?
name|op2
else|:
name|op1
expr_stmt|;
comment|/* Only optimize constant conditions when the selected branch 	     has the same type as the COND_EXPR.  This avoids optimizing              away "c ? x : throw", where the throw has a void type.              Avoid throwing away that operand which contains label.  */
if|if
condition|(
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|unused_op
argument_list|)
operator|||
operator|!
name|contains_label_p
argument_list|(
name|unused_op
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|tem
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|pedantic_omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If we have A op B ? A : C, we may be able to convert this to a 	 simpler expression, depending on the operation and the values 	 of B and C.  Signed zeros prevent all of these transformations, 	 for reasons given above each one.           Also try swapping the arguments and inverting the conditional.  */
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|arg0
argument_list|)
operator|&&
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_cond_expr_with_comparison
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|arg0
argument_list|)
operator|&&
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_truth_not_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|COMPARISON_CLASS_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_cond_expr_with_comparison
argument_list|(
name|type
argument_list|,
name|tem
argument_list|,
name|op2
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
block|}
comment|/* If the second operand is simpler than the third, swap them 	 since that produces better jump optimization results.  */
if|if
condition|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|tree_swap_operands_p
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|false
argument_list|)
condition|)
block|{
comment|/* See if this can be inverted.  If it can't, possibly because 	     it was a floating-point inequality comparison, don't do 	     anything.  */
name|tem
operator|=
name|fold_truth_not_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_build3
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|op2
argument_list|,
name|op1
argument_list|)
return|;
block|}
comment|/* Convert A ? 1 : 0 to simply A.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|op1
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|op2
argument_list|)
comment|/* If we try to convert OP0 to our type, the 	     call to fold will try to move the conversion inside 	     a COND, which will recurse.  In that case, the COND_EXPR 	     is probably the best choice, so leave it alone.  */
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|arg0
argument_list|)
return|;
comment|/* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR 	 over COND_EXPR in cases such as floating point comparisons.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|op2
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* A< 0 ?<sign bit of A> : 0 is simply (A&<sign bit of A>).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|LT_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
operator|(
name|tem
operator|=
name|sign_bit_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
operator|)
condition|)
block|{
comment|/* sign_bit_p only checks ARG1 bits within A's precision. 	     If<sign bit of A> has wider type than A, bits outside 	     of A's precision in<sign bit of A> need to be checked. 	     If they are all 0, this optimization needs to be done 	     in unsigned A's type, if they are all 1 in signed A's type, 	     otherwise this can't be done.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask_lo
decl_stmt|;
name|HOST_WIDE_INT
name|mask_hi
decl_stmt|;
name|int
name|inner_width
decl_stmt|,
name|outer_width
decl_stmt|;
name|tree
name|tem_type
decl_stmt|;
name|inner_width
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|outer_width
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer_width
operator|>
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
name|outer_width
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer_width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|mask_hi
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|outer_width
operator|)
operator|)
expr_stmt|;
name|mask_lo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mask_hi
operator|=
literal|0
expr_stmt|;
name|mask_lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|outer_width
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|inner_width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|mask_hi
operator|&=
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|inner_width
operator|)
operator|)
expr_stmt|;
name|mask_lo
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|mask_lo
operator|&=
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|inner_width
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|&
name|mask_hi
operator|)
operator|==
name|mask_hi
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
name|mask_lo
operator|)
operator|==
name|mask_lo
condition|)
block|{
name|tem_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_convert
argument_list|(
name|tem_type
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|&
name|mask_hi
operator|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
name|mask_lo
operator|)
operator|==
literal|0
condition|)
block|{
name|tem_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_convert
argument_list|(
name|tem_type
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* (A>> N)& 1 ? (1<< N) : 0 is simply A& (1<< N).  A& 1 was 	 already handled above.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|tree_log2
argument_list|(
name|arg1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* A& N ? N : 0 is simply A& N if N is a power of two.  This 	 is probably obsolete because the first operand should be a 	 truth value (that's why we have the two cases above), but let's 	 leave it in until we can confirm this for all front-ends.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert A ? B : 0 into A&& B if A and B are truth values.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* Convert A ? B : 1 into !A || B if A and B are truth values.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|op2
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Only perform transformation if ARG0 is easily inverted.  */
name|tem
operator|=
name|fold_truth_not_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_build2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* Convert A ? 0 : B into !A&& B if A and B are truth values.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Only perform transformation if ARG0 is easily inverted.  */
name|tem
operator|=
name|fold_truth_not_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold_build2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
argument_list|,
name|op2
argument_list|)
return|;
block|}
comment|/* Convert A ? 1 : B into A || B if A and B are truth values.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|op2
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold_builtin
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|,
name|false
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
case|case
name|BIT_FIELD_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|op2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|width
init|=
name|tree_low_cst
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
init|=
name|tree_low_cst
argument_list|(
name|op2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|simple_cst_equal
argument_list|(
name|arg1
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|idx
operator|%
name|width
operator|)
operator|==
literal|0
operator|&&
operator|(
name|idx
operator|=
name|idx
operator|/
name|width
operator|)
operator|<
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|elements
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
while|while
condition|(
name|idx
operator|--
operator|>
literal|0
operator|&&
name|elements
condition|)
name|elements
operator|=
name|TREE_CHAIN
argument_list|(
name|elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|elements
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|elements
argument_list|)
return|;
else|else
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* switch (code) */
block|}
end_function

begin_comment
comment|/* Perform constant folding and related simplification of EXPR.    The related simplifications include x*1 => x, x*0 => 0, etc.,    and application of the associative law.    NOP_EXPR conversions may be removed freely (as long as we    are careful not to change the type of the overall expression).    We cannot simplify through a CONVERT_EXPR, FIX_EXPR or FLOAT_EXPR,    but we can constant-fold them if they have constant operands.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|fold
parameter_list|(
name|x
parameter_list|)
value|fold_1 (x)
end_define

begin_function_decl
specifier|static
name|tree
name|fold_1
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
endif|#
directive|endif
name|tree
name|fold
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
specifier|const
name|tree
name|t
init|=
name|expr
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|tree_code_class
name|kind
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* Return right away if a constant.  */
if|if
condition|(
name|kind
operator|==
name|tcc_constant
condition|)
return|return
name|t
return|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|kind
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_unary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|tem
condition|?
name|tem
else|:
name|expr
return|;
case|case
literal|2
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_binary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|tem
condition|?
name|tem
else|:
name|expr
return|;
case|case
literal|3
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_ternary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
return|return
name|tem
condition|?
name|tem
else|:
name|expr
return|;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_DECL
case|:
return|return
name|fold
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
comment|/* switch (code) */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
end_ifdef

begin_undef
undef|#
directive|undef
name|fold
end_undef

begin_function_decl
specifier|static
name|void
name|fold_checksum_tree
parameter_list|(
name|tree
parameter_list|,
name|struct
name|md5_ctx
modifier|*
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fold_check_failed
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_fold_checksum
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* When --enable-checking=fold, compute a digest of expr before    and after actual fold call to see if fold did not accidentally    change original expr.  */
end_comment

begin_function
name|tree
name|fold
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|checksum_before
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after
index|[
literal|16
index|]
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
name|ht
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fold_1
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before
argument_list|,
name|checksum_after
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|expr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|print_fold_checksum
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|,
name|cnt
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
name|ht
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ht
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|16
condition|;
operator|++
name|cnt
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x"
argument_list|,
name|checksum
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fold_check_failed
parameter_list|(
name|tree
name|expr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|ret
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"fold check: original tree changed by fold"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fold_checksum_tree
parameter_list|(
name|tree
name|expr
parameter_list|,
name|struct
name|md5_ctx
modifier|*
name|ctx
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|struct
name|tree_function_decl
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|recursive_label
label|:
name|gcc_assert
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_function_decl
argument_list|)
operator|)
operator|&&
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|ht
argument_list|,
name|expr
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|!=
name|NULL
condition|)
return|return;
operator|*
name|slot
operator|=
name|expr
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_declaration
operator|&&
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* Allow DECL_ASSEMBLER_NAME to be modified.  */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|tree
operator|)
operator|&
name|buf
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_type
operator|&&
operator|(
name|TYPE_POINTER_TO
argument_list|(
name|expr
argument_list|)
operator|||
name|TYPE_REFERENCE_TO
argument_list|(
name|expr
argument_list|)
operator|||
name|TYPE_CACHED_VALUES_P
argument_list|(
name|expr
argument_list|)
operator|||
name|TYPE_CONTAINS_PLACEHOLDER_INTERNAL
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
block|{
comment|/* Allow these fields to be modified.  */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|tree
operator|)
operator|&
name|buf
expr_stmt|;
name|TYPE_CONTAINS_PLACEHOLDER_INTERNAL
argument_list|(
name|expr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TYPE_CACHED_VALUES_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|TYPE_CACHED_VALUES_P
argument_list|(
name|expr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_CACHED_VALUES
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|md5_process_bytes
argument_list|(
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|tcc_type
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|tcc_declaration
operator|&&
name|code
operator|!=
name|TREE_LIST
condition|)
name|fold_checksum_tree
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_constant
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|STRING_CST
case|:
name|md5_process_bytes
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
name|fold_checksum_tree
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_CST
case|:
name|fold_checksum_tree
argument_list|(
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|tcc_exceptional
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TREE_LIST
case|:
name|fold_checksum_tree
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TREE_VALUE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|expr
operator|=
name|TREE_CHAIN
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|recursive_label
goto|;
break|break;
case|case
name|TREE_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|expr
argument_list|)
condition|;
operator|++
name|i
control|)
name|fold_checksum_tree
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|tcc_expression
case|:
case|case
name|tcc_reference
case|:
case|case
name|tcc_comparison
case|:
case|case
name|tcc_unary
case|:
case|case
name|tcc_binary
case|:
case|case
name|tcc_statement
case|:
name|len
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|fold_checksum_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_declaration
case|:
name|fold_checksum_tree
argument_list|(
name|DECL_NAME
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TS_DECL_COMMON
argument_list|)
condition|)
block|{
name|fold_checksum_tree
argument_list|(
name|DECL_SIZE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_ATTRIBUTES
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TS_DECL_WITH_VIS
argument_list|)
condition|)
name|fold_checksum_tree
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TS_DECL_NON_COMMON
argument_list|)
condition|)
block|{
name|fold_checksum_tree
argument_list|(
name|DECL_VINDEX
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_RESULT_FLD
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_ARGUMENT_FLD
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tcc_type
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|fold_checksum_tree
argument_list|(
name|TYPE_VALUES
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_SIZE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_NAME
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|expr
argument_list|)
operator|||
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|fold_checksum_tree
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
name|fold_checksum_tree
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|fold_checksum_tree
argument_list|(
name|TYPE_BINFO
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fold a unary tree expression with code CODE of type TYPE with an    operand OP0.  Return a folded expression if successful.  Otherwise,    return a tree expression with code CODE of type TYPE with an    operand OP0.  */
end_comment

begin_function
name|tree
name|fold_build1_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
name|unsigned
name|char
name|checksum_before
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
name|ht
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op0
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|fold_unary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|tem
operator|=
name|build1_stat
argument_list|(
argument|code
argument_list|,
argument|type
argument_list|,
argument|op0 PASS_MEM_STAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op0
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before
argument_list|,
name|checksum_after
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|op0
argument_list|,
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Fold a binary tree expression with code CODE of type TYPE with    operands OP0 and OP1.  Return a folded expression if successful.    Otherwise, return a tree expression with code CODE of type TYPE    with operands OP0 and OP1.  */
end_comment

begin_function
name|tree
name|fold_build2_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
name|unsigned
name|char
name|checksum_before_op0
index|[
literal|16
index|]
decl_stmt|,
name|checksum_before_op1
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after_op0
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after_op1
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
name|ht
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op0
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before_op0
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op1
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before_op1
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|fold_binary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|tem
operator|=
name|build2_stat
argument_list|(
argument|code
argument_list|,
argument|type
argument_list|,
argument|op0
argument_list|,
argument|op1 PASS_MEM_STAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op0
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after_op0
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before_op0
argument_list|,
name|checksum_after_op0
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|op0
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op1
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after_op1
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before_op1
argument_list|,
name|checksum_after_op1
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|op1
argument_list|,
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Fold a ternary tree expression with code CODE of type TYPE with    operands OP0, OP1, and OP2.  Return a folded expression if    successful.  Otherwise, return a tree expression with code CODE of    type TYPE with operands OP0, OP1, and OP2.  */
end_comment

begin_function
name|tree
name|fold_build3_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
name|unsigned
name|char
name|checksum_before_op0
index|[
literal|16
index|]
decl_stmt|,
name|checksum_before_op1
index|[
literal|16
index|]
decl_stmt|,
name|checksum_before_op2
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after_op0
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after_op1
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after_op2
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
name|ht
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op0
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before_op0
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op1
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before_op1
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op2
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before_op2
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|fold_ternary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|tem
operator|=
name|build3_stat
argument_list|(
argument|code
argument_list|,
argument|type
argument_list|,
argument|op0
argument_list|,
argument|op1
argument_list|,
argument|op2 PASS_MEM_STAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op0
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after_op0
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before_op0
argument_list|,
name|checksum_after_op0
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|op0
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op1
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after_op1
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before_op1
argument_list|,
name|checksum_after_op1
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|op1
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|op2
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after_op2
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before_op2
argument_list|,
name|checksum_after_op2
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|op2
argument_list|,
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Perform constant folding and related simplification of initializer    expression EXPR.  These behave identically to "fold_buildN" but ignore    potential run-time traps and exceptions that fold must preserve.  */
end_comment

begin_define
define|#
directive|define
name|START_FOLD_INIT
define|\
value|int saved_signaling_nans = flag_signaling_nans;\   int saved_trapping_math = flag_trapping_math;\   int saved_rounding_math = flag_rounding_math;\   int saved_trapv = flag_trapv;\   int saved_folding_initializer = folding_initializer;\   flag_signaling_nans = 0;\   flag_trapping_math = 0;\   flag_rounding_math = 0;\   flag_trapv = 0;\   folding_initializer = 1;
end_define

begin_define
define|#
directive|define
name|END_FOLD_INIT
define|\
value|flag_signaling_nans = saved_signaling_nans;\   flag_trapping_math = saved_trapping_math;\   flag_rounding_math = saved_rounding_math;\   flag_trapv = saved_trapv;\   folding_initializer = saved_folding_initializer;
end_define

begin_function
name|tree
name|fold_build1_initializer
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|START_FOLD_INIT
expr_stmt|;
name|result
operator|=
name|fold_build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|END_FOLD_INIT
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|fold_build2_initializer
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|START_FOLD_INIT
expr_stmt|;
name|result
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|END_FOLD_INIT
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|fold_build3_initializer
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|START_FOLD_INIT
expr_stmt|;
name|result
operator|=
name|fold_build3
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|END_FOLD_INIT
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|START_FOLD_INIT
end_undef

begin_undef
undef|#
directive|undef
name|END_FOLD_INIT
end_undef

begin_comment
comment|/* Determine if first argument is a multiple of second argument.  Return 0 if    it is not, or we cannot easily determined it to be.     An example of the sort of thing we care about (at this point; this routine    could surely be made more general, and expanded to do what the *_DIV_EXPR's    fold cases do now) is discovering that       SAVE_EXPR (I) * SAVE_EXPR (J * 8)     is a multiple of       SAVE_EXPR (J * 8)     when we know that the two SAVE_EXPR (J * 8) nodes are the same node.     This code also handles discovering that       SAVE_EXPR (I) * SAVE_EXPR (J * 8)     is a multiple of 8 so we don't have to worry about dealing with a    possible remainder.     Note that we *look* inside a SAVE_EXPR only to determine how it was    calculated; it is not safe for fold to do much of anything else with the    internals of a SAVE_EXPR, since it cannot know when it will be evaluated    at run time.  For example, the latter example above *cannot* be implemented    as SAVE_EXPR (I) * J or any variant thereof, since the value of J at    evaluation time of the original SAVE_EXPR is not necessarily the same at    the time the new expression is evaluated.  The only optimization of this    sort that would be valid is changing       SAVE_EXPR (I) * SAVE_EXPR (SAVE_EXPR (J) * 8)     divided by 8 to       SAVE_EXPR (I) * SAVE_EXPR (J)     (where the same SAVE_EXPR (J) is used in the original and the    transformed version).  */
end_comment

begin_function
specifier|static
name|int
name|multiple_of_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|top
parameter_list|,
name|tree
name|bottom
parameter_list|)
block|{
if|if
condition|(
name|operand_equal_p
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|top
argument_list|)
condition|)
block|{
case|case
name|BIT_AND_EXPR
case|:
comment|/* Bitwise and provides a power of two multiple.  If the mask is 	 a multiple of BOTTOM then TOP is a multiple of BOTTOM.  */
if|if
condition|(
operator|!
name|integer_pow2p
argument_list|(
name|bottom
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|MULT_EXPR
case|:
return|return
operator|(
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|||
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
operator|(
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|&&
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|)
return|;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|op1
decl_stmt|,
name|t1
decl_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* const_binop may not detect overflow correctly, 	     so check for it explicitly here.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|bottom
argument_list|)
return|;
block|}
return|return
literal|0
return|;
case|case
name|NOP_EXPR
case|:
comment|/* Can't handle conversions from non-integral or wider integral type.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* .. fall through ...  */
case|case
name|SAVE_EXPR
case|:
return|return
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bottom
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|tree_int_cst_sgn
argument_list|(
name|top
argument_list|)
operator|<
literal|0
operator|||
name|tree_int_cst_sgn
argument_list|(
name|bottom
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|top
argument_list|,
name|bottom
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if `t' is known to be non-negative.  If the return    value is based on the assumption that signed overflow is undefined,    set *STRICT_OVERFLOW_P to true; otherwise, don't change    *STRICT_OVERFLOW_P.  */
end_comment

begin_function
name|int
name|tree_expr_nonnegative_warnv_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
comment|/* Query VRP to see if it has recorded any information about 	 the range of this object.  */
return|return
name|ssa_name_nonnegative_p
argument_list|(
name|t
argument_list|)
return|;
case|case
name|ABS_EXPR
case|:
comment|/* We can't return 1 if flag_wrapv is set because 	 ABS_EXPR<INT_MIN> = INT_MIN.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|INTEGER_CST
case|:
return|return
name|tree_int_cst_sgn
argument_list|(
name|t
argument_list|)
operator|>=
literal|0
return|;
case|case
name|REAL_CST
case|:
return|return
operator|!
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
comment|/* zero_extend(x) + zero_extend(y) is non-negative if x and y are 	 both unsigned and at least 2 bits shorter than the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|tree
name|inner1
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inner2
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|inner1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|inner2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|inner2
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|prec
init|=
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|inner1
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|inner2
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
return|return
name|prec
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* x * x for floating point x is always non-negative.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
block|}
comment|/* zero_extend(x) * zero_extend(y) is non-negative if x and y are 	 both unsigned and their total bits is shorter than the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|tree
name|inner1
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inner2
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|inner1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|inner2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|inner2
argument_list|)
condition|)
return|return
name|TYPE_PRECISION
argument_list|(
name|inner1
argument_list|)
operator|+
name|TYPE_PRECISION
argument_list|(
name|inner2
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|MAX_EXPR
case|:
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|||
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|expr_last
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|outer_type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|outer_type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|outer_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|TARGET_EXPR
case|:
block|{
name|tree
name|temp
init|=
name|TARGET_EXPR_SLOT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|TARGET_EXPR_INITIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If the initializer is non-void, then it's a normal expression 	   that will be assigned to the slot.  */
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|t
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
comment|/* Otherwise, the initializer sets the slot in some way.  One common 	   way is an assignment statement at the end of the initializer.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|t
operator|=
name|expr_last
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TRY_FINALLY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TRY_CATCH_EXPR
condition|)
name|t
operator|=
name|expr_last
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
name|t
operator|=
name|expr_last
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|temp
condition|)
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecl
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ACOS
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ACOSH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CABS
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COSH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ERFC
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP10
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP2
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FABS
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FDIM
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_HYPOT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW10
argument_list|)
operator|:
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_FFS
argument_list|)
operator|:
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_PARITY
argument_list|)
operator|:
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_POPCOUNT
argument_list|)
operator|:
case|case
name|BUILT_IN_BSWAP32
case|:
case|case
name|BUILT_IN_BSWAP64
case|:
comment|/* Always true.  */
return|return
literal|1
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SQRT
argument_list|)
operator|:
comment|/* sqrt(-0.0) is -0.0.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ASINH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATAN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATANH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CBRT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ERF
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXPM1
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FMOD
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FREXP
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LDEXP
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LFLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLFLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLRINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLROUND
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LRINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LROUND
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_MODF
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NEARBYINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_RINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ROUND
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIGNBIT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SINH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TANH
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TRUNC
argument_list|)
operator|:
comment|/* True if the 1st argument is nonnegative.  */
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FMAX
argument_list|)
operator|:
comment|/* True if the 1st OR 2nd arguments are nonnegative.  */
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|||
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
operator|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FMIN
argument_list|)
operator|:
comment|/* True if the 1st AND 2nd arguments are nonnegative.  */
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|&&
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
operator|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COPYSIGN
argument_list|)
operator|:
comment|/* True if the 2nd argument is nonnegative.  */
return|return
operator|(
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* ... fall through ...  */
default|default:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
literal|1
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
comment|/* Truth values evaluate to 0 or 1, which is nonnegative unless we              have a signed:1 type (where the value is -1 and 0).  */
return|return
name|true
return|;
block|}
block|}
comment|/* We don't know sign of `t', so be conservative and return false.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if `t' is known to be non-negative.  Handle warnings    about undefined signed overflow.  */
end_comment

begin_function
name|int
name|tree_expr_nonnegative_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|bool
name|strict_overflow_p
decl_stmt|;
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|t
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur when "
literal|"determining that expression is always "
literal|"non-negative"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return true when T is an address and is known to be nonzero.    For floating point we further ensure that T is not denormal.    Similar logic is present in nonzero_address in rtlanal.h.     If the return value is based on the assumption that signed overflow    is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't    change *STRICT_OVERFLOW_P.  */
end_comment

begin_function
name|bool
name|tree_expr_nonzero_warnv_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bool
name|sub_strict_overflow_p
decl_stmt|;
comment|/* Doing something useful for floating point would need more work.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
comment|/* Query VRP to see if it has recorded any information about 	 the range of this object.  */
return|return
name|ssa_name_nonzero_p
argument_list|(
name|t
argument_list|)
return|;
case|case
name|ABS_EXPR
case|:
return|return
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
comment|/* We used to test for !integer_zerop here.  This does not work correctly 	 if TREE_CONSTANT_OVERFLOW (t).  */
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
operator|)
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* With the presence of negative values it is hard 	     to say something.  */
name|sub_strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
operator|||
operator|!
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* One of operands must be positive and the other non-negative.  */
comment|/* We don't set *STRICT_OVERFLOW_P here: even if this value 	     overflows, on a twos-complement machine the sum of two 	     nonnegative numbers can never be zero.  */
return|return
operator|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|||
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
condition|)
block|{
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
break|break;
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|outer_type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
return|return
operator|(
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
block|{
name|tree
name|base
init|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
name|false
return|;
comment|/* Weak declarations may link to NULL.  */
if|if
condition|(
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|base
argument_list|)
condition|)
return|return
operator|!
name|DECL_WEAK
argument_list|(
name|base
argument_list|)
return|;
comment|/* Constants are never weak.  */
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|base
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
case|case
name|COND_EXPR
case|:
name|sub_strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|sub_strict_overflow_p
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
name|MIN_EXPR
case|:
name|sub_strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|sub_strict_overflow_p
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|MAX_EXPR
case|:
name|sub_strict_overflow_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|sub_strict_overflow_p
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
comment|/* When both operands are nonzero, then MAX must be too.  */
if|if
condition|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* MAX where operand 0 is positive is positive.  */
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
block|}
comment|/* MAX where operand 1 is positive is positive.  */
elseif|else
if|if
condition|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
operator|&&
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|sub_strict_overflow_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|sub_strict_overflow_p
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|BIND_EXPR
case|:
return|return
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
case|case
name|BIT_IOR_EXPR
case|:
return|return
operator|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|||
name|tree_expr_nonzero_warnv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
case|case
name|CALL_EXPR
case|:
return|return
name|alloca_call_p
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true when T is an address and is known to be nonzero.    Handle warnings about undefined signed overflow.  */
end_comment

begin_function
name|bool
name|tree_expr_nonzero_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|,
name|strict_overflow_p
decl_stmt|;
name|strict_overflow_p
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|tree_expr_nonzero_warnv_p
argument_list|(
name|t
argument_list|,
operator|&
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_overflow_p
condition|)
name|fold_overflow_warning
argument_list|(
operator|(
literal|"assuming signed overflow does not occur when "
literal|"determining that expression is always "
literal|"non-zero"
operator|)
argument_list|,
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Given the components of a binary expression CODE, TYPE, OP0 and OP1,    attempt to fold the expression to a constant without modifying TYPE,    OP0 or OP1.     If the expression could be simplified to a constant, then return    the constant.  If the expression would not be simplified to a    constant, then return NULL_TREE.  */
end_comment

begin_function
name|tree
name|fold_binary_to_constant
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|tree
name|tem
init|=
name|fold_binary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
return|return
operator|(
name|tem
operator|&&
name|TREE_CONSTANT
argument_list|(
name|tem
argument_list|)
operator|)
condition|?
name|tem
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given the components of a unary expression CODE, TYPE and OP0,    attempt to fold the expression to a constant without modifying    TYPE or OP0.     If the expression could be simplified to a constant, then return    the constant.  If the expression would not be simplified to a    constant, then return NULL_TREE.  */
end_comment

begin_function
name|tree
name|fold_unary_to_constant
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|)
block|{
name|tree
name|tem
init|=
name|fold_unary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|)
decl_stmt|;
return|return
operator|(
name|tem
operator|&&
name|TREE_CONSTANT
argument_list|(
name|tem
argument_list|)
operator|)
condition|?
name|tem
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If EXP represents referencing an element in a constant string    (either via pointer arithmetic or array indexing), return the    tree representing the value accessed, otherwise return NULL.  */
end_comment

begin_function
name|tree
name|fold_read_from_constant_string
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ARRAY_REF
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|exp1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|string
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|string
operator|=
name|string_constant
argument_list|(
name|exp1
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|low_bound
init|=
name|array_ref_low_bound
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|index
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optimize the special-case of a zero lower bound.  	     We convert the low_bound to sizetype to avoid some problems 	     with constant folding.  (E.g. suppose the lower bound is 1, 	     and its mode is QI.  Without the conversion,l (ARRAY 	     +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1)) 	     +INDEX), which becomes (ARRAY+255+INDEX).  Opps!)  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|size_diffop
argument_list|(
name|index
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|low_bound
argument_list|)
argument_list|)
expr_stmt|;
name|string
operator|=
name|exp1
expr_stmt|;
block|}
if|if
condition|(
name|string
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|index
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
condition|)
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
index|]
operator|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the tree for neg (ARG0) when ARG0 is known to be either    an integer constant or real constant.     TYPE is the type of the result.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_negate_const
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
operator|(
name|overflow
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|REAL_CST
case|:
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the tree for abs (ARG0) when ARG0 is known to be either    an integer constant or real constant.     TYPE is the type of the result.  */
end_comment

begin_function
name|tree
name|fold_abs_const
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* If the value is unsigned, then the absolute value is 	 the same as the ordinary value.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|t
operator|=
name|arg0
expr_stmt|;
comment|/* Similarly, if the value is non-negative.  */
elseif|else
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|integer_minus_one_node
argument_list|,
name|arg0
argument_list|)
condition|)
name|t
operator|=
name|arg0
expr_stmt|;
comment|/* If the value is negative, then the absolute value is 	 its negation.  */
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
operator|-
literal|1
argument_list|,
name|overflow
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REAL_CST
case|:
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|arg0
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the tree for not (ARG0) when ARG0 is known to be an integer    constant.  TYPE is the type of the result.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_not_const
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Given CODE, a relational operator, the target type, TYPE and two    constant operands OP0 and OP1, return the result of the    relational operation.  If the result is not a compile time    constant, then return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_relational_const
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|int
name|result
decl_stmt|,
name|invert
decl_stmt|;
comment|/* From here on, the only cases we handle are when the result is      known to be a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|c0
init|=
name|TREE_REAL_CST_PTR
argument_list|(
name|op0
argument_list|)
decl_stmt|;
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|c1
init|=
name|TREE_REAL_CST_PTR
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* Handle the cases where either operand is a NaN.  */
if|if
condition|(
name|real_isnan
argument_list|(
name|c0
argument_list|)
operator|||
name|real_isnan
argument_list|(
name|c1
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
name|result
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
if|if
condition|(
name|flag_trapping_math
condition|)
return|return
name|NULL_TREE
return|;
name|result
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|constant_boolean_node
argument_list|(
name|result
argument_list|,
name|type
argument_list|)
return|;
block|}
return|return
name|constant_boolean_node
argument_list|(
name|real_compare
argument_list|(
name|code
argument_list|,
name|c0
argument_list|,
name|c1
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/* Handle equality/inequality of complex constants.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
name|tree
name|rcond
init|=
name|fold_relational_const
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_REALPART
argument_list|(
name|op0
argument_list|)
argument_list|,
name|TREE_REALPART
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|icond
init|=
name|fold_relational_const
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|op0
argument_list|)
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|rcond
argument_list|,
name|icond
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|rcond
argument_list|,
name|icond
argument_list|)
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
comment|/* From here on we only handle LT, LE, GT, GE, EQ and NE.       To compute GT, swap the arguments and do LT.      To compute GE, do LT and invert the result.      To compute LE, swap the arguments, do LT and invert the result.      To compute NE, do EQ and invert the result.       Therefore, the code below must handle only EQ and LT.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
condition|)
block|{
name|tree
name|tem
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Note that it is safe to invert for real values here because we      have already handled the one case that it matters.  */
name|invert
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|invert
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|invert_tree_comparison
argument_list|(
name|code
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a result for LT or EQ if args permit;      Otherwise return T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|result
operator|=
name|tree_int_cst_equal
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|INT_CST_LT
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|invert
condition|)
name|result
operator|^=
literal|1
expr_stmt|;
return|return
name|constant_boolean_node
argument_list|(
name|result
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression for the a clean point containing EXPR with type TYPE.    Don't build a cleanup point expression for EXPR which don't have side    effects.  */
end_comment

begin_function
name|tree
name|fold_build_cleanup_point_expr
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
comment|/* If the expression does not have side effects then we don't have to wrap      it with a cleanup point expression.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
comment|/* If the expression is a return, check to see if the expression inside the      return has no side effects or the right hand side of the modify expression      inside the return. If either don't have side effects set we don't need to      wrap the expression in a cleanup point expression.  Note we don't check the      left hand side of the modify because it should always be a return decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|op
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|expr
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|expr
return|;
block|}
return|return
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression for the address of T.  Folds away INDIRECT_REF to    avoid confusing the gimplify process.  */
end_comment

begin_function
name|tree
name|build_fold_addr_expr_with_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|ptrtype
parameter_list|)
block|{
comment|/* The size of the object is not relevant when talking about its address.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Note: doesn't apply to ALIGN_INDIRECT_REF */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MISALIGNED_INDIRECT_REF
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|ptrtype
condition|)
name|t
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|base
init|=
name|t
decl_stmt|;
while|while
condition|(
name|handled_component_p
argument_list|(
name|base
argument_list|)
condition|)
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|base
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|base
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_fold_addr_expr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|build_fold_addr_expr_with_type
argument_list|(
name|t
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer value OP0 and a type TYPE, return a simplified version    of an indirection through OP0, or NULL_TREE if no simplification is    possible.  */
end_comment

begin_function
name|tree
name|fold_indirect_ref_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|)
block|{
name|tree
name|sub
init|=
name|op0
decl_stmt|;
name|tree
name|subtype
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|subtype
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|optype
init|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* *&CONST_DECL -> to the value of the const decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DECL
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|op
argument_list|)
return|;
comment|/* *&p => p;  make sure to handle *&"str"[cst] here.  */
if|if
condition|(
name|type
operator|==
name|optype
condition|)
block|{
name|tree
name|fop
init|=
name|fold_read_from_constant_string
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|fop
condition|)
return|return
name|fop
return|;
else|else
return|return
name|op
return|;
block|}
comment|/* *(foo *)&fooarray => fooarray[0] */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|optype
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|optype
argument_list|)
condition|)
block|{
name|tree
name|type_domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|optype
argument_list|)
decl_stmt|;
name|tree
name|min_val
init|=
name|size_zero_node
decl_stmt|;
if|if
condition|(
name|type_domain
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
condition|)
name|min_val
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
expr_stmt|;
return|return
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|op
argument_list|,
name|min_val
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
comment|/* *(foo *)&complexfoo => __real__ complexfoo */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|optype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|optype
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|op
argument_list|)
return|;
block|}
comment|/* ((foo*)&complexfoo)[1] => __imag__ complexfoo */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|op00
init|=
name|TREE_OPERAND
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op01
init|=
name|TREE_OPERAND
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|op00type
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|op00
argument_list|)
expr_stmt|;
name|op00type
operator|=
name|TREE_TYPE
argument_list|(
name|op00
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op00
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op00type
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op00type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|size
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|size
argument_list|,
name|op01
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op00
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* *(foo *)fooarrptr => (*fooarrptr)[0] */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|subtype
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|subtype
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type_domain
decl_stmt|;
name|tree
name|min_val
init|=
name|size_zero_node
decl_stmt|;
name|sub
operator|=
name|build_fold_indirect_ref
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|type_domain
operator|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_domain
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
condition|)
name|min_val
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
expr_stmt|;
return|return
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|sub
argument_list|,
name|min_val
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Builds an expression for an indirection through T, simplifying some    cases.  */
end_comment

begin_function
name|tree
name|build_fold_indirect_ref
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|sub
init|=
name|fold_indirect_ref_1
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
condition|)
return|return
name|sub
return|;
else|else
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an INDIRECT_REF T, return either T or a simplified version.  */
end_comment

begin_function
name|tree
name|fold_indirect_ref
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|sub
init|=
name|fold_indirect_ref_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
condition|)
return|return
name|sub
return|;
else|else
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Strip non-trapping, non-side-effecting tree nodes from an expression    whose result is ignored.  The type of the returned tree need not be    the same as the original expression.  */
end_comment

begin_function
name|tree
name|fold_ignored_result
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|integer_zero_node
return|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_unary
case|:
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
name|t
return|;
break|break;
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|t
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
name|t
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|t
return|;
block|}
break|break;
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the value of VALUE, rounded up to a multiple of DIVISOR.    This can only be applied to objects of a sizetype.  */
end_comment

begin_function
name|tree
name|round_up
parameter_list|(
name|tree
name|value
parameter_list|,
name|int
name|divisor
parameter_list|)
block|{
name|tree
name|div
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|divisor
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|1
condition|)
return|return
name|value
return|;
comment|/* See if VALUE is already a multiple of DIVISOR.  If so, we don't      have to do anything.  Only do this when we are not given a const,      because in that case, this check is more expensive than just      doing it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|div
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiple_of_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|,
name|div
argument_list|)
condition|)
return|return
name|value
return|;
block|}
comment|/* If divisor is a power of two, simplify this to bit manipulation.  */
if|if
condition|(
name|divisor
operator|==
operator|(
name|divisor
operator|&
operator|-
name|divisor
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|divisor
operator|-
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
operator|-
name|divisor
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|value
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|div
condition|)
name|div
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|value
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|value
argument_list|,
name|div
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but round down.  */
end_comment

begin_function
name|tree
name|round_down
parameter_list|(
name|tree
name|value
parameter_list|,
name|int
name|divisor
parameter_list|)
block|{
name|tree
name|div
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|divisor
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|1
condition|)
return|return
name|value
return|;
comment|/* See if VALUE is already a multiple of DIVISOR.  If so, we don't      have to do anything.  Only do this when we are not given a const,      because in that case, this check is more expensive than just      doing it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|div
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiple_of_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|,
name|div
argument_list|)
condition|)
return|return
name|value
return|;
block|}
comment|/* If divisor is a power of two, simplify this to bit manipulation.  */
if|if
condition|(
name|divisor
operator|==
operator|(
name|divisor
operator|&
operator|-
name|divisor
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
operator|-
name|divisor
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|value
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|div
condition|)
name|div
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|value
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|value
argument_list|,
name|div
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Returns the pointer to the base of the object addressed by EXP and    extracts the information about the offset of the access, storing it    to PBITPOS and POFFSET.  */
end_comment

begin_function
specifier|static
name|tree
name|split_address_to_core_and_offset
parameter_list|(
name|tree
name|exp
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pbitpos
parameter_list|,
name|tree
modifier|*
name|poffset
parameter_list|)
block|{
name|tree
name|core
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|volatilep
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|core
operator|=
name|get_inner_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|bitsize
argument_list|,
name|pbitpos
argument_list|,
name|poffset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|core
operator|=
name|build_fold_addr_expr
argument_list|(
name|core
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|core
operator|=
name|exp
expr_stmt|;
operator|*
name|pbitpos
operator|=
literal|0
expr_stmt|;
operator|*
name|poffset
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|core
return|;
block|}
end_function

begin_comment
comment|/* Returns true if addresses of E1 and E2 differ by a constant, false    otherwise.  If they do, E1 - E2 is stored in *DIFF.  */
end_comment

begin_function
name|bool
name|ptr_difference_const
parameter_list|(
name|tree
name|e1
parameter_list|,
name|tree
name|e2
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|diff
parameter_list|)
block|{
name|tree
name|core1
decl_stmt|,
name|core2
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos1
decl_stmt|,
name|bitpos2
decl_stmt|;
name|tree
name|toffset1
decl_stmt|,
name|toffset2
decl_stmt|,
name|tdiff
decl_stmt|,
name|type
decl_stmt|;
name|core1
operator|=
name|split_address_to_core_and_offset
argument_list|(
name|e1
argument_list|,
operator|&
name|bitpos1
argument_list|,
operator|&
name|toffset1
argument_list|)
expr_stmt|;
name|core2
operator|=
name|split_address_to_core_and_offset
argument_list|(
name|e2
argument_list|,
operator|&
name|bitpos2
argument_list|,
operator|&
name|toffset2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos1
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|||
name|bitpos2
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|core1
argument_list|,
name|core2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|toffset1
operator|&&
name|toffset2
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|toffset1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|toffset2
argument_list|)
condition|)
name|toffset2
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|toffset2
argument_list|)
expr_stmt|;
name|tdiff
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|toffset1
argument_list|,
name|toffset2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cst_and_fits_in_hwi
argument_list|(
name|tdiff
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|diff
operator|=
name|int_cst_value
argument_list|(
name|tdiff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toffset1
operator|||
name|toffset2
condition|)
block|{
comment|/* If only one of the offsets is non-constant, the difference cannot 	 be a constant.  */
return|return
name|false
return|;
block|}
else|else
operator|*
name|diff
operator|=
literal|0
expr_stmt|;
operator|*
name|diff
operator|+=
operator|(
name|bitpos1
operator|-
name|bitpos2
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Simplify the floating point expression EXP when the sign of the    result is not significant.  Return NULL_TREE if no simplification    is possible.  */
end_comment

begin_function
name|tree
name|fold_strip_sign_ops
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ABS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
name|arg0
operator|=
name|fold_strip_sign_ops
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg0
condition|?
name|arg0
else|:
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg0
operator|=
name|fold_strip_sign_ops
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|fold_strip_sign_ops
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|!=
name|NULL_TREE
operator|||
name|arg1
operator|!=
name|NULL_TREE
condition|)
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|arg0
condition|?
name|arg0
else|:
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
condition|?
name|arg1
else|:
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

end_unit

