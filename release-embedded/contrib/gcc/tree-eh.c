begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Exception handling semantics and decomposition for trees.    Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we are using EH to handle cleanups.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_eh_for_cleanups_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|using_eh_for_cleanups
parameter_list|(
name|void
parameter_list|)
block|{
name|using_eh_for_cleanups_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Misc functions used in this file.  */
end_comment

begin_comment
comment|/* Compare and hash for any structure which begins with a canonical    pointer.  Assumes all pointers are interchangeable, which is sort    of already assumed by gcc elsewhere IIRC.  */
end_comment

begin_function
specifier|static
name|int
name|struct_ptr_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|x
init|=
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|y
init|=
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|b
decl_stmt|;
return|return
operator|*
name|x
operator|==
operator|*
name|y
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|struct_ptr_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|x
init|=
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|a
decl_stmt|;
return|return
operator|(
name|size_t
operator|)
operator|*
name|x
operator|>>
literal|4
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remember and lookup EH region data for arbitrary statements.    Really this means any statement that could_throw_p.  We could    stuff this information into the stmt_ann data structure, but:     (1) We absolutely rely on this information being kept until    we get to rtl.  Once we're done with lowering here, if we lose    the information there's no way to recover it!     (2) There are many more statements that *cannot* throw as    compared to those that can.  We should be saving some amount    of space by only allocating memory for those that can throw.  */
end_comment

begin_function
specifier|static
name|void
name|record_stmt_eh_region
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|region
condition|)
return|return;
name|add_stmt_to_eh_region
argument_list|(
name|t
argument_list|,
name|get_eh_region_number
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_stmt_to_eh_region_fn
parameter_list|(
name|struct
name|function
modifier|*
name|ifun
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|throw_stmt_node
modifier|*
name|n
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|num
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|RESX_EXPR
argument_list|)
expr_stmt|;
name|n
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|throw_stmt_node
argument_list|)
expr_stmt|;
name|n
operator|->
name|stmt
operator|=
name|t
expr_stmt|;
name|n
operator|->
name|region_nr
operator|=
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|get_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|)
condition|)
name|set_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|,
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|struct_ptr_hash
argument_list|,
name|struct_ptr_eq
argument_list|,
name|ggc_free
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|get_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|)
argument_list|,
name|n
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|n
expr_stmt|;
comment|/* ??? For the benefit of calls.c, converting all this to rtl,      we need to record the call expression, not just the outer      modify statement.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|(
name|t
operator|=
name|get_call_expr_in
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|add_stmt_to_eh_region_fn
argument_list|(
name|ifun
argument_list|,
name|t
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_stmt_to_eh_region
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|add_stmt_to_eh_region_fn
argument_list|(
name|cfun
argument_list|,
name|t
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|remove_stmt_from_eh_region_fn
parameter_list|(
name|struct
name|function
modifier|*
name|ifun
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|struct
name|throw_stmt_node
name|dummy
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|get_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|)
condition|)
return|return
name|false
return|;
name|dummy
operator|.
name|stmt
operator|=
name|t
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|get_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
block|{
name|htab_clear_slot
argument_list|(
name|get_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* ??? For the benefit of calls.c, converting all this to rtl, 	 we need to record the call expression, not just the outer 	 modify statement.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|(
name|t
operator|=
name|get_call_expr_in
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|remove_stmt_from_eh_region_fn
argument_list|(
name|ifun
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|remove_stmt_from_eh_region
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|remove_stmt_from_eh_region_fn
argument_list|(
name|cfun
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|lookup_stmt_eh_region_fn
parameter_list|(
name|struct
name|function
modifier|*
name|ifun
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|struct
name|throw_stmt_node
modifier|*
name|p
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|get_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|n
operator|.
name|stmt
operator|=
name|t
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|throw_stmt_node
operator|*
operator|)
name|htab_find
argument_list|(
name|get_eh_throw_stmt_table
argument_list|(
name|ifun
argument_list|)
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
condition|?
name|p
operator|->
name|region_nr
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lookup_stmt_eh_region
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* We can get called from initialized data when -fnon-call-exceptions      is on; prevent crash.  */
if|if
condition|(
operator|!
name|cfun
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|lookup_stmt_eh_region_fn
argument_list|(
name|cfun
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* First pass of EH node decomposition.  Build up a tree of TRY_FINALLY_EXPR    nodes and LABEL_DECL nodes.  We will use this during the second phase to    determine if a goto leaves the body of a TRY_FINALLY_EXPR node.  */
end_comment

begin_struct
struct|struct
name|finally_tree_node
block|{
name|tree
name|child
decl_stmt|,
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Note that this table is *not* marked GTY.  It is short-lived.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|finally_tree
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_in_finally_tree
parameter_list|(
name|tree
name|child
parameter_list|,
name|tree
name|parent
parameter_list|)
block|{
name|struct
name|finally_tree_node
modifier|*
name|n
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|n
operator|=
name|XNEW
argument_list|(
expr|struct
name|finally_tree_node
argument_list|)
expr_stmt|;
name|n
operator|->
name|child
operator|=
name|child
expr_stmt|;
name|n
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|finally_tree
argument_list|,
name|n
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|collect_finally_tree
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|region
parameter_list|)
block|{
name|tailrecurse
label|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|LABEL_EXPR
case|:
name|record_in_finally_tree
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|,
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
name|record_in_finally_tree
argument_list|(
name|t
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|collect_finally_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|tailrecurse
goto|;
case|case
name|TRY_CATCH_EXPR
case|:
name|collect_finally_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|tailrecurse
goto|;
case|case
name|CATCH_EXPR
case|:
name|t
operator|=
name|CATCH_BODY
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|tailrecurse
goto|;
case|case
name|EH_FILTER_EXPR
case|:
name|t
operator|=
name|EH_FILTER_FAILURE
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|tailrecurse
goto|;
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|collect_finally_tree
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* A type, a decl, or some kind of statement that we're not 	 interested in.  Don't walk them.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Use the finally tree to determine if a jump from START to TARGET    would leave the try_finally node that START lives in.  */
end_comment

begin_function
specifier|static
name|bool
name|outside_finally_tree
parameter_list|(
name|tree
name|start
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|struct
name|finally_tree_node
name|n
decl_stmt|,
modifier|*
name|p
decl_stmt|;
do|do
block|{
name|n
operator|.
name|child
operator|=
name|start
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|finally_tree_node
operator|*
operator|)
name|htab_find
argument_list|(
name|finally_tree
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|true
return|;
name|start
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
do|while
condition|(
name|start
operator|!=
name|target
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Second pass of EH node decomposition.  Actually transform the TRY_FINALLY    and TRY_CATCH nodes into a set of gotos, magic labels, and eh regions.    The eh region creation is straight-forward, but frobbing all the gotos    and such into shape isn't.  */
end_comment

begin_comment
comment|/* State of the world while lowering.  */
end_comment

begin_struct
struct|struct
name|leh_state
block|{
comment|/* What's "current" while constructing the eh region tree.  These      correspond to variables of the same name in cfun->eh, which we      don't have easy access to.  */
name|struct
name|eh_region
modifier|*
name|cur_region
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|prev_try
decl_stmt|;
comment|/* Processing of TRY_FINALLY requires a bit more state.  This is      split out into a separate structure so that we don't have to      copy so much when processing other nodes.  */
name|struct
name|leh_tf_state
modifier|*
name|tf
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|leh_tf_state
block|{
comment|/* Pointer to the TRY_FINALLY node under discussion.  The try_finally_expr      is the original TRY_FINALLY_EXPR.  We need to retain this so that      outside_finally_tree can reliably reference the tree used in the      collect_finally_tree data structures.  */
name|tree
name|try_finally_expr
decl_stmt|;
name|tree
modifier|*
name|top_p
decl_stmt|;
comment|/* The state outside this try_finally node.  */
name|struct
name|leh_state
modifier|*
name|outer
decl_stmt|;
comment|/* The exception region created for it.  */
name|struct
name|eh_region
modifier|*
name|region
decl_stmt|;
comment|/* The GOTO_QUEUE is is an array of GOTO_EXPR and RETURN_EXPR statements      that are seen to escape this TRY_FINALLY_EXPR node.  */
struct|struct
name|goto_queue_node
block|{
name|tree
name|stmt
decl_stmt|;
name|tree
name|repl_stmt
decl_stmt|;
name|tree
name|cont_stmt
decl_stmt|;
name|int
name|index
decl_stmt|;
block|}
modifier|*
name|goto_queue
struct|;
name|size_t
name|goto_queue_size
decl_stmt|;
name|size_t
name|goto_queue_active
decl_stmt|;
comment|/* The set of unique labels seen as entries in the goto queue.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|dest_array
expr_stmt|;
comment|/* A label to be added at the end of the completed transformed      sequence.  It will be set if may_fallthru was true *at one time*,      though subsequent transformations may have cleared that flag.  */
name|tree
name|fallthru_label
decl_stmt|;
comment|/* A label that has been registered with except.c to be the      landing pad for this try block.  */
name|tree
name|eh_label
decl_stmt|;
comment|/* True if it is possible to fall out the bottom of the try block.      Cleared if the fallthru is converted to a goto.  */
name|bool
name|may_fallthru
decl_stmt|;
comment|/* True if any entry in goto_queue is a RETURN_EXPR.  */
name|bool
name|may_return
decl_stmt|;
comment|/* True if the finally block can receive an exception edge.      Cleared if the exception case is handled by code duplication.  */
name|bool
name|may_throw
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|lower_eh_filter
parameter_list|(
name|struct
name|leh_state
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lower_eh_constructs_1
parameter_list|(
name|struct
name|leh_state
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Comparison function for qsort/bsearch.  We're interested in    searching goto queue elements for source statements.  */
end_comment

begin_function
specifier|static
name|int
name|goto_queue_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|tree
name|a
init|=
operator|(
operator|(
specifier|const
expr|struct
name|goto_queue_node
operator|*
operator|)
name|x
operator|)
operator|->
name|stmt
decl_stmt|;
name|tree
name|b
init|=
operator|(
operator|(
specifier|const
expr|struct
name|goto_queue_node
operator|*
operator|)
name|y
operator|)
operator|->
name|stmt
decl_stmt|;
return|return
operator|(
name|a
operator|==
name|b
condition|?
literal|0
else|:
name|a
operator|<
name|b
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STMT in the goto queue.  Return the replacement,    or null if the statement isn't in the queue.  */
end_comment

begin_function
specifier|static
name|tree
name|find_goto_replacement
parameter_list|(
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|struct
name|goto_queue_node
name|tmp
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|tmp
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|goto_queue_node
operator|*
operator|)
name|bsearch
argument_list|(
operator|&
name|tmp
argument_list|,
name|tf
operator|->
name|goto_queue
argument_list|,
name|tf
operator|->
name|goto_queue_active
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|goto_queue_node
argument_list|)
argument_list|,
name|goto_queue_cmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
condition|?
name|ret
operator|->
name|repl_stmt
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of replace_goto_queue_1.  Handles the sub-clauses of a    lowered COND_EXPR.  If, by chance, the replacement is a simple goto,    then we can just splat it in, otherwise we add the new stmts immediately    after the COND_EXPR and redirect.  */
end_comment

begin_function
specifier|static
name|void
name|replace_goto_queue_cond_clause
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|tree
name|new
decl_stmt|,
name|one
decl_stmt|,
name|label
decl_stmt|;
name|new
operator|=
name|find_goto_replacement
argument_list|(
name|tf
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return;
name|one
operator|=
name|expr_only
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|&&
name|TREE_CODE
argument_list|(
name|one
argument_list|)
operator|==
name|GOTO_EXPR
condition|)
block|{
operator|*
name|tp
operator|=
name|one
expr_stmt|;
return|return;
block|}
name|label
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|label
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|new
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The real work of replace_goto_queue.  Returns with TSI updated to    point to the next statement.  */
end_comment

begin_function_decl
specifier|static
name|void
name|replace_goto_queue_stmt_list
parameter_list|(
name|tree
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|replace_goto_queue_1
parameter_list|(
name|tree
name|t
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GOTO_EXPR
case|:
case|case
name|RETURN_EXPR
case|:
name|t
operator|=
name|find_goto_replacement
argument_list|(
name|tf
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|COND_EXPR
case|:
name|replace_goto_queue_cond_clause
argument_list|(
operator|&
name|COND_EXPR_THEN
argument_list|(
name|t
argument_list|)
argument_list|,
name|tf
argument_list|,
name|tsi
argument_list|)
expr_stmt|;
name|replace_goto_queue_cond_clause
argument_list|(
operator|&
name|COND_EXPR_ELSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tf
argument_list|,
name|tsi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
name|replace_goto_queue_stmt_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|replace_goto_queue_stmt_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXPR
case|:
name|replace_goto_queue_stmt_list
argument_list|(
name|CATCH_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_FILTER_EXPR
case|:
name|replace_goto_queue_stmt_list
argument_list|(
name|EH_FILTER_FAILURE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATEMENT_LIST
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
comment|/* These won't have gotos in them.  */
break|break;
block|}
name|tsi_next
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of replace_goto_queue.  Handles STATEMENT_LISTs.  */
end_comment

begin_function
specifier|static
name|void
name|replace_goto_queue_stmt_list
parameter_list|(
name|tree
name|t
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
name|tree_stmt_iterator
name|i
init|=
name|tsi_start
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|)
name|replace_goto_queue_1
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|,
name|tf
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace all goto queue members.  */
end_comment

begin_function
specifier|static
name|void
name|replace_goto_queue
parameter_list|(
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
if|if
condition|(
name|tf
operator|->
name|goto_queue_active
operator|==
literal|0
condition|)
return|return;
name|replace_goto_queue_stmt_list
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For any GOTO_EXPR or RETURN_EXPR, decide whether it leaves a try_finally    node, and if so record that fact in the goto queue associated with that    try_finally node.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_record_in_goto_queue
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|struct
name|leh_tf_state
modifier|*
name|tf
init|=
name|state
operator|->
name|tf
decl_stmt|;
name|struct
name|goto_queue_node
modifier|*
name|q
decl_stmt|;
name|size_t
name|active
decl_stmt|,
name|size
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|tf
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|GOTO_EXPR
case|:
block|{
name|tree
name|lab
init|=
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* Computed and non-local gotos do not get processed.  Given 	   their nature we can neither tell whether we've escaped the 	   finally block nor redirect them if we knew.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lab
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
return|return;
comment|/* No need to record gotos that don't leave the try block.  */
if|if
condition|(
operator|!
name|outside_finally_tree
argument_list|(
name|lab
argument_list|,
name|tf
operator|->
name|try_finally_expr
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|tf
operator|->
name|dest_array
condition|)
block|{
name|tf
operator|->
name|dest_array
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|tf
operator|->
name|dest_array
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|n
init|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|tf
operator|->
name|dest_array
argument_list|)
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|n
condition|;
operator|++
name|index
control|)
if|if
condition|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|tf
operator|->
name|dest_array
argument_list|,
name|index
argument_list|)
operator|==
name|lab
condition|)
break|break;
if|if
condition|(
name|index
operator|==
name|n
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|tf
operator|->
name|dest_array
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RETURN_EXPR
case|:
name|tf
operator|->
name|may_return
operator|=
name|true
expr_stmt|;
name|index
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|active
operator|=
name|tf
operator|->
name|goto_queue_active
expr_stmt|;
name|size
operator|=
name|tf
operator|->
name|goto_queue_size
expr_stmt|;
if|if
condition|(
name|active
operator|>=
name|size
condition|)
block|{
name|size
operator|=
operator|(
name|size
condition|?
name|size
operator|*
literal|2
else|:
literal|32
operator|)
expr_stmt|;
name|tf
operator|->
name|goto_queue_size
operator|=
name|size
expr_stmt|;
name|tf
operator|->
name|goto_queue
operator|=
name|XRESIZEVEC
argument_list|(
expr|struct
name|goto_queue_node
argument_list|,
name|tf
operator|->
name|goto_queue
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
operator|&
name|tf
operator|->
name|goto_queue
index|[
name|active
index|]
expr_stmt|;
name|tf
operator|->
name|goto_queue_active
operator|=
name|active
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
name|q
operator|->
name|index
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* We do not process SWITCH_EXPRs for now.  As long as the original source    was in fact structured, and we've not yet done jump threading, then none    of the labels will leave outer TRY_FINALLY_EXPRs.  Verify this.  */
end_comment

begin_function
specifier|static
name|void
name|verify_norecord_switch_expr
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|tree
name|switch_expr
parameter_list|)
block|{
name|struct
name|leh_tf_state
modifier|*
name|tf
init|=
name|state
operator|->
name|tf
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|vec
decl_stmt|;
if|if
condition|(
operator|!
name|tf
condition|)
return|return;
name|vec
operator|=
name|SWITCH_LABELS
argument_list|(
name|switch_expr
argument_list|)
expr_stmt|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|lab
init|=
name|CASE_LABEL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|outside_finally_tree
argument_list|(
name|lab
argument_list|,
name|tf
operator|->
name|try_finally_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|verify_norecord_switch_expr
parameter_list|(
name|state
parameter_list|,
name|switch_expr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Redirect a RETURN_EXPR pointed to by STMT_P to FINLAB.  Place in CONT_P    whatever is needed to finish the return.  If MOD is non-null, insert it    before the new branch.  RETURN_VALUE_P is a cache containing a temporary    variable to be used in manipulating the value returned from the function.  */
end_comment

begin_function
specifier|static
name|void
name|do_return_redirection
parameter_list|(
name|struct
name|goto_queue_node
modifier|*
name|q
parameter_list|,
name|tree
name|finlab
parameter_list|,
name|tree
name|mod
parameter_list|,
name|tree
modifier|*
name|return_value_p
parameter_list|)
block|{
name|tree
name|ret_expr
init|=
name|TREE_OPERAND
argument_list|(
name|q
operator|->
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|ret_expr
condition|)
block|{
comment|/* The nasty part about redirecting the return value is that the 	 return value itself is to be computed before the FINALLY block 	 is executed.  e.g.  		int x; 		int foo (void) 		{ 		  x = 0; 		  try { 		    return x; 		  } finally { 		    x++; 		  } 		}  	  should return 0, not 1.  Arrange for this to happen by copying 	  computed the return value into a local temporary.  This also 	  allows us to redirect multiple return statements through the 	  same destination block; whether this is a net win or not really 	  depends, I guess, but it does make generation of the switch in 	  lower_try_finally_switch easier.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ret_expr
argument_list|)
condition|)
block|{
case|case
name|RESULT_DECL
case|:
if|if
condition|(
operator|!
operator|*
name|return_value_p
condition|)
operator|*
name|return_value_p
operator|=
name|ret_expr
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
operator|*
name|return_value_p
operator|==
name|ret_expr
argument_list|)
expr_stmt|;
name|q
operator|->
name|cont_stmt
operator|=
name|q
operator|->
name|stmt
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|result
init|=
name|TREE_OPERAND
argument_list|(
name|ret_expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|new
decl_stmt|,
name|old
init|=
name|TREE_OPERAND
argument_list|(
name|ret_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|return_value_p
condition|)
block|{
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
comment|/* If this function returns in memory, copy the argument 		    into the return slot now.  Otherwise, we might need to 		    worry about magic return semantics, so we need to use a 		    temporary to hold the value until we're actually ready 		    to return.  */
name|new
operator|=
name|result
expr_stmt|;
else|else
name|new
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
argument_list|,
literal|"rettmp"
argument_list|)
expr_stmt|;
operator|*
name|return_value_p
operator|=
name|new
expr_stmt|;
block|}
else|else
name|new
operator|=
operator|*
name|return_value_p
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|new
argument_list|)
argument_list|,
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|q
operator|->
name|repl_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|result
condition|)
name|x
operator|=
name|result
expr_stmt|;
else|else
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|q
operator|->
name|cont_stmt
operator|=
name|build1
argument_list|(
name|RETURN_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we don't return a value, all return statements are the same.  */
name|q
operator|->
name|cont_stmt
operator|=
name|q
operator|->
name|stmt
expr_stmt|;
block|}
if|if
condition|(
name|mod
condition|)
name|append_to_statement_list
argument_list|(
name|mod
argument_list|,
operator|&
name|q
operator|->
name|repl_stmt
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finlab
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|q
operator|->
name|repl_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but easier, for GOTO_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|do_goto_redirection
parameter_list|(
name|struct
name|goto_queue_node
modifier|*
name|q
parameter_list|,
name|tree
name|finlab
parameter_list|,
name|tree
name|mod
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
name|q
operator|->
name|cont_stmt
operator|=
name|q
operator|->
name|stmt
expr_stmt|;
if|if
condition|(
name|mod
condition|)
name|append_to_statement_list
argument_list|(
name|mod
argument_list|,
operator|&
name|q
operator|->
name|repl_stmt
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finlab
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|q
operator|->
name|repl_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We want to transform 	try { body; } catch { stuff; }    to 	body; goto over; lab: stuff; over:     T is a TRY_FINALLY or TRY_CATCH node.  LAB is the label that    should be placed before the second operand, or NULL.  OVER is    an existing label that should be put at the exit, or NULL.  */
end_comment

begin_function
specifier|static
name|void
name|frob_into_branch_around
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|tree
name|lab
parameter_list|,
name|tree
name|over
parameter_list|)
block|{
name|tree
name|x
decl_stmt|,
name|op1
decl_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_may_fallthru
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|over
condition|)
name|over
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|over
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lab
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|append_to_statement_list
argument_list|(
name|op1
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|over
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|over
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of lower_try_finally.  Duplicate the tree rooted at T.    Make sure to record all new labels found.  */
end_comment

begin_function
specifier|static
name|tree
name|lower_try_finally_dup_block
parameter_list|(
name|tree
name|t
parameter_list|,
name|struct
name|leh_state
modifier|*
name|outer_state
parameter_list|)
block|{
name|tree
name|region
init|=
name|NULL
decl_stmt|;
name|t
operator|=
name|unsave_expr_now
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer_state
operator|->
name|tf
condition|)
name|region
operator|=
name|outer_state
operator|->
name|tf
operator|->
name|try_finally_expr
expr_stmt|;
name|collect_finally_tree
argument_list|(
name|t
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_try_finally.  Create a fallthru label for    the given try_finally state.  The only tricky bit here is that    we have to make sure to record the label in our outer context.  */
end_comment

begin_function
specifier|static
name|tree
name|lower_try_finally_fallthru_label
parameter_list|(
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
name|tree
name|label
init|=
name|tf
operator|->
name|fallthru_label
decl_stmt|;
if|if
condition|(
operator|!
name|label
condition|)
block|{
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|tf
operator|->
name|fallthru_label
operator|=
name|label
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|outer
operator|->
name|tf
condition|)
name|record_in_finally_tree
argument_list|(
name|label
argument_list|,
name|tf
operator|->
name|outer
operator|->
name|tf
operator|->
name|try_finally_expr
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_try_finally.  If lang_protect_cleanup_actions    returns non-null, then the language requires that the exception path out    of a try_finally be treated specially.  To wit: the code within the    finally block may not itself throw an exception.  We have two choices here.    First we can duplicate the finally block and wrap it in a must_not_throw    region.  Second, we can generate code like  	try { 	  finally_block; 	} catch { 	  if (fintmp == eh_edge) 	    protect_cleanup_actions; 	}     where "fintmp" is the temporary used in the switch statement generation    alternative considered below.  For the nonce, we always choose the first    option.     THIS_STATE may be null if this is a try-cleanup, not a try-finally.  */
end_comment

begin_function
specifier|static
name|void
name|honor_protect_cleanup_actions
parameter_list|(
name|struct
name|leh_state
modifier|*
name|outer_state
parameter_list|,
name|struct
name|leh_state
modifier|*
name|this_state
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
name|tree
name|protect_cleanup_actions
decl_stmt|,
name|finally
decl_stmt|,
name|x
decl_stmt|;
name|tree_stmt_iterator
name|i
decl_stmt|;
name|bool
name|finally_may_fallthru
decl_stmt|;
comment|/* First check for nothing to do.  */
if|if
condition|(
name|lang_protect_cleanup_actions
condition|)
name|protect_cleanup_actions
operator|=
name|lang_protect_cleanup_actions
argument_list|()
expr_stmt|;
else|else
name|protect_cleanup_actions
operator|=
name|NULL
expr_stmt|;
name|finally
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the EH case of the finally block can fall through, this may be a      structure of the form 	try { 	  try { 	    throw ...; 	  } cleanup { 	    try { 	      throw ...; 	    } catch (...) { 	    } 	  } 	} catch (...) { 	  yyy; 	}     E.g. with an inline destructor with an embedded try block.  In this     case we must save the runtime EH data around the nested exception.      This complication means that any time the previous runtime data might     be used (via fallthru from the finally) we handle the eh case here,     whether or not protect_cleanup_actions is active.  */
name|finally_may_fallthru
operator|=
name|block_may_fallthru
argument_list|(
name|finally
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|finally_may_fallthru
operator|&&
operator|!
name|protect_cleanup_actions
condition|)
return|return;
comment|/* Duplicate the FINALLY block.  Only need to do this for try-finally,      and not for cleanups.  */
if|if
condition|(
name|this_state
condition|)
name|finally
operator|=
name|lower_try_finally_dup_block
argument_list|(
name|finally
argument_list|,
name|outer_state
argument_list|)
expr_stmt|;
comment|/* Resume execution after the exception.  Adding this now lets      lower_eh_filter not add unnecessary gotos, as it is clear that      we never fallthru from this copy of the finally block.  */
if|if
condition|(
name|finally_may_fallthru
condition|)
block|{
name|tree
name|save_eptr
decl_stmt|,
name|save_filt
decl_stmt|;
name|save_eptr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"save_eptr"
argument_list|)
expr_stmt|;
name|save_filt
operator|=
name|create_tmp_var
argument_list|(
name|integer_type_node
argument_list|,
literal|"save_filt"
argument_list|)
expr_stmt|;
name|i
operator|=
name|tsi_start
argument_list|(
name|finally
argument_list|)
expr_stmt|;
name|x
operator|=
name|build0
argument_list|(
name|EXC_PTR_EXPR
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|save_eptr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|x
operator|=
name|build0
argument_list|(
name|FILTER_EXPR
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|save_filt
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|i
operator|=
name|tsi_last
argument_list|(
name|finally
argument_list|)
expr_stmt|;
name|x
operator|=
name|build0
argument_list|(
name|EXC_PTR_EXPR
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|,
name|save_eptr
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|x
operator|=
name|build0
argument_list|(
name|FILTER_EXPR
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|,
name|save_filt
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_resx
argument_list|(
name|get_eh_region_number
argument_list|(
name|tf
operator|->
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
comment|/* Wrap the block with protect_cleanup_actions as the action.  */
if|if
condition|(
name|protect_cleanup_actions
condition|)
block|{
name|x
operator|=
name|build2
argument_list|(
name|EH_FILTER_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|protect_cleanup_actions
argument_list|,
operator|&
name|EH_FILTER_FAILURE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|EH_FILTER_MUST_NOT_THROW
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finally
operator|=
name|build2
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|lower_eh_filter
argument_list|(
name|outer_state
argument_list|,
operator|&
name|finally
argument_list|)
expr_stmt|;
block|}
else|else
name|lower_eh_constructs_1
argument_list|(
name|outer_state
argument_list|,
operator|&
name|finally
argument_list|)
expr_stmt|;
comment|/* Hook this up to the end of the existing try block.  If we      previously fell through the end, we'll have to branch around.      This means adding a new goto, and adding it to the queue.  */
name|i
operator|=
name|tsi_last
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|may_fallthru
condition|)
block|{
name|x
operator|=
name|lower_try_finally_fallthru_label
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_state
condition|)
name|maybe_record_in_goto_queue
argument_list|(
name|this_state
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tf
operator|->
name|may_fallthru
operator|=
name|false
expr_stmt|;
block|}
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tf
operator|->
name|eh_label
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|finally
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Having now been handled, EH isn't to be considered with      the rest of the outgoing edges.  */
name|tf
operator|->
name|may_throw
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_try_finally.  We have determined that there is    no fallthru edge out of the finally block.  This means that there is    no outgoing edge corresponding to any incoming edge.  Restructure the    try_finally node for this special case.  */
end_comment

begin_function
specifier|static
name|void
name|lower_try_finally_nofallthru
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
name|tree
name|x
decl_stmt|,
name|finally
decl_stmt|,
name|lab
decl_stmt|,
name|return_val
decl_stmt|;
name|struct
name|goto_queue_node
modifier|*
name|q
decl_stmt|,
modifier|*
name|qe
decl_stmt|;
if|if
condition|(
name|tf
operator|->
name|may_throw
condition|)
name|lab
operator|=
name|tf
operator|->
name|eh_label
expr_stmt|;
else|else
name|lab
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|finally
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tf
operator|->
name|top_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|return_val
operator|=
name|NULL
expr_stmt|;
name|q
operator|=
name|tf
operator|->
name|goto_queue
expr_stmt|;
name|qe
operator|=
name|q
operator|+
name|tf
operator|->
name|goto_queue_active
expr_stmt|;
for|for
control|(
init|;
name|q
operator|<
name|qe
condition|;
operator|++
name|q
control|)
if|if
condition|(
name|q
operator|->
name|index
operator|<
literal|0
condition|)
name|do_return_redirection
argument_list|(
name|q
argument_list|,
name|lab
argument_list|,
name|NULL
argument_list|,
operator|&
name|return_val
argument_list|)
expr_stmt|;
else|else
name|do_goto_redirection
argument_list|(
name|q
argument_list|,
name|lab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|replace_goto_queue
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|finally
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|finally
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_try_finally.  We have determined that there is    exactly one destination of the finally block.  Restructure the    try_finally node for this special case.  */
end_comment

begin_function
specifier|static
name|void
name|lower_try_finally_onedest
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
name|struct
name|goto_queue_node
modifier|*
name|q
decl_stmt|,
modifier|*
name|qe
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|finally
decl_stmt|,
name|finally_label
decl_stmt|;
name|finally
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tf
operator|->
name|top_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|finally
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|may_throw
condition|)
block|{
comment|/* Only reachable via the exception edge.  Add the given label to          the head of the FINALLY block.  Append a RESX at the end.  */
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tf
operator|->
name|eh_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|finally
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_resx
argument_list|(
name|get_eh_region_number
argument_list|(
name|tf
operator|->
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tf
operator|->
name|may_fallthru
condition|)
block|{
comment|/* Only reachable via the fallthru edge.  Do nothing but let 	 the two blocks run together; we'll fall out the bottom.  */
name|append_to_statement_list
argument_list|(
name|finally
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|finally_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|finally
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|q
operator|=
name|tf
operator|->
name|goto_queue
expr_stmt|;
name|qe
operator|=
name|q
operator|+
name|tf
operator|->
name|goto_queue_active
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|may_return
condition|)
block|{
comment|/* Reachable by return expressions only.  Redirect them.  */
name|tree
name|return_val
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
name|q
operator|<
name|qe
condition|;
operator|++
name|q
control|)
name|do_return_redirection
argument_list|(
name|q
argument_list|,
name|finally_label
argument_list|,
name|NULL
argument_list|,
operator|&
name|return_val
argument_list|)
expr_stmt|;
name|replace_goto_queue
argument_list|(
name|tf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reachable by goto expressions only.  Redirect them.  */
for|for
control|(
init|;
name|q
operator|<
name|qe
condition|;
operator|++
name|q
control|)
name|do_goto_redirection
argument_list|(
name|q
argument_list|,
name|finally_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|replace_goto_queue
argument_list|(
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|tf
operator|->
name|dest_array
argument_list|,
literal|0
argument_list|)
operator|==
name|tf
operator|->
name|fallthru_label
condition|)
block|{
comment|/* Reachable by goto to fallthru label only.  Redirect it 	     to the new label (already created, sadly), and do not 	     emit the final branch out, or the fallthru label.  */
name|tf
operator|->
name|fallthru_label
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
name|append_to_statement_list
argument_list|(
name|tf
operator|->
name|goto_queue
index|[
literal|0
index|]
operator|.
name|cont_stmt
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|maybe_record_in_goto_queue
argument_list|(
name|state
argument_list|,
name|tf
operator|->
name|goto_queue
index|[
literal|0
index|]
operator|.
name|cont_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_try_finally.  There are multiple edges incoming    and outgoing from the finally block.  Implement this by duplicating the    finally block for every destination.  */
end_comment

begin_function
specifier|static
name|void
name|lower_try_finally_copy
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
name|tree
name|finally
decl_stmt|,
name|new_stmt
decl_stmt|;
name|tree
name|x
decl_stmt|;
name|finally
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tf
operator|->
name|top_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|may_fallthru
condition|)
block|{
name|x
operator|=
name|lower_try_finally_dup_block
argument_list|(
name|finally
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
name|x
operator|=
name|lower_try_finally_fallthru_label
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tf
operator|->
name|may_throw
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tf
operator|->
name|eh_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
name|x
operator|=
name|lower_try_finally_dup_block
argument_list|(
name|finally
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_resx
argument_list|(
name|get_eh_region_number
argument_list|(
name|tf
operator|->
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tf
operator|->
name|goto_queue
condition|)
block|{
name|struct
name|goto_queue_node
modifier|*
name|q
decl_stmt|,
modifier|*
name|qe
decl_stmt|;
name|tree
name|return_val
init|=
name|NULL
decl_stmt|;
name|int
name|return_index
decl_stmt|,
name|index
decl_stmt|;
struct|struct
name|labels_s
block|{
name|struct
name|goto_queue_node
modifier|*
name|q
decl_stmt|;
name|tree
name|label
decl_stmt|;
block|}
modifier|*
name|labels
struct|;
name|return_index
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|tf
operator|->
name|dest_array
argument_list|)
expr_stmt|;
name|labels
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|labels_s
argument_list|,
name|return_index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|q
operator|=
name|tf
operator|->
name|goto_queue
expr_stmt|;
name|qe
operator|=
name|q
operator|+
name|tf
operator|->
name|goto_queue_active
expr_stmt|;
for|for
control|(
init|;
name|q
operator|<
name|qe
condition|;
name|q
operator|++
control|)
block|{
name|index
operator|=
name|q
operator|->
name|index
operator|<
literal|0
condition|?
name|return_index
else|:
name|q
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|labels
index|[
name|index
index|]
operator|.
name|q
condition|)
name|labels
index|[
name|index
index|]
operator|.
name|q
operator|=
name|q
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|return_index
operator|+
literal|1
condition|;
name|index
operator|++
control|)
block|{
name|tree
name|lab
decl_stmt|;
name|q
operator|=
name|labels
index|[
name|index
index|]
operator|.
name|q
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
continue|continue;
name|lab
operator|=
name|labels
index|[
name|index
index|]
operator|.
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|return_index
condition|)
name|do_return_redirection
argument_list|(
name|q
argument_list|,
name|lab
argument_list|,
name|NULL
argument_list|,
operator|&
name|return_val
argument_list|)
expr_stmt|;
else|else
name|do_goto_redirection
argument_list|(
name|q
argument_list|,
name|lab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
name|x
operator|=
name|lower_try_finally_dup_block
argument_list|(
name|finally
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|q
operator|->
name|cont_stmt
argument_list|,
operator|&
name|new_stmt
argument_list|)
expr_stmt|;
name|maybe_record_in_goto_queue
argument_list|(
name|state
argument_list|,
name|q
operator|->
name|cont_stmt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
name|tf
operator|->
name|goto_queue
init|;
name|q
operator|<
name|qe
condition|;
name|q
operator|++
control|)
block|{
name|tree
name|lab
decl_stmt|;
name|index
operator|=
name|q
operator|->
name|index
operator|<
literal|0
condition|?
name|return_index
else|:
name|q
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|labels
index|[
name|index
index|]
operator|.
name|q
operator|==
name|q
condition|)
continue|continue;
name|lab
operator|=
name|labels
index|[
name|index
index|]
operator|.
name|label
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|return_index
condition|)
name|do_return_redirection
argument_list|(
name|q
argument_list|,
name|lab
argument_list|,
name|NULL
argument_list|,
operator|&
name|return_val
argument_list|)
expr_stmt|;
else|else
name|do_goto_redirection
argument_list|(
name|q
argument_list|,
name|lab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|replace_goto_queue
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
block|}
comment|/* Need to link new stmts after running replace_goto_queue due      to not wanting to process the same goto stmts twice.  */
name|append_to_statement_list
argument_list|(
name|new_stmt
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_try_finally.  There are multiple edges incoming    and outgoing from the finally block.  Implement this by instrumenting    each incoming edge and creating a switch statement at the end of the    finally block that branches to the appropriate destination.  */
end_comment

begin_function
specifier|static
name|void
name|lower_try_finally_switch
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|struct
name|leh_tf_state
modifier|*
name|tf
parameter_list|)
block|{
name|struct
name|goto_queue_node
modifier|*
name|q
decl_stmt|,
modifier|*
name|qe
decl_stmt|;
name|tree
name|return_val
init|=
name|NULL
decl_stmt|;
name|tree
name|finally
decl_stmt|,
name|finally_tmp
decl_stmt|,
name|finally_label
decl_stmt|;
name|int
name|return_index
decl_stmt|,
name|eh_index
decl_stmt|,
name|fallthru_index
decl_stmt|;
name|int
name|nlabels
decl_stmt|,
name|ndests
decl_stmt|,
name|j
decl_stmt|,
name|last_case_index
decl_stmt|;
name|tree
name|case_label_vec
decl_stmt|,
name|switch_stmt
decl_stmt|,
name|last_case
decl_stmt|,
name|switch_body
decl_stmt|;
name|tree
name|x
decl_stmt|;
comment|/* Mash the TRY block to the head of the chain.  */
name|finally
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tf
operator|->
name|top_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tf
operator|->
name|top_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Lower the finally block itself.  */
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|finally
argument_list|)
expr_stmt|;
comment|/* Prepare for switch statement generation.  */
name|nlabels
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|tf
operator|->
name|dest_array
argument_list|)
expr_stmt|;
name|return_index
operator|=
name|nlabels
expr_stmt|;
name|eh_index
operator|=
name|return_index
operator|+
name|tf
operator|->
name|may_return
expr_stmt|;
name|fallthru_index
operator|=
name|eh_index
operator|+
name|tf
operator|->
name|may_throw
expr_stmt|;
name|ndests
operator|=
name|fallthru_index
operator|+
name|tf
operator|->
name|may_fallthru
expr_stmt|;
name|finally_tmp
operator|=
name|create_tmp_var
argument_list|(
name|integer_type_node
argument_list|,
literal|"finally_tmp"
argument_list|)
expr_stmt|;
name|finally_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|case_label_vec
operator|=
name|make_tree_vec
argument_list|(
name|ndests
argument_list|)
expr_stmt|;
name|switch_stmt
operator|=
name|build3
argument_list|(
name|SWITCH_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|finally_tmp
argument_list|,
name|NULL_TREE
argument_list|,
name|case_label_vec
argument_list|)
expr_stmt|;
name|switch_body
operator|=
name|NULL
expr_stmt|;
name|last_case
operator|=
name|NULL
expr_stmt|;
name|last_case_index
operator|=
literal|0
expr_stmt|;
comment|/* Begin inserting code for getting to the finally block.  Things      are done in this order to correspond to the sequence the code is      layed out.  */
if|if
condition|(
name|tf
operator|->
name|may_fallthru
condition|)
block|{
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_tmp
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|fallthru_index
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|may_throw
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
block|}
name|last_case
operator|=
name|build3
argument_list|(
name|CASE_LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|fallthru_index
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|create_artificial_label
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|case_label_vec
argument_list|,
name|last_case_index
argument_list|)
operator|=
name|last_case
expr_stmt|;
name|last_case_index
operator|++
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|CASE_LABEL
argument_list|(
name|last_case
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|switch_body
argument_list|)
expr_stmt|;
name|x
operator|=
name|lower_try_finally_fallthru_label
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|switch_body
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tf
operator|->
name|may_throw
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tf
operator|->
name|eh_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_tmp
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|eh_index
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|last_case
operator|=
name|build3
argument_list|(
name|CASE_LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|eh_index
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|create_artificial_label
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|case_label_vec
argument_list|,
name|last_case_index
argument_list|)
operator|=
name|last_case
expr_stmt|;
name|last_case_index
operator|++
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|CASE_LABEL
argument_list|(
name|last_case
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|switch_body
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_resx
argument_list|(
name|get_eh_region_number
argument_list|(
name|tf
operator|->
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|switch_body
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|finally
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
comment|/* Redirect each incoming goto edge.  */
name|q
operator|=
name|tf
operator|->
name|goto_queue
expr_stmt|;
name|qe
operator|=
name|q
operator|+
name|tf
operator|->
name|goto_queue_active
expr_stmt|;
name|j
operator|=
name|last_case_index
operator|+
name|tf
operator|->
name|may_return
expr_stmt|;
for|for
control|(
init|;
name|q
operator|<
name|qe
condition|;
operator|++
name|q
control|)
block|{
name|tree
name|mod
decl_stmt|;
name|int
name|switch_id
decl_stmt|,
name|case_index
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|index
operator|<
literal|0
condition|)
block|{
name|mod
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_tmp
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|return_index
argument_list|)
argument_list|)
expr_stmt|;
name|do_return_redirection
argument_list|(
name|q
argument_list|,
name|finally_label
argument_list|,
name|mod
argument_list|,
operator|&
name|return_val
argument_list|)
expr_stmt|;
name|switch_id
operator|=
name|return_index
expr_stmt|;
block|}
else|else
block|{
name|mod
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|finally_tmp
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|q
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|do_goto_redirection
argument_list|(
name|q
argument_list|,
name|finally_label
argument_list|,
name|mod
argument_list|)
expr_stmt|;
name|switch_id
operator|=
name|q
operator|->
name|index
expr_stmt|;
block|}
name|case_index
operator|=
name|j
operator|+
name|q
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|case_label_vec
argument_list|,
name|case_index
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|case_label_vec
argument_list|,
name|case_index
argument_list|)
operator|=
name|build3
argument_list|(
name|CASE_LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|switch_id
argument_list|)
argument_list|,
name|NULL
argument_list|,
comment|/* We store the cont_stmt in the 		       CASE_LABEL, so that we can recover it 		       in the loop below.  We don't create 		       the new label while walking the 		       goto_queue because pointers don't 		       offer a stable order.  */
name|q
operator|->
name|cont_stmt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|last_case_index
init|;
name|j
operator|<
name|last_case_index
operator|+
name|nlabels
condition|;
name|j
operator|++
control|)
block|{
name|tree
name|label
decl_stmt|;
name|tree
name|cont_stmt
decl_stmt|;
name|last_case
operator|=
name|TREE_VEC_ELT
argument_list|(
name|case_label_vec
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|last_case
argument_list|)
expr_stmt|;
name|cont_stmt
operator|=
name|CASE_LABEL
argument_list|(
name|last_case
argument_list|)
expr_stmt|;
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|CASE_LABEL
argument_list|(
name|last_case
argument_list|)
operator|=
name|label
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|switch_body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|cont_stmt
argument_list|,
operator|&
name|switch_body
argument_list|)
expr_stmt|;
name|maybe_record_in_goto_queue
argument_list|(
name|state
argument_list|,
name|cont_stmt
argument_list|)
expr_stmt|;
block|}
name|replace_goto_queue
argument_list|(
name|tf
argument_list|)
expr_stmt|;
comment|/* Make sure that the last case is the default label, as one is required.      Then sort the labels, which is also required in GIMPLE.  */
name|CASE_LOW
argument_list|(
name|last_case
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sort_case_labels
argument_list|(
name|case_label_vec
argument_list|)
expr_stmt|;
comment|/* Need to link switch_stmt after running replace_goto_queue due      to not wanting to process the same goto stmts twice.  */
name|append_to_statement_list
argument_list|(
name|switch_stmt
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|switch_body
argument_list|,
name|tf
operator|->
name|top_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether or not we are going to duplicate the finally block.    There are several considerations.     First, if this is Java, then the finally block contains code    written by the user.  It has line numbers associated with it,    so duplicating the block means it's difficult to set a breakpoint.    Since controlling code generation via -g is verboten, we simply    never duplicate code without optimization.     Second, we'd like to prevent egregious code growth.  One way to    do this is to estimate the size of the finally block, multiply    that by the number of copies we'd need to make, and compare against    the estimate of the size of the switch machinery we'd have to add.  */
end_comment

begin_function
specifier|static
name|bool
name|decide_copy_try_finally
parameter_list|(
name|int
name|ndests
parameter_list|,
name|tree
name|finally
parameter_list|)
block|{
name|int
name|f_estimate
decl_stmt|,
name|sw_estimate
decl_stmt|;
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
name|false
return|;
comment|/* Finally estimate N times, plus N gotos.  */
name|f_estimate
operator|=
name|estimate_num_insns
argument_list|(
name|finally
argument_list|)
expr_stmt|;
name|f_estimate
operator|=
operator|(
name|f_estimate
operator|+
literal|1
operator|)
operator|*
name|ndests
expr_stmt|;
comment|/* Switch statement (cost 10), N variable assignments, N gotos.  */
name|sw_estimate
operator|=
literal|10
operator|+
literal|2
operator|*
name|ndests
expr_stmt|;
comment|/* Optimize for size clearly wants our best guess.  */
if|if
condition|(
name|optimize_size
condition|)
return|return
name|f_estimate
operator|<
name|sw_estimate
return|;
comment|/* ??? These numbers are completely made up so far.  */
if|if
condition|(
name|optimize
operator|>
literal|1
condition|)
return|return
name|f_estimate
operator|<
literal|100
operator|||
name|f_estimate
operator|<
name|sw_estimate
operator|*
literal|2
return|;
else|else
return|return
name|f_estimate
operator|<
literal|40
operator|||
name|f_estimate
operator|*
literal|2
operator|<
name|sw_estimate
operator|*
literal|3
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_eh_constructs_1.  Lower a TRY_FINALLY_EXPR nodes    to a sequence of labels and blocks, plus the exception region trees    that record all the magic.  This is complicated by the need to    arrange for the FINALLY block to be executed on all exits.  */
end_comment

begin_function
specifier|static
name|void
name|lower_try_finally
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|leh_tf_state
name|this_tf
decl_stmt|;
name|struct
name|leh_state
name|this_state
decl_stmt|;
name|int
name|ndests
decl_stmt|;
comment|/* Process the try block.  */
name|memset
argument_list|(
operator|&
name|this_tf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|this_tf
argument_list|)
argument_list|)
expr_stmt|;
name|this_tf
operator|.
name|try_finally_expr
operator|=
operator|*
name|tp
expr_stmt|;
name|this_tf
operator|.
name|top_p
operator|=
name|tp
expr_stmt|;
name|this_tf
operator|.
name|outer
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|using_eh_for_cleanups_p
condition|)
name|this_tf
operator|.
name|region
operator|=
name|gen_eh_region_cleanup
argument_list|(
name|state
operator|->
name|cur_region
argument_list|,
name|state
operator|->
name|prev_try
argument_list|)
expr_stmt|;
else|else
name|this_tf
operator|.
name|region
operator|=
name|NULL
expr_stmt|;
name|this_state
operator|.
name|cur_region
operator|=
name|this_tf
operator|.
name|region
expr_stmt|;
name|this_state
operator|.
name|prev_try
operator|=
name|state
operator|->
name|prev_try
expr_stmt|;
name|this_state
operator|.
name|tf
operator|=
operator|&
name|this_tf
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
operator|&
name|this_state
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine if the try block is escaped through the bottom.  */
name|this_tf
operator|.
name|may_fallthru
operator|=
name|block_may_fallthru
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine if any exceptions are possible within the try block.  */
if|if
condition|(
name|using_eh_for_cleanups_p
condition|)
name|this_tf
operator|.
name|may_throw
operator|=
name|get_eh_region_may_contain_throw
argument_list|(
name|this_tf
operator|.
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_tf
operator|.
name|may_throw
condition|)
block|{
name|this_tf
operator|.
name|eh_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|set_eh_region_tree_label
argument_list|(
name|this_tf
operator|.
name|region
argument_list|,
name|this_tf
operator|.
name|eh_label
argument_list|)
expr_stmt|;
name|honor_protect_cleanup_actions
argument_list|(
name|state
argument_list|,
operator|&
name|this_state
argument_list|,
operator|&
name|this_tf
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the goto queue for efficient searching later.  */
if|if
condition|(
name|this_tf
operator|.
name|goto_queue_active
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|this_tf
operator|.
name|goto_queue
argument_list|,
name|this_tf
operator|.
name|goto_queue_active
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|goto_queue_node
argument_list|)
argument_list|,
name|goto_queue_cmp
argument_list|)
expr_stmt|;
comment|/* Determine how many edges (still) reach the finally block.  Or rather,      how many destinations are reached by the finally block.  Use this to      determine how we process the finally block itself.  */
name|ndests
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|this_tf
operator|.
name|dest_array
argument_list|)
expr_stmt|;
name|ndests
operator|+=
name|this_tf
operator|.
name|may_fallthru
expr_stmt|;
name|ndests
operator|+=
name|this_tf
operator|.
name|may_return
expr_stmt|;
name|ndests
operator|+=
name|this_tf
operator|.
name|may_throw
expr_stmt|;
comment|/* If the FINALLY block is not reachable, dike it out.  */
if|if
condition|(
name|ndests
operator|==
literal|0
condition|)
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the finally block doesn't fall through, then any destination      we might try to impose there isn't reached either.  There may be      some minor amount of cleanup and redirection still needed.  */
elseif|else
if|if
condition|(
operator|!
name|block_may_fallthru
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|lower_try_finally_nofallthru
argument_list|(
name|state
argument_list|,
operator|&
name|this_tf
argument_list|)
expr_stmt|;
comment|/* We can easily special-case redirection to a single destination.  */
elseif|else
if|if
condition|(
name|ndests
operator|==
literal|1
condition|)
name|lower_try_finally_onedest
argument_list|(
name|state
argument_list|,
operator|&
name|this_tf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decide_copy_try_finally
argument_list|(
name|ndests
argument_list|,
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|lower_try_finally_copy
argument_list|(
name|state
argument_list|,
operator|&
name|this_tf
argument_list|)
expr_stmt|;
else|else
name|lower_try_finally_switch
argument_list|(
name|state
argument_list|,
operator|&
name|this_tf
argument_list|)
expr_stmt|;
comment|/* If someone requested we add a label at the end of the transformed      block, do so.  */
if|if
condition|(
name|this_tf
operator|.
name|fallthru_label
condition|)
block|{
name|tree
name|x
init|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|this_tf
operator|.
name|fallthru_label
argument_list|)
decl_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|this_tf
operator|.
name|dest_array
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_tf
operator|.
name|goto_queue
condition|)
name|free
argument_list|(
name|this_tf
operator|.
name|goto_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_eh_constructs_1.  Lower a TRY_CATCH_EXPR with a    list of CATCH_EXPR nodes to a sequence of labels and blocks, plus the    exception region trees that record all the magic.  */
end_comment

begin_function
specifier|static
name|void
name|lower_catch
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|eh_region
modifier|*
name|try_region
decl_stmt|;
name|struct
name|leh_state
name|this_state
decl_stmt|;
name|tree_stmt_iterator
name|i
decl_stmt|;
name|tree
name|out_label
decl_stmt|;
name|try_region
operator|=
name|gen_eh_region_try
argument_list|(
name|state
operator|->
name|cur_region
argument_list|)
expr_stmt|;
name|this_state
operator|.
name|cur_region
operator|=
name|try_region
expr_stmt|;
name|this_state
operator|.
name|prev_try
operator|=
name|try_region
expr_stmt|;
name|this_state
operator|.
name|tf
operator|=
name|state
operator|->
name|tf
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
operator|&
name|this_state
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_eh_region_may_contain_throw
argument_list|(
name|try_region
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|out_label
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
control|)
block|{
name|struct
name|eh_region
modifier|*
name|catch_region
decl_stmt|;
name|tree
name|catch
decl_stmt|,
name|x
decl_stmt|,
name|eh_label
decl_stmt|;
name|catch
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|catch_region
operator|=
name|gen_eh_region_catch
argument_list|(
name|try_region
argument_list|,
name|CATCH_TYPES
argument_list|(
name|catch
argument_list|)
argument_list|)
expr_stmt|;
name|this_state
operator|.
name|cur_region
operator|=
name|catch_region
expr_stmt|;
name|this_state
operator|.
name|prev_try
operator|=
name|state
operator|->
name|prev_try
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
operator|&
name|this_state
argument_list|,
operator|&
name|CATCH_BODY
argument_list|(
name|catch
argument_list|)
argument_list|)
expr_stmt|;
name|eh_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|set_eh_region_tree_label
argument_list|(
name|catch_region
argument_list|,
name|eh_label
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|eh_label
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_may_fallthru
argument_list|(
name|CATCH_BODY
argument_list|(
name|catch
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|out_label
condition|)
name|out_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|out_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|CATCH_BODY
argument_list|(
name|catch
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tsi_link_before
argument_list|(
operator|&
name|i
argument_list|,
name|CATCH_BODY
argument_list|(
name|catch
argument_list|)
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
name|frob_into_branch_around
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|,
name|out_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of lower_eh_constructs_1.  Lower a TRY_CATCH_EXPR with a    EH_FILTER_EXPR to a sequence of labels and blocks, plus the exception    region trees that record all the magic.  */
end_comment

begin_function
specifier|static
name|void
name|lower_eh_filter
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|leh_state
name|this_state
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|this_region
decl_stmt|;
name|tree
name|inner
init|=
name|expr_first
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|eh_label
decl_stmt|;
if|if
condition|(
name|EH_FILTER_MUST_NOT_THROW
argument_list|(
name|inner
argument_list|)
condition|)
name|this_region
operator|=
name|gen_eh_region_must_not_throw
argument_list|(
name|state
operator|->
name|cur_region
argument_list|)
expr_stmt|;
else|else
name|this_region
operator|=
name|gen_eh_region_allowed
argument_list|(
name|state
operator|->
name|cur_region
argument_list|,
name|EH_FILTER_TYPES
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|this_state
operator|=
operator|*
name|state
expr_stmt|;
name|this_state
operator|.
name|cur_region
operator|=
name|this_region
expr_stmt|;
comment|/* For must not throw regions any cleanup regions inside it      can't reach outer catch regions.  */
if|if
condition|(
name|EH_FILTER_MUST_NOT_THROW
argument_list|(
name|inner
argument_list|)
condition|)
name|this_state
operator|.
name|prev_try
operator|=
name|NULL
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
operator|&
name|this_state
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_eh_region_may_contain_throw
argument_list|(
name|this_region
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|EH_FILTER_FAILURE
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
operator|=
name|EH_FILTER_FAILURE
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|eh_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|set_eh_region_tree_label
argument_list|(
name|this_region
argument_list|,
name|eh_label
argument_list|)
expr_stmt|;
name|frob_into_branch_around
argument_list|(
name|tp
argument_list|,
name|eh_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement a cleanup expression.  This is similar to try-finally,    except that we only execute the cleanup block for exception edges.  */
end_comment

begin_function
specifier|static
name|void
name|lower_cleanup
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|leh_state
name|this_state
decl_stmt|;
name|struct
name|eh_region
modifier|*
name|this_region
decl_stmt|;
name|struct
name|leh_tf_state
name|fake_tf
decl_stmt|;
comment|/* If not using eh, then exception-only cleanups are no-ops.  */
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
block|{
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
name|this_region
operator|=
name|gen_eh_region_cleanup
argument_list|(
name|state
operator|->
name|cur_region
argument_list|,
name|state
operator|->
name|prev_try
argument_list|)
expr_stmt|;
name|this_state
operator|=
operator|*
name|state
expr_stmt|;
name|this_state
operator|.
name|cur_region
operator|=
name|this_region
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
operator|&
name|this_state
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_eh_region_may_contain_throw
argument_list|(
name|this_region
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Build enough of a try-finally state so that we can reuse      honor_protect_cleanup_actions.  */
name|memset
argument_list|(
operator|&
name|fake_tf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fake_tf
argument_list|)
argument_list|)
expr_stmt|;
name|fake_tf
operator|.
name|top_p
operator|=
name|tp
expr_stmt|;
name|fake_tf
operator|.
name|outer
operator|=
name|state
expr_stmt|;
name|fake_tf
operator|.
name|region
operator|=
name|this_region
expr_stmt|;
name|fake_tf
operator|.
name|may_fallthru
operator|=
name|block_may_fallthru
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fake_tf
operator|.
name|may_throw
operator|=
name|true
expr_stmt|;
name|fake_tf
operator|.
name|eh_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|set_eh_region_tree_label
argument_list|(
name|this_region
argument_list|,
name|fake_tf
operator|.
name|eh_label
argument_list|)
expr_stmt|;
name|honor_protect_cleanup_actions
argument_list|(
name|state
argument_list|,
name|NULL
argument_list|,
operator|&
name|fake_tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fake_tf
operator|.
name|may_throw
condition|)
block|{
comment|/* In this case honor_protect_cleanup_actions had nothing to do, 	 and we should process this normally.  */
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|frob_into_branch_around
argument_list|(
name|tp
argument_list|,
name|fake_tf
operator|.
name|eh_label
argument_list|,
name|fake_tf
operator|.
name|fallthru_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In this case honor_protect_cleanup_actions did nearly all of 	 the work.  All we have left is to append the fallthru_label.  */
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fake_tf
operator|.
name|fallthru_label
condition|)
block|{
name|tree
name|x
init|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fake_tf
operator|.
name|fallthru_label
argument_list|)
decl_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Main loop for lowering eh constructs.  */
end_comment

begin_function
specifier|static
name|void
name|lower_eh_constructs_1
parameter_list|(
name|struct
name|leh_state
modifier|*
name|state
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|COND_EXPR_THEN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
operator|&
name|COND_EXPR_ELSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Look for things that can throw exceptions, and record them.  */
if|if
condition|(
name|state
operator|->
name|cur_region
operator|&&
name|tree_could_throw_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|record_stmt_eh_region
argument_list|(
name|state
operator|->
name|cur_region
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|note_eh_region_may_contain_throw
argument_list|(
name|state
operator|->
name|cur_region
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MODIFY_EXPR
case|:
comment|/* Look for things that can throw exceptions, and record them.  */
if|if
condition|(
name|state
operator|->
name|cur_region
operator|&&
name|tree_could_throw_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|record_stmt_eh_region
argument_list|(
name|state
operator|->
name|cur_region
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|note_eh_region_may_contain_throw
argument_list|(
name|state
operator|->
name|cur_region
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GOTO_EXPR
case|:
case|case
name|RETURN_EXPR
case|:
name|maybe_record_in_goto_queue
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|verify_norecord_switch_expr
argument_list|(
name|state
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
name|lower_try_finally
argument_list|(
name|state
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_CATCH_EXPR
case|:
name|i
operator|=
name|tsi_start
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CATCH_EXPR
case|:
name|lower_catch
argument_list|(
name|state
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_FILTER_EXPR
case|:
name|lower_eh_filter
argument_list|(
name|state
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lower_cleanup
argument_list|(
name|state
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|STATEMENT_LIST
case|:
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
control|)
block|{
name|lower_eh_constructs_1
argument_list|(
name|state
argument_list|,
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|tsi_link_before
argument_list|(
operator|&
name|i
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* A type, a decl, or some kind of statement that we're not 	 interested in.  Don't walk them.  */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|lower_eh_constructs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|leh_state
name|null_state
decl_stmt|;
name|tree
modifier|*
name|tp
init|=
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|finally_tree
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|struct_ptr_hash
argument_list|,
name|struct_ptr_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|collect_finally_tree
argument_list|(
operator|*
name|tp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|null_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|null_state
argument_list|)
argument_list|)
expr_stmt|;
name|lower_eh_constructs_1
argument_list|(
operator|&
name|null_state
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|finally_tree
argument_list|)
expr_stmt|;
name|collect_eh_region_array
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_lower_eh
init|=
block|{
literal|"eh"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|lower_eh_constructs
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_EH
block|,
comment|/* tv_id */
name|PROP_gimple_lcf
block|,
comment|/* properties_required */
name|PROP_gimple_leh
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Construct EH edges for STMT.  */
end_comment

begin_function
specifier|static
name|void
name|make_eh_edge
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|lab
decl_stmt|;
name|basic_block
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|stmt
operator|=
operator|(
name|tree
operator|)
name|data
expr_stmt|;
name|lab
operator|=
name|get_eh_region_tree_label
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|src
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|dst
operator|=
name|label_to_block
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_EH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_eh_edges
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|region_nr
decl_stmt|;
name|bool
name|is_resx
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RESX_EXPR
condition|)
block|{
name|region_nr
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|is_resx
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|region_nr
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_nr
operator|<
literal|0
condition|)
return|return;
name|is_resx
operator|=
name|false
expr_stmt|;
block|}
name|foreach_reachable_handler
argument_list|(
name|region_nr
argument_list|,
name|is_resx
argument_list|,
name|make_eh_edge
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bool
name|mark_eh_edge_found_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark edge make_eh_edge would create for given region by setting it aux    field, output error if something goes wrong.  */
end_comment

begin_function
specifier|static
name|void
name|mark_eh_edge
parameter_list|(
name|struct
name|eh_region
modifier|*
name|region
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|lab
decl_stmt|;
name|basic_block
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|stmt
operator|=
operator|(
name|tree
operator|)
name|data
expr_stmt|;
name|lab
operator|=
name|get_eh_region_tree_label
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|src
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|dst
operator|=
name|label_to_block
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|e
operator|=
name|find_edge
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|error
argument_list|(
literal|"EH edge %i->%i is missing"
argument_list|,
name|src
operator|->
name|index
argument_list|,
name|dst
operator|->
name|index
argument_list|)
expr_stmt|;
name|mark_eh_edge_found_error
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"EH edge %i->%i miss EH flag"
argument_list|,
name|src
operator|->
name|index
argument_list|,
name|dst
operator|->
name|index
argument_list|)
expr_stmt|;
name|mark_eh_edge_found_error
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|aux
condition|)
block|{
comment|/* ??? might not be mistake.  */
name|error
argument_list|(
literal|"EH edge %i->%i has duplicated regions"
argument_list|,
name|src
operator|->
name|index
argument_list|,
name|dst
operator|->
name|index
argument_list|)
expr_stmt|;
name|mark_eh_edge_found_error
operator|=
name|true
expr_stmt|;
block|}
else|else
name|e
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify that BB containing stmt as last stmt has precisely the edges    make_eh_edges would create.  */
end_comment

begin_function
name|bool
name|verify_eh_edges
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|region_nr
decl_stmt|;
name|bool
name|is_resx
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|gcc_assert
argument_list|(
operator|!
name|e
operator|->
name|aux
argument_list|)
expr_stmt|;
name|mark_eh_edge_found_error
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RESX_EXPR
condition|)
block|{
name|region_nr
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|is_resx
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|region_nr
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_nr
operator|<
literal|0
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
name|error
argument_list|(
literal|"BB %i can not throw but has EH edges"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|tree_could_throw_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"BB %i last statement has incorrectly set region"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|is_resx
operator|=
name|false
expr_stmt|;
block|}
name|foreach_reachable_handler
argument_list|(
name|region_nr
argument_list|,
name|is_resx
argument_list|,
name|mark_eh_edge
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
operator|&&
operator|!
name|e
operator|->
name|aux
condition|)
block|{
name|error
argument_list|(
literal|"unnecessary EH edge %i->%i"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|mark_eh_edge_found_error
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|mark_eh_edge_found_error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the expr can trap, as in dereferencing an invalid pointer    location or floating point arithmetic.  C.f. the rtl version, may_trap_p.    This routine expects only GIMPLE lhs or rhs input.  */
end_comment

begin_function
name|bool
name|tree_could_trap_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|bool
name|honor_nans
init|=
name|false
decl_stmt|;
name|bool
name|honor_snans
init|=
name|false
decl_stmt|;
name|bool
name|fp_operation
init|=
name|false
decl_stmt|;
name|bool
name|honor_trapv
init|=
name|false
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|base
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
condition|)
block|{
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fp_operation
operator|=
name|FLOAT_TYPE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_operation
condition|)
block|{
name|honor_nans
operator|=
name|flag_trapping_math
operator|&&
operator|!
name|flag_finite_math_only
expr_stmt|;
name|honor_snans
operator|=
name|flag_signaling_nans
operator|!=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|t
argument_list|)
condition|)
name|honor_trapv
operator|=
name|true
expr_stmt|;
block|}
name|restart
label|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TARGET_MEM_REF
case|:
comment|/* For TARGET_MEM_REFs use the information based on the original 	 reference.  */
name|expr
operator|=
name|TMR_ORIGINAL
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|COMPONENT_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|WITH_SIZE_EXPR
case|:
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|ARRAY_RANGE_REF
case|:
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_could_trap_p
argument_list|(
name|base
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_THIS_NOTRAP
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|!
name|range_in_array_bounds_p
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_could_trap_p
argument_list|(
name|base
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_THIS_NOTRAP
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|!
name|in_array_bounds_p
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
return|return
operator|!
name|TREE_THIS_NOTRAP
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|ASM_EXPR
case|:
return|return
name|TREE_THIS_VOLATILE
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
name|honor_snans
operator|||
name|honor_trapv
condition|)
return|return
name|true
return|;
if|if
condition|(
name|fp_operation
condition|)
return|return
name|flag_trapping_math
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
comment|/* Some floating point comparisons may trap.  */
return|return
name|honor_nans
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
return|return
name|honor_snans
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
comment|/* Conversion of floating point might trap.  */
return|return
name|honor_nans
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
comment|/* These operations don't trap with floating point.  */
if|if
condition|(
name|honor_trapv
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
comment|/* Any floating arithmetic may trap.  */
if|if
condition|(
name|fp_operation
operator|&&
name|flag_trapping_math
condition|)
return|return
name|true
return|;
if|if
condition|(
name|honor_trapv
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|CALL_EXPR
case|:
name|t
operator|=
name|get_callee_fndecl
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Assume that calls to weak functions may trap.  */
if|if
condition|(
operator|!
name|t
operator|||
operator|!
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_WEAK
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
default|default:
comment|/* Any floating arithmetic may trap.  */
if|if
condition|(
name|fp_operation
operator|&&
name|flag_trapping_math
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
name|bool
name|tree_could_throw_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_exceptions
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|tree_could_trap_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
operator|(
name|call_expr_flags
argument_list|(
name|t
argument_list|)
operator|&
name|ECF_NOTHROW
operator|)
operator|==
literal|0
return|;
if|if
condition|(
name|flag_non_call_exceptions
condition|)
return|return
name|tree_could_trap_p
argument_list|(
name|t
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|tree_can_throw_internal
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|region_nr
decl_stmt|;
name|bool
name|is_resx
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RESX_EXPR
condition|)
name|region_nr
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|is_resx
operator|=
name|true
expr_stmt|;
else|else
name|region_nr
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_nr
operator|<
literal|0
condition|)
return|return
name|false
return|;
return|return
name|can_throw_internal_1
argument_list|(
name|region_nr
argument_list|,
name|is_resx
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|tree_can_throw_external
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|region_nr
decl_stmt|;
name|bool
name|is_resx
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RESX_EXPR
condition|)
name|region_nr
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|is_resx
operator|=
name|true
expr_stmt|;
else|else
name|region_nr
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_nr
operator|<
literal|0
condition|)
return|return
name|tree_could_throw_p
argument_list|(
name|stmt
argument_list|)
return|;
else|else
return|return
name|can_throw_external_1
argument_list|(
name|region_nr
argument_list|,
name|is_resx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a statement OLD_STMT and a new statement NEW_STMT that has replaced    OLD_STMT in the function, remove OLD_STMT from the EH table and put NEW_STMT    in the table if it should be in there.  Return TRUE if a replacement was    done that my require an EH edge purge.  */
end_comment

begin_function
name|bool
name|maybe_clean_or_replace_eh_stmt
parameter_list|(
name|tree
name|old_stmt
parameter_list|,
name|tree
name|new_stmt
parameter_list|)
block|{
name|int
name|region_nr
init|=
name|lookup_stmt_eh_region
argument_list|(
name|old_stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|region_nr
operator|>=
literal|0
condition|)
block|{
name|bool
name|new_stmt_could_throw
init|=
name|tree_could_throw_p
argument_list|(
name|new_stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_stmt
operator|==
name|old_stmt
operator|&&
name|new_stmt_could_throw
condition|)
return|return
name|false
return|;
name|remove_stmt_from_eh_region
argument_list|(
name|old_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_stmt_could_throw
condition|)
block|{
name|add_stmt_to_eh_region
argument_list|(
name|new_stmt
argument_list|,
name|region_nr
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function
specifier|static
name|int
name|verify_eh_throw_stmt_node
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|throw_stmt_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|throw_stmt_node
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|->
name|stmt
operator|->
name|common
operator|.
name|ann
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|verify_eh_throw_table_statements
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|get_eh_throw_stmt_table
argument_list|(
name|cfun
argument_list|)
condition|)
return|return;
name|htab_traverse
argument_list|(
name|get_eh_throw_stmt_table
argument_list|(
name|cfun
argument_list|)
argument_list|,
name|verify_eh_throw_stmt_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

