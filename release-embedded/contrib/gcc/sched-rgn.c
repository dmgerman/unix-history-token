begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This pass implements list scheduling within basic blocks.  It is    run twice: (1) after flow analysis, but before register allocation,    and (2) after register allocation.     The first run performs interblock scheduling, moving insns between    different blocks in the same "region", and the second runs only    basic block scheduling.     Interblock motions performed are useful motions and speculative    motions, including speculative loads.  Motions requiring code    duplication are not supported.  The identification of motion type    and the check for validity of speculative motions requires    construction and analysis of the function's control flow graph.     The main entry point for this pass is schedule_insns(), called for    each function.  The work of the scheduler is organized in three    levels: (1) function level: insns are subject to splitting,    control-flow-graph is constructed, regions are computed (after    reload, each region is of one block), (2) region level: control    flow graph attributes required for interblock scheduling are    computed (dominators, reachability, etc.), data dependences and    priorities are computed, and (3) block level: insns in the block    are actually scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* Define when we want to do count REG_DEAD notes before and after scheduling    for sanity checking.  We can't do that when conditional execution is used,    as REG_DEAD exist only for unconditional deaths.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_conditional_execution
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_CHECKING
argument_list|)
end_if

begin_define
define|#
directive|define
name|CHECK_DEAD_NOTES
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_DEAD_NOTES
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* Some accessor macros for h_i_d members only used within this file.  */
end_comment

begin_define
define|#
directive|define
name|INSN_REF_COUNT
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].ref_count)
end_define

begin_define
define|#
directive|define
name|FED_BY_SPEC_LOAD
parameter_list|(
name|insn
parameter_list|)
value|(h_i_d[INSN_UID (insn)].fed_by_spec_load)
end_define

begin_define
define|#
directive|define
name|IS_LOAD_INSN
parameter_list|(
name|insn
parameter_list|)
value|(h_i_d[INSN_UID (insn)].is_load_insn)
end_define

begin_comment
comment|/* nr_inter/spec counts interblock/speculative motion for the function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_inter
decl_stmt|,
name|nr_spec
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|is_cfg_nonregular
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sched_is_disabled_for_current_region_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A region is the main entity for interblock scheduling: insns    are allowed to move between blocks in the same region, along    control flow graph edges, in the 'up' direction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Number of extended basic blocks in region.  */
name|int
name|rgn_nr_blocks
decl_stmt|;
comment|/* cblocks in the region (actually index in rgn_bb_table).  */
name|int
name|rgn_blocks
decl_stmt|;
comment|/* Dependencies for this region are already computed.  Basically, indicates,      that this is a recovery block.  */
name|unsigned
name|int
name|dont_calc_deps
range|:
literal|1
decl_stmt|;
comment|/* This region has at least one non-trivial ebb.  */
name|unsigned
name|int
name|has_real_ebb
range|:
literal|1
decl_stmt|;
block|}
name|region
typedef|;
end_typedef

begin_comment
comment|/* Number of regions in the procedure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_regions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of region descriptions.  */
end_comment

begin_decl_stmt
specifier|static
name|region
modifier|*
name|rgn_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of lists of regions' blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|rgn_bb_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Topological order of blocks in the region (if b2 is reachable from    b1, block_to_bb[b2]> block_to_bb[b1]).  Note: A basic block is    always referred to by either block or b, while its topological    order name (in the region) is referred to by bb.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|block_to_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of the region containing a block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|containing_rgn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The minimum probability of reaching a source block so that it will be    considered for speculative scheduling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|min_spec_prob
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RGN_NR_BLOCKS
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].rgn_nr_blocks)
end_define

begin_define
define|#
directive|define
name|RGN_BLOCKS
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].rgn_blocks)
end_define

begin_define
define|#
directive|define
name|RGN_DONT_CALC_DEPS
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].dont_calc_deps)
end_define

begin_define
define|#
directive|define
name|RGN_HAS_REAL_EBB
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].has_real_ebb)
end_define

begin_define
define|#
directive|define
name|BLOCK_TO_BB
parameter_list|(
name|block
parameter_list|)
value|(block_to_bb[block])
end_define

begin_define
define|#
directive|define
name|CONTAINING_RGN
parameter_list|(
name|block
parameter_list|)
value|(containing_rgn[block])
end_define

begin_function_decl
name|void
name|debug_regions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_single_block_region
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_rgns
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_rgns
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|sbitmap
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|too_large
parameter_list|(
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|debug_live
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Blocks of the current region being scheduled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_nr_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rgn_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mapping from ebb to block.  */
end_comment

begin_comment
comment|/* ebb_head [i] - is index in rgn_bb_table, while    EBB_HEAD (i) - is basic block index.    BASIC_BLOCK (EBB_HEAD (i)) - head of ebb.  */
end_comment

begin_define
define|#
directive|define
name|BB_TO_BLOCK
parameter_list|(
name|ebb
parameter_list|)
value|(rgn_bb_table[ebb_head[ebb]])
end_define

begin_define
define|#
directive|define
name|EBB_FIRST_BB
parameter_list|(
name|ebb
parameter_list|)
value|BASIC_BLOCK (BB_TO_BLOCK (ebb))
end_define

begin_define
define|#
directive|define
name|EBB_LAST_BB
parameter_list|(
name|ebb
parameter_list|)
value|BASIC_BLOCK (rgn_bb_table[ebb_head[ebb + 1] - 1])
end_define

begin_comment
comment|/* Target info declarations.     The block currently being scheduled is referred to as the "target" block,    while other blocks in the region from which insns can be moved to the    target are called "source" blocks.  The candidate structure holds info    about such sources: are they valid?  Speculative?  Etc.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|basic_block
modifier|*
name|first_member
decl_stmt|;
name|int
name|nr_members
decl_stmt|;
block|}
name|bblst
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|is_valid
decl_stmt|;
name|char
name|is_speculative
decl_stmt|;
name|int
name|src_prob
decl_stmt|;
name|bblst
name|split_bbs
decl_stmt|;
name|bblst
name|update_bbs
decl_stmt|;
block|}
name|candidate
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|candidate
modifier|*
name|candidate_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A speculative motion requires checking live information on the path    from 'source' to 'target'.  The split blocks are those to be checked.    After a speculative motion, live information should be modified in    the 'update' blocks.     Lists of split and update blocks for each candidate of the current    target are in array bblst_table.  */
end_comment

begin_decl_stmt
specifier|static
name|basic_block
modifier|*
name|bblst_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bblst_size
decl_stmt|,
name|bblst_last
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_VALID
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].is_valid )
end_define

begin_define
define|#
directive|define
name|IS_SPECULATIVE
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].is_speculative )
end_define

begin_define
define|#
directive|define
name|SRC_PROB
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].src_prob )
end_define

begin_comment
comment|/* The bb being currently scheduled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of edges.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|edge
modifier|*
name|first_member
decl_stmt|;
name|int
name|nr_members
decl_stmt|;
block|}
name|edgelst
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|edge
modifier|*
name|edgelst_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|edgelst_last
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|extract_edgelst
parameter_list|(
name|sbitmap
parameter_list|,
name|edgelst
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Target info functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|split_edges
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|edgelst
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_trg_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_candidate
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_candidates
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dominators array: dom[i] contains the sbitmap of dominators of    bb i in the region.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|dom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bb 0 is the only region entry.  */
end_comment

begin_define
define|#
directive|define
name|IS_RGN_ENTRY
parameter_list|(
name|bb
parameter_list|)
value|(!bb)
end_define

begin_comment
comment|/* Is bb_src dominated by bb_trg.  */
end_comment

begin_define
define|#
directive|define
name|IS_DOMINATED
parameter_list|(
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
define|\
value|( TEST_BIT (dom[bb_src], bb_trg) )
end_define

begin_comment
comment|/* Probability: Prob[i] is an int in [0, REG_BR_PROB_BASE] which is    the probability of bb i relative to the region entry.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|prob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit-set of edges, where bit i stands for edge i.  */
end_comment

begin_typedef
typedef|typedef
name|sbitmap
name|edgeset
typedef|;
end_typedef

begin_comment
comment|/* Number of edges in the region.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rgn_nr_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of size rgn_nr_edges.  */
end_comment

begin_decl_stmt
specifier|static
name|edge
modifier|*
name|rgn_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from each edge in the graph to its number in the rgn.  */
end_comment

begin_define
define|#
directive|define
name|EDGE_TO_BIT
parameter_list|(
name|edge
parameter_list|)
value|((int)(size_t)(edge)->aux)
end_define

begin_define
define|#
directive|define
name|SET_EDGE_TO_BIT
parameter_list|(
name|edge
parameter_list|,
name|nr
parameter_list|)
value|((edge)->aux = (void *)(size_t)(nr))
end_define

begin_comment
comment|/* The split edges of a source bb is different for each target    bb.  In order to compute this efficiently, the 'potential-split edges'    are computed for each bb prior to scheduling a region.  This is actually    the split edges of each bb relative to the region entry.     pot_split[bb] is the set of potential split edges of bb.  */
end_comment

begin_decl_stmt
specifier|static
name|edgeset
modifier|*
name|pot_split
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For every bb, a set of its ancestor edges.  */
end_comment

begin_decl_stmt
specifier|static
name|edgeset
modifier|*
name|ancestor_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of EBBs sizes.  Currently we can get a ebb only through     splitting of currently scheduling block, therefore, we don't need    ebb_head array for every region, its sufficient to hold it only    for current one.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|ebb_head
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|compute_dom_prob_ps
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INSN_PROBABILITY
parameter_list|(
name|INSN
parameter_list|)
value|(SRC_PROB (BLOCK_TO_BB (BLOCK_NUM (INSN))))
end_define

begin_define
define|#
directive|define
name|IS_SPECULATIVE_INSN
parameter_list|(
name|INSN
parameter_list|)
value|(IS_SPECULATIVE (BLOCK_TO_BB (BLOCK_NUM (INSN))))
end_define

begin_define
define|#
directive|define
name|INSN_BB
parameter_list|(
name|INSN
parameter_list|)
value|(BLOCK_TO_BB (BLOCK_NUM (INSN)))
end_define

begin_comment
comment|/* Speculative scheduling functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|check_live_1
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_live_1
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_live
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_live
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_spec_fed
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_pfree
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_conditional_protection
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_conditionally_protected
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_prisky
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_exception_free
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sets_likely_spilled
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sets_likely_spilled_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_branch_dependences
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_block_backward_dependences
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_dependencies
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_regions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|schedule_region
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|concat_INSN_LIST
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|concat_insn_mem_list
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_deps
parameter_list|(
name|int
parameter_list|,
name|struct
name|deps
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_pending_lists
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for construction of the control flow graph.  */
end_comment

begin_comment
comment|/* Return 1 if control flow graph should not be constructed, 0 otherwise.     We decide not to build the control flow graph if there is possibly more    than one entry to the function, if computed branches exist, if we    have nonlocal gotos, or if we have an unreachable loop.  */
end_comment

begin_function
specifier|static
name|int
name|is_cfg_nonregular
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* If we have a label that could be the target of a nonlocal goto, then      the cfg is not well structured.  */
if|if
condition|(
name|nonlocal_goto_handler_labels
condition|)
return|return
literal|1
return|;
comment|/* If we have any forced labels, then the cfg is not well structured.  */
if|if
condition|(
name|forced_labels
condition|)
return|return
literal|1
return|;
comment|/* If we have exception handlers, then we consider the cfg not well      structured.  ?!?  We should be able to handle this now that flow.c      computes an accurate cfg for EH.  */
if|if
condition|(
name|current_function_has_exception_handlers
argument_list|()
condition|)
return|return
literal|1
return|;
comment|/* If we have non-jumping insns which refer to labels, then we consider      the cfg not well structured.  */
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
name|FOR_BB_INSNS
argument_list|(
argument|b
argument_list|,
argument|insn
argument_list|)
block|{
comment|/* Check for labels referred by non-jump insns.  */
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
operator|!
operator|(
name|JUMP_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* If this function has a computed jump, then we consider the cfg 	   not well structured.  */
elseif|else
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Unreachable loops with more than one basic block are detected      during the DFS traversal in find_rgns.       Unreachable loops with a single block are detected here.  This      test is redundant with the one in find_rgns, but it's much      cheaper to go ahead and catch the trivial case here.  */
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|b
operator|->
name|preds
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|single_pred_p
argument_list|(
name|b
argument_list|)
operator|&&
name|single_pred
argument_list|(
name|b
argument_list|)
operator|==
name|b
operator|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* All the tests passed.  Consider the cfg well structured.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Extract list of edges from a bitmap containing EDGE_TO_BIT bits.  */
end_comment

begin_function
specifier|static
name|void
name|extract_edgelst
parameter_list|(
name|sbitmap
name|set
parameter_list|,
name|edgelst
modifier|*
name|el
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
comment|/* edgelst table space is reused in each call to extract_edgelst.  */
name|edgelst_last
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|first_member
operator|=
operator|&
name|edgelst_table
index|[
name|edgelst_last
index|]
expr_stmt|;
name|el
operator|->
name|nr_members
operator|=
literal|0
expr_stmt|;
comment|/* Iterate over each word in the bitset.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
block|{
name|edgelst_table
index|[
name|edgelst_last
operator|++
index|]
operator|=
name|rgn_edges
index|[
name|i
index|]
expr_stmt|;
name|el
operator|->
name|nr_members
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Functions for the construction of regions.  */
end_comment

begin_comment
comment|/* Print the regions, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_regions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rgn
decl_stmt|,
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;;   ------------ REGIONS ----------\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\trgn %d nr_blocks %d:\n"
argument_list|,
name|rgn
argument_list|,
name|rgn_table
index|[
name|rgn
index|]
operator|.
name|rgn_nr_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\tbb/block: "
argument_list|)
expr_stmt|;
comment|/* We don't have ebb_head initialized yet, so we can't use 	 BB_TO_BLOCK ().  */
name|current_blocks
operator|=
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|rgn_table
index|[
name|rgn
index|]
operator|.
name|rgn_nr_blocks
condition|;
name|bb
operator|++
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" %d/%d "
argument_list|,
name|bb
argument_list|,
name|rgn_bb_table
index|[
name|current_blocks
operator|+
name|bb
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a single block region for each basic block in the function.    This allows for using the same code for interblock and basic block    scheduling.  */
end_comment

begin_function
specifier|static
name|void
name|find_single_block_region
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|nr_regions
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rgn_bb_table
index|[
name|nr_regions
index|]
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|RGN_DONT_CALC_DEPS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RGN_HAS_REAL_EBB
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
literal|0
expr_stmt|;
name|nr_regions
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update number of blocks and the estimate for number of insns    in the region.  Return true if the region is "too large" for interblock    scheduling (compile time considerations).  */
end_comment

begin_function
specifier|static
name|bool
name|too_large
parameter_list|(
name|int
name|block
parameter_list|,
name|int
modifier|*
name|num_bbs
parameter_list|,
name|int
modifier|*
name|num_insns
parameter_list|)
block|{
operator|(
operator|*
name|num_bbs
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|num_insns
operator|)
operator|+=
operator|(
name|INSN_LUID
argument_list|(
name|BB_END
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|block
argument_list|)
argument_list|)
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|BB_HEAD
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|block
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|num_bbs
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_SCHED_REGION_BLOCKS
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|num_insns
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_SCHED_REGION_INSNS
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Update_loop_relations(blk, hdr): Check if the loop headed by max_hdr[blk]    is still an inner loop.  Put in max_hdr[blk] the header of the most inner    loop containing blk.  */
end_comment

begin_define
define|#
directive|define
name|UPDATE_LOOP_RELATIONS
parameter_list|(
name|blk
parameter_list|,
name|hdr
parameter_list|)
define|\
value|{						\   if (max_hdr[blk] == -1)			\     max_hdr[blk] = hdr;				\   else if (dfs_nr[max_hdr[blk]]> dfs_nr[hdr])	\     RESET_BIT (inner, hdr);			\   else if (dfs_nr[max_hdr[blk]]< dfs_nr[hdr])	\     {						\       RESET_BIT (inner,max_hdr[blk]);		\       max_hdr[blk] = hdr;			\     }						\ }
end_define

begin_comment
comment|/* Find regions for interblock scheduling.     A region for scheduling can be:       * A loop-free procedure, or       * A reducible inner loop, or       * A basic block not contained in any other region.     ?!? In theory we could build other regions based on extended basic    blocks or reverse extended basic blocks.  Is it worth the trouble?     Loop blocks that form a region are put into the region's block list    in topological order.     This procedure stores its results into the following global (ick) variables       * rgn_nr      * rgn_table      * rgn_bb_table      * block_to_bb      * containing region     We use dominator relationships to avoid making regions out of non-reducible    loops.     This procedure needs to be converted to work on pred/succ lists instead    of edge tables.  That would simplify it somewhat.  */
end_comment

begin_function
specifier|static
name|void
name|find_rgns
parameter_list|(
name|void
parameter_list|)
block|{
name|int
modifier|*
name|max_hdr
decl_stmt|,
modifier|*
name|dfs_nr
decl_stmt|,
modifier|*
name|degree
decl_stmt|;
name|char
name|no_loops
init|=
literal|1
decl_stmt|;
name|int
name|node
decl_stmt|,
name|child
decl_stmt|,
name|loop_head
decl_stmt|,
name|i
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|sp
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|;
name|edge_iterator
name|current_edge
decl_stmt|;
name|edge_iterator
modifier|*
name|stack
decl_stmt|;
name|int
name|num_bbs
decl_stmt|,
name|num_insns
decl_stmt|,
name|unreachable
decl_stmt|;
name|int
name|too_large_failure
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Note if a block is a natural loop header.  */
name|sbitmap
name|header
decl_stmt|;
comment|/* Note if a block is a natural inner loop header.  */
name|sbitmap
name|inner
decl_stmt|;
comment|/* Note if a block is in the block queue.  */
name|sbitmap
name|in_queue
decl_stmt|;
comment|/* Note if a block is in the block queue.  */
name|sbitmap
name|in_stack
decl_stmt|;
comment|/* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops      and a mapping from block to its loop header (if the block is contained      in a loop, else -1).       Store results in HEADER, INNER, and MAX_HDR respectively, these will      be used as inputs to the second traversal.       STACK, SP and DFS_NR are only used during the first traversal.  */
comment|/* Allocate and initialize variables for the first traversal.  */
name|max_hdr
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dfs_nr
operator|=
name|XCNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|edge_iterator
argument_list|,
name|n_edges
argument_list|)
expr_stmt|;
name|inner
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|header
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|in_queue
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|in_stack
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_stack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
condition|;
name|i
operator|++
control|)
name|max_hdr
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
define|#
directive|define
name|EDGE_PASSED
parameter_list|(
name|E
parameter_list|)
value|(ei_end_p ((E)) || ei_edge ((E))->aux)
define|#
directive|define
name|SET_EDGE_PASSED
parameter_list|(
name|E
parameter_list|)
value|(ei_edge ((E))->aux = ei_edge ((E)))
comment|/* DFS traversal to find inner loops in the cfg.  */
name|current_edge
operator|=
name|ei_start
argument_list|(
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|succs
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|EDGE_PASSED
argument_list|(
name|current_edge
argument_list|)
condition|)
block|{
comment|/* We have reached a leaf node or a node that was already 	     processed.  Pop edges off the stack until we find 	     an edge that has not yet been processed.  */
while|while
condition|(
name|sp
operator|>=
literal|0
operator|&&
name|EDGE_PASSED
argument_list|(
name|current_edge
argument_list|)
condition|)
block|{
comment|/* Pop entry off the stack.  */
name|current_edge
operator|=
name|stack
index|[
name|sp
operator|--
index|]
expr_stmt|;
name|node
operator|=
name|ei_edge
argument_list|(
name|current_edge
argument_list|)
operator|->
name|src
operator|->
name|index
expr_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|!=
name|ENTRY_BLOCK
argument_list|)
expr_stmt|;
name|child
operator|=
name|ei_edge
argument_list|(
name|current_edge
argument_list|)
operator|->
name|dest
operator|->
name|index
expr_stmt|;
name|gcc_assert
argument_list|(
name|child
operator|!=
name|EXIT_BLOCK
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|in_stack
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|child
index|]
operator|>=
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
condition|)
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|current_edge
argument_list|)
expr_stmt|;
block|}
comment|/* See if have finished the DFS tree traversal.  */
if|if
condition|(
name|sp
operator|<
literal|0
operator|&&
name|EDGE_PASSED
argument_list|(
name|current_edge
argument_list|)
condition|)
break|break;
comment|/* Nope, continue the traversal with the popped node.  */
continue|continue;
block|}
comment|/* Process a node.  */
name|node
operator|=
name|ei_edge
argument_list|(
name|current_edge
argument_list|)
operator|->
name|src
operator|->
name|index
expr_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|!=
name|ENTRY_BLOCK
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_stack
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|dfs_nr
index|[
name|node
index|]
operator|=
operator|++
name|count
expr_stmt|;
comment|/* We don't traverse to the exit block.  */
name|child
operator|=
name|ei_edge
argument_list|(
name|current_edge
argument_list|)
operator|->
name|dest
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|EXIT_BLOCK
condition|)
block|{
name|SET_EDGE_PASSED
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|current_edge
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the successor is in the stack, then we've found a loop. 	 Mark the loop, if it is not a natural loop, then it will 	 be rejected during the second traversal.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|child
argument_list|)
condition|)
block|{
name|no_loops
operator|=
literal|0
expr_stmt|;
name|SET_BIT
argument_list|(
name|header
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|SET_EDGE_PASSED
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|current_edge
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the child was already visited, then there is no need to visit 	 it again.  Just update the loop relationships and restart 	 with a new edge.  */
if|if
condition|(
name|dfs_nr
index|[
name|child
index|]
condition|)
block|{
if|if
condition|(
name|max_hdr
index|[
name|child
index|]
operator|>=
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
condition|)
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
expr_stmt|;
name|SET_EDGE_PASSED
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|current_edge
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Push an entry on the stack and continue DFS traversal.  */
name|stack
index|[
operator|++
name|sp
index|]
operator|=
name|current_edge
expr_stmt|;
name|SET_EDGE_PASSED
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|ei_start
argument_list|(
name|ei_edge
argument_list|(
name|current_edge
argument_list|)
operator|->
name|dest
operator|->
name|succs
argument_list|)
expr_stmt|;
block|}
comment|/* Reset ->aux field used by EDGE_PASSED.  */
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Another check for unreachable blocks.  The earlier test in      is_cfg_nonregular only finds unreachable blocks that do not      form a loop.       The DFS traversal will mark every block that is reachable from      the entry node by placing a nonzero value in dfs_nr.  Thus if      dfs_nr is zero for any block, then it must be unreachable.  */
name|unreachable
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|dfs_nr
index|[
name|bb
operator|->
name|index
index|]
operator|==
literal|0
condition|)
block|{
name|unreachable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Gross.  To avoid wasting memory, the second pass uses the dfs_nr array      to hold degree counts.  */
name|degree
operator|=
name|dfs_nr
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|degree
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
expr_stmt|;
comment|/* Do not perform region scheduling if there are any unreachable      blocks.  */
if|if
condition|(
operator|!
name|unreachable
condition|)
block|{
name|int
modifier|*
name|queue
decl_stmt|,
modifier|*
name|degree1
init|=
name|NULL
decl_stmt|;
comment|/* We use EXTENDED_RGN_HEADER as an addition to HEADER and put 	 there basic blocks, which are forced to be region heads. 	 This is done to try to assemble few smaller regions  	 from a too_large region.  */
name|sbitmap
name|extended_rgn_header
init|=
name|NULL
decl_stmt|;
name|bool
name|extend_regions_p
decl_stmt|;
if|if
condition|(
name|no_loops
condition|)
name|SET_BIT
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Second traversal:find reducible inner loops and topologically sort 	 block of each region.  */
name|queue
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|extend_regions_p
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|extend_regions_p
condition|)
block|{
name|degree1
operator|=
name|xmalloc
argument_list|(
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|extended_rgn_header
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|extended_rgn_header
argument_list|)
expr_stmt|;
block|}
comment|/* Find blocks which are inner loop headers.  We still have non-reducible 	 loops to consider at this point.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|header
argument_list|,
name|bb
operator|->
name|index
argument_list|)
operator|&&
name|TEST_BIT
argument_list|(
name|inner
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|jbb
decl_stmt|;
comment|/* Now check that the loop is reducible.  We do this separate 		 from finding inner loops so that we do not find a reducible 		 loop which contains an inner non-reducible loop.  		 A simple way to find reducible/natural loops is to verify 		 that each block in the loop is dominated by the loop 		 header.  		 If there exists a block that is not dominated by the loop 		 header, then the block is reachable from outside the loop 		 and thus the loop is not a natural loop.  */
name|FOR_EACH_BB
argument_list|(
argument|jbb
argument_list|)
block|{
comment|/* First identify blocks in the loop, except for the loop 		     entry block.  */
if|if
condition|(
name|bb
operator|->
name|index
operator|==
name|max_hdr
index|[
name|jbb
operator|->
name|index
index|]
operator|&&
name|bb
operator|!=
name|jbb
condition|)
block|{
comment|/* Now verify that the block is dominated by the loop 			 header.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|jbb
argument_list|,
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* If we exited the loop early, then I is the header of 		 a non-reducible loop and we should quit processing it 		 now.  */
if|if
condition|(
name|jbb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
comment|/* I is a header of an inner loop, or block 0 in a subroutine 		 with no loops at all.  */
name|head
operator|=
name|tail
operator|=
operator|-
literal|1
expr_stmt|;
name|too_large_failure
operator|=
literal|0
expr_stmt|;
name|loop_head
operator|=
name|max_hdr
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|extend_regions_p
condition|)
comment|/* We save degree in case when we meet a too_large region  		   and cancel it.  We need a correct degree later when                     calling extend_rgns.  */
name|memcpy
argument_list|(
name|degree1
argument_list|,
name|degree
argument_list|,
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrease degree of all I's successors for topological 		 ordering.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
operator|--
name|degree
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
expr_stmt|;
comment|/* Estimate # insns, and count # blocks in the region.  */
name|num_bbs
operator|=
literal|1
expr_stmt|;
name|num_insns
operator|=
operator|(
name|INSN_LUID
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Find all loop latches (blocks with back edges to the loop 		 header) or all the leaf blocks in the cfg has no loops.  		 Place those blocks into the queue.  */
if|if
condition|(
name|no_loops
condition|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|jbb
argument_list|)
comment|/* Leaf nodes have only a single successor which must 		       be EXIT_BLOCK.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|jbb
argument_list|)
operator|&&
name|single_succ
argument_list|(
name|jbb
argument_list|)
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|jbb
operator|->
name|index
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|jbb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|jbb
operator|->
name|index
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|edge
name|e
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
name|node
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|node
index|]
operator|==
name|loop_head
operator|&&
name|node
operator|!=
name|bb
operator|->
name|index
condition|)
block|{
comment|/* This is a loop latch.  */
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|node
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|node
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Now add all the blocks in the loop to the queue.  	     We know the loop is a natural loop; however the algorithm 	     above will not always mark certain blocks as being in the 	     loop.  Consider: 		node   children 		 a	  b,c 		 b	  c 		 c	  a,d 		 d	  b  	     The algorithm in the DFS traversal may not mark B& D as part 	     of the loop (i.e. they will not have max_hdr set to A).  	     We know they can not be loop latches (else they would have 	     had max_hdr set since they'd have a backedge to a dominator 	     block).  So we don't need them on the initial queue.  	     We know they are part of the loop because they are dominated 	     by the loop header and can be reached by a backwards walk of 	     the edges starting with nodes on the initial queue.  	     It is safe and desirable to include those nodes in the 	     loop/scheduling region.  To do so we would need to decrease 	     the degree of a node if it is the target of a backedge 	     within the loop itself as the node is placed in the queue.  	     We do not do this because I'm not sure that the actual 	     scheduling code will properly handle this case. ?!? */
while|while
condition|(
name|head
operator|<
name|tail
operator|&&
operator|!
name|too_large_failure
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|child
operator|=
name|queue
index|[
operator|++
name|head
index|]
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (child)->preds
argument_list|)
block|{
name|node
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
comment|/* See discussion above about nodes not marked as in 			 this loop during the initial DFS traversal.  */
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|max_hdr
index|[
name|node
index|]
operator|!=
name|loop_head
condition|)
block|{
name|tail
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
operator|&&
name|node
operator|!=
name|bb
operator|->
name|index
condition|)
block|{
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|node
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|node
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|tail
operator|>=
literal|0
operator|&&
operator|!
name|too_large_failure
condition|)
block|{
comment|/* Place the loop header into list of region blocks.  */
name|degree
index|[
name|bb
operator|->
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|num_bbs
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
operator|++
expr_stmt|;
name|RGN_DONT_CALC_DEPS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RGN_HAS_REAL_EBB
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Remove blocks from queue[] when their in degree 		     becomes zero.  Repeat until no blocks are left on the 		     list.  This produces a topological list of blocks in 		     the region.  */
while|while
condition|(
name|tail
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|head
operator|<
literal|0
condition|)
name|head
operator|=
name|tail
expr_stmt|;
name|child
operator|=
name|queue
index|[
name|head
index|]
expr_stmt|;
if|if
condition|(
name|degree
index|[
name|child
index|]
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|degree
index|[
name|child
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
operator|++
index|]
operator|=
name|child
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|child
argument_list|)
operator|=
operator|++
name|count
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|child
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|queue
index|[
name|head
index|]
operator|=
name|queue
index|[
name|tail
operator|--
index|]
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (child)->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
operator|--
name|degree
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
expr_stmt|;
block|}
else|else
operator|--
name|head
expr_stmt|;
block|}
operator|++
name|nr_regions
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|extend_regions_p
condition|)
block|{
comment|/* Restore DEGREE.  */
name|int
modifier|*
name|t
init|=
name|degree
decl_stmt|;
name|degree
operator|=
name|degree1
expr_stmt|;
name|degree1
operator|=
name|t
expr_stmt|;
comment|/* And force successors of BB to be region heads. 		     This may provide several smaller regions instead 		     of one too_large region.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|SET_BIT
argument_list|(
name|extended_rgn_header
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|extend_regions_p
condition|)
block|{
name|free
argument_list|(
name|degree1
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|header
argument_list|,
name|header
argument_list|,
name|extended_rgn_header
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|extended_rgn_header
argument_list|)
expr_stmt|;
name|extend_rgns
argument_list|(
name|degree
argument_list|,
operator|&
name|idx
argument_list|,
name|header
argument_list|,
name|max_hdr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Any block that did not end up in a region is placed into a region      by itself.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|degree
index|[
name|bb
operator|->
name|index
index|]
operator|>=
literal|0
condition|)
block|{
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
operator|++
expr_stmt|;
name|RGN_DONT_CALC_DEPS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RGN_HAS_REAL_EBB
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|nr_regions
operator|++
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|max_hdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|degree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|in_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|gather_region_statistics
parameter_list|(
name|int
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_region_statistics
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Calculate the histogram that shows the number of regions having the     given number of basic blocks, and store it in the RSP array.  Return     the size of this array.  */
end_comment

begin_function
specifier|static
name|int
name|gather_region_statistics
parameter_list|(
name|int
modifier|*
modifier|*
name|rsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
modifier|*
name|a
init|=
literal|0
decl_stmt|,
name|a_sz
init|=
literal|0
decl_stmt|;
comment|/* a[i] is the number of regions that have (i + 1) basic blocks.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_regions
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nr_blocks
init|=
name|RGN_NR_BLOCKS
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|nr_blocks
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_blocks
operator|>
name|a_sz
condition|)
block|{
name|a
operator|=
name|xrealloc
argument_list|(
name|a
argument_list|,
name|nr_blocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
do|do
name|a
index|[
name|a_sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
do|while
condition|(
name|a_sz
operator|!=
name|nr_blocks
condition|)
do|;
block|}
name|a
index|[
name|nr_blocks
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
operator|*
name|rsp
operator|=
name|a
expr_stmt|;
return|return
name|a_sz
return|;
block|}
end_function

begin_comment
comment|/* Print regions statistics.  S1 and S2 denote the data before and after     calling extend_rgns, respectively.  */
end_comment

begin_function
specifier|static
name|void
name|print_region_statistics
parameter_list|(
name|int
modifier|*
name|s1
parameter_list|,
name|int
name|s1_sz
parameter_list|,
name|int
modifier|*
name|s2
parameter_list|,
name|int
name|s2_sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We iterate until s2_sz because extend_rgns does not decrease       the maximal region size.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|s2_sz
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|n2
operator|=
name|s2
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|n2
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|>=
name|s1_sz
condition|)
name|n1
operator|=
literal|0
expr_stmt|;
else|else
name|n1
operator|=
name|s1
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; Region extension statistics: size %d: "
expr|\
literal|"was %d + %d more\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|n1
argument_list|,
name|n2
operator|-
name|n1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extend regions.    DEGREE - Array of incoming edge count, considering only    the edges, that don't have their sources in formed regions yet.    IDXP - pointer to the next available index in rgn_bb_table.    HEADER - set of all region heads.    LOOP_HDR - mapping from block to the containing loop    (two blocks can reside within one region if they have    the same loop header).  */
end_comment

begin_function
specifier|static
name|void
name|extend_rgns
parameter_list|(
name|int
modifier|*
name|degree
parameter_list|,
name|int
modifier|*
name|idxp
parameter_list|,
name|sbitmap
name|header
parameter_list|,
name|int
modifier|*
name|loop_hdr
parameter_list|)
block|{
name|int
modifier|*
name|order
decl_stmt|,
name|i
decl_stmt|,
name|rescan
init|=
literal|0
decl_stmt|,
name|idx
init|=
operator|*
name|idxp
decl_stmt|,
name|iter
init|=
literal|0
decl_stmt|,
name|max_iter
decl_stmt|,
modifier|*
name|max_hdr
decl_stmt|;
name|int
name|nblocks
init|=
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
decl_stmt|;
name|max_iter
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS
argument_list|)
expr_stmt|;
name|max_hdr
operator|=
name|xmalloc
argument_list|(
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|max_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|order
operator|=
name|xmalloc
argument_list|(
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|order
argument_list|)
argument_list|)
expr_stmt|;
name|post_order_compute
argument_list|(
name|order
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nblocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|bbn
init|=
name|order
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|degree
index|[
name|bbn
index|]
operator|>=
literal|0
condition|)
block|{
name|max_hdr
index|[
name|bbn
index|]
operator|=
name|bbn
expr_stmt|;
name|rescan
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* This block already was processed in find_rgns.  */
name|max_hdr
index|[
name|bbn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* The idea is to topologically walk through CFG in top-down order.      During the traversal, if all the predecessors of a node are      marked to be in the same region (they all have the same max_hdr),      then current node is also marked to be a part of that region.       Otherwise the node starts its own region.      CFG should be traversed until no further changes are made.  On each       iteration the set of the region heads is extended (the set of those       blocks that have max_hdr[bbi] == bbi).  This set is upper bounded by the       set of all basic blocks, thus the algorithm is guaranteed to terminate.  */
while|while
condition|(
name|rescan
operator|&&
name|iter
operator|<
name|max_iter
condition|)
block|{
name|rescan
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nblocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|bbn
init|=
name|order
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|bbn
index|]
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|header
argument_list|,
name|bbn
argument_list|)
condition|)
block|{
name|int
name|hdr
init|=
operator|-
literal|1
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (bbn)->preds
argument_list|)
block|{
name|int
name|predn
init|=
name|e
operator|->
name|src
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|predn
operator|!=
name|ENTRY_BLOCK
comment|/* If pred wasn't processed in find_rgns.  */
operator|&&
name|max_hdr
index|[
name|predn
index|]
operator|!=
operator|-
literal|1
comment|/* And pred and bb reside in the same loop. 			 (Or out of any loop).  */
operator|&&
name|loop_hdr
index|[
name|bbn
index|]
operator|==
name|loop_hdr
index|[
name|predn
index|]
condition|)
block|{
if|if
condition|(
name|hdr
operator|==
operator|-
literal|1
condition|)
comment|/* Then bb extends the containing region of pred.  */
name|hdr
operator|=
name|max_hdr
index|[
name|predn
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|hdr
operator|!=
name|max_hdr
index|[
name|predn
index|]
condition|)
comment|/* Too bad, there are at least two predecessors 			   that reside in different regions.  Thus, BB should 			   begin its own region.  */
block|{
name|hdr
operator|=
name|bbn
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* BB starts its own region.  */
block|{
name|hdr
operator|=
name|bbn
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hdr
operator|==
name|bbn
condition|)
block|{
comment|/* If BB start its own region, 		     update set of headers with BB.  */
name|SET_BIT
argument_list|(
name|header
argument_list|,
name|bbn
argument_list|)
expr_stmt|;
name|rescan
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
name|hdr
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|max_hdr
index|[
name|bbn
index|]
operator|=
name|hdr
expr_stmt|;
block|}
block|}
name|iter
operator|++
expr_stmt|;
block|}
comment|/* Statistics were gathered on the SPEC2000 package of tests with      mainline weekly snapshot gcc-4.1-20051015 on ia64.            Statistics for SPECint:      1 iteration : 1751 cases (38.7%)      2 iterations: 2770 cases (61.3%)      Blocks wrapped in regions by find_rgns without extension: 18295 blocks      Blocks wrapped in regions by 2 iterations in extend_rgns: 23821 blocks      (We don't count single block regions here).            Statistics for SPECfp:      1 iteration : 621 cases (35.9%)      2 iterations: 1110 cases (64.1%)      Blocks wrapped in regions by find_rgns without extension: 6476 blocks      Blocks wrapped in regions by 2 iterations in extend_rgns: 11155 blocks      (We don't count single block regions here).       By default we do at most 2 iterations.      This can be overridden with max-sched-extend-regions-iters parameter:      0 - disable region extension,      N> 0 - do at most N iterations.  */
if|if
condition|(
name|sched_verbose
operator|&&
name|iter
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; Region extension iterations: %d%s\n"
argument_list|,
name|iter
argument_list|,
name|rescan
condition|?
literal|"... failed"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rescan
operator|&&
name|iter
operator|!=
literal|0
condition|)
block|{
name|int
modifier|*
name|s1
init|=
name|NULL
decl_stmt|,
name|s1_sz
init|=
literal|0
decl_stmt|;
comment|/* Save the old statistics for later printout.  */
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
name|s1_sz
operator|=
name|gather_region_statistics
argument_list|(
operator|&
name|s1
argument_list|)
expr_stmt|;
comment|/* We have succeeded.  Now assemble the regions.  */
for|for
control|(
name|i
operator|=
name|nblocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|bbn
init|=
name|order
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|bbn
index|]
operator|==
name|bbn
condition|)
comment|/* BBN is a region head.  */
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|num_bbs
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|num_insns
init|=
literal|0
decl_stmt|,
name|large
decl_stmt|;
name|large
operator|=
name|too_large
argument_list|(
name|bbn
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
expr_stmt|;
name|degree
index|[
name|bbn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|bbn
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
operator|++
expr_stmt|;
name|RGN_DONT_CALC_DEPS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RGN_HAS_REAL_EBB
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|bbn
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|bbn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (bbn)->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|degree
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|large
condition|)
comment|/* Here we check whether the region is too_large.  */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|succn
init|=
name|order
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|succn
index|]
operator|==
name|bbn
condition|)
block|{
if|if
condition|(
operator|(
name|large
operator|=
name|too_large
argument_list|(
name|succn
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|large
condition|)
comment|/* If the region is too_large, then wrap every block of 		   the region into single block region. 		   Here we wrap region head only.  Other blocks are 		   processed in the below cycle.  */
block|{
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nr_regions
operator|++
expr_stmt|;
block|}
name|num_bbs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|succn
init|=
name|order
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|succn
index|]
operator|==
name|bbn
condition|)
comment|/* This cycle iterates over all basic blocks, that  		       are supposed to be in the region with head BBN, 		       and wraps them into that region (or in single 		       block region).  */
block|{
name|gcc_assert
argument_list|(
name|degree
index|[
name|succn
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|degree
index|[
name|succn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|succn
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|succn
argument_list|)
operator|=
name|large
condition|?
literal|0
else|:
name|num_bbs
operator|++
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|succn
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
if|if
condition|(
name|large
condition|)
comment|/* Wrap SUCCN into single block region.  */
block|{
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_DONT_CALC_DEPS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RGN_HAS_REAL_EBB
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|nr_regions
operator|++
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (succn)->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|degree
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|large
condition|)
block|{
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|num_bbs
expr_stmt|;
name|nr_regions
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
block|{
name|int
modifier|*
name|s2
decl_stmt|,
name|s2_sz
decl_stmt|;
comment|/* Get the new statistics and print the comparison with the               one before calling this function.  */
name|s2_sz
operator|=
name|gather_region_statistics
argument_list|(
operator|&
name|s2
argument_list|)
expr_stmt|;
name|print_region_statistics
argument_list|(
name|s1
argument_list|,
name|s1_sz
argument_list|,
name|s2
argument_list|,
name|s2_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|max_hdr
argument_list|)
expr_stmt|;
operator|*
name|idxp
operator|=
name|idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for regions scheduling information.  */
end_comment

begin_comment
comment|/* Compute dominators, probability, and potential-split-edges of bb.    Assume that these values were already computed for bb's predecessors.  */
end_comment

begin_function
specifier|static
name|void
name|compute_dom_prob_ps
parameter_list|(
name|int
name|bb
parameter_list|)
block|{
name|edge_iterator
name|in_ei
decl_stmt|;
name|edge
name|in_edge
decl_stmt|;
comment|/* We shouldn't have any real ebbs yet.  */
name|gcc_assert
argument_list|(
name|ebb_head
index|[
name|bb
index|]
operator|==
name|bb
operator|+
name|current_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_RGN_ENTRY
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prob
index|[
name|bb
index|]
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
return|return;
block|}
name|prob
index|[
name|bb
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Initialize dom[bb] to '111..1'.  */
name|sbitmap_ones
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|in_edge
argument_list|,
argument|in_ei
argument_list|,
argument|BASIC_BLOCK (BB_TO_BLOCK (bb))->preds
argument_list|)
block|{
name|int
name|pred_bb
decl_stmt|;
name|edge
name|out_edge
decl_stmt|;
name|edge_iterator
name|out_ei
decl_stmt|;
if|if
condition|(
name|in_edge
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
name|pred_bb
operator|=
name|BLOCK_TO_BB
argument_list|(
name|in_edge
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
name|dom
index|[
name|bb
index|]
argument_list|,
name|dom
index|[
name|pred_bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|pred_bb
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|in_edge
argument_list|)
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|pot_split
index|[
name|pred_bb
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|out_edge
argument_list|,
argument|out_ei
argument_list|,
argument|in_edge->src->succs
argument_list|)
name|SET_BIT
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|out_edge
argument_list|)
argument_list|)
expr_stmt|;
name|prob
index|[
name|bb
index|]
operator|+=
operator|(
operator|(
name|prob
index|[
name|pred_bb
index|]
operator|*
name|in_edge
operator|->
name|probability
operator|)
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
block|}
name|SET_BIT
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;  bb_prob(%d, %d) = %3d\n"
argument_list|,
name|bb
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|(
literal|100
operator|*
name|prob
index|[
name|bb
index|]
operator|)
operator|/
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for target info.  */
end_comment

begin_comment
comment|/* Compute in BL the list of split-edges of bb_src relatively to bb_trg.    Note that bb_trg dominates bb_src.  */
end_comment

begin_function
specifier|static
name|void
name|split_edges
parameter_list|(
name|int
name|bb_src
parameter_list|,
name|int
name|bb_trg
parameter_list|,
name|edgelst
modifier|*
name|bl
parameter_list|)
block|{
name|sbitmap
name|src
init|=
name|sbitmap_alloc
argument_list|(
name|pot_split
index|[
name|bb_src
index|]
operator|->
name|n_bits
argument_list|)
decl_stmt|;
name|sbitmap_copy
argument_list|(
name|src
argument_list|,
name|pot_split
index|[
name|bb_src
index|]
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|src
argument_list|,
name|src
argument_list|,
name|pot_split
index|[
name|bb_trg
index|]
argument_list|)
expr_stmt|;
name|extract_edgelst
argument_list|(
name|src
argument_list|,
name|bl
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the valid candidate-source-blocks for the target block TRG, compute    their probability, and check if they are speculative or not.    For speculative sources, compute their update-blocks and split-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|compute_trg_info
parameter_list|(
name|int
name|trg
parameter_list|)
block|{
name|candidate
modifier|*
name|sp
decl_stmt|;
name|edgelst
name|el
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|update_idx
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Define some of the fields for the target bb as well.  */
name|sp
operator|=
name|candidate_table
operator|+
name|trg
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|src_prob
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|trg
operator|+
literal|1
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|candidate_table
operator|+
name|i
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
name|IS_DOMINATED
argument_list|(
name|i
argument_list|,
name|trg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|int
name|tf
init|=
name|prob
index|[
name|trg
index|]
decl_stmt|,
name|cf
init|=
name|prob
index|[
name|i
index|]
decl_stmt|;
comment|/* In CFGs with low probability edges TF can possibly be zero.  */
name|sp
operator|->
name|src_prob
operator|=
operator|(
name|tf
condition|?
operator|(
operator|(
name|cf
operator|*
name|REG_BR_PROB_BASE
operator|)
operator|/
name|tf
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
operator|(
name|sp
operator|->
name|src_prob
operator|>=
name|min_spec_prob
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|split_edges
argument_list|(
name|i
argument_list|,
name|trg
argument_list|,
operator|&
name|el
argument_list|)
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
operator|(
name|el
operator|.
name|nr_members
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|is_speculative
operator|&&
operator|!
name|flag_schedule_speculative
condition|)
name|sp
operator|->
name|is_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
comment|/* Compute split blocks and store them in bblst_table. 	     The TO block of every split edge is a split block.  */
name|sp
operator|->
name|split_bbs
operator|.
name|first_member
operator|=
operator|&
name|bblst_table
index|[
name|bblst_last
index|]
expr_stmt|;
name|sp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|=
name|el
operator|.
name|nr_members
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|el
operator|.
name|nr_members
condition|;
name|bblst_last
operator|++
operator|,
name|j
operator|++
control|)
name|bblst_table
index|[
name|bblst_last
index|]
operator|=
name|el
operator|.
name|first_member
index|[
name|j
index|]
operator|->
name|dest
expr_stmt|;
name|sp
operator|->
name|update_bbs
operator|.
name|first_member
operator|=
operator|&
name|bblst_table
index|[
name|bblst_last
index|]
expr_stmt|;
comment|/* Compute update blocks and store them in bblst_table. 	     For every split edge, look at the FROM block, and check 	     all out edges.  For each out edge that is not a split edge, 	     add the TO block to the update block list.  This list can end 	     up with a lot of duplicates.  We need to weed them out to avoid 	     overrunning the end of the bblst_table.  */
name|update_idx
operator|=
literal|0
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|el
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|block
operator|=
name|el
operator|.
name|first_member
index|[
name|j
index|]
operator|->
name|src
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->succs
argument_list|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|el
operator|.
name|nr_members
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|e
operator|==
name|el
operator|.
name|first_member
index|[
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|el
operator|.
name|nr_members
condition|)
block|{
name|bblst_table
index|[
name|bblst_last
operator|++
index|]
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|update_idx
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|sp
operator|->
name|update_bbs
operator|.
name|nr_members
operator|=
name|update_idx
expr_stmt|;
comment|/* Make sure we didn't overrun the end of bblst_table.  */
name|gcc_assert
argument_list|(
name|bblst_last
operator|<=
name|bblst_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|=
name|sp
operator|->
name|update_bbs
operator|.
name|nr_members
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|src_prob
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print candidates info, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_candidate
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|!
name|candidate_table
index|[
name|i
index|]
operator|.
name|is_valid
condition|)
return|return;
if|if
condition|(
name|candidate_table
index|[
name|i
index|]
operator|.
name|is_speculative
condition|)
block|{
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"src b %d bb %d speculative \n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"split path: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|candidate_table
index|[
name|i
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|i
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|j
index|]
operator|->
name|index
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" %d "
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"update path: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|candidate_table
index|[
name|i
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|i
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|j
index|]
operator|->
name|index
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" %d "
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" src %d equivalent\n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print candidates info, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_candidates
parameter_list|(
name|int
name|trg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"----------- candidate table: target: b=%d bb=%d ---\n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|trg
argument_list|)
argument_list|,
name|trg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|trg
operator|+
literal|1
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
name|debug_candidate
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for speculative scheduling.  */
end_comment

begin_comment
comment|/* Return 0 if x is a set of a register alive in the beginning of one    of the split-blocks of src, otherwise return 1.  */
end_comment

begin_function
specifier|static
name|int
name|check_live_1
parameter_list|(
name|int
name|src
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|check_live_1
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return
literal|1
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Global registers are assumed live.  */
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Check for hard registers.  */
name|int
name|j
init|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
comment|/* We can have split blocks, that were recently generated. 		     such blocks are always outside current region.  */
name|gcc_assert
argument_list|(
name|glat_start
index|[
name|b
operator|->
name|index
index|]
operator|||
name|CONTAINING_RGN
argument_list|(
name|b
operator|->
name|index
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glat_start
index|[
name|b
operator|->
name|index
index|]
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|glat_start
index|[
name|b
operator|->
name|index
index|]
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Check for pseudo registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|glat_start
index|[
name|b
operator|->
name|index
index|]
operator|||
name|CONTAINING_RGN
argument_list|(
name|b
operator|->
name|index
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glat_start
index|[
name|b
operator|->
name|index
index|]
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|glat_start
index|[
name|b
operator|->
name|index
index|]
argument_list|,
name|regno
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If x is a set of a register R, mark that R is alive in the beginning    of every update-block of src.  */
end_comment

begin_function
specifier|static
name|void
name|update_live_1
parameter_list|(
name|int
name|src
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
comment|/* Global registers are always live, so the code below does not apply      to them.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|glat_start
index|[
name|b
operator|->
name|index
index|]
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|glat_start
index|[
name|b
operator|->
name|index
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if insn can be speculatively moved from block src to trg,    otherwise return 0.  Called before first insertion of insn to    ready-list or before the scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|check_live
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|src
parameter_list|)
block|{
comment|/* Find the registers set by instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|check_live_1
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
operator|!
name|check_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Update the live registers info after insn was moved speculatively from    block src to trg.  */
end_comment

begin_function
specifier|static
name|void
name|update_live
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|src
parameter_list|)
block|{
comment|/* Find the registers set by instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if block bb_to is equal to, or reachable from block bb_from.  */
end_comment

begin_define
define|#
directive|define
name|IS_REACHABLE
parameter_list|(
name|bb_from
parameter_list|,
name|bb_to
parameter_list|)
define|\
value|(bb_from == bb_to							\    || IS_RGN_ENTRY (bb_from)						\    || (TEST_BIT (ancestor_edges[bb_to],					\ 	 EDGE_TO_BIT (single_pred_edge (BASIC_BLOCK (BB_TO_BLOCK (bb_from)))))))
end_define

begin_comment
comment|/* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */
end_comment

begin_function
specifier|static
name|void
name|set_spec_fed
parameter_list|(
name|rtx
name|load_insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|load_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|==
name|VOIDmode
condition|)
name|FED_BY_SPEC_LOAD
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_spec_fed */
end_comment

begin_comment
comment|/* On the path from the insn to load_insn_bb, find a conditional branch depending on insn, that guards the speculative load.  */
end_comment

begin_function
specifier|static
name|int
name|find_conditional_protection
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|load_insn_bb
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Iterate through DEF-USE forward dependences.  */
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|CONTAINING_RGN
argument_list|(
name|BLOCK_NUM
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|load_insn_bb
argument_list|)
argument_list|)
operator|)
operator|&&
name|IS_REACHABLE
argument_list|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|,
name|load_insn_bb
argument_list|)
operator|&&
name|load_insn_bb
operator|!=
name|INSN_BB
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|JUMP_P
argument_list|(
name|next
argument_list|)
operator|||
name|find_conditional_protection
argument_list|(
name|next
argument_list|,
name|load_insn_bb
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* find_conditional_protection */
end_comment

begin_comment
comment|/* Returns 1 if the same insn1 that participates in the computation    of load_insn's address is feeding a conditional branch that is    guarding on load_insn. This is true if we find a the two DEF-USE    chains:    insn1 -> ... -> conditional-branch    insn1 -> ... -> load_insn,    and if a flow path exist:    insn1 -> ... -> conditional-branch -> ... -> load_insn,    and if insn1 is on the path    region-entry -> ... -> bb_trg -> ... load_insn.     Locate insn1 by climbing on LOG_LINKS from load_insn.    Locate the branch by following INSN_DEPEND from insn1.  */
end_comment

begin_function
specifier|static
name|int
name|is_conditionally_protected
parameter_list|(
name|rtx
name|load_insn
parameter_list|,
name|int
name|bb_src
parameter_list|,
name|int
name|bb_trg
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Must be a DEF-USE dependence upon non-branch.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|!=
name|VOIDmode
operator|||
name|JUMP_P
argument_list|(
name|insn1
argument_list|)
condition|)
continue|continue;
comment|/* Must exist a path: region-entry -> ... -> bb_trg -> ... load_insn.  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|==
name|bb_src
operator|||
operator|(
name|CONTAINING_RGN
argument_list|(
name|BLOCK_NUM
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb_src
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_REACHABLE
argument_list|(
name|bb_trg
argument_list|,
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|&&
operator|!
name|IS_REACHABLE
argument_list|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
argument_list|,
name|bb_trg
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Now search for the conditional-branch.  */
if|if
condition|(
name|find_conditional_protection
argument_list|(
name|insn1
argument_list|,
name|bb_src
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Recursive step: search another insn1, "above" current insn1.  */
return|return
name|is_conditionally_protected
argument_list|(
name|insn1
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
return|;
block|}
comment|/* The chain does not exist.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_conditionally_protected */
end_comment

begin_comment
comment|/* Returns 1 if a clue for "similar load" 'insn2' is found, and hence    load_insn can move speculatively from bb_src to bb_trg.  All the    following must hold:     (1) both loads have 1 base register (PFREE_CANDIDATEs).    (2) load_insn and load1 have a def-use dependence upon    the same insn 'insn1'.    (3) either load2 is in bb_trg, or:    - there's only one split-block, and    - load1 is on the escape path, and     From all these we can conclude that the two loads access memory    addresses that differ at most by a constant, and hence if moving    load_insn would cause an exception, it would have been caused by    load2 anyhow.  */
end_comment

begin_function
specifier|static
name|int
name|is_pfree
parameter_list|(
name|rtx
name|load_insn
parameter_list|,
name|int
name|bb_src
parameter_list|,
name|int
name|bb_trg
parameter_list|)
block|{
name|rtx
name|back_link
decl_stmt|;
name|candidate
modifier|*
name|candp
init|=
name|candidate_table
operator|+
name|bb_src
decl_stmt|;
if|if
condition|(
name|candp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|!=
literal|1
condition|)
comment|/* Must have exactly one escape block.  */
return|return
literal|0
return|;
for|for
control|(
name|back_link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|back_link
condition|;
name|back_link
operator|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|back_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* Found a DEF-USE dependence (insn1, load_insn).  */
name|rtx
name|fore_link
decl_stmt|;
for|for
control|(
name|fore_link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn1
argument_list|)
init|;
name|fore_link
condition|;
name|fore_link
operator|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn2
init|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|fore_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* Found a DEF-USE dependence (insn1, insn2).  */
if|if
condition|(
name|haifa_classify_insn
argument_list|(
name|insn2
argument_list|)
operator|!=
name|PFREE_CANDIDATE
condition|)
comment|/* insn2 not guaranteed to be a 1 base reg load.  */
continue|continue;
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
operator|==
name|bb_trg
condition|)
comment|/* insn2 is the similar load, in the target block.  */
return|return
literal|1
return|;
if|if
condition|(
operator|*
operator|(
name|candp
operator|->
name|split_bbs
operator|.
name|first_member
operator|)
operator|==
name|BLOCK_FOR_INSN
argument_list|(
name|insn2
argument_list|)
condition|)
comment|/* insn2 is a similar load, in a split-block.  */
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
comment|/* Couldn't find a similar load.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_pfree */
end_comment

begin_comment
comment|/* Return 1 if load_insn is prisky (i.e. if load_insn is fed by    a load moved speculatively, or if load_insn is protected by    a compare on load_insn's address).  */
end_comment

begin_function
specifier|static
name|int
name|is_prisky
parameter_list|(
name|rtx
name|load_insn
parameter_list|,
name|int
name|bb_src
parameter_list|,
name|int
name|bb_trg
parameter_list|)
block|{
if|if
condition|(
name|FED_BY_SPEC_LOAD
argument_list|(
name|load_insn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
operator|==
name|NULL
condition|)
comment|/* Dependence may 'hide' out of the region.  */
return|return
literal|1
return|;
if|if
condition|(
name|is_conditionally_protected
argument_list|(
name|load_insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insn is a candidate to be moved speculatively from bb_src to bb_trg.    Return 1 if insn is exception-free (and the motion is valid)    and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|is_exception_free
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|bb_src
parameter_list|,
name|int
name|bb_trg
parameter_list|)
block|{
name|int
name|insn_class
init|=
name|haifa_classify_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Handle non-load insns.  */
switch|switch
condition|(
name|insn_class
condition|)
block|{
case|case
name|TRAP_FREE
case|:
return|return
literal|1
return|;
case|case
name|TRAP_RISKY
case|:
return|return
literal|0
return|;
default|default:
empty_stmt|;
block|}
comment|/* Handle loads.  */
if|if
condition|(
operator|!
name|flag_schedule_speculative_load
condition|)
return|return
literal|0
return|;
name|IS_LOAD_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|insn_class
condition|)
block|{
case|case
name|IFREE
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|IRISKY
case|:
return|return
literal|0
return|;
case|case
name|PFREE_CANDIDATE
case|:
if|if
condition|(
name|is_pfree
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Don't 'break' here: PFREE-candidate is also PRISKY-candidate.  */
case|case
name|PRISKY_CANDIDATE
case|:
if|if
condition|(
operator|!
name|flag_schedule_speculative_load_dangerous
operator|||
name|is_prisky
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|flag_schedule_speculative_load_dangerous
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The number of insns from the current block scheduled so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_target_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of insns from the current block to be scheduled in total.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of insns from the entire region scheduled so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implementations of the sched_info functions for region scheduling.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_schedule_ready_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|begin_schedule_ready
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ds_t
name|new_ready
parameter_list|(
name|rtx
parameter_list|,
name|ds_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|schedule_more_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rgn_print_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rgn_rank
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|rtx
parameter_list|,
name|regset
parameter_list|,
name|regset
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for speculative scheduling.  */
end_comment

begin_function_decl
specifier|static
name|void
name|add_remove_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_regions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_block1
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_recovery_cfg
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|advance_target_bb
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_dead_notes1
parameter_list|(
name|int
parameter_list|,
name|sbitmap
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function_decl
specifier|static
name|int
name|region_head_or_leaf_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return nonzero if there are more insns that should be scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_more_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|sched_target_n_insns
operator|<
name|target_n_insns
return|;
block|}
end_function

begin_comment
comment|/* Add all insns that are initially ready to the ready list READY.  Called    once before scheduling a set of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|int
name|bb_src
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|target_n_insns
operator|=
literal|0
expr_stmt|;
name|sched_target_n_insns
operator|=
literal|0
expr_stmt|;
name|sched_n_insns
operator|=
literal|0
expr_stmt|;
comment|/* Print debugging information.  */
if|if
condition|(
name|sched_verbose
operator|>=
literal|5
condition|)
name|debug_dependencies
argument_list|()
expr_stmt|;
comment|/* Prepare current target block info.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|candidate_table
operator|=
name|XNEWVEC
argument_list|(
name|candidate
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
name|bblst_last
operator|=
literal|0
expr_stmt|;
comment|/* bblst_table holds split blocks and update blocks for each block after 	 the current one in the region.  split blocks and update blocks are 	 the TO blocks of region edges, so there can be at most rgn_nr_edges 	 of them.  */
name|bblst_size
operator|=
operator|(
name|current_nr_blocks
operator|-
name|target_bb
operator|)
operator|*
name|rgn_nr_edges
expr_stmt|;
name|bblst_table
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|bblst_size
argument_list|)
expr_stmt|;
name|edgelst_last
operator|=
literal|0
expr_stmt|;
name|edgelst_table
operator|=
name|XNEWVEC
argument_list|(
name|edge
argument_list|,
name|rgn_nr_edges
argument_list|)
expr_stmt|;
name|compute_trg_info
argument_list|(
name|target_bb
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize ready list with all 'ready' insns in target block.      Count number of insns in the target block being scheduled.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|try_ready
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|target_n_insns
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BEGIN_CONTROL
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add to ready list all 'ready' insns in valid source blocks.      For speculative insns, check-live, exception-free, and      issue-delay.  */
for|for
control|(
name|bb_src
operator|=
name|target_bb
operator|+
literal|1
init|;
name|bb_src
operator|<
name|current_nr_blocks
condition|;
name|bb_src
operator|++
control|)
if|if
condition|(
name|IS_VALID
argument_list|(
name|bb_src
argument_list|)
condition|)
block|{
name|rtx
name|src_head
decl_stmt|;
name|rtx
name|src_next_tail
decl_stmt|;
name|rtx
name|tail
decl_stmt|,
name|head
decl_stmt|;
name|get_ebb_head_tail
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb_src
argument_list|)
argument_list|,
name|EBB_LAST_BB
argument_list|(
name|bb_src
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|src_next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|src_head
operator|=
name|head
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|src_head
init|;
name|insn
operator|!=
name|src_next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|try_ready
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after taking INSN from the ready list.  Returns nonzero if this    insn can be scheduled, nonzero if we should silently discard it.  */
end_comment

begin_function
specifier|static
name|int
name|can_schedule_ready_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* An interblock motion?  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
operator|&&
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|check_live
argument_list|(
name|insn
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Updates counter and other information.  Split from can_schedule_ready_p ()    because when we schedule insn speculatively then insn passed to    can_schedule_ready_p () differs from the one passed to    begin_schedule_ready ().  */
end_comment

begin_function
specifier|static
name|void
name|begin_schedule_ready
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|last
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* An interblock motion?  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
block|{
if|if
condition|(
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|check_live
argument_list|(
name|insn
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|update_live
argument_list|(
name|insn
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For speculative load, mark insns fed by it.  */
if|if
condition|(
name|IS_LOAD_INSN
argument_list|(
name|insn
argument_list|)
operator|||
name|FED_BY_SPEC_LOAD
argument_list|(
name|insn
argument_list|)
condition|)
name|set_spec_fed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|nr_spec
operator|++
expr_stmt|;
block|}
name|nr_inter
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* In block motion.  */
name|sched_target_n_insns
operator|++
expr_stmt|;
block|}
name|sched_n_insns
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after INSN has all its hard dependencies resolved and the speculation    of type TS is enough to overcome them all.    Return nonzero if it should be moved to the ready list or the queue, or zero    if we should silently discard it.  */
end_comment

begin_function
specifier|static
name|ds_t
name|new_ready
parameter_list|(
name|rtx
name|next
parameter_list|,
name|ds_t
name|ts
parameter_list|)
block|{
if|if
condition|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
operator|!=
name|target_bb
condition|)
block|{
name|int
name|not_ex_free
init|=
literal|0
decl_stmt|;
comment|/* For speculative insns, before inserting to ready/queue, 	 check live, exception-free, and issue-delay.  */
if|if
condition|(
operator|!
name|IS_VALID
argument_list|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|)
operator|||
name|CANT_MOVE
argument_list|(
name|next
argument_list|)
operator|||
operator|(
name|IS_SPECULATIVE_INSN
argument_list|(
name|next
argument_list|)
operator|&&
operator|(
operator|(
name|recog_memoized
argument_list|(
name|next
argument_list|)
operator|>=
literal|0
operator|&&
name|min_insn_conflict_delay
argument_list|(
name|curr_state
argument_list|,
name|next
argument_list|,
name|next
argument_list|)
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_SCHED_INSN_CONFLICT_DELAY
argument_list|)
operator|)
operator|||
name|IS_SPECULATION_CHECK_P
argument_list|(
name|next
argument_list|)
operator|||
operator|!
name|check_live
argument_list|(
name|next
argument_list|,
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|)
operator|||
operator|(
name|not_ex_free
operator|=
operator|!
name|is_exception_free
argument_list|(
name|next
argument_list|,
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|,
name|target_bb
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|not_ex_free
comment|/* We are here because is_exception_free () == false. 		 But we possibly can handle that with control speculation.  */
operator|&&
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
comment|/* Here we got new control-speculative instruction.  */
name|ts
operator|=
name|set_dep_weak
argument_list|(
name|ts
argument_list|,
name|BEGIN_CONTROL
argument_list|,
name|MAX_DEP_WEAK
argument_list|)
expr_stmt|;
else|else
name|ts
operator|=
operator|(
name|ts
operator|&
operator|~
name|SPECULATIVE
operator|)
operator||
name|HARD_DEP
expr_stmt|;
block|}
block|}
return|return
name|ts
return|;
block|}
end_function

begin_comment
comment|/* Return a string that contains the insn uid and optionally anything else    necessary to identify this insn in an output.  It's valid to use a    static buffer for this.  The ALIGNED parameter should cause the string    to be formatted so that multiple output lines will line up nicely.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rgn_print_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|aligned
parameter_list|)
block|{
specifier|static
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|aligned
condition|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"b%3d: i%4d"
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
operator|&&
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d/b%d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Compare priority of two insns.  Return a positive number if the second    insn is to be preferred for scheduling, and a negative one if the first    is to be preferred.  Zero if they are equally good.  */
end_comment

begin_function
specifier|static
name|int
name|rgn_rank
parameter_list|(
name|rtx
name|insn1
parameter_list|,
name|rtx
name|insn2
parameter_list|)
block|{
comment|/* Some comparison make sense in interblock scheduling only.  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|!=
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
condition|)
block|{
name|int
name|spec_val
decl_stmt|,
name|prob_val
decl_stmt|;
comment|/* Prefer an inblock motion on an interblock motion.  */
if|if
condition|(
operator|(
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
operator|==
name|target_bb
operator|)
operator|&&
operator|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|!=
name|target_bb
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|==
name|target_bb
operator|)
operator|&&
operator|(
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
operator|!=
name|target_bb
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Prefer a useful motion on a speculative one.  */
name|spec_val
operator|=
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn1
argument_list|)
operator|-
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_val
condition|)
return|return
name|spec_val
return|;
comment|/* Prefer a more probable (speculative) insn.  */
name|prob_val
operator|=
name|INSN_PROBABILITY
argument_list|(
name|insn2
argument_list|)
operator|-
name|INSN_PROBABILITY
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prob_val
condition|)
return|return
name|prob_val
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NEXT is an instruction that depends on INSN (a backward dependence);    return nonzero if we should include this dependence in priority    calculations.  */
end_comment

begin_function
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|rtx
name|next
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* NEXT and INSN reside in one ebb.  */
return|return
name|BLOCK_TO_BB
argument_list|(
name|BLOCK_NUM
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|BLOCK_TO_BB
argument_list|(
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* INSN is a JUMP_INSN, COND_SET is the set of registers that are    conditionally set before INSN.  Store the set of registers that    must be considered as used by this jump in USED and that of    registers that must be considered as set in SET.  */
end_comment

begin_function
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|regset
name|cond_exec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|regset
name|used
name|ATTRIBUTE_UNUSED
parameter_list|,
name|regset
name|set
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Nothing to do here, since we postprocess jumps in      add_branch_dependences.  */
block|}
end_function

begin_comment
comment|/* Used in schedule_insns to initialize current_sched_info for scheduling    regions (or single basic blocks).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sched_info
name|region_sched_info
init|=
block|{
name|init_ready_list
block|,
name|can_schedule_ready_p
block|,
name|schedule_more_p
block|,
name|new_ready
block|,
name|rgn_rank
block|,
name|rgn_print_insn
block|,
name|contributes_to_priority
block|,
name|compute_jump_reg_dependencies
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|add_remove_insn
block|,
name|begin_schedule_ready
block|,
name|add_block1
block|,
name|advance_target_bb
block|,
name|fix_recovery_cfg
block|,
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|region_head_or_leaf_p
block|,
endif|#
directive|endif
name|SCHED_RGN
operator||
name|USE_GLAT
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
operator||
name|DETACH_LIFE_INFO
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine if PAT sets a CLASS_LIKELY_SPILLED_P register.  */
end_comment

begin_function
specifier|static
name|bool
name|sets_likely_spilled
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
name|bool
name|ret
init|=
name|false
decl_stmt|;
name|note_stores
argument_list|(
name|pat
argument_list|,
name|sets_likely_spilled_1
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sets_likely_spilled_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bool
modifier|*
name|ret
init|=
operator|(
name|bool
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
operator|*
name|ret
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add dependences so that branches are scheduled to run last in their    block.  */
end_comment

begin_function
specifier|static
name|void
name|add_branch_dependences
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
comment|/* For all branches, calls, uses, clobbers, cc0 setters, and instructions      that can throw exceptions, force them to remain in order at the end of      the block by adding dependencies and giving the last a high priority.      There may be notes present, and prev_head may also be a note.       Branches must obviously remain at the end.  Calls should remain at the      end since moving them results in worse register allocation.  Uses remain      at the end to ensure proper register allocation.       cc0 setters remain at the end because they can't be moved away from      their cc0 user.       COND_EXEC insns cannot be moved past a branch (see e.g. PR17808).       Insns setting CLASS_LIKELY_SPILLED_P registers (usually return values)      are not moved before reload because we can wind up with register      allocation failures.  */
name|insn
operator|=
name|tail
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
endif|#
directive|endif
operator|||
operator|(
operator|!
name|reload_completed
operator|&&
name|sets_likely_spilled
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|||
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
operator|!=
literal|0
operator|&&
operator|!
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|last
argument_list|,
name|insn
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|++
expr_stmt|;
block|}
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
block|}
comment|/* Don't overrun the bounds of the basic block.  */
if|if
condition|(
name|insn
operator|==
name|head
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure these insns are scheduled last in their block.  */
name|insn
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
literal|0
condition|)
while|while
condition|(
name|insn
operator|!=
name|head
condition|)
block|{
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|last
argument_list|,
name|insn
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* Finally, if the block ends in a jump, and we are doing intra-block      scheduling, make sure that the branch depends on any COND_EXEC insns      inside the block to avoid moving the COND_EXECs past the branch insn.       We only have to do this after reload, because (1) before reload there      are no COND_EXEC insns, and (2) the region scheduler is an intra-block      scheduler after reload.       FIXME: We could in some cases move COND_EXEC insns past the branch if      this scheduler would be a little smarter.  Consider this code:  		T = [addr] 	C  ?	addr += 4 	!C ?	X += 12 	C  ?	T += 1 	C  ?	jump foo       On a target with a one cycle stall on a memory access the optimal      sequence would be:  		T = [addr] 	C  ?	addr += 4 	C  ?	T += 1 	C  ?	jump foo 	!C ?	X += 12       We don't want to put the 'X += 12' before the branch because it just      wastes a cycle of execution time when the branch is taken.       Note that in the example "!C" will always be true.  That is another      possible improvement for handling COND_EXECs in this scheduler: it      could remove always-true predicates.  */
if|if
condition|(
operator|!
name|reload_completed
operator|||
operator|!
name|JUMP_P
argument_list|(
name|tail
argument_list|)
condition|)
return|return;
name|insn
operator|=
name|tail
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|head
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Note that we want to add this dependency even when 	 sched_insns_conditions_mutex_p returns true.  The whole point 	 is that we _want_ this dependency, even if these insns really 	 are independent.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|add_dependence
argument_list|(
name|tail
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Data structures for the computation of data dependences in a regions.  We    keep one `deps' structure for every basic block.  Before analyzing the    data dependences for a bb, its variables are initialized as a function of    the variables of its predecessors.  When the analysis for a bb completes,    we save the contents to the corresponding bb_deps[bb] variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|deps
modifier|*
name|bb_deps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Duplicate the INSN_LIST elements of COPY and prepend them to OLD.  */
end_comment

begin_function
specifier|static
name|rtx
name|concat_INSN_LIST
parameter_list|(
name|rtx
name|copy
parameter_list|,
name|rtx
name|old
parameter_list|)
block|{
name|rtx
name|new
init|=
name|old
decl_stmt|;
for|for
control|(
init|;
name|copy
condition|;
name|copy
operator|=
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
control|)
name|new
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|concat_insn_mem_list
parameter_list|(
name|rtx
name|copy_insns
parameter_list|,
name|rtx
name|copy_mems
parameter_list|,
name|rtx
modifier|*
name|old_insns_p
parameter_list|,
name|rtx
modifier|*
name|old_mems_p
parameter_list|)
block|{
name|rtx
name|new_insns
init|=
operator|*
name|old_insns_p
decl_stmt|;
name|rtx
name|new_mems
init|=
operator|*
name|old_mems_p
decl_stmt|;
while|while
condition|(
name|copy_insns
condition|)
block|{
name|new_insns
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|copy_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_insns
argument_list|)
expr_stmt|;
name|new_mems
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|copy_mems
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_mems
argument_list|)
expr_stmt|;
name|copy_insns
operator|=
name|XEXP
argument_list|(
name|copy_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|copy_mems
operator|=
name|XEXP
argument_list|(
name|copy_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|old_insns_p
operator|=
name|new_insns
expr_stmt|;
operator|*
name|old_mems_p
operator|=
name|new_mems
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After computing the dependencies for block BB, propagate the dependencies    found in TMP_DEPS to the successors of the block.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_deps
parameter_list|(
name|int
name|bb
parameter_list|,
name|struct
name|deps
modifier|*
name|pred_deps
parameter_list|)
block|{
name|basic_block
name|block
init|=
name|BASIC_BLOCK
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* bb's structures are inherited by its successors.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->succs
argument_list|)
block|{
name|struct
name|deps
modifier|*
name|succ_deps
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|reg_set_iterator
name|rsi
decl_stmt|;
comment|/* Only bbs "below" bb, in the same region, are interesting.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|CONTAINING_RGN
argument_list|(
name|block
operator|->
name|index
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|||
name|BLOCK_TO_BB
argument_list|(
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|<=
name|bb
condition|)
continue|continue;
name|succ_deps
operator|=
name|bb_deps
operator|+
name|BLOCK_TO_BB
argument_list|(
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* The reg_last lists are inherited by successor.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&pred_deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|reg
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|pred_rl
init|=
operator|&
name|pred_deps
operator|->
name|reg_last
index|[
name|reg
index|]
decl_stmt|;
name|struct
name|deps_reg
modifier|*
name|succ_rl
init|=
operator|&
name|succ_deps
operator|->
name|reg_last
index|[
name|reg
index|]
decl_stmt|;
name|succ_rl
operator|->
name|uses
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_rl
operator|->
name|uses
argument_list|,
name|succ_rl
operator|->
name|uses
argument_list|)
expr_stmt|;
name|succ_rl
operator|->
name|sets
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_rl
operator|->
name|sets
argument_list|,
name|succ_rl
operator|->
name|sets
argument_list|)
expr_stmt|;
name|succ_rl
operator|->
name|clobbers
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_rl
operator|->
name|clobbers
argument_list|,
name|succ_rl
operator|->
name|clobbers
argument_list|)
expr_stmt|;
name|succ_rl
operator|->
name|uses_length
operator|+=
name|pred_rl
operator|->
name|uses_length
expr_stmt|;
name|succ_rl
operator|->
name|clobbers_length
operator|+=
name|pred_rl
operator|->
name|clobbers_length
expr_stmt|;
block|}
name|IOR_REG_SET
argument_list|(
operator|&
name|succ_deps
operator|->
name|reg_last_in_use
argument_list|,
operator|&
name|pred_deps
operator|->
name|reg_last_in_use
argument_list|)
expr_stmt|;
comment|/* Mem read/write lists are inherited by successor.  */
name|concat_insn_mem_list
argument_list|(
name|pred_deps
operator|->
name|pending_read_insns
argument_list|,
name|pred_deps
operator|->
name|pending_read_mems
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_read_insns
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_read_mems
argument_list|)
expr_stmt|;
name|concat_insn_mem_list
argument_list|(
name|pred_deps
operator|->
name|pending_write_insns
argument_list|,
name|pred_deps
operator|->
name|pending_write_mems
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_write_insns
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_write_mems
argument_list|)
expr_stmt|;
name|succ_deps
operator|->
name|last_pending_memory_flush
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_deps
operator|->
name|last_pending_memory_flush
argument_list|,
name|succ_deps
operator|->
name|last_pending_memory_flush
argument_list|)
expr_stmt|;
name|succ_deps
operator|->
name|pending_lists_length
operator|+=
name|pred_deps
operator|->
name|pending_lists_length
expr_stmt|;
name|succ_deps
operator|->
name|pending_flush_length
operator|+=
name|pred_deps
operator|->
name|pending_flush_length
expr_stmt|;
comment|/* last_function_call is inherited by successor.  */
name|succ_deps
operator|->
name|last_function_call
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_deps
operator|->
name|last_function_call
argument_list|,
name|succ_deps
operator|->
name|last_function_call
argument_list|)
expr_stmt|;
comment|/* sched_before_next_call is inherited by successor.  */
name|succ_deps
operator|->
name|sched_before_next_call
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_deps
operator|->
name|sched_before_next_call
argument_list|,
name|succ_deps
operator|->
name|sched_before_next_call
argument_list|)
expr_stmt|;
block|}
comment|/* These lists should point to the right place, for correct      freeing later.  */
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_insns
operator|=
name|pred_deps
operator|->
name|pending_read_insns
expr_stmt|;
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_mems
operator|=
name|pred_deps
operator|->
name|pending_read_mems
expr_stmt|;
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_insns
operator|=
name|pred_deps
operator|->
name|pending_write_insns
expr_stmt|;
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_mems
operator|=
name|pred_deps
operator|->
name|pending_write_mems
expr_stmt|;
comment|/* Can't allow these to be freed twice.  */
name|pred_deps
operator|->
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
name|pred_deps
operator|->
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
name|pred_deps
operator|->
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
name|pred_deps
operator|->
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute backward dependences inside bb.  In a multiple blocks region:    (1) a bb is analyzed after its predecessors, and (2) the lists in    effect at the end of bb (after analyzing for bb) are inherited by    bb's successors.     Specifically for reg-reg data dependences, the block insns are    scanned by sched_analyze () top-to-bottom.  Two lists are    maintained by sched_analyze (): reg_last[].sets for register DEFs,    and reg_last[].uses for register USEs.     When analysis is completed for bb, we update for its successors:    ;  - DEFS[succ] = Union (DEFS [succ], DEFS [bb])    ;  - USES[succ] = Union (USES [succ], DEFS [bb])     The mechanism for computing mem-mem data dependence is very    similar, and the result is interblock dependences in the region.  */
end_comment

begin_function
specifier|static
name|void
name|compute_block_backward_dependences
parameter_list|(
name|int
name|bb
parameter_list|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|struct
name|deps
name|tmp_deps
decl_stmt|;
name|tmp_deps
operator|=
name|bb_deps
index|[
name|bb
index|]
expr_stmt|;
comment|/* Do the analysis for this block.  */
name|gcc_assert
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
operator|==
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|get_ebb_head_tail
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|sched_analyze
argument_list|(
operator|&
name|tmp_deps
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|add_branch_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
name|propagate_deps
argument_list|(
name|bb
argument_list|,
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
comment|/* Free up the INSN_LISTs.  */
name|free_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add    them to the unused_*_list variables, so that they can be reused.  */
end_comment

begin_function
specifier|static
name|void
name|free_pending_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|bb
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|free_INSN_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_insns
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_insns
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_mems
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_mems
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print dependences for debugging, callable from debugger.  */
end_comment

begin_function
name|void
name|debug_dependencies
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   --------------- forward dependences: ------------ \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|gcc_assert
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
operator|==
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|get_ebb_head_tail
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;;   --- Region Dependences --- b %d bb %d \n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %7s%6s%6s%6s%6s%6s%14s\n"
argument_list|,
literal|"insn"
argument_list|,
literal|"code"
argument_list|,
literal|"bb"
argument_list|,
literal|"dep"
argument_list|,
literal|"prio"
argument_list|,
literal|"cost"
argument_list|,
literal|"reservation"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %7s%6s%6s%6s%6s%6s%14s\n"
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|,
literal|"--"
argument_list|,
literal|"---"
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|,
literal|"-----------"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|n
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %6d "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|n
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"%s\n"
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|expanded_location
name|xloc
decl_stmt|;
name|NOTE_EXPANDED_LOCATION
argument_list|(
name|xloc
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"line %d, file %s\n"
argument_list|,
name|xloc
operator|.
name|line
argument_list|,
name|xloc
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" {%s}\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %s%5d%6d%6d%6d%6d%6d   "
argument_list|,
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|?
literal|"+"
else|:
literal|" "
operator|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn_cost
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"nothing"
argument_list|)
expr_stmt|;
else|else
name|print_reservation
argument_list|(
name|sched_dump
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\t: "
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"%d "
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns true if all the basic blocks of the current region have    NOTE_DISABLE_SCHED_OF_BLOCK which means not to schedule that region.  */
end_comment

begin_function
specifier|static
name|bool
name|sched_is_disabled_for_current_region_p
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|bb
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|BASIC_BLOCK
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|->
name|flags
operator|&
name|BB_DISABLE_SCHEDULE
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Schedule a region.  A region is either an inner loop, a loop-free    subroutine, or a single basic block.  Each bb in the region is    scheduled after its flow predecessors.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_region
parameter_list|(
name|int
name|rgn
parameter_list|)
block|{
name|basic_block
name|block
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int
name|sched_rgn_n_insns
init|=
literal|0
decl_stmt|;
name|rgn_n_insns
operator|=
literal|0
expr_stmt|;
comment|/* Set variables for the current region.  */
name|current_nr_blocks
operator|=
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|current_blocks
operator|=
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
comment|/* See comments in add_block1, for what reasons we allocate +1 element.  */
name|ebb_head
operator|=
name|xrealloc
argument_list|(
name|ebb_head
argument_list|,
operator|(
name|current_nr_blocks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ebb_head
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<=
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|ebb_head
index|[
name|bb
index|]
operator|=
name|current_blocks
operator|+
name|bb
expr_stmt|;
comment|/* Don't schedule region that is marked by      NOTE_DISABLE_SCHED_OF_BLOCK.  */
if|if
condition|(
name|sched_is_disabled_for_current_region_p
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|RGN_DONT_CALC_DEPS
argument_list|(
name|rgn
argument_list|)
condition|)
block|{
name|init_deps_global
argument_list|()
expr_stmt|;
comment|/* Initializations for region data dependence analysis.  */
name|bb_deps
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|deps
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|init_deps
argument_list|(
name|bb_deps
operator|+
name|bb
argument_list|)
expr_stmt|;
comment|/* Compute LOG_LINKS.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|compute_block_backward_dependences
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Compute INSN_DEPEND.  */
for|for
control|(
name|bb
operator|=
name|current_nr_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|gcc_assert
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
operator|==
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|get_ebb_head_tail
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|compute_forward_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dependencies_evaluation_hook
condition|)
name|targetm
operator|.
name|sched
operator|.
name|dependencies_evaluation_hook
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|free_pending_lists
argument_list|()
expr_stmt|;
name|finish_deps_global
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|bb_deps
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This is a recovery block.  It is always a single block region.  */
name|gcc_assert
argument_list|(
name|current_nr_blocks
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priorities.  */
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|gcc_assert
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
operator|==
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|get_ebb_head_tail
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|rgn_n_insns
operator|+=
name|set_priorities
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|++
expr_stmt|;
comment|/* Compute interblock info: probabilities, split-edges, dominators, etc.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|prob
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
name|dom
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|current_nr_blocks
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|dom
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
comment|/* Use ->aux to implement EDGE_TO_BIT mapping.  */
name|rgn_nr_edges
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|block
argument_list|)
block|{
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|block
operator|->
name|index
argument_list|)
operator|!=
name|rgn
condition|)
continue|continue;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->succs
argument_list|)
name|SET_EDGE_TO_BIT
argument_list|(
name|e
argument_list|,
name|rgn_nr_edges
operator|++
argument_list|)
expr_stmt|;
block|}
name|rgn_edges
operator|=
name|XNEWVEC
argument_list|(
name|edge
argument_list|,
name|rgn_nr_edges
argument_list|)
expr_stmt|;
name|rgn_nr_edges
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|block
argument_list|)
block|{
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|block
operator|->
name|index
argument_list|)
operator|!=
name|rgn
condition|)
continue|continue;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->succs
argument_list|)
name|rgn_edges
index|[
name|rgn_nr_edges
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
comment|/* Split edges.  */
name|pot_split
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|current_nr_blocks
argument_list|,
name|rgn_nr_edges
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|pot_split
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
name|ancestor_edges
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|current_nr_blocks
argument_list|,
name|rgn_nr_edges
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ancestor_edges
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
comment|/* Compute probabilities, dominators, split_edges.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|compute_dom_prob_ps
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Cleanup ->aux used for EDGE_TO_BIT mapping.  */
comment|/* We don't need them anymore.  But we want to avoid duplication of 	 aux fields in the newly created edges.  */
name|FOR_EACH_BB
argument_list|(
argument|block
argument_list|)
block|{
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|block
operator|->
name|index
argument_list|)
operator|!=
name|rgn
condition|)
continue|continue;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->succs
argument_list|)
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Now we can schedule all blocks.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|basic_block
name|first_bb
decl_stmt|,
name|last_bb
decl_stmt|,
name|curr_bb
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|b
init|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|first_bb
operator|=
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|last_bb
operator|=
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|get_ebb_head_tail
argument_list|(
name|first_bb
argument_list|,
name|last_bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_real_insns_p
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|first_bb
operator|==
name|last_bb
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|current_sched_info
operator|->
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|save_line_notes
argument_list|(
name|b
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|rm_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* rm_other_notes only removes notes which are _inside_ the 	 block---that is, it won't remove notes before the first real insn 	 or after the last real insn of the block.  So if the first insn 	 has a REG_SAVE_NOTE which would otherwise be emitted before the 	 insn, it is redundant with the note before the start of the 	 block, and so we have to take it out.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|head
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This means that first block in ebb is empty. 	   It looks to me as an impossible thing.  There at least should be 	   a recovery check, that caused the splitting.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Remove remaining note insns from the block, save them in 	 note_list.  These notes are restored at the end of 	 schedule_block ().  */
name|rm_other_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|unlink_bb_notes
argument_list|(
name|first_bb
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
name|target_bb
operator|=
name|bb
expr_stmt|;
name|gcc_assert
argument_list|(
name|flag_schedule_interblock
operator|||
name|current_nr_blocks
operator|==
literal|1
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|=
name|current_nr_blocks
operator|==
literal|1
expr_stmt|;
name|curr_bb
operator|=
name|first_bb
expr_stmt|;
name|schedule_block
argument_list|(
operator|&
name|curr_bb
argument_list|,
name|rgn_n_insns
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
operator|==
name|first_bb
argument_list|)
expr_stmt|;
name|sched_rgn_n_insns
operator|+=
name|sched_n_insns
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|candidate_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bblst_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edgelst_table
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sanity check: verify that all region insns were scheduled.  */
name|gcc_assert
argument_list|(
name|sched_rgn_n_insns
operator|==
name|rgn_n_insns
argument_list|)
expr_stmt|;
comment|/* Restore line notes.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|get_ebb_head_tail
argument_list|(
name|EBB_FIRST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
name|EBB_LAST_BB
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|restore_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Done with this region.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|prob
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|pot_split
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ancestor_edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rgn_edges
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Indexed by region, holds the number of death notes found in that region.    Used for consistency checks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|deaths_in_region
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data structures for region scheduling.  */
end_comment

begin_function
specifier|static
name|void
name|init_regions
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap
name|blocks
decl_stmt|;
name|int
name|rgn
decl_stmt|;
name|nr_regions
operator|=
literal|0
expr_stmt|;
name|rgn_table
operator|=
literal|0
expr_stmt|;
name|rgn_bb_table
operator|=
literal|0
expr_stmt|;
name|block_to_bb
operator|=
literal|0
expr_stmt|;
name|containing_rgn
operator|=
literal|0
expr_stmt|;
name|extend_regions
argument_list|()
expr_stmt|;
comment|/* Compute regions for scheduling.  */
if|if
condition|(
name|reload_completed
operator|||
name|n_basic_blocks
operator|==
name|NUM_FIXED_BLOCKS
operator|+
literal|1
operator|||
operator|!
name|flag_schedule_interblock
operator|||
name|is_cfg_nonregular
argument_list|()
condition|)
block|{
name|find_single_block_region
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute the dominators and post dominators.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Find regions.  */
name|find_rgns
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|3
condition|)
name|debug_regions
argument_list|()
expr_stmt|;
comment|/* For now.  This will move as more and more of haifa is converted 	 to using the cfg code in flow.c.  */
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
block|}
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|RGN_BLOCKS
argument_list|(
name|nr_regions
operator|-
literal|1
argument_list|)
operator|+
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_DEAD_NOTES
condition|)
block|{
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|deaths_in_region
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|nr_regions
argument_list|)
expr_stmt|;
comment|/* Remove all death notes from the subroutine.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
name|check_dead_notes1
argument_list|(
name|rgn
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
else|else
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  */
end_comment

begin_function
name|void
name|schedule_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap
name|large_region_blocks
decl_stmt|,
name|blocks
decl_stmt|;
name|int
name|rgn
decl_stmt|;
name|int
name|any_large_regions
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
name|NUM_FIXED_BLOCKS
condition|)
return|return;
name|nr_inter
operator|=
literal|0
expr_stmt|;
name|nr_spec
operator|=
literal|0
expr_stmt|;
comment|/* We need current_sched_info in init_dependency_caches, which is      invoked via sched_init.  */
name|current_sched_info
operator|=
operator|&
name|region_sched_info
expr_stmt|;
name|sched_init
argument_list|()
expr_stmt|;
name|min_spec_prob
operator|=
operator|(
operator|(
name|PARAM_VALUE
argument_list|(
name|PARAM_MIN_SPEC_PROB
argument_list|)
operator|*
name|REG_BR_PROB_BASE
operator|)
operator|/
literal|100
operator|)
expr_stmt|;
name|init_regions
argument_list|()
expr_stmt|;
comment|/* EBB_HEAD is a region-scope structure.  But we realloc it for      each region to save time/memory/something else.  */
name|ebb_head
operator|=
literal|0
expr_stmt|;
comment|/* Schedule every region in the subroutine.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
name|schedule_region
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ebb_head
argument_list|)
expr_stmt|;
comment|/* Update life analysis for the subroutine.  Do single block regions      first so that we can verify that live_at_start didn't change.  Then      do all other blocks.  */
comment|/* ??? There is an outside possibility that update_life_info, or more      to the point propagate_block, could get called with nonzero flags      more than once for one basic block.  This would be kinda bad if it      were to happen, since REG_INFO would be accumulated twice for the      block, and we'd have twice the REG_DEAD notes.       I'm fairly certain that this _shouldn't_ happen, since I don't think      that live_at_start should change at region heads.  Not sure what the      best way to test for this kind of thing...  */
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DETACH_LIFE_INFO
condition|)
comment|/* this flag can be set either by the target or by ENABLE_CHECKING.  */
name|attach_life_info
argument_list|()
expr_stmt|;
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|any_large_regions
operator|=
literal|0
expr_stmt|;
name|large_region_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|large_region_blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|SET_BIT
argument_list|(
name|large_region_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
comment|/* Update life information.  For regions consisting of multiple blocks      we've possibly done interblock scheduling that affects global liveness.      For regions consisting of single blocks we need to do only local      liveness.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
if|if
condition|(
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|>
literal|1
comment|/* Or the only block of this region has been split.  */
operator|||
name|RGN_HAS_REAL_EBB
argument_list|(
name|rgn
argument_list|)
comment|/* New blocks (e.g. recovery blocks) should be processed 	   as parts of large regions.  */
operator|||
operator|!
name|glat_start
index|[
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
index|]
index|]
condition|)
name|any_large_regions
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|large_region_blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Don't update reg info after reload, since that affects      regs_ever_live, which should not change after reload.  */
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
operator|(
name|reload_completed
condition|?
name|PROP_DEATH_NOTES
else|:
operator|(
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_large_regions
condition|)
block|{
name|update_life_info
argument_list|(
name|large_region_blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
operator|(
name|reload_completed
condition|?
name|PROP_DEATH_NOTES
else|:
operator|(
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
operator|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|check_reg_live
argument_list|(
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|CHECK_DEAD_NOTES
condition|)
block|{
comment|/* Verify the counts of basic block notes in single basic block          regions.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
if|if
condition|(
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|deaths_in_region
index|[
name|rgn
index|]
operator|==
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|deaths_in_region
argument_list|)
expr_stmt|;
block|}
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Delete redundant line notes.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|rm_redundant_line_notes
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|&&
name|flag_schedule_interblock
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;; Procedure interblock/speculative motions == %d/%d \n"
argument_list|,
name|nr_inter
argument_list|,
name|nr_spec
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
name|nr_inter
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|rgn_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rgn_bb_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|block_to_bb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|containing_rgn
argument_list|)
expr_stmt|;
name|sched_finish
argument_list|()
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|large_region_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* INSN has been added to/removed from current region.  */
end_comment

begin_function
specifier|static
name|void
name|add_remove_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|remove_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|remove_p
condition|)
name|rgn_n_insns
operator|++
expr_stmt|;
else|else
name|rgn_n_insns
operator|--
expr_stmt|;
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|==
name|target_bb
condition|)
block|{
if|if
condition|(
operator|!
name|remove_p
condition|)
name|target_n_insns
operator|++
expr_stmt|;
else|else
name|target_n_insns
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extend internal data structures.  */
end_comment

begin_function
specifier|static
name|void
name|extend_regions
parameter_list|(
name|void
parameter_list|)
block|{
name|rgn_table
operator|=
name|XRESIZEVEC
argument_list|(
name|region
argument_list|,
name|rgn_table
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|rgn_bb_table
operator|=
name|XRESIZEVEC
argument_list|(
name|int
argument_list|,
name|rgn_bb_table
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|block_to_bb
operator|=
name|XRESIZEVEC
argument_list|(
name|int
argument_list|,
name|block_to_bb
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|containing_rgn
operator|=
name|XRESIZEVEC
argument_list|(
name|int
argument_list|,
name|containing_rgn
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* BB was added to ebb after AFTER.  */
end_comment

begin_function
specifier|static
name|void
name|add_block1
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|extend_regions
argument_list|()
expr_stmt|;
if|if
condition|(
name|after
operator|==
literal|0
operator|||
name|after
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
expr_stmt|;
comment|/* I - first free position in rgn_bb_table.  */
name|rgn_bb_table
index|[
name|i
index|]
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_DONT_CALC_DEPS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|after
operator|==
name|EXIT_BLOCK_PTR
expr_stmt|;
name|RGN_HAS_REAL_EBB
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
literal|0
expr_stmt|;
name|nr_regions
operator|++
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|CHECK_DEAD_NOTES
condition|)
block|{
name|sbitmap
name|blocks
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
name|deaths_in_region
operator|=
name|xrealloc
argument_list|(
name|deaths_in_region
argument_list|,
name|nr_regions
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|deaths_in_region
argument_list|)
argument_list|)
expr_stmt|;
name|check_dead_notes1
argument_list|(
name|nr_regions
operator|-
literal|1
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|pos
decl_stmt|;
comment|/* We need to fix rgn_table, block_to_bb, containing_rgn 	 and ebb_head.  */
name|BLOCK_TO_BB
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|BLOCK_TO_BB
argument_list|(
name|after
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* We extend ebb_head to one more position to 	 easily find the last position of the last ebb in  	 the current region.  Thus, ebb_head[BLOCK_TO_BB (after) + 1] 	 is _always_ valid for access.  */
name|i
operator|=
name|BLOCK_TO_BB
argument_list|(
name|after
operator|->
name|index
argument_list|)
operator|+
literal|1
expr_stmt|;
name|pos
operator|=
name|ebb_head
index|[
name|i
index|]
operator|-
literal|1
expr_stmt|;
comment|/* Now POS is the index of the last block in the region.  */
comment|/* Find index of basic block AFTER.  */
for|for
control|(
init|;
name|rgn_bb_table
index|[
name|pos
index|]
operator|!=
name|after
operator|->
name|index
condition|;
name|pos
operator|--
control|)
empty_stmt|;
name|pos
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|pos
operator|>
name|ebb_head
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* i - ebb right after "AFTER".  */
comment|/* ebb_head[i] - VALID.  */
comment|/* Source position: ebb_head[i] 	 Destination position: ebb_head[i] + 1 	 Last position:  	   RGN_BLOCKS (nr_regions) - 1 	 Number of elements to copy: (last_position) - (source_position) + 1        */
name|memmove
argument_list|(
name|rgn_bb_table
operator|+
name|pos
operator|+
literal|1
argument_list|,
name|rgn_bb_table
operator|+
name|pos
argument_list|,
operator|(
operator|(
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|-
literal|1
operator|)
operator|-
operator|(
name|pos
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rgn_bb_table
argument_list|)
argument_list|)
expr_stmt|;
name|rgn_bb_table
index|[
name|pos
index|]
operator|=
name|bb
operator|->
name|index
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
name|ebb_head
index|[
name|i
index|]
operator|++
expr_stmt|;
name|i
operator|=
name|CONTAINING_RGN
argument_list|(
name|after
operator|->
name|index
argument_list|)
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|=
name|i
expr_stmt|;
name|RGN_HAS_REAL_EBB
argument_list|(
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
operator|++
name|i
init|;
name|i
operator|<=
name|nr_regions
condition|;
name|i
operator|++
control|)
name|RGN_BLOCKS
argument_list|(
name|i
argument_list|)
operator|++
expr_stmt|;
comment|/* We don't need to call check_dead_notes1 () because this new block 	 is just a split of the old.  We don't want to count anything twice.  */
block|}
block|}
end_function

begin_comment
comment|/* Fix internal data after interblock movement of jump instruction.    For parameter meaning please refer to    sched-int.h: struct sched_info: fix_recovery_cfg.  */
end_comment

begin_function
specifier|static
name|void
name|fix_recovery_cfg
parameter_list|(
name|int
name|bbi
parameter_list|,
name|int
name|check_bbi
parameter_list|,
name|int
name|check_bb_nexti
parameter_list|)
block|{
name|int
name|old_pos
decl_stmt|,
name|new_pos
decl_stmt|,
name|i
decl_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|check_bb_nexti
argument_list|)
operator|=
name|BLOCK_TO_BB
argument_list|(
name|bbi
argument_list|)
expr_stmt|;
for|for
control|(
name|old_pos
operator|=
name|ebb_head
index|[
name|BLOCK_TO_BB
argument_list|(
name|check_bbi
argument_list|)
operator|+
literal|1
index|]
operator|-
literal|1
init|;
name|rgn_bb_table
index|[
name|old_pos
index|]
operator|!=
name|check_bb_nexti
condition|;
name|old_pos
operator|--
control|)
empty_stmt|;
name|gcc_assert
argument_list|(
name|old_pos
operator|>
name|ebb_head
index|[
name|BLOCK_TO_BB
argument_list|(
name|check_bbi
argument_list|)
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|new_pos
operator|=
name|ebb_head
index|[
name|BLOCK_TO_BB
argument_list|(
name|bbi
argument_list|)
operator|+
literal|1
index|]
operator|-
literal|1
init|;
name|rgn_bb_table
index|[
name|new_pos
index|]
operator|!=
name|bbi
condition|;
name|new_pos
operator|--
control|)
empty_stmt|;
name|new_pos
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_pos
operator|>
name|ebb_head
index|[
name|BLOCK_TO_BB
argument_list|(
name|bbi
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_pos
operator|<
name|old_pos
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rgn_bb_table
operator|+
name|new_pos
operator|+
literal|1
argument_list|,
name|rgn_bb_table
operator|+
name|new_pos
argument_list|,
operator|(
name|old_pos
operator|-
name|new_pos
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rgn_bb_table
argument_list|)
argument_list|)
expr_stmt|;
name|rgn_bb_table
index|[
name|new_pos
index|]
operator|=
name|check_bb_nexti
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BLOCK_TO_BB
argument_list|(
name|bbi
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<=
name|BLOCK_TO_BB
argument_list|(
name|check_bbi
argument_list|)
condition|;
name|i
operator|++
control|)
name|ebb_head
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return next block in ebb chain.  For parameter meaning please refer to    sched-int.h: struct sched_info: advance_target_bb.  */
end_comment

begin_function
specifier|static
name|basic_block
name|advance_target_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
condition|)
return|return
literal|0
return|;
name|gcc_assert
argument_list|(
name|BLOCK_TO_BB
argument_list|(
name|bb
operator|->
name|index
argument_list|)
operator|==
name|target_bb
operator|&&
name|BLOCK_TO_BB
argument_list|(
name|bb
operator|->
name|next_bb
operator|->
name|index
argument_list|)
operator|==
name|target_bb
argument_list|)
expr_stmt|;
return|return
name|bb
operator|->
name|next_bb
return|;
block|}
end_function

begin_comment
comment|/* Count and remove death notes in region RGN, which consists of blocks    with indecies in BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|check_dead_notes1
parameter_list|(
name|int
name|rgn
parameter_list|,
name|sbitmap
name|blocks
parameter_list|)
block|{
name|int
name|b
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|-
literal|1
init|;
name|b
operator|>=
literal|0
condition|;
operator|--
name|b
control|)
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|+
name|b
index|]
argument_list|)
expr_stmt|;
name|deaths_in_region
index|[
name|rgn
index|]
operator|=
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* Return non zero, if BB is head or leaf (depending of LEAF_P) block in    current region.  For more information please refer to    sched-int.h: struct sched_info: region_head_or_leaf_p.  */
end_comment

begin_function
specifier|static
name|int
name|region_head_or_leaf_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|leaf_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|leaf_p
condition|)
return|return
name|bb
operator|->
name|index
operator|==
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|CONTAINING_RGN
argument_list|(
name|bb
operator|->
name|index
argument_list|)
argument_list|)
index|]
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|i
operator|=
name|CONTAINING_RGN
argument_list|(
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|CONTAINING_RGN
argument_list|(
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|==
name|i
comment|/* except self-loop.  */
operator|&&
name|e
operator|->
name|dest
operator|!=
name|bb
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_CHECKING  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_sched
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
return|return
name|flag_schedule_insns
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Run instruction scheduler.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_sched
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* Do control and data sched analysis,      and write some of the results to dump file.  */
name|schedule_insns
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_handle_sched2
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
return|return
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns_after_reload
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Run second scheduling pass after reload.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_sched2
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* Do control and data sched analysis again,      and write some more of the results to dump file.  */
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_sched2_use_superblocks
operator|||
name|flag_sched2_use_traces
condition|)
block|{
name|schedule_ebbs
argument_list|()
expr_stmt|;
comment|/* No liveness updating code yet, but it should be easy to do.          reg-stack recomputes the liveness when needed for now.  */
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
block|}
else|else
name|schedule_insns
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_sched
init|=
block|{
literal|"sched1"
block|,
comment|/* name */
name|gate_handle_sched
block|,
comment|/* gate */
name|rest_of_handle_sched
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_SCHED
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'S'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_sched2
init|=
block|{
literal|"sched2"
block|,
comment|/* name */
name|gate_handle_sched2
block|,
comment|/* gate */
name|rest_of_handle_sched2
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_SCHED2
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'R'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

