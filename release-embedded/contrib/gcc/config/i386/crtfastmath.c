begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2005 Free Software Foundation, Inc.  *  * This file is free software; you can redistribute it and/or modify it  * under the terms of the GNU General Public License as published by the  * Free Software Foundation; either version 2, or (at your option) any  * later version.  *   * In addition to the permissions in the GNU General Public License, the  * Free Software Foundation gives you unlimited permission to link the  * compiled version of this file with other programs, and to distribute  * those programs without any restriction coming from the use of this  * file.  (The General Public License restrictions do apply in other  * respects; for example, they cover modification of the file, and  * distribution when not linked into another program.)  *   * This file is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; see the file COPYING.  If not, write to  * the Free Software Foundation, 51 Franklin Street, Fifth Floor,  * Boston, MA 02110-1301, USA.  *   *    As a special exception, if you link this library with files  *    compiled with GCC to produce an executable, this does not cause  *    the resulting executable to be covered by the GNU General Public License.  *    This exception does not however invalidate any other reasons why  *    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_define
define|#
directive|define
name|MXCSR_DAZ
value|(1<< 6)
end_define

begin_comment
comment|/* Enable denormals are zero mode */
end_comment

begin_define
define|#
directive|define
name|MXCSR_FTZ
value|(1<< 15)
end_define

begin_comment
comment|/* Enable flush to zero mode */
end_comment

begin_define
define|#
directive|define
name|FXSAVE
value|(1<< 24)
end_define

begin_define
define|#
directive|define
name|SSE
value|(1<< 25)
end_define

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|constructor
operator|)
argument_list|)
ifndef|#
directive|ifndef
name|__x86_64__
comment|/* The i386 ABI only requires 4-byte stack alignment, so this is necessary    to make sure the fxsave struct gets correct alignment.    See PR27537 and PR28621.  */
name|__attribute__
argument_list|(
operator|(
name|force_align_arg_pointer
operator|)
argument_list|)
endif|#
directive|endif
name|set_fast_math
argument_list|(
name|void
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__x86_64__
comment|/* All 64-bit targets have SSE and DAZ; only check them explicitly      for 32-bit ones. */
name|unsigned
name|int
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
comment|/* See if we can use cpuid.  */
asm|asm
specifier|volatile
asm|("pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;" 		"pushl %0; popfl; pushfl; popl %0; popfl" 		: "=&r" (eax), "=&r" (ebx) 		: "i" (0x00200000));
if|if
condition|(
operator|(
operator|(
name|eax
operator|^
name|ebx
operator|)
operator|&
literal|0x00200000
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Check the highest input value for eax.  */
asm|asm
specifier|volatile
asm|("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1" 		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx) 		: "0" (0));
if|if
condition|(
name|eax
operator|==
literal|0
condition|)
return|return;
asm|asm
specifier|volatile
asm|("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1" 		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx) 		: "0" (1));
if|if
condition|(
name|edx
operator|&
name|SSE
condition|)
block|{
name|unsigned
name|int
name|mxcsr
init|=
name|__builtin_ia32_stmxcsr
argument_list|()
decl_stmt|;
name|mxcsr
operator||=
name|MXCSR_FTZ
expr_stmt|;
if|if
condition|(
name|edx
operator|&
name|FXSAVE
condition|)
block|{
comment|/* Check if DAZ is available.  */
struct|struct
block|{
name|unsigned
name|short
name|int
name|cwd
decl_stmt|;
name|unsigned
name|short
name|int
name|swd
decl_stmt|;
name|unsigned
name|short
name|int
name|twd
decl_stmt|;
name|unsigned
name|short
name|int
name|fop
decl_stmt|;
name|long
name|int
name|fip
decl_stmt|;
name|long
name|int
name|fcs
decl_stmt|;
name|long
name|int
name|foo
decl_stmt|;
name|long
name|int
name|fos
decl_stmt|;
name|long
name|int
name|mxcsr
decl_stmt|;
name|long
name|int
name|mxcsr_mask
decl_stmt|;
name|long
name|int
name|st_space
index|[
literal|32
index|]
decl_stmt|;
name|long
name|int
name|xmm_space
index|[
literal|32
index|]
decl_stmt|;
name|long
name|int
name|padding
index|[
literal|56
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|aligned
argument_list|(
literal|16
argument_list|)
operator|)
argument_list|)
name|fxsave
struct|;
name|__builtin_memset
argument_list|(
operator|&
name|fxsave
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fxsave
argument_list|)
argument_list|)
expr_stmt|;
asm|asm
specifier|volatile
asm|("fxsave %0" : "=m" (fxsave) : "m" (fxsave));
if|if
condition|(
name|fxsave
operator|.
name|mxcsr_mask
operator|&
name|MXCSR_DAZ
condition|)
name|mxcsr
operator||=
name|MXCSR_DAZ
expr_stmt|;
block|}
name|__builtin_ia32_ldmxcsr
argument_list|(
name|mxcsr
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|unsigned
name|int
name|mxcsr
init|=
name|__builtin_ia32_stmxcsr
argument_list|()
decl_stmt|;
name|mxcsr
operator||=
name|MXCSR_DAZ
operator||
name|MXCSR_FTZ
expr_stmt|;
name|__builtin_ia32_ldmxcsr
argument_list|(
name|mxcsr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

end_unit

