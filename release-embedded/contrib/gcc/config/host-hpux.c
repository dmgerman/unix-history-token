begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* HP-UX host-specific hook definitions.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks-def.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|(void *)-1L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|hpux_gt_pch_get_address
parameter_list|(
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpux_gt_pch_use_address
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_GT_PCH_GET_ADDRESS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_GT_PCH_GET_ADDRESS
value|hpux_gt_pch_get_address
end_define

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_GT_PCH_USE_ADDRESS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_GT_PCH_USE_ADDRESS
value|hpux_gt_pch_use_address
end_define

begin_comment
comment|/* For various ports, try to guess a fixed spot in the vm space    that's probably free.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__hppa__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ia64__
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|__LP64__
argument_list|)
end_if

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x8000000000000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__hppa__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ia64__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x60000000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Determine a location where we might be able to reliably allocate    SIZE bytes.  FD is the PCH file, though we should return with the    file unmapped.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|hpux_gt_pch_get_address
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|mmap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TRY_EMPTY_VM_SPACE
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we failed the map, that means there's *no* free space.  */
if|if
condition|(
name|addr
operator|==
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
return|return
name|NULL
return|;
comment|/* Unmap the area before returning.  */
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at    mapping the data at BASE, -1 if we couldn't.     It's not possibly to reliably mmap a file using MAP_PRIVATE to    a specific START address on either hpux or linux.  First we see    if mmap with MAP_PRIVATE works.  If it does, we are off to the    races.  If it doesn't, we try an anonymous private mmap since the    kernel is more likely to honor the BASE address in anonymous maps.    We then copy the data to the anonymous private map.  This assumes    of course that we don't need to change the data in the PCH file    after it is created.     This approach obviously causes a performance penalty but there is    little else we can do given the current PCH implementation.  */
end_comment

begin_function
specifier|static
name|int
name|hpux_gt_pch_use_address
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|fd
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
comment|/* We're called with size == 0 if we're not planning to load a PCH      file at all.  This allows the hook to free any static space that      we might have allocated at link time.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Try to map the file with MAP_PRIVATE.  */
name|addr
operator|=
name|mmap
argument_list|(
name|base
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|base
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Try to make an anonymous private mmap at the desired location.  */
name|addr
operator|=
name|mmap
argument_list|(
name|base
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|base
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|size
condition|)
block|{
name|ssize_t
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|base
argument_list|,
name|MIN
argument_list|(
name|size
argument_list|,
name|SSIZE_MAX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|nbytes
expr_stmt|;
name|size
operator|-=
name|nbytes
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|struct
name|host_hooks
name|host_hooks
init|=
name|HOST_HOOKS_INITIALIZER
decl_stmt|;
end_decl_stmt

end_unit

