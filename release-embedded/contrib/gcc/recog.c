begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used by or related to instruction recognition.    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"addresses.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POP_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_POP_CODE
value|POST_INC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_POP_CODE
value|POST_DEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|validate_replace_rtx_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
modifier|*
name|find_single_use_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_replace_src_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|split_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero means allow operands to be volatile.    This should be 0 if you are generating rtl, such as if you are calling    the functions in optabs.c and expmed.c (most of the time).    This should be 1 if all valid insns need to be recognized,    such as in regclass.c and final.c and reload.c.     init_recog and init_recog_no_volatile are responsible for setting this.  */
end_comment

begin_decl_stmt
name|int
name|volatile_ok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|recog_data
name|recog_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains a vector of operand_alternative structures for every operand.    Set up by preprocess_constraints.  */
end_comment

begin_decl_stmt
name|struct
name|operand_alternative
name|recog_op_alt
index|[
name|MAX_RECOG_OPERANDS
index|]
index|[
name|MAX_RECOG_ALTERNATIVES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On return from `constrain_operands', indicate which alternative    was satisfied.  */
end_comment

begin_decl_stmt
name|int
name|which_alternative
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after end of reload pass.    Set to 1 or 0 by toplev.c.    Controls the significance of (SUBREG (MEM)).  */
end_comment

begin_decl_stmt
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after thread_prologue_and_epilogue_insns has run.  */
end_comment

begin_decl_stmt
name|int
name|epilogue_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data used by the function `recog'.    This must be called once in the compilation of a function    before any insn recognition may be done in the function.  */
end_comment

begin_function
name|void
name|init_recog_no_volatile
parameter_list|(
name|void
parameter_list|)
block|{
name|volatile_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_recog
parameter_list|(
name|void
parameter_list|)
block|{
name|volatile_ok
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check that X is an insn-body for an `asm' with operands    and that the operands mentioned in it are legitimate.  */
end_comment

begin_function
name|int
name|check_asm_operands
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|noperands
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Post-reload, be more strict with things.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
comment|/* ??? Doh!  We've not got the wrapping insn.  Cook one up.  */
name|extract_insn
argument_list|(
name|make_insn_raw
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|which_alternative
operator|>=
literal|0
return|;
block|}
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|noperands
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|operands
operator|=
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|constraints
operator|=
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|decode_asm_operands
argument_list|(
name|x
argument_list|,
name|operands
argument_list|,
name|NULL
argument_list|,
name|constraints
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
index|[
literal|0
index|]
argument_list|)
operator|&&
name|c
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|c
operator|=
name|constraints
index|[
name|c
index|[
literal|0
index|]
operator|-
literal|'0'
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|asm_operand_ok
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Static data for the next two routines.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|change_t
block|{
name|rtx
name|object
decl_stmt|;
name|int
name|old_code
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|old
decl_stmt|;
block|}
name|change_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|change_t
modifier|*
name|changes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|changes_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_changes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Validate a proposed change to OBJECT.  LOC is the location in the rtl    at which NEW will be placed.  If OBJECT is zero, no validation is done,    the change is simply made.     Two types of objects are supported:  If OBJECT is a MEM, memory_address_p    will be called with the address and mode as parameters.  If OBJECT is    an INSN, CALL_INSN, or JUMP_INSN, the insn will be re-recognized with    the change in place.     IN_GROUP is nonzero if this is part of a group of changes that must be    performed as a group.  In that case, the changes will be stored.  The    function `apply_change_group' will validate and apply the changes.     If IN_GROUP is zero, this is a single change.  Try to recognize the insn    or validate the memory reference with the change applied.  If the result    is not valid for the machine, suppress the change and return zero.    Otherwise, perform the change and return 1.  */
end_comment

begin_function
name|int
name|validate_change
parameter_list|(
name|rtx
name|object
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|new
parameter_list|,
name|int
name|in_group
parameter_list|)
block|{
name|rtx
name|old
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|new
operator|||
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
condition|)
return|return
literal|1
return|;
name|gcc_assert
argument_list|(
name|in_group
operator|!=
literal|0
operator|||
name|num_changes
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|new
expr_stmt|;
comment|/* Save the information describing this change.  */
if|if
condition|(
name|num_changes
operator|>=
name|changes_allocated
condition|)
block|{
if|if
condition|(
name|changes_allocated
operator|==
literal|0
condition|)
comment|/* This value allows for repeated substitutions inside complex 	   indexed addresses, or changes in up to 5 insns.  */
name|changes_allocated
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|5
expr_stmt|;
else|else
name|changes_allocated
operator|*=
literal|2
expr_stmt|;
name|changes
operator|=
name|xrealloc
argument_list|(
name|changes
argument_list|,
sizeof|sizeof
argument_list|(
name|change_t
argument_list|)
operator|*
name|changes_allocated
argument_list|)
expr_stmt|;
block|}
name|changes
index|[
name|num_changes
index|]
operator|.
name|object
operator|=
name|object
expr_stmt|;
name|changes
index|[
name|num_changes
index|]
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|changes
index|[
name|num_changes
index|]
operator|.
name|old
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|object
operator|&&
operator|!
name|MEM_P
argument_list|(
name|object
argument_list|)
condition|)
block|{
comment|/* Set INSN_CODE to force rerecognition of insn.  Save old code in 	 case invalid.  */
name|changes
index|[
name|num_changes
index|]
operator|.
name|old_code
operator|=
name|INSN_CODE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|object
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|num_changes
operator|++
expr_stmt|;
comment|/* If we are making a group of changes, return 1.  Otherwise, validate the      change group we made.  */
if|if
condition|(
name|in_group
condition|)
return|return
literal|1
return|;
else|else
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* This subroutine of apply_change_group verifies whether the changes to INSN    were valid; i.e. whether INSN can still be recognized.  */
end_comment

begin_function
name|int
name|insn_invalid_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|num_clobbers
init|=
literal|0
decl_stmt|;
comment|/* If we are before reload and the pattern is a SET, see if we can add      clobbers.  */
name|int
name|icode
init|=
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|reload_in_progress
operator|)
condition|?
operator|&
name|num_clobbers
else|:
literal|0
argument_list|)
decl_stmt|;
name|int
name|is_asm
init|=
name|icode
operator|<
literal|0
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
decl_stmt|;
comment|/* If this is an asm and the operand aren't legal, then fail.  Likewise if      this is not an asm and the insn wasn't recognized.  */
if|if
condition|(
operator|(
name|is_asm
operator|&&
operator|!
name|check_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|is_asm
operator|&&
name|icode
operator|<
literal|0
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If we have to add CLOBBERs, fail if we have to add ones that reference      hard registers since our callers can't know if they are live or not.      Otherwise, add them.  */
if|if
condition|(
name|num_clobbers
operator|>
literal|0
condition|)
block|{
name|rtx
name|newpat
decl_stmt|;
if|if
condition|(
name|added_clobbers_hard_reg_p
argument_list|(
name|icode
argument_list|)
condition|)
return|return
literal|1
return|;
name|newpat
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_clobbers
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|pat
expr_stmt|;
name|add_clobbers
argument_list|(
name|newpat
argument_list|,
name|icode
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
operator|=
name|newpat
expr_stmt|;
block|}
comment|/* After reload, verify that all constraints are satisfied.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|icode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return number of changes made and not validated yet.  */
end_comment

begin_function
name|int
name|num_changes_pending
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|num_changes
return|;
block|}
end_function

begin_comment
comment|/* Tentatively apply the changes numbered NUM and up.    Return 1 if all changes are valid, zero otherwise.  */
end_comment

begin_function
name|int
name|verify_changes
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|last_validated
init|=
name|NULL_RTX
decl_stmt|;
comment|/* The changes have been applied and all INSN_CODEs have been reset to force      rerecognition.       The changes are valid if we aren't given an object, or if we are      given a MEM and it still is a valid address, or if this is in insn      and it is recognized.  In the latter case, if reload has completed,      we also require that the operands meet the constraints for      the insn.  */
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|num_changes
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|object
init|=
name|changes
index|[
name|i
index|]
operator|.
name|object
decl_stmt|;
comment|/* If there is no object to test or if it is the same as the one we          already tested, ignore it.  */
if|if
condition|(
name|object
operator|==
literal|0
operator|||
name|object
operator|==
name|last_validated
condition|)
continue|continue;
if|if
condition|(
name|MEM_P
argument_list|(
name|object
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|insn_invalid_p
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|object
argument_list|)
decl_stmt|;
comment|/* Perhaps we couldn't recognize the insn because there were 	     extra CLOBBERs at the end.  If so, try to re-recognize 	     without the last CLOBBER (later iterations will cause each of 	     them to be eliminated, in turn).  But don't do this if we 	     have an ASM_OPERAND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|newpat
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
condition|)
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|newpat
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Add a new change to this group to replace the pattern 		 with this new pattern.  Then consider this change 		 as having succeeded.  The change we added will 		 cause the entire call to fail if things remain invalid.  		 Note that this can lose if a later change than the one 		 we are processing specified&XVECEXP (PATTERN (object), 0, X) 		 but this shouldn't occur.  */
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
comment|/* If this insn is a CLOBBER or USE, it is always valid, but is 	       never recognized.  */
continue|continue;
else|else
break|break;
block|}
name|last_validated
operator|=
name|object
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|==
name|num_changes
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A group of changes has previously been issued with validate_change and    verified with verify_changes.  Update the BB_DIRTY flags of the affected    blocks, and clear num_changes.  */
end_comment

begin_function
name|void
name|confirm_change_group
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_changes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|changes
index|[
name|i
index|]
operator|.
name|object
operator|&&
name|INSN_P
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|)
condition|)
name|bb
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
name|num_changes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply a group of changes previously issued with `validate_change'.    If all changes are valid, call confirm_change_group and return 1,    otherwise, call cancel_changes and return 0.  */
end_comment

begin_function
name|int
name|apply_change_group
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|verify_changes
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|confirm_change_group
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of changes so far in the current group.  */
end_comment

begin_function
name|int
name|num_validated_changes
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|num_changes
return|;
block|}
end_function

begin_comment
comment|/* Retract the changes numbered NUM and up.  */
end_comment

begin_function
name|void
name|cancel_changes
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Back out all the changes.  Do this in the opposite order in which      they were made.  */
for|for
control|(
name|i
operator|=
name|num_changes
operator|-
literal|1
init|;
name|i
operator|>=
name|num
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|changes
index|[
name|i
index|]
operator|.
name|loc
operator|=
name|changes
index|[
name|i
index|]
operator|.
name|old
expr_stmt|;
if|if
condition|(
name|changes
index|[
name|i
index|]
operator|.
name|object
operator|&&
operator|!
name|MEM_P
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
condition|)
name|INSN_CODE
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|=
name|changes
index|[
name|i
index|]
operator|.
name|old_code
expr_stmt|;
block|}
name|num_changes
operator|=
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace every occurrence of FROM in X with TO.  Mark each change with    validate_change passing OBJECT.  */
end_comment

begin_function
specifier|static
name|void
name|validate_replace_rtx_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
name|object
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|op0_mode
init|=
name|VOIDmode
decl_stmt|;
name|int
name|prev_changes
init|=
name|num_changes
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* X matches FROM if it is the same rtx or they are both referring to the      same register in the same mode.  Avoid calling rtx_equal_p unless the      operands look similar.  */
if|if
condition|(
name|x
operator|==
name|from
operator|||
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|from
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|from
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|from
argument_list|)
operator|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Call ourself recursively to perform the replacements.      We must not replace inside already replaced expression, otherwise we      get infinite recursion for replacements like (reg X)->(subreg (reg X))      done by regmove, so we must special case shared ASM_OPERANDS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|j
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* Verify that operands are really shared.  */
name|gcc_assert
argument_list|(
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|validate_replace_rtx_1
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
else|else
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* If we didn't substitute, there is nothing more to do.  */
if|if
condition|(
name|num_changes
operator|==
name|prev_changes
condition|)
return|return;
comment|/* Allow substituted expression to have different mode.  This is used by      regmove to change mode of pseudo register.  */
if|if
condition|(
name|fmt
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do changes needed to keep rtx consistent.  Don't do any other      simplifications, as it is not our job.  */
if|if
condition|(
name|SWAPPABLE_OPERANDS_P
argument_list|(
name|x
argument_list|)
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|COMMUTATIVE_ARITH_P
argument_list|(
name|x
argument_list|)
condition|?
name|code
else|:
name|swap_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
operator|*
name|loc
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* If we have a PLUS whose second operand is now a CONST_INT, use          simplify_gen_binary to try to simplify it.          ??? We may want later to remove this, once simplification is          separated from this function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|to
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|new
operator|=
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0_mode
argument_list|)
expr_stmt|;
comment|/* If any of the above failed, substitute in something that 	     we know won't be recognized.  */
if|if
condition|(
operator|!
name|new
condition|)
name|new
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* All subregs possible to simplify should be simplified.  */
name|new
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subregs of VOIDmode operands are incorrect.  */
if|if
condition|(
operator|!
name|new
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
name|new
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
comment|/* If we are replacing a register with memory, try to change the memory          to be the mode required for memory in extract operations (this isn't          likely to be an insertion operation; if it was, nothing bad will          happen, we might just fail in some cases).  */
if|if
condition|(
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mode
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|wanted_mode
operator|=
name|new_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|mode_for_extraction
argument_list|(
name|EP_extv
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mode
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|wanted_mode
operator|=
name|new_mode
expr_stmt|;
block|}
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|wanted_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
comment|/* If the bytes and bits are counted differently, we 	         must adjust the offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|adjust_address_nv
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|wanted_mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newmem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO.  After all    changes have been made, validate by seeing if INSN is still valid.  */
end_comment

begin_function
name|int
name|validate_replace_rtx
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|validate_replace_rtx_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO.  */
end_comment

begin_function
name|void
name|validate_replace_rtx_group
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|validate_replace_rtx_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function called by note_uses to replace used subexpressions.  */
end_comment

begin_struct
struct|struct
name|validate_replace_src_data
block|{
name|rtx
name|from
decl_stmt|;
comment|/* Old RTX */
name|rtx
name|to
decl_stmt|;
comment|/* New RTX */
name|rtx
name|insn
decl_stmt|;
comment|/* Insn in which substitution is occurring.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|validate_replace_src_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|validate_replace_src_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|validate_replace_src_data
operator|*
operator|)
name|data
decl_stmt|;
name|validate_replace_rtx_1
argument_list|(
name|x
argument_list|,
name|d
operator|->
name|from
argument_list|,
name|d
operator|->
name|to
argument_list|,
name|d
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO, avoiding    SET_DESTs.  */
end_comment

begin_function
name|void
name|validate_replace_src_group
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|validate_replace_src_data
name|d
decl_stmt|;
name|d
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|d
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|d
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|validate_replace_src_1
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try simplify INSN.    Invoke simplify_rtx () on every SET_SRC and SET_DEST inside the INSN's    pattern and return true if something was simplified.  */
end_comment

begin_function
name|bool
name|validate_simplify_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|pat
init|=
name|NULL
decl_stmt|;
name|rtx
name|newpat
init|=
name|NULL
decl_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|newpat
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpat
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|newpat
argument_list|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpat
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|newpat
argument_list|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|s
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|newpat
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpat
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|s
argument_list|)
argument_list|,
name|newpat
argument_list|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpat
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|,
name|newpat
argument_list|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|s
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|num_changes_pending
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|apply_change_group
argument_list|()
operator|>
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Return 1 if the insn using CC0 set by INSN does not contain    any ordered tests applied to the condition codes.    EQ and NE tests do not count.  */
end_comment

begin_function
name|int
name|next_insn_tests_no_inequality
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|next
init|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If there is no next insn, we have to take the conservative choice.  */
if|if
condition|(
name|next
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|INSN_P
argument_list|(
name|next
argument_list|)
operator|&&
operator|!
name|inequality_comparisons_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is used by find_single_use to locate an rtx that contains exactly one    use of DEST, which is typically either a REG or CC0.  It returns a    pointer to the innermost rtx expression containing DEST.  Appearances of    DEST that are being used to totally replace it are not counted.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_single_use_1
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|this_result
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CLOBBER
case|:
return|return
literal|0
return|;
case|case
name|SET
case|:
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn uses DEST if 	 it is mentioned in the destination or the source.  Otherwise, we 	 need just check the source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
operator|!
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
condition|)
break|break;
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
case|case
name|SUBREG
case|:
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it wasn't one of the common cases above, check each expression and      vector of this code.  Look for a unique usage of DEST.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
operator|(
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
comment|/* Duplicate usage.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|==
name|dest
operator|||
operator|(
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if DEST, produced in INSN, is used only a single time in the    sequel.  If so, return a pointer to the innermost rtx expression in which    it is used.     If PLOC is nonzero, *PLOC is set to the insn containing the single use.     This routine will return usually zero either before flow is called (because    there will be no LOG_LINKS notes) or after reload (because the REG_DEAD    note can't be trusted).     If DEST is cc0_rtx, we look only at the next insn.  In that case, we don't    care about REG_DEAD notes or LOG_LINKS.     Otherwise, we find the single use by finding an insn that has a    LOG_LINKS pointing at INSN and has a REG_DEAD note for DEST.  If DEST is    only referenced once in that insn, we know that it must be the first    and last insn referencing DEST.  */
end_comment

begin_function
name|rtx
modifier|*
name|find_single_use
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|ploc
parameter_list|)
block|{
name|rtx
name|next
decl_stmt|;
name|rtx
modifier|*
name|result
decl_stmt|;
name|rtx
name|link
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
operator|||
operator|(
operator|!
name|NONJUMP_INSN_P
argument_list|(
name|next
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|next
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reload_completed
operator|||
name|reload_in_progress
operator|||
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|next
operator|!=
literal|0
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|next
argument_list|)
condition|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|next
argument_list|)
operator|&&
name|dead_or_set_p
argument_list|(
name|next
argument_list|,
name|dest
argument_list|)
condition|)
block|{
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
break|break;
if|if
condition|(
name|link
condition|)
block|{
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid general operand for machine mode MODE.    This is either a register reference, a memory reference,    or a constant.  In the case of a memory reference, the address    is checked for general validity for the target machine.     Register and memory references must have mode MODE in order to be valid,    but some constants have no machine mode and are valid for any mode.     If MODE is VOIDmode, OP is checked for validity for whatever mode    it has.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     For an explanation of this function's behavior for registers of    class NO_REGS, see the comment for `register_operand'.  */
end_comment

begin_function
name|int
name|general_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
comment|/* Except for certain constants with VOIDmode, already checked for,      OP's mode must match MODE if MODE specifies a mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|sub
init|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* On machines that have insn scheduling, we want all memory 	 reference to be explicit, so outlaw paradoxical SUBREGs. 	 However, we must allow them after reload so that they can 	 get cleaned up by cleanup_subreg_operands.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|MEM_P
argument_list|(
name|sub
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Avoid memories with nonzero SUBREG_BYTE, as offsetting the memory          may result in incorrect reference.  We should simplify all valid          subregs of MEM anyway.  But allow this after reload because we 	 might be called from cleanup_subreg_operands.  	 ??? This is a kludge.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
operator|&&
name|MEM_P
argument_list|(
name|sub
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally 	 create such rtl, and we must reject it.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|sub
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
comment|/* A register whose class is NO_REGS is not a general operand.  */
return|return
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|volatile_ok
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Use the mem's mode, since it will be reloaded thus.  */
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid memory address for a memory reference    of mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|address_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference of mode MODE.    If MODE is VOIDmode, accept a register in any mode.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     As a special exception, registers whose class is NO_REGS are    not accepted by `register_operand'.  The reason for this change    is to allow the representation of special architecture artifacts    (such as a condition code register) without extending the rtl    definitions.  Since registers of class NO_REGS cannot be used    as registers in any case where register classes are examined,    it is most consistent to keep this function from accepting them.  */
end_comment

begin_function
name|int
name|register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|sub
init|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|MEM_P
argument_list|(
name|sub
argument_list|)
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
name|REG_P
argument_list|(
name|sub
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|sub
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_CANNOT_CHANGE_MODE_P
argument_list|(
name|REGNO
argument_list|(
name|sub
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally 	 create such rtl, and we must reject it.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|sub
expr_stmt|;
block|}
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for a register in Pmode; ignore the tested mode.  */
end_comment

begin_function
name|int
name|pmode_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP should match a MATCH_SCRATCH, i.e., if it is a SCRATCH    or a hard register.  */
end_comment

begin_function
name|int
name|scratch_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|||
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid immediate operand for mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|immediate_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a CONST_INT.  */
end_comment

begin_function
name|int
name|const_int_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a constant integer or constant    floating-point number.  */
end_comment

begin_function
name|int
name|const_double_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand that is not an immediate operand.  */
end_comment

begin_function
name|int
name|nonimmediate_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference or immediate value of mode MODE.  */
end_comment

begin_function
name|int
name|nonmemory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Don't accept CONST_INT or anything similar 	 if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|MEM_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for pushing a    value of mode MODE onto the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|push_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|rounded_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|rounded_size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|rounded_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rounded_size
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_PUSH_CODE
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PRE_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|-
operator|(
name|int
operator|)
name|rounded_size
else|#
directive|else
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|rounded_size
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
block|}
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for popping a    value of mode MODE off the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|pop_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POP_CODE
condition|)
return|return
literal|0
return|;
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is a valid memory address for mode MODE.  */
end_comment

begin_function
name|int
name|memory_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid memory reference with mode MODE,    including a valid address.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|inner
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
comment|/* Note that no SUBREG is a memory operand before end of reload pass,        because (SUBREG (MEM...)) forces reloading into a register.  */
return|return
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
operator|(
name|MEM_P
argument_list|(
name|inner
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid indirect memory reference with mode MODE;    that is, a memory reference whose address is a general_operand.  */
end_comment

begin_function
name|int
name|indirect_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* Before reload, a SUBREG isn't in memory (see memory_operand, above).  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|MEM_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
comment|/* The only way that we can have a general_operand as the resulting 	 address is if OFFSET is zero and the address already is an operand 	 or if the address is (plus Y (const_int -OFFSET)) and Y is an 	 operand.  */
return|return
operator|(
operator|(
name|offset
operator|==
literal|0
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|offset
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator.  This allows the use of    MATCH_OPERATOR to recognize all the branch insns.  */
end_comment

begin_function
name|int
name|comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
name|COMPARISON_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If BODY is an insn body that uses ASM_OPERANDS,    return the number of operands (both input and output) in the insn.    Otherwise return -1.  */
end_comment

begin_function
name|int
name|asm_noperands
parameter_list|(
name|rtx
name|body
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|ASM_OPERANDS
case|:
comment|/* No output operands: return number of input operands.  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
return|;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|PARALLEL
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* Multiple output operands, or 1 output plus some clobbers: 	     body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
name|int
name|n_sets
decl_stmt|;
comment|/* Count backwards through CLOBBERs to determine number of SETs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* N_SETS is now number of output operands.  */
name|n_sets
operator|=
name|i
expr_stmt|;
comment|/* Verify that all the SETs we have 	     came from a single original asm_operands insn 	     (so that invalid combinations are blocked).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If these ASM_OPERANDS rtx's came from different original insns 	         then they aren't allowed together.  */
if|if
condition|(
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|n_sets
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* 0 outputs, but some clobbers: 	     body is [(asm_operands ...) (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
comment|/* Make sure all the other parallel things really are clobbers.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Assuming BODY is an insn body that uses ASM_OPERANDS,    copy its operands (both input and output) into the vector OPERANDS,    the locations of the operands within the insn into the vector OPERAND_LOCS,    and the constraints for the operands into CONSTRAINTS.    Write the modes of the operands into MODES.    Return the assembler-template.     If MODES, OPERAND_LOCS, CONSTRAINTS or OPERANDS is 0,    we don't store that info.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|decode_asm_operands
parameter_list|(
name|rtx
name|body
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
modifier|*
modifier|*
name|operand_locs
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|constraints
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|modes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|noperands
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ....)).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The output is in the SET. 	 Its constraint is in the ASM_OPERANDS itself.  */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
literal|0
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
literal|0
index|]
operator|=
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
literal|0
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|body
decl_stmt|;
comment|/* No output operands: BODY is (asm_operands ....).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nparallel
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Includes CLOBBERs.  */
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
name|int
name|nout
init|=
literal|0
decl_stmt|;
comment|/* Does not include CLOBBERs.  */
comment|/* At least one output, plus some CLOBBERs.  */
comment|/* The outputs are in the SETs. 	 Their constraints are in the ASM_OPERANDS itself.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparallel
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
comment|/* Past last SET */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nout
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
operator|+
name|nout
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* No outputs, but some CLOBBERs.  */
name|rtx
name|asmop
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
return|return
name|template
return|;
block|}
end_function

begin_comment
comment|/* Check if an asm_operand matches its constraints.    Return> 0 if ok, = 0 if bad,< 0 if inconclusive.  */
end_comment

begin_function
name|int
name|asm_operand_ok
parameter_list|(
name|rtx
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|constraint
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Use constrain_operands after reload.  */
name|gcc_assert
argument_list|(
operator|!
name|reload_completed
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|constraint
condition|)
block|{
name|char
name|c
init|=
operator|*
name|constraint
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|','
case|:
name|constraint
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'!'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'?'
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* For best results, our caller should have given us the 	     proper matching constraint, but we can't actually fail 	     the check if they didn't.  Indicate that results are 	     inconclusive.  */
do|do
name|constraint
operator|++
expr_stmt|;
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|constraint
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
name|address_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'V'
case|:
comment|/* non-offsettable */
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* offsettable */
if|if
condition|(
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
comment|/* ??? Before flow, auto inc/dec insns are not supposed to exist, 	     excepting those that expand_call created.  Further, on some 	     machines which do not have generalized auto inc/dec, an inc/dec 	     is not a memory_operand.  	     Match any memory and hope things are resolved after reload.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_CONSTRAINT_P
argument_list|(
name|op
argument_list|,
literal|'G'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_CONSTRAINT_P
argument_list|(
name|op
argument_list|,
literal|'H'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'J'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'M'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'N'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'O'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'P'
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* For all other letters, we first check for a register class, 	     otherwise it is an EXTRA_CONSTRAINT.  */
if|if
condition|(
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|constraint
argument_list|)
operator|!=
name|NO_REGS
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|BLKmode
condition|)
break|break;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT_STR
elseif|else
if|if
condition|(
name|EXTRA_CONSTRAINT_STR
argument_list|(
name|op
argument_list|,
name|c
argument_list|,
name|constraint
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|EXTRA_MEMORY_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|constraint
argument_list|)
comment|/* Every memory operand can be reloaded to fit.  */
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|EXTRA_ADDRESS_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|constraint
argument_list|)
comment|/* Every address operand can be reloaded to fit.  */
operator|&&
name|address_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|len
operator|=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
do|do
name|constraint
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|len
operator|&&
operator|*
name|constraint
condition|)
do|;
if|if
condition|(
name|len
condition|)
return|return
literal|0
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx *P, if it is a sum containing an integer constant term,    return the location (type rtx *) of the pointer to that constant term.    Otherwise, return a null pointer.  */
end_comment

begin_function
name|rtx
modifier|*
name|find_constant_term_loc
parameter_list|(
name|rtx
modifier|*
name|p
parameter_list|)
block|{
name|rtx
modifier|*
name|tem
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
comment|/* If *P IS such a constant term, P is its location.  */
if|if
condition|(
name|code
operator|==
name|CONST_INT
operator|||
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
operator|||
name|code
operator|==
name|CONST
condition|)
return|return
name|p
return|;
comment|/* Otherwise, if not a sum, it has no constant term.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
comment|/* If one of the summands is constant, return its location.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|p
return|;
comment|/* Otherwise, check each summand for containing a constant term.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a memory reference    whose address contains no side effects    and remains valid after the addition    of a positive integer less than the    size of the object being referenced.     We assume that the original address is valid and do not check it.     This uses strict_memory_address_p as a subroutine, so    don't use it before reload.  */
end_comment

begin_function
name|int
name|offsettable_memref_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
return|return
operator|(
operator|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but don't require a strictly valid mem ref:    consider pseudo-regs valid as index or base regs.  */
end_comment

begin_function
name|int
name|offsettable_nonstrict_memref_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
return|return
operator|(
operator|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if Y is a memory address which contains no side effects    and would remain valid after the addition of a positive integer    less than the size of that mode.     We assume that the original address is valid and do not check it.    We do check that it is valid for narrower modes.     If STRICTP is nonzero, we require a strictly valid address,    for the sake of use in reload.c.  */
end_comment

begin_function
name|int
name|offsettable_address_p
parameter_list|(
name|int
name|strictp
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|rtx_code
name|ycode
init|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|rtx
name|z
decl_stmt|;
name|rtx
name|y1
init|=
name|y
decl_stmt|;
name|rtx
modifier|*
name|y2
decl_stmt|;
name|int
function_decl|(
modifier|*
name|addressp
function_decl|)
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
init|=
operator|(
name|strictp
condition|?
name|strict_memory_address_p
operator|:
name|memory_address_p
init|)
function_decl|;
name|unsigned
name|int
name|mode_sz
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Adjusting an offsettable address involves changing to a narrower mode.      Make sure that's OK.  */
if|if
condition|(
name|mode_dependent_address_p
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ??? How much offset does an offsettable BLKmode reference need?      Clearly that depends on the situation in which it's being used.      However, the current situation in which we test 0xffffffff is      less than ideal.  Caveat user.  */
if|if
condition|(
name|mode_sz
operator|==
literal|0
condition|)
name|mode_sz
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* If the expression contains a constant term,      see if it remains valid when max possible offset is added.  */
if|if
condition|(
operator|(
name|ycode
operator|==
name|PLUS
operator|)
operator|&&
operator|(
name|y2
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|y1
argument_list|)
operator|)
condition|)
block|{
name|int
name|good
decl_stmt|;
name|y1
operator|=
operator|*
name|y2
expr_stmt|;
operator|*
name|y2
operator|=
name|plus_constant
argument_list|(
operator|*
name|y2
argument_list|,
name|mode_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid 	 for any wider mode.  But it should be valid for a single byte.  */
name|good
operator|=
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* In any case, restore old contents of memory.  */
operator|*
name|y2
operator|=
name|y1
expr_stmt|;
return|return
name|good
return|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|ycode
argument_list|)
operator|==
name|RTX_AUTOINC
condition|)
return|return
literal|0
return|;
comment|/* The offset added here is chosen as the maximum offset that      any instruction could need to add when operating on something      of the specified mode.  We assume that if Y and Y+c are      valid addresses then so is Y+d for all 0<d<c.  adjust_address will      go inside a LO_SUM here, so we do so as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode_sz
operator|<=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
condition|)
name|z
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode_sz
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|z
operator|=
name|plus_constant
argument_list|(
name|y
argument_list|,
name|mode_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid      for any wider mode.  But it should be valid for a single byte.  */
return|return
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|z
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is an address-expression whose effect depends    on the mode of the memory reference it is used in.     Autoincrement addressing is a typical example of mode-dependence    because the amount of the increment depends on the mode.  */
end_comment

begin_function
name|int
name|mode_dependent_address_p
parameter_list|(
name|rtx
name|addr
name|ATTRIBUTE_UNUSED
comment|/* Maybe used in GO_IF_MODE_DEPENDENT_ADDRESS.  */
parameter_list|)
block|{
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Label `win' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS.  */
name|win
label|:
name|ATTRIBUTE_UNUSED_LABEL
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like extract_insn, but save insn extracted and don't extract again, when    called again for the same insn expecting that recog_data still contain the    valid information.  This is used primary by gen_attr infrastructure that    often does extract insn again and again.  */
end_comment

begin_function
name|void
name|extract_insn_cached
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_data
operator|.
name|insn
operator|==
name|insn
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|recog_data
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do cached extract_insn, constrain_operands and complain about failures.    Used by insn_attrtab.  */
end_comment

begin_function
name|void
name|extract_constrain_insn_cached
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_alternative
operator|==
operator|-
literal|1
operator|&&
operator|!
name|constrain_operands
argument_list|(
name|reload_completed
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do cached constrain_operands and complain about failures.  */
end_comment

begin_function
name|int
name|constrain_operands_cached
parameter_list|(
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
name|which_alternative
operator|==
operator|-
literal|1
condition|)
return|return
name|constrain_operands
argument_list|(
name|strict
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Analyze INSN and fill in recog_data.  */
end_comment

begin_function
name|void
name|extract_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|recog_data
operator|.
name|insn
operator|=
name|NULL
expr_stmt|;
name|recog_data
operator|.
name|n_operands
operator|=
literal|0
expr_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
literal|0
expr_stmt|;
name|recog_data
operator|.
name|n_dups
operator|=
literal|0
expr_stmt|;
name|which_alternative
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
goto|goto
name|asm_insn
goto|;
else|else
goto|goto
name|normal_insn
goto|;
case|case
name|PARALLEL
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
goto|goto
name|asm_insn
goto|;
else|else
goto|goto
name|normal_insn
goto|;
case|case
name|ASM_OPERANDS
case|:
name|asm_insn
label|:
name|recog_data
operator|.
name|n_operands
operator|=
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  */
comment|/* expand_asm_operands makes sure there aren't too many operands.  */
name|gcc_assert
argument_list|(
name|noperands
operator|<=
name|MAX_RECOG_OPERANDS
argument_list|)
expr_stmt|;
comment|/* Now get the operand values and constraints out of the insn.  */
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|,
name|recog_data
operator|.
name|operand_loc
argument_list|,
name|recog_data
operator|.
name|constraints
argument_list|,
name|recog_data
operator|.
name|operand_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_data
operator|.
name|constraints
index|[
literal|0
index|]
decl_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|recog_data
operator|.
name|n_alternatives
operator|+=
operator|(
operator|*
name|p
operator|++
operator|==
literal|','
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
default|default:
name|normal_insn
label|:
comment|/* Ordinary insn: recognize it, get the operands via insn_extract 	 and get the constraints.  */
name|icode
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|<
literal|0
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|recog_data
operator|.
name|n_operands
operator|=
name|noperands
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_operands
expr_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_alternatives
expr_stmt|;
name|recog_data
operator|.
name|n_dups
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_dups
expr_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|constraint
expr_stmt|;
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|mode
expr_stmt|;
comment|/* VOIDmode match_operands gets mode from their real operand.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|==
name|VOIDmode
condition|)
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|=
operator|(
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|?
name|OP_OUT
else|:
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|?
name|OP_INOUT
else|:
name|OP_IN
operator|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|<=
name|MAX_RECOG_ALTERNATIVES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After calling extract_insn, you can use this function to extract some    information from the constraint strings into a more usable form.    The collected data is stored in recog_op_alt.  */
end_comment

begin_function
name|void
name|preprocess_constraints
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
name|memset
argument_list|(
name|recog_op_alt
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|operand_alternative
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|operand_alternative
modifier|*
name|op_alt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
decl_stmt|;
name|op_alt
operator|=
name|recog_op_alt
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|j
operator|++
control|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
operator|=
name|NO_REGS
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|constraint
operator|=
name|p
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
operator|=
operator|-
literal|1
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matched
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|anything_ok
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
do|do
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'?'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|reject
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|reject
operator|+=
literal|600
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|earlyclobber
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|recog_op_alt
index|[
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
index|]
index|[
name|j
index|]
operator|.
name|matched
operator|=
name|i
expr_stmt|;
name|p
operator|=
name|end
expr_stmt|;
block|}
continue|continue;
case|case
literal|'m'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|memory_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|decmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|incmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|nonoffmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|offmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|anything_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|is_address
operator|=
literal|1
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
index|]
index|[
operator|(
name|int
operator|)
name|base_reg_class
argument_list|(
name|VOIDmode
argument_list|,
name|ADDRESS
argument_list|,
name|SCRATCH
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|EXTRA_MEMORY_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|memory_ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EXTRA_ADDRESS_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|is_address
operator|=
literal|1
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
operator|=
operator|(
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
index|]
index|[
operator|(
name|int
operator|)
name|base_reg_class
argument_list|(
name|VOIDmode
argument_list|,
name|ADDRESS
argument_list|,
name|SCRATCH
argument_list|)
index|]
operator|)
expr_stmt|;
break|break;
block|}
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
operator|=
operator|(
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|cl
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|,
name|p
argument_list|)
index|]
operator|)
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check the operands of an insn against the insn's operand constraints    and return 1 if they are valid.    The information about the insn's operands, constraints, operand modes    etc. is obtained from the global variables set up by extract_insn.     WHICH_ALTERNATIVE is set to a number which indicates which    alternative of constraints was matched: 0 for the first alternative,    1 for the next, etc.     In addition, when two operands are required to match    and it happens that the output operand is (reg) while the    input operand is --(reg) or ++(reg) (a pre-inc or pre-dec),    make the output operand look like the input.    This is because the output operand is the one the template will print.     This is used in final, just before printing the assembler code and by    the routines that determine an insn's attribute.     If STRICT is a positive nonzero value, it means that we have been    called after reload has been completed.  In that case, we must    do all checks strictly.  If it is zero, it means that we have been called    before reload has completed.  In that case, we first try to see if we can    find an alternative that matches strictly.  If not, we try again, this    time assuming that reload will fix up the insn.  This provides a "best    guess" for the alternative and is used to compute attributes of insns prior    to reload.  A negative value of STRICT is used for this internal call.  */
end_comment

begin_struct
struct|struct
name|funny_match
block|{
name|int
name|this
decl_stmt|,
name|other
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|constrain_operands
parameter_list|(
name|int
name|strict
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|matching_operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|funny_match
name|funny_match
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|funny_match_index
decl_stmt|;
name|which_alternative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|n_operands
operator|==
literal|0
operator|||
name|recog_data
operator|.
name|n_alternatives
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|c
operator|++
control|)
block|{
name|constraints
index|[
name|c
index|]
operator|=
name|recog_data
operator|.
name|constraints
index|[
name|c
index|]
expr_stmt|;
name|matching_operands
index|[
name|c
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
do|do
block|{
name|int
name|seen_earlyclobber_at
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|opno
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|funny_match_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
name|rtx
name|op
init|=
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|opno
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|len
decl_stmt|;
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* A unary operator may be accepted by the predicate, but it 	     is irrelevant for matching constraints.  */
if|if
condition|(
name|UNARY_P
argument_list|(
name|op
argument_list|)
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
expr_stmt|;
do|do
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|,
name|len
operator|=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
operator|,
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|c
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
break|break;
case|case
literal|'#'
case|:
comment|/* Ignore rest of this alternative as far as 		   constraint checking is concerned.  */
do|do
name|p
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
do|;
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|seen_earlyclobber_at
operator|<
literal|0
condition|)
name|seen_earlyclobber_at
operator|=
name|opno
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
comment|/* This operand must be the same as a previous one. 		     This kind of constraint is used for instructions such 		     as add when they take only two operands.  		     Note that the lower-numbered operand is passed first.  		     If we are not testing strictly, assume that this 		     constraint will be satisfied.  */
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
name|val
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|rtx
name|op1
init|=
name|recog_data
operator|.
name|operand
index|[
name|match
index|]
decl_stmt|;
name|rtx
name|op2
init|=
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
decl_stmt|;
comment|/* A unary operator may be accepted by the predicate, 			 but it is irrelevant for matching constraints.  */
if|if
condition|(
name|UNARY_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNARY_P
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|operands_match_p
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
name|matching_operands
index|[
name|opno
index|]
operator|=
name|match
expr_stmt|;
name|matching_operands
index|[
name|match
index|]
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* If output is *x and input is *--x, arrange later 		     to change the output to *--x as well, since the 		     output op is the one that will be printed.  */
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|strict
operator|>
literal|0
condition|)
block|{
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
operator|=
name|opno
expr_stmt|;
name|funny_match
index|[
name|funny_match_index
operator|++
index|]
operator|.
name|other
operator|=
name|match
expr_stmt|;
block|}
block|}
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* p is used for address_operands.  When we are called by 		   gen_reload, no one will have checked that the address is 		   strictly valid, i.e., that all pseudos requiring hard regs 		   have gotten them.  */
if|if
condition|(
name|strict
operator|<=
literal|0
operator|||
operator|(
name|strict_memory_address_p
argument_list|(
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|op
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* No need to check general_operand again; 		   it was done in insn-recog.c.  Well, except that reload 		   doesn't check the validity of its replacements, but 		   that should only matter when there's a bug.  */
case|case
literal|'g'
case|:
comment|/* Anything goes unless it is a REG and really has a hard reg 		   but the hard reg is not in the class GENERAL_REGS.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
operator|(
name|reload_in_progress
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used for a MATCH_SCRATCH in the cases when 		   we don't actually need anything.  So anything goes 		   any time.  */
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Memory operands must be valid, to the extent 		   required by STRICT.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
operator|&&
operator|!
name|strict_memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strict
operator|==
literal|0
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
name|win
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Before reload, accept what reload can turn into mem.  */
elseif|else
if|if
condition|(
name|strict
operator|<
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* During reload, accept a pseudo  */
elseif|else
if|if
condition|(
name|reload_in_progress
operator|&&
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_CONSTRAINT_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|,
name|p
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|,
name|p
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|(
name|strict
operator|>
literal|0
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
operator|!
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|strict
operator|>
literal|0
operator|&&
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
operator|)
comment|/* Before reload, accept what reload can handle.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
block|{
name|enum
name|reg_class
name|cl
decl_stmt|;
name|cl
operator|=
operator|(
name|c
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cl
operator|!=
name|NO_REGS
condition|)
block|{
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|cl
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT_STR
elseif|else
if|if
condition|(
name|EXTRA_CONSTRAINT_STR
argument_list|(
name|op
argument_list|,
name|c
argument_list|,
name|p
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|EXTRA_MEMORY_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
comment|/* Every memory operand can be reloaded to fit.  */
operator|&&
operator|(
operator|(
name|strict
operator|<
literal|0
operator|&&
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|)
comment|/* Before reload, accept what reload can turn 				  into mem.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|EXTRA_ADDRESS_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
comment|/* Every address operand can be reloaded to fit.  */
operator|&&
name|strict
operator|<
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
do|while
condition|(
name|p
operator|+=
name|len
operator|,
name|c
condition|)
do|;
name|constraints
index|[
name|opno
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand did not win somehow, 	     this alternative loses.  */
if|if
condition|(
operator|!
name|win
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This alternative won; the operands are ok. 	 Change whichever operands this alternative says to change.  */
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|int
name|opno
decl_stmt|,
name|eopno
decl_stmt|;
comment|/* See if any earlyclobber operand conflicts with some other 	     operand.  */
if|if
condition|(
name|strict
operator|>
literal|0
operator|&&
name|seen_earlyclobber_at
operator|>=
literal|0
condition|)
for|for
control|(
name|eopno
operator|=
name|seen_earlyclobber_at
init|;
name|eopno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|eopno
operator|++
control|)
comment|/* Ignore earlyclobber operands now in memory, 		 because we would often report failure when we have 		 two memory operands, one of which was formerly a REG.  */
if|if
condition|(
name|earlyclobber
index|[
name|eopno
index|]
operator|&&
name|REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|eopno
index|]
argument_list|)
condition|)
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
if|if
condition|(
operator|(
name|MEM_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|)
operator|||
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|!=
name|OP_OUT
operator|)
operator|&&
name|opno
operator|!=
name|eopno
comment|/* Ignore things like match_operator operands.  */
operator|&&
operator|*
name|recog_data
operator|.
name|constraints
index|[
name|opno
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|matching_operands
index|[
name|opno
index|]
operator|==
name|eopno
operator|&&
name|operands_match_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|eopno
index|]
argument_list|)
operator|)
operator|&&
operator|!
name|safe_from_earlyclobber
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|eopno
index|]
argument_list|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
condition|)
block|{
while|while
condition|(
operator|--
name|funny_match_index
operator|>=
literal|0
condition|)
block|{
name|recog_data
operator|.
name|operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|other
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
name|which_alternative
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|which_alternative
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|)
do|;
name|which_alternative
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we are about to reject this, but we are not to test strictly,      try a very loose test.  Only return failure if it fails also.  */
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|constrain_operands
argument_list|(
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff OPERAND (assumed to be a REG rtx)    is a hard reg in class CLASS when its regno is offset by OFFSET    and changed to mode MODE.    If REG occupies multiple hard regs, all of them must be in CLASS.  */
end_comment

begin_function
name|int
name|reg_fits_class_p
parameter_list|(
name|rtx
name|operand
parameter_list|,
name|enum
name|reg_class
name|cl
parameter_list|,
name|int
name|offset
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|cl
operator|==
name|NO_REGS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|cl
index|]
argument_list|,
name|regno
operator|+
name|offset
argument_list|)
condition|)
block|{
name|int
name|sr
decl_stmt|;
name|regno
operator|+=
name|offset
expr_stmt|;
for|for
control|(
name|sr
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
operator|-
literal|1
init|;
name|sr
operator|>
literal|0
condition|;
name|sr
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|cl
index|]
argument_list|,
name|regno
operator|+
name|sr
argument_list|)
condition|)
break|break;
return|return
name|sr
operator|==
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split single instruction.  Helper function for split_all_insns and    split_all_insns_noflow.  Return last insn in the sequence if successful,    or NULL if unsuccessful.  */
end_comment

begin_function
specifier|static
name|rtx
name|split_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* Split insns here to get max fine-grain parallelism.  */
name|rtx
name|first
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|==
name|insn
condition|)
return|return
name|NULL_RTX
return|;
comment|/* try_split returns the NOTE that INSN became.  */
name|SET_INSN_DELETED
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? Coddle to md files that generate subregs in post-reload      splitters instead of computing the proper hard register.  */
if|if
condition|(
name|reload_completed
operator|&&
name|first
operator|!=
name|last
condition|)
block|{
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|first
argument_list|)
condition|)
name|cleanup_subreg_operands
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
break|break;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Split all insns in the function.  If UPD_LIFE, update life info after.  */
end_comment

begin_function
name|void
name|split_all_insns
parameter_list|(
name|int
name|upd_life
parameter_list|)
block|{
name|sbitmap
name|blocks
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|bool
name|finish
init|=
name|false
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|finish
condition|;
name|insn
operator|=
name|next
control|)
block|{
comment|/* Can't use `next_real_insn' because that might go across 	     CODE_LABELS and short-out basic blocks.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|finish
operator|=
operator|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Don't split no-op move insns.  These should silently 		 disappear later in final.  Splitting such insns would 		 break the code that handles REG_NO_CONFLICT blocks.  */
if|if
condition|(
name|set
operator|&&
name|set_noop_p
argument_list|(
name|set
argument_list|)
condition|)
block|{
comment|/* Nops get in the way while scheduling, so delete them 		     now if register allocation has already been done.  It 		     is too risky to try to do this before register 		     allocation, and there are unlikely to be very many 		     nops then anyways.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
comment|/* If the no-op set has a REG_UNUSED note, we need 			 to update liveness information.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
comment|/* ??? Is life info affected by deleting edges?  */
name|delete_insn_and_edges
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|last
init|=
name|split_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
condition|)
block|{
comment|/* The split sequence may include barrier, but the 			 BB boundary we are interested in will be set to 			 previous one.  */
while|while
condition|(
name|BARRIER_P
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|old_last_basic_block
init|=
name|last_basic_block
decl_stmt|;
name|find_many_sub_basic_blocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_last_basic_block
operator|!=
name|last_basic_block
operator|&&
name|upd_life
condition|)
name|blocks
operator|=
name|sbitmap_resize
argument_list|(
name|blocks
argument_list|,
name|last_basic_block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|upd_life
condition|)
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as split_all_insns, but do not expect CFG to be available.    Used by machine dependent reorg passes.  */
end_comment

begin_function
name|unsigned
name|int
name|split_all_insns_noflow
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|next
decl_stmt|,
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Don't split no-op move insns.  These should silently 	     disappear later in final.  Splitting such insns would 	     break the code that handles REG_NO_CONFLICT blocks.  */
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|set_noop_p
argument_list|(
name|set
argument_list|)
condition|)
block|{
comment|/* Nops get in the way while scheduling, so delete them 		 now if register allocation has already been done.  It 		 is too risky to try to do this before register 		 allocation, and there are unlikely to be very many 		 nops then anyways.  		 ??? Should we use delete_insn when the CFG isn't valid?  */
if|if
condition|(
name|reload_completed
condition|)
name|delete_insn_and_edges
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|split_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_peephole2
end_ifdef

begin_struct
struct|struct
name|peep2_insn_data
block|{
name|rtx
name|insn
decl_stmt|;
name|regset
name|live_before
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|peep2_insn_data
name|peep2_insn_data
index|[
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|peep2_current
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of instructions available to match a peep2.  */
end_comment

begin_decl_stmt
name|int
name|peep2_current_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A non-insn marker indicating the last insn of the block.    The live_before regset for this element is correct, indicating    global_live_at_end for the block.  */
end_comment

begin_define
define|#
directive|define
name|PEEP2_EOB
value|pc_rtx
end_define

begin_comment
comment|/* Return the Nth non-note insn after `current', or return NULL_RTX if it    does not exist.  Used by the recognizer to find the next insn to match    in a multi-insn pattern.  */
end_comment

begin_function
name|rtx
name|peep2_next_insn
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|n
operator|<=
name|peep2_current_count
argument_list|)
expr_stmt|;
name|n
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|n
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
return|return
name|peep2_insn_data
index|[
name|n
index|]
operator|.
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGNO is dead before the Nth non-note insn    after `current'.  */
end_comment

begin_function
name|int
name|peep2_regno_dead_p
parameter_list|(
name|int
name|ofs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|ofs
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ofs
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|ofs
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|ofs
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|insn
operator|!=
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|live_before
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similarly for a REG.  */
end_comment

begin_function
name|int
name|peep2_reg_dead_p
parameter_list|(
name|int
name|ofs
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|n
decl_stmt|;
name|gcc_assert
argument_list|(
name|ofs
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ofs
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|ofs
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|ofs
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|insn
operator|!=
name|NULL_RTX
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|n
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|live_before
argument_list|,
name|regno
operator|+
name|n
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Try to find a hard register of mode MODE, matching the register class in    CLASS_STR, which is available at the beginning of insn CURRENT_INSN and    remains available until the end of LAST_INSN.  LAST_INSN may be NULL_RTX,    in which case the only condition is that the register must be available    before CURRENT_INSN.    Registers that already have bits set in REG_SET will not be considered.     If an appropriate register is available, it will be returned and the    corresponding bit(s) in REG_SET will be set; otherwise, NULL_RTX is    returned.  */
end_comment

begin_function
name|rtx
name|peep2_find_free_register
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|class_str
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HARD_REG_SET
modifier|*
name|reg_set
parameter_list|)
block|{
specifier|static
name|int
name|search_ofs
decl_stmt|;
name|enum
name|reg_class
name|cl
decl_stmt|;
name|HARD_REG_SET
name|live
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|from
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|to
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|from
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|from
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|from
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|to
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|to
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|to
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|insn
operator|!=
name|NULL_RTX
argument_list|)
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
while|while
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|HARD_REG_SET
name|this_live
decl_stmt|;
if|if
condition|(
operator|++
name|from
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|from
operator|=
literal|0
expr_stmt|;
name|gcc_assert
argument_list|(
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|insn
operator|!=
name|NULL_RTX
argument_list|)
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|this_live
argument_list|,
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|this_live
argument_list|)
expr_stmt|;
block|}
name|cl
operator|=
operator|(
name|class_str
index|[
literal|0
index|]
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|class_str
index|[
literal|0
index|]
argument_list|,
name|class_str
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|raw_regno
decl_stmt|,
name|regno
decl_stmt|,
name|success
decl_stmt|,
name|j
decl_stmt|;
comment|/* Distribute the free registers as much as possible.  */
name|raw_regno
operator|=
name|search_ofs
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|raw_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|raw_regno
operator|-=
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|regno
operator|=
name|reg_alloc_order
index|[
name|raw_regno
index|]
expr_stmt|;
else|#
directive|else
name|regno
operator|=
name|raw_regno
expr_stmt|;
endif|#
directive|endif
comment|/* Don't allocate fixed registers.  */
if|if
condition|(
name|fixed_regs
index|[
name|regno
index|]
condition|)
continue|continue;
comment|/* Make sure the register is of the right class.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|cl
index|]
argument_list|,
name|regno
argument_list|)
condition|)
continue|continue;
comment|/* And can support the mode we need.  */
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
comment|/* And that we don't create an extra save/restore.  */
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|regs_ever_live
index|[
name|regno
index|]
condition|)
continue|continue;
comment|/* And we don't clobber traceback for noreturn functions.  */
if|if
condition|(
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
condition|)
continue|continue;
name|success
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|reg_set
argument_list|,
name|regno
operator|+
name|j
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|live
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
block|{
for|for
control|(
name|j
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|reg_set
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
comment|/* Start the next search with the next register.  */
if|if
condition|(
operator|++
name|raw_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|raw_regno
operator|=
literal|0
expr_stmt|;
name|search_ofs
operator|=
name|raw_regno
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
block|}
name|search_ofs
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Perform the peephole2 optimization pass.  */
end_comment

begin_function
specifier|static
name|void
name|peephole2_optimize
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|sbitmap
name|blocks
decl_stmt|;
name|bool
name|changed
decl_stmt|;
endif|#
directive|endif
name|bool
name|do_cleanup_cfg
init|=
name|false
decl_stmt|;
name|bool
name|do_global_life_update
init|=
name|false
decl_stmt|;
name|bool
name|do_rebuild_jump_labels
init|=
name|false
decl_stmt|;
comment|/* Initialize the regsets we're going to use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|live
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
else|#
directive|else
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|propagate_block_info
modifier|*
name|pbi
decl_stmt|;
name|reg_set_iterator
name|rsi
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* Indicate that all slots except the last holds invalid data.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
condition|;
operator|++
name|i
control|)
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
name|peep2_current_count
operator|=
literal|0
expr_stmt|;
comment|/* Indicate that the last slot contains live_after data.  */
name|peep2_insn_data
index|[
name|MAX_INSNS_PER_PEEP2
index|]
operator|.
name|insn
operator|=
name|PEEP2_EOB
expr_stmt|;
name|peep2_current
operator|=
name|MAX_INSNS_PER_PEEP2
expr_stmt|;
comment|/* Start up propagation.  */
name|COPY_REG_SET
argument_list|(
name|live
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|MAX_INSNS_PER_PEEP2
index|]
operator|.
name|live_before
argument_list|,
name|live
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|bb
argument_list|,
name|live
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|bb
argument_list|,
name|live
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|try
decl_stmt|,
name|before_try
decl_stmt|,
name|x
decl_stmt|;
name|int
name|match_len
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|bool
name|was_call
init|=
name|false
decl_stmt|;
comment|/* Record this insn.  */
if|if
condition|(
operator|--
name|peep2_current
operator|<
literal|0
condition|)
name|peep2_current
operator|=
name|MAX_INSNS_PER_PEEP2
expr_stmt|;
if|if
condition|(
name|peep2_current_count
operator|<
name|MAX_INSNS_PER_PEEP2
operator|&&
name|peep2_insn_data
index|[
name|peep2_current
index|]
operator|.
name|insn
operator|==
name|NULL_RTX
condition|)
name|peep2_current_count
operator|++
expr_stmt|;
name|peep2_insn_data
index|[
name|peep2_current
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|peep2_current
index|]
operator|.
name|live_before
argument_list|,
name|live
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an insn has RTX_FRAME_RELATED_P set, peephole 		     substitution would lose the 		     REG_FRAME_RELATED_EXPR that is attached.  */
name|peep2_current_count
operator|=
literal|0
expr_stmt|;
name|try
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* Match the peephole.  */
name|try
operator|=
name|peephole2_insns
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
operator|&
name|match_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|!=
name|NULL
condition|)
block|{
comment|/* If we are splitting a CALL_INSN, look for the CALL_INSN 		     in SEQ and copy our CALL_INSN_FUNCTION_USAGE and other 		     cfg-related call notes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|match_len
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
name|rtx
name|old_insn
decl_stmt|,
name|new_insn
decl_stmt|,
name|note
decl_stmt|;
name|j
operator|=
name|i
operator|+
name|peep2_current
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|j
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|old_insn
operator|=
name|peep2_insn_data
index|[
name|j
index|]
operator|.
name|insn
expr_stmt|;
if|if
condition|(
operator|!
name|CALL_P
argument_list|(
name|old_insn
argument_list|)
condition|)
continue|continue;
name|was_call
operator|=
name|true
expr_stmt|;
name|new_insn
operator|=
name|try
expr_stmt|;
while|while
condition|(
name|new_insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|new_insn
argument_list|)
condition|)
break|break;
name|new_insn
operator|=
name|NEXT_INSN
argument_list|(
name|new_insn
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|new_insn
operator|!=
name|NULL_RTX
argument_list|)
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|new_insn
argument_list|)
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|old_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|old_insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_NORETURN
case|:
case|case
name|REG_SETJMP
case|:
name|REG_NOTES
argument_list|(
name|new_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|new_insn
argument_list|)
argument_list|)
expr_stmt|;
default|default:
comment|/* Discard all other reg notes.  */
break|break;
block|}
comment|/* Croak if there is another call in the sequence.  */
while|while
condition|(
operator|++
name|i
operator|<=
name|match_len
condition|)
block|{
name|j
operator|=
name|i
operator|+
name|peep2_current
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|j
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|old_insn
operator|=
name|peep2_insn_data
index|[
name|j
index|]
operator|.
name|insn
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|CALL_P
argument_list|(
name|old_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|i
operator|=
name|match_len
operator|+
name|peep2_current
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|i
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Replace the old sequence with the new.  */
name|try
operator|=
name|emit_insn_after_setloc
argument_list|(
name|try
argument_list|,
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|before_try
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|insn
argument_list|,
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
comment|/* Re-insert the EH_REGION notes.  */
if|if
condition|(
name|note
operator|||
operator|(
name|was_call
operator|&&
name|nonlocal_goto_handler_labels
operator|)
condition|)
block|{
name|edge
name|eh_edge
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|eh_edge
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|eh_edge
operator|->
name|flags
operator|&
operator|(
name|EDGE_EH
operator||
name|EDGE_ABNORMAL_CALL
operator|)
condition|)
break|break;
for|for
control|(
name|x
operator|=
name|try
init|;
name|x
operator|!=
name|before_try
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|CALL_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|x
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|note
condition|)
name|REG_NOTES
argument_list|(
name|x
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|&&
name|eh_edge
condition|)
block|{
name|edge
name|nfte
decl_stmt|,
name|nehe
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|nfte
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|eh_edge
operator|->
name|flags
operator|&
operator|(
name|EDGE_EH
operator||
name|EDGE_ABNORMAL
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|CALL_P
argument_list|(
name|x
argument_list|)
condition|)
name|flags
operator||=
name|EDGE_ABNORMAL_CALL
expr_stmt|;
name|nehe
operator|=
name|make_edge
argument_list|(
name|nfte
operator|->
name|src
argument_list|,
name|eh_edge
operator|->
name|dest
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|nehe
operator|->
name|probability
operator|=
name|eh_edge
operator|->
name|probability
expr_stmt|;
name|nfte
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|nehe
operator|->
name|probability
expr_stmt|;
name|do_cleanup_cfg
operator||=
name|purge_dead_edges
argument_list|(
name|nfte
operator|->
name|dest
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|nfte
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
name|bb
operator|=
name|nfte
operator|->
name|src
expr_stmt|;
name|eh_edge
operator|=
name|nehe
expr_stmt|;
block|}
block|}
comment|/* Converting possibly trapping insn to non-trapping is 			 possible.  Zap dummy outgoing edges.  */
name|do_cleanup_cfg
operator||=
name|purge_dead_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* With conditional execution, we cannot back up the 		     live information so easily, since the conditional 		     death data structures are not so self-contained. 		     So record that we've made a modification to this 		     block and update life information at the end.  */
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
name|peep2_insn_data
index|[
name|peep2_current
index|]
operator|.
name|insn
operator|=
name|PEEP2_EOB
expr_stmt|;
name|peep2_current_count
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* Back up lifetime information past the end of the 		     newly created sequence.  */
if|if
condition|(
operator|++
name|i
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|live
argument_list|,
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
comment|/* Update life information for the new sequence.  */
name|x
operator|=
name|try
expr_stmt|;
do|do
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|MAX_INSNS_PER_PEEP2
expr_stmt|;
if|if
condition|(
name|peep2_current_count
operator|<
name|MAX_INSNS_PER_PEEP2
operator|&&
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
operator|==
name|NULL_RTX
condition|)
name|peep2_current_count
operator|++
expr_stmt|;
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
operator|=
name|x
expr_stmt|;
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
argument_list|,
name|live
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|!=
name|prev
condition|)
do|;
comment|/* ??? Should verify that LIVE now matches what we 		     had before the new sequence.  */
name|peep2_current
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* If we generated a jump instruction, it won't have 		     JUMP_LABEL set.  Recompute after we're done.  */
for|for
control|(
name|x
operator|=
name|try
init|;
name|x
operator|!=
name|before_try
condition|;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|JUMP_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|do_rebuild_jump_labels
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
comment|/* Some peepholes can decide the don't need one or more of their 	 inputs.  If this happens, local life update is not enough.  */
name|EXECUTE_IF_AND_COMPL_IN_BITMAP
argument_list|(
argument|bb->il.rtl->global_live_at_start
argument_list|,
argument|live
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|rsi
argument_list|)
block|{
name|do_global_life_update
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|free_propagate_block_info
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|FREE_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rebuild_jump_labels
condition|)
name|rebuild_jump_labels
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If we eliminated EH edges, we may be able to merge blocks.  Further,      we've changed global life since exception handlers are no longer      reachable.  */
if|if
condition|(
name|do_cleanup_cfg
condition|)
block|{
name|cleanup_cfg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|do_global_life_update
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|do_global_life_update
condition|)
name|update_life_info
argument_list|(
literal|0
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
else|else
block|{
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_peephole2 */
end_comment

begin_comment
comment|/* Common predicates for use with define_bypass.  */
end_comment

begin_comment
comment|/* True if the dependency between OUT_INSN and IN_INSN is on the store    data not the address operand(s) of the store.  IN_INSN must be    single_set.  OUT_INSN must be either a single_set or a PARALLEL with    SETs inside.  */
end_comment

begin_function
name|int
name|store_data_bypass_p
parameter_list|(
name|rtx
name|out_insn
parameter_list|,
name|rtx
name|in_insn
parameter_list|)
block|{
name|rtx
name|out_set
decl_stmt|,
name|in_set
decl_stmt|;
name|in_set
operator|=
name|single_set
argument_list|(
name|in_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|in_set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|SET_DEST
argument_list|(
name|in_set
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|out_set
operator|=
name|single_set
argument_list|(
name|out_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_set
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|out_set
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|in_set
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|rtx
name|out_pat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|out_pat
operator|=
name|PATTERN
argument_list|(
name|out_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|out_pat
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|out_pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|exp
init|=
name|XVECEXP
argument_list|(
name|out_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|in_set
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* True if the dependency between OUT_INSN and IN_INSN is in the IF_THEN_ELSE    condition, and not the THEN or ELSE branch.  OUT_INSN may be either a single    or multiple set; IN_INSN should be single_set for truth, but for convenience    of insn categorization may be any JUMP or CALL insn.  */
end_comment

begin_function
name|int
name|if_test_bypass_p
parameter_list|(
name|rtx
name|out_insn
parameter_list|,
name|rtx
name|in_insn
parameter_list|)
block|{
name|rtx
name|out_set
decl_stmt|,
name|in_set
decl_stmt|;
name|in_set
operator|=
name|single_set
argument_list|(
name|in_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_set
condition|)
block|{
name|gcc_assert
argument_list|(
name|JUMP_P
argument_list|(
name|in_insn
argument_list|)
operator|||
name|CALL_P
argument_list|(
name|in_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|in_set
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
name|false
return|;
name|in_set
operator|=
name|SET_SRC
argument_list|(
name|in_set
argument_list|)
expr_stmt|;
name|out_set
operator|=
name|single_set
argument_list|(
name|out_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_set
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|out_set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|in_set
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|out_set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|in_set
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|rtx
name|out_pat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|out_pat
operator|=
name|PATTERN
argument_list|(
name|out_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|out_pat
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|out_pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|exp
init|=
name|XVECEXP
argument_list|(
name|out_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|out_set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|in_set
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|out_set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|in_set
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_peephole2
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_peephole2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_peephole2
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_peephole2
name|peephole2_optimize
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_peephole2
init|=
block|{
literal|"peephole2"
block|,
comment|/* name */
name|gate_handle_peephole2
block|,
comment|/* gate */
name|rest_of_handle_peephole2
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_PEEPHOLE2
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'z'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_split_all_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_split_all_insns
init|=
block|{
literal|"split1"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rest_of_handle_split_all_insns
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The placement of the splitting that we do for shorten_branches    depends on whether regstack is used by the target or not.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_do_final_split
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATTR_length
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STACK_REGS
argument_list|)
return|return
literal|1
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_split_for_shorten_branches
init|=
block|{
literal|"split3"
block|,
comment|/* name */
name|gate_do_final_split
block|,
comment|/* gate */
name|split_all_insns_noflow
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_SHORTEN_BRANCH
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|gate_handle_split_before_regstack
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATTR_length
argument_list|)
operator|&&
name|defined
argument_list|(
name|STACK_REGS
argument_list|)
comment|/* If flow2 creates new instructions which need splitting      and scheduling after reload is not done, they might not be      split until final which doesn't allow splitting      if HAVE_ATTR_length.  */
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
return|return
operator|(
name|optimize
operator|&&
operator|!
name|flag_schedule_insns_after_reload
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|optimize
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_split_before_regstack
init|=
block|{
literal|"split2"
block|,
comment|/* name */
name|gate_handle_split_before_regstack
block|,
comment|/* gate */
name|rest_of_handle_split_all_insns
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_SHORTEN_BRANCH
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

