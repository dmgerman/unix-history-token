begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic block reordering routines for the GNU compiler.    Copyright (C) 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This (greedy) algorithm constructs traces in several rounds.    The construction starts from "seeds".  The seed for the first round    is the entry point of function.  When there are more than one seed    that one is selected first that has the lowest key in the heap    (see function bb_to_key).  Then the algorithm repeatedly adds the most    probable successor to the end of a trace.  Finally it connects the traces.     There are two parameters: Branch Threshold and Exec Threshold.    If the edge to a successor of the actual basic block is lower than    Branch Threshold or the frequency of the successor is lower than    Exec Threshold the successor will be the seed in one of the next rounds.    Each round has these parameters lower than the previous one.    The last round has to have these parameters set to zero    so that the remaining blocks are picked up.     The algorithm selects the most probable successor from all unvisited    successors and successors that have been added to this trace.    The other successors (that has not been "sent" to the next round) will be    other seeds for this round and the secondary traces will start in them.    If the successor has not been visited in this trace it is added to the trace    (however, there is some heuristic for simple branches).    If the successor has been visited in this trace the loop has been found.    If the loop has many iterations the loop is rotated so that the    source block of the most probable edge going out from the loop    is the last block of the trace.    If the loop has few iterations and there is no edge from the last block of    the loop going out from loop the loop header is duplicated.    Finally, the construction of the trace is terminated.     When connecting traces it first checks whether there is an edge from the    last block of one trace to the first block of another trace.    When there are still some unconnected traces it checks whether there exists    a basic block BB such that BB is a successor of the last bb of one trace    and BB is a predecessor of the first block of another trace. In this case,    BB is duplicated and the traces are connected through this duplicate.    The rest of traces are simply connected so there will be a jump to the    beginning of the rest of trace.      References:     "Software Trace Cache"    A. Ramirez, J. Larriba-Pey, C. Navarro, J. Torrellas and M. Valero; 1999    http://citeseer.nj.nec.com/15361.html  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_execution
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_execution
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of rounds.  In most cases there will only be 4 rounds, but    when partitioning hot and cold basic blocks into separate sections of    the .o file there will be an extra round.*/
end_comment

begin_define
define|#
directive|define
name|N_ROUNDS
value|5
end_define

begin_comment
comment|/* Stubs in case we don't have a return insn.    We have to check at runtime too, not only compiletime.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_return
end_ifndef

begin_define
define|#
directive|define
name|HAVE_return
value|0
end_define

begin_define
define|#
directive|define
name|gen_return
parameter_list|()
value|NULL_RTX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Branch thresholds in thousandths (per mille) of the REG_BR_PROB_BASE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|branch_threshold
index|[
name|N_ROUNDS
index|]
init|=
block|{
literal|400
block|,
literal|200
block|,
literal|100
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exec thresholds in thousandths (per mille) of the frequency of bb 0.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exec_threshold
index|[
name|N_ROUNDS
index|]
init|=
block|{
literal|500
block|,
literal|200
block|,
literal|50
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If edge frequency is lower than DUPLICATION_THRESHOLD per mille of entry    block the edge destination is not duplicated while connecting traces.  */
end_comment

begin_define
define|#
directive|define
name|DUPLICATION_THRESHOLD
value|100
end_define

begin_comment
comment|/* Length of unconditional jump instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uncond_jump_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to hold needed information for each basic block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bbro_basic_block_data_def
block|{
comment|/* Which trace is the bb start of (-1 means it is not a start of a trace).  */
name|int
name|start_of_trace
decl_stmt|;
comment|/* Which trace is the bb end of (-1 means it is not an end of a trace).  */
name|int
name|end_of_trace
decl_stmt|;
comment|/* Which trace is the bb in?  */
name|int
name|in_trace
decl_stmt|;
comment|/* Which heap is BB in (if any)?  */
name|fibheap_t
name|heap
decl_stmt|;
comment|/* Which heap node is BB in (if any)?  */
name|fibnode_t
name|node
decl_stmt|;
block|}
name|bbro_basic_block_data
typedef|;
end_typedef

begin_comment
comment|/* The current size of the following dynamic array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|array_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array which holds needed information for basic blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|bbro_basic_block_data
modifier|*
name|bbd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To avoid frequent reallocation the size of arrays is greater than needed,    the number of elements is (not less than) 1.25 * size_wanted.  */
end_comment

begin_define
define|#
directive|define
name|GET_ARRAY_SIZE
parameter_list|(
name|X
parameter_list|)
value|((((X) / 4) + 1) * 5)
end_define

begin_comment
comment|/* Free the memory and set the pointer to NULL.  */
end_comment

begin_define
define|#
directive|define
name|FREE
parameter_list|(
name|P
parameter_list|)
value|(gcc_assert (P), free (P), P = 0)
end_define

begin_comment
comment|/* Structure for holding information about a trace.  */
end_comment

begin_struct
struct|struct
name|trace
block|{
comment|/* First and last basic block of the trace.  */
name|basic_block
name|first
decl_stmt|,
name|last
decl_stmt|;
comment|/* The round of the STC creation which this trace was found in.  */
name|int
name|round
decl_stmt|;
comment|/* The length (i.e. the number of basic blocks) of the trace.  */
name|int
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Maximum frequency and count of one of the entry blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_entry_frequency
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gcov_type
name|max_entry_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|find_traces
parameter_list|(
name|int
modifier|*
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|rotate_loop
parameter_list|(
name|edge
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_bb_visited
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_traces_1_round
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|gcov_type
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|fibheap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|copy_bb
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fibheapkey_t
name|bb_to_key
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|better_edge_p
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_traces
parameter_list|(
name|int
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|copy_bb_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_uncond_jump_length
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|push_to_next_round_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|gcov_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_rarely_executed_basic_blocks_and_crossing_edges
parameter_list|(
name|edge
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_labels_and_missing_jumps
parameter_list|(
name|edge
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_reg_crossing_jump_notes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_up_fall_thru_edges
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_edges_for_rarely_executed_code
parameter_list|(
name|edge
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_crossing_conditional_branches
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_crossing_unconditional_branches
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Check to see if bb should be pushed into the next round of trace    collections or not.  Reasons for pushing the block forward are 1).    If the block is cold, we are doing partitioning, and there will be    another round (cold partition blocks are not supposed to be    collected into traces until the very last round); or 2). There will    be another round, and the basic block is not "hot enough" for the    current round of trace collection.  */
end_comment

begin_function
specifier|static
name|bool
name|push_to_next_round_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|round
parameter_list|,
name|int
name|number_of_rounds
parameter_list|,
name|int
name|exec_th
parameter_list|,
name|gcov_type
name|count_th
parameter_list|)
block|{
name|bool
name|there_exists_another_round
decl_stmt|;
name|bool
name|block_not_hot_enough
decl_stmt|;
name|there_exists_another_round
operator|=
name|round
operator|<
name|number_of_rounds
operator|-
literal|1
expr_stmt|;
name|block_not_hot_enough
operator|=
operator|(
name|bb
operator|->
name|frequency
operator|<
name|exec_th
operator|||
name|bb
operator|->
name|count
operator|<
name|count_th
operator|||
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|there_exists_another_round
operator|&&
name|block_not_hot_enough
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Find the traces for Software Trace Cache.  Chain each trace through    RBI()->next.  Store the number of traces to N_TRACES and description of    traces to TRACES.  */
end_comment

begin_function
specifier|static
name|void
name|find_traces
parameter_list|(
name|int
modifier|*
name|n_traces
parameter_list|,
name|struct
name|trace
modifier|*
name|traces
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|number_of_rounds
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|fibheap_t
name|heap
decl_stmt|;
comment|/* Add one extra round of trace collection when partitioning hot/cold      basic blocks into separate sections.  The last round is for all the      cold blocks (and ONLY the cold blocks).  */
name|number_of_rounds
operator|=
name|N_ROUNDS
operator|-
literal|1
expr_stmt|;
comment|/* Insert entry points of function into heap.  */
name|heap
operator|=
name|fibheap_new
argument_list|()
expr_stmt|;
name|max_entry_frequency
operator|=
literal|0
expr_stmt|;
name|max_entry_count
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
block|{
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|heap
expr_stmt|;
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
name|bb_to_key
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|frequency
operator|>
name|max_entry_frequency
condition|)
name|max_entry_frequency
operator|=
name|e
operator|->
name|dest
operator|->
name|frequency
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|count
operator|>
name|max_entry_count
condition|)
name|max_entry_count
operator|=
name|e
operator|->
name|dest
operator|->
name|count
expr_stmt|;
block|}
comment|/* Find the traces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_rounds
condition|;
name|i
operator|++
control|)
block|{
name|gcov_type
name|count_threshold
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"STC - round %d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_entry_count
operator|<
name|INT_MAX
operator|/
literal|1000
condition|)
name|count_threshold
operator|=
name|max_entry_count
operator|*
name|exec_threshold
index|[
name|i
index|]
operator|/
literal|1000
expr_stmt|;
else|else
name|count_threshold
operator|=
name|max_entry_count
operator|/
literal|1000
operator|*
name|exec_threshold
index|[
name|i
index|]
expr_stmt|;
name|find_traces_1_round
argument_list|(
name|REG_BR_PROB_BASE
operator|*
name|branch_threshold
index|[
name|i
index|]
operator|/
literal|1000
argument_list|,
name|max_entry_frequency
operator|*
name|exec_threshold
index|[
name|i
index|]
operator|/
literal|1000
argument_list|,
name|count_threshold
argument_list|,
name|traces
argument_list|,
name|n_traces
argument_list|,
name|i
argument_list|,
operator|&
name|heap
argument_list|,
name|number_of_rounds
argument_list|)
expr_stmt|;
block|}
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|n_traces
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Trace %d (round %d):  "
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|traces
index|[
name|i
index|]
operator|.
name|round
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|traces
index|[
name|i
index|]
operator|.
name|first
init|;
name|bb
operator|!=
name|traces
index|[
name|i
index|]
operator|.
name|last
condition|;
name|bb
operator|=
name|bb
operator|->
name|aux
control|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d [%d] "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d [%d]\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rotate loop whose back edge is BACK_EDGE in the tail of trace TRACE    (with sequential number TRACE_N).  */
end_comment

begin_function
specifier|static
name|basic_block
name|rotate_loop
parameter_list|(
name|edge
name|back_edge
parameter_list|,
name|struct
name|trace
modifier|*
name|trace
parameter_list|,
name|int
name|trace_n
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* Information about the best end (end after rotation) of the loop.  */
name|basic_block
name|best_bb
init|=
name|NULL
decl_stmt|;
name|edge
name|best_edge
init|=
name|NULL
decl_stmt|;
name|int
name|best_freq
init|=
operator|-
literal|1
decl_stmt|;
name|gcov_type
name|best_count
init|=
operator|-
literal|1
decl_stmt|;
comment|/* The best edge is preferred when its destination is not visited yet      or is a start block of some trace.  */
name|bool
name|is_preferred
init|=
name|false
decl_stmt|;
comment|/* Find the most frequent edge that goes out from current trace.  */
name|bb
operator|=
name|back_edge
operator|->
name|dest
expr_stmt|;
do|do
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|!=
name|trace_n
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
block|{
if|if
condition|(
name|is_preferred
condition|)
block|{
comment|/* The best edge is preferred.  */
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|||
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
condition|)
block|{
comment|/* The current edge E is also preferred.  */
name|int
name|freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|freq
operator|>
name|best_freq
operator|||
name|e
operator|->
name|count
operator|>
name|best_count
condition|)
block|{
name|best_freq
operator|=
name|freq
expr_stmt|;
name|best_count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_bb
operator|=
name|bb
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|||
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
condition|)
block|{
comment|/* The current edge E is preferred.  */
name|is_preferred
operator|=
name|true
expr_stmt|;
name|best_freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|best_count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_bb
operator|=
name|bb
expr_stmt|;
block|}
else|else
block|{
name|int
name|freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|best_edge
operator|||
name|freq
operator|>
name|best_freq
operator|||
name|e
operator|->
name|count
operator|>
name|best_count
condition|)
block|{
name|best_freq
operator|=
name|freq
expr_stmt|;
name|best_count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_bb
operator|=
name|bb
expr_stmt|;
block|}
block|}
block|}
block|}
name|bb
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
block|}
do|while
condition|(
name|bb
operator|!=
name|back_edge
operator|->
name|dest
condition|)
do|;
if|if
condition|(
name|best_bb
condition|)
block|{
comment|/* Rotate the loop so that the BEST_EDGE goes out from the last block of 	 the trace.  */
if|if
condition|(
name|back_edge
operator|->
name|dest
operator|==
name|trace
operator|->
name|first
condition|)
block|{
name|trace
operator|->
name|first
operator|=
name|best_bb
operator|->
name|aux
expr_stmt|;
block|}
else|else
block|{
name|basic_block
name|prev_bb
decl_stmt|;
for|for
control|(
name|prev_bb
operator|=
name|trace
operator|->
name|first
init|;
name|prev_bb
operator|->
name|aux
operator|!=
name|back_edge
operator|->
name|dest
condition|;
name|prev_bb
operator|=
name|prev_bb
operator|->
name|aux
control|)
empty_stmt|;
name|prev_bb
operator|->
name|aux
operator|=
name|best_bb
operator|->
name|aux
expr_stmt|;
comment|/* Try to get rid of uncond jump to cond jump.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|prev_bb
argument_list|)
condition|)
block|{
name|basic_block
name|header
init|=
name|single_succ
argument_list|(
name|prev_bb
argument_list|)
decl_stmt|;
comment|/* Duplicate HEADER if it is a small block containing cond jump 		 in the end.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|header
argument_list|)
argument_list|)
operator|&&
name|copy_bb_p
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|header
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|copy_bb
argument_list|(
name|header
argument_list|,
name|single_succ_edge
argument_list|(
name|prev_bb
argument_list|)
argument_list|,
name|prev_bb
argument_list|,
name|trace_n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We have not found suitable loop tail so do no rotation.  */
name|best_bb
operator|=
name|back_edge
operator|->
name|src
expr_stmt|;
block|}
name|best_bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|best_bb
return|;
block|}
end_function

begin_comment
comment|/* This function marks BB that it was visited in trace number TRACE.  */
end_comment

begin_function
specifier|static
name|void
name|mark_bb_visited
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|trace
parameter_list|)
block|{
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|=
name|trace
expr_stmt|;
if|if
condition|(
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
condition|)
block|{
name|fibheap_delete_node
argument_list|(
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
argument_list|,
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
argument_list|)
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* One round of finding traces. Find traces for BRANCH_TH and EXEC_TH i.e. do    not include basic blocks their probability is lower than BRANCH_TH or their    frequency is lower than EXEC_TH into traces (or count is lower than    COUNT_TH).  It stores the new traces into TRACES and modifies the number of    traces *N_TRACES. Sets the round (which the trace belongs to) to ROUND. It    expects that starting basic blocks are in *HEAP and at the end it deletes    *HEAP and stores starting points for the next round into new *HEAP.  */
end_comment

begin_function
specifier|static
name|void
name|find_traces_1_round
parameter_list|(
name|int
name|branch_th
parameter_list|,
name|int
name|exec_th
parameter_list|,
name|gcov_type
name|count_th
parameter_list|,
name|struct
name|trace
modifier|*
name|traces
parameter_list|,
name|int
modifier|*
name|n_traces
parameter_list|,
name|int
name|round
parameter_list|,
name|fibheap_t
modifier|*
name|heap
parameter_list|,
name|int
name|number_of_rounds
parameter_list|)
block|{
comment|/* Heap for discarded basic blocks which are possible starting points for      the next round.  */
name|fibheap_t
name|new_heap
init|=
name|fibheap_new
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
operator|*
name|heap
argument_list|)
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|trace
modifier|*
name|trace
decl_stmt|;
name|edge
name|best_edge
decl_stmt|,
name|e
decl_stmt|;
name|fibheapkey_t
name|key
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bb
operator|=
name|fibheap_extract_min
argument_list|(
operator|*
name|heap
argument_list|)
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Getting bb %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* If the BB's frequency is too low send BB to the next round.  When 	 partitioning hot/cold blocks into separate sections, make sure all 	 the cold blocks (and ONLY the cold blocks) go into the (extra) final 	 round.  */
if|if
condition|(
name|push_to_next_round_p
argument_list|(
name|bb
argument_list|,
name|round
argument_list|,
name|number_of_rounds
argument_list|,
name|exec_th
argument_list|,
name|count_th
argument_list|)
condition|)
block|{
name|int
name|key
init|=
name|bb_to_key
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|new_heap
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|fibheap_insert
argument_list|(
name|new_heap
argument_list|,
name|key
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Possible start point of next round: %d (key: %d)\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|trace
operator|=
name|traces
operator|+
operator|*
name|n_traces
expr_stmt|;
name|trace
operator|->
name|first
operator|=
name|bb
expr_stmt|;
name|trace
operator|->
name|round
operator|=
name|round
expr_stmt|;
name|trace
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|in_trace
operator|=
operator|*
name|n_traces
expr_stmt|;
operator|(
operator|*
name|n_traces
operator|)
operator|++
expr_stmt|;
do|do
block|{
name|int
name|prob
decl_stmt|,
name|freq
decl_stmt|;
name|bool
name|ends_in_call
decl_stmt|;
comment|/* The probability and frequency of the best edge.  */
name|int
name|best_prob
init|=
name|INT_MIN
operator|/
literal|2
decl_stmt|;
name|int
name|best_freq
init|=
name|INT_MIN
operator|/
literal|2
decl_stmt|;
name|best_edge
operator|=
name|NULL
expr_stmt|;
name|mark_bb_visited
argument_list|(
name|bb
argument_list|,
operator|*
name|n_traces
argument_list|)
expr_stmt|;
name|trace
operator|->
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Basic block %d was visited in trace %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
operator|*
name|n_traces
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ends_in_call
operator|=
name|block_ends_with_call_p
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Select the successor that will be placed after BB.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|&&
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|!=
operator|*
name|n_traces
condition|)
continue|continue;
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
name|prob
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|freq
operator|=
name|e
operator|->
name|dest
operator|->
name|frequency
expr_stmt|;
comment|/* The only sensible preference for a call instruction is the 		 fallthru edge.  Don't bother selecting anything else.  */
if|if
condition|(
name|ends_in_call
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
condition|)
block|{
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_prob
operator|=
name|prob
expr_stmt|;
name|best_freq
operator|=
name|freq
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Edge that cannot be fallthru or improbable or infrequent 		 successor (i.e. it is unsuitable successor).  */
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|||
name|prob
operator|<
name|branch_th
operator|||
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|<
name|exec_th
operator|||
name|e
operator|->
name|count
operator|<
name|count_th
condition|)
continue|continue;
comment|/* If partitioning hot/cold basic blocks, don't consider edges 		 that cross section boundaries.  */
if|if
condition|(
name|better_edge_p
argument_list|(
name|bb
argument_list|,
name|e
argument_list|,
name|prob
argument_list|,
name|freq
argument_list|,
name|best_prob
argument_list|,
name|best_freq
argument_list|,
name|best_edge
argument_list|)
condition|)
block|{
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_prob
operator|=
name|prob
expr_stmt|;
name|best_freq
operator|=
name|freq
expr_stmt|;
block|}
block|}
comment|/* If the best destination has multiple predecessors, and can be 	     duplicated cheaper than a jump, don't allow it to be added 	     to a trace.  We'll duplicate it when connecting traces.  */
if|if
condition|(
name|best_edge
operator|&&
name|EDGE_COUNT
argument_list|(
name|best_edge
operator|->
name|dest
operator|->
name|preds
argument_list|)
operator|>=
literal|2
operator|&&
name|copy_bb_p
argument_list|(
name|best_edge
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
name|best_edge
operator|=
name|NULL
expr_stmt|;
comment|/* Add all non-selected successors to the heaps.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|==
name|best_edge
operator|||
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
condition|)
continue|continue;
name|key
operator|=
name|bb_to_key
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
condition|)
block|{
comment|/* E->DEST is already in some heap.  */
if|if
condition|(
name|key
operator|!=
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Changing key for bb %d from %ld to %ld.\n"
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|fibheap_replace_key
argument_list|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
argument_list|,
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fibheap_t
name|which_heap
init|=
operator|*
name|heap
decl_stmt|;
name|prob
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|||
name|prob
operator|<
name|branch_th
operator|||
name|freq
operator|<
name|exec_th
operator|||
name|e
operator|->
name|count
operator|<
name|count_th
condition|)
block|{
comment|/* When partitioning hot/cold basic blocks, make sure 			 the cold blocks (and only the cold blocks) all get 			 pushed to the last round of trace collection.  */
if|if
condition|(
name|push_to_next_round_p
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|round
argument_list|,
name|number_of_rounds
argument_list|,
name|exec_th
argument_list|,
name|count_th
argument_list|)
condition|)
name|which_heap
operator|=
name|new_heap
expr_stmt|;
block|}
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|which_heap
expr_stmt|;
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|fibheap_insert
argument_list|(
name|which_heap
argument_list|,
name|key
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Possible start of %s round: %d (key: %ld)\n"
argument_list|,
operator|(
name|which_heap
operator|==
name|new_heap
operator|)
condition|?
literal|"next"
else|:
literal|"this"
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best_edge
condition|)
comment|/* Suitable successor was found.  */
block|{
if|if
condition|(
name|best_edge
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|==
operator|*
name|n_traces
condition|)
block|{
comment|/* We do nothing with one basic block loops.  */
if|if
condition|(
name|best_edge
operator|->
name|dest
operator|!=
name|bb
condition|)
block|{
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|best_edge
argument_list|)
operator|>
literal|4
operator|*
name|best_edge
operator|->
name|dest
operator|->
name|frequency
operator|/
literal|5
condition|)
block|{
comment|/* The loop has at least 4 iterations.  If the loop 			     header is not the first block of the function 			     we can rotate the loop.  */
if|if
condition|(
name|best_edge
operator|->
name|dest
operator|!=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Rotating loop %d - %d\n"
argument_list|,
name|best_edge
operator|->
name|dest
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|bb
operator|->
name|aux
operator|=
name|best_edge
operator|->
name|dest
expr_stmt|;
name|bbd
index|[
name|best_edge
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|in_trace
operator|=
operator|(
operator|*
name|n_traces
operator|)
operator|-
literal|1
expr_stmt|;
name|bb
operator|=
name|rotate_loop
argument_list|(
name|best_edge
argument_list|,
name|trace
argument_list|,
operator|*
name|n_traces
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The loop has less than 4 iterations.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|copy_bb_p
argument_list|(
name|best_edge
operator|->
name|dest
argument_list|,
operator|!
name|optimize_size
argument_list|)
condition|)
block|{
name|bb
operator|=
name|copy_bb
argument_list|(
name|best_edge
operator|->
name|dest
argument_list|,
name|best_edge
argument_list|,
name|bb
argument_list|,
operator|*
name|n_traces
argument_list|)
expr_stmt|;
name|trace
operator|->
name|length
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Terminate the trace.  */
break|break;
block|}
else|else
block|{
comment|/* Check for a situation  		    A 		   /| 		  B | 		   \| 		    C  		  where 		  EDGE_FREQUENCY (AB) + EDGE_FREQUENCY (BC)>= EDGE_FREQUENCY (AC). 		  (i.e. 2 * B->frequency>= EDGE_FREQUENCY (AC) ) 		  Best ordering is then A B C.  		  This situation is created for example by:  		  if (A) B; 		  C;  		  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|!=
name|best_edge
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|&&
name|single_pred_p
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
operator|&&
name|single_succ_p
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|&&
operator|(
name|single_succ_edge
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|single_succ_edge
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|single_succ
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|==
name|best_edge
operator|->
name|dest
operator|&&
literal|2
operator|*
name|e
operator|->
name|dest
operator|->
name|frequency
operator|>=
name|EDGE_FREQUENCY
argument_list|(
name|best_edge
argument_list|)
condition|)
block|{
name|best_edge
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Selecting BB %d\n"
argument_list|,
name|best_edge
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
name|bb
operator|->
name|aux
operator|=
name|best_edge
operator|->
name|dest
expr_stmt|;
name|bbd
index|[
name|best_edge
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|in_trace
operator|=
operator|(
operator|*
name|n_traces
operator|)
operator|-
literal|1
expr_stmt|;
name|bb
operator|=
name|best_edge
operator|->
name|dest
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|best_edge
condition|)
do|;
name|trace
operator|->
name|last
operator|=
name|bb
expr_stmt|;
name|bbd
index|[
name|trace
operator|->
name|first
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|=
operator|*
name|n_traces
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|trace
operator|->
name|last
operator|->
name|index
index|]
operator|.
name|end_of_trace
operator|=
operator|*
name|n_traces
operator|-
literal|1
expr_stmt|;
comment|/* The trace is terminated so we have to recount the keys in heap 	 (some block can have a lower key because now one of its predecessors 	 is an end of the trace).  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
condition|)
continue|continue;
if|if
condition|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
condition|)
block|{
name|key
operator|=
name|bb_to_key
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Changing key for bb %d from %ld to %ld.\n"
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|fibheap_replace_key
argument_list|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
argument_list|,
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|fibheap_delete
argument_list|(
operator|*
name|heap
argument_list|)
expr_stmt|;
comment|/* "Return" the new heap.  */
operator|*
name|heap
operator|=
name|new_heap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a duplicate of the basic block OLD_BB and redirect edge E to it, add    it to trace after BB, mark OLD_BB visited and update pass' data structures    (TRACE is a number of trace which OLD_BB is duplicated to).  */
end_comment

begin_function
specifier|static
name|basic_block
name|copy_bb
parameter_list|(
name|basic_block
name|old_bb
parameter_list|,
name|edge
name|e
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|trace
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
name|new_bb
operator|=
name|duplicate_block
argument_list|(
name|old_bb
argument_list|,
name|e
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|BB_COPY_PARTITION
argument_list|(
name|new_bb
argument_list|,
name|old_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest
operator|==
name|new_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Duplicated bb %d (created bb %d)\n"
argument_list|,
name|old_bb
operator|->
name|index
argument_list|,
name|new_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|=
name|trace
expr_stmt|;
name|new_bb
operator|->
name|aux
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|new_bb
expr_stmt|;
if|if
condition|(
name|new_bb
operator|->
name|index
operator|>=
name|array_size
operator|||
name|last_basic_block
operator|>
name|array_size
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|new_size
decl_stmt|;
name|new_size
operator|=
name|MAX
argument_list|(
name|last_basic_block
argument_list|,
name|new_bb
operator|->
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_size
operator|=
name|GET_ARRAY_SIZE
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
name|bbd
operator|=
name|xrealloc
argument_list|(
name|bbd
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|bbro_basic_block_data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|array_size
init|;
name|i
operator|<
name|new_size
condition|;
name|i
operator|++
control|)
block|{
name|bbd
index|[
name|i
index|]
operator|.
name|start_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|in_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|end_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|array_size
operator|=
name|new_size
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Growing the dynamic array to %d elements.\n"
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
block|}
block|}
name|bbd
index|[
name|new_bb
operator|->
name|index
index|]
operator|.
name|in_trace
operator|=
name|trace
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Compute and return the key (for the heap) of the basic block BB.  */
end_comment

begin_function
specifier|static
name|fibheapkey_t
name|bb_to_key
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|priority
init|=
literal|0
decl_stmt|;
comment|/* Do not start in probably never executed blocks.  */
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
operator|==
name|BB_COLD_PARTITION
operator|||
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|BB_FREQ_MAX
return|;
comment|/* Prefer blocks whose predecessor is an end of some trace      or whose predecessor edge is EDGE_DFS_BACK.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|bbd
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
operator|.
name|end_of_trace
operator|>=
literal|0
operator|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
block|{
name|int
name|edge_freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge_freq
operator|>
name|priority
condition|)
name|priority
operator|=
name|edge_freq
expr_stmt|;
block|}
block|}
if|if
condition|(
name|priority
condition|)
comment|/* The block with priority should have significantly lower key.  */
return|return
operator|-
operator|(
literal|100
operator|*
name|BB_FREQ_MAX
operator|+
literal|100
operator|*
name|priority
operator|+
name|bb
operator|->
name|frequency
operator|)
return|;
return|return
operator|-
name|bb
operator|->
name|frequency
return|;
block|}
end_function

begin_comment
comment|/* Return true when the edge E from basic block BB is better than the temporary    best edge (details are in function).  The probability of edge E is PROB. The    frequency of the successor is FREQ.  The current best probability is    BEST_PROB, the best frequency is BEST_FREQ.    The edge is considered to be equivalent when PROB does not differ much from    BEST_PROB; similarly for frequency.  */
end_comment

begin_function
specifier|static
name|bool
name|better_edge_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|edge
name|e
parameter_list|,
name|int
name|prob
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|best_prob
parameter_list|,
name|int
name|best_freq
parameter_list|,
name|edge
name|cur_best_edge
parameter_list|)
block|{
name|bool
name|is_better_edge
decl_stmt|;
comment|/* The BEST_* values do not have to be best, but can be a bit smaller than      maximum values.  */
name|int
name|diff_prob
init|=
name|best_prob
operator|/
literal|10
decl_stmt|;
name|int
name|diff_freq
init|=
name|best_freq
operator|/
literal|10
decl_stmt|;
if|if
condition|(
name|prob
operator|>
name|best_prob
operator|+
name|diff_prob
condition|)
comment|/* The edge has higher probability than the temporary best edge.  */
name|is_better_edge
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|<
name|best_prob
operator|-
name|diff_prob
condition|)
comment|/* The edge has lower probability than the temporary best edge.  */
name|is_better_edge
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|freq
operator|<
name|best_freq
operator|-
name|diff_freq
condition|)
comment|/* The edge and the temporary best edge  have almost equivalent        probabilities.  The higher frequency of a successor now means        that there is another edge going into that successor.        This successor has lower frequency so it is better.  */
name|is_better_edge
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|freq
operator|>
name|best_freq
operator|+
name|diff_freq
condition|)
comment|/* This successor has higher frequency so it is worse.  */
name|is_better_edge
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|prev_bb
operator|==
name|bb
condition|)
comment|/* The edges have equivalent probabilities and the successors        have equivalent frequencies.  Select the previous successor.  */
name|is_better_edge
operator|=
name|true
expr_stmt|;
else|else
name|is_better_edge
operator|=
name|false
expr_stmt|;
comment|/* If we are doing hot/cold partitioning, make sure that we always favor      non-crossing edges over crossing edges.  */
if|if
condition|(
operator|!
name|is_better_edge
operator|&&
name|flag_reorder_blocks_and_partition
operator|&&
name|cur_best_edge
operator|&&
operator|(
name|cur_best_edge
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
name|is_better_edge
operator|=
name|true
expr_stmt|;
return|return
name|is_better_edge
return|;
block|}
end_function

begin_comment
comment|/* Connect traces in array TRACES, N_TRACES is the count of traces.  */
end_comment

begin_function
specifier|static
name|void
name|connect_traces
parameter_list|(
name|int
name|n_traces
parameter_list|,
name|struct
name|trace
modifier|*
name|traces
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
modifier|*
name|connected
decl_stmt|;
name|bool
name|two_passes
decl_stmt|;
name|int
name|last_trace
decl_stmt|;
name|int
name|current_pass
decl_stmt|;
name|int
name|current_partition
decl_stmt|;
name|int
name|freq_threshold
decl_stmt|;
name|gcov_type
name|count_threshold
decl_stmt|;
name|freq_threshold
operator|=
name|max_entry_frequency
operator|*
name|DUPLICATION_THRESHOLD
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|max_entry_count
operator|<
name|INT_MAX
operator|/
literal|1000
condition|)
name|count_threshold
operator|=
name|max_entry_count
operator|*
name|DUPLICATION_THRESHOLD
operator|/
literal|1000
expr_stmt|;
else|else
name|count_threshold
operator|=
name|max_entry_count
operator|/
literal|1000
operator|*
name|DUPLICATION_THRESHOLD
expr_stmt|;
name|connected
operator|=
name|XCNEWVEC
argument_list|(
name|bool
argument_list|,
name|n_traces
argument_list|)
expr_stmt|;
name|last_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|current_pass
operator|=
literal|1
expr_stmt|;
name|current_partition
operator|=
name|BB_PARTITION
argument_list|(
name|traces
index|[
literal|0
index|]
operator|.
name|first
argument_list|)
expr_stmt|;
name|two_passes
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_traces
operator|&&
operator|!
name|two_passes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|traces
index|[
literal|0
index|]
operator|.
name|first
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|traces
index|[
name|i
index|]
operator|.
name|first
argument_list|)
condition|)
name|two_passes
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_traces
operator|||
operator|(
name|two_passes
operator|&&
name|current_pass
operator|==
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
init|=
name|i
decl_stmt|;
name|int
name|t2
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|best
decl_stmt|;
name|int
name|best_len
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|n_traces
condition|)
block|{
name|gcc_assert
argument_list|(
name|two_passes
operator|&&
name|current_pass
operator|==
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|i
expr_stmt|;
name|current_pass
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|current_partition
operator|==
name|BB_HOT_PARTITION
condition|)
name|current_partition
operator|=
name|BB_COLD_PARTITION
expr_stmt|;
else|else
name|current_partition
operator|=
name|BB_HOT_PARTITION
expr_stmt|;
block|}
if|if
condition|(
name|connected
index|[
name|t
index|]
condition|)
continue|continue;
if|if
condition|(
name|two_passes
operator|&&
name|BB_PARTITION
argument_list|(
name|traces
index|[
name|t
index|]
operator|.
name|first
argument_list|)
operator|!=
name|current_partition
condition|)
continue|continue;
name|connected
index|[
name|t
index|]
operator|=
name|true
expr_stmt|;
comment|/* Find the predecessor traces.  */
for|for
control|(
name|t2
operator|=
name|t
init|;
name|t2
operator|>
literal|0
condition|;
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|best
operator|=
name|NULL
expr_stmt|;
name|best_len
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|traces[t2].first->preds
argument_list|)
block|{
name|int
name|si
init|=
name|e
operator|->
name|src
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
operator|>=
literal|0
operator|&&
operator|!
name|connected
index|[
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
index|]
operator|&&
operator|(
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|==
name|current_partition
operator|)
operator|&&
operator|(
operator|!
name|best
operator|||
name|e
operator|->
name|probability
operator|>
name|best
operator|->
name|probability
operator|||
operator|(
name|e
operator|->
name|probability
operator|==
name|best
operator|->
name|probability
operator|&&
name|traces
index|[
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
index|]
operator|.
name|length
operator|>
name|best_len
operator|)
operator|)
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|best_len
operator|=
name|traces
index|[
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
condition|)
block|{
name|best
operator|->
name|src
operator|->
name|aux
operator|=
name|best
operator|->
name|dest
expr_stmt|;
name|t2
operator|=
name|bbd
index|[
name|best
operator|->
name|src
operator|->
name|index
index|]
operator|.
name|end_of_trace
expr_stmt|;
name|connected
index|[
name|t2
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Connection: %d %d\n"
argument_list|,
name|best
operator|->
name|src
operator|->
name|index
argument_list|,
name|best
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|last_trace
operator|>=
literal|0
condition|)
name|traces
index|[
name|last_trace
index|]
operator|.
name|last
operator|->
name|aux
operator|=
name|traces
index|[
name|t2
index|]
operator|.
name|first
expr_stmt|;
name|last_trace
operator|=
name|t
expr_stmt|;
comment|/* Find the successor traces.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find the continuation of the chain.  */
name|edge_iterator
name|ei
decl_stmt|;
name|best
operator|=
name|NULL
expr_stmt|;
name|best_len
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|traces[t].last->succs
argument_list|)
block|{
name|int
name|di
init|=
name|e
operator|->
name|dest
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
operator|&&
operator|!
name|connected
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|&&
operator|(
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|==
name|current_partition
operator|)
operator|&&
operator|(
operator|!
name|best
operator|||
name|e
operator|->
name|probability
operator|>
name|best
operator|->
name|probability
operator|||
operator|(
name|e
operator|->
name|probability
operator|==
name|best
operator|->
name|probability
operator|&&
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
operator|>
name|best_len
operator|)
operator|)
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|best_len
operator|=
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Connection: %d %d\n"
argument_list|,
name|best
operator|->
name|src
operator|->
name|index
argument_list|,
name|best
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|bbd
index|[
name|best
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
expr_stmt|;
name|traces
index|[
name|last_trace
index|]
operator|.
name|last
operator|->
name|aux
operator|=
name|traces
index|[
name|t
index|]
operator|.
name|first
expr_stmt|;
name|connected
index|[
name|t
index|]
operator|=
name|true
expr_stmt|;
name|last_trace
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to connect the traces by duplication of 1 block.  */
name|edge
name|e2
decl_stmt|;
name|basic_block
name|next_bb
init|=
name|NULL
decl_stmt|;
name|bool
name|try_copy
init|=
name|false
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|traces[t].last->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|(
operator|!
name|best
operator|||
name|e
operator|->
name|probability
operator|>
name|best
operator|->
name|probability
operator|)
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|best2
init|=
name|NULL
decl_stmt|;
name|int
name|best2_len
init|=
literal|0
decl_stmt|;
comment|/* If the destination is a start of a trace which is only 		       one block long, then no need to search the successor 		       blocks of the trace.  Accept it.  */
if|if
condition|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
operator|&&
name|traces
index|[
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|try_copy
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e2
argument_list|,
argument|ei
argument_list|,
argument|e->dest->succs
argument_list|)
block|{
name|int
name|di
init|=
name|e2
operator|->
name|dest
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|e2
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
operator|(
operator|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
operator|&&
operator|!
name|connected
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|&&
operator|(
name|BB_PARTITION
argument_list|(
name|e2
operator|->
name|dest
argument_list|)
operator|==
name|current_partition
operator|)
operator|&&
operator|(
name|EDGE_FREQUENCY
argument_list|(
name|e2
argument_list|)
operator|>=
name|freq_threshold
operator|)
operator|&&
operator|(
name|e2
operator|->
name|count
operator|>=
name|count_threshold
operator|)
operator|&&
operator|(
operator|!
name|best2
operator|||
name|e2
operator|->
name|probability
operator|>
name|best2
operator|->
name|probability
operator|||
operator|(
name|e2
operator|->
name|probability
operator|==
name|best2
operator|->
name|probability
operator|&&
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
operator|>
name|best2_len
operator|)
operator|)
operator|)
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|best2
operator|=
name|e2
expr_stmt|;
if|if
condition|(
name|e2
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|best2_len
operator|=
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
expr_stmt|;
else|else
name|best2_len
operator|=
name|INT_MAX
expr_stmt|;
name|next_bb
operator|=
name|e2
operator|->
name|dest
expr_stmt|;
name|try_copy
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
name|try_copy
operator|=
name|false
expr_stmt|;
comment|/* Copy tiny blocks always; copy larger blocks only when the 		 edge is traversed frequently enough.  */
if|if
condition|(
name|try_copy
operator|&&
name|copy_bb_p
argument_list|(
name|best
operator|->
name|dest
argument_list|,
operator|!
name|optimize_size
operator|&&
name|EDGE_FREQUENCY
argument_list|(
name|best
argument_list|)
operator|>=
name|freq_threshold
operator|&&
name|best
operator|->
name|count
operator|>=
name|count_threshold
argument_list|)
condition|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Connection: %d %d "
argument_list|,
name|traces
index|[
name|t
index|]
operator|.
name|last
operator|->
name|index
argument_list|,
name|best
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_bb
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"exit\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d\n"
argument_list|,
name|next_bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|new_bb
operator|=
name|copy_bb
argument_list|(
name|best
operator|->
name|dest
argument_list|,
name|best
argument_list|,
name|traces
index|[
name|t
index|]
operator|.
name|last
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|traces
index|[
name|t
index|]
operator|.
name|last
operator|=
name|new_bb
expr_stmt|;
if|if
condition|(
name|next_bb
operator|&&
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|t
operator|=
name|bbd
index|[
name|next_bb
operator|->
name|index
index|]
operator|.
name|start_of_trace
expr_stmt|;
name|traces
index|[
name|last_trace
index|]
operator|.
name|last
operator|->
name|aux
operator|=
name|traces
index|[
name|t
index|]
operator|.
name|first
expr_stmt|;
name|connected
index|[
name|t
index|]
operator|=
name|true
expr_stmt|;
name|last_trace
operator|=
name|t
expr_stmt|;
block|}
else|else
break|break;
comment|/* Stop finding the successor traces.  */
block|}
else|else
break|break;
comment|/* Stop finding the successor traces.  */
block|}
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Final order:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|traces
index|[
literal|0
index|]
operator|.
name|first
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|aux
control|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|connected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when BB can and should be copied. CODE_MAY_GROW is true    when code size is allowed to grow by duplication.  */
end_comment

begin_function
specifier|static
name|bool
name|copy_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|code_may_grow
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|max_size
init|=
name|uncond_jump_length
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|bb
operator|->
name|frequency
condition|)
return|return
name|false
return|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|<
literal|2
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|can_duplicate_block_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Avoid duplicating blocks which have many successors (PR/13430).  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>
literal|8
condition|)
return|return
name|false
return|;
if|if
condition|(
name|code_may_grow
operator|&&
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|max_size
operator|*=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_GROW_COPY_BB_INSNS
argument_list|)
expr_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|size
operator|+=
name|get_attr_min_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
name|max_size
condition|)
return|return
name|true
return|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Block %d can't be copied because its size = %d.\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the length of unconditional jump instruction.  */
end_comment

begin_function
specifier|static
name|int
name|get_uncond_jump_length
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|,
name|jump
decl_stmt|;
name|int
name|length
decl_stmt|;
name|label
operator|=
name|emit_label_before
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|get_attr_min_length
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Find the basic blocks that are rarely executed and need to be moved to    a separate section of the .o file (to cut down on paging and improve    cache locality).  */
end_comment

begin_function
specifier|static
name|void
name|find_rarely_executed_basic_blocks_and_crossing_edges
parameter_list|(
name|edge
modifier|*
name|crossing_edges
parameter_list|,
name|int
modifier|*
name|n_crossing_edges
parameter_list|,
name|int
modifier|*
name|max_idx
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|bool
name|has_hot_blocks
init|=
name|false
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Mark which partition (hot/cold) each basic block belongs in.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|BB_SET_PARTITION
argument_list|(
name|bb
argument_list|,
name|BB_COLD_PARTITION
argument_list|)
expr_stmt|;
else|else
block|{
name|BB_SET_PARTITION
argument_list|(
name|bb
argument_list|,
name|BB_HOT_PARTITION
argument_list|)
expr_stmt|;
name|has_hot_blocks
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Mark every edge that crosses between sections.  */
name|i
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|e
operator|->
name|flags
operator||=
name|EDGE_CROSSING
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|*
name|max_idx
condition|)
block|{
operator|*
name|max_idx
operator|*=
literal|2
expr_stmt|;
name|crossing_edges
operator|=
name|xrealloc
argument_list|(
name|crossing_edges
argument_list|,
operator|(
operator|*
name|max_idx
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|crossing_edges
index|[
name|i
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
else|else
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_CROSSING
expr_stmt|;
block|}
operator|*
name|n_crossing_edges
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If any destination of a crossing edge does not have a label, add label;    Convert any fall-through crossing edges (for blocks that do not contain    a jump) to unconditional jumps.  */
end_comment

begin_function
specifier|static
name|void
name|add_labels_and_missing_jumps
parameter_list|(
name|edge
modifier|*
name|crossing_edges
parameter_list|,
name|int
name|n_crossing_edges
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|rtx
name|new_jump
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_crossing_edges
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|crossing_edges
index|[
name|i
index|]
condition|)
block|{
name|src
operator|=
name|crossing_edges
index|[
name|i
index|]
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|crossing_edges
index|[
name|i
index|]
operator|->
name|dest
expr_stmt|;
comment|/* Make sure dest has a label.  */
if|if
condition|(
name|dest
operator|&&
operator|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|)
condition|)
block|{
name|label
operator|=
name|block_label
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Make sure source block ends with a jump.  */
if|if
condition|(
name|src
operator|&&
operator|(
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
comment|/* bb just falls through.  */
block|{
comment|/* make sure there's only one successor */
name|gcc_assert
argument_list|(
name|single_succ_p
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find label in dest block.  */
name|label
operator|=
name|block_label
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|new_jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|new_jump
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|src
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|unlink_insn_chain
argument_list|(
name|barrier
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
comment|/* Mark edge as non-fallthru.  */
name|crossing_edges
index|[
name|i
index|]
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
block|}
comment|/* end: 'if (GET_CODE ... '  */
block|}
comment|/* end: 'if (src&& src->index...'  */
block|}
comment|/* end: 'if (dest&& dest->index...'  */
block|}
comment|/* end: 'if (crossing_edges[i]...'  */
block|}
comment|/* end for loop  */
block|}
end_function

begin_comment
comment|/* Find any bb's where the fall-through edge is a crossing edge (note that    these bb's must also contain a conditional jump; we've already    dealt with fall-through edges for blocks that didn't have a    conditional jump in the call to add_labels_and_missing_jumps).    Convert the fall-through edge to non-crossing edge by inserting a    new bb to fall-through into.  The new bb will contain an    unconditional jump (crossing edge) to the original fall through    destination.  */
end_comment

begin_function
specifier|static
name|void
name|fix_up_fall_thru_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|cur_bb
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|edge
name|succ1
decl_stmt|;
name|edge
name|succ2
decl_stmt|;
name|edge
name|fall_thru
decl_stmt|;
name|edge
name|cond_jump
init|=
name|NULL
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|bool
name|cond_jump_crosses
decl_stmt|;
name|int
name|invert_worked
decl_stmt|;
name|rtx
name|old_jump
decl_stmt|;
name|rtx
name|fall_thru_label
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|cur_bb
argument_list|)
block|{
name|fall_thru
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|cur_bb
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
name|succ1
operator|=
name|EDGE_SUCC
argument_list|(
name|cur_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|succ1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|cur_bb
operator|->
name|succs
argument_list|)
operator|>
literal|1
condition|)
name|succ2
operator|=
name|EDGE_SUCC
argument_list|(
name|cur_bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|succ2
operator|=
name|NULL
expr_stmt|;
comment|/* Find the fall-through edge.  */
if|if
condition|(
name|succ1
operator|&&
operator|(
name|succ1
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
block|{
name|fall_thru
operator|=
name|succ1
expr_stmt|;
name|cond_jump
operator|=
name|succ2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|succ2
operator|&&
operator|(
name|succ2
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
block|{
name|fall_thru
operator|=
name|succ2
expr_stmt|;
name|cond_jump
operator|=
name|succ1
expr_stmt|;
block|}
if|if
condition|(
name|fall_thru
operator|&&
operator|(
name|fall_thru
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|)
condition|)
block|{
comment|/* Check to see if the fall-thru edge is a crossing edge.  */
if|if
condition|(
name|fall_thru
operator|->
name|flags
operator|&
name|EDGE_CROSSING
condition|)
block|{
comment|/* The fall_thru edge crosses; now check the cond jump edge, if 		 it exists.  */
name|cond_jump_crosses
operator|=
name|true
expr_stmt|;
name|invert_worked
operator|=
literal|0
expr_stmt|;
name|old_jump
operator|=
name|BB_END
argument_list|(
name|cur_bb
argument_list|)
expr_stmt|;
comment|/* Find the jump instruction, if there is one.  */
if|if
condition|(
name|cond_jump
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cond_jump
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
name|cond_jump_crosses
operator|=
name|false
expr_stmt|;
comment|/* We know the fall-thru edge crosses; if the cond 		     jump edge does NOT cross, and its destination is the 		     next block in the bb order, invert the jump 		     (i.e. fix it so the fall thru does not cross and 		     the cond jump does).  */
if|if
condition|(
operator|!
name|cond_jump_crosses
operator|&&
name|cur_bb
operator|->
name|aux
operator|==
name|cond_jump
operator|->
name|dest
condition|)
block|{
comment|/* Find label in fall_thru block. We've already added 			 any missing labels, so there must be one.  */
name|fall_thru_label
operator|=
name|block_label
argument_list|(
name|fall_thru
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_jump
operator|&&
name|fall_thru_label
condition|)
name|invert_worked
operator|=
name|invert_jump
argument_list|(
name|old_jump
argument_list|,
name|fall_thru_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_worked
condition|)
block|{
name|fall_thru
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|cond_jump
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|cur_bb
argument_list|)
expr_stmt|;
name|e
operator|=
name|fall_thru
expr_stmt|;
name|fall_thru
operator|=
name|cond_jump
expr_stmt|;
name|cond_jump
operator|=
name|e
expr_stmt|;
name|cond_jump
operator|->
name|flags
operator||=
name|EDGE_CROSSING
expr_stmt|;
name|fall_thru
operator|->
name|flags
operator|&=
operator|~
name|EDGE_CROSSING
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cond_jump_crosses
operator|||
operator|!
name|invert_worked
condition|)
block|{
comment|/* This is the case where both edges out of the basic 		     block are crossing edges. Here we will fix up the 		     fall through edge. The jump edge will be taken care 		     of later.  */
name|new_bb
operator|=
name|force_nonfallthru
argument_list|(
name|fall_thru
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bb
condition|)
block|{
name|new_bb
operator|->
name|aux
operator|=
name|cur_bb
operator|->
name|aux
expr_stmt|;
name|cur_bb
operator|->
name|aux
operator|=
name|new_bb
expr_stmt|;
comment|/* Make sure new fall-through bb is in same 			 partition as bb it's falling through from.  */
name|BB_COPY_PARTITION
argument_list|(
name|new_bb
argument_list|,
name|cur_bb
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|new_bb
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_CROSSING
expr_stmt|;
block|}
comment|/* Add barrier after new jump */
if|if
condition|(
name|new_bb
condition|)
block|{
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|new_bb
argument_list|)
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|unlink_insn_chain
argument_list|(
name|barrier
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|cur_bb
argument_list|)
argument_list|)
expr_stmt|;
name|cur_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|unlink_insn_chain
argument_list|(
name|barrier
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function checks the destination blockof a "crossing jump" to    see if it has any crossing predecessors that begin with a code label    and end with an unconditional jump.  If so, it returns that predecessor    block.  (This is to avoid creating lots of new basic blocks that all    contain unconditional jumps to the same destination).  */
end_comment

begin_function
specifier|static
name|basic_block
name|find_jump_block
parameter_list|(
name|basic_block
name|jump_dest
parameter_list|)
block|{
name|basic_block
name|source_bb
init|=
name|NULL
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|jump_dest->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CROSSING
condition|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
comment|/* Check each predecessor to see if it has a label, and contains 	   only one executable instruction, which is an unconditional jump. 	   If so, we can use it.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|BB_HEAD
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|src
argument_list|)
init|;
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|insn
operator|==
name|BB_END
argument_list|(
name|src
argument_list|)
operator|&&
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|source_bb
operator|=
name|src
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|source_bb
condition|)
break|break;
block|}
return|return
name|source_bb
return|;
block|}
end_function

begin_comment
comment|/* Find all BB's with conditional jumps that are crossing edges;    insert a new bb and make the conditional jump branch to the new    bb instead (make the new bb same color so conditional branch won't    be a 'crossing' edge).  Insert an unconditional jump from the    new bb to the original destination of the conditional jump.  */
end_comment

begin_function
specifier|static
name|void
name|fix_crossing_conditional_branches
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|cur_bb
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|basic_block
name|last_bb
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
name|basic_block
name|prev_bb
decl_stmt|;
name|edge
name|succ1
decl_stmt|;
name|edge
name|succ2
decl_stmt|;
name|edge
name|crossing_edge
decl_stmt|;
name|edge
name|new_edge
decl_stmt|;
name|rtx
name|old_jump
decl_stmt|;
name|rtx
name|set_src
decl_stmt|;
name|rtx
name|old_label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|new_label
decl_stmt|;
name|rtx
name|new_jump
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|last_bb
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|cur_bb
argument_list|)
block|{
name|crossing_edge
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|cur_bb
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
name|succ1
operator|=
name|EDGE_SUCC
argument_list|(
name|cur_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|succ1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|cur_bb
operator|->
name|succs
argument_list|)
operator|>
literal|1
condition|)
name|succ2
operator|=
name|EDGE_SUCC
argument_list|(
name|cur_bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|succ2
operator|=
name|NULL
expr_stmt|;
comment|/* We already took care of fall-through edges, so only one successor 	 can be a crossing edge.  */
if|if
condition|(
name|succ1
operator|&&
operator|(
name|succ1
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
name|crossing_edge
operator|=
name|succ1
expr_stmt|;
elseif|else
if|if
condition|(
name|succ2
operator|&&
operator|(
name|succ2
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
name|crossing_edge
operator|=
name|succ2
expr_stmt|;
if|if
condition|(
name|crossing_edge
condition|)
block|{
name|old_jump
operator|=
name|BB_END
argument_list|(
name|cur_bb
argument_list|)
expr_stmt|;
comment|/* Check to make sure the jump instruction is a 	     conditional jump.  */
name|set_src
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|any_condjump_p
argument_list|(
name|old_jump
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|old_jump
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|old_jump
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|old_jump
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|set_src
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|old_jump
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|SET
condition|)
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set_src
argument_list|)
expr_stmt|;
else|else
name|set_src
operator|=
name|NULL_RTX
expr_stmt|;
block|}
block|}
if|if
condition|(
name|set_src
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
name|old_label
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
name|old_label
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check to see if new bb for jumping to that dest has 		 already been created; if so, use it; if not, create 		 a new one.  */
name|new_bb
operator|=
name|find_jump_block
argument_list|(
name|crossing_edge
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bb
condition|)
name|new_label
operator|=
name|block_label
argument_list|(
name|new_bb
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create new basic block to be dest for 		     conditional jump.  */
name|new_bb
operator|=
name|create_basic_block
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|aux
operator|=
name|last_bb
operator|->
name|aux
expr_stmt|;
name|last_bb
operator|->
name|aux
operator|=
name|new_bb
expr_stmt|;
name|prev_bb
operator|=
name|last_bb
expr_stmt|;
name|last_bb
operator|=
name|new_bb
expr_stmt|;
comment|/* Update register liveness information.  */
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|prev_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|prev_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
comment|/* Put appropriate instructions in new bb.  */
name|new_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_before
argument_list|(
name|new_label
argument_list|,
name|BB_HEAD
argument_list|(
name|new_bb
argument_list|)
argument_list|)
expr_stmt|;
name|BB_HEAD
argument_list|(
name|new_bb
argument_list|)
operator|=
name|new_label
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|old_label
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|old_label
operator|=
name|JUMP_LABEL
argument_list|(
name|old_jump
argument_list|)
expr_stmt|;
name|new_jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|old_label
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|new_bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|HAVE_return
operator|&&
name|GET_CODE
argument_list|(
name|old_label
argument_list|)
operator|==
name|RETURN
argument_list|)
expr_stmt|;
name|new_jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_return
argument_list|()
argument_list|,
name|BB_END
argument_list|(
name|new_bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|new_jump
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
operator|=
name|old_label
expr_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|footer
operator|=
name|unlink_insn_chain
argument_list|(
name|barrier
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
comment|/* Make sure new bb is in same partition as source 		     of conditional branch.  */
name|BB_COPY_PARTITION
argument_list|(
name|new_bb
argument_list|,
name|cur_bb
argument_list|)
expr_stmt|;
block|}
comment|/* Make old jump branch to new bb.  */
name|redirect_jump
argument_list|(
name|old_jump
argument_list|,
name|new_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove crossing_edge as predecessor of 'dest'.  */
name|dest
operator|=
name|crossing_edge
operator|->
name|dest
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|crossing_edge
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
comment|/* Make a new edge from new_bb to old dest; new edge 		 will be a successor for new_bb and a predecessor 		 for 'dest'.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|new_bb
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
name|new_edge
operator|=
name|make_edge
argument_list|(
name|new_bb
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|new_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|new_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crossing_edge
operator|->
name|flags
operator|&=
operator|~
name|EDGE_CROSSING
expr_stmt|;
name|new_edge
operator|->
name|flags
operator||=
name|EDGE_CROSSING
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Find any unconditional branches that cross between hot and cold    sections.  Convert them into indirect jumps instead.  */
end_comment

begin_function
specifier|static
name|void
name|fix_crossing_unconditional_branches
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|cur_bb
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|label_addr
decl_stmt|;
name|rtx
name|indirect_jump_sequence
decl_stmt|;
name|rtx
name|jump_insn
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|new_reg
decl_stmt|;
name|rtx
name|cur_insn
decl_stmt|;
name|edge
name|succ
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|cur_bb
argument_list|)
block|{
name|last_insn
operator|=
name|BB_END
argument_list|(
name|cur_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|cur_bb
operator|->
name|succs
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
name|succ
operator|=
name|EDGE_SUCC
argument_list|(
name|cur_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see if bb ends in a crossing (unconditional) jump.  At 	 this point, no crossing jumps should be conditional.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|last_insn
argument_list|)
operator|&&
operator|(
name|succ
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
condition|)
block|{
name|rtx
name|label2
decl_stmt|,
name|table
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the jump is not already an indirect or table jump.  */
if|if
condition|(
operator|!
name|computed_jump_p
argument_list|(
name|last_insn
argument_list|)
operator|&&
operator|!
name|tablejump_p
argument_list|(
name|last_insn
argument_list|,
operator|&
name|label2
argument_list|,
operator|&
name|table
argument_list|)
condition|)
block|{
comment|/* We have found a "crossing" unconditional branch.  Now 		 we must convert it to an indirect jump.  First create 		 reference of label, as target for jump.  */
name|label
operator|=
name|JUMP_LABEL
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
name|label_addr
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|+=
literal|1
expr_stmt|;
comment|/* Get a register to use for the indirect jump.  */
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Generate indirect the jump sequence.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|new_reg
argument_list|,
name|label_addr
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|new_reg
argument_list|)
expr_stmt|;
name|indirect_jump_sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Make sure every instruction in the new jump sequence has 		 its basic block set to be cur_bb.  */
for|for
control|(
name|cur_insn
operator|=
name|indirect_jump_sequence
init|;
name|cur_insn
condition|;
name|cur_insn
operator|=
name|NEXT_INSN
argument_list|(
name|cur_insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BARRIER_P
argument_list|(
name|cur_insn
argument_list|)
condition|)
name|BLOCK_FOR_INSN
argument_list|(
name|cur_insn
argument_list|)
operator|=
name|cur_bb
expr_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|cur_insn
argument_list|)
condition|)
name|jump_insn
operator|=
name|cur_insn
expr_stmt|;
block|}
comment|/* Insert the new (indirect) jump sequence immediately before 		 the unconditional jump, then delete the unconditional jump.  */
name|emit_insn_before
argument_list|(
name|indirect_jump_sequence
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
comment|/* Make BB_END for cur_bb be the jump instruction (NOT the 		 barrier instruction at the end of the sequence...).  */
name|BB_END
argument_list|(
name|cur_bb
argument_list|)
operator|=
name|jump_insn
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add REG_CROSSING_JUMP note to all crossing jump insns.  */
end_comment

begin_function
specifier|static
name|void
name|add_reg_crossing_jump_notes
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CROSSING
operator|)
operator|&&
name|JUMP_P
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hot and cold basic blocks are partitioned and put in separate    sections of the .o file, to reduce paging and improve cache    performance (hopefully).  This can result in bits of code from the    same function being widely separated in the .o file.  However this    is not obvious to the current bb structure.  Therefore we must take    care to ensure that: 1). There are no fall_thru edges that cross    between sections; 2). For those architectures which have "short"    conditional branches, all conditional branches that attempt to    cross between sections are converted to unconditional branches;    and, 3). For those architectures which have "short" unconditional    branches, all unconditional branches that attempt to cross between    sections are converted to indirect jumps.     The code for fixing up fall_thru edges that cross between hot and    cold basic blocks does so by creating new basic blocks containing    unconditional branches to the appropriate label in the "other"    section.  The new basic block is then put in the same (hot or cold)    section as the original conditional branch, and the fall_thru edge    is modified to fall into the new basic block instead.  By adding    this level of indirection we end up with only unconditional branches    crossing between hot and cold sections.     Conditional branches are dealt with by adding a level of indirection.    A new basic block is added in the same (hot/cold) section as the    conditional branch, and the conditional branch is retargeted to the    new basic block.  The new basic block contains an unconditional branch    to the original target of the conditional branch (in the other section).     Unconditional branches are dealt with by converting them into    indirect jumps.  */
end_comment

begin_function
specifier|static
name|void
name|fix_edges_for_rarely_executed_code
parameter_list|(
name|edge
modifier|*
name|crossing_edges
parameter_list|,
name|int
name|n_crossing_edges
parameter_list|)
block|{
comment|/* Make sure the source of any crossing edge ends in a jump and the      destination of any crossing edge has a label.  */
name|add_labels_and_missing_jumps
argument_list|(
name|crossing_edges
argument_list|,
name|n_crossing_edges
argument_list|)
expr_stmt|;
comment|/* Convert all crossing fall_thru edges to non-crossing fall      thrus to unconditional jumps (that jump to the original fall      thru dest).  */
name|fix_up_fall_thru_edges
argument_list|()
expr_stmt|;
comment|/* If the architecture does not have conditional branches that can      span all of memory, convert crossing conditional branches into      crossing unconditional branches.  */
if|if
condition|(
operator|!
name|HAS_LONG_COND_BRANCH
condition|)
name|fix_crossing_conditional_branches
argument_list|()
expr_stmt|;
comment|/* If the architecture does not have unconditional branches that      can span all of memory, convert crossing unconditional branches      into indirect jumps.  Since adding an indirect jump also adds      a new register usage, update the register usage information as      well.  */
if|if
condition|(
operator|!
name|HAS_LONG_UNCOND_BRANCH
condition|)
block|{
name|fix_crossing_unconditional_branches
argument_list|()
expr_stmt|;
name|reg_scan
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|add_reg_crossing_jump_notes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify, in the basic block chain, that there is at most one switch    between hot/cold partitions. This is modelled on    rtl_verify_flow_info_1, but it cannot go inside that function    because this condition will not be true until after    reorder_basic_blocks is called.  */
end_comment

begin_function
specifier|static
name|void
name|verify_hot_cold_block_grouping
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|bool
name|switched_sections
init|=
name|false
decl_stmt|;
name|int
name|current_partition
init|=
literal|0
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
operator|!
name|current_partition
condition|)
name|current_partition
operator|=
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
operator|!=
name|current_partition
condition|)
block|{
if|if
condition|(
name|switched_sections
condition|)
block|{
name|error
argument_list|(
literal|"multiple hot/cold transitions found (bb %i)"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|switched_sections
operator|=
name|true
expr_stmt|;
name|current_partition
operator|=
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|gcc_assert
argument_list|(
operator|!
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reorder basic blocks.  The main entry point to this file.  FLAGS is    the set of flags to pass to cfg_layout_initialize().  */
end_comment

begin_function
name|void
name|reorder_basic_blocks
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|n_traces
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|trace
modifier|*
name|traces
decl_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|<=
name|NUM_FIXED_BLOCKS
operator|+
literal|1
condition|)
return|return;
if|if
condition|(
name|targetm
operator|.
name|cannot_modify_jumps_p
argument_list|()
condition|)
return|return;
name|cfg_layout_initialize
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|set_edge_can_fallthru_flag
argument_list|()
expr_stmt|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
comment|/* We are estimating the length of uncond jump insn only once since the code      for getting the insn length always returns the minimal length now.  */
if|if
condition|(
name|uncond_jump_length
operator|==
literal|0
condition|)
name|uncond_jump_length
operator|=
name|get_uncond_jump_length
argument_list|()
expr_stmt|;
comment|/* We need to know some information for each basic block.  */
name|array_size
operator|=
name|GET_ARRAY_SIZE
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|bbd
operator|=
name|XNEWVEC
argument_list|(
name|bbro_basic_block_data
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array_size
condition|;
name|i
operator|++
control|)
block|{
name|bbd
index|[
name|i
index|]
operator|.
name|start_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|in_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|end_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|traces
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|trace
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|n_traces
operator|=
literal|0
expr_stmt|;
name|find_traces
argument_list|(
operator|&
name|n_traces
argument_list|,
name|traces
argument_list|)
expr_stmt|;
name|connect_traces
argument_list|(
name|n_traces
argument_list|,
name|traces
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|traces
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|bbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_flow_info
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
name|verify_hot_cold_block_grouping
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine which partition the first basic block in the function    belongs to, then find the first basic block in the current function    that belongs to a different section, and insert a    NOTE_INSN_SWITCH_TEXT_SECTIONS note immediately before it in the    instruction stream.  When writing out the assembly code,    encountering this note will make the compiler switch between the    hot and cold text sections.  */
end_comment

begin_function
specifier|static
name|void
name|insert_section_boundary_note
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|new_note
decl_stmt|;
name|int
name|first_partition
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
operator|!
name|first_partition
condition|)
name|first_partition
operator|=
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
operator|!=
name|first_partition
condition|)
block|{
name|new_note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_SWITCH_TEXT_SECTIONS
argument_list|,
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Duplicate the blocks containing computed gotos.  This basically unfactors    computed gotos that were factored early on in the compilation process to    speed up edge based data flow.  We used to not unfactoring them again,    which can seriously pessimize code with many computed jumps in the source    code, such as interpreters.  See e.g. PR15242.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_duplicate_computed_gotos
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_expensive_optimizations
operator|&&
operator|!
name|optimize_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|duplicate_computed_gotos
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|new_bb
decl_stmt|;
name|bitmap
name|candidates
decl_stmt|;
name|int
name|max_size
decl_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|<=
name|NUM_FIXED_BLOCKS
operator|+
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|targetm
operator|.
name|cannot_modify_jumps_p
argument_list|()
condition|)
return|return
literal|0
return|;
name|cfg_layout_initialize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* We are estimating the length of uncond jump insn only once      since the code for getting the insn length always returns      the minimal length now.  */
if|if
condition|(
name|uncond_jump_length
operator|==
literal|0
condition|)
name|uncond_jump_length
operator|=
name|get_uncond_jump_length
argument_list|()
expr_stmt|;
name|max_size
operator|=
name|uncond_jump_length
operator|*
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_GOTO_DUPLICATION_INSNS
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Look for blocks that end in a computed jump, and see if such blocks      are suitable for unfactoring.  If a block is a candidate for unfactoring,      mark it in the candidates.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|size
decl_stmt|,
name|all_flags
decl_stmt|;
comment|/* Build the reorder chain for the original order of blocks.  */
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|bb
operator|->
name|aux
operator|=
name|bb
operator|->
name|next_bb
expr_stmt|;
comment|/* Obviously the block has to end in a computed jump.  */
if|if
condition|(
operator|!
name|computed_jump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Only consider blocks that can be duplicated.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
operator|!
name|can_duplicate_block_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
comment|/* Make sure that the block is small enough.  */
name|size
operator|=
literal|0
expr_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|size
operator|+=
name|get_attr_min_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|max_size
condition|)
break|break;
block|}
if|if
condition|(
name|size
operator|>
name|max_size
condition|)
continue|continue;
comment|/* Final check: there must not be any incoming abnormal edges.  */
name|all_flags
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|all_flags
operator||=
name|e
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|all_flags
operator|&
name|EDGE_COMPLEX
condition|)
continue|continue;
name|bitmap_set_bit
argument_list|(
name|candidates
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Nothing to do if there is no computed jump here.  */
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|candidates
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Duplicate computed gotos.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
condition|)
continue|continue;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
comment|/* BB must have one outgoing edge.  That edge must not lead to 	 the exit block or the next block. 	 The destination must have more than one predecessor.  */
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|||
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|==
name|bb
operator|->
name|next_bb
operator|||
name|single_pred_p
argument_list|(
name|single_succ
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* The successor block has to be a duplication candidate.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|candidates
argument_list|,
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|new_bb
operator|=
name|duplicate_block
argument_list|(
name|single_succ
argument_list|(
name|bb
argument_list|)
argument_list|,
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|aux
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|new_bb
expr_stmt|;
name|new_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_duplicate_computed_gotos
init|=
block|{
literal|"compgotos"
block|,
comment|/* name */
name|gate_duplicate_computed_gotos
block|,
comment|/* gate */
name|duplicate_computed_gotos
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_REORDER_BLOCKS
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is the main 'entrance' for the optimization that    partitions hot and cold basic blocks into separate sections of the    .o file (to improve performance and cache locality).  Ideally it    would be called after all optimizations that rearrange the CFG have    been called.  However part of this optimization may introduce new    register usage, so it must be called before register allocation has    occurred.  This means that this optimization is actually called    well before the optimization that reorders basic blocks (see    function above).     This optimization checks the feedback information to determine    which basic blocks are hot/cold, updates flags on the basic blocks    to indicate which section they belong in.  This information is    later used for writing out sections in the .o file.  Because hot    and cold sections can be arbitrarily large (within the bounds of    memory), far beyond the size of a single function, it is necessary    to fix up all edges that cross section boundaries, to make sure the    instructions used can actually span the required distance.  The    fixes are described below.     Fall-through edges must be changed into jumps; it is not safe or    legal to fall through across a section boundary.  Whenever a    fall-through edge crossing a section boundary is encountered, a new    basic block is inserted (in the same section as the fall-through    source), and the fall through edge is redirected to the new basic    block.  The new basic block contains an unconditional jump to the    original fall-through target.  (If the unconditional jump is    insufficient to cross section boundaries, that is dealt with a    little later, see below).     In order to deal with architectures that have short conditional    branches (which cannot span all of memory) we take any conditional    jump that attempts to cross a section boundary and add a level of    indirection: it becomes a conditional jump to a new basic block, in    the same section.  The new basic block contains an unconditional    jump to the original target, in the other section.     For those architectures whose unconditional branch is also    incapable of reaching all of memory, those unconditional jumps are    converted into indirect jumps, through a register.     IMPORTANT NOTE: This optimization causes some messy interactions    with the cfg cleanup optimizations; those optimizations want to    merge blocks wherever possible, and to collapse indirect jump    sequences (change "A jumps to B jumps to C" directly into "A jumps    to C").  Those optimizations can undo the jump fixes that    partitioning is required to make (see above), in order to ensure    that jumps attempting to cross section boundaries are really able    to cover whatever distance the jump requires (on many architectures    conditional or unconditional jumps are not able to reach all of    memory).  Therefore tests have to be inserted into each such    optimization to make sure that it does not undo stuff necessary to    cross partition boundaries.  This would be much less of a problem    if we could perform this optimization later in the compilation, but    unfortunately the fact that we may need to create indirect jumps    (through registers) requires that this optimization be performed    before register allocation.  */
end_comment

begin_function
specifier|static
name|void
name|partition_hot_cold_basic_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|cur_bb
decl_stmt|;
name|edge
modifier|*
name|crossing_edges
decl_stmt|;
name|int
name|n_crossing_edges
decl_stmt|;
name|int
name|max_edges
init|=
literal|2
operator|*
name|last_basic_block
decl_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|<=
name|NUM_FIXED_BLOCKS
operator|+
literal|1
condition|)
return|return;
name|crossing_edges
operator|=
name|XCNEWVEC
argument_list|(
name|edge
argument_list|,
name|max_edges
argument_list|)
expr_stmt|;
name|cfg_layout_initialize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|cur_bb
argument_list|)
if|if
condition|(
name|cur_bb
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
operator|&&
name|cur_bb
operator|->
name|next_bb
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
condition|)
name|cur_bb
operator|->
name|aux
operator|=
name|cur_bb
operator|->
name|next_bb
expr_stmt|;
name|find_rarely_executed_basic_blocks_and_crossing_edges
argument_list|(
name|crossing_edges
argument_list|,
operator|&
name|n_crossing_edges
argument_list|,
operator|&
name|max_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_crossing_edges
operator|>
literal|0
condition|)
name|fix_edges_for_rarely_executed_code
argument_list|(
name|crossing_edges
argument_list|,
name|n_crossing_edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|crossing_edges
argument_list|)
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_reorder_blocks
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reorder basic blocks.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_reorder_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|changed
decl_stmt|;
name|unsigned
name|int
name|liveness_flags
decl_stmt|;
comment|/* Last attempt to optimize CFG, as scheduling, peepholing and insn      splitting possibly introduced more crossjumping opportunities.  */
name|liveness_flags
operator|=
operator|(
operator|!
name|HAVE_conditional_execution
condition|?
name|CLEANUP_UPDATE_LIFE
else|:
literal|0
operator|)
expr_stmt|;
name|changed
operator|=
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|liveness_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_sched2_use_traces
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_TRACER
argument_list|)
expr_stmt|;
name|tracer
argument_list|(
name|liveness_flags
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TRACER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_reorder_blocks
operator|||
name|flag_reorder_blocks_and_partition
condition|)
name|reorder_basic_blocks
argument_list|(
name|liveness_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks
operator|||
name|flag_reorder_blocks_and_partition
operator|||
operator|(
name|flag_sched2_use_traces
operator|&&
name|flag_schedule_insns_after_reload
operator|)
condition|)
name|changed
operator||=
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|liveness_flags
argument_list|)
expr_stmt|;
comment|/* On conditional execution targets we can not update the life cheaply, so      we deffer the updating to after both cleanups.  This may lose some cases      but should not be terribly bad.  */
if|if
condition|(
name|changed
operator|&&
name|HAVE_conditional_execution
condition|)
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
comment|/* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */
name|insert_section_boundary_note
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_reorder_blocks
init|=
block|{
literal|"bbro"
block|,
comment|/* name */
name|gate_handle_reorder_blocks
block|,
comment|/* gate */
name|rest_of_handle_reorder_blocks
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_REORDER_BLOCKS
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'B'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|gate_handle_partition_blocks
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The optimization to partition hot/cold basic blocks into separate      sections of the .o file does not work well with linkonce or with      user defined section attributes.  Don't call it if either case      arises.  */
return|return
operator|(
name|flag_reorder_blocks_and_partition
operator|&&
operator|!
name|DECL_ONE_ONLY
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|user_defined_section_attribute
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Partition hot and cold basic blocks.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_partition_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|partition_hot_cold_basic_blocks
argument_list|()
expr_stmt|;
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_LOG_LINKS
operator||
name|PROP_REG_INFO
operator||
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_partition_blocks
init|=
block|{
literal|"bbpart"
block|,
comment|/* name */
name|gate_handle_partition_blocks
block|,
comment|/* gate */
name|rest_of_handle_partition_blocks
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_REORDER_BLOCKS
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

